# Comparing `tmp/argos_toolkit-0.1.3.post3.tar.gz` & `tmp/argos_toolkit-0.2.0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "C:\Users\raysu\Documents\src\argos\dist\.tmp-u35v2y7v\argos_toolkit-0.1.3.post3.tar", last modified: Fri Nov 25 10:01:46 2022, max compression
+gzip compressed data, was "argos_toolkit-0.2.0.tar", last modified: Fri May 17 13:49:05 2024, max compression
```

## Comparing `argos_toolkit-0.1.3.post3.tar` & `argos_toolkit-0.2.0.tar`

### file list

```diff
@@ -1,122 +1,131 @@
-drwxrwxrwx   0        0        0        0 2022-11-25 10:01:46.000000 argos_toolkit-0.1.3.post3/
--rw-rw-rw-   0        0        0     1473 2021-03-17 23:19:09.000000 argos_toolkit-0.1.3.post3/LICENSE.txt
--rw-rw-rw-   0        0        0      114 2021-10-20 15:49:49.000000 argos_toolkit-0.1.3.post3/MANIFEST.in
--rw-rw-rw-   0        0        0    27688 2022-11-25 10:01:46.000000 argos_toolkit-0.1.3.post3/PKG-INFO
--rw-rw-rw-   0        0        0    26852 2022-01-25 07:40:03.000000 argos_toolkit-0.1.3.post3/README.md
-drwxrwxrwx   0        0        0        0 2022-11-25 10:01:46.000000 argos_toolkit-0.1.3.post3/argos/
--rw-rw-rw-   0        0        0      145 2022-11-25 09:34:45.000000 argos_toolkit-0.1.3.post3/argos/__init__.py
-drwxrwxrwx   0        0        0        0 2022-11-25 10:01:46.000000 argos_toolkit-0.1.3.post3/argos/_stylesheets/
--rw-rw-rw-   0        0        0    19735 2021-10-19 06:19:27.000000 argos_toolkit-0.1.3.post3/argos/_stylesheets/breeze.qrc
-drwxrwxrwx   0        0        0        0 2022-11-25 10:01:46.000000 argos_toolkit-0.1.3.post3/argos/_stylesheets/dark/
--rw-rw-rw-   0        0        0    46740 2021-10-19 06:19:27.000000 argos_toolkit-0.1.3.post3/argos/_stylesheets/dark/stylesheet.qss
-drwxrwxrwx   0        0        0        0 2022-11-25 10:01:46.000000 argos_toolkit-0.1.3.post3/argos/_stylesheets/dark-green/
--rw-rw-rw-   0        0        0    47414 2021-10-19 06:19:27.000000 argos_toolkit-0.1.3.post3/argos/_stylesheets/dark-green/stylesheet.qss
-drwxrwxrwx   0        0        0        0 2022-11-25 10:01:46.000000 argos_toolkit-0.1.3.post3/argos/_stylesheets/dark-purple/
--rw-rw-rw-   0        0        0    47538 2021-10-19 06:19:27.000000 argos_toolkit-0.1.3.post3/argos/_stylesheets/dark-purple/stylesheet.qss
-drwxrwxrwx   0        0        0        0 2022-11-25 10:01:46.000000 argos_toolkit-0.1.3.post3/argos/_stylesheets/light/
--rw-rw-rw-   0        0        0    47530 2021-10-19 06:19:27.000000 argos_toolkit-0.1.3.post3/argos/_stylesheets/light/stylesheet.qss
-drwxrwxrwx   0        0        0        0 2022-11-25 10:01:46.000000 argos_toolkit-0.1.3.post3/argos/_stylesheets/light-green/
--rw-rw-rw-   0        0        0    48166 2021-10-19 06:19:27.000000 argos_toolkit-0.1.3.post3/argos/_stylesheets/light-green/stylesheet.qss
-drwxrwxrwx   0        0        0        0 2022-11-25 10:01:46.000000 argos_toolkit-0.1.3.post3/argos/_stylesheets/light-purple/
--rw-rw-rw-   0        0        0    48328 2021-10-19 06:19:27.000000 argos_toolkit-0.1.3.post3/argos/_stylesheets/light-purple/stylesheet.qss
--rw-rw-rw-   0        0        0    58211 2021-08-05 05:19:58.000000 argos_toolkit-0.1.3.post3/argos/annotate.py
--rw-rw-rw-   0        0        0     2351 2021-05-04 13:00:45.000000 argos_toolkit-0.1.3.post3/argos/batch_motion_track.py
--rw-rw-rw-   0        0        0     8465 2020-07-15 23:04:19.000000 argos_toolkit-0.1.3.post3/argos/batchtrack_queue.py
--rw-rw-rw-   0        0        0   296717 2021-07-26 14:46:01.000000 argos_toolkit-0.1.3.post3/argos/breeze_resources.py
--rw-rw-rw-   0        0        0    24292 2021-08-15 15:49:50.000000 argos_toolkit-0.1.3.post3/argos/capture.py
--rw-rw-rw-   0        0        0    24260 2021-08-15 15:23:45.000000 argos_toolkit-0.1.3.post3/argos/capture.updated.py
--rw-rw-rw-   0        0        0     4710 2021-02-05 17:14:22.000000 argos_toolkit-0.1.3.post3/argos/caputil.py
--rw-rw-rw-   0        0        0   677747 2022-11-25 10:01:42.000000 argos_toolkit-0.1.3.post3/argos/ccapture.c
--rw-rw-rw-   0        0        0    10780 2021-08-15 15:49:39.000000 argos_toolkit-0.1.3.post3/argos/ccapture.pyx
--rw-rw-rw-   0        0        0    10757 2021-08-15 15:22:25.000000 argos_toolkit-0.1.3.post3/argos/ccapture.updated.pyx
--rw-rw-rw-   0        0        0     6362 2021-10-20 16:12:37.000000 argos_toolkit-0.1.3.post3/argos/constants.py
--rw-rw-rw-   0        0        0    14627 2022-11-25 09:29:13.000000 argos_toolkit-0.1.3.post3/argos/csrtracker.py
--rw-rw-rw-   0        0        0   434565 2022-11-25 10:01:43.000000 argos_toolkit-0.1.3.post3/argos/cutility.c
--rw-rw-rw-   0        0        0     8893 2022-03-03 04:56:52.000000 argos_toolkit-0.1.3.post3/argos/cutility.pyx
--rw-rw-rw-   0        0        0     4713 2021-08-03 06:59:46.000000 argos_toolkit-0.1.3.post3/argos/extract_frames.py
--rw-rw-rw-   0        0        0    40103 2022-11-18 11:18:50.000000 argos_toolkit-0.1.3.post3/argos/frameview.py
--rw-rw-rw-   0        0        0     4348 2022-03-02 15:20:58.000000 argos_toolkit-0.1.3.post3/argos/limitswidget.py
--rw-rw-rw-   0        0        0    19616 2021-07-30 13:35:24.000000 argos_toolkit-0.1.3.post3/argos/plot_tracks.py
--rw-rw-rw-   0        0        0    23867 2021-07-30 13:34:50.000000 argos_toolkit-0.1.3.post3/argos/plotutil.py
--rw-rw-rw-   0        0        0   128478 2022-11-25 08:25:32.000000 argos_toolkit-0.1.3.post3/argos/review.py
--rw-rw-rw-   0        0        0    12163 2021-08-04 15:47:43.000000 argos_toolkit-0.1.3.post3/argos/segment.py
--rw-rw-rw-   0        0        0    33689 2021-08-05 05:19:08.000000 argos_toolkit-0.1.3.post3/argos/segwidget.py
--rw-rw-rw-   0        0        0     7839 2021-01-12 05:46:51.000000 argos_toolkit-0.1.3.post3/argos/test_ccap.py
--rw-rw-rw-   0        0        0    17459 2020-06-25 18:02:07.000000 argos_toolkit-0.1.3.post3/argos/test_tracker.py
--rw-rw-rw-   0        0        0    24068 2022-11-25 08:25:32.000000 argos_toolkit-0.1.3.post3/argos/utility.py
--rw-rw-rw-   0        0        0     7617 2022-11-25 09:29:12.000000 argos_toolkit-0.1.3.post3/argos/vreader.py
--rw-rw-rw-   0        0        0    20365 2022-11-25 08:25:32.000000 argos_toolkit-0.1.3.post3/argos/vwidget.py
--rw-rw-rw-   0        0        0     5650 2020-11-28 21:16:51.000000 argos_toolkit-0.1.3.post3/argos/writer.py
--rw-rw-rw-   0        0        0    18967 2021-11-18 19:10:24.000000 argos_toolkit-0.1.3.post3/argos/yolactwidget.py
-drwxrwxrwx   0        0        0        0 2022-11-25 10:01:46.000000 argos_toolkit-0.1.3.post3/argos_toolkit.egg-info/
--rw-rw-rw-   0        0        0    27688 2022-11-25 10:01:46.000000 argos_toolkit-0.1.3.post3/argos_toolkit.egg-info/PKG-INFO
--rw-rw-rw-   0        0        0     2559 2022-11-25 10:01:46.000000 argos_toolkit-0.1.3.post3/argos_toolkit.egg-info/SOURCES.txt
--rw-rw-rw-   0        0        0        1 2022-11-25 10:01:46.000000 argos_toolkit-0.1.3.post3/argos_toolkit.egg-info/dependency_links.txt
--rw-rw-rw-   0        0        0      127 2022-11-25 10:01:46.000000 argos_toolkit-0.1.3.post3/argos_toolkit.egg-info/requires.txt
--rw-rw-rw-   0        0        0       13 2022-11-25 10:01:46.000000 argos_toolkit-0.1.3.post3/argos_toolkit.egg-info/top_level.txt
-drwxrwxrwx   0        0        0        0 2022-11-25 10:01:46.000000 argos_toolkit-0.1.3.post3/config/
-drwxrwxrwx   0        0        0        0 2022-11-25 10:01:46.000000 argos_toolkit-0.1.3.post3/config/yolact_base/
--rw-rw-rw-   0        0        0     2373 2020-10-13 22:02:09.000000 argos_toolkit-0.1.3.post3/config/yolact_base/yolact_base_config.yml
--rw-rw-rw-   0        0        0      359 2021-08-30 04:55:44.000000 argos_toolkit-0.1.3.post3/pyproject.toml
--rw-rw-rw-   0        0        0       42 2022-11-25 10:01:46.000000 argos_toolkit-0.1.3.post3/setup.cfg
--rw-rw-rw-   0        0        0     3643 2022-01-25 07:35:07.000000 argos_toolkit-0.1.3.post3/setup.py
-drwxrwxrwx   0        0        0        0 2022-11-25 10:01:46.000000 argos_toolkit-0.1.3.post3/yolact/
--rw-rw-rw-   0        0        0      181 2020-07-01 21:17:11.000000 argos_toolkit-0.1.3.post3/yolact/__init__.py
--rw-rw-rw-   0        0        0    17286 2020-02-26 18:43:20.000000 argos_toolkit-0.1.3.post3/yolact/backbone.py
-drwxrwxrwx   0        0        0        0 2022-11-25 10:01:46.000000 argos_toolkit-0.1.3.post3/yolact/data/
--rw-rw-rw-   0        0        0       86 2020-02-26 18:43:20.000000 argos_toolkit-0.1.3.post3/yolact/data/__init__.py
--rw-rw-rw-   0        0        0    10858 2020-02-26 18:43:20.000000 argos_toolkit-0.1.3.post3/yolact/data/coco.py
--rw-rw-rw-   0        0        0    32858 2020-07-01 22:24:18.000000 argos_toolkit-0.1.3.post3/yolact/data/config.py
--rw-rw-rw-   0        0        0    31798 2020-07-01 19:48:55.000000 argos_toolkit-0.1.3.post3/yolact/data/config_20200305.py
-drwxrwxrwx   0        0        0        0 2022-11-25 10:01:46.000000 argos_toolkit-0.1.3.post3/yolact/data/scripts/
--rw-rw-rw-   0        0        0      115 2020-06-04 16:45:44.000000 argos_toolkit-0.1.3.post3/yolact/data/scripts/__init__.py
--rw-rw-rw-   0        0        0     2409 2020-02-26 18:43:20.000000 argos_toolkit-0.1.3.post3/yolact/data/scripts/mix_sets.py
--rw-rw-rw-   0        0        0    47785 2020-07-01 20:08:20.000000 argos_toolkit-0.1.3.post3/yolact/evaluate.py
-drwxrwxrwx   0        0        0        0 2022-11-25 10:01:46.000000 argos_toolkit-0.1.3.post3/yolact/external/
-drwxrwxrwx   0        0        0        0 2022-11-25 10:01:46.000000 argos_toolkit-0.1.3.post3/yolact/external/DCNv2/
--rw-rw-rw-   0        0        0        0 2020-02-26 18:43:20.000000 argos_toolkit-0.1.3.post3/yolact/external/DCNv2/__init__.py
--rw-rw-rw-   0        0        0    12081 2020-02-26 18:43:20.000000 argos_toolkit-0.1.3.post3/yolact/external/DCNv2/dcn_v2.py
--rw-rw-rw-   0        0        0     2107 2021-08-17 12:58:49.000000 argos_toolkit-0.1.3.post3/yolact/external/DCNv2/setup.py
--rw-rw-rw-   0        0        0     8506 2020-02-26 18:43:20.000000 argos_toolkit-0.1.3.post3/yolact/external/DCNv2/test.py
--rw-rw-rw-   0        0        0      115 2020-06-04 16:45:44.000000 argos_toolkit-0.1.3.post3/yolact/external/__init__.py
-drwxrwxrwx   0        0        0        0 2022-11-25 10:01:46.000000 argos_toolkit-0.1.3.post3/yolact/layers/
--rw-rw-rw-   0        0        0       48 2020-02-26 18:43:20.000000 argos_toolkit-0.1.3.post3/yolact/layers/__init__.py
--rw-rw-rw-   0        0        0    15009 2020-07-02 00:51:43.000000 argos_toolkit-0.1.3.post3/yolact/layers/box_utils.py
-drwxrwxrwx   0        0        0        0 2022-11-25 10:01:46.000000 argos_toolkit-0.1.3.post3/yolact/layers/functions/
--rw-rw-rw-   0        0        0       53 2020-02-26 18:43:20.000000 argos_toolkit-0.1.3.post3/yolact/layers/functions/__init__.py
--rw-rw-rw-   0        0        0     8915 2020-07-15 03:00:36.000000 argos_toolkit-0.1.3.post3/yolact/layers/functions/detection.py
--rw-rw-rw-   0        0        0      412 2020-02-26 18:43:20.000000 argos_toolkit-0.1.3.post3/yolact/layers/interpolate.py
-drwxrwxrwx   0        0        0        0 2022-11-25 10:01:46.000000 argos_toolkit-0.1.3.post3/yolact/layers/modules/
--rw-rw-rw-   0        0        0       68 2020-02-26 18:43:20.000000 argos_toolkit-0.1.3.post3/yolact/layers/modules/__init__.py
--rw-rw-rw-   0        0        0    31356 2020-07-02 00:56:48.000000 argos_toolkit-0.1.3.post3/yolact/layers/modules/multibox_loss.py
--rw-rw-rw-   0        0        0     6921 2020-07-02 00:54:25.000000 argos_toolkit-0.1.3.post3/yolact/layers/output_utils.py
--rw-rw-rw-   0        0        0     1465 2020-07-06 21:18:48.000000 argos_toolkit-0.1.3.post3/yolact/run_coco_eval.py
-drwxrwxrwx   0        0        0        0 2022-11-25 10:01:46.000000 argos_toolkit-0.1.3.post3/yolact/scripts/
--rw-rw-rw-   0        0        0      115 2020-06-04 16:45:44.000000 argos_toolkit-0.1.3.post3/yolact/scripts/__init__.py
--rw-rw-rw-   0        0        0     3986 2020-02-26 18:43:20.000000 argos_toolkit-0.1.3.post3/yolact/scripts/augment_bbox.py
--rw-rw-rw-   0        0        0     5968 2020-02-26 18:43:20.000000 argos_toolkit-0.1.3.post3/yolact/scripts/bbox_recall.py
--rw-rw-rw-   0        0        0     1758 2020-02-26 18:43:20.000000 argos_toolkit-0.1.3.post3/yolact/scripts/cluster_bbox_sizes.py
--rw-rw-rw-   0        0        0     2618 2020-02-26 18:43:20.000000 argos_toolkit-0.1.3.post3/yolact/scripts/compute_masks.py
--rw-rw-rw-   0        0        0     1466 2020-02-26 18:43:20.000000 argos_toolkit-0.1.3.post3/yolact/scripts/convert_darknet.py
--rw-rw-rw-   0        0        0     2160 2020-02-26 18:43:20.000000 argos_toolkit-0.1.3.post3/yolact/scripts/convert_sbd.py
--rw-rw-rw-   0        0        0     5041 2020-02-26 18:43:20.000000 argos_toolkit-0.1.3.post3/yolact/scripts/make_grid.py
--rw-rw-rw-   0        0        0     6751 2020-02-26 18:43:20.000000 argos_toolkit-0.1.3.post3/yolact/scripts/optimize_bboxes.py
--rw-rw-rw-   0        0        0     1166 2020-02-26 18:43:20.000000 argos_toolkit-0.1.3.post3/yolact/scripts/parse_eval.py
--rw-rw-rw-   0        0        0     1932 2020-02-26 18:43:20.000000 argos_toolkit-0.1.3.post3/yolact/scripts/plot_loss.py
--rw-rw-rw-   0        0        0      797 2020-02-26 18:43:20.000000 argos_toolkit-0.1.3.post3/yolact/scripts/save_bboxes.py
--rw-rw-rw-   0        0        0      456 2020-02-26 18:43:20.000000 argos_toolkit-0.1.3.post3/yolact/scripts/unpack_statedict.py
--rw-rw-rw-   0        0        0    24460 2021-08-18 16:56:49.000000 argos_toolkit-0.1.3.post3/yolact/train.py
-drwxrwxrwx   0        0        0        0 2022-11-25 10:01:46.000000 argos_toolkit-0.1.3.post3/yolact/utils/
--rw-rw-rw-   0        0        0       42 2020-02-26 18:43:20.000000 argos_toolkit-0.1.3.post3/yolact/utils/__init__.py
--rw-rw-rw-   0        0        0    24174 2021-08-17 16:10:46.000000 argos_toolkit-0.1.3.post3/yolact/utils/augmentations.py
--rw-rw-rw-   0        0        0   306307 2022-11-25 10:01:44.000000 argos_toolkit-0.1.3.post3/yolact/utils/cython_nms.c
--rw-rw-rw-   0        0        0     2457 2020-02-26 18:43:20.000000 argos_toolkit-0.1.3.post3/yolact/utils/cython_nms.pyx
--rw-rw-rw-   0        0        0     6511 2020-07-02 00:54:59.000000 argos_toolkit-0.1.3.post3/yolact/utils/functions.py
--rw-rw-rw-   0        0        0    15327 2020-02-26 18:43:20.000000 argos_toolkit-0.1.3.post3/yolact/utils/logger.py
--rw-rw-rw-   0        0        0     2402 2020-02-26 18:43:20.000000 argos_toolkit-0.1.3.post3/yolact/utils/nvinfo.py
--rw-rw-rw-   0        0        0     3508 2020-02-26 18:43:20.000000 argos_toolkit-0.1.3.post3/yolact/utils/timer.py
-drwxrwxrwx   0        0        0        0 2022-11-25 10:01:46.000000 argos_toolkit-0.1.3.post3/yolact/web/
--rw-rw-rw-   0        0        0      115 2020-06-04 16:45:44.000000 argos_toolkit-0.1.3.post3/yolact/web/__init__.py
--rw-rw-rw-   0        0        0     1593 2020-02-26 18:43:20.000000 argos_toolkit-0.1.3.post3/yolact/web/server.py
--rw-rw-rw-   0        0        0    32500 2020-07-06 21:18:48.000000 argos_toolkit-0.1.3.post3/yolact/yolact.py
--rw-rw-rw-   0        0        0    31786 2021-08-27 09:49:29.000000 argos_toolkit-0.1.3.post3/yolact/yolact_.py
+drwxrwxrwx   0        0        0        0 2024-05-17 13:49:05.212027 argos_toolkit-0.2.0/
+-rw-rw-rw-   0        0        0    35823 2021-03-17 13:31:55.000000 argos_toolkit-0.2.0/LICENSE
+-rw-rw-rw-   0        0        0     1473 2021-03-17 23:19:09.000000 argos_toolkit-0.2.0/LICENSE.txt
+-rw-rw-rw-   0        0        0      114 2021-10-20 15:49:49.000000 argos_toolkit-0.2.0/MANIFEST.in
+-rw-rw-rw-   0        0        0    27904 2024-05-17 13:49:05.211009 argos_toolkit-0.2.0/PKG-INFO
+-rw-rw-rw-   0        0        0    26649 2024-05-17 13:18:56.000000 argos_toolkit-0.2.0/README.md
+drwxrwxrwx   0        0        0        0 2024-05-17 13:49:05.136013 argos_toolkit-0.2.0/argos/
+-rw-rw-rw-   0        0        0      273 2024-05-17 13:08:21.000000 argos_toolkit-0.2.0/argos/__init__.py
+drwxrwxrwx   0        0        0        0 2024-05-17 13:49:05.137010 argos_toolkit-0.2.0/argos/_stylesheets/
+-rw-rw-rw-   0        0        0    19735 2021-10-19 06:19:27.000000 argos_toolkit-0.2.0/argos/_stylesheets/breeze.qrc
+drwxrwxrwx   0        0        0        0 2024-05-17 13:49:05.139015 argos_toolkit-0.2.0/argos/_stylesheets/dark/
+-rw-rw-rw-   0        0        0    46740 2021-10-19 06:19:27.000000 argos_toolkit-0.2.0/argos/_stylesheets/dark/stylesheet.qss
+drwxrwxrwx   0        0        0        0 2024-05-17 13:49:05.140013 argos_toolkit-0.2.0/argos/_stylesheets/dark-green/
+-rw-rw-rw-   0        0        0    47414 2021-10-19 06:19:27.000000 argos_toolkit-0.2.0/argos/_stylesheets/dark-green/stylesheet.qss
+drwxrwxrwx   0        0        0        0 2024-05-17 13:49:05.141012 argos_toolkit-0.2.0/argos/_stylesheets/dark-purple/
+-rw-rw-rw-   0        0        0    47538 2021-10-19 06:19:27.000000 argos_toolkit-0.2.0/argos/_stylesheets/dark-purple/stylesheet.qss
+drwxrwxrwx   0        0        0        0 2024-05-17 13:49:05.142012 argos_toolkit-0.2.0/argos/_stylesheets/light/
+-rw-rw-rw-   0        0        0    47530 2021-10-19 06:19:27.000000 argos_toolkit-0.2.0/argos/_stylesheets/light/stylesheet.qss
+drwxrwxrwx   0        0        0        0 2024-05-17 13:49:05.144014 argos_toolkit-0.2.0/argos/_stylesheets/light-green/
+-rw-rw-rw-   0        0        0    48166 2021-10-19 06:19:27.000000 argos_toolkit-0.2.0/argos/_stylesheets/light-green/stylesheet.qss
+drwxrwxrwx   0        0        0        0 2024-05-17 13:49:05.145011 argos_toolkit-0.2.0/argos/_stylesheets/light-purple/
+-rw-rw-rw-   0        0        0    48328 2021-10-19 06:19:27.000000 argos_toolkit-0.2.0/argos/_stylesheets/light-purple/stylesheet.qss
+-rw-rw-rw-   0        0        0    58202 2024-01-28 09:11:23.000000 argos_toolkit-0.2.0/argos/annotate.py
+-rw-rw-rw-   0        0        0     2351 2021-05-04 13:00:45.000000 argos_toolkit-0.2.0/argos/batch_motion_track.py
+-rw-rw-rw-   0        0        0    25857 2022-11-12 05:06:44.000000 argos_toolkit-0.2.0/argos/batchtrack.py
+-rw-rw-rw-   0        0        0     8465 2020-07-15 23:04:19.000000 argos_toolkit-0.2.0/argos/batchtrack_queue.py
+-rw-rw-rw-   0        0        0   296717 2021-07-26 14:46:01.000000 argos_toolkit-0.2.0/argos/breeze_resources.py
+-rw-rw-rw-   0        0        0    24292 2021-08-15 15:49:50.000000 argos_toolkit-0.2.0/argos/capture.py
+-rw-rw-rw-   0        0        0    24260 2021-08-15 15:23:45.000000 argos_toolkit-0.2.0/argos/capture.updated.py
+-rw-rw-rw-   0        0        0     4710 2021-02-05 17:14:22.000000 argos_toolkit-0.2.0/argos/caputil.py
+-rw-rw-rw-   0        0        0   839525 2024-05-17 13:49:03.000000 argos_toolkit-0.2.0/argos/ccapture.c
+-rw-rw-rw-   0        0        0    10781 2024-05-17 11:24:02.000000 argos_toolkit-0.2.0/argos/ccapture.pyx
+-rw-rw-rw-   0        0        0    10757 2021-08-15 15:22:25.000000 argos_toolkit-0.2.0/argos/ccapture.updated.pyx
+-rw-rw-rw-   0        0        0     6362 2021-10-20 16:12:37.000000 argos_toolkit-0.2.0/argos/constants.py
+-rw-rw-rw-   0        0        0     2968 2024-05-17 07:26:54.000000 argos_toolkit-0.2.0/argos/convert_dlc.py
+-rw-rw-rw-   0        0        0    14633 2022-12-05 11:21:24.000000 argos_toolkit-0.2.0/argos/csrtracker.py
+-rw-rw-rw-   0        0        0   628881 2024-05-17 13:49:03.000000 argos_toolkit-0.2.0/argos/cutility.c
+-rw-rw-rw-   0        0        0     8902 2024-05-17 11:22:58.000000 argos_toolkit-0.2.0/argos/cutility.pyx
+-rw-rw-rw-   0        0        0     4713 2021-08-03 06:59:46.000000 argos_toolkit-0.2.0/argos/extract_frames.py
+-rw-rw-rw-   0        0        0    40103 2022-11-18 11:18:50.000000 argos_toolkit-0.2.0/argos/frameview.py
+-rw-rw-rw-   0        0        0     4263 2024-05-17 13:39:50.000000 argos_toolkit-0.2.0/argos/limitswidget.py
+-rw-rw-rw-   0        0        0    19616 2021-07-30 13:35:24.000000 argos_toolkit-0.2.0/argos/plot_tracks.py
+-rw-rw-rw-   0        0        0    23867 2021-07-30 13:34:50.000000 argos_toolkit-0.2.0/argos/plotutil.py
+-rw-rw-rw-   0        0        0   109007 2024-05-17 07:26:54.000000 argos_toolkit-0.2.0/argos/review.py
+-rw-rw-rw-   0        0        0    12163 2021-08-04 15:47:43.000000 argos_toolkit-0.2.0/argos/segment.py
+-rw-rw-rw-   0        0        0    34223 2024-01-28 08:55:34.000000 argos_toolkit-0.2.0/argos/segwidget.py
+-rw-rw-rw-   0        0        0    10389 2021-03-16 19:39:19.000000 argos_toolkit-0.2.0/argos/sortracker.py
+-rw-rw-rw-   0        0        0     9399 2024-05-17 12:57:42.000000 argos_toolkit-0.2.0/argos/sortrackerwidget.py
+-rw-rw-rw-   0        0        0     7839 2021-01-12 05:46:51.000000 argos_toolkit-0.2.0/argos/test_ccap.py
+-rw-rw-rw-   0        0        0    17459 2020-06-25 18:02:07.000000 argos_toolkit-0.2.0/argos/test_tracker.py
+-rw-rw-rw-   0        0        0    17214 2024-05-17 12:57:33.000000 argos_toolkit-0.2.0/argos/track.py
+-rw-rw-rw-   0        0        0     5645 2022-12-05 11:20:51.000000 argos_toolkit-0.2.0/argos/tracklist.py
+-rw-rw-rw-   0        0        0    18224 2024-05-17 13:41:13.000000 argos_toolkit-0.2.0/argos/trackreader.py
+-rw-rw-rw-   0        0        0     6714 2022-12-05 11:20:51.000000 argos_toolkit-0.2.0/argos/trackview.py
+-rw-rw-rw-   0        0        0    24958 2024-01-28 08:55:25.000000 argos_toolkit-0.2.0/argos/utility.py
+-rw-rw-rw-   0        0        0     7617 2022-11-25 09:29:12.000000 argos_toolkit-0.2.0/argos/vreader.py
+-rw-rw-rw-   0        0        0    20515 2022-12-05 11:20:51.000000 argos_toolkit-0.2.0/argos/vwidget.py
+-rw-rw-rw-   0        0        0     5663 2024-05-17 13:46:49.000000 argos_toolkit-0.2.0/argos/writer.py
+-rw-rw-rw-   0        0        0    19303 2024-05-17 09:18:35.000000 argos_toolkit-0.2.0/argos/yolactwidget.py
+drwxrwxrwx   0        0        0        0 2024-05-17 13:49:05.210010 argos_toolkit-0.2.0/argos_toolkit.egg-info/
+-rw-rw-rw-   0        0        0    27904 2024-05-17 13:49:05.000000 argos_toolkit-0.2.0/argos_toolkit.egg-info/PKG-INFO
+-rw-rw-rw-   0        0        0     2728 2024-05-17 13:49:05.000000 argos_toolkit-0.2.0/argos_toolkit.egg-info/SOURCES.txt
+-rw-rw-rw-   0        0        0        1 2024-05-17 13:49:05.000000 argos_toolkit-0.2.0/argos_toolkit.egg-info/dependency_links.txt
+-rw-rw-rw-   0        0        0      138 2024-05-17 13:49:05.000000 argos_toolkit-0.2.0/argos_toolkit.egg-info/requires.txt
+-rw-rw-rw-   0        0        0       13 2024-05-17 13:49:05.000000 argos_toolkit-0.2.0/argos_toolkit.egg-info/top_level.txt
+drwxrwxrwx   0        0        0        0 2024-05-17 13:49:05.069019 argos_toolkit-0.2.0/config/
+drwxrwxrwx   0        0        0        0 2024-05-17 13:49:05.153013 argos_toolkit-0.2.0/config/yolact_base/
+-rw-rw-rw-   0        0        0     2373 2020-10-13 22:02:09.000000 argos_toolkit-0.2.0/config/yolact_base/yolact_base_config.yml
+-rw-rw-rw-   0        0        0      359 2021-08-30 04:55:44.000000 argos_toolkit-0.2.0/pyproject.toml
+-rw-rw-rw-   0        0        0       42 2024-05-17 13:49:05.213011 argos_toolkit-0.2.0/setup.cfg
+-rw-rw-rw-   0        0        0     3700 2024-05-17 13:11:38.000000 argos_toolkit-0.2.0/setup.py
+drwxrwxrwx   0        0        0        0 2024-05-17 13:49:05.161009 argos_toolkit-0.2.0/yolact/
+-rw-rw-rw-   0        0        0      181 2020-07-01 21:17:11.000000 argos_toolkit-0.2.0/yolact/__init__.py
+-rw-rw-rw-   0        0        0    17286 2020-02-26 18:43:20.000000 argos_toolkit-0.2.0/yolact/backbone.py
+drwxrwxrwx   0        0        0        0 2024-05-17 13:49:05.168011 argos_toolkit-0.2.0/yolact/data/
+-rw-rw-rw-   0        0        0       86 2020-02-26 18:43:20.000000 argos_toolkit-0.2.0/yolact/data/__init__.py
+-rw-rw-rw-   0        0        0    10858 2020-02-26 18:43:20.000000 argos_toolkit-0.2.0/yolact/data/coco.py
+-rw-rw-rw-   0        0        0    32858 2020-07-01 22:24:18.000000 argos_toolkit-0.2.0/yolact/data/config.py
+-rw-rw-rw-   0        0        0    31798 2020-07-01 19:48:55.000000 argos_toolkit-0.2.0/yolact/data/config_20200305.py
+drwxrwxrwx   0        0        0        0 2024-05-17 13:49:05.170009 argos_toolkit-0.2.0/yolact/data/scripts/
+-rw-rw-rw-   0        0        0      115 2020-06-04 16:45:44.000000 argos_toolkit-0.2.0/yolact/data/scripts/__init__.py
+-rw-rw-rw-   0        0        0     2409 2020-02-26 18:43:20.000000 argos_toolkit-0.2.0/yolact/data/scripts/mix_sets.py
+-rw-rw-rw-   0        0        0    54365 2024-02-10 09:12:39.000000 argos_toolkit-0.2.0/yolact/evaluate.py
+drwxrwxrwx   0        0        0        0 2024-05-17 13:49:05.171012 argos_toolkit-0.2.0/yolact/external/
+drwxrwxrwx   0        0        0        0 2024-05-17 13:49:05.175010 argos_toolkit-0.2.0/yolact/external/DCNv2/
+-rw-rw-rw-   0        0        0        0 2020-02-26 18:43:20.000000 argos_toolkit-0.2.0/yolact/external/DCNv2/__init__.py
+-rw-rw-rw-   0        0        0    12081 2020-02-26 18:43:20.000000 argos_toolkit-0.2.0/yolact/external/DCNv2/dcn_v2.py
+-rw-rw-rw-   0        0        0     2107 2021-08-17 12:58:49.000000 argos_toolkit-0.2.0/yolact/external/DCNv2/setup.py
+-rw-rw-rw-   0        0        0     8506 2020-02-26 18:43:20.000000 argos_toolkit-0.2.0/yolact/external/DCNv2/test.py
+-rw-rw-rw-   0        0        0      115 2020-06-04 16:45:44.000000 argos_toolkit-0.2.0/yolact/external/__init__.py
+drwxrwxrwx   0        0        0        0 2024-05-17 13:49:05.180014 argos_toolkit-0.2.0/yolact/layers/
+-rw-rw-rw-   0        0        0       48 2020-02-26 18:43:20.000000 argos_toolkit-0.2.0/yolact/layers/__init__.py
+-rw-rw-rw-   0        0        0    15009 2020-07-02 00:51:43.000000 argos_toolkit-0.2.0/yolact/layers/box_utils.py
+drwxrwxrwx   0        0        0        0 2024-05-17 13:49:05.182011 argos_toolkit-0.2.0/yolact/layers/functions/
+-rw-rw-rw-   0        0        0       53 2020-02-26 18:43:20.000000 argos_toolkit-0.2.0/yolact/layers/functions/__init__.py
+-rw-rw-rw-   0        0        0     9143 2024-05-17 12:39:57.000000 argos_toolkit-0.2.0/yolact/layers/functions/detection.py
+-rw-rw-rw-   0        0        0      412 2020-02-26 18:43:20.000000 argos_toolkit-0.2.0/yolact/layers/interpolate.py
+drwxrwxrwx   0        0        0        0 2024-05-17 13:49:05.185010 argos_toolkit-0.2.0/yolact/layers/modules/
+-rw-rw-rw-   0        0        0       68 2020-02-26 18:43:20.000000 argos_toolkit-0.2.0/yolact/layers/modules/__init__.py
+-rw-rw-rw-   0        0        0    31356 2020-07-02 00:56:48.000000 argos_toolkit-0.2.0/yolact/layers/modules/multibox_loss.py
+-rw-rw-rw-   0        0        0     7021 2024-02-10 09:11:03.000000 argos_toolkit-0.2.0/yolact/layers/output_utils.py
+-rw-rw-rw-   0        0        0     1465 2020-07-06 21:18:48.000000 argos_toolkit-0.2.0/yolact/run_coco_eval.py
+drwxrwxrwx   0        0        0        0 2024-05-17 13:49:05.198009 argos_toolkit-0.2.0/yolact/scripts/
+-rw-rw-rw-   0        0        0      115 2020-06-04 16:45:44.000000 argos_toolkit-0.2.0/yolact/scripts/__init__.py
+-rw-rw-rw-   0        0        0     3986 2020-02-26 18:43:20.000000 argos_toolkit-0.2.0/yolact/scripts/augment_bbox.py
+-rw-rw-rw-   0        0        0     5968 2020-02-26 18:43:20.000000 argos_toolkit-0.2.0/yolact/scripts/bbox_recall.py
+-rw-rw-rw-   0        0        0     1758 2020-02-26 18:43:20.000000 argos_toolkit-0.2.0/yolact/scripts/cluster_bbox_sizes.py
+-rw-rw-rw-   0        0        0     2618 2020-02-26 18:43:20.000000 argos_toolkit-0.2.0/yolact/scripts/compute_masks.py
+-rw-rw-rw-   0        0        0     1466 2020-02-26 18:43:20.000000 argos_toolkit-0.2.0/yolact/scripts/convert_darknet.py
+-rw-rw-rw-   0        0        0     2160 2020-02-26 18:43:20.000000 argos_toolkit-0.2.0/yolact/scripts/convert_sbd.py
+-rw-rw-rw-   0        0        0     5041 2020-02-26 18:43:20.000000 argos_toolkit-0.2.0/yolact/scripts/make_grid.py
+-rw-rw-rw-   0        0        0     6751 2020-02-26 18:43:20.000000 argos_toolkit-0.2.0/yolact/scripts/optimize_bboxes.py
+-rw-rw-rw-   0        0        0     1166 2020-02-26 18:43:20.000000 argos_toolkit-0.2.0/yolact/scripts/parse_eval.py
+-rw-rw-rw-   0        0        0     1932 2020-02-26 18:43:20.000000 argos_toolkit-0.2.0/yolact/scripts/plot_loss.py
+-rw-rw-rw-   0        0        0      797 2020-02-26 18:43:20.000000 argos_toolkit-0.2.0/yolact/scripts/save_bboxes.py
+-rw-rw-rw-   0        0        0      456 2020-02-26 18:43:20.000000 argos_toolkit-0.2.0/yolact/scripts/unpack_statedict.py
+-rw-rw-rw-   0        0        0    27093 2024-01-28 14:17:44.000000 argos_toolkit-0.2.0/yolact/train.py
+drwxrwxrwx   0        0        0        0 2024-05-17 13:49:05.207010 argos_toolkit-0.2.0/yolact/utils/
+-rw-rw-rw-   0        0        0       42 2020-02-26 18:43:20.000000 argos_toolkit-0.2.0/yolact/utils/__init__.py
+-rw-rw-rw-   0        0        0    24174 2021-08-17 16:10:46.000000 argos_toolkit-0.2.0/yolact/utils/augmentations.py
+-rw-rw-rw-   0        0        0   478155 2024-05-17 13:49:04.000000 argos_toolkit-0.2.0/yolact/utils/cython_nms.c
+-rw-rw-rw-   0        0        0     3246 2024-05-17 12:39:50.000000 argos_toolkit-0.2.0/yolact/utils/cython_nms.pyx
+-rw-rw-rw-   0        0        0     6511 2020-07-02 00:54:59.000000 argos_toolkit-0.2.0/yolact/utils/functions.py
+-rw-rw-rw-   0        0        0    15327 2020-02-26 18:43:20.000000 argos_toolkit-0.2.0/yolact/utils/logger.py
+-rw-rw-rw-   0        0        0     2402 2020-02-26 18:43:20.000000 argos_toolkit-0.2.0/yolact/utils/nvinfo.py
+-rw-rw-rw-   0        0        0     3508 2020-02-26 18:43:20.000000 argos_toolkit-0.2.0/yolact/utils/timer.py
+drwxrwxrwx   0        0        0        0 2024-05-17 13:49:05.209010 argos_toolkit-0.2.0/yolact/web/
+-rw-rw-rw-   0        0        0      115 2020-06-04 16:45:44.000000 argos_toolkit-0.2.0/yolact/web/__init__.py
+-rw-rw-rw-   0        0        0     1593 2020-02-26 18:43:20.000000 argos_toolkit-0.2.0/yolact/web/server.py
+-rw-rw-rw-   0        0        0    32912 2024-05-17 07:47:15.000000 argos_toolkit-0.2.0/yolact/yolact.py
+-rw-rw-rw-   0        0        0    34145 2024-02-09 12:09:45.000000 argos_toolkit-0.2.0/yolact/yolact_.py
```

### filetype from file(1)

```diff
@@ -1 +1 @@
-POSIX tar archive (GNU)
+POSIX tar archive
```

### Comparing `argos_toolkit-0.1.3.post3/LICENSE.txt` & `argos_toolkit-0.2.0/LICENSE.txt`

 * *Files identical despite different names*

### Comparing `argos_toolkit-0.1.3.post3/PKG-INFO` & `argos_toolkit-0.2.0/PKG-INFO`

 * *Files 4% similar despite different names*

```diff
@@ -1,44 +1,54 @@
 Metadata-Version: 2.1
 Name: argos_toolkit
-Version: 0.1.3.post3
+Version: 0.2.0
 Summary: Software tools to facilitate tracking multiple objects (animals) in a video.
 Home-page: https://github.com/subhacom/argos
 Author: Subhasis Ray
 Author-email: ray.subhasis@gmail.com
 Project-URL: Documentation, https://argos.readthedocs.io
 Project-URL: Source, https://github.com/subhacom/argos
 Project-URL: Tracker, https://github.com/subhacom/argos/issues
 Classifier: Programming Language :: Python :: 3
-Classifier: License :: Public Domain
+Classifier: License :: OSI Approved :: GNU General Public License (GPL)
 Classifier: Operating System :: Microsoft :: Windows
 Classifier: Operating System :: MacOS
 Classifier: Operating System :: POSIX :: Linux
 Classifier: Topic :: Scientific/Engineering
 Classifier: Topic :: Utilities
 Requires-Python: >=3.6
 Description-Content-Type: text/markdown
+License-File: LICENSE
 License-File: LICENSE.txt
+Requires-Dist: cython
+Requires-Dist: torch
+Requires-Dist: torchvision
+Requires-Dist: numpy
+Requires-Dist: scipy
+Requires-Dist: scikit-learn
+Requires-Dist: pandas
+Requires-Dist: tables
+Requires-Dist: sortedcontainers
+Requires-Dist: pyqt5
+Requires-Dist: opencv-contrib-python
+Requires-Dist: pyyaml
+Requires-Dist: matplotlib
+Requires-Dist: qdarkstyle
 
 # Argos: tracking multiple objects ([documentation](https://argos.readthedocs.io/en/latest/))
 Argos is a free, open source software toolkit to facilitate tracking
 multiple objects (animals) in videos. 
 
-It is distributed in two packages, this, providing tools for video
-capture, annotation of training dataset, and review and correction of
-tracks detected automatically by the Argos Tracking tool. The other
-package is the Argos Tracking tool, distributed in the package
-[argos-tracker](https://github.com/subhacom/argos_tracker).
-
 It is described in this article: 
 ```
-Ray, S., & Stopfer, M. A. (2021). 
+Ray, S., Stopfer, M.A., 2022. 
 Argos: A toolkit for tracking multiple animals in complex visual environments. 
-Methods in Ecology and Evolution, 00, 1-11. 
+Methods in Ecology and Evolution 13, 585â€“595. 
 https://doi.org/10.1111/2041-210X.13776
+
 ```
 
 Please feel free to create an issue in the [issue tracker](
 https://github.com/subhacom/argos/issues) if you have questions,
 suggestions, or bugs to report.
 
 
@@ -59,17 +69,15 @@
    3. Track animals in videos (as described above) using either a GUI
       or in batch mode.
    4. Review and correct detected tracks using a GUI.
 
 The user documentation for Argos is available on
 [readthedocs](https://argos.readthedocs.io/en/latest/).
 
-Argos is in the Public Domain, while the 
-[tracker tool](https://github.com/subhacom/argos_tracker) 
-is released under GPL. Both are free and open source.
+Argos 0.2.0 onwards is released free and open source GPL3 license. 
 
 Instead of reinventing the wheel, we put together algorithms developed
 by researchers in computer vision in a simple graphical interface to
 facilitate the work of biologists.
 
 The components of Argos are loosely coupled. Specifically, the
 tracking does not use neural nets, so no need for training it with
@@ -110,14 +118,16 @@
    
 5. Install PyTorch.
 
    If you have a CUDA capable GPU, see  [pytorch website](https://pytorch.org/get-started/locally/)
    to select the  right command. But note that you will need to install the appropriate 
    [NVIDIA driver](https://www.nvidia.com/Download/index.aspx) for it to work.
 
+   *NOTE: Feb 2024 YOLACT does not work on PyTorch with CUDA 12 due to a device mismatch. Use CUDA  11.8 version of PyTorch*
+   
    In case you do not have a CUDA capable GPU, you have to use
    *CPU-only* version (which can be ~10 times slower), in the Anaconda
    prompt
 
    ``` 
    conda install pytorch torchvision cpuonly -c pytorch 
    ``` 
@@ -149,24 +159,19 @@
    ```
 
 7. Install Argos with this command:
 
    ```
    pip install argos_toolkit
    ```
-   and the Tracking utility:
-   ```
-   pip install argos_tracker
-   ```
 
    If you want the development versions of these, do this instead:
 
    ```
    pip install https://github.com/subhacom/argos/archive/master.zip
-   pip install https://github.com/subhacom/argos_tracker/archive/master.zip
    ```
 
 ### Usage
 
 To try Argos tracking on objects in COCO dataset, download the
 pretrained model released with YOLACT
 [here](https://drive.google.com/file/d/1UYy3dMapbH1BnmtZU4WH1zbYgOzzHHf_/view?usp=sharing)
@@ -196,24 +201,24 @@
 ```
 
 Continue reading below, or refer to the documentation for specific
 cases.
 
 #### Interactive tracking
 
-The `argos_track` utility provides a graphical
+The `argos.track` utility provides a graphical
 interface to set the parameters, choose algorithms for detection
 (instance segmentation) and tracking, and to view the performance as
 tracking proceeds. Follow the steps below to start and use this
 program.
 
 1. Run `argos` tracking script on the Anaconda prompt:
    
    ```
-   python -m argos_track
+   python -m argos.track
    ```
 
    This will start the Graphical User Interface for the
    tracker. Follow the steps below in the GUI to track objects while
    visualizing the tracking.
 
 2. Open the video file using either the `File` menu. After selecting
@@ -282,20 +287,20 @@
 	
 #### Batch tracking 
 You can also run the tracking in batch mode from the command
 line. This is useful for processing a number of files from a shell
 script. This uses YOLACT for decteting objects and SORT for tracking.
 
 ```
-python -m argos_track.batchtrack -i {input_file} -o {output_file} -c {yolact_config} -w {yolact_weights} -s {score} -k {max_objects} --hmin {minimum_height} --hmax {maximum_height} --wmin {minimum_width} --wmax {maximum_width} --overlap {minimum_overlap} --max_age {maximum_misses}
+python -m argos.batchtrack -i {input_file} -o {output_file} -c {yolact_config} -w {yolact_weights} -s {score} -k {max_objects} --hmin {minimum_height} --hmax {maximum_height} --wmin {minimum_width} --wmax {maximum_width} --overlap {minimum_overlap} --max_age {maximum_misses}
 ```	
 
 where every entry inside braces is to be replaced by the appropriate
 value. The arguments are described below (full list can be obtained by
-the command `python -m argos_track.batchtrack -h`)
+the command `python -m argos.batchtrack -h`)
 
 - `input_file`: path of input video file
 
 - `output_file`: path of output data
 
 - `yolact_config`: path of yolact configuration file (as described above
   in step 10)
@@ -352,15 +357,15 @@
 these animals in `config/weights.pth`, the recorded video in
 `myvideo.avi`, where we know that no more than 20 animals (including
 misdetection of other objects as the animal, e.g. a scratch in the
 arena) should be detected in the video, the following command may
 work:
 
 ```
-python -m argos_track.batchtrack -i myvideo.avi -o myvideo.h5 -c config/yolact.yml -w config/weights.pth -s 0.3 -k 20 --hmin 10 --hmax 100 --wmin 5 --wmax 50 --overlap 0.3 --max_age 20
+python -m argos.batchtrack -i myvideo.avi -o myvideo.h5 -c config/yolact.yml -w config/weights.pth -s 0.3 -k 20 --hmin 10 --hmax 100 --wmin 5 --wmax 50 --overlap 0.3 --max_age 20
 ```
 
 This will give a new label to an object if it is missing for 20 frames
 or more. If there are misdetections, they can be corrected manually by
 the `review` tool described below.
 
 Before embarking on processing a series of similar videos in batch
@@ -389,15 +394,15 @@
    running the reviewer.
 2. Start the GUI using the command
 
   ```
   python -m argos.review
   ```
 
-3. From the File menu open the track generated by `argos_track` and it
+3. From the File menu open the track generated by the tracking utility and it
    will ask for the corresponding video file.
    
    Once both are selected, you will see the current frame in the right
    pane and the previous frame in the left pane (initially empty).
 
 4. Press Play (keyboard shortcut: `space bar`) to start going through the video.
 
@@ -582,15 +587,15 @@
   instrctions above).
   
   On Unix-like systems (Linux/Mac) you can install pycocotools with
   ```
   pip install pycocotools
   ```
   
-- I get this error when trying `python -m argos_track`:
+- I get this error when trying `python -m argos.track`:
   ```
   RuntimeError: Found no NVIDIA driver on your system. Please check that you have an NVIDIA GPU and installed a driver from http://www.nvidia.com/Download/index.aspx
   ```
   
   Check if you have NVIDIA drivers for CUDA installed. Also note that
   CUDA does not work from Windows Subsystem for Linux (WSL). In
   general it is a good idea to install Argos on the native platform.
@@ -635,7 +640,9 @@
   ```
 
 - If you use Argos for a publication, please cite the article describing it:
 
     Ray, S., & Stopfer, M. A. (2021).  Argos: A toolkit for tracking
     multiple animals in complex visual environments. Methods in Ecology
     and Evolution, 00, 1- 11. https://doi.org/10.1111/2041-210X.13776
+	
+- Funding: During the initial development of Argos (v0.1) the author was funded by the National Institutes of Health. Since June 2021 Args does not receive any funding and the author develops it in his free time as a contribution to the community.
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `argos_toolkit-0.1.3.post3/README.md` & `argos_toolkit-0.2.0/README.md`

 * *Files 4% similar despite different names*

```diff
@@ -1,23 +1,18 @@
 # Argos: tracking multiple objects ([documentation](https://argos.readthedocs.io/en/latest/))
 Argos is a free, open source software toolkit to facilitate tracking
 multiple objects (animals) in videos. 
 
-It is distributed in two packages, this, providing tools for video
-capture, annotation of training dataset, and review and correction of
-tracks detected automatically by the Argos Tracking tool. The other
-package is the Argos Tracking tool, distributed in the package
-[argos-tracker](https://github.com/subhacom/argos_tracker).
-
 It is described in this article: 
 ```
-Ray, S., & Stopfer, M. A. (2021). 
+Ray, S., Stopfer, M.A., 2022. 
 Argos: A toolkit for tracking multiple animals in complex visual environments. 
-Methods in Ecology and Evolution, 00, 1-11. 
+Methods in Ecology and Evolution 13, 585–595. 
 https://doi.org/10.1111/2041-210X.13776
+
 ```
 
 Please feel free to create an issue in the [issue tracker](
 https://github.com/subhacom/argos/issues) if you have questions,
 suggestions, or bugs to report.
 
 
@@ -38,17 +33,15 @@
    3. Track animals in videos (as described above) using either a GUI
       or in batch mode.
    4. Review and correct detected tracks using a GUI.
 
 The user documentation for Argos is available on
 [readthedocs](https://argos.readthedocs.io/en/latest/).
 
-Argos is in the Public Domain, while the 
-[tracker tool](https://github.com/subhacom/argos_tracker) 
-is released under GPL. Both are free and open source.
+Argos 0.2.0 onwards is released free and open source GPL3 license. 
 
 Instead of reinventing the wheel, we put together algorithms developed
 by researchers in computer vision in a simple graphical interface to
 facilitate the work of biologists.
 
 The components of Argos are loosely coupled. Specifically, the
 tracking does not use neural nets, so no need for training it with
@@ -89,14 +82,16 @@
    
 5. Install PyTorch.
 
    If you have a CUDA capable GPU, see  [pytorch website](https://pytorch.org/get-started/locally/)
    to select the  right command. But note that you will need to install the appropriate 
    [NVIDIA driver](https://www.nvidia.com/Download/index.aspx) for it to work.
 
+   *NOTE: Feb 2024 YOLACT does not work on PyTorch with CUDA 12 due to a device mismatch. Use CUDA  11.8 version of PyTorch*
+   
    In case you do not have a CUDA capable GPU, you have to use
    *CPU-only* version (which can be ~10 times slower), in the Anaconda
    prompt
 
    ``` 
    conda install pytorch torchvision cpuonly -c pytorch 
    ``` 
@@ -128,24 +123,19 @@
    ```
 
 7. Install Argos with this command:
 
    ```
    pip install argos_toolkit
    ```
-   and the Tracking utility:
-   ```
-   pip install argos_tracker
-   ```
 
    If you want the development versions of these, do this instead:
 
    ```
    pip install https://github.com/subhacom/argos/archive/master.zip
-   pip install https://github.com/subhacom/argos_tracker/archive/master.zip
    ```
 
 ### Usage
 
 To try Argos tracking on objects in COCO dataset, download the
 pretrained model released with YOLACT
 [here](https://drive.google.com/file/d/1UYy3dMapbH1BnmtZU4WH1zbYgOzzHHf_/view?usp=sharing)
@@ -175,24 +165,24 @@
 ```
 
 Continue reading below, or refer to the documentation for specific
 cases.
 
 #### Interactive tracking
 
-The `argos_track` utility provides a graphical
+The `argos.track` utility provides a graphical
 interface to set the parameters, choose algorithms for detection
 (instance segmentation) and tracking, and to view the performance as
 tracking proceeds. Follow the steps below to start and use this
 program.
 
 1. Run `argos` tracking script on the Anaconda prompt:
    
    ```
-   python -m argos_track
+   python -m argos.track
    ```
 
    This will start the Graphical User Interface for the
    tracker. Follow the steps below in the GUI to track objects while
    visualizing the tracking.
 
 2. Open the video file using either the `File` menu. After selecting
@@ -261,20 +251,20 @@
 	
 #### Batch tracking 
 You can also run the tracking in batch mode from the command
 line. This is useful for processing a number of files from a shell
 script. This uses YOLACT for decteting objects and SORT for tracking.
 
 ```
-python -m argos_track.batchtrack -i {input_file} -o {output_file} -c {yolact_config} -w {yolact_weights} -s {score} -k {max_objects} --hmin {minimum_height} --hmax {maximum_height} --wmin {minimum_width} --wmax {maximum_width} --overlap {minimum_overlap} --max_age {maximum_misses}
+python -m argos.batchtrack -i {input_file} -o {output_file} -c {yolact_config} -w {yolact_weights} -s {score} -k {max_objects} --hmin {minimum_height} --hmax {maximum_height} --wmin {minimum_width} --wmax {maximum_width} --overlap {minimum_overlap} --max_age {maximum_misses}
 ```	
 
 where every entry inside braces is to be replaced by the appropriate
 value. The arguments are described below (full list can be obtained by
-the command `python -m argos_track.batchtrack -h`)
+the command `python -m argos.batchtrack -h`)
 
 - `input_file`: path of input video file
 
 - `output_file`: path of output data
 
 - `yolact_config`: path of yolact configuration file (as described above
   in step 10)
@@ -331,15 +321,15 @@
 these animals in `config/weights.pth`, the recorded video in
 `myvideo.avi`, where we know that no more than 20 animals (including
 misdetection of other objects as the animal, e.g. a scratch in the
 arena) should be detected in the video, the following command may
 work:
 
 ```
-python -m argos_track.batchtrack -i myvideo.avi -o myvideo.h5 -c config/yolact.yml -w config/weights.pth -s 0.3 -k 20 --hmin 10 --hmax 100 --wmin 5 --wmax 50 --overlap 0.3 --max_age 20
+python -m argos.batchtrack -i myvideo.avi -o myvideo.h5 -c config/yolact.yml -w config/weights.pth -s 0.3 -k 20 --hmin 10 --hmax 100 --wmin 5 --wmax 50 --overlap 0.3 --max_age 20
 ```
 
 This will give a new label to an object if it is missing for 20 frames
 or more. If there are misdetections, they can be corrected manually by
 the `review` tool described below.
 
 Before embarking on processing a series of similar videos in batch
@@ -368,15 +358,15 @@
    running the reviewer.
 2. Start the GUI using the command
 
   ```
   python -m argos.review
   ```
 
-3. From the File menu open the track generated by `argos_track` and it
+3. From the File menu open the track generated by the tracking utility and it
    will ask for the corresponding video file.
    
    Once both are selected, you will see the current frame in the right
    pane and the previous frame in the left pane (initially empty).
 
 4. Press Play (keyboard shortcut: `space bar`) to start going through the video.
 
@@ -561,15 +551,15 @@
   instrctions above).
   
   On Unix-like systems (Linux/Mac) you can install pycocotools with
   ```
   pip install pycocotools
   ```
   
-- I get this error when trying `python -m argos_track`:
+- I get this error when trying `python -m argos.track`:
   ```
   RuntimeError: Found no NVIDIA driver on your system. Please check that you have an NVIDIA GPU and installed a driver from http://www.nvidia.com/Download/index.aspx
   ```
   
   Check if you have NVIDIA drivers for CUDA installed. Also note that
   CUDA does not work from Windows Subsystem for Linux (WSL). In
   general it is a good idea to install Argos on the native platform.
@@ -614,7 +604,9 @@
   ```
 
 - If you use Argos for a publication, please cite the article describing it:
 
     Ray, S., & Stopfer, M. A. (2021).  Argos: A toolkit for tracking
     multiple animals in complex visual environments. Methods in Ecology
     and Evolution, 00, 1- 11. https://doi.org/10.1111/2041-210X.13776
+	
+- Funding: During the initial development of Argos (v0.1) the author was funded by the National Institutes of Health. Since June 2021 Args does not receive any funding and the author develops it in his free time as a contribution to the community.
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `argos_toolkit-0.1.3.post3/argos/_stylesheets/breeze.qrc` & `argos_toolkit-0.2.0/argos/_stylesheets/breeze.qrc`

 * *Files identical despite different names*

### Comparing `argos_toolkit-0.1.3.post3/argos/_stylesheets/dark/stylesheet.qss` & `argos_toolkit-0.2.0/argos/_stylesheets/dark/stylesheet.qss`

 * *Files identical despite different names*

### Comparing `argos_toolkit-0.1.3.post3/argos/_stylesheets/dark-green/stylesheet.qss` & `argos_toolkit-0.2.0/argos/_stylesheets/dark-green/stylesheet.qss`

 * *Files identical despite different names*

### Comparing `argos_toolkit-0.1.3.post3/argos/_stylesheets/dark-purple/stylesheet.qss` & `argos_toolkit-0.2.0/argos/_stylesheets/dark-purple/stylesheet.qss`

 * *Files identical despite different names*

### Comparing `argos_toolkit-0.1.3.post3/argos/_stylesheets/light/stylesheet.qss` & `argos_toolkit-0.2.0/argos/_stylesheets/light/stylesheet.qss`

 * *Files identical despite different names*

### Comparing `argos_toolkit-0.1.3.post3/argos/_stylesheets/light-green/stylesheet.qss` & `argos_toolkit-0.2.0/argos/_stylesheets/light-green/stylesheet.qss`

 * *Files identical despite different names*

### Comparing `argos_toolkit-0.1.3.post3/argos/_stylesheets/light-purple/stylesheet.qss` & `argos_toolkit-0.2.0/argos/_stylesheets/light-purple/stylesheet.qss`

 * *Files identical despite different names*

### Comparing `argos_toolkit-0.1.3.post3/argos/annotate.py` & `argos_toolkit-0.2.0/argos/annotate.py`

 * *Files 2% similar despite different names*

```diff
@@ -70,20 +70,20 @@
    :alt: Screenshot of annotate tool after segmenting an image.
 
    Screenshot of annotate tool after segmenting an image.
 
 The image above shows some locusts in a box with petri dishes
 containing paper strips. As you can see, the segmentation includes
 spots on the paper floor, edges of the petri dishes as well as the
-animals. 
+animals.
 
 We want to train the YOLACT network to detect the locusts. So we must
 remove any segmented objects that are not locusts. To do this, click on
 the ID of an unwanted object on the left pane listing ``Segmented
-objects``. The selected object will be outlined with dotted blue line. 
+objects``. The selected object will be outlined with dotted blue line.
 
 You can click the ``Remove selected objects`` button on the panel at
 the bottom left, or press ``x`` on the keyboard to delete this
 segmented object.
 
 .. figure:: ../doc/images/annotate_02.png
    :width: 100%
@@ -99,15 +99,15 @@
 keeping the ``Ctrl`` key pressed while left-clicking on the IDs of the
 animals on the left pane. Then click ``Keep selected objects`` or
 press ``k`` on the keyboard to delete all other segmented
 objects.
 
 By default, objects are outlined with solid green line, and selected
 objects are outlined with dotted blue line. But you can change this
-from ``View`` menu. 
+from ``View`` menu.
 
 In the ``View`` menu you can check ``Autocolor`` to make the program
 automatically use a different color for each object. In this case, the
 selected object is outlined in a thicker line of the same color, while
 all other object outlines are dimmed.
 
 You can also choose ``Colormap`` from the view menu and specify the
@@ -117,20 +117,20 @@
 
 Segmentation settings
 ---------------------
 
 The segmentation settings pane allows you to control how each image is
 segmented. The segmentation here is done in the following steps:
 
-1. Convert the image to gray-scale 
+1. Convert the image to gray-scale
 
 2. Smooth the gray-scale image by Gaussian blurring. For this the
    following parameters can be set:
 
-   - Blur width: diameter of the 2D Gaussian window in pixels 
+   - Blur width: diameter of the 2D Gaussian window in pixels
 
    - Blur sd: Standard deviation of the Gaussian curve used for
      blurring.
 
 3. Threshold the blurred image. For this the following parameters can
    be set:
 
@@ -155,15 +155,15 @@
      the threshold value is the Gaussian-weighted sum of the values in
      its neighborhood minus this baseline value.
 
    - Thresholding block size: size of the neighborhood considered for
      each pixel.
 
    - Segmentation method: This combo box allows you to choose between
-     several thresholding methods. 
+     several thresholding methods.
 
      - ``Threshold`` and ``Contour`` are essentially the same, with
        slight difference in speed. They both find the blobs in the
        thresholded image and consider them as objects.
 
      - ``Watershed`` uses the watershed algorithm from OpenCV
        library. This is good for objects covering large patches (100s
@@ -178,15 +178,15 @@
        insects in an image are often missed by the other algorithms,
        but DBSCAN may keep them depending on the parameter
        settings). When you choose this method, there are additional
        parameters to be specified. For a better understanding of
        DBSCAN algorithm and relevant references see its documentation
        in ``scikit-learn`` package:
        https://scikit-learn.org/stable/modules/generated/sklearn.cluster.DBSCAN.html
-       
+
        - DBSCAN minimum samples: The core points of a cluster should
          include these many neighbors.
 
        - DBSCAN epsilon: this is the neighborhood size, i.e., each
          core point of a cluster should have ``minimum samples``
          neighbors within this radius. Experiment with it (try values
          like 0.1, 1, 5, etc)!
@@ -286,37 +286,35 @@
    :width: 100%
    :alt: Screenshot of suggested command line after exporting annotations.
 
    Screenshot of suggested command line after exporting annotations.
 
 """
 import sys
+
 # import time
 import logging
 import os
+
 # from collections import OrderedDict
 import random
 import pickle
 from typing import Dict
 from datetime import datetime
 import numpy as np
 import cv2
 import json
 import yaml
-from PyQt5 import (
-    QtCore as qc,
-    QtWidgets as qw,
-    QtGui as qg)
-
-from argos.constants import (
-    OutlineStyle,
-    DrawingGeom)
+from PyQt5 import QtCore as qc, QtWidgets as qw, QtGui as qg
+
+from argos.constants import OutlineStyle, DrawingGeom
 
 from argos import utility as ut
 from argos import constants as const
+
 # from argos import frameview
 from argos.frameview import FrameView
 from argos.segwidget import SegWidget
 from argos.limitswidget import LimitsWidget
 from yolact import config as yconfig
 
 
@@ -333,22 +331,23 @@
         self.segList.setSizeAdjustPolicy(qw.QListWidget.AdjustToContents)
         self.segList.setSelectionMode(self.segList.ExtendedSelection)
         self.segList.itemSelectionChanged.connect(self.sendSelection)
         self.sigItemSelectionChanged.connect(self.scene().setSelected)
         self.keepSelectedAction = qw.QAction('Keep selected objects (K)')
         self.removeSelectedAction = qw.QAction('Remove selected objects (X)')
         self.keepSelectedAction.triggered.connect(self.scene().keepSelected)
-        self.removeSelectedAction.triggered.connect(self.scene().removeSelected)
+        self.removeSelectedAction.triggered.connect(
+            self.scene().removeSelected
+        )
         # self.scene().sigPolygons.connect(self.sigPolygons)
         self.scene().sigPolygons.connect(self.updateSegList)
 
     @qc.pyqtSlot()
     def sendSelection(self):
-        selection = [int(item.text()) for item in
-                     self.segList.selectedItems()]
+        selection = [int(item.text()) for item in self.segList.selectedItems()]
         self.sigItemSelectionChanged.emit(selection)
 
     @qc.pyqtSlot(dict)
     def updateSegList(self, segdict: Dict[int, np.ndarray]) -> None:
         self.segList.clear()
         self.segList.addItems([str(key) for key in segdict.keys()])
         self.segList.updateGeometry()
@@ -356,16 +355,17 @@
     def setRoiMode(self):
         self.scene().setRoiPolygonMode()
 
     @qc.pyqtSlot(np.ndarray, int)
     def setBboxes(self, bboxes: Dict[int, np.ndarray], pos: int):
         """Method for converting x,y,w,h bbox into series of verices compatible
         with polygon settings"""
-        polygons = {ii: ut.rect2points(bboxes[ii, :])
-                    for ii in range(bboxes.shape[0])}
+        polygons = {
+            ii: ut.rect2points(bboxes[ii, :]) for ii in range(bboxes.shape[0])
+        }
         self.setPolygons(polygons, pos)
 
 
 class TrainingWidget(qw.QMainWindow):
     sigQuit = qc.pyqtSignal()
     # Send an image and its index in file list for segmentation
     sigSegment = qc.pyqtSignal(np.ndarray, int)
@@ -409,16 +409,17 @@
         self.segDict = {}  # dict containing segmentation info for each file
         self.segWidget = SegWidget()
         self.segWidget.setSegmentationMethod('Contour')
         self.segWidget.outlineCombo.setCurrentText('contour')
         self.segWidget.setOutlineStyle('contour')
         self.limitsWidget = LimitsWidget()
         self.segDock = qw.QDockWidget('Segmentation settings')
-        self.segDock.setAllowedAreas(qc.Qt.LeftDockWidgetArea |
-                                     qc.Qt.RightDockWidgetArea)
+        self.segDock.setAllowedAreas(
+            qc.Qt.LeftDockWidgetArea | qc.Qt.RightDockWidgetArea
+        )
         self.addDockWidget(qc.Qt.RightDockWidgetArea, self.segDock)
         layout = qw.QVBoxLayout()
         layout.addWidget(self.segWidget)
         layout.addWidget(self.limitsWidget)
         widget = qw.QWidget()
         widget.setLayout(layout)
         scroll = qw.QScrollArea()
@@ -431,17 +432,19 @@
         self._makeActions()
         self._makeFileDock()
         self._makeSegDock()
         self._makeMenuBar()
         self.sigImage.connect(self.displayWidget.setFrame)
         self.sigSegment.connect(self.segWidget.sigProcess)
         self.segWidget.sigSegPolygons.connect(
-            self.displayWidget.sigSetPolygons)
+            self.displayWidget.sigSetPolygons
+        )
         self.displayWidget.sigPolygons.connect(self.setSegmented)
         self.segWidget.sigProcessed.connect(self.displayWidget.setBboxes)
+        self.segWidget.sigSettingsChanged.connect(self.resegmentCurrent)
         self.limitsWidget.sigWmin.connect(self.segWidget.setWmin)
         self.limitsWidget.sigWmax.connect(self.segWidget.setWmax)
         self.limitsWidget.sigHmin.connect(self.segWidget.setHmin)
         self.limitsWidget.sigHmax.connect(self.segWidget.setHmax)
         # Note the difference between `sigSegment` and `sigSegmented`
         # - this TrainingWidget's `sigSegment` sends the image to the
         #   segmentation widget
@@ -467,83 +470,96 @@
     def _makeFileDock(self):
         self.fileDock = qw.QDockWidget('Files/Dirs')
 
         dirlayout = qw.QFormLayout()
         self.outDirLabel = qw.QLabel('Output directory for training data')
         self.outDirName = qw.QLabel(self.outputDir)
         self.outDirName.setMinimumWidth(0)
-        self.outDirName.setSizePolicy(qw.QSizePolicy.MinimumExpanding,
-                                      qw.QSizePolicy.Preferred)
+        self.outDirName.setSizePolicy(
+            qw.QSizePolicy.MinimumExpanding, qw.QSizePolicy.Preferred
+        )
         dirlayout.addRow(self.outDirLabel, self.outDirName)
         self.imageDirLabel = qw.QLabel('Input image directory')
         self.imageDirName = qw.QLabel(self.imageDir)
         self.imageDirName.setMinimumWidth(0)
-        self.imageDirName.setSizePolicy(qw.QSizePolicy.MinimumExpanding,
-                                        qw.QSizePolicy.Preferred)
+        self.imageDirName.setSizePolicy(
+            qw.QSizePolicy.MinimumExpanding, qw.QSizePolicy.Preferred
+        )
         dirlayout.addRow(self.imageDirLabel, self.imageDirName)
         self.dirWidget = qw.QWidget()
         self.dirWidget.setLayout(dirlayout)
 
         self.fileView = qw.QListView()
         self.fileView.setSizeAdjustPolicy(qw.QListWidget.AdjustToContents)
         self.fileModel = qw.QFileSystemModel()
         self.fileModel.setFilter(qc.QDir.NoDotAndDotDot | qc.QDir.Files)
         self.fileView.setModel(self.fileModel)
         self.fileView.setRootIndex(self.fileModel.setRootPath(self.imageDir))
-        self.fileView.selectionModel().selectionChanged.connect(self.handleFileSelectionChanged)
+        self.fileView.selectionModel().selectionChanged.connect(
+            self.handleFileSelectionChanged
+        )
 
         self.fwidget = qw.QWidget()
         layout = qw.QVBoxLayout()
         layout.addWidget(self.dirWidget)
         layout.addWidget(self.fileView)
         self.fwidget.setLayout(layout)
         self.fileDock.setWidget(self.fwidget)
-        self.fileDock.setAllowedAreas(qc.Qt.LeftDockWidgetArea |
-                                      qc.Qt.RightDockWidgetArea)
+        self.fileDock.setAllowedAreas(
+            qc.Qt.LeftDockWidgetArea | qc.Qt.RightDockWidgetArea
+        )
         self.addDockWidget(qc.Qt.RightDockWidgetArea, self.fileDock)
 
     def _makeSegDock(self):
         self.nextButton = qw.QToolButton()
-        self.nextButton.setSizePolicy(qw.QSizePolicy.Minimum,
-                                      qw.QSizePolicy.MinimumExpanding)
+        self.nextButton.setSizePolicy(
+            qw.QSizePolicy.Minimum, qw.QSizePolicy.MinimumExpanding
+        )
         self.nextButton.setDefaultAction(self.nextFrameAction)
 
         self.prev_button = qw.QToolButton()
-        self.prev_button.setSizePolicy(qw.QSizePolicy.Minimum,
-                                       qw.QSizePolicy.MinimumExpanding)
+        self.prev_button.setSizePolicy(
+            qw.QSizePolicy.Minimum, qw.QSizePolicy.MinimumExpanding
+        )
         self.prev_button.setDefaultAction(self.prevFrameAction)
         self.resegment_button = qw.QToolButton()
-        self.resegment_button.setSizePolicy(qw.QSizePolicy.Minimum,
-                                       qw.QSizePolicy.MinimumExpanding)
+        self.resegment_button.setSizePolicy(
+            qw.QSizePolicy.Minimum, qw.QSizePolicy.MinimumExpanding
+        )
         self.resegment_button.setDefaultAction(self.resegmentAction)
         self.batchSegment_button = qw.QToolButton()
         self.batchSegment_button.setDefaultAction(self.batchSegmentAction)
-        self.batchSegment_button.setSizePolicy(qw.QSizePolicy.Minimum,
-                                       qw.QSizePolicy.MinimumExpanding)
+        self.batchSegment_button.setSizePolicy(
+            qw.QSizePolicy.Minimum, qw.QSizePolicy.MinimumExpanding
+        )
         self.clearCurButton = qw.QToolButton()
-        self.clearCurButton.setSizePolicy(qw.QSizePolicy.Minimum,
-                                          qw.QSizePolicy.MinimumExpanding)
+        self.clearCurButton.setSizePolicy(
+            qw.QSizePolicy.Minimum, qw.QSizePolicy.MinimumExpanding
+        )
         self.clearCurButton.setDefaultAction(self.clearCurrentAction)
         self.clearAllButton = qw.QToolButton()
-        self.clearAllButton.setSizePolicy(qw.QSizePolicy.Minimum,
-                                          qw.QSizePolicy.MinimumExpanding)
+        self.clearAllButton.setSizePolicy(
+            qw.QSizePolicy.Minimum, qw.QSizePolicy.MinimumExpanding
+        )
         self.clearAllButton.setDefaultAction(self.clearAllAction)
         # self.export_button = qw.QToolButton()
         # self.export_button.setDefaultAction(self.exportSegmentationAction)
         # layout.addWidget(self.export_button)
         self.keepButton = qw.QToolButton()
-        self.keepButton.setSizePolicy(qw.QSizePolicy.Minimum,
-                                      qw.QSizePolicy.MinimumExpanding)
-        self.keepButton.setDefaultAction(
-            self.displayWidget.keepSelectedAction)
+        self.keepButton.setSizePolicy(
+            qw.QSizePolicy.Minimum, qw.QSizePolicy.MinimumExpanding
+        )
+        self.keepButton.setDefaultAction(self.displayWidget.keepSelectedAction)
         self.removeButton = qw.QToolButton()
-        self.removeButton.setSizePolicy(qw.QSizePolicy.Minimum,
-                                        qw.QSizePolicy.MinimumExpanding)
+        self.removeButton.setSizePolicy(
+            qw.QSizePolicy.Minimum, qw.QSizePolicy.MinimumExpanding
+        )
         self.removeButton.setDefaultAction(
-            self.displayWidget.removeSelectedAction)
+            self.displayWidget.removeSelectedAction
+        )
 
         layout = qw.QVBoxLayout()
         layout.addWidget(self.displayWidget.segList, 1)
 
         layout.addWidget(self.keepButton)
         layout.addWidget(self.removeButton)
         layout.addWidget(self.nextButton)
@@ -551,44 +567,54 @@
         layout.addWidget(self.resegment_button)
         layout.addWidget(self.clearCurButton)
         layout.addWidget(self.clearAllButton)
         widget = qw.QWidget()
         widget.setLayout(layout)
         self.segDock = qw.QDockWidget('Segmented objects')
         self.segDock.setWidget(widget)
-        self.segDock.setAllowedAreas(qc.Qt.LeftDockWidgetArea |
-                                     qc.Qt.RightDockWidgetArea)
+        self.segDock.setAllowedAreas(
+            qc.Qt.LeftDockWidgetArea | qc.Qt.RightDockWidgetArea
+        )
         self.addDockWidget(qc.Qt.LeftDockWidgetArea, self.segDock)
 
     def _makeActions(self):
+        self.quitAction = qw.QAction('Quit (Ctrl+Q)')
+        self.quitAction.setShortcut(qg.QKeySequence('Ctrl+Q'))
+        self.quitAction.triggered.connect(self.close)
         self.imagedirAction = qw.QAction('Open image dir')
         self.imagedirAction.triggered.connect(self.openImageDir)
         self.outdirAction = qw.QAction('Open output directory')
         self.outdirAction.triggered.connect(self.setOutputDir)
         self.extractFramesAction = qw.QAction('Extract frames from video')
         self.extractFramesAction.triggered.connect(self.extractFrames)
         self.nextFrameAction = qw.QAction('&Next image (PgDn)')
         self.nextFrameAction.triggered.connect(self.nextFrame)
         self.prevFrameAction = qw.QAction('&Previous image (PgUp)')
         self.prevFrameAction.triggered.connect(self.prevFrame)
         self.resegmentAction = qw.QAction('Re-segment current image (R)')
-        self.resegmentAction.triggered.connect(
-            self.resegmentCurrent)
+        self.resegmentAction.triggered.connect(self.resegmentCurrent)
         self.batchSegmentAction = qw.QAction('Segment all files in directory')
         self.batchSegmentAction.triggered.connect(self.batchSegment)
         self.clearCurrentAction = qw.QAction('&Clear current segmentation (C)')
         self.clearCurrentAction.triggered.connect(self.clearCurrent)
         self.clearAllAction = qw.QAction('Reset all segmentation')
         self.clearAllAction.triggered.connect(self.clearAllSegmentation)
         self.exportSegmentationAction = qw.QAction(
-            '&Export training and validation data (Ctrl+E)')
-        self.exportSegmentationAction.triggered.connect(self.exportSegmentation)
-        self.saveSegmentationAction = qw.QAction('&Save segmentations (Ctrl+S)')
+            '&Export training and validation data (Ctrl+E)'
+        )
+        self.exportSegmentationAction.triggered.connect(
+            self.exportSegmentation
+        )
+        self.saveSegmentationAction = qw.QAction(
+            '&Save segmentations (Ctrl+S)'
+        )
         self.saveSegmentationAction.triggered.connect(self.saveSegmentation)
-        self.loadSegmentationsAction = qw.QAction('&Open saved segmentations (Ctrl+O)')
+        self.loadSegmentationsAction = qw.QAction(
+            '&Open saved segmentations (Ctrl+O)'
+        )
         self.loadSegmentationsAction.triggered.connect(self.loadSegmentation)
 
         # Views of the dock widgets
         self.showFileDockAction = qw.QAction('Directory listing')
         self.showFileDockAction.setCheckable(True)
         self.showFileDockAction.setChecked(True)
         self.showSegDockAction = qw.QAction('Segmentation settings')
@@ -607,86 +633,113 @@
 
     def _makeShortcuts(self):
         self.zoomInKey = qw.QShortcut(qg.QKeySequence('+'), self)
         self.zoomInKey.activated.connect(self.displayWidget.zoomIn)
         self.zoomOutKey = qw.QShortcut(qg.QKeySequence('-'), self)
         self.zoomOutKey.activated.connect(self.displayWidget.zoomOut)
 
-        self.nextImageKey = qw.QShortcut(qg.QKeySequence(qc.Qt.Key_PageDown), self)
+        self.nextImageKey = qw.QShortcut(
+            qg.QKeySequence(qc.Qt.Key_PageDown), self
+        )
         self.nextImageKey.activated.connect(self.nextFrame)
-        self.prevImageKey = qw.QShortcut(qg.QKeySequence(qc.Qt.Key_PageUp), self)
+        self.prevImageKey = qw.QShortcut(
+            qg.QKeySequence(qc.Qt.Key_PageUp), self
+        )
         self.prevImageKey.activated.connect(self.prevFrame)
 
-        self.removeSegKey = qw.QShortcut(qg.QKeySequence(qc.Qt.Key_Delete), self)
+        self.removeSegKey = qw.QShortcut(
+            qg.QKeySequence(qc.Qt.Key_Delete), self
+        )
         self.removeSegKey.activated.connect(
-            self.displayWidget.removeSelectedAction.trigger)
+            self.displayWidget.removeSelectedAction.trigger
+        )
         self.removeSegKey2 = qw.QShortcut(qg.QKeySequence('X'), self)
         self.removeSegKey2.activated.connect(
-            self.displayWidget.removeSelectedAction.trigger)
+            self.displayWidget.removeSelectedAction.trigger
+        )
         self.keepSegKey = qw.QShortcut(qg.QKeySequence('K'), self)
         self.keepSegKey.activated.connect(
-            self.displayWidget.keepSelectedAction.trigger)
+            self.displayWidget.keepSelectedAction.trigger
+        )
         self.keepSegKey2 = qw.QShortcut(qg.QKeySequence('Shift+X'), self)
         self.keepSegKey2.activated.connect(
-            self.displayWidget.keepSelectedAction.trigger)
+            self.displayWidget.keepSelectedAction.trigger
+        )
 
         self.clearCurrentImageKey = qw.QShortcut(qg.QKeySequence('C'), self)
         self.clearCurrentImageKey.activated.connect(self.clearCurrent)
-        self.resegmentCurrentImageKey = qw.QShortcut(qg.QKeySequence('R'), self)
+        self.resegmentCurrentImageKey = qw.QShortcut(
+            qg.QKeySequence('R'), self
+        )
         self.resegmentCurrentImageKey.activated.connect(self.resegmentCurrent)
 
         self.saveKey = qw.QShortcut(qg.QKeySequence('Ctrl+S'), self)
-        self.saveKey.activated.connect(
-            self.saveSegmentation)
+        self.saveKey.activated.connect(self.saveSegmentation)
         self.openKey = qw.QShortcut(qg.QKeySequence('Ctrl+O'), self)
-        self.openKey.activated.connect(
-            self.loadSegmentation)
+        self.openKey.activated.connect(self.loadSegmentation)
 
         self.exportKey = qw.QShortcut(qg.QKeySequence('Ctrl+E'), self)
         self.exportKey.activated.connect(self.exportSegmentation)
 
     def _makeConnections(self):
         """separated from creating actions because they refer to objects that
         are created after the actions."""
         self.showFileDockAction.triggered.connect(self.fileDock.setVisible)
         self.showSegDockAction.triggered.connect(self.segDock.setVisible)
         self.showActionsDockAction.triggered.connect(self.fileDock.setVisible)
 
     def _makeMenuBar(self):
         self.fileMenu = self.menuBar().addMenu('&File')
-        self.fileMenu.addActions([self.imagedirAction,
-                                  self.outdirAction,
-                                  self.extractFramesAction,
-                                  self.loadSegmentationsAction,
-                                  self.saveSegmentationAction,
-                                  self.exportSegmentationAction])
+        self.fileMenu.addActions(
+            [
+                self.imagedirAction,
+                self.outdirAction,
+                self.extractFramesAction,
+                self.loadSegmentationsAction,
+                self.saveSegmentationAction,
+                self.exportSegmentationAction,
+                self.quitAction,
+            ]
+        )
         self.segMenu = self.menuBar().addMenu('&Segment')
-        self.segMenu.addActions([self.nextFrameAction,
-                                 self.prevFrameAction,
-                                 self.resegmentAction,
-                                 self.batchSegmentAction,
-                                 self.clearCurrentAction,
-                                 self.clearAllAction])
+        self.segMenu.addActions(
+            [
+                self.nextFrameAction,
+                self.prevFrameAction,
+                self.resegmentAction,
+                self.batchSegmentAction,
+                self.clearCurrentAction,
+                self.clearAllAction,
+            ]
+        )
         self.viewMenu = self.menuBar().addMenu('View')
-        self.viewMenu.addActions([self.displayWidget.zoomInAction,
-                                  self.displayWidget.zoomOutAction,
-                                  self.displayWidget.setColorAction,
-                                  self.displayWidget.setSelectedColorAction,
-                                  self.displayWidget.setAlphaUnselectedAction,
-                                  self.displayWidget.autoColorAction,
-                                  self.displayWidget.colormapAction,
-                                  self.displayWidget.lineWidthAction,
-                                  self.displayWidget.fontSizeAction,
-                                  self.displayWidget.relativeFontSizeAction,
-                                  self.displayWidget.setLabelInsideAction,
-                                  self.segWidget.showIntermediateAction])
+        self.viewMenu.addActions(
+            [
+                self.displayWidget.zoomInAction,
+                self.displayWidget.zoomOutAction,
+                self.displayWidget.setColorAction,
+                self.displayWidget.setSelectedColorAction,
+                self.displayWidget.setAlphaUnselectedAction,
+                self.displayWidget.autoColorAction,
+                self.displayWidget.colormapAction,
+                self.displayWidget.lineWidthAction,
+                self.displayWidget.fontSizeAction,
+                self.displayWidget.relativeFontSizeAction,
+                self.displayWidget.setLabelInsideAction,
+                self.segWidget.showIntermediateAction,
+            ]
+        )
         self.docksMenu = self.viewMenu.addMenu('Dock widgets')
-        self.docksMenu.addActions([self.showFileDockAction,
-                                  self.showSegDockAction,
-                                  self.showActionsDockAction])
+        self.docksMenu.addActions(
+            [
+                self.showFileDockAction,
+                self.showSegDockAction,
+                self.showActionsDockAction,
+            ]
+        )
         self.advancedMenu = self.menuBar().addMenu('Advanced')
         self.advancedMenu.addAction(self.debugAction)
 
     @qc.pyqtSlot(bool)
     def setDebug(self, val: bool):
         level = logging.DEBUG if val else logging.INFO
         logging.getLogger().setLevel(level)
@@ -697,58 +750,60 @@
             self.sigSetDisplayGeom.emit(DrawingGeom.rectangle)
         else:
             self.sigSetDisplayGeom.emit(DrawingGeom.polygon)
 
     def _openImageDir(self, directory):
         logging.debug(f'Opening directory "{directory}"')
         try:
-            self.imageFiles = [entry.path for entry in
-                               os.scandir(directory)]
+            self.imageFiles = [entry.path for entry in os.scandir(directory)]
             self.imageIndex = -1
             settings.setValue('training/imagedir', directory)
             self.imageDir = directory
             self.imageDirName.setText(directory)
         except IOError as err:
-            qw.QMessageBox.critical(self, 'Could not open image directory',
-                                    str(err))
+            qw.QMessageBox.critical(
+                self, 'Could not open image directory', str(err)
+            )
         self.fileView.setRootIndex(self.fileModel.setRootPath(self.imageDir))
 
     def openImageDir(self):
         directory = settings.value('training/imagedir', '.')
-        tmp = qw.QFileDialog.getExistingDirectory(self,
-                                                        'Open image diretory',
-                                                        directory=directory)
+        tmp = qw.QFileDialog.getExistingDirectory(
+            self, 'Open image diretory', directory=directory
+        )
         if len(tmp) > 0:
             directory = tmp
         self._openImageDir(directory)
 
     def setOutputDir(self):
         directory = settings.value('training/outdir', '.')
-        directory = qw.QFileDialog.getExistingDirectory(self,
-                                                        'Open image diretory',
-                                                        directory=directory)
+        directory = qw.QFileDialog.getExistingDirectory(
+            self, 'Open image diretory', directory=directory
+        )
         logging.debug(f'Opening directory "{directory}"')
         if len(directory) == 0:
             return
         try:
             self.outputDir = directory
             self.outDirName.setText(directory)
             settings.setValue('training/outdir', directory)
         except IOError as err:
-            qw.QMessageBox.critical(self,
-                                    'Could create training/validation directory',
-                                    str(err))
+            qw.QMessageBox.critical(
+                self, 'Could create training/validation directory', str(err)
+            )
             return
 
     def gotoFrame(self, index):
         if index >= len(self.imageFiles) or index < 0 or self._waiting:
             return
         fname = self.imageFiles[index]
         if not os.path.exists(fname):
-            qw.QMessageBox.critical(self, 'File does not exist', f'No such file exists: {fname}')
+            qw.QMessageBox.critical(
+                self, 'File does not exist', f'No such file exists: {fname}'
+            )
             del self.imageFiles[index]
             self.segDict.pop(index, None)
             return
         image = cv2.imread(fname)
         if image is None:
             return
         self.imageIndex = index
@@ -756,23 +811,27 @@
         self.sigImage.emit(image, index)
         self.displayWidget.updateSegList({})
         if fname not in self.segDict:
             self.saved = False
             self._waiting = True
             self.statusBar().showMessage(
                 f'Processing image: {os.path.basename(fname)}.'
-                f'[Image {self.imageIndex + 1} of {len(self.imageFiles)}] ...')
+                f'[Image {self.imageIndex + 1} of {len(self.imageFiles)}] ...'
+            )
             self.sigSegment.emit(image, index)
-            print(f'#### Sent image: {os.path.basename(fname)}.'
-            f'[Index {self.imageIndex} of {len(self.imageFiles)}]')
+            print(
+                f'#### Sent image: {os.path.basename(fname)}.'
+                f'[Index {self.imageIndex} of {len(self.imageFiles)}]'
+            )
         else:
             self.sigSegmented.emit(self.segDict[fname], index)
             self.statusBar().showMessage(
                 f'Current image: {os.path.basename(fname)}.'
-                f'[Image {self.imageIndex + 1} of {len(self.imageFiles)}]')
+                f'[Image {self.imageIndex + 1} of {len(self.imageFiles)}]'
+            )
 
     def nextFrame(self):
         self.gotoFrame(self.imageIndex + 1)
 
     def prevFrame(self):
         self.gotoFrame(self.imageIndex - 1)
 
@@ -783,100 +842,106 @@
         fname = self.fileModel.data(indices[0])
         index = self.imageFiles.index(os.path.join(self.imageDir, fname))
         self.gotoFrame(index)
 
     @qc.pyqtSlot(dict)
     def setSegmented(self, segdict: Dict[int, np.ndarray]) -> None:
         """Store the list of segmented objects for frame"""
-        logging.debug(f'Received segmentated {len(segdict)} objects'
-                      f' from {self.sender()} for image # {self.imageIndex}')
+        logging.debug(
+            f'Received segmentated {len(segdict)} objects'
+            f' from {self.sender()} for image # {self.imageIndex}'
+        )
 
         fname = self.imageFiles[self.imageIndex]
         self.segDict[fname] = segdict
         self._waiting = False
         self.statusBar().showMessage(
             f'Current image: {os.path.basename(fname)}.'
-            f' [Image {self.imageIndex + 1} of {len(self.imageFiles)}]')
+            f' [Image {self.imageIndex + 1} of {len(self.imageFiles)}]'
+        )
 
     @qc.pyqtSlot(dict)
     def sendAndWaitSegmentation(self, segdict: Dict[int, np.ndarray]) -> None:
         """Utility function for batch segmentation.
 
         When triggered send the next image file for processing
         """
-        if len(segdict ) > 0:
+        if len(segdict) > 0:
             self.setSegmented(segdict)
         # this comparison is needed because entries may be removed
         # from imageFiles in case of unreadable or deleted file
         if len(self.segDict) >= len(self.imageFiles):
             self.batchSegIndicator.setValue(self.batchSegIndicator.maximum())
             # Switch the connection back for interactive segmentation
             try:
                 self.displayWidget.sigPolygons.disconnect(
-                    self.sendAndWaitSegmentation)
+                    self.sendAndWaitSegmentation
+                )
             except TypeError:
                 logging.error('Failed to disconnect: sendAndWaitSegmentation')
-            self.displayWidget.sigPolygons.connect(
-                self.setSegmented)
+            self.displayWidget.sigPolygons.connect(self.setSegmented)
             return
         self.batchSegIndicator.setValue(self.imageIndex + 1)
         self.gotoFrame(self.imageIndex + 1)
-        
+
     @qc.pyqtSlot()
     def batchSegment(self):
         """This works by switching the displayWidget.sigPolygons from slot
         setSegmented to sendAndWaitSegmentation.
 
-        
+
         """
         maxcount = len(self.imageFiles)
-        self.batchSegIndicator = qw.QProgressDialog('Processing all files in directory',
-                                                    None,
-                                                    0, maxcount,
-                                                    self)
+        self.batchSegIndicator = qw.QProgressDialog(
+            'Processing all files in directory', None, 0, maxcount, self
+        )
         self.batchSegIndicator.setWindowModality(qc.Qt.WindowModal)
         self.batchSegIndicator.setValue(0)
         self.batchSegIndicator.show()
         try:
-            self.displayWidget.sigPolygons.disconnect(
-                self.setSegmented)
+            self.displayWidget.sigPolygons.disconnect(self.setSegmented)
         except TypeError:
             logging.error('Failed to disconnect: setSegmented')
-        self.displayWidget.sigPolygons.connect(
-            self.sendAndWaitSegmentation)
+        self.displayWidget.sigPolygons.connect(self.sendAndWaitSegmentation)
         self.imageIndex = -1
         self.sendAndWaitSegmentation({})
 
     def cleanup(self):
         self.sigQuit.emit()
         settings.sync()
         logging.debug('Saved settings')
 
     def closeEvent(self, a0: qg.QCloseEvent) -> None:
         self.segWidget.hideIntermediateOutput()
         if self.saved:
             a0.accept()
         else:
-            ret = qw.QMessageBox.question(self, 'Quit without saving?',
-                                          'Are you sure to quit?'
-                                          ' Data not saved.'
-                                          ' Select "No" and use the'
-                                          ' "Export training/validation data"'
-                                          ' button to save the data.',
-                                          qw.QMessageBox.Yes,
-                                          qw.QMessageBox.No)
+            ret = qw.QMessageBox.question(
+                self,
+                'Quit without saving?',
+                'Are you sure to quit?'
+                ' Data not saved.'
+                ' Select "No" and use the'
+                ' "Export training/validation data"'
+                ' button to save the data.',
+                qw.QMessageBox.Yes,
+                qw.QMessageBox.No,
+            )
             if ret == qw.QMessageBox.Yes:
                 a0.accept()
             else:
                 a0.ignore()
 
     def clearAllSegmentation(self):
         self.segDict = {}
 
     def resegmentCurrent(self):
+        print('Image index', self.imageIndex)
+        if self.imageIndex < 0:
+            return
         self.segDict.pop(self.imageFiles[self.imageIndex], None)
         self.gotoFrame(self.imageIndex)
 
     def clearCurrent(self):
         self.segDict.pop(self.imageFiles[self.imageIndex], None)
         self.displayWidget.setPolygons({}, self.imageIndex)
 
@@ -1002,111 +1067,126 @@
 
     def exportSegmentation(self):
         self.setOutputDir()
         trainDir = f'{self.outputDir}/training'
         try:
             os.mkdir(trainDir)
         except FileExistsError:
-            qw.QMessageBox.critical(self, 'Directory already exists',
-                                    f'Directory {trainDir} already exists.'
-                                    f' Delete it or specify another output'
-                                    f' directory')
+            qw.QMessageBox.critical(
+                self,
+                'Directory already exists',
+                f'Directory {trainDir} already exists.'
+                f' Delete it or specify another output'
+                f' directory',
+            )
             return
         except FileNotFoundError as ferr:
             qw.QMessageBox.critical(self, 'Path does not exist', str(ferr))
             return
         valDir = f'{self.outputDir}/validation'
         try:
             os.mkdir(valDir)
         except FileExistsError:
-            qw.QMessageBox.critical('Directory already exists',
-                                    f'Directory {valDir} already exists.'
-                                    f' Delete it or specify another output'
-                                    f' directory')
+            qw.QMessageBox.critical(
+                'Directory already exists',
+                f'Directory {valDir} already exists.'
+                f' Delete it or specify another output'
+                f' directory',
+            )
             return
         ts = datetime.now()
 
-        accepted = self._makeCocoDialog()
+        self._makeCocoDialog()
         validationCount = int(len(self.imageFiles) * self.validationFrac)
         trainingCount = len(self.imageFiles) - validationCount
         trainingList = random.sample(self.imageFiles, trainingCount)
-        self.dumpCocoJson(trainingList, trainDir, ts,
-                          message='Exporting training set in COCO format')
-        yolactConfig = {'name': f'{self.categoryName}_weights',
-                         'base': self.baseconfigName,
-                         'dataset': {'name': self.description,
-                                     'train_info': f'{trainDir}/annotations.json',
-                                     'valid_info': f'{valDir}/annotations.json',
-                                     'train_images': trainDir,
-                                     'valid_images': valDir,
-                                     'has_gt': True,
-                                     'class_names': [self.categoryName]},
-                         'num_classes': 2,
-                         'max_size': self.inputImageSize,
-                        'lr_steps': [100000, 150000, 175000, 190000],
-                        'max_iter': 200000}
+        self.dumpCocoJson(
+            trainingList,
+            trainDir,
+            ts,
+            message='Exporting training set in COCO format',
+        )
+        yolactConfig = {
+            'name': f'{self.categoryName}_weights',
+            'base': self.baseconfigName,
+            'dataset': {
+                'name': self.description,
+                'train_info': f'{trainDir}/annotations.json',
+                'valid_info': f'{valDir}/annotations.json',
+                'train_images': trainDir,
+                'valid_images': valDir,
+                'has_gt': True,
+                'class_names': [self.categoryName],
+            },
+            'num_classes': 2,
+            'max_size': self.inputImageSize,
+            'lr_steps': [100000, 150000, 175000, 190000],
+            'max_iter': 200000,
+        }
         yolactFile = f'{self.outputDir}/yolact_config.yaml'
         with open(yolactFile, 'w') as yolactFd:
             yaml.dump(yolactConfig, yolactFd)
         if validationCount > 0:
             validationList = set(self.imageFiles) - set(trainingList)
-            self.dumpCocoJson(validationList, valDir, ts,
-                              message='Exporting validation set in COCO format')
+            self.dumpCocoJson(
+                validationList,
+                valDir,
+                ts,
+                message='Exporting validation set in COCO format',
+            )
         command = f'python -m yolact.train --config={yolactFile} --save_folder={self.outputDir}'
-        qw.QMessageBox.information(self, 'Data saved',
-                                   f'Training images: {trainDir}<br>'
-                                   f'Validation images: {valDir}<br>'
-                                   f'Yolact configuration: {yolactFile}<br>'
-                                   f'Now you can train yolact by running this command (copied to clipboard):<br>'
-                                   f'<b>{command}</b><br>'
-                                   f'But you must copy the initial weights file {self.baseconfig.backbone.path} to {self.outputDir} before starting<br>'
-                                   f'For finer control over training settings see yolact help:'
-                                   f'`python -m yolact.train --help`'
-                                   )
+        qw.QMessageBox.information(
+            self,
+            'Data saved',
+            f'Training images: {trainDir}<br>'
+            f'Validation images: {valDir}<br>'
+            f'Yolact configuration: {yolactFile}<br>'
+            f'Now you can train yolact by running this command (copied to clipboard):<br>'
+            f'<b>{command}</b><br>'
+            f'But you must copy the initial weights file {self.baseconfig.backbone.path} to {self.outputDir} before starting<br>'
+            f'For finer control over training settings see yolact help:'
+            f'`python -m yolact.train --help`',
+        )
         qw.qApp.clipboard().setText(command)
 
-    def dumpCocoJson(self, filepaths, directory, ts, subregions=0,
-                     message='Exporting COCO JSON'):
+    def dumpCocoJson(
+        self,
+        filepaths,
+        directory,
+        ts,
+        subregions=0,
+        message='Exporting COCO JSON',
+    ):
         """Dump annotation in COCO format as a .JSON file."""
         coco = {
             "info": {
                 "description": self.description,
                 "url": self.url,
                 "version": '1.0',
                 "year": ts.year,
                 "contributor": self.contributor,
-                "date_created": ts.isoformat(sep=' ')
+                "date_created": ts.isoformat(sep=' '),
             },
             "licenses": [
-                {
-                    "url": self.licenseUrl,
-                    "id": 0,
-                    "name": self.licenseName
-                }
+                {"url": self.licenseUrl, "id": 0, "name": self.licenseName}
             ],
             'images': [],
             'type': 'instances',
             'annotations': [],
             'categories': [
-                {'supercategory': None,
-                 'id': 0,
-                 'name': '_background_'},
-                {'supercategory': None,
-                 'id': 1,
-                 'name': self.categoryName}
-            ]
+                {'supercategory': None, 'id': 0, 'name': '_background_'},
+                {'supercategory': None, 'id': 1, 'name': self.categoryName},
+            ],
         }
         imdir = os.path.join(directory, 'PNGImages')
         os.mkdir(imdir)
         segId = 0
         imgId = 0
 
-        indicator = qw.QProgressDialog(message, None,
-                                       0, len(filepaths),
-                                       self)
+        indicator = qw.QProgressDialog(message, None, 0, len(filepaths), self)
 
         indicator.setWindowModality(qc.Qt.WindowModal)
         indicator.show()
 
         for ii, fpath in enumerate(filepaths):
             indicator.setValue(ii)
             if fpath not in self.segDict or len(self.segDict[fpath]) == 0:
@@ -1114,93 +1194,125 @@
             img = cv2.imread(fpath)
             fname = os.path.basename(fpath)
             prefix = fname.rpartition('.')[0]
             # If image is bigger than allowed size, make some random crops
             h = min(self.inputImageSize, img.shape[0])
             w = min(self.inputImageSize, img.shape[1])
 
-            if img.shape[0] > self.inputImageSize or img.shape[1] > self.inputImageSize:
+            if (
+                img.shape[0] > self.inputImageSize
+                or img.shape[1] > self.inputImageSize
+            ):
                 # Here I select half of `num_crops` segments' top left corner (pos_tl)
                 # and another half's bottom right corner.
-                segBounds = [(np.min(seg[:, 0]), np.min(seg[:, 1]))
-                             for seg in self.segDict[fpath].values()]
+                segBounds = [
+                    (np.min(seg[:, 0]), np.min(seg[:, 1]))
+                    for seg in self.segDict[fpath].values()
+                ]
                 segBounds = np.array(segBounds)
                 idx = np.random.randint(0, len(segBounds), size=self.numCrops)
-                xlist = segBounds[idx, 0] - np.random.randint(0, w // 2, size=len(idx))
+                xlist = segBounds[idx, 0] - np.random.randint(
+                    0, w // 2, size=len(idx)
+                )
                 xlist[xlist < 0] = 0
-                ylist = segBounds[idx, 1] - np.random.randint(0, h // 2, size=len(idx))
+                ylist = segBounds[idx, 1] - np.random.randint(
+                    0, h // 2, size=len(idx)
+                )
                 ylist[ylist < 0] = 0
             else:
                 xlist, ylist = [0], [0]
             for jj, (x, y) in enumerate(zip(xlist, ylist)):
-                sqImg = np.zeros((self.inputImageSize, self.inputImageSize, 3),
-                                 dtype=np.uint8)
+                sqImg = np.zeros(
+                    (self.inputImageSize, self.inputImageSize, 3),
+                    dtype=np.uint8,
+                )
                 h_ = min(h, img.shape[0] - y)
                 w_ = min(w, img.shape[1] - x)
-                sqImg[:h_, :w_, :] = img[y: y + h_, x: x + w_, :]
-                logging.debug(f'Processing: {prefix}: span ({x}, {y}, {x+h_}, {y+h_}')
+                sqImg[:h_, :w_, :] = img[y : y + h_, x : x + w_, :]
+                logging.debug(
+                    f'Processing: {prefix}: span ({x}, {y}, {x+h_}, {y+h_}'
+                )
                 fname = f'{prefix}_{jj}.png'
                 anyValidSeg = False
                 for seg in self.segDict[fpath].values():
                     tmpSeg = seg - [x, y]
-                    tmpSeg = tmpSeg[np.all((tmpSeg >= 0) &
-                                           (tmpSeg < self.inputImageSize),
-                                           axis=1)]
+                    tmpSeg = tmpSeg[
+                        np.all(
+                            (tmpSeg >= 0) & (tmpSeg < self.inputImageSize),
+                            axis=1,
+                        )
+                    ]
                     if tmpSeg.shape[0] < 3:
                         continue
                     anyValidSeg = True
                     bbox = [int(xx) for xx in cv2.boundingRect(tmpSeg)]
                     if self.boundaryType == 'contour':
                         segmentation = [int(xx) for xx in tmpSeg.flatten()]
                     elif self.boundaryType == 'bbox':
-                        segmentation = [bbox[0], bbox[1],
-                                        bbox[0], bbox[1] + bbox[3],
-                                        bbox[0] + bbox[2], bbox[1] + bbox[3],
-                                        bbox[0] + bbox[2], bbox[1]]
+                        segmentation = [
+                            bbox[0],
+                            bbox[1],
+                            bbox[0],
+                            bbox[1] + bbox[3],
+                            bbox[0] + bbox[2],
+                            bbox[1] + bbox[3],
+                            bbox[0] + bbox[2],
+                            bbox[1],
+                        ]
                     elif self.boundaryType == 'minrect':
                         mr = cv2.minAreaRect(tmpSeg)
                         segmentation = [int(xx) for xx in cv2.boxPoints(mr)]
                     _seg = np.array(segmentation).reshape(-1, 2)
-                    logging.debug(f'Segmentation: \n{_seg} \nafter translating \n{seg}\nto {x}, {y}')
+                    logging.debug(
+                        f'Segmentation: \n{_seg} \nafter translating \n{seg}\nto {x}, {y}'
+                    )
                     if len(_seg) == 0:
-                        logging.debug(f'Segmentation empty for ({x},{y}): {seg}')
+                        logging.debug(
+                            f'Segmentation empty for ({x},{y}): {seg}'
+                        )
                         continue
                     if self.displayCoco:
                         cv2.drawContours(sqImg, [_seg], -1, (0, 0, 255))
-                        cv2.rectangle(sqImg, (bbox[0], bbox[1]),
-                                      (bbox[0] + bbox[2], bbox[1] + bbox[3]),
-                                      (0, 255, 255))
+                        cv2.rectangle(
+                            sqImg,
+                            (bbox[0], bbox[1]),
+                            (bbox[0] + bbox[2], bbox[1] + bbox[3]),
+                            (0, 255, 255),
+                        )
                     annotation = {
                         "id": segId,
                         "image_id": imgId,
                         "category_id": 1,
                         "segmentation": [segmentation],
                         "area": cv2.contourArea(tmpSeg),
                         "bbox": bbox,
-                        "iscrowd": 0
+                        "iscrowd": 0,
                     }
                     coco['annotations'].append(annotation)
                     segId += 1
                 if not anyValidSeg:
                     continue
-                cv2.imwrite(os.path.join(imdir, fname),
-                            sqImg)
-                coco['images'].append({
-                    "license": 0,
-                    "url": None,
-                    "file_name": f"PNGImages/{fname}",
-                    "height": self.inputImageSize,
-                    "width": self.inputImageSize,
-                    "date_captured": None,
-                    "id": imgId
-                })
+                cv2.imwrite(os.path.join(imdir, fname), sqImg)
+                coco['images'].append(
+                    {
+                        "license": 0,
+                        "url": None,
+                        "file_name": f"PNGImages/{fname}",
+                        "height": self.inputImageSize,
+                        "width": self.inputImageSize,
+                        "date_captured": None,
+                        "id": imgId,
+                    }
+                )
                 if self.displayCoco:
                     winname = 'cvwin'
-                    title = f'{fname}. Press `Esc` or `q` to hide. '  \
-                            f'Any other key to fast forward.'
+                    title = (
+                        f'{fname}. Press `Esc` or `q` to hide. '
+                        f'Any other key to fast forward.'
+                    )
                     cv2.namedWindow(winname, cv2.WINDOW_NORMAL)
                     cv2.resizeWindow(winname, 800, 600)
                     cv2.imshow(winname, sqImg)
                     cv2.setWindowTitle(winname, title)
                     key = cv2.waitKey(1000)
                     if key == 27 or key == ord('q'):
                         self.displayCoco = False
@@ -1213,80 +1325,100 @@
 
     def saveSegmentation(self):
         saveDir = settings.value('training/savedir', '.')
         filename, _ = qw.QFileDialog.getSaveFileName(
             self,
             'Save current segmentation data',
             directory=saveDir,
-            filter='Pickle file (*.pkl *.pickle);;All files (*)')
+            filter='Pickle file (*.pkl *.pickle);;All files (*)',
+        )
         if len(filename) == 0:
             return
-        data = {'image_dir': self.imageDir,
-                'seg_dict': {fpath: seg for fpath, seg in self.segDict.items()}}
+        data = {
+            'image_dir': self.imageDir,
+            'seg_dict': {fpath: seg for fpath, seg in self.segDict.items()},
+        }
         with open(filename, 'wb') as fd:
             pickle.dump(data, fd)
         settings.setValue('training/savedir', os.path.dirname(filename))
         self.saved = True
 
     def loadSegmentation(self):
         saveDir = settings.value('training/savedir', '.')
         filename, _ = qw.QFileDialog.getOpenFileName(
-            self, 'Load saved segmentation', directory=saveDir,
-            filter='Pickle file (*.pkl *.pickle);;All files (*)')
+            self,
+            'Load saved segmentation',
+            directory=saveDir,
+            filter='Pickle file (*.pkl *.pickle);;All files (*)',
+        )
         if len(filename) == 0:
             return
         with open(filename, 'rb') as fd:
             data = pickle.load(fd)
             self.imageDir = data['image_dir']
             segDict = data['seg_dict']
-            self.imageFiles = [entry.path for entry in os.scandir(self.imageDir) if os.path.isfile(entry.path)]
+            self.imageFiles = [
+                entry.path
+                for entry in os.scandir(self.imageDir)
+                if os.path.isfile(entry.path)
+            ]
             for key in list(segDict.keys()):
                 if key not in self.imageFiles:
                     segDict.pop(key)
             self.segDict = {fpath: seg for fpath, seg in segDict.items()}
         settings.setValue('training/savedir', os.path.dirname(filename))
         self.gotoFrame(0)
 
     @qc.pyqtSlot()
     def extractFrames(self):
         """Extract frames from a video and open the extraction directory for
         annotating images"""
         saveDir = settings.value('training/savedir', '.')
 
         filename, _ = qw.QFileDialog.getOpenFileName(
-                self, 'Load video', directory=saveDir,
-                filter='Video file (*.avi *.mp4 *.mpg *.mpeg *.ogg *.webm *.wmv'
-                       ' *.mov);;All files (*)')
+            self,
+            'Load video',
+            directory=saveDir,
+            filter='Video file (*.avi *.mp4 *.mpg *.mpeg *.ogg *.webm *.wmv'
+            ' *.mov);;All files (*)',
+        )
         if len(filename) == 0:
             return
-        nframes, ok = qw.QInputDialog.getInt(self, 'Extract frames',
-                                         'Number of frames to extract',
-                                         const.EXTRACT_FRAMES, min=0)
+        nframes, ok = qw.QInputDialog.getInt(
+            self,
+            'Extract frames',
+            'Number of frames to extract',
+            const.EXTRACT_FRAMES,
+            min=0,
+        )
         if not ok:
             return
-        scale, _ =  qw.QInputDialog.getDouble(self, 'Extract frames',
-                                         'Scale each frame X',
-                                         1.0, min=0.1)
+        print('Number of frames', nframes)
+        scale, _ = qw.QInputDialog.getDouble(
+            self, 'Extract frames', 'Scale each frame X', 1.0, min=0.1
+        )
         if not ok:
             return
-        random = qw.QMessageBox.question(self, 'Random frames?',
-                                         'Select random frames?',
-                                         qw.QMessageBox.Yes | qw.QMessageBox.No)
-        extractDir = qw.QFileDialog.getExistingDirectory(self,
-            'Extract frames into directory',
-            saveDir
+        qw.QMessageBox.question(
+            self,
+            'Random frames?',
+            'Select random frames?',
+            qw.QMessageBox.Yes | qw.QMessageBox.No,
+        )
+        extractDir = qw.QFileDialog.getExistingDirectory(
+            self, 'Extract frames into directory', saveDir
         )
         if len(extractDir) == 0:
             return
-        ut.extract_frames(filename, nframes, scale, extractDir,
-                          random=qw.QMessageBox.Yes)
+        ut.extract_frames(
+            filename, nframes, scale, extractDir, random=qw.QMessageBox.Yes
+        )
         self._openImageDir(extractDir)
 
 
-
 if __name__ == '__main__':
     app = qw.QApplication(sys.argv)
     win = TrainingWidget()
     win.setMinimumSize(800, 600)
     win.setWindowTitle('Argos - generate training data')
     win.showMaximized()
     app.aboutToQuit.connect(win.cleanup)
```

### Comparing `argos_toolkit-0.1.3.post3/argos/batch_motion_track.py` & `argos_toolkit-0.2.0/argos/batch_motion_track.py`

 * *Files identical despite different names*

### Comparing `argos_toolkit-0.1.3.post3/argos/batchtrack_queue.py` & `argos_toolkit-0.2.0/argos/batchtrack_queue.py`

 * *Files identical despite different names*

### Comparing `argos_toolkit-0.1.3.post3/argos/breeze_resources.py` & `argos_toolkit-0.2.0/argos/breeze_resources.py`

 * *Files identical despite different names*

### Comparing `argos_toolkit-0.1.3.post3/argos/capture.py` & `argos_toolkit-0.2.0/argos/capture.py`

 * *Files identical despite different names*

### Comparing `argos_toolkit-0.1.3.post3/argos/capture.updated.py` & `argos_toolkit-0.2.0/argos/capture.updated.py`

 * *Files identical despite different names*

### Comparing `argos_toolkit-0.1.3.post3/argos/caputil.py` & `argos_toolkit-0.2.0/argos/caputil.py`

 * *Files identical despite different names*

### Comparing `argos_toolkit-0.1.3.post3/argos/ccapture.pyx` & `argos_toolkit-0.2.0/argos/ccapture.updated.pyx`

 * *Files 0% similar despite different names*

```diff
@@ -247,17 +247,17 @@
                 tswriter.writerow([read_frames - 1, writ_frames - 1, tstring])
                 if max_frames > 0:
                     writ_frames = (writ_frames + 1) % max_frames
                 else:
                     writ_frames += 1
                 if interactive:
                     cv2.imshow(outfname, roi)
-                    key = cv2.waitKey(1) & 0xFF
-                    if key == ord('q') or key == 27:
-                       break
+            key = cv2.waitKey(1) & 0xFF
+            if key == ord('q') or key == 27:
+                break
     except KeyboardInterrupt:
         print('Caught keyboard interrupt')
     except FileNotFoundError:
         print('Could not find one or more file paths')
     finally:
         cap.release()
         if (outfile is not None) and outfile.isOpened():
```

### Comparing `argos_toolkit-0.1.3.post3/argos/ccapture.updated.pyx` & `argos_toolkit-0.2.0/argos/ccapture.pyx`

 * *Files 1% similar despite different names*

```diff
@@ -92,15 +92,15 @@
                     int kernel_width,                    
                     bint timestamp,
                     bint show_diff,
                     cnp.ndarray[int] tb,
                     cnp.ndarray[int] tc,
                     int tx,
                     int ty,
-                    float fs
+                    double fs
                     ):
 
     cdef int w_
     cdef int h_
     # cdef cnp.ndarray[unsigned char, ndim=2] frame 
     cdef cnp.ndarray[unsigned char, ndim=2] cur_blurred
     cdef cnp.ndarray[unsigned char, ndim=2] prev_blurred
@@ -247,17 +247,17 @@
                 tswriter.writerow([read_frames - 1, writ_frames - 1, tstring])
                 if max_frames > 0:
                     writ_frames = (writ_frames + 1) % max_frames
                 else:
                     writ_frames += 1
                 if interactive:
                     cv2.imshow(outfname, roi)
-            key = cv2.waitKey(1) & 0xFF
-            if key == ord('q') or key == 27:
-                break
+                    key = cv2.waitKey(1) & 0xFF
+                    if key == ord('q') or key == 27:
+                       break
     except KeyboardInterrupt:
         print('Caught keyboard interrupt')
     except FileNotFoundError:
         print('Could not find one or more file paths')
     finally:
         cap.release()
         if (outfile is not None) and outfile.isOpened():
```

### Comparing `argos_toolkit-0.1.3.post3/argos/constants.py` & `argos_toolkit-0.2.0/argos/constants.py`

 * *Files identical despite different names*

### Comparing `argos_toolkit-0.1.3.post3/argos/csrtracker.py` & `argos_toolkit-0.2.0/argos/csrtracker.py`

 * *Files 2% similar despite different names*

```diff
@@ -8,15 +8,18 @@
 ===================================================================
 
 """
 import logging
 from typing import Tuple
 import numpy as np
 import cv2
-from PyQt5 import QtCore as qc, QtWidgets as qw
+from PyQt5 import (
+    QtCore as qc,
+    QtWidgets as qw
+)
 
 from argos.utility import match_bboxes, pairwise_distance, init
 from argos.constants import OutlineStyle, DistanceMetric
 
 settings = init()
 
 
@@ -49,23 +52,17 @@
 
 class CSRMultiTracker(qc.QObject):
 
     sigTracked = qc.pyqtSignal(dict, int)
 
     def __init__(self, *args, **kwargs):
         super(CSRMultiTracker, self).__init__(*args, **kwargs)
-        self.checkAge = settings.value(
-            'csrt/checkAge', 10, type=int
-        )  # check against segmentation after these many frames
-        self.checkSeq = settings.value(
-            'csrt/checkSeq', 1, type=int
-        )  # keep checking for these many frames for missing objects
-        self.missLimit = settings.value(
-            'csrt/missLimit', 3, type=int
-        )  # delete tracker after these many misses
+        self.checkAge = settings.value('csrt/checkAge', 10, type=int)  # check against segmentation after these many frames
+        self.checkSeq = settings.value('csrt/checkSeq', 1, type=int)  # keep checking for these many frames for missing objects
+        self.missLimit = settings.value('csrt/missLimit', 3, type=int)  # delete tracker after these many misses
         self.maxDist = settings.value('csrt/maxDist', 0.3, type=float)
         if settings.value('csrt/distMetric', 'iou', type=str) == 'euclidean':
             self.distMetric = DistanceMetric.euclidean
         else:
             self.distMetric = DistanceMetric.iou
         # dynamic variables
         self.trackers = {}
@@ -79,26 +76,24 @@
         logging.debug(f'=== Added tracker {tracker.id_} for bbox: {bbox}')
         self._next_id += 1
         return tracker.id_
 
     def find_nonoverlapping(self, bboxes):
         """Remove entries which are within `maxDist` distance from another bbox
         considering them to be the same object detected twice."""
-        if bboxes.size > 0:
-            dist = pairwise_distance(
-                bboxes, bboxes, OutlineStyle.bbox, DistanceMetric.iou
-            )
-            close_row, close_col = np.where(dist <= self.maxDist)
-            ignore = close_col[close_col > close_row]
-            if len(ignore) > 0:
-                logging.debug(f'Ignore {ignore}')
-            valid_idx = set(list(range(bboxes.shape[0]))) - set(ignore)
-            logging.debug(f'Valid indices: {valid_idx}')
-            return bboxes[list(valid_idx)].copy()
-        return np.empty(0)
+        dist = pairwise_distance(bboxes, bboxes,
+                                 OutlineStyle.bbox,
+                                 DistanceMetric.iou)
+        close_row, close_col = np.where(dist <= self.maxDist)
+        ignore = close_col[close_col > close_row]
+        if len(ignore) > 0:
+            logging.debug(f'Ignore {ignore}')
+        valid_idx = set(list(range(bboxes.shape[0]))) - set(ignore)
+        logging.debug(f'Valid indices: {valid_idx}')
+        return bboxes[list(valid_idx)].copy()
 
     @qc.pyqtSlot(np.ndarray, np.ndarray, int)
     def track(self, frame: np.ndarray, bboxes: np.ndarray, pos: int) -> None:
         """Track objects in frame, possibly comparing them to bounding boxes
         in ``bboxes``
 
         This uses a hybrid of CSRT with Hungarian algorithm.
@@ -117,61 +112,49 @@
             frame.
         """
         # Now do the checks for trackers that are off target
 
         self.age += 1
         if len(self.trackers) == 0 and bboxes.size > 0:
             valid = self.find_nonoverlapping(bboxes)
-            ret = {
-                self._add_tracker(frame, valid[ii]): valid[ii]
-                for ii in range(valid.shape[0])
-            }
+            ret = {self._add_tracker(frame, valid[ii]): valid[ii]
+                   for ii in range(valid.shape[0])}
             logging.debug(f'==== Added initial trackers \n{ret}')
             self.sigTracked.emit(ret, pos)
             return
 
-        predicted = {
-            id_: tracker.update(frame)
-            for id_, tracker in self.trackers.items()
-        }
+        predicted = {id_: tracker.update(frame)
+                     for id_, tracker in self.trackers.items()}
         self.sigTracked.emit(predicted, pos)
         if self.age > self.checkAge:
             valid = self.find_nonoverlapping(bboxes)
             matched, new_unmatched, old_unmatched = match_bboxes(
-                predicted,
-                valid,
-                boxtype=OutlineStyle.bbox,
+                predicted, valid, boxtype=OutlineStyle.bbox,
                 metric=self.distMetric,
-                max_dist=self.maxDist,
-            )
+                max_dist=self.maxDist)
             logging.debug(f'==== matching bboxes Frame: {pos} ====')
-            logging.debug(
-                f'Input bboxes: {valid}\n'
-                f'Matched: {matched}\n'
-                f'New unmatched: {new_unmatched}\n'
-                f'Old unmatched: {old_unmatched}'
-            )
+            logging.debug(f'Input bboxes: {valid}\n'
+                          f'Matched: {matched}\n'
+                          f'New unmatched: {new_unmatched}\n'
+                          f'Old unmatched: {old_unmatched}')
             # Renitialize trackers that matched to closest bounding box
             for tid, idx in matched.items():
                 self.trackers[tid].reinit(frame, valid[idx])
             # Increase miss count for unmatched trackers
             for tid in old_unmatched:
                 self.trackers[tid].misses += 1
             # Add trackers for bboxes that did not match any tracker
             for idx in new_unmatched:
                 self._add_tracker(frame, valid[idx])
             self.check_count += 1
         # Remove the trackers that missed too many times - only after we have
         # given them `checkSeq` chances for rematching
         if self.check_count >= self.checkSeq:
-            self.trackers = {
-                tid: tracker
-                for tid, tracker in self.trackers.items()
-                if tracker.misses < self.missLimit
-            }
+            self.trackers = {tid: tracker for tid, tracker in self.trackers.items()
+                             if tracker.misses < self.missLimit}
             self.age = 0
             self.check_count = 0
 
     @qc.pyqtSlot(int)
     def setCheckAge(self, age: int) -> None:
         self.checkAge = age
 
@@ -191,14 +174,15 @@
     def setDistMetric(self, metric: str) -> None:
         if metric.lower() == 'iou':
             self.distMetric = DistanceMetric.iou
         elif metric.lower() == 'euclidean':
             self.distMetric = DistanceMetric.euclidean
         else:
             raise ValueError(f'Unknown distance metric {metric}')
+            
 
     @qc.pyqtSlot()
     def reset(self):
         self.trackers = {}
         self._next_id = 1
         self.age = 0
         self.check_count = 0
@@ -214,15 +198,14 @@
     any of the segmentation widgets via ``sigProcessed`` signal, we need to
     synchronize them. This is done by two slots, ``setFrame`` and ``setBboxes``
     which, track the frame position for the image and that for the bboxes
     and emits the data via ``sigTrack`` when the two match. The position
     variables are reset after that.
 
     """
-
     sigTrack = qc.pyqtSignal(np.ndarray, np.ndarray, int)
     sigTracked = qc.pyqtSignal(dict, int)
     sigQuit = qc.pyqtSignal()
     sigReset = qc.pyqtSignal()
 
     def __init__(self, *args, **kwargs):
         super(CSRTWidget, self).__init__(*args, **kwargs)
@@ -231,74 +214,63 @@
         self._framePos = -1
         self._bboxes = None
         self._bboxesPos = -1
         layout = qw.QFormLayout()
         self._checkAgeLabel = qw.QLabel('Check after every N frames')
         self._checkAgeSpin = qw.QSpinBox()
         self._checkAgeSpin.setRange(0, 100)
-        value = settings.value(
-            'csrt/checkAge', self.tracker.checkAge, type=int
-        )
+        value = settings.value('csrt/checkAge', self.tracker.checkAge,
+                               type=int)
         self.tracker.checkAge = value
         self._checkAgeSpin.setValue(value)
-        self._checkAgeSpin.setToolTip(
-            'Verify tracked bounding boxes against'
-            ' segmented bounding boxes every this'
-            ' many frames. Remove or reinitialize'
-            ' tracks that are off.'
-        )
+        self._checkAgeSpin.setToolTip('Verify tracked bounding boxes against'
+                                        ' segmented bounding boxes every this'
+                                        ' many frames. Remove or reinitialize'
+                                        ' tracks that are off.')
         layout.addRow(self._checkAgeLabel, self._checkAgeSpin)
         self._checkSeqLabel = qw.QLabel('# of checks')
         self._checkSeqSpin = qw.QSpinBox()
         self._checkSeqSpin.setRange(0, 100)
-        value = settings.value(
-            'csrt/checkSeq', self.tracker.checkSeq, type=int
-        )
+        value = settings.value('csrt/checkSeq', self.tracker.checkSeq,
+                               type=int)
         self._checkSeqSpin.setValue(value)
         self.tracker.checkSeq = value
-        self._checkSeqSpin.setToolTip(
-            'Try this many times before removing a' ' failed tracker.'
-        )
+        self._checkSeqSpin.setToolTip('Try this many times before removing a'
+                                        ' failed tracker.')
         layout.addRow(self._checkSeqLabel, self._checkSeqSpin)
         self._missLimitLabel = qw.QLabel('Miss limit')
         self._missLimitSpin = qw.QSpinBox()
-        self._missLimitSpin.setToolTip(
-            'Number of misses before a tracker is' ' removed.'
-        )
+        self._missLimitSpin.setToolTip('Number of misses before a tracker is'
+                                         ' removed.')
         self._missLimitSpin.setRange(1, 100)
-        value = settings.value(
-            'csrt/missLimit', self.tracker.missLimit, type=int
-        )
+        value = settings.value('csrt/missLimit', self.tracker.missLimit,
+                               type=int)
         self._missLimitSpin.setValue(value)
         self.tracker.missLimit = value
         layout.addRow(self._missLimitLabel, self._missLimitSpin)
         self._maxDistLabel = qw.QLabel('Minimum separation')
         self._maxDistSpin = qw.QDoubleSpinBox()
-        self._maxDistSpin.setToolTip(
-            'Minimum separation between a tracker and'
-            ' its closest bounding box to consider'
-            ' them to be separate objects.'
-        )
+        self._maxDistSpin.setToolTip('Minimum separation between a tracker and'
+                                       ' its closest bounding box to consider'
+                                       ' them to be separate objects.')
         self._maxDistSpin.setValue(self.tracker.maxDist)
         layout.addRow(self._maxDistLabel, self._maxDistSpin)
         self._distMetricLabel = qw.QLabel('Distance metric')
         self._distMetricCombo = qw.QComboBox(self)
         self._distMetricCombo.addItems(['IoU', 'Euclidean'])
         if self.tracker.distMetric == DistanceMetric.iou:
             self._distMetricCombo.setCurrentText('IoU')
         else:
             self._distMetricCombo.setCurrentText('Euclidean')
         self._distMetricCombo.setToolTip(
-            'Distance metric to use for measuring proximity'
-        )
+            'Distance metric to use for measuring proximity')
         layout.addRow(self._distMetricLabel, self._distMetricCombo)
         self._disableCheck = qw.QCheckBox('Disable tracking')
-        self._disableCheck.setToolTip(
-            'Directly show segmentation results ' 'without any tracking'
-        )
+        self._disableCheck.setToolTip('Directly show segmentation results '
+                                      'without any tracking')
         layout.addWidget(self._disableCheck)
         self.setLayout(layout)
         ################
         self.thread = qc.QThread()
         self.tracker.moveToThread(self.thread)
         self.sigTrack.connect(self.tracker.track)
         self.tracker.sigTracked.connect(self.sigTracked)
@@ -307,56 +279,54 @@
         self.sigQuit.connect(self.thread.quit)
         self.thread.finished.connect(self.thread.deleteLater)
         self._checkAgeSpin.valueChanged.connect(self.tracker.setCheckAge)
         self._checkSeqSpin.valueChanged.connect(self.tracker.setCheckSeq)
         self._missLimitSpin.valueChanged.connect(self.tracker.setMissLimit)
         self._maxDistSpin.valueChanged.connect(self.tracker.setMaxDist)
         self._distMetricCombo.currentTextChanged.connect(
-            self.tracker.setDistMetric
-        )
+            self.tracker.setDistMetric)
         self.thread.start()
 
     @qc.pyqtSlot(np.ndarray, int)
     def setFrame(self, frame: np.ndarray, pos: int) -> None:
         """Slot to store video frame and frame position, and signal the tracker
         if the bboxes for the same frame are available"""
         logging.debug(f'Received frame: {pos}')
         if self._disableCheck.isChecked():
             return
         self._frame = frame
         self._framePos = pos
         if self._framePos >= 0 and self._framePos == self._bboxesPos:
             logging.debug(f'Emitting signal for frame {self._framePos}')
-            self.sigTrack.emit(self._frame, self._bboxes, self._framePos)
+            self.sigTrack.emit(self._frame, self._bboxes,
+                               self._framePos)
             self._framePos = -1
             self._bboxesPos = -1
 
     @qc.pyqtSlot(np.ndarray, int)
     def setBboxes(self, bboxes: np.ndarray, pos: int) -> None:
         """Slot to store bounding boxes and frame position, and signal the
         tracker if the image for the same frame is available"""
         logging.debug(f'Received bboxes: {pos}')
         if self._disableCheck.isChecked():
-            self.sigTracked.emit(
-                {ii: bboxes[ii] for ii in range(bboxes.shape[0])}, pos
-            )
+            self.sigTracked.emit({ii: bboxes[ii]
+                                  for ii in range(bboxes.shape[0])},
+                                 pos)
             return
         self._bboxes = bboxes
         self._bboxesPos = pos
         if self._framePos >= 0 and self._framePos == self._bboxesPos:
             logging.debug(f'Emitting signal for frame {self._framePos}')
-            self.sigTrack.emit(self._frame, self._bboxes, self._framePos)
+            self.sigTrack.emit(self._frame, self._bboxes,
+                               self._framePos)
             self._framePos = -1
             self._bboxesPos = -1
 
     @qc.pyqtSlot()
     def saveSettings(self):
         settings.setValue('csrt/checkAge', self.tracker.checkAge)
         settings.setValue('csrt/checkSeq', self.tracker.checkSeq)
         settings.setValue('csrt/missLimit', self.tracker.missLimit)
         settings.setValue('csrt/maxDist', self.tracker.maxDist)
-        settings.setValue(
-            'csrt/distMetric',
-            'iou'
-            if self.tracker.distMetric == DistanceMetric.iou
-            else 'euclidean',
-        )
+        settings.setValue('csrt/distMetric',
+                          'iou' if self.tracker.distMetric == DistanceMetric.iou
+                          else 'euclidean')
```

### Comparing `argos_toolkit-0.1.3.post3/argos/cutility.c` & `argos_toolkit-0.2.0/yolact/utils/cython_nms.c`

 * *Files 12% similar despite different names*

```diff
@@ -1,48 +1,65 @@
-/* Generated by Cython 0.29.32 */
+/* Generated by Cython 3.0.10 */
 
 /* BEGIN: Cython Metadata
 {
     "distutils": {
         "depends": [
-            "C:\\Users\\raysu\\AppData\\Local\\Temp\\build-env-e1goy0pt\\lib\\site-packages\\numpy\\core\\include\\numpy\\arrayobject.h",
-            "C:\\Users\\raysu\\AppData\\Local\\Temp\\build-env-e1goy0pt\\lib\\site-packages\\numpy\\core\\include\\numpy\\arrayscalars.h",
-            "C:\\Users\\raysu\\AppData\\Local\\Temp\\build-env-e1goy0pt\\lib\\site-packages\\numpy\\core\\include\\numpy\\ndarrayobject.h",
-            "C:\\Users\\raysu\\AppData\\Local\\Temp\\build-env-e1goy0pt\\lib\\site-packages\\numpy\\core\\include\\numpy\\ndarraytypes.h",
-            "C:\\Users\\raysu\\AppData\\Local\\Temp\\build-env-e1goy0pt\\lib\\site-packages\\numpy\\core\\include\\numpy\\ufuncobject.h"
+            "C:\\Users\\raysu\\AppData\\Local\\Temp\\build-env-dz0q5375\\Lib\\site-packages\\numpy\\core\\include\\numpy\\arrayobject.h",
+            "C:\\Users\\raysu\\AppData\\Local\\Temp\\build-env-dz0q5375\\Lib\\site-packages\\numpy\\core\\include\\numpy\\arrayscalars.h",
+            "C:\\Users\\raysu\\AppData\\Local\\Temp\\build-env-dz0q5375\\Lib\\site-packages\\numpy\\core\\include\\numpy\\ndarrayobject.h",
+            "C:\\Users\\raysu\\AppData\\Local\\Temp\\build-env-dz0q5375\\Lib\\site-packages\\numpy\\core\\include\\numpy\\ndarraytypes.h",
+            "C:\\Users\\raysu\\AppData\\Local\\Temp\\build-env-dz0q5375\\Lib\\site-packages\\numpy\\core\\include\\numpy\\ufuncobject.h"
         ],
         "include_dirs": [
-            "C:\\Users\\raysu\\AppData\\Local\\Temp\\build-env-e1goy0pt\\lib\\site-packages\\numpy\\core\\include"
+            "C:\\Users\\raysu\\AppData\\Local\\Temp\\build-env-dz0q5375\\Lib\\site-packages\\numpy\\core\\include"
         ],
-        "name": "argos.cutility",
+        "name": "yolact.utils.cython_nms",
         "sources": [
-            "argos/cutility.pyx"
+            "yolact/utils/cython_nms.pyx"
         ]
     },
-    "module_name": "argos.cutility"
+    "module_name": "yolact.utils.cython_nms"
 }
 END: Cython Metadata */
 
 #ifndef PY_SSIZE_T_CLEAN
 #define PY_SSIZE_T_CLEAN
 #endif /* PY_SSIZE_T_CLEAN */
+#if defined(CYTHON_LIMITED_API) && 0
+  #ifndef Py_LIMITED_API
+    #if CYTHON_LIMITED_API+0 > 0x03030000
+      #define Py_LIMITED_API CYTHON_LIMITED_API
+    #else
+      #define Py_LIMITED_API 0x03030000
+    #endif
+  #endif
+#endif
+
 #include "Python.h"
 #ifndef Py_PYTHON_H
     #error Python headers needed to compile C extensions, please install development version of Python.
-#elif PY_VERSION_HEX < 0x02060000 || (0x03000000 <= PY_VERSION_HEX && PY_VERSION_HEX < 0x03030000)
-    #error Cython requires Python 2.6+ or Python 3.3+.
+#elif PY_VERSION_HEX < 0x02070000 || (0x03000000 <= PY_VERSION_HEX && PY_VERSION_HEX < 0x03030000)
+    #error Cython requires Python 2.7+ or Python 3.3+.
 #else
-#define CYTHON_ABI "0_29_32"
-#define CYTHON_HEX_VERSION 0x001D20F0
-#define CYTHON_FUTURE_DIVISION 0
+#if defined(CYTHON_LIMITED_API) && CYTHON_LIMITED_API
+#define __PYX_EXTRA_ABI_MODULE_NAME "limited"
+#else
+#define __PYX_EXTRA_ABI_MODULE_NAME ""
+#endif
+#define CYTHON_ABI "3_0_10" __PYX_EXTRA_ABI_MODULE_NAME
+#define __PYX_ABI_MODULE_NAME "_cython_" CYTHON_ABI
+#define __PYX_TYPE_MODULE_PREFIX __PYX_ABI_MODULE_NAME "."
+#define CYTHON_HEX_VERSION 0x03000AF0
+#define CYTHON_FUTURE_DIVISION 1
 #include <stddef.h>
 #ifndef offsetof
   #define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
 #endif
-#if !defined(WIN32) && !defined(MS_WINDOWS)
+#if !defined(_WIN32) && !defined(WIN32) && !defined(MS_WINDOWS)
   #ifndef __stdcall
     #define __stdcall
   #endif
   #ifndef __cdecl
     #define __cdecl
   #endif
   #ifndef __fastcall
@@ -53,31 +70,35 @@
   #define DL_IMPORT(t) t
 #endif
 #ifndef DL_EXPORT
   #define DL_EXPORT(t) t
 #endif
 #define __PYX_COMMA ,
 #ifndef HAVE_LONG_LONG
-  #if PY_VERSION_HEX >= 0x02070000
-    #define HAVE_LONG_LONG
-  #endif
+  #define HAVE_LONG_LONG
 #endif
 #ifndef PY_LONG_LONG
   #define PY_LONG_LONG LONG_LONG
 #endif
 #ifndef Py_HUGE_VAL
   #define Py_HUGE_VAL HUGE_VAL
 #endif
-#ifdef PYPY_VERSION
-  #define CYTHON_COMPILING_IN_PYPY 1
-  #define CYTHON_COMPILING_IN_PYSTON 0
+#define __PYX_LIMITED_VERSION_HEX PY_VERSION_HEX
+#if defined(GRAALVM_PYTHON)
+  /* For very preliminary testing purposes. Most variables are set the same as PyPy.
+     The existence of this section does not imply that anything works or is even tested */
+  #define CYTHON_COMPILING_IN_PYPY 0
   #define CYTHON_COMPILING_IN_CPYTHON 0
+  #define CYTHON_COMPILING_IN_LIMITED_API 0
+  #define CYTHON_COMPILING_IN_GRAAL 1
   #define CYTHON_COMPILING_IN_NOGIL 0
   #undef CYTHON_USE_TYPE_SLOTS
   #define CYTHON_USE_TYPE_SLOTS 0
+  #undef CYTHON_USE_TYPE_SPECS
+  #define CYTHON_USE_TYPE_SPECS 0
   #undef CYTHON_USE_PYTYPE_LOOKUP
   #define CYTHON_USE_PYTYPE_LOOKUP 0
   #if PY_VERSION_HEX < 0x03050000
     #undef CYTHON_USE_ASYNC_SLOTS
     #define CYTHON_USE_ASYNC_SLOTS 0
   #elif !defined(CYTHON_USE_ASYNC_SLOTS)
     #define CYTHON_USE_ASYNC_SLOTS 1
@@ -94,141 +115,253 @@
   #define CYTHON_AVOID_BORROWED_REFS 1
   #undef CYTHON_ASSUME_SAFE_MACROS
   #define CYTHON_ASSUME_SAFE_MACROS 0
   #undef CYTHON_UNPACK_METHODS
   #define CYTHON_UNPACK_METHODS 0
   #undef CYTHON_FAST_THREAD_STATE
   #define CYTHON_FAST_THREAD_STATE 0
+  #undef CYTHON_FAST_GIL
+  #define CYTHON_FAST_GIL 0
+  #undef CYTHON_METH_FASTCALL
+  #define CYTHON_METH_FASTCALL 0
   #undef CYTHON_FAST_PYCALL
   #define CYTHON_FAST_PYCALL 0
+  #ifndef CYTHON_PEP487_INIT_SUBCLASS
+    #define CYTHON_PEP487_INIT_SUBCLASS (PY_MAJOR_VERSION >= 3)
+  #endif
   #undef CYTHON_PEP489_MULTI_PHASE_INIT
-  #define CYTHON_PEP489_MULTI_PHASE_INIT 0
+  #define CYTHON_PEP489_MULTI_PHASE_INIT 1
+  #undef CYTHON_USE_MODULE_STATE
+  #define CYTHON_USE_MODULE_STATE 0
   #undef CYTHON_USE_TP_FINALIZE
   #define CYTHON_USE_TP_FINALIZE 0
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
   #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
-    #define CYTHON_UPDATE_DESCRIPTOR_DOC (PYPY_VERSION_HEX >= 0x07030900)
+    #define CYTHON_UPDATE_DESCRIPTOR_DOC 0
   #endif
-#elif defined(PYSTON_VERSION)
-  #define CYTHON_COMPILING_IN_PYPY 0
-  #define CYTHON_COMPILING_IN_PYSTON 1
+  #undef CYTHON_USE_FREELISTS
+  #define CYTHON_USE_FREELISTS 0
+#elif defined(PYPY_VERSION)
+  #define CYTHON_COMPILING_IN_PYPY 1
   #define CYTHON_COMPILING_IN_CPYTHON 0
+  #define CYTHON_COMPILING_IN_LIMITED_API 0
+  #define CYTHON_COMPILING_IN_GRAAL 0
   #define CYTHON_COMPILING_IN_NOGIL 0
-  #ifndef CYTHON_USE_TYPE_SLOTS
-    #define CYTHON_USE_TYPE_SLOTS 1
+  #undef CYTHON_USE_TYPE_SLOTS
+  #define CYTHON_USE_TYPE_SLOTS 0
+  #ifndef CYTHON_USE_TYPE_SPECS
+    #define CYTHON_USE_TYPE_SPECS 0
+  #endif
+  #undef CYTHON_USE_PYTYPE_LOOKUP
+  #define CYTHON_USE_PYTYPE_LOOKUP 0
+  #if PY_VERSION_HEX < 0x03050000
+    #undef CYTHON_USE_ASYNC_SLOTS
+    #define CYTHON_USE_ASYNC_SLOTS 0
+  #elif !defined(CYTHON_USE_ASYNC_SLOTS)
+    #define CYTHON_USE_ASYNC_SLOTS 1
+  #endif
+  #undef CYTHON_USE_PYLIST_INTERNALS
+  #define CYTHON_USE_PYLIST_INTERNALS 0
+  #undef CYTHON_USE_UNICODE_INTERNALS
+  #define CYTHON_USE_UNICODE_INTERNALS 0
+  #undef CYTHON_USE_UNICODE_WRITER
+  #define CYTHON_USE_UNICODE_WRITER 0
+  #undef CYTHON_USE_PYLONG_INTERNALS
+  #define CYTHON_USE_PYLONG_INTERNALS 0
+  #undef CYTHON_AVOID_BORROWED_REFS
+  #define CYTHON_AVOID_BORROWED_REFS 1
+  #undef CYTHON_ASSUME_SAFE_MACROS
+  #define CYTHON_ASSUME_SAFE_MACROS 0
+  #undef CYTHON_UNPACK_METHODS
+  #define CYTHON_UNPACK_METHODS 0
+  #undef CYTHON_FAST_THREAD_STATE
+  #define CYTHON_FAST_THREAD_STATE 0
+  #undef CYTHON_FAST_GIL
+  #define CYTHON_FAST_GIL 0
+  #undef CYTHON_METH_FASTCALL
+  #define CYTHON_METH_FASTCALL 0
+  #undef CYTHON_FAST_PYCALL
+  #define CYTHON_FAST_PYCALL 0
+  #ifndef CYTHON_PEP487_INIT_SUBCLASS
+    #define CYTHON_PEP487_INIT_SUBCLASS (PY_MAJOR_VERSION >= 3)
   #endif
+  #if PY_VERSION_HEX < 0x03090000
+    #undef CYTHON_PEP489_MULTI_PHASE_INIT
+    #define CYTHON_PEP489_MULTI_PHASE_INIT 0
+  #elif !defined(CYTHON_PEP489_MULTI_PHASE_INIT)
+    #define CYTHON_PEP489_MULTI_PHASE_INIT 1
+  #endif
+  #undef CYTHON_USE_MODULE_STATE
+  #define CYTHON_USE_MODULE_STATE 0
+  #undef CYTHON_USE_TP_FINALIZE
+  #define CYTHON_USE_TP_FINALIZE (PY_VERSION_HEX >= 0x030400a1 && PYPY_VERSION_NUM >= 0x07030C00)
+  #undef CYTHON_USE_DICT_VERSIONS
+  #define CYTHON_USE_DICT_VERSIONS 0
+  #undef CYTHON_USE_EXC_INFO_STACK
+  #define CYTHON_USE_EXC_INFO_STACK 0
+  #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
+    #define CYTHON_UPDATE_DESCRIPTOR_DOC 0
+  #endif
+  #undef CYTHON_USE_FREELISTS
+  #define CYTHON_USE_FREELISTS 0
+#elif defined(CYTHON_LIMITED_API)
+  #ifdef Py_LIMITED_API
+    #undef __PYX_LIMITED_VERSION_HEX
+    #define __PYX_LIMITED_VERSION_HEX Py_LIMITED_API
+  #endif
+  #define CYTHON_COMPILING_IN_PYPY 0
+  #define CYTHON_COMPILING_IN_CPYTHON 0
+  #define CYTHON_COMPILING_IN_LIMITED_API 1
+  #define CYTHON_COMPILING_IN_GRAAL 0
+  #define CYTHON_COMPILING_IN_NOGIL 0
+  #undef CYTHON_CLINE_IN_TRACEBACK
+  #define CYTHON_CLINE_IN_TRACEBACK 0
+  #undef CYTHON_USE_TYPE_SLOTS
+  #define CYTHON_USE_TYPE_SLOTS 0
+  #undef CYTHON_USE_TYPE_SPECS
+  #define CYTHON_USE_TYPE_SPECS 1
   #undef CYTHON_USE_PYTYPE_LOOKUP
   #define CYTHON_USE_PYTYPE_LOOKUP 0
   #undef CYTHON_USE_ASYNC_SLOTS
   #define CYTHON_USE_ASYNC_SLOTS 0
   #undef CYTHON_USE_PYLIST_INTERNALS
   #define CYTHON_USE_PYLIST_INTERNALS 0
-  #ifndef CYTHON_USE_UNICODE_INTERNALS
-    #define CYTHON_USE_UNICODE_INTERNALS 1
+  #undef CYTHON_USE_UNICODE_INTERNALS
+  #define CYTHON_USE_UNICODE_INTERNALS 0
+  #ifndef CYTHON_USE_UNICODE_WRITER
+    #define CYTHON_USE_UNICODE_WRITER 0
   #endif
-  #undef CYTHON_USE_UNICODE_WRITER
-  #define CYTHON_USE_UNICODE_WRITER 0
   #undef CYTHON_USE_PYLONG_INTERNALS
   #define CYTHON_USE_PYLONG_INTERNALS 0
   #ifndef CYTHON_AVOID_BORROWED_REFS
     #define CYTHON_AVOID_BORROWED_REFS 0
   #endif
-  #ifndef CYTHON_ASSUME_SAFE_MACROS
-    #define CYTHON_ASSUME_SAFE_MACROS 1
-  #endif
-  #ifndef CYTHON_UNPACK_METHODS
-    #define CYTHON_UNPACK_METHODS 1
-  #endif
+  #undef CYTHON_ASSUME_SAFE_MACROS
+  #define CYTHON_ASSUME_SAFE_MACROS 0
+  #undef CYTHON_UNPACK_METHODS
+  #define CYTHON_UNPACK_METHODS 0
   #undef CYTHON_FAST_THREAD_STATE
   #define CYTHON_FAST_THREAD_STATE 0
+  #undef CYTHON_FAST_GIL
+  #define CYTHON_FAST_GIL 0
+  #undef CYTHON_METH_FASTCALL
+  #define CYTHON_METH_FASTCALL 0
   #undef CYTHON_FAST_PYCALL
   #define CYTHON_FAST_PYCALL 0
+  #ifndef CYTHON_PEP487_INIT_SUBCLASS
+    #define CYTHON_PEP487_INIT_SUBCLASS 1
+  #endif
   #undef CYTHON_PEP489_MULTI_PHASE_INIT
   #define CYTHON_PEP489_MULTI_PHASE_INIT 0
-  #undef CYTHON_USE_TP_FINALIZE
-  #define CYTHON_USE_TP_FINALIZE 0
+  #undef CYTHON_USE_MODULE_STATE
+  #define CYTHON_USE_MODULE_STATE 1
+  #ifndef CYTHON_USE_TP_FINALIZE
+    #define CYTHON_USE_TP_FINALIZE 0
+  #endif
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
   #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
     #define CYTHON_UPDATE_DESCRIPTOR_DOC 0
   #endif
-#elif defined(PY_NOGIL)
+  #undef CYTHON_USE_FREELISTS
+  #define CYTHON_USE_FREELISTS 0
+#elif defined(Py_GIL_DISABLED) || defined(Py_NOGIL)
   #define CYTHON_COMPILING_IN_PYPY 0
-  #define CYTHON_COMPILING_IN_PYSTON 0
   #define CYTHON_COMPILING_IN_CPYTHON 0
+  #define CYTHON_COMPILING_IN_LIMITED_API 0
+  #define CYTHON_COMPILING_IN_GRAAL 0
   #define CYTHON_COMPILING_IN_NOGIL 1
   #ifndef CYTHON_USE_TYPE_SLOTS
     #define CYTHON_USE_TYPE_SLOTS 1
   #endif
+  #ifndef CYTHON_USE_TYPE_SPECS
+    #define CYTHON_USE_TYPE_SPECS 0
+  #endif
   #undef CYTHON_USE_PYTYPE_LOOKUP
   #define CYTHON_USE_PYTYPE_LOOKUP 0
   #ifndef CYTHON_USE_ASYNC_SLOTS
     #define CYTHON_USE_ASYNC_SLOTS 1
   #endif
+  #ifndef CYTHON_USE_PYLONG_INTERNALS
+    #define CYTHON_USE_PYLONG_INTERNALS 0
+  #endif
   #undef CYTHON_USE_PYLIST_INTERNALS
   #define CYTHON_USE_PYLIST_INTERNALS 0
   #ifndef CYTHON_USE_UNICODE_INTERNALS
     #define CYTHON_USE_UNICODE_INTERNALS 1
   #endif
   #undef CYTHON_USE_UNICODE_WRITER
   #define CYTHON_USE_UNICODE_WRITER 0
-  #undef CYTHON_USE_PYLONG_INTERNALS
-  #define CYTHON_USE_PYLONG_INTERNALS 0
   #ifndef CYTHON_AVOID_BORROWED_REFS
     #define CYTHON_AVOID_BORROWED_REFS 0
   #endif
   #ifndef CYTHON_ASSUME_SAFE_MACROS
     #define CYTHON_ASSUME_SAFE_MACROS 1
   #endif
   #ifndef CYTHON_UNPACK_METHODS
     #define CYTHON_UNPACK_METHODS 1
   #endif
   #undef CYTHON_FAST_THREAD_STATE
   #define CYTHON_FAST_THREAD_STATE 0
+  #undef CYTHON_FAST_GIL
+  #define CYTHON_FAST_GIL 0
+  #ifndef CYTHON_METH_FASTCALL
+    #define CYTHON_METH_FASTCALL 1
+  #endif
   #undef CYTHON_FAST_PYCALL
   #define CYTHON_FAST_PYCALL 0
+  #ifndef CYTHON_PEP487_INIT_SUBCLASS
+    #define CYTHON_PEP487_INIT_SUBCLASS 1
+  #endif
   #ifndef CYTHON_PEP489_MULTI_PHASE_INIT
     #define CYTHON_PEP489_MULTI_PHASE_INIT 1
   #endif
+  #ifndef CYTHON_USE_MODULE_STATE
+    #define CYTHON_USE_MODULE_STATE 0
+  #endif
   #ifndef CYTHON_USE_TP_FINALIZE
     #define CYTHON_USE_TP_FINALIZE 1
   #endif
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
+  #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
+    #define CYTHON_UPDATE_DESCRIPTOR_DOC 1
+  #endif
+  #ifndef CYTHON_USE_FREELISTS
+    #define CYTHON_USE_FREELISTS 0
+  #endif
 #else
   #define CYTHON_COMPILING_IN_PYPY 0
-  #define CYTHON_COMPILING_IN_PYSTON 0
   #define CYTHON_COMPILING_IN_CPYTHON 1
+  #define CYTHON_COMPILING_IN_LIMITED_API 0
+  #define CYTHON_COMPILING_IN_GRAAL 0
   #define CYTHON_COMPILING_IN_NOGIL 0
   #ifndef CYTHON_USE_TYPE_SLOTS
     #define CYTHON_USE_TYPE_SLOTS 1
   #endif
-  #if PY_VERSION_HEX < 0x02070000
-    #undef CYTHON_USE_PYTYPE_LOOKUP
-    #define CYTHON_USE_PYTYPE_LOOKUP 0
-  #elif !defined(CYTHON_USE_PYTYPE_LOOKUP)
+  #ifndef CYTHON_USE_TYPE_SPECS
+    #define CYTHON_USE_TYPE_SPECS 0
+  #endif
+  #ifndef CYTHON_USE_PYTYPE_LOOKUP
     #define CYTHON_USE_PYTYPE_LOOKUP 1
   #endif
   #if PY_MAJOR_VERSION < 3
     #undef CYTHON_USE_ASYNC_SLOTS
     #define CYTHON_USE_ASYNC_SLOTS 0
   #elif !defined(CYTHON_USE_ASYNC_SLOTS)
     #define CYTHON_USE_ASYNC_SLOTS 1
   #endif
-  #if PY_VERSION_HEX < 0x02070000
-    #undef CYTHON_USE_PYLONG_INTERNALS
-    #define CYTHON_USE_PYLONG_INTERNALS 0
-  #elif !defined(CYTHON_USE_PYLONG_INTERNALS)
+  #ifndef CYTHON_USE_PYLONG_INTERNALS
     #define CYTHON_USE_PYLONG_INTERNALS 1
   #endif
   #ifndef CYTHON_USE_PYLIST_INTERNALS
     #define CYTHON_USE_PYLIST_INTERNALS 1
   #endif
   #ifndef CYTHON_USE_UNICODE_INTERNALS
     #define CYTHON_USE_UNICODE_INTERNALS 1
@@ -244,45 +377,70 @@
   #endif
   #ifndef CYTHON_ASSUME_SAFE_MACROS
     #define CYTHON_ASSUME_SAFE_MACROS 1
   #endif
   #ifndef CYTHON_UNPACK_METHODS
     #define CYTHON_UNPACK_METHODS 1
   #endif
-  #if PY_VERSION_HEX >= 0x030B00A4
-    #undef CYTHON_FAST_THREAD_STATE
-    #define CYTHON_FAST_THREAD_STATE 0
-  #elif !defined(CYTHON_FAST_THREAD_STATE)
+  #ifndef CYTHON_FAST_THREAD_STATE
     #define CYTHON_FAST_THREAD_STATE 1
   #endif
+  #ifndef CYTHON_FAST_GIL
+    #define CYTHON_FAST_GIL (PY_MAJOR_VERSION < 3 || PY_VERSION_HEX >= 0x03060000 && PY_VERSION_HEX < 0x030C00A6)
+  #endif
+  #ifndef CYTHON_METH_FASTCALL
+    #define CYTHON_METH_FASTCALL (PY_VERSION_HEX >= 0x030700A1)
+  #endif
   #ifndef CYTHON_FAST_PYCALL
-    #define CYTHON_FAST_PYCALL (PY_VERSION_HEX < 0x030A0000)
+    #define CYTHON_FAST_PYCALL 1
   #endif
-  #ifndef CYTHON_PEP489_MULTI_PHASE_INIT
-    #define CYTHON_PEP489_MULTI_PHASE_INIT (PY_VERSION_HEX >= 0x03050000)
+  #ifndef CYTHON_PEP487_INIT_SUBCLASS
+    #define CYTHON_PEP487_INIT_SUBCLASS 1
   #endif
-  #ifndef CYTHON_USE_TP_FINALIZE
-    #define CYTHON_USE_TP_FINALIZE (PY_VERSION_HEX >= 0x030400a1)
+  #if PY_VERSION_HEX < 0x03050000
+    #undef CYTHON_PEP489_MULTI_PHASE_INIT
+    #define CYTHON_PEP489_MULTI_PHASE_INIT 0
+  #elif !defined(CYTHON_PEP489_MULTI_PHASE_INIT)
+    #define CYTHON_PEP489_MULTI_PHASE_INIT 1
+  #endif
+  #ifndef CYTHON_USE_MODULE_STATE
+    #define CYTHON_USE_MODULE_STATE 0
   #endif
-  #ifndef CYTHON_USE_DICT_VERSIONS
-    #define CYTHON_USE_DICT_VERSIONS (PY_VERSION_HEX >= 0x030600B1)
+  #if PY_VERSION_HEX < 0x030400a1
+    #undef CYTHON_USE_TP_FINALIZE
+    #define CYTHON_USE_TP_FINALIZE 0
+  #elif !defined(CYTHON_USE_TP_FINALIZE)
+    #define CYTHON_USE_TP_FINALIZE 1
+  #endif
+  #if PY_VERSION_HEX < 0x030600B1
+    #undef CYTHON_USE_DICT_VERSIONS
+    #define CYTHON_USE_DICT_VERSIONS 0
+  #elif !defined(CYTHON_USE_DICT_VERSIONS)
+    #define CYTHON_USE_DICT_VERSIONS  (PY_VERSION_HEX < 0x030C00A5)
   #endif
-  #if PY_VERSION_HEX >= 0x030B00A4
+  #if PY_VERSION_HEX < 0x030700A3
     #undef CYTHON_USE_EXC_INFO_STACK
     #define CYTHON_USE_EXC_INFO_STACK 0
   #elif !defined(CYTHON_USE_EXC_INFO_STACK)
-    #define CYTHON_USE_EXC_INFO_STACK (PY_VERSION_HEX >= 0x030700A3)
+    #define CYTHON_USE_EXC_INFO_STACK 1
   #endif
   #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
     #define CYTHON_UPDATE_DESCRIPTOR_DOC 1
   #endif
+  #ifndef CYTHON_USE_FREELISTS
+    #define CYTHON_USE_FREELISTS 1
+  #endif
 #endif
 #if !defined(CYTHON_FAST_PYCCALL)
 #define CYTHON_FAST_PYCCALL  (CYTHON_FAST_PYCALL && PY_VERSION_HEX >= 0x030600B1)
 #endif
+#if !defined(CYTHON_VECTORCALL)
+#define CYTHON_VECTORCALL  (CYTHON_FAST_PYCCALL && PY_VERSION_HEX >= 0x030800B1)
+#endif
+#define CYTHON_BACKPORT_VECTORCALL (CYTHON_METH_FASTCALL && PY_VERSION_HEX < 0x030800B1)
 #if CYTHON_USE_PYLONG_INTERNALS
   #if PY_MAJOR_VERSION < 3
     #include "longintrepr.h"
   #endif
   #undef SHIFT
   #undef BASE
   #undef MASK
@@ -304,78 +462,136 @@
   #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
     #define CYTHON_RESTRICT restrict
   #else
     #define CYTHON_RESTRICT
   #endif
 #endif
 #ifndef CYTHON_UNUSED
+  #if defined(__cplusplus)
+    /* for clang __has_cpp_attribute(maybe_unused) is true even before C++17
+     * but leads to warnings with -pedantic, since it is a C++17 feature */
+    #if ((defined(_MSVC_LANG) && _MSVC_LANG >= 201703L) || __cplusplus >= 201703L)
+      #if __has_cpp_attribute(maybe_unused)
+        #define CYTHON_UNUSED [[maybe_unused]]
+      #endif
+    #endif
+  #endif
+#endif
+#ifndef CYTHON_UNUSED
 # if defined(__GNUC__)
 #   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
 #     define CYTHON_UNUSED __attribute__ ((__unused__))
 #   else
 #     define CYTHON_UNUSED
 #   endif
 # elif defined(__ICC) || (defined(__INTEL_COMPILER) && !defined(_MSC_VER))
 #   define CYTHON_UNUSED __attribute__ ((__unused__))
 # else
 #   define CYTHON_UNUSED
 # endif
 #endif
-#ifndef CYTHON_MAYBE_UNUSED_VAR
+#ifndef CYTHON_UNUSED_VAR
 #  if defined(__cplusplus)
-     template<class T> void CYTHON_MAYBE_UNUSED_VAR( const T& ) { }
+     template<class T> void CYTHON_UNUSED_VAR( const T& ) { }
 #  else
-#    define CYTHON_MAYBE_UNUSED_VAR(x) (void)(x)
+#    define CYTHON_UNUSED_VAR(x) (void)(x)
 #  endif
 #endif
+#ifndef CYTHON_MAYBE_UNUSED_VAR
+  #define CYTHON_MAYBE_UNUSED_VAR(x) CYTHON_UNUSED_VAR(x)
+#endif
 #ifndef CYTHON_NCP_UNUSED
 # if CYTHON_COMPILING_IN_CPYTHON
 #  define CYTHON_NCP_UNUSED
 # else
 #  define CYTHON_NCP_UNUSED CYTHON_UNUSED
 # endif
 #endif
+#ifndef CYTHON_USE_CPP_STD_MOVE
+  #if defined(__cplusplus) && (\
+    __cplusplus >= 201103L || (defined(_MSC_VER) && _MSC_VER >= 1600))
+    #define CYTHON_USE_CPP_STD_MOVE 1
+  #else
+    #define CYTHON_USE_CPP_STD_MOVE 0
+  #endif
+#endif
 #define __Pyx_void_to_None(void_result) ((void)(void_result), Py_INCREF(Py_None), Py_None)
 #ifdef _MSC_VER
     #ifndef _MSC_STDINT_H_
         #if _MSC_VER < 1300
-           typedef unsigned char     uint8_t;
-           typedef unsigned int      uint32_t;
+            typedef unsigned char     uint8_t;
+            typedef unsigned short    uint16_t;
+            typedef unsigned int      uint32_t;
         #else
-           typedef unsigned __int8   uint8_t;
-           typedef unsigned __int32  uint32_t;
+            typedef unsigned __int8   uint8_t;
+            typedef unsigned __int16  uint16_t;
+            typedef unsigned __int32  uint32_t;
+        #endif
+    #endif
+    #if _MSC_VER < 1300
+        #ifdef _WIN64
+            typedef unsigned long long  __pyx_uintptr_t;
+        #else
+            typedef unsigned int        __pyx_uintptr_t;
+        #endif
+    #else
+        #ifdef _WIN64
+            typedef unsigned __int64    __pyx_uintptr_t;
+        #else
+            typedef unsigned __int32    __pyx_uintptr_t;
         #endif
     #endif
 #else
-   #include <stdint.h>
+    #include <stdint.h>
+    typedef uintptr_t  __pyx_uintptr_t;
 #endif
 #ifndef CYTHON_FALLTHROUGH
-  #if defined(__cplusplus) && __cplusplus >= 201103L
-    #if __has_cpp_attribute(fallthrough)
-      #define CYTHON_FALLTHROUGH [[fallthrough]]
-    #elif __has_cpp_attribute(clang::fallthrough)
-      #define CYTHON_FALLTHROUGH [[clang::fallthrough]]
-    #elif __has_cpp_attribute(gnu::fallthrough)
-      #define CYTHON_FALLTHROUGH [[gnu::fallthrough]]
+  #if defined(__cplusplus)
+    /* for clang __has_cpp_attribute(fallthrough) is true even before C++17
+     * but leads to warnings with -pedantic, since it is a C++17 feature */
+    #if ((defined(_MSVC_LANG) && _MSVC_LANG >= 201703L) || __cplusplus >= 201703L)
+      #if __has_cpp_attribute(fallthrough)
+        #define CYTHON_FALLTHROUGH [[fallthrough]]
+      #endif
+    #endif
+    #ifndef CYTHON_FALLTHROUGH
+      #if __has_cpp_attribute(clang::fallthrough)
+        #define CYTHON_FALLTHROUGH [[clang::fallthrough]]
+      #elif __has_cpp_attribute(gnu::fallthrough)
+        #define CYTHON_FALLTHROUGH [[gnu::fallthrough]]
+      #endif
     #endif
   #endif
   #ifndef CYTHON_FALLTHROUGH
     #if __has_attribute(fallthrough)
       #define CYTHON_FALLTHROUGH __attribute__((fallthrough))
     #else
       #define CYTHON_FALLTHROUGH
     #endif
   #endif
-  #if defined(__clang__ ) && defined(__apple_build_version__)
+  #if defined(__clang__) && defined(__apple_build_version__)
     #if __apple_build_version__ < 7000000
       #undef  CYTHON_FALLTHROUGH
       #define CYTHON_FALLTHROUGH
     #endif
   #endif
 #endif
+#ifdef __cplusplus
+  template <typename T>
+  struct __PYX_IS_UNSIGNED_IMPL {static const bool value = T(0) < T(-1);};
+  #define __PYX_IS_UNSIGNED(type) (__PYX_IS_UNSIGNED_IMPL<type>::value)
+#else
+  #define __PYX_IS_UNSIGNED(type) (((type)-1) > 0)
+#endif
+#if CYTHON_COMPILING_IN_PYPY == 1
+  #define __PYX_NEED_TP_PRINT_SLOT  (PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x030A0000)
+#else
+  #define __PYX_NEED_TP_PRINT_SLOT  (PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000)
+#endif
+#define __PYX_REINTERPRET_FUNCION(func_pointer, other_pointer) ((func_pointer)(void(*)(void))(other_pointer))
 
 #ifndef CYTHON_INLINE
   #if defined(__clang__)
     #define CYTHON_INLINE __inline__ __attribute__ ((__unused__))
   #elif defined(__GNUC__)
     #define CYTHON_INLINE __inline__
   #elif defined(_MSC_VER)
@@ -383,152 +599,289 @@
   #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
     #define CYTHON_INLINE inline
   #else
     #define CYTHON_INLINE
   #endif
 #endif
 
-#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX < 0x02070600 && !defined(Py_OptimizeFlag)
-  #define Py_OptimizeFlag 0
-#endif
 #define __PYX_BUILD_PY_SSIZE_T "n"
 #define CYTHON_FORMAT_SSIZE_T "z"
 #if PY_MAJOR_VERSION < 3
   #define __Pyx_BUILTIN_MODULE_NAME "__builtin__"
-  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
-          PyCode_New(a+k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
   #define __Pyx_DefaultClassType PyClass_Type
+  #define __Pyx_PyCode_New(a, p, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
+          PyCode_New(a+k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
 #else
   #define __Pyx_BUILTIN_MODULE_NAME "builtins"
   #define __Pyx_DefaultClassType PyType_Type
-#if PY_VERSION_HEX >= 0x030B00A1
-    static CYTHON_INLINE PyCodeObject* __Pyx_PyCode_New(int a, int k, int l, int s, int f,
+#if CYTHON_COMPILING_IN_LIMITED_API
+    static CYTHON_INLINE PyObject* __Pyx_PyCode_New(int a, int p, int k, int l, int s, int f,
                                                     PyObject *code, PyObject *c, PyObject* n, PyObject *v,
                                                     PyObject *fv, PyObject *cell, PyObject* fn,
                                                     PyObject *name, int fline, PyObject *lnos) {
-        PyObject *kwds=NULL, *argcount=NULL, *posonlyargcount=NULL, *kwonlyargcount=NULL;
-        PyObject *nlocals=NULL, *stacksize=NULL, *flags=NULL, *replace=NULL, *call_result=NULL, *empty=NULL;
-        const char *fn_cstr=NULL;
-        const char *name_cstr=NULL;
-        PyCodeObject* co=NULL;
+        PyObject *exception_table = NULL;
+        PyObject *types_module=NULL, *code_type=NULL, *result=NULL;
+        #if __PYX_LIMITED_VERSION_HEX < 0x030B0000
+        PyObject *version_info;
+        PyObject *py_minor_version = NULL;
+        #endif
+        long minor_version = 0;
         PyObject *type, *value, *traceback;
         PyErr_Fetch(&type, &value, &traceback);
-        if (!(kwds=PyDict_New())) goto end;
-        if (!(argcount=PyLong_FromLong(a))) goto end;
-        if (PyDict_SetItemString(kwds, "co_argcount", argcount) != 0) goto end;
-        if (!(posonlyargcount=PyLong_FromLong(0))) goto end;
-        if (PyDict_SetItemString(kwds, "co_posonlyargcount", posonlyargcount) != 0) goto end;
-        if (!(kwonlyargcount=PyLong_FromLong(k))) goto end;
-        if (PyDict_SetItemString(kwds, "co_kwonlyargcount", kwonlyargcount) != 0) goto end;
-        if (!(nlocals=PyLong_FromLong(l))) goto end;
-        if (PyDict_SetItemString(kwds, "co_nlocals", nlocals) != 0) goto end;
-        if (!(stacksize=PyLong_FromLong(s))) goto end;
-        if (PyDict_SetItemString(kwds, "co_stacksize", stacksize) != 0) goto end;
-        if (!(flags=PyLong_FromLong(f))) goto end;
-        if (PyDict_SetItemString(kwds, "co_flags", flags) != 0) goto end;
-        if (PyDict_SetItemString(kwds, "co_code", code) != 0) goto end;
-        if (PyDict_SetItemString(kwds, "co_consts", c) != 0) goto end;
-        if (PyDict_SetItemString(kwds, "co_names", n) != 0) goto end;
-        if (PyDict_SetItemString(kwds, "co_varnames", v) != 0) goto end;
-        if (PyDict_SetItemString(kwds, "co_freevars", fv) != 0) goto end;
-        if (PyDict_SetItemString(kwds, "co_cellvars", cell) != 0) goto end;
-        if (PyDict_SetItemString(kwds, "co_linetable", lnos) != 0) goto end;
-        if (!(fn_cstr=PyUnicode_AsUTF8AndSize(fn, NULL))) goto end;
-        if (!(name_cstr=PyUnicode_AsUTF8AndSize(name, NULL))) goto end;
-        if (!(co = PyCode_NewEmpty(fn_cstr, name_cstr, fline))) goto end;
-        if (!(replace = PyObject_GetAttrString((PyObject*)co, "replace"))) goto cleanup_code_too;
-        if (!(empty = PyTuple_New(0))) goto cleanup_code_too; // unfortunately __pyx_empty_tuple isn't available here
-        if (!(call_result = PyObject_Call(replace, empty, kwds))) goto cleanup_code_too;
-        Py_XDECREF((PyObject*)co);
-        co = (PyCodeObject*)call_result;
-        call_result = NULL;
-        if (0) {
-            cleanup_code_too:
-            Py_XDECREF((PyObject*)co);
-            co = NULL;
-        }
-        end:
-        Py_XDECREF(kwds);
-        Py_XDECREF(argcount);
-        Py_XDECREF(posonlyargcount);
-        Py_XDECREF(kwonlyargcount);
-        Py_XDECREF(nlocals);
-        Py_XDECREF(stacksize);
-        Py_XDECREF(replace);
-        Py_XDECREF(call_result);
-        Py_XDECREF(empty);
+        #if __PYX_LIMITED_VERSION_HEX >= 0x030B0000
+        minor_version = 11;
+        #else
+        if (!(version_info = PySys_GetObject("version_info"))) goto end;
+        if (!(py_minor_version = PySequence_GetItem(version_info, 1))) goto end;
+        minor_version = PyLong_AsLong(py_minor_version);
+        Py_DECREF(py_minor_version);
+        if (minor_version == -1 && PyErr_Occurred()) goto end;
+        #endif
+        if (!(types_module = PyImport_ImportModule("types"))) goto end;
+        if (!(code_type = PyObject_GetAttrString(types_module, "CodeType"))) goto end;
+        if (minor_version <= 7) {
+            (void)p;
+            result = PyObject_CallFunction(code_type, "iiiiiOOOOOOiOO", a, k, l, s, f, code,
+                          c, n, v, fn, name, fline, lnos, fv, cell);
+        } else if (minor_version <= 10) {
+            result = PyObject_CallFunction(code_type, "iiiiiiOOOOOOiOO", a,p, k, l, s, f, code,
+                          c, n, v, fn, name, fline, lnos, fv, cell);
+        } else {
+            if (!(exception_table = PyBytes_FromStringAndSize(NULL, 0))) goto end;
+            result = PyObject_CallFunction(code_type, "iiiiiiOOOOOOOiOO", a,p, k, l, s, f, code,
+                          c, n, v, fn, name, name, fline, lnos, exception_table, fv, cell);
+        }
+    end:
+        Py_XDECREF(code_type);
+        Py_XDECREF(exception_table);
+        Py_XDECREF(types_module);
         if (type) {
             PyErr_Restore(type, value, traceback);
         }
-        return co;
+        return result;
     }
+    #ifndef CO_OPTIMIZED
+    #define CO_OPTIMIZED 0x0001
+    #endif
+    #ifndef CO_NEWLOCALS
+    #define CO_NEWLOCALS 0x0002
+    #endif
+    #ifndef CO_VARARGS
+    #define CO_VARARGS 0x0004
+    #endif
+    #ifndef CO_VARKEYWORDS
+    #define CO_VARKEYWORDS 0x0008
+    #endif
+    #ifndef CO_ASYNC_GENERATOR
+    #define CO_ASYNC_GENERATOR 0x0200
+    #endif
+    #ifndef CO_GENERATOR
+    #define CO_GENERATOR 0x0020
+    #endif
+    #ifndef CO_COROUTINE
+    #define CO_COROUTINE 0x0080
+    #endif
+#elif PY_VERSION_HEX >= 0x030B0000
+  static CYTHON_INLINE PyCodeObject* __Pyx_PyCode_New(int a, int p, int k, int l, int s, int f,
+                                                    PyObject *code, PyObject *c, PyObject* n, PyObject *v,
+                                                    PyObject *fv, PyObject *cell, PyObject* fn,
+                                                    PyObject *name, int fline, PyObject *lnos) {
+    PyCodeObject *result;
+    PyObject *empty_bytes = PyBytes_FromStringAndSize("", 0);
+    if (!empty_bytes) return NULL;
+    result =
+      #if PY_VERSION_HEX >= 0x030C0000
+        PyUnstable_Code_NewWithPosOnlyArgs
+      #else
+        PyCode_NewWithPosOnlyArgs
+      #endif
+        (a, p, k, l, s, f, code, c, n, v, fv, cell, fn, name, name, fline, lnos, empty_bytes);
+    Py_DECREF(empty_bytes);
+    return result;
+  }
+#elif PY_VERSION_HEX >= 0x030800B2 && !CYTHON_COMPILING_IN_PYPY
+  #define __Pyx_PyCode_New(a, p, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
+          PyCode_NewWithPosOnlyArgs(a, p, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
 #else
-  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
+  #define __Pyx_PyCode_New(a, p, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
           PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
 #endif
-  #define __Pyx_DefaultClassType PyType_Type
+#endif
+#if PY_VERSION_HEX >= 0x030900A4 || defined(Py_IS_TYPE)
+  #define __Pyx_IS_TYPE(ob, type) Py_IS_TYPE(ob, type)
+#else
+  #define __Pyx_IS_TYPE(ob, type) (((const PyObject*)ob)->ob_type == (type))
+#endif
+#if PY_VERSION_HEX >= 0x030A00B1 || defined(Py_Is)
+  #define __Pyx_Py_Is(x, y)  Py_Is(x, y)
+#else
+  #define __Pyx_Py_Is(x, y) ((x) == (y))
+#endif
+#if PY_VERSION_HEX >= 0x030A00B1 || defined(Py_IsNone)
+  #define __Pyx_Py_IsNone(ob) Py_IsNone(ob)
+#else
+  #define __Pyx_Py_IsNone(ob) __Pyx_Py_Is((ob), Py_None)
+#endif
+#if PY_VERSION_HEX >= 0x030A00B1 || defined(Py_IsTrue)
+  #define __Pyx_Py_IsTrue(ob) Py_IsTrue(ob)
+#else
+  #define __Pyx_Py_IsTrue(ob) __Pyx_Py_Is((ob), Py_True)
+#endif
+#if PY_VERSION_HEX >= 0x030A00B1 || defined(Py_IsFalse)
+  #define __Pyx_Py_IsFalse(ob) Py_IsFalse(ob)
+#else
+  #define __Pyx_Py_IsFalse(ob) __Pyx_Py_Is((ob), Py_False)
+#endif
+#define __Pyx_NoneAsNull(obj)  (__Pyx_Py_IsNone(obj) ? NULL : (obj))
+#if PY_VERSION_HEX >= 0x030900F0 && !CYTHON_COMPILING_IN_PYPY
+  #define __Pyx_PyObject_GC_IsFinalized(o) PyObject_GC_IsFinalized(o)
+#else
+  #define __Pyx_PyObject_GC_IsFinalized(o) _PyGC_FINALIZED(o)
+#endif
+#ifndef CO_COROUTINE
+  #define CO_COROUTINE 0x80
+#endif
+#ifndef CO_ASYNC_GENERATOR
+  #define CO_ASYNC_GENERATOR 0x200
 #endif
 #ifndef Py_TPFLAGS_CHECKTYPES
   #define Py_TPFLAGS_CHECKTYPES 0
 #endif
 #ifndef Py_TPFLAGS_HAVE_INDEX
   #define Py_TPFLAGS_HAVE_INDEX 0
 #endif
 #ifndef Py_TPFLAGS_HAVE_NEWBUFFER
   #define Py_TPFLAGS_HAVE_NEWBUFFER 0
 #endif
 #ifndef Py_TPFLAGS_HAVE_FINALIZE
   #define Py_TPFLAGS_HAVE_FINALIZE 0
 #endif
+#ifndef Py_TPFLAGS_SEQUENCE
+  #define Py_TPFLAGS_SEQUENCE 0
+#endif
+#ifndef Py_TPFLAGS_MAPPING
+  #define Py_TPFLAGS_MAPPING 0
+#endif
 #ifndef METH_STACKLESS
   #define METH_STACKLESS 0
 #endif
 #if PY_VERSION_HEX <= 0x030700A3 || !defined(METH_FASTCALL)
   #ifndef METH_FASTCALL
      #define METH_FASTCALL 0x80
   #endif
   typedef PyObject *(*__Pyx_PyCFunctionFast) (PyObject *self, PyObject *const *args, Py_ssize_t nargs);
   typedef PyObject *(*__Pyx_PyCFunctionFastWithKeywords) (PyObject *self, PyObject *const *args,
                                                           Py_ssize_t nargs, PyObject *kwnames);
 #else
-  #define __Pyx_PyCFunctionFast _PyCFunctionFast
-  #define __Pyx_PyCFunctionFastWithKeywords _PyCFunctionFastWithKeywords
+  #if PY_VERSION_HEX >= 0x030d00A4
+  #  define __Pyx_PyCFunctionFast PyCFunctionFast
+  #  define __Pyx_PyCFunctionFastWithKeywords PyCFunctionFastWithKeywords
+  #else
+  #  define __Pyx_PyCFunctionFast _PyCFunctionFast
+  #  define __Pyx_PyCFunctionFastWithKeywords _PyCFunctionFastWithKeywords
+  #endif
+#endif
+#if CYTHON_METH_FASTCALL
+  #define __Pyx_METH_FASTCALL METH_FASTCALL
+  #define __Pyx_PyCFunction_FastCall __Pyx_PyCFunctionFast
+  #define __Pyx_PyCFunction_FastCallWithKeywords __Pyx_PyCFunctionFastWithKeywords
+#else
+  #define __Pyx_METH_FASTCALL METH_VARARGS
+  #define __Pyx_PyCFunction_FastCall PyCFunction
+  #define __Pyx_PyCFunction_FastCallWithKeywords PyCFunctionWithKeywords
+#endif
+#if CYTHON_VECTORCALL
+  #define __pyx_vectorcallfunc vectorcallfunc
+  #define __Pyx_PY_VECTORCALL_ARGUMENTS_OFFSET  PY_VECTORCALL_ARGUMENTS_OFFSET
+  #define __Pyx_PyVectorcall_NARGS(n)  PyVectorcall_NARGS((size_t)(n))
+#elif CYTHON_BACKPORT_VECTORCALL
+  typedef PyObject *(*__pyx_vectorcallfunc)(PyObject *callable, PyObject *const *args,
+                                            size_t nargsf, PyObject *kwnames);
+  #define __Pyx_PY_VECTORCALL_ARGUMENTS_OFFSET  ((size_t)1 << (8 * sizeof(size_t) - 1))
+  #define __Pyx_PyVectorcall_NARGS(n)  ((Py_ssize_t)(((size_t)(n)) & ~__Pyx_PY_VECTORCALL_ARGUMENTS_OFFSET))
+#else
+  #define __Pyx_PY_VECTORCALL_ARGUMENTS_OFFSET  0
+  #define __Pyx_PyVectorcall_NARGS(n)  ((Py_ssize_t)(n))
+#endif
+#if PY_MAJOR_VERSION >= 0x030900B1
+#define __Pyx_PyCFunction_CheckExact(func)  PyCFunction_CheckExact(func)
+#else
+#define __Pyx_PyCFunction_CheckExact(func)  PyCFunction_Check(func)
+#endif
+#define __Pyx_CyOrPyCFunction_Check(func)  PyCFunction_Check(func)
+#if CYTHON_COMPILING_IN_CPYTHON
+#define __Pyx_CyOrPyCFunction_GET_FUNCTION(func)  (((PyCFunctionObject*)(func))->m_ml->ml_meth)
+#elif !CYTHON_COMPILING_IN_LIMITED_API
+#define __Pyx_CyOrPyCFunction_GET_FUNCTION(func)  PyCFunction_GET_FUNCTION(func)
+#endif
+#if CYTHON_COMPILING_IN_CPYTHON
+#define __Pyx_CyOrPyCFunction_GET_FLAGS(func)  (((PyCFunctionObject*)(func))->m_ml->ml_flags)
+static CYTHON_INLINE PyObject* __Pyx_CyOrPyCFunction_GET_SELF(PyObject *func) {
+    return (__Pyx_CyOrPyCFunction_GET_FLAGS(func) & METH_STATIC) ? NULL : ((PyCFunctionObject*)func)->m_self;
+}
+#endif
+static CYTHON_INLINE int __Pyx__IsSameCFunction(PyObject *func, void *cfunc) {
+#if CYTHON_COMPILING_IN_LIMITED_API
+    return PyCFunction_Check(func) && PyCFunction_GetFunction(func) == (PyCFunction) cfunc;
+#else
+    return PyCFunction_Check(func) && PyCFunction_GET_FUNCTION(func) == (PyCFunction) cfunc;
 #endif
-#if CYTHON_FAST_PYCCALL
-#define __Pyx_PyFastCFunction_Check(func)\
-    ((PyCFunction_Check(func) && (METH_FASTCALL == (PyCFunction_GET_FLAGS(func) & ~(METH_CLASS | METH_STATIC | METH_COEXIST | METH_KEYWORDS | METH_STACKLESS)))))
+}
+#define __Pyx_IsSameCFunction(func, cfunc)   __Pyx__IsSameCFunction(func, cfunc)
+#if __PYX_LIMITED_VERSION_HEX < 0x030900B1
+  #define __Pyx_PyType_FromModuleAndSpec(m, s, b)  ((void)m, PyType_FromSpecWithBases(s, b))
+  typedef PyObject *(*__Pyx_PyCMethod)(PyObject *, PyTypeObject *, PyObject *const *, size_t, PyObject *);
 #else
-#define __Pyx_PyFastCFunction_Check(func) 0
+  #define __Pyx_PyType_FromModuleAndSpec(m, s, b)  PyType_FromModuleAndSpec(m, s, b)
+  #define __Pyx_PyCMethod  PyCMethod
+#endif
+#ifndef METH_METHOD
+  #define METH_METHOD 0x200
 #endif
 #if CYTHON_COMPILING_IN_PYPY && !defined(PyObject_Malloc)
   #define PyObject_Malloc(s)   PyMem_Malloc(s)
   #define PyObject_Free(p)     PyMem_Free(p)
   #define PyObject_Realloc(p)  PyMem_Realloc(p)
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030400A1
-  #define PyMem_RawMalloc(n)           PyMem_Malloc(n)
-  #define PyMem_RawRealloc(p, n)       PyMem_Realloc(p, n)
-  #define PyMem_RawFree(p)             PyMem_Free(p)
-#endif
-#if CYTHON_COMPILING_IN_PYSTON
-  #define __Pyx_PyCode_HasFreeVars(co)  PyCode_HasFreeVars(co)
-  #define __Pyx_PyFrame_SetLineNumber(frame, lineno) PyFrame_SetLineNumber(frame, lineno)
+#if CYTHON_COMPILING_IN_LIMITED_API
+  #define __Pyx_PyCode_HasFreeVars(co)  (PyCode_GetNumFree(co) > 0)
+  #define __Pyx_PyFrame_SetLineNumber(frame, lineno)
 #else
   #define __Pyx_PyCode_HasFreeVars(co)  (PyCode_GetNumFree(co) > 0)
   #define __Pyx_PyFrame_SetLineNumber(frame, lineno)  (frame)->f_lineno = (lineno)
 #endif
-#if !CYTHON_FAST_THREAD_STATE || PY_VERSION_HEX < 0x02070000
+#if CYTHON_COMPILING_IN_LIMITED_API
+  #define __Pyx_PyThreadState_Current PyThreadState_Get()
+#elif !CYTHON_FAST_THREAD_STATE
   #define __Pyx_PyThreadState_Current PyThreadState_GET()
+#elif PY_VERSION_HEX >= 0x030d00A1
+  #define __Pyx_PyThreadState_Current PyThreadState_GetUnchecked()
 #elif PY_VERSION_HEX >= 0x03060000
   #define __Pyx_PyThreadState_Current _PyThreadState_UncheckedGet()
 #elif PY_VERSION_HEX >= 0x03000000
   #define __Pyx_PyThreadState_Current PyThreadState_GET()
 #else
   #define __Pyx_PyThreadState_Current _PyThreadState_Current
 #endif
+#if CYTHON_COMPILING_IN_LIMITED_API
+static CYTHON_INLINE void *__Pyx_PyModule_GetState(PyObject *op)
+{
+    void *result;
+    result = PyModule_GetState(op);
+    if (!result)
+        Py_FatalError("Couldn't find the module state");
+    return result;
+}
+#endif
+#define __Pyx_PyObject_GetSlot(obj, name, func_ctype)  __Pyx_PyType_GetSlot(Py_TYPE(obj), name, func_ctype)
+#if CYTHON_COMPILING_IN_LIMITED_API
+  #define __Pyx_PyType_GetSlot(type, name, func_ctype)  ((func_ctype) PyType_GetSlot((type), Py_##name))
+#else
+  #define __Pyx_PyType_GetSlot(type, name, func_ctype)  ((type)->name)
+#endif
 #if PY_VERSION_HEX < 0x030700A2 && !defined(PyThread_tss_create) && !defined(Py_tss_NEEDS_INIT)
 #include "pythread.h"
 #define Py_tss_NEEDS_INIT 0
 typedef int Py_tss_t;
 static CYTHON_INLINE int PyThread_tss_create(Py_tss_t *key) {
   *key = PyThread_create_key();
   return 0;
@@ -551,86 +904,171 @@
 static CYTHON_INLINE int PyThread_tss_set(Py_tss_t *key, void *value) {
   return PyThread_set_key_value(*key, value);
 }
 static CYTHON_INLINE void * PyThread_tss_get(Py_tss_t *key) {
   return PyThread_get_key_value(*key);
 }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON || defined(_PyDict_NewPresized)
+#if PY_MAJOR_VERSION < 3
+    #if CYTHON_COMPILING_IN_PYPY
+        #if PYPY_VERSION_NUM < 0x07030600
+            #if defined(__cplusplus) && __cplusplus >= 201402L
+                [[deprecated("`with nogil:` inside a nogil function will not release the GIL in PyPy2 < 7.3.6")]]
+            #elif defined(__GNUC__) || defined(__clang__)
+                __attribute__ ((__deprecated__("`with nogil:` inside a nogil function will not release the GIL in PyPy2 < 7.3.6")))
+            #elif defined(_MSC_VER)
+                __declspec(deprecated("`with nogil:` inside a nogil function will not release the GIL in PyPy2 < 7.3.6"))
+            #endif
+            static CYTHON_INLINE int PyGILState_Check(void) {
+                return 0;
+            }
+        #else  // PYPY_VERSION_NUM < 0x07030600
+        #endif  // PYPY_VERSION_NUM < 0x07030600
+    #else
+        static CYTHON_INLINE int PyGILState_Check(void) {
+            PyThreadState * tstate = _PyThreadState_Current;
+            return tstate && (tstate == PyGILState_GetThisThreadState());
+        }
+    #endif
+#endif
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030d0000 || defined(_PyDict_NewPresized)
 #define __Pyx_PyDict_NewPresized(n)  ((n <= 8) ? PyDict_New() : _PyDict_NewPresized(n))
 #else
 #define __Pyx_PyDict_NewPresized(n)  PyDict_New()
 #endif
 #if PY_MAJOR_VERSION >= 3 || CYTHON_FUTURE_DIVISION
   #define __Pyx_PyNumber_Divide(x,y)         PyNumber_TrueDivide(x,y)
   #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceTrueDivide(x,y)
 #else
   #define __Pyx_PyNumber_Divide(x,y)         PyNumber_Divide(x,y)
   #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceDivide(x,y)
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030500A1 && CYTHON_USE_UNICODE_INTERNALS
-#define __Pyx_PyDict_GetItemStr(dict, name)  _PyDict_GetItem_KnownHash(dict, name, ((PyASCIIObject *) name)->hash)
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX > 0x030600B4 && PY_VERSION_HEX < 0x030d0000 && CYTHON_USE_UNICODE_INTERNALS
+#define __Pyx_PyDict_GetItemStrWithError(dict, name)  _PyDict_GetItem_KnownHash(dict, name, ((PyASCIIObject *) name)->hash)
+static CYTHON_INLINE PyObject * __Pyx_PyDict_GetItemStr(PyObject *dict, PyObject *name) {
+    PyObject *res = __Pyx_PyDict_GetItemStrWithError(dict, name);
+    if (res == NULL) PyErr_Clear();
+    return res;
+}
+#elif PY_MAJOR_VERSION >= 3 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07020000)
+#define __Pyx_PyDict_GetItemStrWithError  PyDict_GetItemWithError
+#define __Pyx_PyDict_GetItemStr           PyDict_GetItem
+#else
+static CYTHON_INLINE PyObject * __Pyx_PyDict_GetItemStrWithError(PyObject *dict, PyObject *name) {
+#if CYTHON_COMPILING_IN_PYPY
+    return PyDict_GetItem(dict, name);
 #else
-#define __Pyx_PyDict_GetItemStr(dict, name)  PyDict_GetItem(dict, name)
+    PyDictEntry *ep;
+    PyDictObject *mp = (PyDictObject*) dict;
+    long hash = ((PyStringObject *) name)->ob_shash;
+    assert(hash != -1);
+    ep = (mp->ma_lookup)(mp, name, hash);
+    if (ep == NULL) {
+        return NULL;
+    }
+    return ep->me_value;
+#endif
+}
+#define __Pyx_PyDict_GetItemStr           PyDict_GetItem
 #endif
-#if PY_VERSION_HEX > 0x03030000 && defined(PyUnicode_KIND)
+#if CYTHON_USE_TYPE_SLOTS
+  #define __Pyx_PyType_GetFlags(tp)   (((PyTypeObject *)tp)->tp_flags)
+  #define __Pyx_PyType_HasFeature(type, feature)  ((__Pyx_PyType_GetFlags(type) & (feature)) != 0)
+  #define __Pyx_PyObject_GetIterNextFunc(obj)  (Py_TYPE(obj)->tp_iternext)
+#else
+  #define __Pyx_PyType_GetFlags(tp)   (PyType_GetFlags((PyTypeObject *)tp))
+  #define __Pyx_PyType_HasFeature(type, feature)  PyType_HasFeature(type, feature)
+  #define __Pyx_PyObject_GetIterNextFunc(obj)  PyIter_Next
+#endif
+#if CYTHON_COMPILING_IN_LIMITED_API
+  #define __Pyx_SetItemOnTypeDict(tp, k, v) PyObject_GenericSetAttr((PyObject*)tp, k, v)
+#else
+  #define __Pyx_SetItemOnTypeDict(tp, k, v) PyDict_SetItem(tp->tp_dict, k, v)
+#endif
+#if CYTHON_USE_TYPE_SPECS && PY_VERSION_HEX >= 0x03080000
+#define __Pyx_PyHeapTypeObject_GC_Del(obj)  {\
+    PyTypeObject *type = Py_TYPE((PyObject*)obj);\
+    assert(__Pyx_PyType_HasFeature(type, Py_TPFLAGS_HEAPTYPE));\
+    PyObject_GC_Del(obj);\
+    Py_DECREF(type);\
+}
+#else
+#define __Pyx_PyHeapTypeObject_GC_Del(obj)  PyObject_GC_Del(obj)
+#endif
+#if CYTHON_COMPILING_IN_LIMITED_API
   #define CYTHON_PEP393_ENABLED 1
-  #if defined(PyUnicode_IS_READY)
-  #define __Pyx_PyUnicode_READY(op)       (likely(PyUnicode_IS_READY(op)) ?\
-                                              0 : _PyUnicode_Ready((PyObject *)(op)))
-  #else
   #define __Pyx_PyUnicode_READY(op)       (0)
+  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GetLength(u)
+  #define __Pyx_PyUnicode_READ_CHAR(u, i) PyUnicode_ReadChar(u, i)
+  #define __Pyx_PyUnicode_MAX_CHAR_VALUE(u)   ((void)u, 1114111U)
+  #define __Pyx_PyUnicode_KIND(u)         ((void)u, (0))
+  #define __Pyx_PyUnicode_DATA(u)         ((void*)u)
+  #define __Pyx_PyUnicode_READ(k, d, i)   ((void)k, PyUnicode_ReadChar((PyObject*)(d), i))
+  #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != PyUnicode_GetLength(u))
+#elif PY_VERSION_HEX > 0x03030000 && defined(PyUnicode_KIND)
+  #define CYTHON_PEP393_ENABLED 1
+  #if PY_VERSION_HEX >= 0x030C0000
+    #define __Pyx_PyUnicode_READY(op)       (0)
+  #else
+    #define __Pyx_PyUnicode_READY(op)       (likely(PyUnicode_IS_READY(op)) ?\
+                                                0 : _PyUnicode_Ready((PyObject *)(op)))
   #endif
   #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_LENGTH(u)
   #define __Pyx_PyUnicode_READ_CHAR(u, i) PyUnicode_READ_CHAR(u, i)
   #define __Pyx_PyUnicode_MAX_CHAR_VALUE(u)   PyUnicode_MAX_CHAR_VALUE(u)
-  #define __Pyx_PyUnicode_KIND(u)         PyUnicode_KIND(u)
+  #define __Pyx_PyUnicode_KIND(u)         ((int)PyUnicode_KIND(u))
   #define __Pyx_PyUnicode_DATA(u)         PyUnicode_DATA(u)
   #define __Pyx_PyUnicode_READ(k, d, i)   PyUnicode_READ(k, d, i)
-  #define __Pyx_PyUnicode_WRITE(k, d, i, ch)  PyUnicode_WRITE(k, d, i, ch)
-  #if defined(PyUnicode_IS_READY) && defined(PyUnicode_GET_SIZE)
-  #if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x03090000
-  #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != (likely(PyUnicode_IS_READY(u)) ? PyUnicode_GET_LENGTH(u) : ((PyCompactUnicodeObject *)(u))->wstr_length))
-  #else
-  #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != (likely(PyUnicode_IS_READY(u)) ? PyUnicode_GET_LENGTH(u) : PyUnicode_GET_SIZE(u)))
-  #endif
+  #define __Pyx_PyUnicode_WRITE(k, d, i, ch)  PyUnicode_WRITE(k, d, i, (Py_UCS4) ch)
+  #if PY_VERSION_HEX >= 0x030C0000
+    #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != PyUnicode_GET_LENGTH(u))
   #else
-  #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != PyUnicode_GET_LENGTH(u))
+    #if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x03090000
+    #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != (likely(PyUnicode_IS_READY(u)) ? PyUnicode_GET_LENGTH(u) : ((PyCompactUnicodeObject *)(u))->wstr_length))
+    #else
+    #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != (likely(PyUnicode_IS_READY(u)) ? PyUnicode_GET_LENGTH(u) : PyUnicode_GET_SIZE(u)))
+    #endif
   #endif
 #else
   #define CYTHON_PEP393_ENABLED 0
   #define PyUnicode_1BYTE_KIND  1
   #define PyUnicode_2BYTE_KIND  2
   #define PyUnicode_4BYTE_KIND  4
   #define __Pyx_PyUnicode_READY(op)       (0)
   #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_SIZE(u)
   #define __Pyx_PyUnicode_READ_CHAR(u, i) ((Py_UCS4)(PyUnicode_AS_UNICODE(u)[i]))
-  #define __Pyx_PyUnicode_MAX_CHAR_VALUE(u)   ((sizeof(Py_UNICODE) == 2) ? 65535 : 1114111)
-  #define __Pyx_PyUnicode_KIND(u)         (sizeof(Py_UNICODE))
+  #define __Pyx_PyUnicode_MAX_CHAR_VALUE(u)   ((sizeof(Py_UNICODE) == 2) ? 65535U : 1114111U)
+  #define __Pyx_PyUnicode_KIND(u)         ((int)sizeof(Py_UNICODE))
   #define __Pyx_PyUnicode_DATA(u)         ((void*)PyUnicode_AS_UNICODE(u))
   #define __Pyx_PyUnicode_READ(k, d, i)   ((void)(k), (Py_UCS4)(((Py_UNICODE*)d)[i]))
-  #define __Pyx_PyUnicode_WRITE(k, d, i, ch)  (((void)(k)), ((Py_UNICODE*)d)[i] = ch)
+  #define __Pyx_PyUnicode_WRITE(k, d, i, ch)  (((void)(k)), ((Py_UNICODE*)d)[i] = (Py_UNICODE) ch)
   #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != PyUnicode_GET_SIZE(u))
 #endif
 #if CYTHON_COMPILING_IN_PYPY
   #define __Pyx_PyUnicode_Concat(a, b)      PyNumber_Add(a, b)
   #define __Pyx_PyUnicode_ConcatSafe(a, b)  PyNumber_Add(a, b)
 #else
   #define __Pyx_PyUnicode_Concat(a, b)      PyUnicode_Concat(a, b)
   #define __Pyx_PyUnicode_ConcatSafe(a, b)  ((unlikely((a) == Py_None) || unlikely((b) == Py_None)) ?\
       PyNumber_Add(a, b) : __Pyx_PyUnicode_Concat(a, b))
 #endif
-#if CYTHON_COMPILING_IN_PYPY && !defined(PyUnicode_Contains)
-  #define PyUnicode_Contains(u, s)  PySequence_Contains(u, s)
-#endif
-#if CYTHON_COMPILING_IN_PYPY && !defined(PyByteArray_Check)
-  #define PyByteArray_Check(obj)  PyObject_TypeCheck(obj, &PyByteArray_Type)
-#endif
-#if CYTHON_COMPILING_IN_PYPY && !defined(PyObject_Format)
-  #define PyObject_Format(obj, fmt)  PyObject_CallMethod(obj, "__format__", "O", fmt)
+#if CYTHON_COMPILING_IN_PYPY
+  #if !defined(PyUnicode_DecodeUnicodeEscape)
+    #define PyUnicode_DecodeUnicodeEscape(s, size, errors)  PyUnicode_Decode(s, size, "unicode_escape", errors)
+  #endif
+  #if !defined(PyUnicode_Contains) || (PY_MAJOR_VERSION == 2 && PYPY_VERSION_NUM < 0x07030500)
+    #undef PyUnicode_Contains
+    #define PyUnicode_Contains(u, s)  PySequence_Contains(u, s)
+  #endif
+  #if !defined(PyByteArray_Check)
+    #define PyByteArray_Check(obj)  PyObject_TypeCheck(obj, &PyByteArray_Type)
+  #endif
+  #if !defined(PyObject_Format)
+    #define PyObject_Format(obj, fmt)  PyObject_CallMethod(obj, "__format__", "O", fmt)
+  #endif
 #endif
 #define __Pyx_PyString_FormatSafe(a, b)   ((unlikely((a) == Py_None || (PyString_Check(b) && !PyString_CheckExact(b)))) ? PyNumber_Remainder(a, b) : __Pyx_PyString_Format(a, b))
 #define __Pyx_PyUnicode_FormatSafe(a, b)  ((unlikely((a) == Py_None || (PyUnicode_Check(b) && !PyUnicode_CheckExact(b)))) ? PyNumber_Remainder(a, b) : PyUnicode_Format(a, b))
 #if PY_MAJOR_VERSION >= 3
   #define __Pyx_PyString_Format(a, b)  PyUnicode_Format(a, b)
 #else
   #define __Pyx_PyString_Format(a, b)  PyString_Format(a, b)
@@ -651,45 +1089,81 @@
 #if PY_MAJOR_VERSION >= 3
   #define __Pyx_PyBaseString_Check(obj) PyUnicode_Check(obj)
   #define __Pyx_PyBaseString_CheckExact(obj) PyUnicode_CheckExact(obj)
 #else
   #define __Pyx_PyBaseString_Check(obj) (PyString_Check(obj) || PyUnicode_Check(obj))
   #define __Pyx_PyBaseString_CheckExact(obj) (PyString_CheckExact(obj) || PyUnicode_CheckExact(obj))
 #endif
+#if CYTHON_COMPILING_IN_CPYTHON
+  #define __Pyx_PySequence_ListKeepNew(obj)\
+    (likely(PyList_CheckExact(obj) && Py_REFCNT(obj) == 1) ? __Pyx_NewRef(obj) : PySequence_List(obj))
+#else
+  #define __Pyx_PySequence_ListKeepNew(obj)  PySequence_List(obj)
+#endif
 #ifndef PySet_CheckExact
-  #define PySet_CheckExact(obj)        (Py_TYPE(obj) == &PySet_Type)
+  #define PySet_CheckExact(obj)        __Pyx_IS_TYPE(obj, &PySet_Type)
 #endif
 #if PY_VERSION_HEX >= 0x030900A4
   #define __Pyx_SET_REFCNT(obj, refcnt) Py_SET_REFCNT(obj, refcnt)
   #define __Pyx_SET_SIZE(obj, size) Py_SET_SIZE(obj, size)
 #else
   #define __Pyx_SET_REFCNT(obj, refcnt) Py_REFCNT(obj) = (refcnt)
   #define __Pyx_SET_SIZE(obj, size) Py_SIZE(obj) = (size)
 #endif
 #if CYTHON_ASSUME_SAFE_MACROS
+  #define __Pyx_PySequence_ITEM(o, i) PySequence_ITEM(o, i)
   #define __Pyx_PySequence_SIZE(seq)  Py_SIZE(seq)
+  #define __Pyx_PyTuple_SET_ITEM(o, i, v) (PyTuple_SET_ITEM(o, i, v), (0))
+  #define __Pyx_PyList_SET_ITEM(o, i, v) (PyList_SET_ITEM(o, i, v), (0))
+  #define __Pyx_PyTuple_GET_SIZE(o) PyTuple_GET_SIZE(o)
+  #define __Pyx_PyList_GET_SIZE(o) PyList_GET_SIZE(o)
+  #define __Pyx_PySet_GET_SIZE(o) PySet_GET_SIZE(o)
+  #define __Pyx_PyBytes_GET_SIZE(o) PyBytes_GET_SIZE(o)
+  #define __Pyx_PyByteArray_GET_SIZE(o) PyByteArray_GET_SIZE(o)
 #else
+  #define __Pyx_PySequence_ITEM(o, i) PySequence_GetItem(o, i)
   #define __Pyx_PySequence_SIZE(seq)  PySequence_Size(seq)
+  #define __Pyx_PyTuple_SET_ITEM(o, i, v) PyTuple_SetItem(o, i, v)
+  #define __Pyx_PyList_SET_ITEM(o, i, v) PyList_SetItem(o, i, v)
+  #define __Pyx_PyTuple_GET_SIZE(o) PyTuple_Size(o)
+  #define __Pyx_PyList_GET_SIZE(o) PyList_Size(o)
+  #define __Pyx_PySet_GET_SIZE(o) PySet_Size(o)
+  #define __Pyx_PyBytes_GET_SIZE(o) PyBytes_Size(o)
+  #define __Pyx_PyByteArray_GET_SIZE(o) PyByteArray_Size(o)
+#endif
+#if __PYX_LIMITED_VERSION_HEX >= 0x030d00A1
+  #define __Pyx_PyImport_AddModuleRef(name) PyImport_AddModuleRef(name)
+#else
+  static CYTHON_INLINE PyObject *__Pyx_PyImport_AddModuleRef(const char *name) {
+      PyObject *module = PyImport_AddModule(name);
+      Py_XINCREF(module);
+      return module;
+  }
 #endif
 #if PY_MAJOR_VERSION >= 3
   #define PyIntObject                  PyLongObject
   #define PyInt_Type                   PyLong_Type
   #define PyInt_Check(op)              PyLong_Check(op)
   #define PyInt_CheckExact(op)         PyLong_CheckExact(op)
+  #define __Pyx_Py3Int_Check(op)       PyLong_Check(op)
+  #define __Pyx_Py3Int_CheckExact(op)  PyLong_CheckExact(op)
   #define PyInt_FromString             PyLong_FromString
   #define PyInt_FromUnicode            PyLong_FromUnicode
   #define PyInt_FromLong               PyLong_FromLong
   #define PyInt_FromSize_t             PyLong_FromSize_t
   #define PyInt_FromSsize_t            PyLong_FromSsize_t
   #define PyInt_AsLong                 PyLong_AsLong
   #define PyInt_AS_LONG                PyLong_AS_LONG
   #define PyInt_AsSsize_t              PyLong_AsSsize_t
   #define PyInt_AsUnsignedLongMask     PyLong_AsUnsignedLongMask
   #define PyInt_AsUnsignedLongLongMask PyLong_AsUnsignedLongLongMask
   #define PyNumber_Int                 PyNumber_Long
+#else
+  #define __Pyx_Py3Int_Check(op)       (PyLong_Check(op) || PyInt_Check(op))
+  #define __Pyx_Py3Int_CheckExact(op)  (PyLong_CheckExact(op) || PyInt_CheckExact(op))
 #endif
 #if PY_MAJOR_VERSION >= 3
   #define PyBoolObject                 PyLongObject
 #endif
 #if PY_MAJOR_VERSION >= 3 && CYTHON_COMPILING_IN_PYPY
   #ifndef PyUnicode_InternFromString
     #define PyUnicode_InternFromString(s) PyUnicode_FromString(s)
@@ -699,19 +1173,14 @@
   typedef long Py_hash_t;
   #define __Pyx_PyInt_FromHash_t PyInt_FromLong
   #define __Pyx_PyInt_AsHash_t   __Pyx_PyIndex_AsHash_t
 #else
   #define __Pyx_PyInt_FromHash_t PyInt_FromSsize_t
   #define __Pyx_PyInt_AsHash_t   __Pyx_PyIndex_AsSsize_t
 #endif
-#if PY_MAJOR_VERSION >= 3
-  #define __Pyx_PyMethod_New(func, self, klass) ((self) ? ((void)(klass), PyMethod_New(func, self)) : __Pyx_NewRef(func))
-#else
-  #define __Pyx_PyMethod_New(func, self, klass) PyMethod_New(func, self, klass)
-#endif
 #if CYTHON_USE_ASYNC_SLOTS
   #if PY_VERSION_HEX >= 0x030500B1
     #define __Pyx_PyAsyncMethodsStruct PyAsyncMethods
     #define __Pyx_PyType_AsAsync(obj) (Py_TYPE(obj)->tp_as_async)
   #else
     #define __Pyx_PyType_AsAsync(obj) ((__Pyx_PyAsyncMethodsStruct*) (Py_TYPE(obj)->tp_reserved))
   #endif
@@ -744,39 +1213,48 @@
 #if defined(__CYGWIN__) && defined(_LDBL_EQ_DBL)
 #define __Pyx_truncl trunc
 #else
 #define __Pyx_truncl truncl
 #endif
 
 #define __PYX_MARK_ERR_POS(f_index, lineno) \
-    { __pyx_filename = __pyx_f[f_index]; (void)__pyx_filename; __pyx_lineno = lineno; (void)__pyx_lineno; __pyx_clineno = __LINE__; (void)__pyx_clineno; }
+    { __pyx_filename = __pyx_f[f_index]; (void)__pyx_filename; __pyx_lineno = lineno; (void)__pyx_lineno; __pyx_clineno = __LINE__;  (void)__pyx_clineno; }
 #define __PYX_ERR(f_index, lineno, Ln_error) \
     { __PYX_MARK_ERR_POS(f_index, lineno) goto Ln_error; }
 
-#ifndef __PYX_EXTERN_C
+#ifdef CYTHON_EXTERN_C
+    #undef __PYX_EXTERN_C
+    #define __PYX_EXTERN_C CYTHON_EXTERN_C
+#elif defined(__PYX_EXTERN_C)
+    #ifdef _MSC_VER
+    #pragma message ("Please do not define the '__PYX_EXTERN_C' macro externally. Use 'CYTHON_EXTERN_C' instead.")
+    #else
+    #warning Please do not define the '__PYX_EXTERN_C' macro externally. Use 'CYTHON_EXTERN_C' instead.
+    #endif
+#else
   #ifdef __cplusplus
     #define __PYX_EXTERN_C extern "C"
   #else
     #define __PYX_EXTERN_C extern
   #endif
 #endif
 
-#define __PYX_HAVE__argos__cutility
-#define __PYX_HAVE_API__argos__cutility
+#define __PYX_HAVE__yolact__utils__cython_nms
+#define __PYX_HAVE_API__yolact__utils__cython_nms
 /* Early includes */
 #include <string.h>
 #include <stdio.h>
+
+    /* Using NumPy API declarations from "numpy/__init__.cython-30.pxd" */
+    
 #include "numpy/arrayobject.h"
 #include "numpy/ndarrayobject.h"
 #include "numpy/ndarraytypes.h"
 #include "numpy/arrayscalars.h"
 #include "numpy/ufuncobject.h"
-
-    /* NumPy API declarations from "numpy/__init__.pxd" */
-    
 #ifdef _OPENMP
 #include <omp.h>
 #endif /* _OPENMP */
 
 #if defined(PYREX_WITHOUT_ASSERTIONS) && !defined(CYTHON_WITHOUT_ASSERTIONS)
 #define CYTHON_WITHOUT_ASSERTIONS
 #endif
@@ -817,17 +1295,18 @@
 #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
     #define __Pyx_sst_abs(value) llabs(value)
 #elif defined (__GNUC__)
     #define __Pyx_sst_abs(value) __builtin_llabs(value)
 #else
     #define __Pyx_sst_abs(value) ((value<0) ? -value : value)
 #endif
+static CYTHON_INLINE Py_ssize_t __Pyx_ssize_strlen(const char *s);
 static CYTHON_INLINE const char* __Pyx_PyObject_AsString(PyObject*);
 static CYTHON_INLINE const char* __Pyx_PyObject_AsStringAndSize(PyObject*, Py_ssize_t* length);
-#define __Pyx_PyByteArray_FromString(s) PyByteArray_FromStringAndSize((const char*)s, strlen((const char*)s))
+static CYTHON_INLINE PyObject* __Pyx_PyByteArray_FromString(const char*);
 #define __Pyx_PyByteArray_FromStringAndSize(s, l) PyByteArray_FromStringAndSize((const char*)s, l)
 #define __Pyx_PyBytes_FromString        PyBytes_FromString
 #define __Pyx_PyBytes_FromStringAndSize PyBytes_FromStringAndSize
 static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(const char*);
 #if PY_MAJOR_VERSION < 3
     #define __Pyx_PyStr_FromString        __Pyx_PyBytes_FromString
     #define __Pyx_PyStr_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
@@ -837,31 +1316,25 @@
 #endif
 #define __Pyx_PyBytes_AsWritableString(s)     ((char*) PyBytes_AS_STRING(s))
 #define __Pyx_PyBytes_AsWritableSString(s)    ((signed char*) PyBytes_AS_STRING(s))
 #define __Pyx_PyBytes_AsWritableUString(s)    ((unsigned char*) PyBytes_AS_STRING(s))
 #define __Pyx_PyBytes_AsString(s)     ((const char*) PyBytes_AS_STRING(s))
 #define __Pyx_PyBytes_AsSString(s)    ((const signed char*) PyBytes_AS_STRING(s))
 #define __Pyx_PyBytes_AsUString(s)    ((const unsigned char*) PyBytes_AS_STRING(s))
-#define __Pyx_PyObject_AsWritableString(s)    ((char*) __Pyx_PyObject_AsString(s))
-#define __Pyx_PyObject_AsWritableSString(s)    ((signed char*) __Pyx_PyObject_AsString(s))
-#define __Pyx_PyObject_AsWritableUString(s)    ((unsigned char*) __Pyx_PyObject_AsString(s))
+#define __Pyx_PyObject_AsWritableString(s)    ((char*)(__pyx_uintptr_t) __Pyx_PyObject_AsString(s))
+#define __Pyx_PyObject_AsWritableSString(s)    ((signed char*)(__pyx_uintptr_t) __Pyx_PyObject_AsString(s))
+#define __Pyx_PyObject_AsWritableUString(s)    ((unsigned char*)(__pyx_uintptr_t) __Pyx_PyObject_AsString(s))
 #define __Pyx_PyObject_AsSString(s)    ((const signed char*) __Pyx_PyObject_AsString(s))
 #define __Pyx_PyObject_AsUString(s)    ((const unsigned char*) __Pyx_PyObject_AsString(s))
 #define __Pyx_PyObject_FromCString(s)  __Pyx_PyObject_FromString((const char*)s)
 #define __Pyx_PyBytes_FromCString(s)   __Pyx_PyBytes_FromString((const char*)s)
 #define __Pyx_PyByteArray_FromCString(s)   __Pyx_PyByteArray_FromString((const char*)s)
 #define __Pyx_PyStr_FromCString(s)     __Pyx_PyStr_FromString((const char*)s)
 #define __Pyx_PyUnicode_FromCString(s) __Pyx_PyUnicode_FromString((const char*)s)
-static CYTHON_INLINE size_t __Pyx_Py_UNICODE_strlen(const Py_UNICODE *u) {
-    const Py_UNICODE *u_end = u;
-    while (*u_end++) ;
-    return (size_t)(u_end - u - 1);
-}
-#define __Pyx_PyUnicode_FromUnicode(u)       PyUnicode_FromUnicode(u, __Pyx_Py_UNICODE_strlen(u))
-#define __Pyx_PyUnicode_FromUnicodeAndLength PyUnicode_FromUnicode
+#define __Pyx_PyUnicode_FromOrdinal(o)       PyUnicode_FromOrdinal((int)o)
 #define __Pyx_PyUnicode_AsUnicode            PyUnicode_AsUnicode
 #define __Pyx_NewRef(obj) (Py_INCREF(obj), obj)
 #define __Pyx_Owned_Py_None(b) __Pyx_NewRef(Py_None)
 static CYTHON_INLINE PyObject * __Pyx_PyBool_FromLong(long b);
 static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject*);
 static CYTHON_INLINE int __Pyx_PyObject_IsTrueAndDecref(PyObject*);
 static CYTHON_INLINE PyObject* __Pyx_PyNumber_IntOrLong(PyObject* x);
@@ -877,16 +1350,62 @@
 #endif
 #define __pyx_PyFloat_AsFloat(x) ((float) __pyx_PyFloat_AsDouble(x))
 #if PY_MAJOR_VERSION >= 3
 #define __Pyx_PyNumber_Int(x) (PyLong_CheckExact(x) ? __Pyx_NewRef(x) : PyNumber_Long(x))
 #else
 #define __Pyx_PyNumber_Int(x) (PyInt_CheckExact(x) ? __Pyx_NewRef(x) : PyNumber_Int(x))
 #endif
-#define __Pyx_PyNumber_Float(x) (PyFloat_CheckExact(x) ? __Pyx_NewRef(x) : PyNumber_Float(x))
+#if CYTHON_USE_PYLONG_INTERNALS
+  #if PY_VERSION_HEX >= 0x030C00A7
+  #ifndef _PyLong_SIGN_MASK
+    #define _PyLong_SIGN_MASK 3
+  #endif
+  #ifndef _PyLong_NON_SIZE_BITS
+    #define _PyLong_NON_SIZE_BITS 3
+  #endif
+  #define __Pyx_PyLong_Sign(x)  (((PyLongObject*)x)->long_value.lv_tag & _PyLong_SIGN_MASK)
+  #define __Pyx_PyLong_IsNeg(x)  ((__Pyx_PyLong_Sign(x) & 2) != 0)
+  #define __Pyx_PyLong_IsNonNeg(x)  (!__Pyx_PyLong_IsNeg(x))
+  #define __Pyx_PyLong_IsZero(x)  (__Pyx_PyLong_Sign(x) & 1)
+  #define __Pyx_PyLong_IsPos(x)  (__Pyx_PyLong_Sign(x) == 0)
+  #define __Pyx_PyLong_CompactValueUnsigned(x)  (__Pyx_PyLong_Digits(x)[0])
+  #define __Pyx_PyLong_DigitCount(x)  ((Py_ssize_t) (((PyLongObject*)x)->long_value.lv_tag >> _PyLong_NON_SIZE_BITS))
+  #define __Pyx_PyLong_SignedDigitCount(x)\
+        ((1 - (Py_ssize_t) __Pyx_PyLong_Sign(x)) * __Pyx_PyLong_DigitCount(x))
+  #if defined(PyUnstable_Long_IsCompact) && defined(PyUnstable_Long_CompactValue)
+    #define __Pyx_PyLong_IsCompact(x)     PyUnstable_Long_IsCompact((PyLongObject*) x)
+    #define __Pyx_PyLong_CompactValue(x)  PyUnstable_Long_CompactValue((PyLongObject*) x)
+  #else
+    #define __Pyx_PyLong_IsCompact(x)     (((PyLongObject*)x)->long_value.lv_tag < (2 << _PyLong_NON_SIZE_BITS))
+    #define __Pyx_PyLong_CompactValue(x)  ((1 - (Py_ssize_t) __Pyx_PyLong_Sign(x)) * (Py_ssize_t) __Pyx_PyLong_Digits(x)[0])
+  #endif
+  typedef Py_ssize_t  __Pyx_compact_pylong;
+  typedef size_t  __Pyx_compact_upylong;
+  #else
+  #define __Pyx_PyLong_IsNeg(x)  (Py_SIZE(x) < 0)
+  #define __Pyx_PyLong_IsNonNeg(x)  (Py_SIZE(x) >= 0)
+  #define __Pyx_PyLong_IsZero(x)  (Py_SIZE(x) == 0)
+  #define __Pyx_PyLong_IsPos(x)  (Py_SIZE(x) > 0)
+  #define __Pyx_PyLong_CompactValueUnsigned(x)  ((Py_SIZE(x) == 0) ? 0 : __Pyx_PyLong_Digits(x)[0])
+  #define __Pyx_PyLong_DigitCount(x)  __Pyx_sst_abs(Py_SIZE(x))
+  #define __Pyx_PyLong_SignedDigitCount(x)  Py_SIZE(x)
+  #define __Pyx_PyLong_IsCompact(x)  (Py_SIZE(x) == 0 || Py_SIZE(x) == 1 || Py_SIZE(x) == -1)
+  #define __Pyx_PyLong_CompactValue(x)\
+        ((Py_SIZE(x) == 0) ? (sdigit) 0 : ((Py_SIZE(x) < 0) ? -(sdigit)__Pyx_PyLong_Digits(x)[0] : (sdigit)__Pyx_PyLong_Digits(x)[0]))
+  typedef sdigit  __Pyx_compact_pylong;
+  typedef digit  __Pyx_compact_upylong;
+  #endif
+  #if PY_VERSION_HEX >= 0x030C00A5
+  #define __Pyx_PyLong_Digits(x)  (((PyLongObject*)x)->long_value.ob_digit)
+  #else
+  #define __Pyx_PyLong_Digits(x)  (((PyLongObject*)x)->ob_digit)
+  #endif
+#endif
 #if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
+#include <string.h>
 static int __Pyx_sys_getdefaultencoding_not_ascii;
 static int __Pyx_init_sys_getdefaultencoding_params(void) {
     PyObject* sys;
     PyObject* default_encoding = NULL;
     PyObject* ascii_chars_u = NULL;
     PyObject* ascii_chars_b = NULL;
     const char* default_encoding_c;
@@ -899,15 +1418,15 @@
     if (!default_encoding_c) goto bad;
     if (strcmp(default_encoding_c, "ascii") == 0) {
         __Pyx_sys_getdefaultencoding_not_ascii = 0;
     } else {
         char ascii_chars[128];
         int c;
         for (c = 0; c < 128; c++) {
-            ascii_chars[c] = c;
+            ascii_chars[c] = (char) c;
         }
         __Pyx_sys_getdefaultencoding_not_ascii = 1;
         ascii_chars_u = PyUnicode_DecodeASCII(ascii_chars, 128, NULL);
         if (!ascii_chars_u) goto bad;
         ascii_chars_b = PyUnicode_AsEncodedString(ascii_chars_u, default_encoding_c, NULL);
         if (!ascii_chars_b || !PyBytes_Check(ascii_chars_b) || memcmp(ascii_chars, PyBytes_AS_STRING(ascii_chars_b), 128) != 0) {
             PyErr_Format(
@@ -929,14 +1448,15 @@
 }
 #endif
 #if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT && PY_MAJOR_VERSION >= 3
 #define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_DecodeUTF8(c_str, size, NULL)
 #else
 #define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_Decode(c_str, size, __PYX_DEFAULT_STRING_ENCODING, NULL)
 #if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
+#include <string.h>
 static char* __PYX_DEFAULT_STRING_ENCODING;
 static int __Pyx_init_sys_getdefaultencoding_params(void) {
     PyObject* sys;
     PyObject* default_encoding = NULL;
     char* default_encoding_c;
     sys = PyImport_ImportModule("sys");
     if (!sys) goto bad;
@@ -964,31 +1484,27 @@
   #define unlikely(x) __builtin_expect(!!(x), 0)
 #else /* !__GNUC__ or GCC < 2.95 */
   #define likely(x)   (x)
   #define unlikely(x) (x)
 #endif /* __GNUC__ */
 static CYTHON_INLINE void __Pyx_pretend_to_initialize(void* ptr) { (void)ptr; }
 
+#if !CYTHON_USE_MODULE_STATE
 static PyObject *__pyx_m = NULL;
-static PyObject *__pyx_d;
-static PyObject *__pyx_b;
-static PyObject *__pyx_cython_runtime = NULL;
-static PyObject *__pyx_empty_tuple;
-static PyObject *__pyx_empty_bytes;
-static PyObject *__pyx_empty_unicode;
+#endif
 static int __pyx_lineno;
 static int __pyx_clineno = 0;
-static const char * __pyx_cfilenm= __FILE__;
+static const char * __pyx_cfilenm = __FILE__;
 static const char *__pyx_filename;
 
 /* Header.proto */
 #if !defined(CYTHON_CCOMPLEX)
   #if defined(__cplusplus)
     #define CYTHON_CCOMPLEX 1
-  #elif defined(_Complex_I)
+  #elif (defined(_Complex_I) && !defined(_MSC_VER)) || ((defined (__STDC_VERSION__) && __STDC_VERSION__ >= 201112L) && !defined(__STDC_NO_COMPLEX__) && !defined(_MSC_VER))
     #define CYTHON_CCOMPLEX 1
   #else
     #define CYTHON_CCOMPLEX 0
   #endif
 #endif
 #if CYTHON_CCOMPLEX
   #ifdef __cplusplus
@@ -998,22 +1514,28 @@
   #endif
 #endif
 #if CYTHON_CCOMPLEX && !defined(__cplusplus) && defined(__sun__) && defined(__GNUC__)
   #undef _Complex_I
   #define _Complex_I 1.0fj
 #endif
 
+/* #### Code section: filename_table ### */
 
 static const char *__pyx_f[] = {
-  "argos\\cutility.pyx",
-  "__init__.pxd",
+  "yolact\\\\utils\\\\cython_nms.pyx",
+  "__init__.cython-30.pxd",
   "type.pxd",
 };
+/* #### Code section: utility_code_proto_before_types ### */
+/* ForceInitThreads.proto */
+#ifndef __PYX_FORCE_INIT_THREADS
+  #define __PYX_FORCE_INIT_THREADS 0
+#endif
+
 /* BufferFormatStructs.proto */
-#define IS_UNSIGNED(type) (((type) -1) > 0)
 struct __Pyx_StructField_;
 #define __PYX_BUF_FLAGS_PACKED_STRUCT (1 << 0)
 typedef struct {
   const char* name;
   struct __Pyx_StructField_* fields;
   size_t size;
   size_t arraysize[8];
@@ -1040,340 +1562,541 @@
   int is_complex;
   char enc_type;
   char new_packmode;
   char enc_packmode;
   char is_valid_array;
 } __Pyx_BufFmt_Context;
 
+/* NoFastGil.proto */
+#define __Pyx_PyGILState_Ensure PyGILState_Ensure
+#define __Pyx_PyGILState_Release PyGILState_Release
+#define __Pyx_FastGIL_Remember()
+#define __Pyx_FastGIL_Forget()
+#define __Pyx_FastGilFuncInit()
 
-/* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":690
+/* #### Code section: numeric_typedefs ### */
+
+/* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":730
  * # in Cython to enable them only on the right systems.
  * 
  * ctypedef npy_int8       int8_t             # <<<<<<<<<<<<<<
  * ctypedef npy_int16      int16_t
  * ctypedef npy_int32      int32_t
  */
 typedef npy_int8 __pyx_t_5numpy_int8_t;
 
-/* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":691
+/* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":731
  * 
  * ctypedef npy_int8       int8_t
  * ctypedef npy_int16      int16_t             # <<<<<<<<<<<<<<
  * ctypedef npy_int32      int32_t
  * ctypedef npy_int64      int64_t
  */
 typedef npy_int16 __pyx_t_5numpy_int16_t;
 
-/* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":692
+/* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":732
  * ctypedef npy_int8       int8_t
  * ctypedef npy_int16      int16_t
  * ctypedef npy_int32      int32_t             # <<<<<<<<<<<<<<
  * ctypedef npy_int64      int64_t
  * #ctypedef npy_int96      int96_t
  */
 typedef npy_int32 __pyx_t_5numpy_int32_t;
 
-/* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":693
+/* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":733
  * ctypedef npy_int16      int16_t
  * ctypedef npy_int32      int32_t
  * ctypedef npy_int64      int64_t             # <<<<<<<<<<<<<<
  * #ctypedef npy_int96      int96_t
  * #ctypedef npy_int128     int128_t
  */
 typedef npy_int64 __pyx_t_5numpy_int64_t;
 
-/* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":697
+/* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":737
  * #ctypedef npy_int128     int128_t
  * 
  * ctypedef npy_uint8      uint8_t             # <<<<<<<<<<<<<<
  * ctypedef npy_uint16     uint16_t
  * ctypedef npy_uint32     uint32_t
  */
 typedef npy_uint8 __pyx_t_5numpy_uint8_t;
 
-/* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":698
+/* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":738
  * 
  * ctypedef npy_uint8      uint8_t
  * ctypedef npy_uint16     uint16_t             # <<<<<<<<<<<<<<
  * ctypedef npy_uint32     uint32_t
  * ctypedef npy_uint64     uint64_t
  */
 typedef npy_uint16 __pyx_t_5numpy_uint16_t;
 
-/* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":699
+/* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":739
  * ctypedef npy_uint8      uint8_t
  * ctypedef npy_uint16     uint16_t
  * ctypedef npy_uint32     uint32_t             # <<<<<<<<<<<<<<
  * ctypedef npy_uint64     uint64_t
  * #ctypedef npy_uint96     uint96_t
  */
 typedef npy_uint32 __pyx_t_5numpy_uint32_t;
 
-/* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":700
+/* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":740
  * ctypedef npy_uint16     uint16_t
  * ctypedef npy_uint32     uint32_t
  * ctypedef npy_uint64     uint64_t             # <<<<<<<<<<<<<<
  * #ctypedef npy_uint96     uint96_t
  * #ctypedef npy_uint128    uint128_t
  */
 typedef npy_uint64 __pyx_t_5numpy_uint64_t;
 
-/* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":704
+/* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":744
  * #ctypedef npy_uint128    uint128_t
  * 
  * ctypedef npy_float32    float32_t             # <<<<<<<<<<<<<<
  * ctypedef npy_float64    float64_t
  * #ctypedef npy_float80    float80_t
  */
 typedef npy_float32 __pyx_t_5numpy_float32_t;
 
-/* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":705
+/* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":745
  * 
  * ctypedef npy_float32    float32_t
  * ctypedef npy_float64    float64_t             # <<<<<<<<<<<<<<
  * #ctypedef npy_float80    float80_t
  * #ctypedef npy_float128   float128_t
  */
 typedef npy_float64 __pyx_t_5numpy_float64_t;
 
-/* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":714
+/* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":754
  * # The int types are mapped a bit surprising --
  * # numpy.int corresponds to 'l' and numpy.long to 'q'
  * ctypedef npy_long       int_t             # <<<<<<<<<<<<<<
- * ctypedef npy_longlong   long_t
  * ctypedef npy_longlong   longlong_t
+ * 
  */
 typedef npy_long __pyx_t_5numpy_int_t;
 
-/* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":715
+/* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":755
  * # numpy.int corresponds to 'l' and numpy.long to 'q'
  * ctypedef npy_long       int_t
- * ctypedef npy_longlong   long_t             # <<<<<<<<<<<<<<
- * ctypedef npy_longlong   longlong_t
- * 
- */
-typedef npy_longlong __pyx_t_5numpy_long_t;
-
-/* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":716
- * ctypedef npy_long       int_t
- * ctypedef npy_longlong   long_t
  * ctypedef npy_longlong   longlong_t             # <<<<<<<<<<<<<<
  * 
  * ctypedef npy_ulong      uint_t
  */
 typedef npy_longlong __pyx_t_5numpy_longlong_t;
 
-/* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":718
+/* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":757
  * ctypedef npy_longlong   longlong_t
  * 
  * ctypedef npy_ulong      uint_t             # <<<<<<<<<<<<<<
- * ctypedef npy_ulonglong  ulong_t
  * ctypedef npy_ulonglong  ulonglong_t
+ * 
  */
 typedef npy_ulong __pyx_t_5numpy_uint_t;
 
-/* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":719
+/* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":758
  * 
  * ctypedef npy_ulong      uint_t
- * ctypedef npy_ulonglong  ulong_t             # <<<<<<<<<<<<<<
- * ctypedef npy_ulonglong  ulonglong_t
- * 
- */
-typedef npy_ulonglong __pyx_t_5numpy_ulong_t;
-
-/* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":720
- * ctypedef npy_ulong      uint_t
- * ctypedef npy_ulonglong  ulong_t
  * ctypedef npy_ulonglong  ulonglong_t             # <<<<<<<<<<<<<<
  * 
  * ctypedef npy_intp       intp_t
  */
 typedef npy_ulonglong __pyx_t_5numpy_ulonglong_t;
 
-/* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":722
+/* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":760
  * ctypedef npy_ulonglong  ulonglong_t
  * 
  * ctypedef npy_intp       intp_t             # <<<<<<<<<<<<<<
  * ctypedef npy_uintp      uintp_t
  * 
  */
 typedef npy_intp __pyx_t_5numpy_intp_t;
 
-/* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":723
+/* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":761
  * 
  * ctypedef npy_intp       intp_t
  * ctypedef npy_uintp      uintp_t             # <<<<<<<<<<<<<<
  * 
  * ctypedef npy_double     float_t
  */
 typedef npy_uintp __pyx_t_5numpy_uintp_t;
 
-/* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":725
+/* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":763
  * ctypedef npy_uintp      uintp_t
  * 
  * ctypedef npy_double     float_t             # <<<<<<<<<<<<<<
  * ctypedef npy_double     double_t
  * ctypedef npy_longdouble longdouble_t
  */
 typedef npy_double __pyx_t_5numpy_float_t;
 
-/* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":726
+/* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":764
  * 
  * ctypedef npy_double     float_t
  * ctypedef npy_double     double_t             # <<<<<<<<<<<<<<
  * ctypedef npy_longdouble longdouble_t
  * 
  */
 typedef npy_double __pyx_t_5numpy_double_t;
 
-/* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":727
+/* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":765
  * ctypedef npy_double     float_t
  * ctypedef npy_double     double_t
  * ctypedef npy_longdouble longdouble_t             # <<<<<<<<<<<<<<
  * 
  * ctypedef npy_cfloat      cfloat_t
  */
 typedef npy_longdouble __pyx_t_5numpy_longdouble_t;
+/* #### Code section: complex_type_declarations ### */
 /* Declarations.proto */
-#if CYTHON_CCOMPLEX
+#if CYTHON_CCOMPLEX && (1) && (!0 || __cplusplus)
   #ifdef __cplusplus
     typedef ::std::complex< float > __pyx_t_float_complex;
   #else
     typedef float _Complex __pyx_t_float_complex;
   #endif
 #else
     typedef struct { float real, imag; } __pyx_t_float_complex;
 #endif
 static CYTHON_INLINE __pyx_t_float_complex __pyx_t_float_complex_from_parts(float, float);
 
 /* Declarations.proto */
-#if CYTHON_CCOMPLEX
+#if CYTHON_CCOMPLEX && (1) && (!0 || __cplusplus)
   #ifdef __cplusplus
     typedef ::std::complex< double > __pyx_t_double_complex;
   #else
     typedef double _Complex __pyx_t_double_complex;
   #endif
 #else
     typedef struct { double real, imag; } __pyx_t_double_complex;
 #endif
 static CYTHON_INLINE __pyx_t_double_complex __pyx_t_double_complex_from_parts(double, double);
 
+/* #### Code section: type_declarations ### */
 
 /*--- Type declarations ---*/
 
-/* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":729
+/* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":767
  * ctypedef npy_longdouble longdouble_t
  * 
  * ctypedef npy_cfloat      cfloat_t             # <<<<<<<<<<<<<<
  * ctypedef npy_cdouble     cdouble_t
  * ctypedef npy_clongdouble clongdouble_t
  */
 typedef npy_cfloat __pyx_t_5numpy_cfloat_t;
 
-/* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":730
+/* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":768
  * 
  * ctypedef npy_cfloat      cfloat_t
  * ctypedef npy_cdouble     cdouble_t             # <<<<<<<<<<<<<<
  * ctypedef npy_clongdouble clongdouble_t
  * 
  */
 typedef npy_cdouble __pyx_t_5numpy_cdouble_t;
 
-/* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":731
+/* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":769
  * ctypedef npy_cfloat      cfloat_t
  * ctypedef npy_cdouble     cdouble_t
  * ctypedef npy_clongdouble clongdouble_t             # <<<<<<<<<<<<<<
  * 
  * ctypedef npy_cdouble     complex_t
  */
 typedef npy_clongdouble __pyx_t_5numpy_clongdouble_t;
 
-/* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":733
+/* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":771
  * ctypedef npy_clongdouble clongdouble_t
  * 
  * ctypedef npy_cdouble     complex_t             # <<<<<<<<<<<<<<
  * 
  * cdef inline object PyArray_MultiIterNew1(a):
  */
 typedef npy_cdouble __pyx_t_5numpy_complex_t;
+/* #### Code section: utility_code_proto ### */
 
 /* --- Runtime support code (head) --- */
 /* Refnanny.proto */
 #ifndef CYTHON_REFNANNY
   #define CYTHON_REFNANNY 0
 #endif
 #if CYTHON_REFNANNY
   typedef struct {
-    void (*INCREF)(void*, PyObject*, int);
-    void (*DECREF)(void*, PyObject*, int);
-    void (*GOTREF)(void*, PyObject*, int);
-    void (*GIVEREF)(void*, PyObject*, int);
-    void* (*SetupContext)(const char*, int, const char*);
+    void (*INCREF)(void*, PyObject*, Py_ssize_t);
+    void (*DECREF)(void*, PyObject*, Py_ssize_t);
+    void (*GOTREF)(void*, PyObject*, Py_ssize_t);
+    void (*GIVEREF)(void*, PyObject*, Py_ssize_t);
+    void* (*SetupContext)(const char*, Py_ssize_t, const char*);
     void (*FinishContext)(void**);
   } __Pyx_RefNannyAPIStruct;
   static __Pyx_RefNannyAPIStruct *__Pyx_RefNanny = NULL;
   static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname);
   #define __Pyx_RefNannyDeclarations void *__pyx_refnanny = NULL;
 #ifdef WITH_THREAD
   #define __Pyx_RefNannySetupContext(name, acquire_gil)\
           if (acquire_gil) {\
               PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure();\
-              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__);\
+              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), (__LINE__), (__FILE__));\
               PyGILState_Release(__pyx_gilstate_save);\
           } else {\
-              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__);\
+              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), (__LINE__), (__FILE__));\
+          }
+  #define __Pyx_RefNannyFinishContextNogil() {\
+              PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure();\
+              __Pyx_RefNannyFinishContext();\
+              PyGILState_Release(__pyx_gilstate_save);\
           }
 #else
   #define __Pyx_RefNannySetupContext(name, acquire_gil)\
-          __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__)
+          __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), (__LINE__), (__FILE__))
+  #define __Pyx_RefNannyFinishContextNogil() __Pyx_RefNannyFinishContext()
 #endif
+  #define __Pyx_RefNannyFinishContextNogil() {\
+              PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure();\
+              __Pyx_RefNannyFinishContext();\
+              PyGILState_Release(__pyx_gilstate_save);\
+          }
   #define __Pyx_RefNannyFinishContext()\
           __Pyx_RefNanny->FinishContext(&__pyx_refnanny)
-  #define __Pyx_INCREF(r)  __Pyx_RefNanny->INCREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
-  #define __Pyx_DECREF(r)  __Pyx_RefNanny->DECREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
-  #define __Pyx_GOTREF(r)  __Pyx_RefNanny->GOTREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
-  #define __Pyx_GIVEREF(r) __Pyx_RefNanny->GIVEREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
-  #define __Pyx_XINCREF(r)  do { if((r) != NULL) {__Pyx_INCREF(r); }} while(0)
-  #define __Pyx_XDECREF(r)  do { if((r) != NULL) {__Pyx_DECREF(r); }} while(0)
-  #define __Pyx_XGOTREF(r)  do { if((r) != NULL) {__Pyx_GOTREF(r); }} while(0)
-  #define __Pyx_XGIVEREF(r) do { if((r) != NULL) {__Pyx_GIVEREF(r);}} while(0)
+  #define __Pyx_INCREF(r)  __Pyx_RefNanny->INCREF(__pyx_refnanny, (PyObject *)(r), (__LINE__))
+  #define __Pyx_DECREF(r)  __Pyx_RefNanny->DECREF(__pyx_refnanny, (PyObject *)(r), (__LINE__))
+  #define __Pyx_GOTREF(r)  __Pyx_RefNanny->GOTREF(__pyx_refnanny, (PyObject *)(r), (__LINE__))
+  #define __Pyx_GIVEREF(r) __Pyx_RefNanny->GIVEREF(__pyx_refnanny, (PyObject *)(r), (__LINE__))
+  #define __Pyx_XINCREF(r)  do { if((r) == NULL); else {__Pyx_INCREF(r); }} while(0)
+  #define __Pyx_XDECREF(r)  do { if((r) == NULL); else {__Pyx_DECREF(r); }} while(0)
+  #define __Pyx_XGOTREF(r)  do { if((r) == NULL); else {__Pyx_GOTREF(r); }} while(0)
+  #define __Pyx_XGIVEREF(r) do { if((r) == NULL); else {__Pyx_GIVEREF(r);}} while(0)
 #else
   #define __Pyx_RefNannyDeclarations
   #define __Pyx_RefNannySetupContext(name, acquire_gil)
+  #define __Pyx_RefNannyFinishContextNogil()
   #define __Pyx_RefNannyFinishContext()
   #define __Pyx_INCREF(r) Py_INCREF(r)
   #define __Pyx_DECREF(r) Py_DECREF(r)
   #define __Pyx_GOTREF(r)
   #define __Pyx_GIVEREF(r)
   #define __Pyx_XINCREF(r) Py_XINCREF(r)
   #define __Pyx_XDECREF(r) Py_XDECREF(r)
   #define __Pyx_XGOTREF(r)
   #define __Pyx_XGIVEREF(r)
 #endif
+#define __Pyx_Py_XDECREF_SET(r, v) do {\
+        PyObject *tmp = (PyObject *) r;\
+        r = v; Py_XDECREF(tmp);\
+    } while (0)
 #define __Pyx_XDECREF_SET(r, v) do {\
         PyObject *tmp = (PyObject *) r;\
         r = v; __Pyx_XDECREF(tmp);\
     } while (0)
 #define __Pyx_DECREF_SET(r, v) do {\
         PyObject *tmp = (PyObject *) r;\
         r = v; __Pyx_DECREF(tmp);\
     } while (0)
 #define __Pyx_CLEAR(r)    do { PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);} while(0)
 #define __Pyx_XCLEAR(r)   do { if((r) != NULL) {PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);}} while(0)
 
+/* PyErrExceptionMatches.proto */
+#if CYTHON_FAST_THREAD_STATE
+#define __Pyx_PyErr_ExceptionMatches(err) __Pyx_PyErr_ExceptionMatchesInState(__pyx_tstate, err)
+static CYTHON_INLINE int __Pyx_PyErr_ExceptionMatchesInState(PyThreadState* tstate, PyObject* err);
+#else
+#define __Pyx_PyErr_ExceptionMatches(err)  PyErr_ExceptionMatches(err)
+#endif
+
+/* PyThreadStateGet.proto */
+#if CYTHON_FAST_THREAD_STATE
+#define __Pyx_PyThreadState_declare  PyThreadState *__pyx_tstate;
+#define __Pyx_PyThreadState_assign  __pyx_tstate = __Pyx_PyThreadState_Current;
+#if PY_VERSION_HEX >= 0x030C00A6
+#define __Pyx_PyErr_Occurred()  (__pyx_tstate->current_exception != NULL)
+#define __Pyx_PyErr_CurrentExceptionType()  (__pyx_tstate->current_exception ? (PyObject*) Py_TYPE(__pyx_tstate->current_exception) : (PyObject*) NULL)
+#else
+#define __Pyx_PyErr_Occurred()  (__pyx_tstate->curexc_type != NULL)
+#define __Pyx_PyErr_CurrentExceptionType()  (__pyx_tstate->curexc_type)
+#endif
+#else
+#define __Pyx_PyThreadState_declare
+#define __Pyx_PyThreadState_assign
+#define __Pyx_PyErr_Occurred()  (PyErr_Occurred() != NULL)
+#define __Pyx_PyErr_CurrentExceptionType()  PyErr_Occurred()
+#endif
+
+/* PyErrFetchRestore.proto */
+#if CYTHON_FAST_THREAD_STATE
+#define __Pyx_PyErr_Clear() __Pyx_ErrRestore(NULL, NULL, NULL)
+#define __Pyx_ErrRestoreWithState(type, value, tb)  __Pyx_ErrRestoreInState(PyThreadState_GET(), type, value, tb)
+#define __Pyx_ErrFetchWithState(type, value, tb)    __Pyx_ErrFetchInState(PyThreadState_GET(), type, value, tb)
+#define __Pyx_ErrRestore(type, value, tb)  __Pyx_ErrRestoreInState(__pyx_tstate, type, value, tb)
+#define __Pyx_ErrFetch(type, value, tb)    __Pyx_ErrFetchInState(__pyx_tstate, type, value, tb)
+static CYTHON_INLINE void __Pyx_ErrRestoreInState(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb);
+static CYTHON_INLINE void __Pyx_ErrFetchInState(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A6
+#define __Pyx_PyErr_SetNone(exc) (Py_INCREF(exc), __Pyx_ErrRestore((exc), NULL, NULL))
+#else
+#define __Pyx_PyErr_SetNone(exc) PyErr_SetNone(exc)
+#endif
+#else
+#define __Pyx_PyErr_Clear() PyErr_Clear()
+#define __Pyx_PyErr_SetNone(exc) PyErr_SetNone(exc)
+#define __Pyx_ErrRestoreWithState(type, value, tb)  PyErr_Restore(type, value, tb)
+#define __Pyx_ErrFetchWithState(type, value, tb)  PyErr_Fetch(type, value, tb)
+#define __Pyx_ErrRestoreInState(tstate, type, value, tb)  PyErr_Restore(type, value, tb)
+#define __Pyx_ErrFetchInState(tstate, type, value, tb)  PyErr_Fetch(type, value, tb)
+#define __Pyx_ErrRestore(type, value, tb)  PyErr_Restore(type, value, tb)
+#define __Pyx_ErrFetch(type, value, tb)  PyErr_Fetch(type, value, tb)
+#endif
+
 /* PyObjectGetAttrStr.proto */
 #if CYTHON_USE_TYPE_SLOTS
 static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStr(PyObject* obj, PyObject* attr_name);
 #else
 #define __Pyx_PyObject_GetAttrStr(o,n) PyObject_GetAttr(o,n)
 #endif
 
+/* PyObjectGetAttrStrNoError.proto */
+static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStrNoError(PyObject* obj, PyObject* attr_name);
+
 /* GetBuiltinName.proto */
 static PyObject *__Pyx_GetBuiltinName(PyObject *name);
 
+/* GetTopmostException.proto */
+#if CYTHON_USE_EXC_INFO_STACK && CYTHON_FAST_THREAD_STATE
+static _PyErr_StackItem * __Pyx_PyErr_GetTopmostException(PyThreadState *tstate);
+#endif
+
+/* SaveResetException.proto */
+#if CYTHON_FAST_THREAD_STATE
+#define __Pyx_ExceptionSave(type, value, tb)  __Pyx__ExceptionSave(__pyx_tstate, type, value, tb)
+static CYTHON_INLINE void __Pyx__ExceptionSave(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
+#define __Pyx_ExceptionReset(type, value, tb)  __Pyx__ExceptionReset(__pyx_tstate, type, value, tb)
+static CYTHON_INLINE void __Pyx__ExceptionReset(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb);
+#else
+#define __Pyx_ExceptionSave(type, value, tb)   PyErr_GetExcInfo(type, value, tb)
+#define __Pyx_ExceptionReset(type, value, tb)  PyErr_SetExcInfo(type, value, tb)
+#endif
+
+/* GetException.proto */
+#if CYTHON_FAST_THREAD_STATE
+#define __Pyx_GetException(type, value, tb)  __Pyx__GetException(__pyx_tstate, type, value, tb)
+static int __Pyx__GetException(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
+#else
+static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb);
+#endif
+
+/* PyObjectCall.proto */
+#if CYTHON_COMPILING_IN_CPYTHON
+static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw);
+#else
+#define __Pyx_PyObject_Call(func, arg, kw) PyObject_Call(func, arg, kw)
+#endif
+
+/* RaiseException.proto */
+static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause);
+
+/* TupleAndListFromArray.proto */
+#if CYTHON_COMPILING_IN_CPYTHON
+static CYTHON_INLINE PyObject* __Pyx_PyList_FromArray(PyObject *const *src, Py_ssize_t n);
+static CYTHON_INLINE PyObject* __Pyx_PyTuple_FromArray(PyObject *const *src, Py_ssize_t n);
+#endif
+
+/* IncludeStringH.proto */
+#include <string.h>
+
+/* BytesEquals.proto */
+static CYTHON_INLINE int __Pyx_PyBytes_Equals(PyObject* s1, PyObject* s2, int equals);
+
+/* UnicodeEquals.proto */
+static CYTHON_INLINE int __Pyx_PyUnicode_Equals(PyObject* s1, PyObject* s2, int equals);
+
+/* fastcall.proto */
+#if CYTHON_AVOID_BORROWED_REFS
+    #define __Pyx_Arg_VARARGS(args, i) PySequence_GetItem(args, i)
+#elif CYTHON_ASSUME_SAFE_MACROS
+    #define __Pyx_Arg_VARARGS(args, i) PyTuple_GET_ITEM(args, i)
+#else
+    #define __Pyx_Arg_VARARGS(args, i) PyTuple_GetItem(args, i)
+#endif
+#if CYTHON_AVOID_BORROWED_REFS
+    #define __Pyx_Arg_NewRef_VARARGS(arg) __Pyx_NewRef(arg)
+    #define __Pyx_Arg_XDECREF_VARARGS(arg) Py_XDECREF(arg)
+#else
+    #define __Pyx_Arg_NewRef_VARARGS(arg) arg
+    #define __Pyx_Arg_XDECREF_VARARGS(arg)
+#endif
+#define __Pyx_NumKwargs_VARARGS(kwds) PyDict_Size(kwds)
+#define __Pyx_KwValues_VARARGS(args, nargs) NULL
+#define __Pyx_GetKwValue_VARARGS(kw, kwvalues, s) __Pyx_PyDict_GetItemStrWithError(kw, s)
+#define __Pyx_KwargsAsDict_VARARGS(kw, kwvalues) PyDict_Copy(kw)
+#if CYTHON_METH_FASTCALL
+    #define __Pyx_Arg_FASTCALL(args, i) args[i]
+    #define __Pyx_NumKwargs_FASTCALL(kwds) PyTuple_GET_SIZE(kwds)
+    #define __Pyx_KwValues_FASTCALL(args, nargs) ((args) + (nargs))
+    static CYTHON_INLINE PyObject * __Pyx_GetKwValue_FASTCALL(PyObject *kwnames, PyObject *const *kwvalues, PyObject *s);
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030d0000
+    CYTHON_UNUSED static PyObject *__Pyx_KwargsAsDict_FASTCALL(PyObject *kwnames, PyObject *const *kwvalues);
+  #else
+    #define __Pyx_KwargsAsDict_FASTCALL(kw, kwvalues) _PyStack_AsDict(kwvalues, kw)
+  #endif
+    #define __Pyx_Arg_NewRef_FASTCALL(arg) arg  /* no-op, __Pyx_Arg_FASTCALL is direct and this needs
+                                                   to have the same reference counting */
+    #define __Pyx_Arg_XDECREF_FASTCALL(arg)
+#else
+    #define __Pyx_Arg_FASTCALL __Pyx_Arg_VARARGS
+    #define __Pyx_NumKwargs_FASTCALL __Pyx_NumKwargs_VARARGS
+    #define __Pyx_KwValues_FASTCALL __Pyx_KwValues_VARARGS
+    #define __Pyx_GetKwValue_FASTCALL __Pyx_GetKwValue_VARARGS
+    #define __Pyx_KwargsAsDict_FASTCALL __Pyx_KwargsAsDict_VARARGS
+    #define __Pyx_Arg_NewRef_FASTCALL(arg) __Pyx_Arg_NewRef_VARARGS(arg)
+    #define __Pyx_Arg_XDECREF_FASTCALL(arg) __Pyx_Arg_XDECREF_VARARGS(arg)
+#endif
+#if CYTHON_COMPILING_IN_CPYTHON && CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+#define __Pyx_ArgsSlice_VARARGS(args, start, stop) __Pyx_PyTuple_FromArray(&__Pyx_Arg_VARARGS(args, start), stop - start)
+#define __Pyx_ArgsSlice_FASTCALL(args, start, stop) __Pyx_PyTuple_FromArray(&__Pyx_Arg_FASTCALL(args, start), stop - start)
+#else
+#define __Pyx_ArgsSlice_VARARGS(args, start, stop) PyTuple_GetSlice(args, start, stop)
+#define __Pyx_ArgsSlice_FASTCALL(args, start, stop) PyTuple_GetSlice(args, start, stop)
+#endif
+
+/* RaiseArgTupleInvalid.proto */
+static void __Pyx_RaiseArgtupleInvalid(const char* func_name, int exact,
+    Py_ssize_t num_min, Py_ssize_t num_max, Py_ssize_t num_found);
+
+/* RaiseDoubleKeywords.proto */
+static void __Pyx_RaiseDoubleKeywordsError(const char* func_name, PyObject* kw_name);
+
+/* ParseKeywords.proto */
+static int __Pyx_ParseOptionalKeywords(PyObject *kwds, PyObject *const *kwvalues,
+    PyObject **argnames[],
+    PyObject *kwds2, PyObject *values[], Py_ssize_t num_pos_args,
+    const char* function_name);
+
+/* ArgTypeTest.proto */
+#define __Pyx_ArgTypeTest(obj, type, none_allowed, name, exact)\
+    ((likely(__Pyx_IS_TYPE(obj, type) | (none_allowed && (obj == Py_None)))) ? 1 :\
+        __Pyx__ArgTypeTest(obj, type, name, exact))
+static int __Pyx__ArgTypeTest(PyObject *obj, PyTypeObject *type, const char *name, int exact);
+
+/* IsLittleEndian.proto */
+static CYTHON_INLINE int __Pyx_Is_Little_Endian(void);
+
+/* BufferFormatCheck.proto */
+static const char* __Pyx_BufFmt_CheckString(__Pyx_BufFmt_Context* ctx, const char* ts);
+static void __Pyx_BufFmt_Init(__Pyx_BufFmt_Context* ctx,
+                              __Pyx_BufFmt_StackElem* stack,
+                              __Pyx_TypeInfo* type);
+
+/* BufferGetAndValidate.proto */
+#define __Pyx_GetBufferAndValidate(buf, obj, dtype, flags, nd, cast, stack)\
+    ((obj == Py_None || obj == NULL) ?\
+    (__Pyx_ZeroBuffer(buf), 0) :\
+    __Pyx__GetBufferAndValidate(buf, obj, dtype, flags, nd, cast, stack))
+static int  __Pyx__GetBufferAndValidate(Py_buffer* buf, PyObject* obj,
+    __Pyx_TypeInfo* dtype, int flags, int nd, int cast, __Pyx_BufFmt_StackElem* stack);
+static void __Pyx_ZeroBuffer(Py_buffer* buf);
+static CYTHON_INLINE void __Pyx_SafeReleaseBuffer(Py_buffer* info);
+static Py_ssize_t __Pyx_minusones[] = { -1, -1, -1, -1, -1, -1, -1, -1 };
+static Py_ssize_t __Pyx_zeros[] = { 0, 0, 0, 0, 0, 0, 0, 0 };
+
 /* GetItemInt.proto */
 #define __Pyx_GetItemInt(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck)\
     (__Pyx_fits_Py_ssize_t(i, type, is_signed) ?\
     __Pyx_GetItemInt_Fast(o, (Py_ssize_t)i, is_list, wraparound, boundscheck) :\
     (is_list ? (PyErr_SetString(PyExc_IndexError, "list index out of range"), (PyObject*)NULL) :\
                __Pyx_GetItemInt_Generic(o, to_py_func(i))))
 #define __Pyx_GetItemInt_List(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck)\
@@ -1388,67 +2111,79 @@
     (PyErr_SetString(PyExc_IndexError, "tuple index out of range"), (PyObject*)NULL))
 static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i,
                                                               int wraparound, int boundscheck);
 static PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j);
 static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i,
                                                      int is_list, int wraparound, int boundscheck);
 
-/* PyCFunctionFastCall.proto */
-#if CYTHON_FAST_PYCCALL
-static CYTHON_INLINE PyObject *__Pyx_PyCFunction_FastCall(PyObject *func, PyObject **args, Py_ssize_t nargs);
-#else
-#define __Pyx_PyCFunction_FastCall(func, args, nargs)  (assert(0), NULL)
-#endif
-
 /* PyFunctionFastCall.proto */
 #if CYTHON_FAST_PYCALL
+#if !CYTHON_VECTORCALL
 #define __Pyx_PyFunction_FastCall(func, args, nargs)\
     __Pyx_PyFunction_FastCallDict((func), (args), (nargs), NULL)
-#if 1 || PY_VERSION_HEX < 0x030600B1
 static PyObject *__Pyx_PyFunction_FastCallDict(PyObject *func, PyObject **args, Py_ssize_t nargs, PyObject *kwargs);
-#else
-#define __Pyx_PyFunction_FastCallDict(func, args, nargs, kwargs) _PyFunction_FastCallDict(func, args, nargs, kwargs)
 #endif
 #define __Pyx_BUILD_ASSERT_EXPR(cond)\
     (sizeof(char [1 - 2*!(cond)]) - 1)
 #ifndef Py_MEMBER_SIZE
 #define Py_MEMBER_SIZE(type, member) sizeof(((type *)0)->member)
 #endif
-#if CYTHON_FAST_PYCALL
-  static size_t __pyx_pyframe_localsplus_offset = 0;
+#if !CYTHON_VECTORCALL
+#if PY_VERSION_HEX >= 0x03080000
   #include "frameobject.h"
-#if PY_VERSION_HEX >= 0x030b00a6
+#if PY_VERSION_HEX >= 0x030b00a6 && !CYTHON_COMPILING_IN_LIMITED_API
   #ifndef Py_BUILD_CORE
     #define Py_BUILD_CORE 1
   #endif
   #include "internal/pycore_frame.h"
 #endif
+  #define __Pxy_PyFrame_Initialize_Offsets()
+  #define __Pyx_PyFrame_GetLocalsplus(frame)  ((frame)->f_localsplus)
+#else
+  static size_t __pyx_pyframe_localsplus_offset = 0;
+  #include "frameobject.h"
   #define __Pxy_PyFrame_Initialize_Offsets()\
     ((void)__Pyx_BUILD_ASSERT_EXPR(sizeof(PyFrameObject) == offsetof(PyFrameObject, f_localsplus) + Py_MEMBER_SIZE(PyFrameObject, f_localsplus)),\
      (void)(__pyx_pyframe_localsplus_offset = ((size_t)PyFrame_Type.tp_basicsize) - Py_MEMBER_SIZE(PyFrameObject, f_localsplus)))
   #define __Pyx_PyFrame_GetLocalsplus(frame)\
     (assert(__pyx_pyframe_localsplus_offset), (PyObject **)(((char *)(frame)) + __pyx_pyframe_localsplus_offset))
-#endif // CYTHON_FAST_PYCALL
 #endif
-
-/* PyObjectCall.proto */
-#if CYTHON_COMPILING_IN_CPYTHON
-static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw);
-#else
-#define __Pyx_PyObject_Call(func, arg, kw) PyObject_Call(func, arg, kw)
+#endif
 #endif
 
 /* PyObjectCallMethO.proto */
 #if CYTHON_COMPILING_IN_CPYTHON
 static CYTHON_INLINE PyObject* __Pyx_PyObject_CallMethO(PyObject *func, PyObject *arg);
 #endif
 
+/* PyObjectFastCall.proto */
+#define __Pyx_PyObject_FastCall(func, args, nargs)  __Pyx_PyObject_FastCallDict(func, args, (size_t)(nargs), NULL)
+static CYTHON_INLINE PyObject* __Pyx_PyObject_FastCallDict(PyObject *func, PyObject **args, size_t nargs, PyObject *kwargs);
+
 /* PyObjectCallOneArg.proto */
 static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg);
 
+/* ObjectGetItem.proto */
+#if CYTHON_USE_TYPE_SLOTS
+static CYTHON_INLINE PyObject *__Pyx_PyObject_GetItem(PyObject *obj, PyObject *key);
+#else
+#define __Pyx_PyObject_GetItem(obj, key)  PyObject_GetItem(obj, key)
+#endif
+
+/* ExtTypeTest.proto */
+static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type);
+
+/* PyIntBinop.proto */
+#if !CYTHON_COMPILING_IN_PYPY
+static PyObject* __Pyx_PyInt_AddObjC(PyObject *op1, PyObject *op2, long intval, int inplace, int zerodivision_check);
+#else
+#define __Pyx_PyInt_AddObjC(op1, op2, intval, inplace, zerodivision_check)\
+    (inplace ? PyNumber_InPlaceAdd(op1, op2) : PyNumber_Add(op1, op2))
+#endif
+
 /* PyDictVersioning.proto */
 #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_TYPE_SLOTS
 #define __PYX_DICT_VERSION_INIT  ((PY_UINT64_T) -1)
 #define __PYX_GET_DICT_VERSION(dict)  (((PyDictObject*)(dict))->ma_version_tag)
 #define __PYX_UPDATE_DICT_CACHE(dict, value, cache_var, version_var)\
     (version_var) = __PYX_GET_DICT_VERSION(dict);\
     (cache_var) = (value);
@@ -1469,232 +2204,239 @@
 #define __PYX_GET_DICT_VERSION(dict)  (0)
 #define __PYX_UPDATE_DICT_CACHE(dict, value, cache_var, version_var)
 #define __PYX_PY_DICT_LOOKUP_IF_MODIFIED(VAR, DICT, LOOKUP)  (VAR) = (LOOKUP);
 #endif
 
 /* GetModuleGlobalName.proto */
 #if CYTHON_USE_DICT_VERSIONS
-#define __Pyx_GetModuleGlobalName(var, name)  {\
+#define __Pyx_GetModuleGlobalName(var, name)  do {\
     static PY_UINT64_T __pyx_dict_version = 0;\
     static PyObject *__pyx_dict_cached_value = NULL;\
     (var) = (likely(__pyx_dict_version == __PYX_GET_DICT_VERSION(__pyx_d))) ?\
         (likely(__pyx_dict_cached_value) ? __Pyx_NewRef(__pyx_dict_cached_value) : __Pyx_GetBuiltinName(name)) :\
         __Pyx__GetModuleGlobalName(name, &__pyx_dict_version, &__pyx_dict_cached_value);\
-}
-#define __Pyx_GetModuleGlobalNameUncached(var, name)  {\
+} while(0)
+#define __Pyx_GetModuleGlobalNameUncached(var, name)  do {\
     PY_UINT64_T __pyx_dict_version;\
     PyObject *__pyx_dict_cached_value;\
     (var) = __Pyx__GetModuleGlobalName(name, &__pyx_dict_version, &__pyx_dict_cached_value);\
-}
+} while(0)
 static PyObject *__Pyx__GetModuleGlobalName(PyObject *name, PY_UINT64_T *dict_version, PyObject **dict_cached_value);
 #else
 #define __Pyx_GetModuleGlobalName(var, name)  (var) = __Pyx__GetModuleGlobalName(name)
 #define __Pyx_GetModuleGlobalNameUncached(var, name)  (var) = __Pyx__GetModuleGlobalName(name)
 static CYTHON_INLINE PyObject *__Pyx__GetModuleGlobalName(PyObject *name);
 #endif
 
-/* PyObjectCall2Args.proto */
-static CYTHON_UNUSED PyObject* __Pyx_PyObject_Call2Args(PyObject* function, PyObject* arg1, PyObject* arg2);
-
-/* ExtTypeTest.proto */
-static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type);
-
-/* RaiseArgTupleInvalid.proto */
-static void __Pyx_RaiseArgtupleInvalid(const char* func_name, int exact,
-    Py_ssize_t num_min, Py_ssize_t num_max, Py_ssize_t num_found);
-
-/* RaiseDoubleKeywords.proto */
-static void __Pyx_RaiseDoubleKeywordsError(const char* func_name, PyObject* kw_name);
-
-/* ParseKeywords.proto */
-static int __Pyx_ParseOptionalKeywords(PyObject *kwds, PyObject **argnames[],\
-    PyObject *kwds2, PyObject *values[], Py_ssize_t num_pos_args,\
-    const char* function_name);
-
-/* ArgTypeTest.proto */
-#define __Pyx_ArgTypeTest(obj, type, none_allowed, name, exact)\
-    ((likely((Py_TYPE(obj) == type) | (none_allowed && (obj == Py_None)))) ? 1 :\
-        __Pyx__ArgTypeTest(obj, type, name, exact))
-static int __Pyx__ArgTypeTest(PyObject *obj, PyTypeObject *type, const char *name, int exact);
-
-/* IsLittleEndian.proto */
-static CYTHON_INLINE int __Pyx_Is_Little_Endian(void);
-
-/* BufferFormatCheck.proto */
-static const char* __Pyx_BufFmt_CheckString(__Pyx_BufFmt_Context* ctx, const char* ts);
-static void __Pyx_BufFmt_Init(__Pyx_BufFmt_Context* ctx,
-                              __Pyx_BufFmt_StackElem* stack,
-                              __Pyx_TypeInfo* type);
-
-/* BufferGetAndValidate.proto */
-#define __Pyx_GetBufferAndValidate(buf, obj, dtype, flags, nd, cast, stack)\
-    ((obj == Py_None || obj == NULL) ?\
-    (__Pyx_ZeroBuffer(buf), 0) :\
-    __Pyx__GetBufferAndValidate(buf, obj, dtype, flags, nd, cast, stack))
-static int  __Pyx__GetBufferAndValidate(Py_buffer* buf, PyObject* obj,
-    __Pyx_TypeInfo* dtype, int flags, int nd, int cast, __Pyx_BufFmt_StackElem* stack);
-static void __Pyx_ZeroBuffer(Py_buffer* buf);
-static CYTHON_INLINE void __Pyx_SafeReleaseBuffer(Py_buffer* info);
-static Py_ssize_t __Pyx_minusones[] = { -1, -1, -1, -1, -1, -1, -1, -1 };
-static Py_ssize_t __Pyx_zeros[] = { 0, 0, 0, 0, 0, 0, 0, 0 };
-
-/* ObjectGetItem.proto */
-#if CYTHON_USE_TYPE_SLOTS
-static CYTHON_INLINE PyObject *__Pyx_PyObject_GetItem(PyObject *obj, PyObject* key);
-#else
-#define __Pyx_PyObject_GetItem(obj, key)  PyObject_GetItem(obj, key)
-#endif
-
 #define __Pyx_BufPtrStrided1d(type, buf, i0, s0) (type)((char*)buf + i0 * s0)
-/* PyThreadStateGet.proto */
-#if CYTHON_FAST_THREAD_STATE
-#define __Pyx_PyThreadState_declare  PyThreadState *__pyx_tstate;
-#define __Pyx_PyThreadState_assign  __pyx_tstate = __Pyx_PyThreadState_Current;
-#define __Pyx_PyErr_Occurred()  __pyx_tstate->curexc_type
-#else
-#define __Pyx_PyThreadState_declare
-#define __Pyx_PyThreadState_assign
-#define __Pyx_PyErr_Occurred()  PyErr_Occurred()
-#endif
+/* ErrOccurredWithGIL.proto */
+static CYTHON_INLINE int __Pyx_ErrOccurredWithGIL(void);
 
-/* PyErrFetchRestore.proto */
-#if CYTHON_FAST_THREAD_STATE
-#define __Pyx_PyErr_Clear() __Pyx_ErrRestore(NULL, NULL, NULL)
-#define __Pyx_ErrRestoreWithState(type, value, tb)  __Pyx_ErrRestoreInState(PyThreadState_GET(), type, value, tb)
-#define __Pyx_ErrFetchWithState(type, value, tb)    __Pyx_ErrFetchInState(PyThreadState_GET(), type, value, tb)
-#define __Pyx_ErrRestore(type, value, tb)  __Pyx_ErrRestoreInState(__pyx_tstate, type, value, tb)
-#define __Pyx_ErrFetch(type, value, tb)    __Pyx_ErrFetchInState(__pyx_tstate, type, value, tb)
-static CYTHON_INLINE void __Pyx_ErrRestoreInState(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb);
-static CYTHON_INLINE void __Pyx_ErrFetchInState(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
-#if CYTHON_COMPILING_IN_CPYTHON
-#define __Pyx_PyErr_SetNone(exc) (Py_INCREF(exc), __Pyx_ErrRestore((exc), NULL, NULL))
-#else
-#define __Pyx_PyErr_SetNone(exc) PyErr_SetNone(exc)
-#endif
-#else
-#define __Pyx_PyErr_Clear() PyErr_Clear()
-#define __Pyx_PyErr_SetNone(exc) PyErr_SetNone(exc)
-#define __Pyx_ErrRestoreWithState(type, value, tb)  PyErr_Restore(type, value, tb)
-#define __Pyx_ErrFetchWithState(type, value, tb)  PyErr_Fetch(type, value, tb)
-#define __Pyx_ErrRestoreInState(tstate, type, value, tb)  PyErr_Restore(type, value, tb)
-#define __Pyx_ErrFetchInState(tstate, type, value, tb)  PyErr_Fetch(type, value, tb)
-#define __Pyx_ErrRestore(type, value, tb)  PyErr_Restore(type, value, tb)
-#define __Pyx_ErrFetch(type, value, tb)  PyErr_Fetch(type, value, tb)
-#endif
-
-/* SetItemInt.proto */
-#define __Pyx_SetItemInt(o, i, v, type, is_signed, to_py_func, is_list, wraparound, boundscheck)\
-    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ?\
-    __Pyx_SetItemInt_Fast(o, (Py_ssize_t)i, v, is_list, wraparound, boundscheck) :\
-    (is_list ? (PyErr_SetString(PyExc_IndexError, "list assignment index out of range"), -1) :\
-               __Pyx_SetItemInt_Generic(o, to_py_func(i), v)))
-static int __Pyx_SetItemInt_Generic(PyObject *o, PyObject *j, PyObject *v);
-static CYTHON_INLINE int __Pyx_SetItemInt_Fast(PyObject *o, Py_ssize_t i, PyObject *v,
-                                               int is_list, int wraparound, int boundscheck);
+/* PyIntCompare.proto */
+static CYTHON_INLINE PyObject* __Pyx_PyInt_EqObjC(PyObject *op1, PyObject *op2, long intval, long inplace);
 
-/* RaiseException.proto */
-static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause);
+/* TypeImport.proto */
+#ifndef __PYX_HAVE_RT_ImportType_proto_3_0_10
+#define __PYX_HAVE_RT_ImportType_proto_3_0_10
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 201112L
+#include <stdalign.h>
+#endif
+#if (defined (__STDC_VERSION__) && __STDC_VERSION__ >= 201112L) || __cplusplus >= 201103L
+#define __PYX_GET_STRUCT_ALIGNMENT_3_0_10(s) alignof(s)
+#else
+#define __PYX_GET_STRUCT_ALIGNMENT_3_0_10(s) sizeof(void*)
+#endif
+enum __Pyx_ImportType_CheckSize_3_0_10 {
+   __Pyx_ImportType_CheckSize_Error_3_0_10 = 0,
+   __Pyx_ImportType_CheckSize_Warn_3_0_10 = 1,
+   __Pyx_ImportType_CheckSize_Ignore_3_0_10 = 2
+};
+static PyTypeObject *__Pyx_ImportType_3_0_10(PyObject* module, const char *module_name, const char *class_name, size_t size, size_t alignment, enum __Pyx_ImportType_CheckSize_3_0_10 check_size);
+#endif
 
-/* WriteUnraisableException.proto */
-static void __Pyx_WriteUnraisable(const char *name, int clineno,
-                                  int lineno, const char *filename,
-                                  int full_traceback, int nogil);
+/* Import.proto */
+static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level);
 
-/* PyObjectFormatSimple.proto */
-#if CYTHON_COMPILING_IN_PYPY
-    #define __Pyx_PyObject_FormatSimple(s, f) (\
-        likely(PyUnicode_CheckExact(s)) ? (Py_INCREF(s), s) :\
-        PyObject_Format(s, f))
-#elif PY_MAJOR_VERSION < 3
-    #define __Pyx_PyObject_FormatSimple(s, f) (\
-        likely(PyUnicode_CheckExact(s)) ? (Py_INCREF(s), s) :\
-        likely(PyString_CheckExact(s)) ? PyUnicode_FromEncodedObject(s, NULL, "strict") :\
-        PyObject_Format(s, f))
-#elif CYTHON_USE_TYPE_SLOTS
-    #define __Pyx_PyObject_FormatSimple(s, f) (\
-        likely(PyUnicode_CheckExact(s)) ? (Py_INCREF(s), s) :\
-        likely(PyLong_CheckExact(s)) ? PyLong_Type.tp_str(s) :\
-        likely(PyFloat_CheckExact(s)) ? PyFloat_Type.tp_str(s) :\
-        PyObject_Format(s, f))
-#else
-    #define __Pyx_PyObject_FormatSimple(s, f) (\
-        likely(PyUnicode_CheckExact(s)) ? (Py_INCREF(s), s) :\
-        PyObject_Format(s, f))
+/* ImportDottedModule.proto */
+static PyObject *__Pyx_ImportDottedModule(PyObject *name, PyObject *parts_tuple);
+#if PY_MAJOR_VERSION >= 3
+static PyObject *__Pyx_ImportDottedModule_WalkParts(PyObject *module, PyObject *name, PyObject *parts_tuple);
 #endif
 
-/* GetTopmostException.proto */
-#if CYTHON_USE_EXC_INFO_STACK
-static _PyErr_StackItem * __Pyx_PyErr_GetTopmostException(PyThreadState *tstate);
-#endif
+/* IncludeStructmemberH.proto */
+#include <structmember.h>
 
-/* SaveResetException.proto */
-#if CYTHON_FAST_THREAD_STATE
-#define __Pyx_ExceptionSave(type, value, tb)  __Pyx__ExceptionSave(__pyx_tstate, type, value, tb)
-static CYTHON_INLINE void __Pyx__ExceptionSave(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
-#define __Pyx_ExceptionReset(type, value, tb)  __Pyx__ExceptionReset(__pyx_tstate, type, value, tb)
-static CYTHON_INLINE void __Pyx__ExceptionReset(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb);
-#else
-#define __Pyx_ExceptionSave(type, value, tb)   PyErr_GetExcInfo(type, value, tb)
-#define __Pyx_ExceptionReset(type, value, tb)  PyErr_SetExcInfo(type, value, tb)
+/* FixUpExtensionType.proto */
+#if CYTHON_USE_TYPE_SPECS
+static int __Pyx_fix_up_extension_type_from_spec(PyType_Spec *spec, PyTypeObject *type);
 #endif
 
-/* PyErrExceptionMatches.proto */
-#if CYTHON_FAST_THREAD_STATE
-#define __Pyx_PyErr_ExceptionMatches(err) __Pyx_PyErr_ExceptionMatchesInState(__pyx_tstate, err)
-static CYTHON_INLINE int __Pyx_PyErr_ExceptionMatchesInState(PyThreadState* tstate, PyObject* err);
-#else
-#define __Pyx_PyErr_ExceptionMatches(err)  PyErr_ExceptionMatches(err)
-#endif
+/* FetchSharedCythonModule.proto */
+static PyObject *__Pyx_FetchSharedCythonABIModule(void);
 
-/* GetException.proto */
-#if CYTHON_FAST_THREAD_STATE
-#define __Pyx_GetException(type, value, tb)  __Pyx__GetException(__pyx_tstate, type, value, tb)
-static int __Pyx__GetException(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
+/* FetchCommonType.proto */
+#if !CYTHON_USE_TYPE_SPECS
+static PyTypeObject* __Pyx_FetchCommonType(PyTypeObject* type);
 #else
-static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb);
+static PyTypeObject* __Pyx_FetchCommonTypeFromSpec(PyObject *module, PyType_Spec *spec, PyObject *bases);
 #endif
 
-/* TypeImport.proto */
-#ifndef __PYX_HAVE_RT_ImportType_proto
-#define __PYX_HAVE_RT_ImportType_proto
-enum __Pyx_ImportType_CheckSize {
-   __Pyx_ImportType_CheckSize_Error = 0,
-   __Pyx_ImportType_CheckSize_Warn = 1,
-   __Pyx_ImportType_CheckSize_Ignore = 2
-};
-static PyTypeObject *__Pyx_ImportType(PyObject* module, const char *module_name, const char *class_name, size_t size, enum __Pyx_ImportType_CheckSize check_size);
-#endif
-
-/* Import.proto */
-static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level);
-
-/* ImportFrom.proto */
-static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name);
+/* PyMethodNew.proto */
+#if CYTHON_COMPILING_IN_LIMITED_API
+static PyObject *__Pyx_PyMethod_New(PyObject *func, PyObject *self, PyObject *typ) {
+    PyObject *typesModule=NULL, *methodType=NULL, *result=NULL;
+    CYTHON_UNUSED_VAR(typ);
+    if (!self)
+        return __Pyx_NewRef(func);
+    typesModule = PyImport_ImportModule("types");
+    if (!typesModule) return NULL;
+    methodType = PyObject_GetAttrString(typesModule, "MethodType");
+    Py_DECREF(typesModule);
+    if (!methodType) return NULL;
+    result = PyObject_CallFunctionObjArgs(methodType, func, self, NULL);
+    Py_DECREF(methodType);
+    return result;
+}
+#elif PY_MAJOR_VERSION >= 3
+static PyObject *__Pyx_PyMethod_New(PyObject *func, PyObject *self, PyObject *typ) {
+    CYTHON_UNUSED_VAR(typ);
+    if (!self)
+        return __Pyx_NewRef(func);
+    return PyMethod_New(func, self);
+}
+#else
+    #define __Pyx_PyMethod_New PyMethod_New
+#endif
+
+/* PyVectorcallFastCallDict.proto */
+#if CYTHON_METH_FASTCALL
+static CYTHON_INLINE PyObject *__Pyx_PyVectorcall_FastCallDict(PyObject *func, __pyx_vectorcallfunc vc, PyObject *const *args, size_t nargs, PyObject *kw);
+#endif
+
+/* CythonFunctionShared.proto */
+#define __Pyx_CyFunction_USED
+#define __Pyx_CYFUNCTION_STATICMETHOD  0x01
+#define __Pyx_CYFUNCTION_CLASSMETHOD   0x02
+#define __Pyx_CYFUNCTION_CCLASS        0x04
+#define __Pyx_CYFUNCTION_COROUTINE     0x08
+#define __Pyx_CyFunction_GetClosure(f)\
+    (((__pyx_CyFunctionObject *) (f))->func_closure)
+#if PY_VERSION_HEX < 0x030900B1 || CYTHON_COMPILING_IN_LIMITED_API
+  #define __Pyx_CyFunction_GetClassObj(f)\
+      (((__pyx_CyFunctionObject *) (f))->func_classobj)
+#else
+  #define __Pyx_CyFunction_GetClassObj(f)\
+      ((PyObject*) ((PyCMethodObject *) (f))->mm_class)
+#endif
+#define __Pyx_CyFunction_SetClassObj(f, classobj)\
+    __Pyx__CyFunction_SetClassObj((__pyx_CyFunctionObject *) (f), (classobj))
+#define __Pyx_CyFunction_Defaults(type, f)\
+    ((type *)(((__pyx_CyFunctionObject *) (f))->defaults))
+#define __Pyx_CyFunction_SetDefaultsGetter(f, g)\
+    ((__pyx_CyFunctionObject *) (f))->defaults_getter = (g)
+typedef struct {
+#if CYTHON_COMPILING_IN_LIMITED_API
+    PyObject_HEAD
+    PyObject *func;
+#elif PY_VERSION_HEX < 0x030900B1
+    PyCFunctionObject func;
+#else
+    PyCMethodObject func;
+#endif
+#if CYTHON_BACKPORT_VECTORCALL
+    __pyx_vectorcallfunc func_vectorcall;
+#endif
+#if PY_VERSION_HEX < 0x030500A0 || CYTHON_COMPILING_IN_LIMITED_API
+    PyObject *func_weakreflist;
+#endif
+    PyObject *func_dict;
+    PyObject *func_name;
+    PyObject *func_qualname;
+    PyObject *func_doc;
+    PyObject *func_globals;
+    PyObject *func_code;
+    PyObject *func_closure;
+#if PY_VERSION_HEX < 0x030900B1 || CYTHON_COMPILING_IN_LIMITED_API
+    PyObject *func_classobj;
+#endif
+    void *defaults;
+    int defaults_pyobjects;
+    size_t defaults_size;
+    int flags;
+    PyObject *defaults_tuple;
+    PyObject *defaults_kwdict;
+    PyObject *(*defaults_getter)(PyObject *);
+    PyObject *func_annotations;
+    PyObject *func_is_coroutine;
+} __pyx_CyFunctionObject;
+#undef __Pyx_CyOrPyCFunction_Check
+#define __Pyx_CyFunction_Check(obj)  __Pyx_TypeCheck(obj, __pyx_CyFunctionType)
+#define __Pyx_CyOrPyCFunction_Check(obj)  __Pyx_TypeCheck2(obj, __pyx_CyFunctionType, &PyCFunction_Type)
+#define __Pyx_CyFunction_CheckExact(obj)  __Pyx_IS_TYPE(obj, __pyx_CyFunctionType)
+static CYTHON_INLINE int __Pyx__IsSameCyOrCFunction(PyObject *func, void *cfunc);
+#undef __Pyx_IsSameCFunction
+#define __Pyx_IsSameCFunction(func, cfunc)   __Pyx__IsSameCyOrCFunction(func, cfunc)
+static PyObject *__Pyx_CyFunction_Init(__pyx_CyFunctionObject* op, PyMethodDef *ml,
+                                      int flags, PyObject* qualname,
+                                      PyObject *closure,
+                                      PyObject *module, PyObject *globals,
+                                      PyObject* code);
+static CYTHON_INLINE void __Pyx__CyFunction_SetClassObj(__pyx_CyFunctionObject* f, PyObject* classobj);
+static CYTHON_INLINE void *__Pyx_CyFunction_InitDefaults(PyObject *m,
+                                                         size_t size,
+                                                         int pyobjects);
+static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsTuple(PyObject *m,
+                                                            PyObject *tuple);
+static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsKwDict(PyObject *m,
+                                                             PyObject *dict);
+static CYTHON_INLINE void __Pyx_CyFunction_SetAnnotationsDict(PyObject *m,
+                                                              PyObject *dict);
+static int __pyx_CyFunction_init(PyObject *module);
+#if CYTHON_METH_FASTCALL
+static PyObject * __Pyx_CyFunction_Vectorcall_NOARGS(PyObject *func, PyObject *const *args, size_t nargsf, PyObject *kwnames);
+static PyObject * __Pyx_CyFunction_Vectorcall_O(PyObject *func, PyObject *const *args, size_t nargsf, PyObject *kwnames);
+static PyObject * __Pyx_CyFunction_Vectorcall_FASTCALL_KEYWORDS(PyObject *func, PyObject *const *args, size_t nargsf, PyObject *kwnames);
+static PyObject * __Pyx_CyFunction_Vectorcall_FASTCALL_KEYWORDS_METHOD(PyObject *func, PyObject *const *args, size_t nargsf, PyObject *kwnames);
+#if CYTHON_BACKPORT_VECTORCALL
+#define __Pyx_CyFunction_func_vectorcall(f) (((__pyx_CyFunctionObject*)f)->func_vectorcall)
+#else
+#define __Pyx_CyFunction_func_vectorcall(f) (((PyCFunctionObject*)f)->vectorcall)
+#endif
+#endif
+
+/* CythonFunction.proto */
+static PyObject *__Pyx_CyFunction_New(PyMethodDef *ml,
+                                      int flags, PyObject* qualname,
+                                      PyObject *closure,
+                                      PyObject *module, PyObject *globals,
+                                      PyObject* code);
 
 /* CLineInTraceback.proto */
 #ifdef CYTHON_CLINE_IN_TRACEBACK
 #define __Pyx_CLineForTraceback(tstate, c_line)  (((CYTHON_CLINE_IN_TRACEBACK)) ? c_line : 0)
 #else
 static int __Pyx_CLineForTraceback(PyThreadState *tstate, int c_line);
 #endif
 
 /* CodeObjectCache.proto */
+#if !CYTHON_COMPILING_IN_LIMITED_API
 typedef struct {
     PyCodeObject* code_object;
     int code_line;
 } __Pyx_CodeObjectCacheEntry;
 struct __Pyx_CodeObjectCache {
     int count;
     int max_count;
     __Pyx_CodeObjectCacheEntry* entries;
 };
 static struct __Pyx_CodeObjectCache __pyx_code_cache = {0,0,NULL};
 static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line);
 static PyCodeObject *__pyx_find_code_object(int code_line);
 static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object);
+#endif
 
 /* AddTraceback.proto */
 static void __Pyx_AddTraceback(const char *funcname, int c_line,
                                int py_line, const char *filename);
 
 /* BufferStructDeclare.proto */
 typedef struct {
@@ -1716,15 +2458,15 @@
 #else
     #define __Pyx_GetBuffer PyObject_GetBuffer
     #define __Pyx_ReleaseBuffer PyBuffer_Release
 #endif
 
 
 /* GCCDiagnostics.proto */
-#if defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6))
+#if !defined(__INTEL_COMPILER) && defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6))
 #define __Pyx_HAS_GCC_DIAGNOSTIC
 #endif
 
 /* RealImag.proto */
 #if CYTHON_CCOMPLEX
   #ifdef __cplusplus
     #define __Pyx_CREAL(z) ((z).real())
@@ -1743,15 +2485,15 @@
     #define __Pyx_SET_CIMAG(z,y) ((z).imag(y))
 #else
     #define __Pyx_SET_CREAL(z,x) __Pyx_CREAL(z) = (x)
     #define __Pyx_SET_CIMAG(z,y) __Pyx_CIMAG(z) = (y)
 #endif
 
 /* Arithmetic.proto */
-#if CYTHON_CCOMPLEX
+#if CYTHON_CCOMPLEX && (1) && (!0 || __cplusplus)
     #define __Pyx_c_eq_float(a, b)   ((a)==(b))
     #define __Pyx_c_sum_float(a, b)  ((a)+(b))
     #define __Pyx_c_diff_float(a, b) ((a)-(b))
     #define __Pyx_c_prod_float(a, b) ((a)*(b))
     #define __Pyx_c_quot_float(a, b) ((a)/(b))
     #define __Pyx_c_neg_float(a)     (-(a))
   #ifdef __cplusplus
@@ -1781,15 +2523,15 @@
     #if 1
         static CYTHON_INLINE float __Pyx_c_abs_float(__pyx_t_float_complex);
         static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_pow_float(__pyx_t_float_complex, __pyx_t_float_complex);
     #endif
 #endif
 
 /* Arithmetic.proto */
-#if CYTHON_CCOMPLEX
+#if CYTHON_CCOMPLEX && (1) && (!0 || __cplusplus)
     #define __Pyx_c_eq_double(a, b)   ((a)==(b))
     #define __Pyx_c_sum_double(a, b)  ((a)+(b))
     #define __Pyx_c_diff_double(a, b) ((a)-(b))
     #define __Pyx_c_prod_double(a, b) ((a)*(b))
     #define __Pyx_c_quot_double(a, b) ((a)/(b))
     #define __Pyx_c_neg_double(a)     (-(a))
   #ifdef __cplusplus
@@ -1818,3459 +2560,963 @@
     static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_conj_double(__pyx_t_double_complex);
     #if 1
         static CYTHON_INLINE double __Pyx_c_abs_double(__pyx_t_double_complex);
         static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_pow_double(__pyx_t_double_complex, __pyx_t_double_complex);
     #endif
 #endif
 
-/* CIntToPy.proto */
-static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value);
-
-/* CIntToPy.proto */
-static CYTHON_INLINE PyObject* __Pyx_PyInt_From_npy_long(npy_long value);
-
 /* CIntFromPy.proto */
-static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *);
+static CYTHON_INLINE size_t __Pyx_PyInt_As_size_t(PyObject *);
 
 /* CIntToPy.proto */
-static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int(int value);
+static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value);
 
-/* CIntToPy.proto */
-static CYTHON_INLINE PyObject* __Pyx_PyInt_From_Py_intptr_t(Py_intptr_t value);
+/* FormatTypeName.proto */
+#if CYTHON_COMPILING_IN_LIMITED_API
+typedef PyObject *__Pyx_TypeName;
+#define __Pyx_FMT_TYPENAME "%U"
+static __Pyx_TypeName __Pyx_PyType_GetName(PyTypeObject* tp);
+#define __Pyx_DECREF_TypeName(obj) Py_XDECREF(obj)
+#else
+typedef const char *__Pyx_TypeName;
+#define __Pyx_FMT_TYPENAME "%.200s"
+#define __Pyx_PyType_GetName(tp) ((tp)->tp_name)
+#define __Pyx_DECREF_TypeName(obj)
+#endif
 
 /* CIntFromPy.proto */
-static CYTHON_INLINE Py_intptr_t __Pyx_PyInt_As_Py_intptr_t(PyObject *);
+static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *);
 
 /* CIntFromPy.proto */
-static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *);
+static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *);
 
 /* FastTypeChecks.proto */
 #if CYTHON_COMPILING_IN_CPYTHON
 #define __Pyx_TypeCheck(obj, type) __Pyx_IsSubtype(Py_TYPE(obj), (PyTypeObject *)type)
+#define __Pyx_TypeCheck2(obj, type1, type2) __Pyx_IsAnySubtype2(Py_TYPE(obj), (PyTypeObject *)type1, (PyTypeObject *)type2)
 static CYTHON_INLINE int __Pyx_IsSubtype(PyTypeObject *a, PyTypeObject *b);
+static CYTHON_INLINE int __Pyx_IsAnySubtype2(PyTypeObject *cls, PyTypeObject *a, PyTypeObject *b);
 static CYTHON_INLINE int __Pyx_PyErr_GivenExceptionMatches(PyObject *err, PyObject *type);
 static CYTHON_INLINE int __Pyx_PyErr_GivenExceptionMatches2(PyObject *err, PyObject *type1, PyObject *type2);
 #else
 #define __Pyx_TypeCheck(obj, type) PyObject_TypeCheck(obj, (PyTypeObject *)type)
+#define __Pyx_TypeCheck2(obj, type1, type2) (PyObject_TypeCheck(obj, (PyTypeObject *)type1) || PyObject_TypeCheck(obj, (PyTypeObject *)type2))
 #define __Pyx_PyErr_GivenExceptionMatches(err, type) PyErr_GivenExceptionMatches(err, type)
 #define __Pyx_PyErr_GivenExceptionMatches2(err, type1, type2) (PyErr_GivenExceptionMatches(err, type1) || PyErr_GivenExceptionMatches(err, type2))
 #endif
+#define __Pyx_PyErr_ExceptionMatches2(err1, err2)  __Pyx_PyErr_GivenExceptionMatches2(__Pyx_PyErr_CurrentExceptionType(), err1, err2)
 #define __Pyx_PyException_Check(obj) __Pyx_TypeCheck(obj, PyExc_Exception)
 
 /* CheckBinaryVersion.proto */
-static int __Pyx_check_binary_version(void);
+static unsigned long __Pyx_get_runtime_version(void);
+static int __Pyx_check_binary_version(unsigned long ct_version, unsigned long rt_version, int allow_newer);
 
 /* InitStrings.proto */
 static int __Pyx_InitStrings(__Pyx_StringTabEntry *t);
 
+/* #### Code section: module_declarations ### */
+static CYTHON_INLINE PyObject *__pyx_f_5numpy_7ndarray_4base_base(PyArrayObject *__pyx_v_self); /* proto*/
+static CYTHON_INLINE PyArray_Descr *__pyx_f_5numpy_7ndarray_5descr_descr(PyArrayObject *__pyx_v_self); /* proto*/
+static CYTHON_INLINE int __pyx_f_5numpy_7ndarray_4ndim_ndim(PyArrayObject *__pyx_v_self); /* proto*/
+static CYTHON_INLINE npy_intp *__pyx_f_5numpy_7ndarray_5shape_shape(PyArrayObject *__pyx_v_self); /* proto*/
+static CYTHON_INLINE npy_intp *__pyx_f_5numpy_7ndarray_7strides_strides(PyArrayObject *__pyx_v_self); /* proto*/
+static CYTHON_INLINE npy_intp __pyx_f_5numpy_7ndarray_4size_size(PyArrayObject *__pyx_v_self); /* proto*/
+static CYTHON_INLINE char *__pyx_f_5numpy_7ndarray_4data_data(PyArrayObject *__pyx_v_self); /* proto*/
+
+/* Module declarations from "cython" */
+
+/* Module declarations from "libc.string" */
+
+/* Module declarations from "libc.stdio" */
+
+/* Module declarations from "__builtin__" */
+
+/* Module declarations from "cpython.type" */
 
-/* Module declarations from 'cython' */
+/* Module declarations from "cpython" */
 
-/* Module declarations from 'cpython.buffer' */
+/* Module declarations from "cpython.object" */
 
-/* Module declarations from 'libc.string' */
+/* Module declarations from "cpython.ref" */
 
-/* Module declarations from 'libc.stdio' */
+/* Module declarations from "numpy" */
 
-/* Module declarations from '__builtin__' */
-
-/* Module declarations from 'cpython.type' */
-static PyTypeObject *__pyx_ptype_7cpython_4type_type = 0;
-
-/* Module declarations from 'cpython' */
-
-/* Module declarations from 'cpython.object' */
-
-/* Module declarations from 'cpython.ref' */
-
-/* Module declarations from 'cpython.mem' */
-
-/* Module declarations from 'numpy' */
-
-/* Module declarations from 'numpy' */
-static PyTypeObject *__pyx_ptype_5numpy_dtype = 0;
-static PyTypeObject *__pyx_ptype_5numpy_flatiter = 0;
-static PyTypeObject *__pyx_ptype_5numpy_broadcast = 0;
-static PyTypeObject *__pyx_ptype_5numpy_ndarray = 0;
-static PyTypeObject *__pyx_ptype_5numpy_generic = 0;
-static PyTypeObject *__pyx_ptype_5numpy_number = 0;
-static PyTypeObject *__pyx_ptype_5numpy_integer = 0;
-static PyTypeObject *__pyx_ptype_5numpy_signedinteger = 0;
-static PyTypeObject *__pyx_ptype_5numpy_unsignedinteger = 0;
-static PyTypeObject *__pyx_ptype_5numpy_inexact = 0;
-static PyTypeObject *__pyx_ptype_5numpy_floating = 0;
-static PyTypeObject *__pyx_ptype_5numpy_complexfloating = 0;
-static PyTypeObject *__pyx_ptype_5numpy_flexible = 0;
-static PyTypeObject *__pyx_ptype_5numpy_character = 0;
-static PyTypeObject *__pyx_ptype_5numpy_ufunc = 0;
-
-/* Module declarations from 'argos.cutility' */
-static PyArrayObject *__pyx_f_5argos_8cutility_points2rect(PyArrayObject *, PyArrayObject *, int __pyx_skip_dispatch); /*proto*/
-static PyArrayObject *__pyx_f_5argos_8cutility_rect2points(PyArrayObject *, int __pyx_skip_dispatch); /*proto*/
-static PyArrayObject *__pyx_f_5argos_8cutility_tlwh2xyrh(PyArrayObject *, int __pyx_skip_dispatch); /*proto*/
-static PyArrayObject *__pyx_f_5argos_8cutility_xyrh2tlwh(PyArrayObject *, int __pyx_skip_dispatch); /*proto*/
-static PyArrayObject *__pyx_f_5argos_8cutility_rect_intersection(PyArrayObject *, PyArrayObject *, int __pyx_skip_dispatch); /*proto*/
-static float __pyx_f_5argos_8cutility_rect_iou(PyArrayObject *, PyArrayObject *, int __pyx_skip_dispatch); /*proto*/
-static float __pyx_f_5argos_8cutility_rect_ios(PyArrayObject *, PyArrayObject *, int __pyx_skip_dispatch); /*proto*/
-static PyArrayObject *__pyx_f_5argos_8cutility_pairwise_distance(PyArrayObject *, PyArrayObject *, PyObject *, PyObject *, int __pyx_skip_dispatch); /*proto*/
-static __Pyx_TypeInfo __Pyx_TypeInfo_nn___pyx_t_5numpy_int_t = { "int_t", NULL, sizeof(__pyx_t_5numpy_int_t), { 0 }, 0, IS_UNSIGNED(__pyx_t_5numpy_int_t) ? 'U' : 'I', IS_UNSIGNED(__pyx_t_5numpy_int_t), 0 };
-static __Pyx_TypeInfo __Pyx_TypeInfo_nn___pyx_t_5numpy_float_t = { "float_t", NULL, sizeof(__pyx_t_5numpy_float_t), { 0 }, 0, 'R', 0, 0 };
-#define __Pyx_MODULE_NAME "argos.cutility"
-extern int __pyx_module_is_main_argos__cutility;
-int __pyx_module_is_main_argos__cutility = 0;
-
-/* Implementation of 'argos.cutility' */
-static PyObject *__pyx_builtin_min;
-static PyObject *__pyx_builtin_max;
-static PyObject *__pyx_builtin_round;
-static PyObject *__pyx_builtin_ValueError;
+/* Module declarations from "numpy" */
+
+/* Module declarations from "yolact.utils.cython_nms" */
+static CYTHON_INLINE __pyx_t_5numpy_float32_t __pyx_f_6yolact_5utils_10cython_nms_max(__pyx_t_5numpy_float32_t, __pyx_t_5numpy_float32_t); /*proto*/
+static CYTHON_INLINE __pyx_t_5numpy_float32_t __pyx_f_6yolact_5utils_10cython_nms_min(__pyx_t_5numpy_float32_t, __pyx_t_5numpy_float32_t); /*proto*/
+/* #### Code section: typeinfo ### */
+static __Pyx_TypeInfo __Pyx_TypeInfo_nn___pyx_t_5numpy_float32_t = { "float32_t", NULL, sizeof(__pyx_t_5numpy_float32_t), { 0 }, 0, 'R', 0, 0 };
+static __Pyx_TypeInfo __Pyx_TypeInfo_nn___pyx_t_5numpy_int64_t = { "int64_t", NULL, sizeof(__pyx_t_5numpy_int64_t), { 0 }, 0, __PYX_IS_UNSIGNED(__pyx_t_5numpy_int64_t) ? 'U' : 'I', __PYX_IS_UNSIGNED(__pyx_t_5numpy_int64_t), 0 };
+/* #### Code section: before_global_var ### */
+#define __Pyx_MODULE_NAME "yolact.utils.cython_nms"
+extern int __pyx_module_is_main_yolact__utils__cython_nms;
+int __pyx_module_is_main_yolact__utils__cython_nms = 0;
+
+/* Implementation of "yolact.utils.cython_nms" */
+/* #### Code section: global_var ### */
 static PyObject *__pyx_builtin_range;
-static PyObject *__pyx_builtin_NotImplementedError;
 static PyObject *__pyx_builtin_ImportError;
+/* #### Code section: string_decls ### */
+static const char __pyx_k_h[] = "h";
+static const char __pyx_k_i[] = "_i";
+static const char __pyx_k_j[] = "_j";
+static const char __pyx_k_w[] = "w";
 static const char __pyx_k_np[] = "np";
-static const char __pyx_k_p0[] = "p0";
-static const char __pyx_k_p1[] = "p1";
-static const char __pyx_k_ra[] = "ra";
-static const char __pyx_k_rb[] = "rb";
-static const char __pyx_k_int[] = "int";
-static const char __pyx_k_ios[] = "ios";
-static const char __pyx_k_iou[] = "iou";
-static const char __pyx_k_max[] = "max";
-static const char __pyx_k_min[] = "min";
-static const char __pyx_k_sum[] = "sum";
-static const char __pyx_k_bbox[] = "bbox";
-static const char __pyx_k_enum[] = "enum";
+static const char __pyx_k_x1[] = "x1";
+static const char __pyx_k_x2[] = "x2";
+static const char __pyx_k_y1[] = "y1";
+static const char __pyx_k_y2[] = "y2";
+static const char __pyx_k__10[] = "*";
+static const char __pyx_k__13[] = "?";
+static const char __pyx_k_i_2[] = "i";
+static const char __pyx_k_ix1[] = "ix1";
+static const char __pyx_k_ix2[] = "ix2";
+static const char __pyx_k_iy1[] = "iy1";
+static const char __pyx_k_iy2[] = "iy2";
+static const char __pyx_k_j_2[] = "j";
+static const char __pyx_k_nms[] = "nms";
+static const char __pyx_k_ovr[] = "ovr";
+static const char __pyx_k_xx1[] = "xx1";
+static const char __pyx_k_xx2[] = "xx2";
+static const char __pyx_k_yy1[] = "yy1";
+static const char __pyx_k_yy2[] = "yy2";
+static const char __pyx_k_dets[] = "dets";
 static const char __pyx_k_main[] = "__main__";
 static const char __pyx_k_name[] = "__name__";
+static const char __pyx_k_spec[] = "__spec__";
 static const char __pyx_k_test[] = "__test__";
-static const char __pyx_k_array[] = "array";
+static const char __pyx_k_areas[] = "areas";
 static const char __pyx_k_dtype[] = "dtype";
-static const char __pyx_k_float[] = "float";
-static const char __pyx_k_isinf[] = "isinf";
-static const char __pyx_k_isnan[] = "isnan";
+static const char __pyx_k_iarea[] = "iarea";
+static const char __pyx_k_int64[] = "int64";
+static const char __pyx_k_inter[] = "inter";
+static const char __pyx_k_ndets[] = "ndets";
 static const char __pyx_k_numpy[] = "numpy";
+static const char __pyx_k_order[] = "order";
 static const char __pyx_k_range[] = "range";
-static const char __pyx_k_round[] = "round";
+static const char __pyx_k_where[] = "where";
 static const char __pyx_k_zeros[] = "zeros";
-static const char __pyx_k_bboxes[] = "bboxes";
 static const char __pyx_k_import[] = "__import__";
-static const char __pyx_k_metric[] = "metric";
-static const char __pyx_k_vstack[] = "vstack";
-static const char __pyx_k_boxtype[] = "boxtype";
-static const char __pyx_k_euclidean[] = "euclidean";
-static const char __pyx_k_ValueError[] = "ValueError";
-static const char __pyx_k_asanyarray[] = "asanyarray";
-static const char __pyx_k_new_bboxes[] = "new_bboxes";
+static const char __pyx_k_scores[] = "scores";
+static const char __pyx_k_thresh[] = "thresh";
+static const char __pyx_k_argsort[] = "argsort";
+static const char __pyx_k_asarray[] = "asarray";
+static const char __pyx_k_suppressed[] = "suppressed";
 static const char __pyx_k_ImportError[] = "ImportError";
-static const char __pyx_k_OutlineStyle[] = "OutlineStyle";
-static const char __pyx_k_DistanceMetric[] = "DistanceMetric";
-static const char __pyx_k_Unknown_metric[] = "Unknown metric ";
-static const char __pyx_k_argos_constants[] = "argos.constants";
-static const char __pyx_k_Area_not_positive[] = "Area not positive";
+static const char __pyx_k_initializing[] = "_initializing";
+static const char __pyx_k_is_coroutine[] = "_is_coroutine";
+static const char __pyx_k_class_getitem[] = "__class_getitem__";
+static const char __pyx_k_suppressed_np[] = "suppressed_np";
+static const char __pyx_k_asyncio_coroutines[] = "asyncio.coroutines";
 static const char __pyx_k_cline_in_traceback[] = "cline_in_traceback";
-static const char __pyx_k_NotImplementedError[] = "NotImplementedError";
-static const char __pyx_k_Invalid_intersection[] = "Invalid intersection";
+static const char __pyx_k_yolact_utils_cython_nms[] = "yolact.utils.cython_nms";
+static const char __pyx_k_yolact_utils_cython_nms_pyx[] = "yolact\\utils\\cython_nms.pyx";
 static const char __pyx_k_numpy_core_multiarray_failed_to[] = "numpy.core.multiarray failed to import";
-static const char __pyx_k_Only_handling_axis_aligned_bound[] = "Only handling axis-aligned bounding boxes";
 static const char __pyx_k_numpy_core_umath_failed_to_impor[] = "numpy.core.umath failed to import";
-static PyObject *__pyx_kp_s_Area_not_positive;
-static PyObject *__pyx_n_s_DistanceMetric;
-static PyObject *__pyx_n_s_ImportError;
-static PyObject *__pyx_kp_s_Invalid_intersection;
-static PyObject *__pyx_n_s_NotImplementedError;
-static PyObject *__pyx_kp_s_Only_handling_axis_aligned_bound;
-static PyObject *__pyx_n_s_OutlineStyle;
-static PyObject *__pyx_kp_u_Unknown_metric;
-static PyObject *__pyx_n_s_ValueError;
-static PyObject *__pyx_n_s_argos_constants;
-static PyObject *__pyx_n_s_array;
-static PyObject *__pyx_n_s_asanyarray;
-static PyObject *__pyx_n_s_bbox;
-static PyObject *__pyx_n_s_bboxes;
-static PyObject *__pyx_n_s_boxtype;
-static PyObject *__pyx_n_s_cline_in_traceback;
-static PyObject *__pyx_n_s_dtype;
-static PyObject *__pyx_n_s_enum;
-static PyObject *__pyx_n_s_euclidean;
-static PyObject *__pyx_n_s_float;
-static PyObject *__pyx_n_s_import;
-static PyObject *__pyx_n_s_int;
-static PyObject *__pyx_n_s_ios;
-static PyObject *__pyx_n_s_iou;
-static PyObject *__pyx_n_s_isinf;
-static PyObject *__pyx_n_s_isnan;
-static PyObject *__pyx_n_s_main;
-static PyObject *__pyx_n_s_max;
-static PyObject *__pyx_n_s_metric;
-static PyObject *__pyx_n_s_min;
-static PyObject *__pyx_n_s_name;
-static PyObject *__pyx_n_s_new_bboxes;
-static PyObject *__pyx_n_s_np;
-static PyObject *__pyx_n_s_numpy;
-static PyObject *__pyx_kp_s_numpy_core_multiarray_failed_to;
-static PyObject *__pyx_kp_s_numpy_core_umath_failed_to_impor;
-static PyObject *__pyx_n_s_p0;
-static PyObject *__pyx_n_s_p1;
-static PyObject *__pyx_n_s_ra;
-static PyObject *__pyx_n_s_range;
-static PyObject *__pyx_n_s_rb;
-static PyObject *__pyx_n_s_round;
-static PyObject *__pyx_n_s_sum;
-static PyObject *__pyx_n_s_test;
-static PyObject *__pyx_n_s_vstack;
-static PyObject *__pyx_n_s_zeros;
-static PyObject *__pyx_pf_5argos_8cutility_points2rect(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_p0, PyArrayObject *__pyx_v_p1); /* proto */
-static PyObject *__pyx_pf_5argos_8cutility_2rect2points(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_rect); /* proto */
-static PyObject *__pyx_pf_5argos_8cutility_4tlwh2xyrh(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_rect); /* proto */
-static PyObject *__pyx_pf_5argos_8cutility_6xyrh2tlwh(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_rect); /* proto */
-static PyObject *__pyx_pf_5argos_8cutility_8rect_intersection(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_ra, PyArrayObject *__pyx_v_rb); /* proto */
-static PyObject *__pyx_pf_5argos_8cutility_10rect_iou(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_ra, PyArrayObject *__pyx_v_rb); /* proto */
-static PyObject *__pyx_pf_5argos_8cutility_12rect_ios(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_ra, PyArrayObject *__pyx_v_rb); /* proto */
-static PyObject *__pyx_pf_5argos_8cutility_14pairwise_distance(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_new_bboxes, PyArrayObject *__pyx_v_bboxes, PyObject *__pyx_v_boxtype, PyObject *__pyx_v_metric); /* proto */
-static PyObject *__pyx_float_0_5;
-static PyObject *__pyx_int_2;
-static PyObject *__pyx_int_4;
-static PyObject *__pyx_slice_;
-static PyObject *__pyx_slice__2;
-static PyObject *__pyx_slice__7;
-static PyObject *__pyx_tuple__3;
-static PyObject *__pyx_tuple__4;
-static PyObject *__pyx_tuple__5;
-static PyObject *__pyx_tuple__6;
-static PyObject *__pyx_tuple__8;
-static PyObject *__pyx_tuple__9;
-static PyObject *__pyx_tuple__10;
-static PyObject *__pyx_tuple__11;
-static PyObject *__pyx_tuple__12;
-static PyObject *__pyx_tuple__13;
-/* Late includes */
-
-/* "argos/cutility.pyx":13
- * @cython.boundscheck(False) # turn off bounds-checking for entire function
- * @cython.wraparound(False)  # turn off negative index wrapping for entire function
- * cpdef np.ndarray points2rect(p0: np.ndarray, p1: np.ndarray):             # <<<<<<<<<<<<<<
- *     """Convert diagonally opposite vertices into (x, y, w, h) format
- *     rectangle.
- */
-
-static PyObject *__pyx_pw_5argos_8cutility_1points2rect(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static PyArrayObject *__pyx_f_5argos_8cutility_points2rect(PyArrayObject *__pyx_v_p0, PyArrayObject *__pyx_v_p1, CYTHON_UNUSED int __pyx_skip_dispatch) {
-  PyObject *__pyx_v_x = NULL;
-  PyObject *__pyx_v_y = NULL;
-  PyObject *__pyx_v_xleft = NULL;
-  PyObject *__pyx_v_w = NULL;
-  PyObject *__pyx_v_ytop = NULL;
-  PyObject *__pyx_v_h = NULL;
-  PyArrayObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  PyObject *__pyx_t_2 = NULL;
-  PyObject *__pyx_t_3 = NULL;
-  PyObject *__pyx_t_4 = NULL;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("points2rect", 0);
-
-  /* "argos/cutility.pyx":25
- * 
- *     """
- *     x = p0[0], p1[0]             # <<<<<<<<<<<<<<
- *     y = p0[1], p1[1]
- *     xleft = min(x)
- */
-  __pyx_t_1 = __Pyx_GetItemInt(((PyObject *)__pyx_v_p0), 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 25, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_GetItemInt(((PyObject *)__pyx_v_p1), 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 25, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 25, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_GIVEREF(__pyx_t_1);
-  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_1);
-  __Pyx_GIVEREF(__pyx_t_2);
-  PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_2);
-  __pyx_t_1 = 0;
-  __pyx_t_2 = 0;
-  __pyx_v_x = ((PyObject*)__pyx_t_3);
-  __pyx_t_3 = 0;
-
-  /* "argos/cutility.pyx":26
- *     """
- *     x = p0[0], p1[0]
- *     y = p0[1], p1[1]             # <<<<<<<<<<<<<<
- *     xleft = min(x)
- *     w = max(x) - xleft
- */
-  __pyx_t_3 = __Pyx_GetItemInt(((PyObject *)__pyx_v_p0), 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 26, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_2 = __Pyx_GetItemInt(((PyObject *)__pyx_v_p1), 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 26, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 26, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_GIVEREF(__pyx_t_3);
-  PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_3);
-  __Pyx_GIVEREF(__pyx_t_2);
-  PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_t_2);
-  __pyx_t_3 = 0;
-  __pyx_t_2 = 0;
-  __pyx_v_y = ((PyObject*)__pyx_t_1);
-  __pyx_t_1 = 0;
-
-  /* "argos/cutility.pyx":27
- *     x = p0[0], p1[0]
- *     y = p0[1], p1[1]
- *     xleft = min(x)             # <<<<<<<<<<<<<<
- *     w = max(x) - xleft
- *     ytop = min(y)
- */
-  __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_min, __pyx_v_x); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 27, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_v_xleft = __pyx_t_1;
-  __pyx_t_1 = 0;
-
-  /* "argos/cutility.pyx":28
- *     y = p0[1], p1[1]
- *     xleft = min(x)
- *     w = max(x) - xleft             # <<<<<<<<<<<<<<
- *     ytop = min(y)
- *     h = max(y) - ytop
- */
-  __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_max, __pyx_v_x); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 28, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = PyNumber_Subtract(__pyx_t_1, __pyx_v_xleft); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 28, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_v_w = __pyx_t_2;
-  __pyx_t_2 = 0;
-
-  /* "argos/cutility.pyx":29
- *     xleft = min(x)
- *     w = max(x) - xleft
- *     ytop = min(y)             # <<<<<<<<<<<<<<
- *     h = max(y) - ytop
- *     return np.array((xleft, ytop, w, h))
- */
-  __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_builtin_min, __pyx_v_y); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 29, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_v_ytop = __pyx_t_2;
-  __pyx_t_2 = 0;
-
-  /* "argos/cutility.pyx":30
- *     w = max(x) - xleft
- *     ytop = min(y)
- *     h = max(y) - ytop             # <<<<<<<<<<<<<<
- *     return np.array((xleft, ytop, w, h))
- * 
- */
-  __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_builtin_max, __pyx_v_y); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 30, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_1 = PyNumber_Subtract(__pyx_t_2, __pyx_v_ytop); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 30, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_v_h = __pyx_t_1;
-  __pyx_t_1 = 0;
-
-  /* "argos/cutility.pyx":31
- *     ytop = min(y)
- *     h = max(y) - ytop
- *     return np.array((xleft, ytop, w, h))             # <<<<<<<<<<<<<<
- * 
- * @cython.boundscheck(False)
- */
-  __Pyx_XDECREF(((PyObject *)__pyx_r));
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 31, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_array); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 31, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = PyTuple_New(4); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 31, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_INCREF(__pyx_v_xleft);
-  __Pyx_GIVEREF(__pyx_v_xleft);
-  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_xleft);
-  __Pyx_INCREF(__pyx_v_ytop);
-  __Pyx_GIVEREF(__pyx_v_ytop);
-  PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_v_ytop);
-  __Pyx_INCREF(__pyx_v_w);
-  __Pyx_GIVEREF(__pyx_v_w);
-  PyTuple_SET_ITEM(__pyx_t_2, 2, __pyx_v_w);
-  __Pyx_INCREF(__pyx_v_h);
-  __Pyx_GIVEREF(__pyx_v_h);
-  PyTuple_SET_ITEM(__pyx_t_2, 3, __pyx_v_h);
-  __pyx_t_4 = NULL;
-  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
-    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
-    if (likely(__pyx_t_4)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
-      __Pyx_INCREF(__pyx_t_4);
-      __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_3, function);
-    }
-  }
-  __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_t_2) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_2);
-  __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 31, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (!(likely(((__pyx_t_1) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_1, __pyx_ptype_5numpy_ndarray))))) __PYX_ERR(0, 31, __pyx_L1_error)
-  __pyx_r = ((PyArrayObject *)__pyx_t_1);
-  __pyx_t_1 = 0;
-  goto __pyx_L0;
+/* #### Code section: decls ### */
+static PyObject *__pyx_pf_6yolact_5utils_10cython_nms_nms(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_dets, __pyx_t_5numpy_float32_t __pyx_v_thresh); /* proto */
+/* #### Code section: late_includes ### */
+/* #### Code section: module_state ### */
+typedef struct {
+  PyObject *__pyx_d;
+  PyObject *__pyx_b;
+  PyObject *__pyx_cython_runtime;
+  PyObject *__pyx_empty_tuple;
+  PyObject *__pyx_empty_bytes;
+  PyObject *__pyx_empty_unicode;
+  #ifdef __Pyx_CyFunction_USED
+  PyTypeObject *__pyx_CyFunctionType;
+  #endif
+  #ifdef __Pyx_FusedFunction_USED
+  PyTypeObject *__pyx_FusedFunctionType;
+  #endif
+  #ifdef __Pyx_Generator_USED
+  PyTypeObject *__pyx_GeneratorType;
+  #endif
+  #ifdef __Pyx_IterableCoroutine_USED
+  PyTypeObject *__pyx_IterableCoroutineType;
+  #endif
+  #ifdef __Pyx_Coroutine_USED
+  PyTypeObject *__pyx_CoroutineAwaitType;
+  #endif
+  #ifdef __Pyx_Coroutine_USED
+  PyTypeObject *__pyx_CoroutineType;
+  #endif
+  #if CYTHON_USE_MODULE_STATE
+  #endif
+  #if CYTHON_USE_MODULE_STATE
+  #endif
+  #if CYTHON_USE_MODULE_STATE
+  #endif
+  #if CYTHON_USE_MODULE_STATE
+  #endif
+  #if CYTHON_USE_MODULE_STATE
+  #endif
+  PyTypeObject *__pyx_ptype_7cpython_4type_type;
+  #if CYTHON_USE_MODULE_STATE
+  #endif
+  #if CYTHON_USE_MODULE_STATE
+  #endif
+  #if CYTHON_USE_MODULE_STATE
+  #endif
+  #if CYTHON_USE_MODULE_STATE
+  #endif
+  #if CYTHON_USE_MODULE_STATE
+  #endif
+  PyTypeObject *__pyx_ptype_5numpy_dtype;
+  PyTypeObject *__pyx_ptype_5numpy_flatiter;
+  PyTypeObject *__pyx_ptype_5numpy_broadcast;
+  PyTypeObject *__pyx_ptype_5numpy_ndarray;
+  PyTypeObject *__pyx_ptype_5numpy_generic;
+  PyTypeObject *__pyx_ptype_5numpy_number;
+  PyTypeObject *__pyx_ptype_5numpy_integer;
+  PyTypeObject *__pyx_ptype_5numpy_signedinteger;
+  PyTypeObject *__pyx_ptype_5numpy_unsignedinteger;
+  PyTypeObject *__pyx_ptype_5numpy_inexact;
+  PyTypeObject *__pyx_ptype_5numpy_floating;
+  PyTypeObject *__pyx_ptype_5numpy_complexfloating;
+  PyTypeObject *__pyx_ptype_5numpy_flexible;
+  PyTypeObject *__pyx_ptype_5numpy_character;
+  PyTypeObject *__pyx_ptype_5numpy_ufunc;
+  #if CYTHON_USE_MODULE_STATE
+  #endif
+  PyObject *__pyx_n_s_ImportError;
+  PyObject *__pyx_n_s__10;
+  PyObject *__pyx_n_s__13;
+  PyObject *__pyx_n_s_areas;
+  PyObject *__pyx_n_s_argsort;
+  PyObject *__pyx_n_s_asarray;
+  PyObject *__pyx_n_s_asyncio_coroutines;
+  PyObject *__pyx_n_s_class_getitem;
+  PyObject *__pyx_n_s_cline_in_traceback;
+  PyObject *__pyx_n_s_dets;
+  PyObject *__pyx_n_s_dtype;
+  PyObject *__pyx_n_s_h;
+  PyObject *__pyx_n_s_i;
+  PyObject *__pyx_n_s_i_2;
+  PyObject *__pyx_n_s_iarea;
+  PyObject *__pyx_n_s_import;
+  PyObject *__pyx_n_s_initializing;
+  PyObject *__pyx_n_s_int64;
+  PyObject *__pyx_n_s_inter;
+  PyObject *__pyx_n_s_is_coroutine;
+  PyObject *__pyx_n_s_ix1;
+  PyObject *__pyx_n_s_ix2;
+  PyObject *__pyx_n_s_iy1;
+  PyObject *__pyx_n_s_iy2;
+  PyObject *__pyx_n_s_j;
+  PyObject *__pyx_n_s_j_2;
+  PyObject *__pyx_n_s_main;
+  PyObject *__pyx_n_s_name;
+  PyObject *__pyx_n_s_ndets;
+  PyObject *__pyx_n_s_nms;
+  PyObject *__pyx_n_s_np;
+  PyObject *__pyx_n_s_numpy;
+  PyObject *__pyx_kp_s_numpy_core_multiarray_failed_to;
+  PyObject *__pyx_kp_s_numpy_core_umath_failed_to_impor;
+  PyObject *__pyx_n_s_order;
+  PyObject *__pyx_n_s_ovr;
+  PyObject *__pyx_n_s_range;
+  PyObject *__pyx_n_s_scores;
+  PyObject *__pyx_n_s_spec;
+  PyObject *__pyx_n_s_suppressed;
+  PyObject *__pyx_n_s_suppressed_np;
+  PyObject *__pyx_n_s_test;
+  PyObject *__pyx_n_s_thresh;
+  PyObject *__pyx_n_s_w;
+  PyObject *__pyx_n_s_where;
+  PyObject *__pyx_n_s_x1;
+  PyObject *__pyx_n_s_x2;
+  PyObject *__pyx_n_s_xx1;
+  PyObject *__pyx_n_s_xx2;
+  PyObject *__pyx_n_s_y1;
+  PyObject *__pyx_n_s_y2;
+  PyObject *__pyx_n_s_yolact_utils_cython_nms;
+  PyObject *__pyx_kp_s_yolact_utils_cython_nms_pyx;
+  PyObject *__pyx_n_s_yy1;
+  PyObject *__pyx_n_s_yy2;
+  PyObject *__pyx_n_s_zeros;
+  PyObject *__pyx_int_0;
+  PyObject *__pyx_int_1;
+  PyObject *__pyx_int_2;
+  PyObject *__pyx_int_3;
+  PyObject *__pyx_int_4;
+  PyObject *__pyx_int_neg_1;
+  PyObject *__pyx_tuple_;
+  PyObject *__pyx_slice__3;
+  PyObject *__pyx_slice__9;
+  PyObject *__pyx_tuple__2;
+  PyObject *__pyx_tuple__4;
+  PyObject *__pyx_tuple__5;
+  PyObject *__pyx_tuple__6;
+  PyObject *__pyx_tuple__7;
+  PyObject *__pyx_tuple__8;
+  PyObject *__pyx_tuple__11;
+  PyObject *__pyx_codeobj__12;
+} __pyx_mstate;
 
-  /* "argos/cutility.pyx":13
- * @cython.boundscheck(False) # turn off bounds-checking for entire function
- * @cython.wraparound(False)  # turn off negative index wrapping for entire function
- * cpdef np.ndarray points2rect(p0: np.ndarray, p1: np.ndarray):             # <<<<<<<<<<<<<<
- *     """Convert diagonally opposite vertices into (x, y, w, h) format
- *     rectangle.
- */
+#if CYTHON_USE_MODULE_STATE
+#ifdef __cplusplus
+namespace {
+  extern struct PyModuleDef __pyx_moduledef;
+} /* anonymous namespace */
+#else
+static struct PyModuleDef __pyx_moduledef;
+#endif
 
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_XDECREF(__pyx_t_2);
-  __Pyx_XDECREF(__pyx_t_3);
-  __Pyx_XDECREF(__pyx_t_4);
-  __Pyx_AddTraceback("argos.cutility.points2rect", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = 0;
-  __pyx_L0:;
-  __Pyx_XDECREF(__pyx_v_x);
-  __Pyx_XDECREF(__pyx_v_y);
-  __Pyx_XDECREF(__pyx_v_xleft);
-  __Pyx_XDECREF(__pyx_v_w);
-  __Pyx_XDECREF(__pyx_v_ytop);
-  __Pyx_XDECREF(__pyx_v_h);
-  __Pyx_XGIVEREF((PyObject *)__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
+#define __pyx_mstate(o) ((__pyx_mstate *)__Pyx_PyModule_GetState(o))
 
-/* Python wrapper */
-static PyObject *__pyx_pw_5argos_8cutility_1points2rect(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static char __pyx_doc_5argos_8cutility_points2rect[] = "Convert diagonally opposite vertices into (x, y, w, h) format\n    rectangle.\n\n    Returns\n    -------\n    np.array:\n        Rectangle with diagonal corners `p0` and `p1` after scaling\n        by `scale`. This will work with both top-left - bottom-right\n        and bottom-left - top-right diagonals.\n\n    ";
-static PyObject *__pyx_pw_5argos_8cutility_1points2rect(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
-  PyArrayObject *__pyx_v_p0 = 0;
-  PyArrayObject *__pyx_v_p1 = 0;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("points2rect (wrapper)", 0);
-  {
-    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_p0,&__pyx_n_s_p1,0};
-    PyObject* values[2] = {0,0};
-    if (unlikely(__pyx_kwds)) {
-      Py_ssize_t kw_args;
-      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
-      switch (pos_args) {
-        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
-        CYTHON_FALLTHROUGH;
-        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
-        CYTHON_FALLTHROUGH;
-        case  0: break;
-        default: goto __pyx_L5_argtuple_error;
-      }
-      kw_args = PyDict_Size(__pyx_kwds);
-      switch (pos_args) {
-        case  0:
-        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_p0)) != 0)) kw_args--;
-        else goto __pyx_L5_argtuple_error;
-        CYTHON_FALLTHROUGH;
-        case  1:
-        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_p1)) != 0)) kw_args--;
-        else {
-          __Pyx_RaiseArgtupleInvalid("points2rect", 1, 2, 2, 1); __PYX_ERR(0, 13, __pyx_L3_error)
-        }
-      }
-      if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "points2rect") < 0)) __PYX_ERR(0, 13, __pyx_L3_error)
-      }
-    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
-      goto __pyx_L5_argtuple_error;
-    } else {
-      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
-      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
-    }
-    __pyx_v_p0 = ((PyArrayObject *)values[0]);
-    __pyx_v_p1 = ((PyArrayObject *)values[1]);
-  }
-  goto __pyx_L4_argument_unpacking_done;
-  __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("points2rect", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 13, __pyx_L3_error)
-  __pyx_L3_error:;
-  __Pyx_AddTraceback("argos.cutility.points2rect", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __Pyx_RefNannyFinishContext();
-  return NULL;
-  __pyx_L4_argument_unpacking_done:;
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_p0), __pyx_ptype_5numpy_ndarray, 1, "p0", 0))) __PYX_ERR(0, 13, __pyx_L1_error)
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_p1), __pyx_ptype_5numpy_ndarray, 1, "p1", 0))) __PYX_ERR(0, 13, __pyx_L1_error)
-  __pyx_r = __pyx_pf_5argos_8cutility_points2rect(__pyx_self, __pyx_v_p0, __pyx_v_p1);
+#define __pyx_mstate_global (__pyx_mstate(PyState_FindModule(&__pyx_moduledef)))
 
-  /* function exit code */
-  goto __pyx_L0;
-  __pyx_L1_error:;
-  __pyx_r = NULL;
-  __pyx_L0:;
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
+#define __pyx_m (PyState_FindModule(&__pyx_moduledef))
+#else
+static __pyx_mstate __pyx_mstate_global_static =
+#ifdef __cplusplus
+    {};
+#else
+    {0};
+#endif
+static __pyx_mstate *__pyx_mstate_global = &__pyx_mstate_global_static;
+#endif
+/* #### Code section: module_state_clear ### */
+#if CYTHON_USE_MODULE_STATE
+static int __pyx_m_clear(PyObject *m) {
+  __pyx_mstate *clear_module_state = __pyx_mstate(m);
+  if (!clear_module_state) return 0;
+  Py_CLEAR(clear_module_state->__pyx_d);
+  Py_CLEAR(clear_module_state->__pyx_b);
+  Py_CLEAR(clear_module_state->__pyx_cython_runtime);
+  Py_CLEAR(clear_module_state->__pyx_empty_tuple);
+  Py_CLEAR(clear_module_state->__pyx_empty_bytes);
+  Py_CLEAR(clear_module_state->__pyx_empty_unicode);
+  #ifdef __Pyx_CyFunction_USED
+  Py_CLEAR(clear_module_state->__pyx_CyFunctionType);
+  #endif
+  #ifdef __Pyx_FusedFunction_USED
+  Py_CLEAR(clear_module_state->__pyx_FusedFunctionType);
+  #endif
+  Py_CLEAR(clear_module_state->__pyx_ptype_7cpython_4type_type);
+  Py_CLEAR(clear_module_state->__pyx_ptype_5numpy_dtype);
+  Py_CLEAR(clear_module_state->__pyx_ptype_5numpy_flatiter);
+  Py_CLEAR(clear_module_state->__pyx_ptype_5numpy_broadcast);
+  Py_CLEAR(clear_module_state->__pyx_ptype_5numpy_ndarray);
+  Py_CLEAR(clear_module_state->__pyx_ptype_5numpy_generic);
+  Py_CLEAR(clear_module_state->__pyx_ptype_5numpy_number);
+  Py_CLEAR(clear_module_state->__pyx_ptype_5numpy_integer);
+  Py_CLEAR(clear_module_state->__pyx_ptype_5numpy_signedinteger);
+  Py_CLEAR(clear_module_state->__pyx_ptype_5numpy_unsignedinteger);
+  Py_CLEAR(clear_module_state->__pyx_ptype_5numpy_inexact);
+  Py_CLEAR(clear_module_state->__pyx_ptype_5numpy_floating);
+  Py_CLEAR(clear_module_state->__pyx_ptype_5numpy_complexfloating);
+  Py_CLEAR(clear_module_state->__pyx_ptype_5numpy_flexible);
+  Py_CLEAR(clear_module_state->__pyx_ptype_5numpy_character);
+  Py_CLEAR(clear_module_state->__pyx_ptype_5numpy_ufunc);
+  Py_CLEAR(clear_module_state->__pyx_n_s_ImportError);
+  Py_CLEAR(clear_module_state->__pyx_n_s__10);
+  Py_CLEAR(clear_module_state->__pyx_n_s__13);
+  Py_CLEAR(clear_module_state->__pyx_n_s_areas);
+  Py_CLEAR(clear_module_state->__pyx_n_s_argsort);
+  Py_CLEAR(clear_module_state->__pyx_n_s_asarray);
+  Py_CLEAR(clear_module_state->__pyx_n_s_asyncio_coroutines);
+  Py_CLEAR(clear_module_state->__pyx_n_s_class_getitem);
+  Py_CLEAR(clear_module_state->__pyx_n_s_cline_in_traceback);
+  Py_CLEAR(clear_module_state->__pyx_n_s_dets);
+  Py_CLEAR(clear_module_state->__pyx_n_s_dtype);
+  Py_CLEAR(clear_module_state->__pyx_n_s_h);
+  Py_CLEAR(clear_module_state->__pyx_n_s_i);
+  Py_CLEAR(clear_module_state->__pyx_n_s_i_2);
+  Py_CLEAR(clear_module_state->__pyx_n_s_iarea);
+  Py_CLEAR(clear_module_state->__pyx_n_s_import);
+  Py_CLEAR(clear_module_state->__pyx_n_s_initializing);
+  Py_CLEAR(clear_module_state->__pyx_n_s_int64);
+  Py_CLEAR(clear_module_state->__pyx_n_s_inter);
+  Py_CLEAR(clear_module_state->__pyx_n_s_is_coroutine);
+  Py_CLEAR(clear_module_state->__pyx_n_s_ix1);
+  Py_CLEAR(clear_module_state->__pyx_n_s_ix2);
+  Py_CLEAR(clear_module_state->__pyx_n_s_iy1);
+  Py_CLEAR(clear_module_state->__pyx_n_s_iy2);
+  Py_CLEAR(clear_module_state->__pyx_n_s_j);
+  Py_CLEAR(clear_module_state->__pyx_n_s_j_2);
+  Py_CLEAR(clear_module_state->__pyx_n_s_main);
+  Py_CLEAR(clear_module_state->__pyx_n_s_name);
+  Py_CLEAR(clear_module_state->__pyx_n_s_ndets);
+  Py_CLEAR(clear_module_state->__pyx_n_s_nms);
+  Py_CLEAR(clear_module_state->__pyx_n_s_np);
+  Py_CLEAR(clear_module_state->__pyx_n_s_numpy);
+  Py_CLEAR(clear_module_state->__pyx_kp_s_numpy_core_multiarray_failed_to);
+  Py_CLEAR(clear_module_state->__pyx_kp_s_numpy_core_umath_failed_to_impor);
+  Py_CLEAR(clear_module_state->__pyx_n_s_order);
+  Py_CLEAR(clear_module_state->__pyx_n_s_ovr);
+  Py_CLEAR(clear_module_state->__pyx_n_s_range);
+  Py_CLEAR(clear_module_state->__pyx_n_s_scores);
+  Py_CLEAR(clear_module_state->__pyx_n_s_spec);
+  Py_CLEAR(clear_module_state->__pyx_n_s_suppressed);
+  Py_CLEAR(clear_module_state->__pyx_n_s_suppressed_np);
+  Py_CLEAR(clear_module_state->__pyx_n_s_test);
+  Py_CLEAR(clear_module_state->__pyx_n_s_thresh);
+  Py_CLEAR(clear_module_state->__pyx_n_s_w);
+  Py_CLEAR(clear_module_state->__pyx_n_s_where);
+  Py_CLEAR(clear_module_state->__pyx_n_s_x1);
+  Py_CLEAR(clear_module_state->__pyx_n_s_x2);
+  Py_CLEAR(clear_module_state->__pyx_n_s_xx1);
+  Py_CLEAR(clear_module_state->__pyx_n_s_xx2);
+  Py_CLEAR(clear_module_state->__pyx_n_s_y1);
+  Py_CLEAR(clear_module_state->__pyx_n_s_y2);
+  Py_CLEAR(clear_module_state->__pyx_n_s_yolact_utils_cython_nms);
+  Py_CLEAR(clear_module_state->__pyx_kp_s_yolact_utils_cython_nms_pyx);
+  Py_CLEAR(clear_module_state->__pyx_n_s_yy1);
+  Py_CLEAR(clear_module_state->__pyx_n_s_yy2);
+  Py_CLEAR(clear_module_state->__pyx_n_s_zeros);
+  Py_CLEAR(clear_module_state->__pyx_int_0);
+  Py_CLEAR(clear_module_state->__pyx_int_1);
+  Py_CLEAR(clear_module_state->__pyx_int_2);
+  Py_CLEAR(clear_module_state->__pyx_int_3);
+  Py_CLEAR(clear_module_state->__pyx_int_4);
+  Py_CLEAR(clear_module_state->__pyx_int_neg_1);
+  Py_CLEAR(clear_module_state->__pyx_tuple_);
+  Py_CLEAR(clear_module_state->__pyx_slice__3);
+  Py_CLEAR(clear_module_state->__pyx_slice__9);
+  Py_CLEAR(clear_module_state->__pyx_tuple__2);
+  Py_CLEAR(clear_module_state->__pyx_tuple__4);
+  Py_CLEAR(clear_module_state->__pyx_tuple__5);
+  Py_CLEAR(clear_module_state->__pyx_tuple__6);
+  Py_CLEAR(clear_module_state->__pyx_tuple__7);
+  Py_CLEAR(clear_module_state->__pyx_tuple__8);
+  Py_CLEAR(clear_module_state->__pyx_tuple__11);
+  Py_CLEAR(clear_module_state->__pyx_codeobj__12);
+  return 0;
 }
-
-static PyObject *__pyx_pf_5argos_8cutility_points2rect(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_p0, PyArrayObject *__pyx_v_p1) {
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("points2rect", 0);
-  __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = ((PyObject *)__pyx_f_5argos_8cutility_points2rect(__pyx_v_p0, __pyx_v_p1, 0)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 13, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_r = __pyx_t_1;
-  __pyx_t_1 = 0;
-  goto __pyx_L0;
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_AddTraceback("argos.cutility.points2rect", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
-  __pyx_L0:;
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
+#endif
+/* #### Code section: module_state_traverse ### */
+#if CYTHON_USE_MODULE_STATE
+static int __pyx_m_traverse(PyObject *m, visitproc visit, void *arg) {
+  __pyx_mstate *traverse_module_state = __pyx_mstate(m);
+  if (!traverse_module_state) return 0;
+  Py_VISIT(traverse_module_state->__pyx_d);
+  Py_VISIT(traverse_module_state->__pyx_b);
+  Py_VISIT(traverse_module_state->__pyx_cython_runtime);
+  Py_VISIT(traverse_module_state->__pyx_empty_tuple);
+  Py_VISIT(traverse_module_state->__pyx_empty_bytes);
+  Py_VISIT(traverse_module_state->__pyx_empty_unicode);
+  #ifdef __Pyx_CyFunction_USED
+  Py_VISIT(traverse_module_state->__pyx_CyFunctionType);
+  #endif
+  #ifdef __Pyx_FusedFunction_USED
+  Py_VISIT(traverse_module_state->__pyx_FusedFunctionType);
+  #endif
+  Py_VISIT(traverse_module_state->__pyx_ptype_7cpython_4type_type);
+  Py_VISIT(traverse_module_state->__pyx_ptype_5numpy_dtype);
+  Py_VISIT(traverse_module_state->__pyx_ptype_5numpy_flatiter);
+  Py_VISIT(traverse_module_state->__pyx_ptype_5numpy_broadcast);
+  Py_VISIT(traverse_module_state->__pyx_ptype_5numpy_ndarray);
+  Py_VISIT(traverse_module_state->__pyx_ptype_5numpy_generic);
+  Py_VISIT(traverse_module_state->__pyx_ptype_5numpy_number);
+  Py_VISIT(traverse_module_state->__pyx_ptype_5numpy_integer);
+  Py_VISIT(traverse_module_state->__pyx_ptype_5numpy_signedinteger);
+  Py_VISIT(traverse_module_state->__pyx_ptype_5numpy_unsignedinteger);
+  Py_VISIT(traverse_module_state->__pyx_ptype_5numpy_inexact);
+  Py_VISIT(traverse_module_state->__pyx_ptype_5numpy_floating);
+  Py_VISIT(traverse_module_state->__pyx_ptype_5numpy_complexfloating);
+  Py_VISIT(traverse_module_state->__pyx_ptype_5numpy_flexible);
+  Py_VISIT(traverse_module_state->__pyx_ptype_5numpy_character);
+  Py_VISIT(traverse_module_state->__pyx_ptype_5numpy_ufunc);
+  Py_VISIT(traverse_module_state->__pyx_n_s_ImportError);
+  Py_VISIT(traverse_module_state->__pyx_n_s__10);
+  Py_VISIT(traverse_module_state->__pyx_n_s__13);
+  Py_VISIT(traverse_module_state->__pyx_n_s_areas);
+  Py_VISIT(traverse_module_state->__pyx_n_s_argsort);
+  Py_VISIT(traverse_module_state->__pyx_n_s_asarray);
+  Py_VISIT(traverse_module_state->__pyx_n_s_asyncio_coroutines);
+  Py_VISIT(traverse_module_state->__pyx_n_s_class_getitem);
+  Py_VISIT(traverse_module_state->__pyx_n_s_cline_in_traceback);
+  Py_VISIT(traverse_module_state->__pyx_n_s_dets);
+  Py_VISIT(traverse_module_state->__pyx_n_s_dtype);
+  Py_VISIT(traverse_module_state->__pyx_n_s_h);
+  Py_VISIT(traverse_module_state->__pyx_n_s_i);
+  Py_VISIT(traverse_module_state->__pyx_n_s_i_2);
+  Py_VISIT(traverse_module_state->__pyx_n_s_iarea);
+  Py_VISIT(traverse_module_state->__pyx_n_s_import);
+  Py_VISIT(traverse_module_state->__pyx_n_s_initializing);
+  Py_VISIT(traverse_module_state->__pyx_n_s_int64);
+  Py_VISIT(traverse_module_state->__pyx_n_s_inter);
+  Py_VISIT(traverse_module_state->__pyx_n_s_is_coroutine);
+  Py_VISIT(traverse_module_state->__pyx_n_s_ix1);
+  Py_VISIT(traverse_module_state->__pyx_n_s_ix2);
+  Py_VISIT(traverse_module_state->__pyx_n_s_iy1);
+  Py_VISIT(traverse_module_state->__pyx_n_s_iy2);
+  Py_VISIT(traverse_module_state->__pyx_n_s_j);
+  Py_VISIT(traverse_module_state->__pyx_n_s_j_2);
+  Py_VISIT(traverse_module_state->__pyx_n_s_main);
+  Py_VISIT(traverse_module_state->__pyx_n_s_name);
+  Py_VISIT(traverse_module_state->__pyx_n_s_ndets);
+  Py_VISIT(traverse_module_state->__pyx_n_s_nms);
+  Py_VISIT(traverse_module_state->__pyx_n_s_np);
+  Py_VISIT(traverse_module_state->__pyx_n_s_numpy);
+  Py_VISIT(traverse_module_state->__pyx_kp_s_numpy_core_multiarray_failed_to);
+  Py_VISIT(traverse_module_state->__pyx_kp_s_numpy_core_umath_failed_to_impor);
+  Py_VISIT(traverse_module_state->__pyx_n_s_order);
+  Py_VISIT(traverse_module_state->__pyx_n_s_ovr);
+  Py_VISIT(traverse_module_state->__pyx_n_s_range);
+  Py_VISIT(traverse_module_state->__pyx_n_s_scores);
+  Py_VISIT(traverse_module_state->__pyx_n_s_spec);
+  Py_VISIT(traverse_module_state->__pyx_n_s_suppressed);
+  Py_VISIT(traverse_module_state->__pyx_n_s_suppressed_np);
+  Py_VISIT(traverse_module_state->__pyx_n_s_test);
+  Py_VISIT(traverse_module_state->__pyx_n_s_thresh);
+  Py_VISIT(traverse_module_state->__pyx_n_s_w);
+  Py_VISIT(traverse_module_state->__pyx_n_s_where);
+  Py_VISIT(traverse_module_state->__pyx_n_s_x1);
+  Py_VISIT(traverse_module_state->__pyx_n_s_x2);
+  Py_VISIT(traverse_module_state->__pyx_n_s_xx1);
+  Py_VISIT(traverse_module_state->__pyx_n_s_xx2);
+  Py_VISIT(traverse_module_state->__pyx_n_s_y1);
+  Py_VISIT(traverse_module_state->__pyx_n_s_y2);
+  Py_VISIT(traverse_module_state->__pyx_n_s_yolact_utils_cython_nms);
+  Py_VISIT(traverse_module_state->__pyx_kp_s_yolact_utils_cython_nms_pyx);
+  Py_VISIT(traverse_module_state->__pyx_n_s_yy1);
+  Py_VISIT(traverse_module_state->__pyx_n_s_yy2);
+  Py_VISIT(traverse_module_state->__pyx_n_s_zeros);
+  Py_VISIT(traverse_module_state->__pyx_int_0);
+  Py_VISIT(traverse_module_state->__pyx_int_1);
+  Py_VISIT(traverse_module_state->__pyx_int_2);
+  Py_VISIT(traverse_module_state->__pyx_int_3);
+  Py_VISIT(traverse_module_state->__pyx_int_4);
+  Py_VISIT(traverse_module_state->__pyx_int_neg_1);
+  Py_VISIT(traverse_module_state->__pyx_tuple_);
+  Py_VISIT(traverse_module_state->__pyx_slice__3);
+  Py_VISIT(traverse_module_state->__pyx_slice__9);
+  Py_VISIT(traverse_module_state->__pyx_tuple__2);
+  Py_VISIT(traverse_module_state->__pyx_tuple__4);
+  Py_VISIT(traverse_module_state->__pyx_tuple__5);
+  Py_VISIT(traverse_module_state->__pyx_tuple__6);
+  Py_VISIT(traverse_module_state->__pyx_tuple__7);
+  Py_VISIT(traverse_module_state->__pyx_tuple__8);
+  Py_VISIT(traverse_module_state->__pyx_tuple__11);
+  Py_VISIT(traverse_module_state->__pyx_codeobj__12);
+  return 0;
 }
-
-/* "argos/cutility.pyx":35
- * @cython.boundscheck(False)
- * @cython.wraparound(False)
- * cpdef np.ndarray[np.int_t, ndim=2] rect2points(             # <<<<<<<<<<<<<<
- *     np.ndarray[np.int_t, ndim=1] rect):
- *     """Convert topleft, width, height format rectangle into four anti-clockwise
- */
-
-static PyObject *__pyx_pw_5argos_8cutility_3rect2points(PyObject *__pyx_self, PyObject *__pyx_v_rect); /*proto*/
-static PyArrayObject *__pyx_f_5argos_8cutility_rect2points(PyArrayObject *__pyx_v_rect, CYTHON_UNUSED int __pyx_skip_dispatch) {
-  __Pyx_LocalBuf_ND __pyx_pybuffernd_rect;
-  __Pyx_Buffer __pyx_pybuffer_rect;
-  PyArrayObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  PyObject *__pyx_t_2 = NULL;
-  PyObject *__pyx_t_3 = NULL;
-  Py_ssize_t __pyx_t_4;
-  PyObject *__pyx_t_5 = NULL;
-  Py_ssize_t __pyx_t_6;
-  PyObject *__pyx_t_7 = NULL;
-  PyObject *__pyx_t_8 = NULL;
-  PyObject *__pyx_t_9 = NULL;
-  PyObject *__pyx_t_10 = NULL;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("rect2points", 0);
-  __pyx_pybuffer_rect.pybuffer.buf = NULL;
-  __pyx_pybuffer_rect.refcount = 0;
-  __pyx_pybuffernd_rect.data = NULL;
-  __pyx_pybuffernd_rect.rcbuffer = &__pyx_pybuffer_rect;
-  {
-    __Pyx_BufFmt_StackElem __pyx_stack[1];
-    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_rect.rcbuffer->pybuffer, (PyObject*)__pyx_v_rect, &__Pyx_TypeInfo_nn___pyx_t_5numpy_int_t, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) __PYX_ERR(0, 35, __pyx_L1_error)
-  }
-  __pyx_pybuffernd_rect.diminfo[0].strides = __pyx_pybuffernd_rect.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_rect.diminfo[0].shape = __pyx_pybuffernd_rect.rcbuffer->pybuffer.shape[0];
-
-  /* "argos/cutility.pyx":39
- *     """Convert topleft, width, height format rectangle into four anti-clockwise
- *     vertices"""
- *     return np.vstack([rect[:2],             # <<<<<<<<<<<<<<
- *                       (rect[0], rect[1] + rect[3]),
- *                       rect[:2] + rect[2:],
- */
-  __Pyx_XDECREF(((PyObject *)__pyx_r));
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 39, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_vstack); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 39, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyObject_GetItem(((PyObject *)__pyx_v_rect), __pyx_slice_); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 39, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-
-  /* "argos/cutility.pyx":40
- *     vertices"""
- *     return np.vstack([rect[:2],
- *                       (rect[0], rect[1] + rect[3]),             # <<<<<<<<<<<<<<
- *                       rect[:2] + rect[2:],
- *                       (rect[0] + rect[2], rect[1])])
- */
-  __pyx_t_4 = 0;
-  __pyx_t_5 = __Pyx_PyInt_From_npy_long((*__Pyx_BufPtrStrided1d(__pyx_t_5numpy_int_t *, __pyx_pybuffernd_rect.rcbuffer->pybuffer.buf, __pyx_t_4, __pyx_pybuffernd_rect.diminfo[0].strides))); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 40, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  __pyx_t_4 = 1;
-  __pyx_t_6 = 3;
-  __pyx_t_7 = __Pyx_PyInt_From_npy_long(((*__Pyx_BufPtrStrided1d(__pyx_t_5numpy_int_t *, __pyx_pybuffernd_rect.rcbuffer->pybuffer.buf, __pyx_t_4, __pyx_pybuffernd_rect.diminfo[0].strides)) + (*__Pyx_BufPtrStrided1d(__pyx_t_5numpy_int_t *, __pyx_pybuffernd_rect.rcbuffer->pybuffer.buf, __pyx_t_6, __pyx_pybuffernd_rect.diminfo[0].strides)))); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 40, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_8 = PyTuple_New(2); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 40, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_8);
-  __Pyx_GIVEREF(__pyx_t_5);
-  PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_5);
-  __Pyx_GIVEREF(__pyx_t_7);
-  PyTuple_SET_ITEM(__pyx_t_8, 1, __pyx_t_7);
-  __pyx_t_5 = 0;
-  __pyx_t_7 = 0;
-
-  /* "argos/cutility.pyx":41
- *     return np.vstack([rect[:2],
- *                       (rect[0], rect[1] + rect[3]),
- *                       rect[:2] + rect[2:],             # <<<<<<<<<<<<<<
- *                       (rect[0] + rect[2], rect[1])])
- * 
- */
-  __pyx_t_7 = __Pyx_PyObject_GetItem(((PyObject *)__pyx_v_rect), __pyx_slice_); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 41, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_5 = __Pyx_PyObject_GetItem(((PyObject *)__pyx_v_rect), __pyx_slice__2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 41, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  __pyx_t_9 = PyNumber_Add(__pyx_t_7, __pyx_t_5); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 41, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_9);
-  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-
-  /* "argos/cutility.pyx":42
- *                       (rect[0], rect[1] + rect[3]),
- *                       rect[:2] + rect[2:],
- *                       (rect[0] + rect[2], rect[1])])             # <<<<<<<<<<<<<<
- * 
+#endif
+/* #### Code section: module_state_defines ### */
+#define __pyx_d __pyx_mstate_global->__pyx_d
+#define __pyx_b __pyx_mstate_global->__pyx_b
+#define __pyx_cython_runtime __pyx_mstate_global->__pyx_cython_runtime
+#define __pyx_empty_tuple __pyx_mstate_global->__pyx_empty_tuple
+#define __pyx_empty_bytes __pyx_mstate_global->__pyx_empty_bytes
+#define __pyx_empty_unicode __pyx_mstate_global->__pyx_empty_unicode
+#ifdef __Pyx_CyFunction_USED
+#define __pyx_CyFunctionType __pyx_mstate_global->__pyx_CyFunctionType
+#endif
+#ifdef __Pyx_FusedFunction_USED
+#define __pyx_FusedFunctionType __pyx_mstate_global->__pyx_FusedFunctionType
+#endif
+#ifdef __Pyx_Generator_USED
+#define __pyx_GeneratorType __pyx_mstate_global->__pyx_GeneratorType
+#endif
+#ifdef __Pyx_IterableCoroutine_USED
+#define __pyx_IterableCoroutineType __pyx_mstate_global->__pyx_IterableCoroutineType
+#endif
+#ifdef __Pyx_Coroutine_USED
+#define __pyx_CoroutineAwaitType __pyx_mstate_global->__pyx_CoroutineAwaitType
+#endif
+#ifdef __Pyx_Coroutine_USED
+#define __pyx_CoroutineType __pyx_mstate_global->__pyx_CoroutineType
+#endif
+#if CYTHON_USE_MODULE_STATE
+#endif
+#if CYTHON_USE_MODULE_STATE
+#endif
+#if CYTHON_USE_MODULE_STATE
+#endif
+#if CYTHON_USE_MODULE_STATE
+#endif
+#if CYTHON_USE_MODULE_STATE
+#endif
+#define __pyx_ptype_7cpython_4type_type __pyx_mstate_global->__pyx_ptype_7cpython_4type_type
+#if CYTHON_USE_MODULE_STATE
+#endif
+#if CYTHON_USE_MODULE_STATE
+#endif
+#if CYTHON_USE_MODULE_STATE
+#endif
+#if CYTHON_USE_MODULE_STATE
+#endif
+#if CYTHON_USE_MODULE_STATE
+#endif
+#define __pyx_ptype_5numpy_dtype __pyx_mstate_global->__pyx_ptype_5numpy_dtype
+#define __pyx_ptype_5numpy_flatiter __pyx_mstate_global->__pyx_ptype_5numpy_flatiter
+#define __pyx_ptype_5numpy_broadcast __pyx_mstate_global->__pyx_ptype_5numpy_broadcast
+#define __pyx_ptype_5numpy_ndarray __pyx_mstate_global->__pyx_ptype_5numpy_ndarray
+#define __pyx_ptype_5numpy_generic __pyx_mstate_global->__pyx_ptype_5numpy_generic
+#define __pyx_ptype_5numpy_number __pyx_mstate_global->__pyx_ptype_5numpy_number
+#define __pyx_ptype_5numpy_integer __pyx_mstate_global->__pyx_ptype_5numpy_integer
+#define __pyx_ptype_5numpy_signedinteger __pyx_mstate_global->__pyx_ptype_5numpy_signedinteger
+#define __pyx_ptype_5numpy_unsignedinteger __pyx_mstate_global->__pyx_ptype_5numpy_unsignedinteger
+#define __pyx_ptype_5numpy_inexact __pyx_mstate_global->__pyx_ptype_5numpy_inexact
+#define __pyx_ptype_5numpy_floating __pyx_mstate_global->__pyx_ptype_5numpy_floating
+#define __pyx_ptype_5numpy_complexfloating __pyx_mstate_global->__pyx_ptype_5numpy_complexfloating
+#define __pyx_ptype_5numpy_flexible __pyx_mstate_global->__pyx_ptype_5numpy_flexible
+#define __pyx_ptype_5numpy_character __pyx_mstate_global->__pyx_ptype_5numpy_character
+#define __pyx_ptype_5numpy_ufunc __pyx_mstate_global->__pyx_ptype_5numpy_ufunc
+#if CYTHON_USE_MODULE_STATE
+#endif
+#define __pyx_n_s_ImportError __pyx_mstate_global->__pyx_n_s_ImportError
+#define __pyx_n_s__10 __pyx_mstate_global->__pyx_n_s__10
+#define __pyx_n_s__13 __pyx_mstate_global->__pyx_n_s__13
+#define __pyx_n_s_areas __pyx_mstate_global->__pyx_n_s_areas
+#define __pyx_n_s_argsort __pyx_mstate_global->__pyx_n_s_argsort
+#define __pyx_n_s_asarray __pyx_mstate_global->__pyx_n_s_asarray
+#define __pyx_n_s_asyncio_coroutines __pyx_mstate_global->__pyx_n_s_asyncio_coroutines
+#define __pyx_n_s_class_getitem __pyx_mstate_global->__pyx_n_s_class_getitem
+#define __pyx_n_s_cline_in_traceback __pyx_mstate_global->__pyx_n_s_cline_in_traceback
+#define __pyx_n_s_dets __pyx_mstate_global->__pyx_n_s_dets
+#define __pyx_n_s_dtype __pyx_mstate_global->__pyx_n_s_dtype
+#define __pyx_n_s_h __pyx_mstate_global->__pyx_n_s_h
+#define __pyx_n_s_i __pyx_mstate_global->__pyx_n_s_i
+#define __pyx_n_s_i_2 __pyx_mstate_global->__pyx_n_s_i_2
+#define __pyx_n_s_iarea __pyx_mstate_global->__pyx_n_s_iarea
+#define __pyx_n_s_import __pyx_mstate_global->__pyx_n_s_import
+#define __pyx_n_s_initializing __pyx_mstate_global->__pyx_n_s_initializing
+#define __pyx_n_s_int64 __pyx_mstate_global->__pyx_n_s_int64
+#define __pyx_n_s_inter __pyx_mstate_global->__pyx_n_s_inter
+#define __pyx_n_s_is_coroutine __pyx_mstate_global->__pyx_n_s_is_coroutine
+#define __pyx_n_s_ix1 __pyx_mstate_global->__pyx_n_s_ix1
+#define __pyx_n_s_ix2 __pyx_mstate_global->__pyx_n_s_ix2
+#define __pyx_n_s_iy1 __pyx_mstate_global->__pyx_n_s_iy1
+#define __pyx_n_s_iy2 __pyx_mstate_global->__pyx_n_s_iy2
+#define __pyx_n_s_j __pyx_mstate_global->__pyx_n_s_j
+#define __pyx_n_s_j_2 __pyx_mstate_global->__pyx_n_s_j_2
+#define __pyx_n_s_main __pyx_mstate_global->__pyx_n_s_main
+#define __pyx_n_s_name __pyx_mstate_global->__pyx_n_s_name
+#define __pyx_n_s_ndets __pyx_mstate_global->__pyx_n_s_ndets
+#define __pyx_n_s_nms __pyx_mstate_global->__pyx_n_s_nms
+#define __pyx_n_s_np __pyx_mstate_global->__pyx_n_s_np
+#define __pyx_n_s_numpy __pyx_mstate_global->__pyx_n_s_numpy
+#define __pyx_kp_s_numpy_core_multiarray_failed_to __pyx_mstate_global->__pyx_kp_s_numpy_core_multiarray_failed_to
+#define __pyx_kp_s_numpy_core_umath_failed_to_impor __pyx_mstate_global->__pyx_kp_s_numpy_core_umath_failed_to_impor
+#define __pyx_n_s_order __pyx_mstate_global->__pyx_n_s_order
+#define __pyx_n_s_ovr __pyx_mstate_global->__pyx_n_s_ovr
+#define __pyx_n_s_range __pyx_mstate_global->__pyx_n_s_range
+#define __pyx_n_s_scores __pyx_mstate_global->__pyx_n_s_scores
+#define __pyx_n_s_spec __pyx_mstate_global->__pyx_n_s_spec
+#define __pyx_n_s_suppressed __pyx_mstate_global->__pyx_n_s_suppressed
+#define __pyx_n_s_suppressed_np __pyx_mstate_global->__pyx_n_s_suppressed_np
+#define __pyx_n_s_test __pyx_mstate_global->__pyx_n_s_test
+#define __pyx_n_s_thresh __pyx_mstate_global->__pyx_n_s_thresh
+#define __pyx_n_s_w __pyx_mstate_global->__pyx_n_s_w
+#define __pyx_n_s_where __pyx_mstate_global->__pyx_n_s_where
+#define __pyx_n_s_x1 __pyx_mstate_global->__pyx_n_s_x1
+#define __pyx_n_s_x2 __pyx_mstate_global->__pyx_n_s_x2
+#define __pyx_n_s_xx1 __pyx_mstate_global->__pyx_n_s_xx1
+#define __pyx_n_s_xx2 __pyx_mstate_global->__pyx_n_s_xx2
+#define __pyx_n_s_y1 __pyx_mstate_global->__pyx_n_s_y1
+#define __pyx_n_s_y2 __pyx_mstate_global->__pyx_n_s_y2
+#define __pyx_n_s_yolact_utils_cython_nms __pyx_mstate_global->__pyx_n_s_yolact_utils_cython_nms
+#define __pyx_kp_s_yolact_utils_cython_nms_pyx __pyx_mstate_global->__pyx_kp_s_yolact_utils_cython_nms_pyx
+#define __pyx_n_s_yy1 __pyx_mstate_global->__pyx_n_s_yy1
+#define __pyx_n_s_yy2 __pyx_mstate_global->__pyx_n_s_yy2
+#define __pyx_n_s_zeros __pyx_mstate_global->__pyx_n_s_zeros
+#define __pyx_int_0 __pyx_mstate_global->__pyx_int_0
+#define __pyx_int_1 __pyx_mstate_global->__pyx_int_1
+#define __pyx_int_2 __pyx_mstate_global->__pyx_int_2
+#define __pyx_int_3 __pyx_mstate_global->__pyx_int_3
+#define __pyx_int_4 __pyx_mstate_global->__pyx_int_4
+#define __pyx_int_neg_1 __pyx_mstate_global->__pyx_int_neg_1
+#define __pyx_tuple_ __pyx_mstate_global->__pyx_tuple_
+#define __pyx_slice__3 __pyx_mstate_global->__pyx_slice__3
+#define __pyx_slice__9 __pyx_mstate_global->__pyx_slice__9
+#define __pyx_tuple__2 __pyx_mstate_global->__pyx_tuple__2
+#define __pyx_tuple__4 __pyx_mstate_global->__pyx_tuple__4
+#define __pyx_tuple__5 __pyx_mstate_global->__pyx_tuple__5
+#define __pyx_tuple__6 __pyx_mstate_global->__pyx_tuple__6
+#define __pyx_tuple__7 __pyx_mstate_global->__pyx_tuple__7
+#define __pyx_tuple__8 __pyx_mstate_global->__pyx_tuple__8
+#define __pyx_tuple__11 __pyx_mstate_global->__pyx_tuple__11
+#define __pyx_codeobj__12 __pyx_mstate_global->__pyx_codeobj__12
+/* #### Code section: module_code ### */
+
+/* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":245
+ * 
+ *         @property
+ *         cdef inline PyObject* base(self) nogil:             # <<<<<<<<<<<<<<
+ *             """Returns a borrowed reference to the object owning the data/memory.
+ *             """
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_5numpy_7ndarray_4base_base(PyArrayObject *__pyx_v_self) {
+  PyObject *__pyx_r;
+
+  /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":248
+ *             """Returns a borrowed reference to the object owning the data/memory.
+ *             """
+ *             return PyArray_BASE(self)             # <<<<<<<<<<<<<<
  * 
+ *         @property
  */
-  __pyx_t_6 = 0;
-  __pyx_t_4 = 2;
-  __pyx_t_5 = __Pyx_PyInt_From_npy_long(((*__Pyx_BufPtrStrided1d(__pyx_t_5numpy_int_t *, __pyx_pybuffernd_rect.rcbuffer->pybuffer.buf, __pyx_t_6, __pyx_pybuffernd_rect.diminfo[0].strides)) + (*__Pyx_BufPtrStrided1d(__pyx_t_5numpy_int_t *, __pyx_pybuffernd_rect.rcbuffer->pybuffer.buf, __pyx_t_4, __pyx_pybuffernd_rect.diminfo[0].strides)))); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 42, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  __pyx_t_4 = 1;
-  __pyx_t_7 = __Pyx_PyInt_From_npy_long((*__Pyx_BufPtrStrided1d(__pyx_t_5numpy_int_t *, __pyx_pybuffernd_rect.rcbuffer->pybuffer.buf, __pyx_t_4, __pyx_pybuffernd_rect.diminfo[0].strides))); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 42, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_10 = PyTuple_New(2); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 42, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_10);
-  __Pyx_GIVEREF(__pyx_t_5);
-  PyTuple_SET_ITEM(__pyx_t_10, 0, __pyx_t_5);
-  __Pyx_GIVEREF(__pyx_t_7);
-  PyTuple_SET_ITEM(__pyx_t_10, 1, __pyx_t_7);
-  __pyx_t_5 = 0;
-  __pyx_t_7 = 0;
-
-  /* "argos/cutility.pyx":39
- *     """Convert topleft, width, height format rectangle into four anti-clockwise
- *     vertices"""
- *     return np.vstack([rect[:2],             # <<<<<<<<<<<<<<
- *                       (rect[0], rect[1] + rect[3]),
- *                       rect[:2] + rect[2:],
- */
-  __pyx_t_7 = PyList_New(4); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 39, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_7);
-  __Pyx_GIVEREF(__pyx_t_2);
-  PyList_SET_ITEM(__pyx_t_7, 0, __pyx_t_2);
-  __Pyx_GIVEREF(__pyx_t_8);
-  PyList_SET_ITEM(__pyx_t_7, 1, __pyx_t_8);
-  __Pyx_GIVEREF(__pyx_t_9);
-  PyList_SET_ITEM(__pyx_t_7, 2, __pyx_t_9);
-  __Pyx_GIVEREF(__pyx_t_10);
-  PyList_SET_ITEM(__pyx_t_7, 3, __pyx_t_10);
-  __pyx_t_2 = 0;
-  __pyx_t_8 = 0;
-  __pyx_t_9 = 0;
-  __pyx_t_10 = 0;
-  __pyx_t_10 = NULL;
-  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
-    __pyx_t_10 = PyMethod_GET_SELF(__pyx_t_3);
-    if (likely(__pyx_t_10)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
-      __Pyx_INCREF(__pyx_t_10);
-      __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_3, function);
-    }
-  }
-  __pyx_t_1 = (__pyx_t_10) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_10, __pyx_t_7) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_7);
-  __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
-  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 39, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (!(likely(((__pyx_t_1) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_1, __pyx_ptype_5numpy_ndarray))))) __PYX_ERR(0, 39, __pyx_L1_error)
-  __pyx_r = ((PyArrayObject *)__pyx_t_1);
-  __pyx_t_1 = 0;
+  __pyx_r = PyArray_BASE(__pyx_v_self);
   goto __pyx_L0;
 
-  /* "argos/cutility.pyx":35
- * @cython.boundscheck(False)
- * @cython.wraparound(False)
- * cpdef np.ndarray[np.int_t, ndim=2] rect2points(             # <<<<<<<<<<<<<<
- *     np.ndarray[np.int_t, ndim=1] rect):
- *     """Convert topleft, width, height format rectangle into four anti-clockwise
+  /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":245
+ * 
+ *         @property
+ *         cdef inline PyObject* base(self) nogil:             # <<<<<<<<<<<<<<
+ *             """Returns a borrowed reference to the object owning the data/memory.
+ *             """
  */
 
   /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_XDECREF(__pyx_t_2);
-  __Pyx_XDECREF(__pyx_t_3);
-  __Pyx_XDECREF(__pyx_t_5);
-  __Pyx_XDECREF(__pyx_t_7);
-  __Pyx_XDECREF(__pyx_t_8);
-  __Pyx_XDECREF(__pyx_t_9);
-  __Pyx_XDECREF(__pyx_t_10);
-  { PyObject *__pyx_type, *__pyx_value, *__pyx_tb;
-    __Pyx_PyThreadState_declare
-    __Pyx_PyThreadState_assign
-    __Pyx_ErrFetch(&__pyx_type, &__pyx_value, &__pyx_tb);
-    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_rect.rcbuffer->pybuffer);
-  __Pyx_ErrRestore(__pyx_type, __pyx_value, __pyx_tb);}
-  __Pyx_AddTraceback("argos.cutility.rect2points", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = 0;
-  goto __pyx_L2;
-  __pyx_L0:;
-  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_rect.rcbuffer->pybuffer);
-  __pyx_L2:;
-  __Pyx_XGIVEREF((PyObject *)__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* Python wrapper */
-static PyObject *__pyx_pw_5argos_8cutility_3rect2points(PyObject *__pyx_self, PyObject *__pyx_v_rect); /*proto*/
-static char __pyx_doc_5argos_8cutility_2rect2points[] = "Convert topleft, width, height format rectangle into four anti-clockwise\n    vertices";
-static PyObject *__pyx_pw_5argos_8cutility_3rect2points(PyObject *__pyx_self, PyObject *__pyx_v_rect) {
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("rect2points (wrapper)", 0);
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_rect), __pyx_ptype_5numpy_ndarray, 1, "rect", 0))) __PYX_ERR(0, 36, __pyx_L1_error)
-  __pyx_r = __pyx_pf_5argos_8cutility_2rect2points(__pyx_self, ((PyArrayObject *)__pyx_v_rect));
-
-  /* function exit code */
-  goto __pyx_L0;
-  __pyx_L1_error:;
-  __pyx_r = NULL;
-  __pyx_L0:;
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static PyObject *__pyx_pf_5argos_8cutility_2rect2points(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_rect) {
-  __Pyx_LocalBuf_ND __pyx_pybuffernd_rect;
-  __Pyx_Buffer __pyx_pybuffer_rect;
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("rect2points", 0);
-  __pyx_pybuffer_rect.pybuffer.buf = NULL;
-  __pyx_pybuffer_rect.refcount = 0;
-  __pyx_pybuffernd_rect.data = NULL;
-  __pyx_pybuffernd_rect.rcbuffer = &__pyx_pybuffer_rect;
-  {
-    __Pyx_BufFmt_StackElem __pyx_stack[1];
-    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_rect.rcbuffer->pybuffer, (PyObject*)__pyx_v_rect, &__Pyx_TypeInfo_nn___pyx_t_5numpy_int_t, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) __PYX_ERR(0, 35, __pyx_L1_error)
-  }
-  __pyx_pybuffernd_rect.diminfo[0].strides = __pyx_pybuffernd_rect.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_rect.diminfo[0].shape = __pyx_pybuffernd_rect.rcbuffer->pybuffer.shape[0];
-  __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = ((PyObject *)__pyx_f_5argos_8cutility_rect2points(__pyx_v_rect, 0)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 35, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_r = __pyx_t_1;
-  __pyx_t_1 = 0;
-  goto __pyx_L0;
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  { PyObject *__pyx_type, *__pyx_value, *__pyx_tb;
-    __Pyx_PyThreadState_declare
-    __Pyx_PyThreadState_assign
-    __Pyx_ErrFetch(&__pyx_type, &__pyx_value, &__pyx_tb);
-    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_rect.rcbuffer->pybuffer);
-  __Pyx_ErrRestore(__pyx_type, __pyx_value, __pyx_tb);}
-  __Pyx_AddTraceback("argos.cutility.rect2points", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
-  goto __pyx_L2;
   __pyx_L0:;
-  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_rect.rcbuffer->pybuffer);
-  __pyx_L2:;
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "argos/cutility.pyx":47
- * @cython.boundscheck(False) # turn off bounds-checking for entire function
- * @cython.wraparound(False)  # turn off negative index wrapping for entire function
- * cpdef np.ndarray[np.float_t, ndim=1] tlwh2xyrh(np.ndarray[np.int_t, ndim=1] rect):             # <<<<<<<<<<<<<<
- *     """Convert rectangle in top-left, width, height format into center, aspect ratio, height"""
- *     cdef np.ndarray ret = np.asanyarray(rect, dtype=np.float)
+/* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":251
+ * 
+ *         @property
+ *         cdef inline dtype descr(self):             # <<<<<<<<<<<<<<
+ *             """Returns an owned reference to the dtype of the array.
+ *             """
  */
 
-static PyObject *__pyx_pw_5argos_8cutility_5tlwh2xyrh(PyObject *__pyx_self, PyObject *__pyx_v_rect); /*proto*/
-static PyArrayObject *__pyx_f_5argos_8cutility_tlwh2xyrh(PyArrayObject *__pyx_v_rect, CYTHON_UNUSED int __pyx_skip_dispatch) {
-  PyArrayObject *__pyx_v_ret = 0;
-  __Pyx_LocalBuf_ND __pyx_pybuffernd_rect;
-  __Pyx_Buffer __pyx_pybuffer_rect;
-  PyArrayObject *__pyx_r = NULL;
+static CYTHON_INLINE PyArray_Descr *__pyx_f_5numpy_7ndarray_5descr_descr(PyArrayObject *__pyx_v_self) {
+  PyArray_Descr *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  PyObject *__pyx_t_2 = NULL;
-  PyObject *__pyx_t_3 = NULL;
-  PyObject *__pyx_t_4 = NULL;
-  PyObject *__pyx_t_5 = NULL;
-  Py_ssize_t __pyx_t_6;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("tlwh2xyrh", 0);
-  __pyx_pybuffer_rect.pybuffer.buf = NULL;
-  __pyx_pybuffer_rect.refcount = 0;
-  __pyx_pybuffernd_rect.data = NULL;
-  __pyx_pybuffernd_rect.rcbuffer = &__pyx_pybuffer_rect;
-  {
-    __Pyx_BufFmt_StackElem __pyx_stack[1];
-    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_rect.rcbuffer->pybuffer, (PyObject*)__pyx_v_rect, &__Pyx_TypeInfo_nn___pyx_t_5numpy_int_t, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) __PYX_ERR(0, 47, __pyx_L1_error)
-  }
-  __pyx_pybuffernd_rect.diminfo[0].strides = __pyx_pybuffernd_rect.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_rect.diminfo[0].shape = __pyx_pybuffernd_rect.rcbuffer->pybuffer.shape[0];
+  PyArray_Descr *__pyx_t_1;
+  __Pyx_RefNannySetupContext("descr", 1);
 
-  /* "argos/cutility.pyx":49
- * cpdef np.ndarray[np.float_t, ndim=1] tlwh2xyrh(np.ndarray[np.int_t, ndim=1] rect):
- *     """Convert rectangle in top-left, width, height format into center, aspect ratio, height"""
- *     cdef np.ndarray ret = np.asanyarray(rect, dtype=np.float)             # <<<<<<<<<<<<<<
- *     ret[0] += ret[2] * 0.5
- *     ret[1] += ret[3] * 0.5
- */
-  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 49, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_asanyarray); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 49, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 49, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_INCREF(((PyObject *)__pyx_v_rect));
-  __Pyx_GIVEREF(((PyObject *)__pyx_v_rect));
-  PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)__pyx_v_rect));
-  __pyx_t_3 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 49, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_np); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 49, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_float); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 49, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_dtype, __pyx_t_5) < 0) __PYX_ERR(0, 49, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_1, __pyx_t_3); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 49, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (!(likely(((__pyx_t_5) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_5, __pyx_ptype_5numpy_ndarray))))) __PYX_ERR(0, 49, __pyx_L1_error)
-  __pyx_v_ret = ((PyArrayObject *)__pyx_t_5);
-  __pyx_t_5 = 0;
-
-  /* "argos/cutility.pyx":50
- *     """Convert rectangle in top-left, width, height format into center, aspect ratio, height"""
- *     cdef np.ndarray ret = np.asanyarray(rect, dtype=np.float)
- *     ret[0] += ret[2] * 0.5             # <<<<<<<<<<<<<<
- *     ret[1] += ret[3] * 0.5
- *     # ret[:2] += ret[2:] * 0.5
- */
-  __pyx_t_6 = 0;
-  __pyx_t_5 = __Pyx_GetItemInt(((PyObject *)__pyx_v_ret), __pyx_t_6, Py_ssize_t, 1, PyInt_FromSsize_t, 0, 0, 0); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 50, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  __pyx_t_3 = __Pyx_GetItemInt(((PyObject *)__pyx_v_ret), 2, long, 1, __Pyx_PyInt_From_long, 0, 0, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 50, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_1 = PyNumber_Multiply(__pyx_t_3, __pyx_float_0_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 50, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_3 = PyNumber_InPlaceAdd(__pyx_t_5, __pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 50, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  if (unlikely(__Pyx_SetItemInt(((PyObject *)__pyx_v_ret), __pyx_t_6, __pyx_t_3, Py_ssize_t, 1, PyInt_FromSsize_t, 0, 0, 0) < 0)) __PYX_ERR(0, 50, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-
-  /* "argos/cutility.pyx":51
- *     cdef np.ndarray ret = np.asanyarray(rect, dtype=np.float)
- *     ret[0] += ret[2] * 0.5
- *     ret[1] += ret[3] * 0.5             # <<<<<<<<<<<<<<
- *     # ret[:2] += ret[2:] * 0.5
- *     ret[2] /= ret[3]
- */
-  __pyx_t_6 = 1;
-  __pyx_t_3 = __Pyx_GetItemInt(((PyObject *)__pyx_v_ret), __pyx_t_6, Py_ssize_t, 1, PyInt_FromSsize_t, 0, 0, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 51, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_1 = __Pyx_GetItemInt(((PyObject *)__pyx_v_ret), 3, long, 1, __Pyx_PyInt_From_long, 0, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 51, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_5 = PyNumber_Multiply(__pyx_t_1, __pyx_float_0_5); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 51, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = PyNumber_InPlaceAdd(__pyx_t_3, __pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 51, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  if (unlikely(__Pyx_SetItemInt(((PyObject *)__pyx_v_ret), __pyx_t_6, __pyx_t_1, Py_ssize_t, 1, PyInt_FromSsize_t, 0, 0, 0) < 0)) __PYX_ERR(0, 51, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-
-  /* "argos/cutility.pyx":53
- *     ret[1] += ret[3] * 0.5
- *     # ret[:2] += ret[2:] * 0.5
- *     ret[2] /= ret[3]             # <<<<<<<<<<<<<<
- *     return ret
+  /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":254
+ *             """Returns an owned reference to the dtype of the array.
+ *             """
+ *             return <dtype>PyArray_DESCR(self)             # <<<<<<<<<<<<<<
  * 
+ *         @property
  */
-  __pyx_t_6 = 2;
-  __pyx_t_1 = __Pyx_GetItemInt(((PyObject *)__pyx_v_ret), __pyx_t_6, Py_ssize_t, 1, PyInt_FromSsize_t, 0, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 53, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_5 = __Pyx_GetItemInt(((PyObject *)__pyx_v_ret), 3, long, 1, __Pyx_PyInt_From_long, 0, 0, 0); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 53, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  __pyx_t_3 = __Pyx_PyNumber_InPlaceDivide(__pyx_t_1, __pyx_t_5); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 53, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  if (unlikely(__Pyx_SetItemInt(((PyObject *)__pyx_v_ret), __pyx_t_6, __pyx_t_3, Py_ssize_t, 1, PyInt_FromSsize_t, 0, 0, 0) < 0)) __PYX_ERR(0, 53, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-
-  /* "argos/cutility.pyx":54
- *     # ret[:2] += ret[2:] * 0.5
- *     ret[2] /= ret[3]
- *     return ret             # <<<<<<<<<<<<<<
- * 
- * 
- */
-  __Pyx_XDECREF(((PyObject *)__pyx_r));
-  __Pyx_INCREF(((PyObject *)__pyx_v_ret));
-  __pyx_r = ((PyArrayObject *)__pyx_v_ret);
+  __Pyx_XDECREF((PyObject *)__pyx_r);
+  __pyx_t_1 = PyArray_DESCR(__pyx_v_self);
+  __Pyx_INCREF((PyObject *)((PyArray_Descr *)__pyx_t_1));
+  __pyx_r = ((PyArray_Descr *)__pyx_t_1);
   goto __pyx_L0;
 
-  /* "argos/cutility.pyx":47
- * @cython.boundscheck(False) # turn off bounds-checking for entire function
- * @cython.wraparound(False)  # turn off negative index wrapping for entire function
- * cpdef np.ndarray[np.float_t, ndim=1] tlwh2xyrh(np.ndarray[np.int_t, ndim=1] rect):             # <<<<<<<<<<<<<<
- *     """Convert rectangle in top-left, width, height format into center, aspect ratio, height"""
- *     cdef np.ndarray ret = np.asanyarray(rect, dtype=np.float)
+  /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":251
+ * 
+ *         @property
+ *         cdef inline dtype descr(self):             # <<<<<<<<<<<<<<
+ *             """Returns an owned reference to the dtype of the array.
+ *             """
  */
 
   /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_XDECREF(__pyx_t_2);
-  __Pyx_XDECREF(__pyx_t_3);
-  __Pyx_XDECREF(__pyx_t_4);
-  __Pyx_XDECREF(__pyx_t_5);
-  { PyObject *__pyx_type, *__pyx_value, *__pyx_tb;
-    __Pyx_PyThreadState_declare
-    __Pyx_PyThreadState_assign
-    __Pyx_ErrFetch(&__pyx_type, &__pyx_value, &__pyx_tb);
-    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_rect.rcbuffer->pybuffer);
-  __Pyx_ErrRestore(__pyx_type, __pyx_value, __pyx_tb);}
-  __Pyx_AddTraceback("argos.cutility.tlwh2xyrh", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = 0;
-  goto __pyx_L2;
   __pyx_L0:;
-  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_rect.rcbuffer->pybuffer);
-  __pyx_L2:;
-  __Pyx_XDECREF((PyObject *)__pyx_v_ret);
   __Pyx_XGIVEREF((PyObject *)__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* Python wrapper */
-static PyObject *__pyx_pw_5argos_8cutility_5tlwh2xyrh(PyObject *__pyx_self, PyObject *__pyx_v_rect); /*proto*/
-static char __pyx_doc_5argos_8cutility_4tlwh2xyrh[] = "Convert rectangle in top-left, width, height format into center, aspect ratio, height";
-static PyObject *__pyx_pw_5argos_8cutility_5tlwh2xyrh(PyObject *__pyx_self, PyObject *__pyx_v_rect) {
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("tlwh2xyrh (wrapper)", 0);
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_rect), __pyx_ptype_5numpy_ndarray, 1, "rect", 0))) __PYX_ERR(0, 47, __pyx_L1_error)
-  __pyx_r = __pyx_pf_5argos_8cutility_4tlwh2xyrh(__pyx_self, ((PyArrayObject *)__pyx_v_rect));
-
-  /* function exit code */
-  goto __pyx_L0;
-  __pyx_L1_error:;
-  __pyx_r = NULL;
-  __pyx_L0:;
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static PyObject *__pyx_pf_5argos_8cutility_4tlwh2xyrh(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_rect) {
-  __Pyx_LocalBuf_ND __pyx_pybuffernd_rect;
-  __Pyx_Buffer __pyx_pybuffer_rect;
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("tlwh2xyrh", 0);
-  __pyx_pybuffer_rect.pybuffer.buf = NULL;
-  __pyx_pybuffer_rect.refcount = 0;
-  __pyx_pybuffernd_rect.data = NULL;
-  __pyx_pybuffernd_rect.rcbuffer = &__pyx_pybuffer_rect;
-  {
-    __Pyx_BufFmt_StackElem __pyx_stack[1];
-    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_rect.rcbuffer->pybuffer, (PyObject*)__pyx_v_rect, &__Pyx_TypeInfo_nn___pyx_t_5numpy_int_t, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) __PYX_ERR(0, 47, __pyx_L1_error)
-  }
-  __pyx_pybuffernd_rect.diminfo[0].strides = __pyx_pybuffernd_rect.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_rect.diminfo[0].shape = __pyx_pybuffernd_rect.rcbuffer->pybuffer.shape[0];
-  __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = ((PyObject *)__pyx_f_5argos_8cutility_tlwh2xyrh(__pyx_v_rect, 0)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 47, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_r = __pyx_t_1;
-  __pyx_t_1 = 0;
-  goto __pyx_L0;
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  { PyObject *__pyx_type, *__pyx_value, *__pyx_tb;
-    __Pyx_PyThreadState_declare
-    __Pyx_PyThreadState_assign
-    __Pyx_ErrFetch(&__pyx_type, &__pyx_value, &__pyx_tb);
-    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_rect.rcbuffer->pybuffer);
-  __Pyx_ErrRestore(__pyx_type, __pyx_value, __pyx_tb);}
-  __Pyx_AddTraceback("argos.cutility.tlwh2xyrh", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
-  goto __pyx_L2;
-  __pyx_L0:;
-  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_rect.rcbuffer->pybuffer);
-  __pyx_L2:;
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "argos/cutility.pyx":59
- * @cython.boundscheck(False) # turn off bounds-checking for entire function
- * @cython.wraparound(False)  # turn off negative index wrapping for entire function
- * cpdef np.ndarray[np.int_t, ndim=1] xyrh2tlwh(np.ndarray[np.float_t, ndim=1] rect):             # <<<<<<<<<<<<<<
- *     """Convert centre, aspect ratio, height into top-left, width, height
- *     format"""
+/* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":257
+ * 
+ *         @property
+ *         cdef inline int ndim(self) nogil:             # <<<<<<<<<<<<<<
+ *             """Returns the number of dimensions in the array.
+ *             """
  */
 
-static PyObject *__pyx_pw_5argos_8cutility_7xyrh2tlwh(PyObject *__pyx_self, PyObject *__pyx_v_rect); /*proto*/
-static PyArrayObject *__pyx_f_5argos_8cutility_xyrh2tlwh(PyArrayObject *__pyx_v_rect, CYTHON_UNUSED int __pyx_skip_dispatch) {
-  float __pyx_v_w;
-  PyArrayObject *__pyx_v_ret = 0;
-  __Pyx_LocalBuf_ND __pyx_pybuffernd_rect;
-  __Pyx_Buffer __pyx_pybuffer_rect;
-  PyArrayObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  Py_ssize_t __pyx_t_1;
-  Py_ssize_t __pyx_t_2;
-  PyObject *__pyx_t_3 = NULL;
-  PyObject *__pyx_t_4 = NULL;
-  PyObject *__pyx_t_5 = NULL;
-  PyObject *__pyx_t_6 = NULL;
-  PyObject *__pyx_t_7 = NULL;
-  PyObject *__pyx_t_8 = NULL;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("xyrh2tlwh", 0);
-  __pyx_pybuffer_rect.pybuffer.buf = NULL;
-  __pyx_pybuffer_rect.refcount = 0;
-  __pyx_pybuffernd_rect.data = NULL;
-  __pyx_pybuffernd_rect.rcbuffer = &__pyx_pybuffer_rect;
-  {
-    __Pyx_BufFmt_StackElem __pyx_stack[1];
-    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_rect.rcbuffer->pybuffer, (PyObject*)__pyx_v_rect, &__Pyx_TypeInfo_nn___pyx_t_5numpy_float_t, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) __PYX_ERR(0, 59, __pyx_L1_error)
-  }
-  __pyx_pybuffernd_rect.diminfo[0].strides = __pyx_pybuffernd_rect.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_rect.diminfo[0].shape = __pyx_pybuffernd_rect.rcbuffer->pybuffer.shape[0];
-
-  /* "argos/cutility.pyx":62
- *     """Convert centre, aspect ratio, height into top-left, width, height
- *     format"""
- *     cdef float w = rect[2] * rect[3]             # <<<<<<<<<<<<<<
- *     cdef np.ndarray ret = np.asanyarray((round(rect[0] - w / 2.0),
- *                                          round(rect[1] - rect[3] / 2.0),
- */
-  __pyx_t_1 = 2;
-  __pyx_t_2 = 3;
-  __pyx_v_w = ((*__Pyx_BufPtrStrided1d(__pyx_t_5numpy_float_t *, __pyx_pybuffernd_rect.rcbuffer->pybuffer.buf, __pyx_t_1, __pyx_pybuffernd_rect.diminfo[0].strides)) * (*__Pyx_BufPtrStrided1d(__pyx_t_5numpy_float_t *, __pyx_pybuffernd_rect.rcbuffer->pybuffer.buf, __pyx_t_2, __pyx_pybuffernd_rect.diminfo[0].strides)));
-
-  /* "argos/cutility.pyx":63
- *     format"""
- *     cdef float w = rect[2] * rect[3]
- *     cdef np.ndarray ret = np.asanyarray((round(rect[0] - w / 2.0),             # <<<<<<<<<<<<<<
- *                                          round(rect[1] - rect[3] / 2.0),
- *                                          round(w), round(rect[3])),
- */
-  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_np); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 63, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_asanyarray); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 63, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_2 = 0;
-  __pyx_t_3 = PyFloat_FromDouble(((*__Pyx_BufPtrStrided1d(__pyx_t_5numpy_float_t *, __pyx_pybuffernd_rect.rcbuffer->pybuffer.buf, __pyx_t_2, __pyx_pybuffernd_rect.diminfo[0].strides)) - (__pyx_v_w / 2.0))); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 63, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_5 = __Pyx_PyObject_CallOneArg(__pyx_builtin_round, __pyx_t_3); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 63, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-
-  /* "argos/cutility.pyx":64
- *     cdef float w = rect[2] * rect[3]
- *     cdef np.ndarray ret = np.asanyarray((round(rect[0] - w / 2.0),
- *                                          round(rect[1] - rect[3] / 2.0),             # <<<<<<<<<<<<<<
- *                                          round(w), round(rect[3])),
- *                                         dtype=int)
- */
-  __pyx_t_2 = 1;
-  __pyx_t_1 = 3;
-  __pyx_t_3 = PyFloat_FromDouble(((*__Pyx_BufPtrStrided1d(__pyx_t_5numpy_float_t *, __pyx_pybuffernd_rect.rcbuffer->pybuffer.buf, __pyx_t_2, __pyx_pybuffernd_rect.diminfo[0].strides)) - ((*__Pyx_BufPtrStrided1d(__pyx_t_5numpy_float_t *, __pyx_pybuffernd_rect.rcbuffer->pybuffer.buf, __pyx_t_1, __pyx_pybuffernd_rect.diminfo[0].strides)) / 2.0))); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 64, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_6 = __Pyx_PyObject_CallOneArg(__pyx_builtin_round, __pyx_t_3); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 64, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_6);
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-
-  /* "argos/cutility.pyx":65
- *     cdef np.ndarray ret = np.asanyarray((round(rect[0] - w / 2.0),
- *                                          round(rect[1] - rect[3] / 2.0),
- *                                          round(w), round(rect[3])),             # <<<<<<<<<<<<<<
- *                                         dtype=int)
- *     return ret
- */
-  __pyx_t_3 = PyFloat_FromDouble(__pyx_v_w); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 65, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_7 = __Pyx_PyObject_CallOneArg(__pyx_builtin_round, __pyx_t_3); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 65, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_7);
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_1 = 3;
-  __pyx_t_3 = PyFloat_FromDouble((*__Pyx_BufPtrStrided1d(__pyx_t_5numpy_float_t *, __pyx_pybuffernd_rect.rcbuffer->pybuffer.buf, __pyx_t_1, __pyx_pybuffernd_rect.diminfo[0].strides))); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 65, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_8 = __Pyx_PyObject_CallOneArg(__pyx_builtin_round, __pyx_t_3); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 65, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_8);
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-
-  /* "argos/cutility.pyx":63
- *     format"""
- *     cdef float w = rect[2] * rect[3]
- *     cdef np.ndarray ret = np.asanyarray((round(rect[0] - w / 2.0),             # <<<<<<<<<<<<<<
- *                                          round(rect[1] - rect[3] / 2.0),
- *                                          round(w), round(rect[3])),
- */
-  __pyx_t_3 = PyTuple_New(4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 63, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_GIVEREF(__pyx_t_5);
-  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_5);
-  __Pyx_GIVEREF(__pyx_t_6);
-  PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_6);
-  __Pyx_GIVEREF(__pyx_t_7);
-  PyTuple_SET_ITEM(__pyx_t_3, 2, __pyx_t_7);
-  __Pyx_GIVEREF(__pyx_t_8);
-  PyTuple_SET_ITEM(__pyx_t_3, 3, __pyx_t_8);
-  __pyx_t_5 = 0;
-  __pyx_t_6 = 0;
-  __pyx_t_7 = 0;
-  __pyx_t_8 = 0;
-  __pyx_t_8 = PyTuple_New(1); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 63, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_8);
-  __Pyx_GIVEREF(__pyx_t_3);
-  PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_3);
-  __pyx_t_3 = 0;
-
-  /* "argos/cutility.pyx":66
- *                                          round(rect[1] - rect[3] / 2.0),
- *                                          round(w), round(rect[3])),
- *                                         dtype=int)             # <<<<<<<<<<<<<<
- *     return ret
- * 
- */
-  __pyx_t_3 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 66, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_dtype, ((PyObject *)(&PyInt_Type))) < 0) __PYX_ERR(0, 66, __pyx_L1_error)
-
-  /* "argos/cutility.pyx":63
- *     format"""
- *     cdef float w = rect[2] * rect[3]
- *     cdef np.ndarray ret = np.asanyarray((round(rect[0] - w / 2.0),             # <<<<<<<<<<<<<<
- *                                          round(rect[1] - rect[3] / 2.0),
- *                                          round(w), round(rect[3])),
- */
-  __pyx_t_7 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_8, __pyx_t_3); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 63, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_7);
-  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (!(likely(((__pyx_t_7) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_7, __pyx_ptype_5numpy_ndarray))))) __PYX_ERR(0, 63, __pyx_L1_error)
-  __pyx_v_ret = ((PyArrayObject *)__pyx_t_7);
-  __pyx_t_7 = 0;
+static CYTHON_INLINE int __pyx_f_5numpy_7ndarray_4ndim_ndim(PyArrayObject *__pyx_v_self) {
+  int __pyx_r;
 
-  /* "argos/cutility.pyx":67
- *                                          round(w), round(rect[3])),
- *                                         dtype=int)
- *     return ret             # <<<<<<<<<<<<<<
- * 
+  /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":260
+ *             """Returns the number of dimensions in the array.
+ *             """
+ *             return PyArray_NDIM(self)             # <<<<<<<<<<<<<<
  * 
+ *         @property
  */
-  __Pyx_XDECREF(((PyObject *)__pyx_r));
-  __Pyx_INCREF(((PyObject *)__pyx_v_ret));
-  __pyx_r = ((PyArrayObject *)__pyx_v_ret);
+  __pyx_r = PyArray_NDIM(__pyx_v_self);
   goto __pyx_L0;
 
-  /* "argos/cutility.pyx":59
- * @cython.boundscheck(False) # turn off bounds-checking for entire function
- * @cython.wraparound(False)  # turn off negative index wrapping for entire function
- * cpdef np.ndarray[np.int_t, ndim=1] xyrh2tlwh(np.ndarray[np.float_t, ndim=1] rect):             # <<<<<<<<<<<<<<
- *     """Convert centre, aspect ratio, height into top-left, width, height
- *     format"""
+  /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":257
+ * 
+ *         @property
+ *         cdef inline int ndim(self) nogil:             # <<<<<<<<<<<<<<
+ *             """Returns the number of dimensions in the array.
+ *             """
  */
 
   /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_3);
-  __Pyx_XDECREF(__pyx_t_4);
-  __Pyx_XDECREF(__pyx_t_5);
-  __Pyx_XDECREF(__pyx_t_6);
-  __Pyx_XDECREF(__pyx_t_7);
-  __Pyx_XDECREF(__pyx_t_8);
-  { PyObject *__pyx_type, *__pyx_value, *__pyx_tb;
-    __Pyx_PyThreadState_declare
-    __Pyx_PyThreadState_assign
-    __Pyx_ErrFetch(&__pyx_type, &__pyx_value, &__pyx_tb);
-    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_rect.rcbuffer->pybuffer);
-  __Pyx_ErrRestore(__pyx_type, __pyx_value, __pyx_tb);}
-  __Pyx_AddTraceback("argos.cutility.xyrh2tlwh", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = 0;
-  goto __pyx_L2;
-  __pyx_L0:;
-  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_rect.rcbuffer->pybuffer);
-  __pyx_L2:;
-  __Pyx_XDECREF((PyObject *)__pyx_v_ret);
-  __Pyx_XGIVEREF((PyObject *)__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* Python wrapper */
-static PyObject *__pyx_pw_5argos_8cutility_7xyrh2tlwh(PyObject *__pyx_self, PyObject *__pyx_v_rect); /*proto*/
-static char __pyx_doc_5argos_8cutility_6xyrh2tlwh[] = "Convert centre, aspect ratio, height into top-left, width, height\n    format";
-static PyObject *__pyx_pw_5argos_8cutility_7xyrh2tlwh(PyObject *__pyx_self, PyObject *__pyx_v_rect) {
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("xyrh2tlwh (wrapper)", 0);
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_rect), __pyx_ptype_5numpy_ndarray, 1, "rect", 0))) __PYX_ERR(0, 59, __pyx_L1_error)
-  __pyx_r = __pyx_pf_5argos_8cutility_6xyrh2tlwh(__pyx_self, ((PyArrayObject *)__pyx_v_rect));
-
-  /* function exit code */
-  goto __pyx_L0;
-  __pyx_L1_error:;
-  __pyx_r = NULL;
   __pyx_L0:;
-  __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_5argos_8cutility_6xyrh2tlwh(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_rect) {
-  __Pyx_LocalBuf_ND __pyx_pybuffernd_rect;
-  __Pyx_Buffer __pyx_pybuffer_rect;
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("xyrh2tlwh", 0);
-  __pyx_pybuffer_rect.pybuffer.buf = NULL;
-  __pyx_pybuffer_rect.refcount = 0;
-  __pyx_pybuffernd_rect.data = NULL;
-  __pyx_pybuffernd_rect.rcbuffer = &__pyx_pybuffer_rect;
-  {
-    __Pyx_BufFmt_StackElem __pyx_stack[1];
-    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_rect.rcbuffer->pybuffer, (PyObject*)__pyx_v_rect, &__Pyx_TypeInfo_nn___pyx_t_5numpy_float_t, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) __PYX_ERR(0, 59, __pyx_L1_error)
-  }
-  __pyx_pybuffernd_rect.diminfo[0].strides = __pyx_pybuffernd_rect.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_rect.diminfo[0].shape = __pyx_pybuffernd_rect.rcbuffer->pybuffer.shape[0];
-  __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = ((PyObject *)__pyx_f_5argos_8cutility_xyrh2tlwh(__pyx_v_rect, 0)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 59, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_r = __pyx_t_1;
-  __pyx_t_1 = 0;
-  goto __pyx_L0;
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  { PyObject *__pyx_type, *__pyx_value, *__pyx_tb;
-    __Pyx_PyThreadState_declare
-    __Pyx_PyThreadState_assign
-    __Pyx_ErrFetch(&__pyx_type, &__pyx_value, &__pyx_tb);
-    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_rect.rcbuffer->pybuffer);
-  __Pyx_ErrRestore(__pyx_type, __pyx_value, __pyx_tb);}
-  __Pyx_AddTraceback("argos.cutility.xyrh2tlwh", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
-  goto __pyx_L2;
-  __pyx_L0:;
-  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_rect.rcbuffer->pybuffer);
-  __pyx_L2:;
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "argos/cutility.pyx":72
- * @cython.boundscheck(False) # turn off bounds-checking for entire function
- * @cython.wraparound(False)  # turn off negative index wrapping for entire function
- * cpdef np.ndarray[np.int_t, ndim=1] rect_intersection(np.ndarray[np.int_t, ndim=1] ra, np.ndarray[np.int_t, ndim=1] rb):             # <<<<<<<<<<<<<<
- *     """Find if two axis-aligned rectangles intersect.
+/* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":263
  * 
+ *         @property
+ *         cdef inline npy_intp *shape(self) nogil:             # <<<<<<<<<<<<<<
+ *             """Returns a pointer to the dimensions/shape of the array.
+ *             The number of elements matches the number of dimensions of the array (ndim).
  */
 
-static PyObject *__pyx_pw_5argos_8cutility_9rect_intersection(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static PyArrayObject *__pyx_f_5argos_8cutility_rect_intersection(PyArrayObject *__pyx_v_ra, PyArrayObject *__pyx_v_rb, CYTHON_UNUSED int __pyx_skip_dispatch) {
-  int __pyx_v_x;
-  int __pyx_v_y;
-  int __pyx_v_dx;
-  int __pyx_v_dy;
-  PyArrayObject *__pyx_v_result = 0;
-  __Pyx_LocalBuf_ND __pyx_pybuffernd_ra;
-  __Pyx_Buffer __pyx_pybuffer_ra;
-  __Pyx_LocalBuf_ND __pyx_pybuffernd_rb;
-  __Pyx_Buffer __pyx_pybuffer_rb;
-  PyArrayObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  PyObject *__pyx_t_2 = NULL;
-  PyObject *__pyx_t_3 = NULL;
-  PyObject *__pyx_t_4 = NULL;
-  Py_ssize_t __pyx_t_5;
-  __pyx_t_5numpy_int_t __pyx_t_6;
-  __pyx_t_5numpy_int_t __pyx_t_7;
-  __pyx_t_5numpy_int_t __pyx_t_8;
-  Py_ssize_t __pyx_t_9;
-  int __pyx_t_10;
-  int __pyx_t_11;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("rect_intersection", 0);
-  __pyx_pybuffer_ra.pybuffer.buf = NULL;
-  __pyx_pybuffer_ra.refcount = 0;
-  __pyx_pybuffernd_ra.data = NULL;
-  __pyx_pybuffernd_ra.rcbuffer = &__pyx_pybuffer_ra;
-  __pyx_pybuffer_rb.pybuffer.buf = NULL;
-  __pyx_pybuffer_rb.refcount = 0;
-  __pyx_pybuffernd_rb.data = NULL;
-  __pyx_pybuffernd_rb.rcbuffer = &__pyx_pybuffer_rb;
-  {
-    __Pyx_BufFmt_StackElem __pyx_stack[1];
-    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_ra.rcbuffer->pybuffer, (PyObject*)__pyx_v_ra, &__Pyx_TypeInfo_nn___pyx_t_5numpy_int_t, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) __PYX_ERR(0, 72, __pyx_L1_error)
-  }
-  __pyx_pybuffernd_ra.diminfo[0].strides = __pyx_pybuffernd_ra.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_ra.diminfo[0].shape = __pyx_pybuffernd_ra.rcbuffer->pybuffer.shape[0];
-  {
-    __Pyx_BufFmt_StackElem __pyx_stack[1];
-    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_rb.rcbuffer->pybuffer, (PyObject*)__pyx_v_rb, &__Pyx_TypeInfo_nn___pyx_t_5numpy_int_t, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) __PYX_ERR(0, 72, __pyx_L1_error)
-  }
-  __pyx_pybuffernd_rb.diminfo[0].strides = __pyx_pybuffernd_rb.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_rb.diminfo[0].shape = __pyx_pybuffernd_rb.rcbuffer->pybuffer.shape[0];
-
-  /* "argos/cutility.pyx":92
- *     """
- *     cdef int x, y, dx, dy
- *     cdef np.ndarray result = np.zeros((4,), dtype=np.int)             # <<<<<<<<<<<<<<
- *     x = int(max(ra[0], rb[0]))
- *     y = int(max(ra[1], rb[1]))
- */
-  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 92, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_zeros); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 92, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 92, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_np); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 92, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_int); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 92, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_dtype, __pyx_t_4) < 0) __PYX_ERR(0, 92, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_tuple__4, __pyx_t_1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 92, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  if (!(likely(((__pyx_t_4) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_4, __pyx_ptype_5numpy_ndarray))))) __PYX_ERR(0, 92, __pyx_L1_error)
-  __pyx_v_result = ((PyArrayObject *)__pyx_t_4);
-  __pyx_t_4 = 0;
-
-  /* "argos/cutility.pyx":93
- *     cdef int x, y, dx, dy
- *     cdef np.ndarray result = np.zeros((4,), dtype=np.int)
- *     x = int(max(ra[0], rb[0]))             # <<<<<<<<<<<<<<
- *     y = int(max(ra[1], rb[1]))
- *     dx = int(min(ra[0] + ra[2], rb[0] + rb[2]) - x)
- */
-  __pyx_t_5 = 0;
-  __pyx_t_6 = (*__Pyx_BufPtrStrided1d(__pyx_t_5numpy_int_t *, __pyx_pybuffernd_rb.rcbuffer->pybuffer.buf, __pyx_t_5, __pyx_pybuffernd_rb.diminfo[0].strides));
-  __pyx_t_5 = 0;
-  __pyx_t_7 = (*__Pyx_BufPtrStrided1d(__pyx_t_5numpy_int_t *, __pyx_pybuffernd_ra.rcbuffer->pybuffer.buf, __pyx_t_5, __pyx_pybuffernd_ra.diminfo[0].strides));
-  if (((__pyx_t_6 > __pyx_t_7) != 0)) {
-    __pyx_t_8 = __pyx_t_6;
-  } else {
-    __pyx_t_8 = __pyx_t_7;
-  }
-  __pyx_v_x = ((int)__pyx_t_8);
-
-  /* "argos/cutility.pyx":94
- *     cdef np.ndarray result = np.zeros((4,), dtype=np.int)
- *     x = int(max(ra[0], rb[0]))
- *     y = int(max(ra[1], rb[1]))             # <<<<<<<<<<<<<<
- *     dx = int(min(ra[0] + ra[2], rb[0] + rb[2]) - x)
- *     dy = int(min(ra[1] + ra[3], rb[1] + rb[3]) - y)
- */
-  __pyx_t_5 = 1;
-  __pyx_t_8 = (*__Pyx_BufPtrStrided1d(__pyx_t_5numpy_int_t *, __pyx_pybuffernd_rb.rcbuffer->pybuffer.buf, __pyx_t_5, __pyx_pybuffernd_rb.diminfo[0].strides));
-  __pyx_t_5 = 1;
-  __pyx_t_6 = (*__Pyx_BufPtrStrided1d(__pyx_t_5numpy_int_t *, __pyx_pybuffernd_ra.rcbuffer->pybuffer.buf, __pyx_t_5, __pyx_pybuffernd_ra.diminfo[0].strides));
-  if (((__pyx_t_8 > __pyx_t_6) != 0)) {
-    __pyx_t_7 = __pyx_t_8;
-  } else {
-    __pyx_t_7 = __pyx_t_6;
-  }
-  __pyx_v_y = ((int)__pyx_t_7);
+static CYTHON_INLINE npy_intp *__pyx_f_5numpy_7ndarray_5shape_shape(PyArrayObject *__pyx_v_self) {
+  npy_intp *__pyx_r;
 
-  /* "argos/cutility.pyx":95
- *     x = int(max(ra[0], rb[0]))
- *     y = int(max(ra[1], rb[1]))
- *     dx = int(min(ra[0] + ra[2], rb[0] + rb[2]) - x)             # <<<<<<<<<<<<<<
- *     dy = int(min(ra[1] + ra[3], rb[1] + rb[3]) - y)
- *     if (dx > 0) and (dy > 0):
- */
-  __pyx_t_5 = 0;
-  __pyx_t_9 = 2;
-  __pyx_t_7 = ((*__Pyx_BufPtrStrided1d(__pyx_t_5numpy_int_t *, __pyx_pybuffernd_rb.rcbuffer->pybuffer.buf, __pyx_t_5, __pyx_pybuffernd_rb.diminfo[0].strides)) + (*__Pyx_BufPtrStrided1d(__pyx_t_5numpy_int_t *, __pyx_pybuffernd_rb.rcbuffer->pybuffer.buf, __pyx_t_9, __pyx_pybuffernd_rb.diminfo[0].strides)));
-  __pyx_t_9 = 0;
-  __pyx_t_5 = 2;
-  __pyx_t_8 = ((*__Pyx_BufPtrStrided1d(__pyx_t_5numpy_int_t *, __pyx_pybuffernd_ra.rcbuffer->pybuffer.buf, __pyx_t_9, __pyx_pybuffernd_ra.diminfo[0].strides)) + (*__Pyx_BufPtrStrided1d(__pyx_t_5numpy_int_t *, __pyx_pybuffernd_ra.rcbuffer->pybuffer.buf, __pyx_t_5, __pyx_pybuffernd_ra.diminfo[0].strides)));
-  if (((__pyx_t_7 < __pyx_t_8) != 0)) {
-    __pyx_t_6 = __pyx_t_7;
-  } else {
-    __pyx_t_6 = __pyx_t_8;
-  }
-  __pyx_v_dx = ((int)(__pyx_t_6 - __pyx_v_x));
-
-  /* "argos/cutility.pyx":96
- *     y = int(max(ra[1], rb[1]))
- *     dx = int(min(ra[0] + ra[2], rb[0] + rb[2]) - x)
- *     dy = int(min(ra[1] + ra[3], rb[1] + rb[3]) - y)             # <<<<<<<<<<<<<<
- *     if (dx > 0) and (dy > 0):
- *         result[0] = x
- */
-  __pyx_t_5 = 1;
-  __pyx_t_9 = 3;
-  __pyx_t_6 = ((*__Pyx_BufPtrStrided1d(__pyx_t_5numpy_int_t *, __pyx_pybuffernd_rb.rcbuffer->pybuffer.buf, __pyx_t_5, __pyx_pybuffernd_rb.diminfo[0].strides)) + (*__Pyx_BufPtrStrided1d(__pyx_t_5numpy_int_t *, __pyx_pybuffernd_rb.rcbuffer->pybuffer.buf, __pyx_t_9, __pyx_pybuffernd_rb.diminfo[0].strides)));
-  __pyx_t_9 = 1;
-  __pyx_t_5 = 3;
-  __pyx_t_7 = ((*__Pyx_BufPtrStrided1d(__pyx_t_5numpy_int_t *, __pyx_pybuffernd_ra.rcbuffer->pybuffer.buf, __pyx_t_9, __pyx_pybuffernd_ra.diminfo[0].strides)) + (*__Pyx_BufPtrStrided1d(__pyx_t_5numpy_int_t *, __pyx_pybuffernd_ra.rcbuffer->pybuffer.buf, __pyx_t_5, __pyx_pybuffernd_ra.diminfo[0].strides)));
-  if (((__pyx_t_6 < __pyx_t_7) != 0)) {
-    __pyx_t_8 = __pyx_t_6;
-  } else {
-    __pyx_t_8 = __pyx_t_7;
-  }
-  __pyx_v_dy = ((int)(__pyx_t_8 - __pyx_v_y));
-
-  /* "argos/cutility.pyx":97
- *     dx = int(min(ra[0] + ra[2], rb[0] + rb[2]) - x)
- *     dy = int(min(ra[1] + ra[3], rb[1] + rb[3]) - y)
- *     if (dx > 0) and (dy > 0):             # <<<<<<<<<<<<<<
- *         result[0] = x
- *         result[1] = y
+  /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":268
+ *             Can return NULL for 0-dimensional arrays.
+ *             """
+ *             return PyArray_DIMS(self)             # <<<<<<<<<<<<<<
+ * 
+ *         @property
  */
-  __pyx_t_11 = ((__pyx_v_dx > 0) != 0);
-  if (__pyx_t_11) {
-  } else {
-    __pyx_t_10 = __pyx_t_11;
-    goto __pyx_L4_bool_binop_done;
-  }
-  __pyx_t_11 = ((__pyx_v_dy > 0) != 0);
-  __pyx_t_10 = __pyx_t_11;
-  __pyx_L4_bool_binop_done:;
-  if (__pyx_t_10) {
-
-    /* "argos/cutility.pyx":98
- *     dy = int(min(ra[1] + ra[3], rb[1] + rb[3]) - y)
- *     if (dx > 0) and (dy > 0):
- *         result[0] = x             # <<<<<<<<<<<<<<
- *         result[1] = y
- *         result[2] = dx
- */
-    __pyx_t_4 = __Pyx_PyInt_From_int(__pyx_v_x); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 98, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_4);
-    if (unlikely(__Pyx_SetItemInt(((PyObject *)__pyx_v_result), 0, __pyx_t_4, long, 1, __Pyx_PyInt_From_long, 0, 0, 0) < 0)) __PYX_ERR(0, 98, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-
-    /* "argos/cutility.pyx":99
- *     if (dx > 0) and (dy > 0):
- *         result[0] = x
- *         result[1] = y             # <<<<<<<<<<<<<<
- *         result[2] = dx
- *         result[3] = dy
- */
-    __pyx_t_4 = __Pyx_PyInt_From_int(__pyx_v_y); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 99, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_4);
-    if (unlikely(__Pyx_SetItemInt(((PyObject *)__pyx_v_result), 1, __pyx_t_4, long, 1, __Pyx_PyInt_From_long, 0, 0, 0) < 0)) __PYX_ERR(0, 99, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-
-    /* "argos/cutility.pyx":100
- *         result[0] = x
- *         result[1] = y
- *         result[2] = dx             # <<<<<<<<<<<<<<
- *         result[3] = dy
- *     return result
- */
-    __pyx_t_4 = __Pyx_PyInt_From_int(__pyx_v_dx); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 100, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_4);
-    if (unlikely(__Pyx_SetItemInt(((PyObject *)__pyx_v_result), 2, __pyx_t_4, long, 1, __Pyx_PyInt_From_long, 0, 0, 0) < 0)) __PYX_ERR(0, 100, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-
-    /* "argos/cutility.pyx":101
- *         result[1] = y
- *         result[2] = dx
- *         result[3] = dy             # <<<<<<<<<<<<<<
- *     return result
- * 
- */
-    __pyx_t_4 = __Pyx_PyInt_From_int(__pyx_v_dy); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 101, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_4);
-    if (unlikely(__Pyx_SetItemInt(((PyObject *)__pyx_v_result), 3, __pyx_t_4, long, 1, __Pyx_PyInt_From_long, 0, 0, 0) < 0)) __PYX_ERR(0, 101, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-
-    /* "argos/cutility.pyx":97
- *     dx = int(min(ra[0] + ra[2], rb[0] + rb[2]) - x)
- *     dy = int(min(ra[1] + ra[3], rb[1] + rb[3]) - y)
- *     if (dx > 0) and (dy > 0):             # <<<<<<<<<<<<<<
- *         result[0] = x
- *         result[1] = y
- */
-  }
-
-  /* "argos/cutility.pyx":102
- *         result[2] = dx
- *         result[3] = dy
- *     return result             # <<<<<<<<<<<<<<
- * 
- * 
- */
-  __Pyx_XDECREF(((PyObject *)__pyx_r));
-  __Pyx_INCREF(((PyObject *)__pyx_v_result));
-  __pyx_r = ((PyArrayObject *)__pyx_v_result);
+  __pyx_r = PyArray_DIMS(__pyx_v_self);
   goto __pyx_L0;
 
-  /* "argos/cutility.pyx":72
- * @cython.boundscheck(False) # turn off bounds-checking for entire function
- * @cython.wraparound(False)  # turn off negative index wrapping for entire function
- * cpdef np.ndarray[np.int_t, ndim=1] rect_intersection(np.ndarray[np.int_t, ndim=1] ra, np.ndarray[np.int_t, ndim=1] rb):             # <<<<<<<<<<<<<<
- *     """Find if two axis-aligned rectangles intersect.
+  /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":263
  * 
+ *         @property
+ *         cdef inline npy_intp *shape(self) nogil:             # <<<<<<<<<<<<<<
+ *             """Returns a pointer to the dimensions/shape of the array.
+ *             The number of elements matches the number of dimensions of the array (ndim).
  */
 
   /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_XDECREF(__pyx_t_2);
-  __Pyx_XDECREF(__pyx_t_3);
-  __Pyx_XDECREF(__pyx_t_4);
-  { PyObject *__pyx_type, *__pyx_value, *__pyx_tb;
-    __Pyx_PyThreadState_declare
-    __Pyx_PyThreadState_assign
-    __Pyx_ErrFetch(&__pyx_type, &__pyx_value, &__pyx_tb);
-    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_ra.rcbuffer->pybuffer);
-    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_rb.rcbuffer->pybuffer);
-  __Pyx_ErrRestore(__pyx_type, __pyx_value, __pyx_tb);}
-  __Pyx_AddTraceback("argos.cutility.rect_intersection", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = 0;
-  goto __pyx_L2;
-  __pyx_L0:;
-  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_ra.rcbuffer->pybuffer);
-  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_rb.rcbuffer->pybuffer);
-  __pyx_L2:;
-  __Pyx_XDECREF((PyObject *)__pyx_v_result);
-  __Pyx_XGIVEREF((PyObject *)__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* Python wrapper */
-static PyObject *__pyx_pw_5argos_8cutility_9rect_intersection(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static char __pyx_doc_5argos_8cutility_8rect_intersection[] = "Find if two axis-aligned rectangles intersect.\n\n    This runs almost 50 times faster than Polygon intersection in shapely.\n    and ~5 times faster than cv2.intersectConvexConvex.\n\n    Parameters\n    ----------\n    ra: np.ndarray\n    rb: np.ndarray\n        Rectangles specified as (x, y, w, h) where (x, y) is the coordinate\n        of the lower left corner, w and h are width and height.\n\n    Returns\n    -------\n    np.ndarray\n        (x, y, dx, dy) specifying the overlap rectangle. If there is no\n        overlap, all entries are 0.\n    ";
-static PyObject *__pyx_pw_5argos_8cutility_9rect_intersection(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
-  PyArrayObject *__pyx_v_ra = 0;
-  PyArrayObject *__pyx_v_rb = 0;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("rect_intersection (wrapper)", 0);
-  {
-    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_ra,&__pyx_n_s_rb,0};
-    PyObject* values[2] = {0,0};
-    if (unlikely(__pyx_kwds)) {
-      Py_ssize_t kw_args;
-      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
-      switch (pos_args) {
-        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
-        CYTHON_FALLTHROUGH;
-        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
-        CYTHON_FALLTHROUGH;
-        case  0: break;
-        default: goto __pyx_L5_argtuple_error;
-      }
-      kw_args = PyDict_Size(__pyx_kwds);
-      switch (pos_args) {
-        case  0:
-        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_ra)) != 0)) kw_args--;
-        else goto __pyx_L5_argtuple_error;
-        CYTHON_FALLTHROUGH;
-        case  1:
-        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_rb)) != 0)) kw_args--;
-        else {
-          __Pyx_RaiseArgtupleInvalid("rect_intersection", 1, 2, 2, 1); __PYX_ERR(0, 72, __pyx_L3_error)
-        }
-      }
-      if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "rect_intersection") < 0)) __PYX_ERR(0, 72, __pyx_L3_error)
-      }
-    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
-      goto __pyx_L5_argtuple_error;
-    } else {
-      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
-      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
-    }
-    __pyx_v_ra = ((PyArrayObject *)values[0]);
-    __pyx_v_rb = ((PyArrayObject *)values[1]);
-  }
-  goto __pyx_L4_argument_unpacking_done;
-  __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("rect_intersection", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 72, __pyx_L3_error)
-  __pyx_L3_error:;
-  __Pyx_AddTraceback("argos.cutility.rect_intersection", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __Pyx_RefNannyFinishContext();
-  return NULL;
-  __pyx_L4_argument_unpacking_done:;
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_ra), __pyx_ptype_5numpy_ndarray, 1, "ra", 0))) __PYX_ERR(0, 72, __pyx_L1_error)
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_rb), __pyx_ptype_5numpy_ndarray, 1, "rb", 0))) __PYX_ERR(0, 72, __pyx_L1_error)
-  __pyx_r = __pyx_pf_5argos_8cutility_8rect_intersection(__pyx_self, __pyx_v_ra, __pyx_v_rb);
-
-  /* function exit code */
-  goto __pyx_L0;
-  __pyx_L1_error:;
-  __pyx_r = NULL;
-  __pyx_L0:;
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static PyObject *__pyx_pf_5argos_8cutility_8rect_intersection(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_ra, PyArrayObject *__pyx_v_rb) {
-  __Pyx_LocalBuf_ND __pyx_pybuffernd_ra;
-  __Pyx_Buffer __pyx_pybuffer_ra;
-  __Pyx_LocalBuf_ND __pyx_pybuffernd_rb;
-  __Pyx_Buffer __pyx_pybuffer_rb;
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("rect_intersection", 0);
-  __pyx_pybuffer_ra.pybuffer.buf = NULL;
-  __pyx_pybuffer_ra.refcount = 0;
-  __pyx_pybuffernd_ra.data = NULL;
-  __pyx_pybuffernd_ra.rcbuffer = &__pyx_pybuffer_ra;
-  __pyx_pybuffer_rb.pybuffer.buf = NULL;
-  __pyx_pybuffer_rb.refcount = 0;
-  __pyx_pybuffernd_rb.data = NULL;
-  __pyx_pybuffernd_rb.rcbuffer = &__pyx_pybuffer_rb;
-  {
-    __Pyx_BufFmt_StackElem __pyx_stack[1];
-    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_ra.rcbuffer->pybuffer, (PyObject*)__pyx_v_ra, &__Pyx_TypeInfo_nn___pyx_t_5numpy_int_t, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) __PYX_ERR(0, 72, __pyx_L1_error)
-  }
-  __pyx_pybuffernd_ra.diminfo[0].strides = __pyx_pybuffernd_ra.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_ra.diminfo[0].shape = __pyx_pybuffernd_ra.rcbuffer->pybuffer.shape[0];
-  {
-    __Pyx_BufFmt_StackElem __pyx_stack[1];
-    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_rb.rcbuffer->pybuffer, (PyObject*)__pyx_v_rb, &__Pyx_TypeInfo_nn___pyx_t_5numpy_int_t, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) __PYX_ERR(0, 72, __pyx_L1_error)
-  }
-  __pyx_pybuffernd_rb.diminfo[0].strides = __pyx_pybuffernd_rb.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_rb.diminfo[0].shape = __pyx_pybuffernd_rb.rcbuffer->pybuffer.shape[0];
-  __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = ((PyObject *)__pyx_f_5argos_8cutility_rect_intersection(__pyx_v_ra, __pyx_v_rb, 0)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 72, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_r = __pyx_t_1;
-  __pyx_t_1 = 0;
-  goto __pyx_L0;
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  { PyObject *__pyx_type, *__pyx_value, *__pyx_tb;
-    __Pyx_PyThreadState_declare
-    __Pyx_PyThreadState_assign
-    __Pyx_ErrFetch(&__pyx_type, &__pyx_value, &__pyx_tb);
-    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_ra.rcbuffer->pybuffer);
-    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_rb.rcbuffer->pybuffer);
-  __Pyx_ErrRestore(__pyx_type, __pyx_value, __pyx_tb);}
-  __Pyx_AddTraceback("argos.cutility.rect_intersection", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
-  goto __pyx_L2;
   __pyx_L0:;
-  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_ra.rcbuffer->pybuffer);
-  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_rb.rcbuffer->pybuffer);
-  __pyx_L2:;
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "argos/cutility.pyx":107
- * @cython.boundscheck(False) # turn off bounds-checking for entire function
- * @cython.wraparound(False)  # turn off negative index wrapping for entire function
- * cpdef float rect_iou(np.ndarray[np.int_t, ndim=1] ra, np.ndarray[np.int_t, ndim=1] rb):             # <<<<<<<<<<<<<<
- *     """Compute Intersection over Union of two axis-aligned rectangles.
+/* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":271
  * 
+ *         @property
+ *         cdef inline npy_intp *strides(self) nogil:             # <<<<<<<<<<<<<<
+ *             """Returns a pointer to the strides of the array.
+ *             The number of elements matches the number of dimensions of the array (ndim).
  */
 
-static PyObject *__pyx_pw_5argos_8cutility_11rect_iou(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static float __pyx_f_5argos_8cutility_rect_iou(PyArrayObject *__pyx_v_ra, PyArrayObject *__pyx_v_rb, CYTHON_UNUSED int __pyx_skip_dispatch) {
-  PyArrayObject *__pyx_v_inter = 0;
-  float __pyx_v_area_i;
-  float __pyx_v_area_u;
-  float __pyx_v_ret;
-  __Pyx_LocalBuf_ND __pyx_pybuffernd_ra;
-  __Pyx_Buffer __pyx_pybuffer_ra;
-  __Pyx_LocalBuf_ND __pyx_pybuffernd_rb;
-  __Pyx_Buffer __pyx_pybuffer_rb;
-  float __pyx_r;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  PyObject *__pyx_t_2 = NULL;
-  PyObject *__pyx_t_3 = NULL;
-  float __pyx_t_4;
-  Py_ssize_t __pyx_t_5;
-  Py_ssize_t __pyx_t_6;
-  Py_ssize_t __pyx_t_7;
-  Py_ssize_t __pyx_t_8;
-  int __pyx_t_9;
-  int __pyx_t_10;
-  double __pyx_t_11;
-  PyObject *__pyx_t_12 = NULL;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("rect_iou", 0);
-  __pyx_pybuffer_ra.pybuffer.buf = NULL;
-  __pyx_pybuffer_ra.refcount = 0;
-  __pyx_pybuffernd_ra.data = NULL;
-  __pyx_pybuffernd_ra.rcbuffer = &__pyx_pybuffer_ra;
-  __pyx_pybuffer_rb.pybuffer.buf = NULL;
-  __pyx_pybuffer_rb.refcount = 0;
-  __pyx_pybuffernd_rb.data = NULL;
-  __pyx_pybuffernd_rb.rcbuffer = &__pyx_pybuffer_rb;
-  {
-    __Pyx_BufFmt_StackElem __pyx_stack[1];
-    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_ra.rcbuffer->pybuffer, (PyObject*)__pyx_v_ra, &__Pyx_TypeInfo_nn___pyx_t_5numpy_int_t, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) __PYX_ERR(0, 107, __pyx_L1_error)
-  }
-  __pyx_pybuffernd_ra.diminfo[0].strides = __pyx_pybuffernd_ra.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_ra.diminfo[0].shape = __pyx_pybuffernd_ra.rcbuffer->pybuffer.shape[0];
-  {
-    __Pyx_BufFmt_StackElem __pyx_stack[1];
-    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_rb.rcbuffer->pybuffer, (PyObject*)__pyx_v_rb, &__Pyx_TypeInfo_nn___pyx_t_5numpy_int_t, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) __PYX_ERR(0, 107, __pyx_L1_error)
-  }
-  __pyx_pybuffernd_rb.diminfo[0].strides = __pyx_pybuffernd_rb.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_rb.diminfo[0].shape = __pyx_pybuffernd_rb.rcbuffer->pybuffer.shape[0];
-
-  /* "argos/cutility.pyx":125
- *         The Intersection over Union of two rectangles.
- *     """
- *     cdef np.ndarray inter = rect_intersection(ra, rb)             # <<<<<<<<<<<<<<
- *     cdef float area_i, area_u
- *     cdef float ret
- */
-  __pyx_t_1 = ((PyObject *)__pyx_f_5argos_8cutility_rect_intersection(((PyArrayObject *)__pyx_v_ra), ((PyArrayObject *)__pyx_v_rb), 0)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 125, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_v_inter = ((PyArrayObject *)__pyx_t_1);
-  __pyx_t_1 = 0;
-
-  /* "argos/cutility.pyx":128
- *     cdef float area_i, area_u
- *     cdef float ret
- *     area_i = inter[2] * inter[3]             # <<<<<<<<<<<<<<
- *     area_u = ra[2] * ra[3] + rb[2] * rb[3] - area_i
- *     if area_u <= 0 or area_i < 0:
- */
-  __pyx_t_1 = __Pyx_GetItemInt(((PyObject *)__pyx_v_inter), 2, long, 1, __Pyx_PyInt_From_long, 0, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 128, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_GetItemInt(((PyObject *)__pyx_v_inter), 3, long, 1, __Pyx_PyInt_From_long, 0, 0, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 128, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = PyNumber_Multiply(__pyx_t_1, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 128, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_4 = __pyx_PyFloat_AsFloat(__pyx_t_3); if (unlikely((__pyx_t_4 == (float)-1) && PyErr_Occurred())) __PYX_ERR(0, 128, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_v_area_i = __pyx_t_4;
-
-  /* "argos/cutility.pyx":129
- *     cdef float ret
- *     area_i = inter[2] * inter[3]
- *     area_u = ra[2] * ra[3] + rb[2] * rb[3] - area_i             # <<<<<<<<<<<<<<
- *     if area_u <= 0 or area_i < 0:
- *         raise ValueError('Area not positive')
- */
-  __pyx_t_5 = 2;
-  __pyx_t_6 = 3;
-  __pyx_t_7 = 2;
-  __pyx_t_8 = 3;
-  __pyx_v_area_u = ((((*__Pyx_BufPtrStrided1d(__pyx_t_5numpy_int_t *, __pyx_pybuffernd_ra.rcbuffer->pybuffer.buf, __pyx_t_5, __pyx_pybuffernd_ra.diminfo[0].strides)) * (*__Pyx_BufPtrStrided1d(__pyx_t_5numpy_int_t *, __pyx_pybuffernd_ra.rcbuffer->pybuffer.buf, __pyx_t_6, __pyx_pybuffernd_ra.diminfo[0].strides))) + ((*__Pyx_BufPtrStrided1d(__pyx_t_5numpy_int_t *, __pyx_pybuffernd_rb.rcbuffer->pybuffer.buf, __pyx_t_7, __pyx_pybuffernd_rb.diminfo[0].strides)) * (*__Pyx_BufPtrStrided1d(__pyx_t_5numpy_int_t *, __pyx_pybuffernd_rb.rcbuffer->pybuffer.buf, __pyx_t_8, __pyx_pybuffernd_rb.diminfo[0].strides)))) - __pyx_v_area_i);
-
-  /* "argos/cutility.pyx":130
- *     area_i = inter[2] * inter[3]
- *     area_u = ra[2] * ra[3] + rb[2] * rb[3] - area_i
- *     if area_u <= 0 or area_i < 0:             # <<<<<<<<<<<<<<
- *         raise ValueError('Area not positive')
- *     ret = 1.0 * area_i / area_u
- */
-  __pyx_t_10 = ((__pyx_v_area_u <= 0.0) != 0);
-  if (!__pyx_t_10) {
-  } else {
-    __pyx_t_9 = __pyx_t_10;
-    goto __pyx_L4_bool_binop_done;
-  }
-  __pyx_t_10 = ((__pyx_v_area_i < 0.0) != 0);
-  __pyx_t_9 = __pyx_t_10;
-  __pyx_L4_bool_binop_done:;
-  if (unlikely(__pyx_t_9)) {
-
-    /* "argos/cutility.pyx":131
- *     area_u = ra[2] * ra[3] + rb[2] * rb[3] - area_i
- *     if area_u <= 0 or area_i < 0:
- *         raise ValueError('Area not positive')             # <<<<<<<<<<<<<<
- *     ret = 1.0 * area_i / area_u
- *     if np.isinf(ret) or np.isnan(ret) or ret < 0:
- */
-    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__5, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 131, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __PYX_ERR(0, 131, __pyx_L1_error)
-
-    /* "argos/cutility.pyx":130
- *     area_i = inter[2] * inter[3]
- *     area_u = ra[2] * ra[3] + rb[2] * rb[3] - area_i
- *     if area_u <= 0 or area_i < 0:             # <<<<<<<<<<<<<<
- *         raise ValueError('Area not positive')
- *     ret = 1.0 * area_i / area_u
- */
-  }
+static CYTHON_INLINE npy_intp *__pyx_f_5numpy_7ndarray_7strides_strides(PyArrayObject *__pyx_v_self) {
+  npy_intp *__pyx_r;
 
-  /* "argos/cutility.pyx":132
- *     if area_u <= 0 or area_i < 0:
- *         raise ValueError('Area not positive')
- *     ret = 1.0 * area_i / area_u             # <<<<<<<<<<<<<<
- *     if np.isinf(ret) or np.isnan(ret) or ret < 0:
- *         raise ValueError('Invalid intersection')
- */
-  __pyx_t_11 = (1.0 * __pyx_v_area_i);
-  if (unlikely(__pyx_v_area_u == 0)) {
-    PyErr_SetString(PyExc_ZeroDivisionError, "float division");
-    __PYX_ERR(0, 132, __pyx_L1_error)
-  }
-  __pyx_v_ret = (__pyx_t_11 / __pyx_v_area_u);
-
-  /* "argos/cutility.pyx":133
- *         raise ValueError('Area not positive')
- *     ret = 1.0 * area_i / area_u
- *     if np.isinf(ret) or np.isnan(ret) or ret < 0:             # <<<<<<<<<<<<<<
- *         raise ValueError('Invalid intersection')
- *     return ret
- */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 133, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_isinf); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 133, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = PyFloat_FromDouble(__pyx_v_ret); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 133, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_12 = NULL;
-  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
-    __pyx_t_12 = PyMethod_GET_SELF(__pyx_t_1);
-    if (likely(__pyx_t_12)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
-      __Pyx_INCREF(__pyx_t_12);
-      __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_1, function);
-    }
-  }
-  __pyx_t_3 = (__pyx_t_12) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_12, __pyx_t_2) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_t_2);
-  __Pyx_XDECREF(__pyx_t_12); __pyx_t_12 = 0;
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 133, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_10 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 133, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (!__pyx_t_10) {
-  } else {
-    __pyx_t_9 = __pyx_t_10;
-    goto __pyx_L7_bool_binop_done;
-  }
-  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 133, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_isnan); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 133, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = PyFloat_FromDouble(__pyx_v_ret); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 133, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_12 = NULL;
-  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
-    __pyx_t_12 = PyMethod_GET_SELF(__pyx_t_2);
-    if (likely(__pyx_t_12)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
-      __Pyx_INCREF(__pyx_t_12);
-      __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_2, function);
-    }
-  }
-  __pyx_t_3 = (__pyx_t_12) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_12, __pyx_t_1) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_1);
-  __Pyx_XDECREF(__pyx_t_12); __pyx_t_12 = 0;
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 133, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_10 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 133, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (!__pyx_t_10) {
-  } else {
-    __pyx_t_9 = __pyx_t_10;
-    goto __pyx_L7_bool_binop_done;
-  }
-  __pyx_t_10 = ((__pyx_v_ret < 0.0) != 0);
-  __pyx_t_9 = __pyx_t_10;
-  __pyx_L7_bool_binop_done:;
-  if (unlikely(__pyx_t_9)) {
-
-    /* "argos/cutility.pyx":134
- *     ret = 1.0 * area_i / area_u
- *     if np.isinf(ret) or np.isnan(ret) or ret < 0:
- *         raise ValueError('Invalid intersection')             # <<<<<<<<<<<<<<
- *     return ret
- * 
- */
-    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__6, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 134, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __PYX_ERR(0, 134, __pyx_L1_error)
-
-    /* "argos/cutility.pyx":133
- *         raise ValueError('Area not positive')
- *     ret = 1.0 * area_i / area_u
- *     if np.isinf(ret) or np.isnan(ret) or ret < 0:             # <<<<<<<<<<<<<<
- *         raise ValueError('Invalid intersection')
- *     return ret
- */
-  }
-
-  /* "argos/cutility.pyx":135
- *     if np.isinf(ret) or np.isnan(ret) or ret < 0:
- *         raise ValueError('Invalid intersection')
- *     return ret             # <<<<<<<<<<<<<<
- * 
+  /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":275
+ *             The number of elements matches the number of dimensions of the array (ndim).
+ *             """
+ *             return PyArray_STRIDES(self)             # <<<<<<<<<<<<<<
  * 
+ *         @property
  */
-  __pyx_r = __pyx_v_ret;
+  __pyx_r = PyArray_STRIDES(__pyx_v_self);
   goto __pyx_L0;
 
-  /* "argos/cutility.pyx":107
- * @cython.boundscheck(False) # turn off bounds-checking for entire function
- * @cython.wraparound(False)  # turn off negative index wrapping for entire function
- * cpdef float rect_iou(np.ndarray[np.int_t, ndim=1] ra, np.ndarray[np.int_t, ndim=1] rb):             # <<<<<<<<<<<<<<
- *     """Compute Intersection over Union of two axis-aligned rectangles.
+  /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":271
  * 
+ *         @property
+ *         cdef inline npy_intp *strides(self) nogil:             # <<<<<<<<<<<<<<
+ *             """Returns a pointer to the strides of the array.
+ *             The number of elements matches the number of dimensions of the array (ndim).
  */
 
   /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_XDECREF(__pyx_t_2);
-  __Pyx_XDECREF(__pyx_t_3);
-  __Pyx_XDECREF(__pyx_t_12);
-  { PyObject *__pyx_type, *__pyx_value, *__pyx_tb;
-    __Pyx_PyThreadState_declare
-    __Pyx_PyThreadState_assign
-    __Pyx_ErrFetch(&__pyx_type, &__pyx_value, &__pyx_tb);
-    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_ra.rcbuffer->pybuffer);
-    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_rb.rcbuffer->pybuffer);
-  __Pyx_ErrRestore(__pyx_type, __pyx_value, __pyx_tb);}
-  __Pyx_WriteUnraisable("argos.cutility.rect_iou", __pyx_clineno, __pyx_lineno, __pyx_filename, 1, 0);
-  __pyx_r = 0;
-  goto __pyx_L2;
-  __pyx_L0:;
-  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_ra.rcbuffer->pybuffer);
-  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_rb.rcbuffer->pybuffer);
-  __pyx_L2:;
-  __Pyx_XDECREF((PyObject *)__pyx_v_inter);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* Python wrapper */
-static PyObject *__pyx_pw_5argos_8cutility_11rect_iou(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static char __pyx_doc_5argos_8cutility_10rect_iou[] = "Compute Intersection over Union of two axis-aligned rectangles.\n\n    This is the ratio of the are of intersection to the area of the union\n    of the two rectangles.\n\n    Parameters\n    ----------\n    ra: np.ndarray\n    rb: np.ndarray\n        Axis aligned rectangles specified as (x, y, w, h) where (x, y) is\n        the position of the lower left corner, w and h are width and height.\n\n    Returns\n    -------\n    float\n        The Intersection over Union of two rectangles.\n    ";
-static PyObject *__pyx_pw_5argos_8cutility_11rect_iou(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
-  PyArrayObject *__pyx_v_ra = 0;
-  PyArrayObject *__pyx_v_rb = 0;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("rect_iou (wrapper)", 0);
-  {
-    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_ra,&__pyx_n_s_rb,0};
-    PyObject* values[2] = {0,0};
-    if (unlikely(__pyx_kwds)) {
-      Py_ssize_t kw_args;
-      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
-      switch (pos_args) {
-        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
-        CYTHON_FALLTHROUGH;
-        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
-        CYTHON_FALLTHROUGH;
-        case  0: break;
-        default: goto __pyx_L5_argtuple_error;
-      }
-      kw_args = PyDict_Size(__pyx_kwds);
-      switch (pos_args) {
-        case  0:
-        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_ra)) != 0)) kw_args--;
-        else goto __pyx_L5_argtuple_error;
-        CYTHON_FALLTHROUGH;
-        case  1:
-        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_rb)) != 0)) kw_args--;
-        else {
-          __Pyx_RaiseArgtupleInvalid("rect_iou", 1, 2, 2, 1); __PYX_ERR(0, 107, __pyx_L3_error)
-        }
-      }
-      if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "rect_iou") < 0)) __PYX_ERR(0, 107, __pyx_L3_error)
-      }
-    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
-      goto __pyx_L5_argtuple_error;
-    } else {
-      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
-      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
-    }
-    __pyx_v_ra = ((PyArrayObject *)values[0]);
-    __pyx_v_rb = ((PyArrayObject *)values[1]);
-  }
-  goto __pyx_L4_argument_unpacking_done;
-  __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("rect_iou", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 107, __pyx_L3_error)
-  __pyx_L3_error:;
-  __Pyx_AddTraceback("argos.cutility.rect_iou", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __Pyx_RefNannyFinishContext();
-  return NULL;
-  __pyx_L4_argument_unpacking_done:;
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_ra), __pyx_ptype_5numpy_ndarray, 1, "ra", 0))) __PYX_ERR(0, 107, __pyx_L1_error)
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_rb), __pyx_ptype_5numpy_ndarray, 1, "rb", 0))) __PYX_ERR(0, 107, __pyx_L1_error)
-  __pyx_r = __pyx_pf_5argos_8cutility_10rect_iou(__pyx_self, __pyx_v_ra, __pyx_v_rb);
-
-  /* function exit code */
-  goto __pyx_L0;
-  __pyx_L1_error:;
-  __pyx_r = NULL;
   __pyx_L0:;
-  __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_5argos_8cutility_10rect_iou(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_ra, PyArrayObject *__pyx_v_rb) {
-  __Pyx_LocalBuf_ND __pyx_pybuffernd_ra;
-  __Pyx_Buffer __pyx_pybuffer_ra;
-  __Pyx_LocalBuf_ND __pyx_pybuffernd_rb;
-  __Pyx_Buffer __pyx_pybuffer_rb;
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("rect_iou", 0);
-  __pyx_pybuffer_ra.pybuffer.buf = NULL;
-  __pyx_pybuffer_ra.refcount = 0;
-  __pyx_pybuffernd_ra.data = NULL;
-  __pyx_pybuffernd_ra.rcbuffer = &__pyx_pybuffer_ra;
-  __pyx_pybuffer_rb.pybuffer.buf = NULL;
-  __pyx_pybuffer_rb.refcount = 0;
-  __pyx_pybuffernd_rb.data = NULL;
-  __pyx_pybuffernd_rb.rcbuffer = &__pyx_pybuffer_rb;
-  {
-    __Pyx_BufFmt_StackElem __pyx_stack[1];
-    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_ra.rcbuffer->pybuffer, (PyObject*)__pyx_v_ra, &__Pyx_TypeInfo_nn___pyx_t_5numpy_int_t, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) __PYX_ERR(0, 107, __pyx_L1_error)
-  }
-  __pyx_pybuffernd_ra.diminfo[0].strides = __pyx_pybuffernd_ra.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_ra.diminfo[0].shape = __pyx_pybuffernd_ra.rcbuffer->pybuffer.shape[0];
-  {
-    __Pyx_BufFmt_StackElem __pyx_stack[1];
-    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_rb.rcbuffer->pybuffer, (PyObject*)__pyx_v_rb, &__Pyx_TypeInfo_nn___pyx_t_5numpy_int_t, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) __PYX_ERR(0, 107, __pyx_L1_error)
-  }
-  __pyx_pybuffernd_rb.diminfo[0].strides = __pyx_pybuffernd_rb.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_rb.diminfo[0].shape = __pyx_pybuffernd_rb.rcbuffer->pybuffer.shape[0];
-  __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = PyFloat_FromDouble(__pyx_f_5argos_8cutility_rect_iou(__pyx_v_ra, __pyx_v_rb, 0)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 107, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_r = __pyx_t_1;
-  __pyx_t_1 = 0;
-  goto __pyx_L0;
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  { PyObject *__pyx_type, *__pyx_value, *__pyx_tb;
-    __Pyx_PyThreadState_declare
-    __Pyx_PyThreadState_assign
-    __Pyx_ErrFetch(&__pyx_type, &__pyx_value, &__pyx_tb);
-    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_ra.rcbuffer->pybuffer);
-    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_rb.rcbuffer->pybuffer);
-  __Pyx_ErrRestore(__pyx_type, __pyx_value, __pyx_tb);}
-  __Pyx_AddTraceback("argos.cutility.rect_iou", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
-  goto __pyx_L2;
-  __pyx_L0:;
-  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_ra.rcbuffer->pybuffer);
-  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_rb.rcbuffer->pybuffer);
-  __pyx_L2:;
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "argos/cutility.pyx":140
- * @cython.boundscheck(False) # turn off bounds-checking for entire function
- * @cython.wraparound(False)  # turn off negative index wrapping for entire function
- * cpdef float rect_ios(np.ndarray[np.int_t, ndim=1] ra, np.ndarray[np.int_t, ndim=1] rb):             # <<<<<<<<<<<<<<
- *     """Compute intersection over area of smaller of two axis-aligned
- *     rectangles.
- */
-
-static PyObject *__pyx_pw_5argos_8cutility_13rect_ios(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static float __pyx_f_5argos_8cutility_rect_ios(PyArrayObject *__pyx_v_ra, PyArrayObject *__pyx_v_rb, CYTHON_UNUSED int __pyx_skip_dispatch) {
-  PyArrayObject *__pyx_v_inter = 0;
-  float __pyx_v_area_i;
-  float __pyx_v_area_a;
-  float __pyx_v_area_b;
-  float __pyx_v_ret;
-  __Pyx_LocalBuf_ND __pyx_pybuffernd_ra;
-  __Pyx_Buffer __pyx_pybuffer_ra;
-  __Pyx_LocalBuf_ND __pyx_pybuffernd_rb;
-  __Pyx_Buffer __pyx_pybuffer_rb;
-  float __pyx_r;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  PyObject *__pyx_t_2 = NULL;
-  PyObject *__pyx_t_3 = NULL;
-  float __pyx_t_4;
-  Py_ssize_t __pyx_t_5;
-  Py_ssize_t __pyx_t_6;
-  int __pyx_t_7;
-  int __pyx_t_8;
-  float __pyx_t_9;
-  float __pyx_t_10;
-  PyObject *__pyx_t_11 = NULL;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("rect_ios", 0);
-  __pyx_pybuffer_ra.pybuffer.buf = NULL;
-  __pyx_pybuffer_ra.refcount = 0;
-  __pyx_pybuffernd_ra.data = NULL;
-  __pyx_pybuffernd_ra.rcbuffer = &__pyx_pybuffer_ra;
-  __pyx_pybuffer_rb.pybuffer.buf = NULL;
-  __pyx_pybuffer_rb.refcount = 0;
-  __pyx_pybuffernd_rb.data = NULL;
-  __pyx_pybuffernd_rb.rcbuffer = &__pyx_pybuffer_rb;
-  {
-    __Pyx_BufFmt_StackElem __pyx_stack[1];
-    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_ra.rcbuffer->pybuffer, (PyObject*)__pyx_v_ra, &__Pyx_TypeInfo_nn___pyx_t_5numpy_int_t, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) __PYX_ERR(0, 140, __pyx_L1_error)
-  }
-  __pyx_pybuffernd_ra.diminfo[0].strides = __pyx_pybuffernd_ra.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_ra.diminfo[0].shape = __pyx_pybuffernd_ra.rcbuffer->pybuffer.shape[0];
-  {
-    __Pyx_BufFmt_StackElem __pyx_stack[1];
-    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_rb.rcbuffer->pybuffer, (PyObject*)__pyx_v_rb, &__Pyx_TypeInfo_nn___pyx_t_5numpy_int_t, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) __PYX_ERR(0, 140, __pyx_L1_error)
-  }
-  __pyx_pybuffernd_rb.diminfo[0].strides = __pyx_pybuffernd_rb.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_rb.diminfo[0].shape = __pyx_pybuffernd_rb.rcbuffer->pybuffer.shape[0];
-
-  /* "argos/cutility.pyx":159
- *         The Intersection over area of the smaller of two rectangles.
- *     """
- *     cdef np.ndarray inter = rect_intersection(ra, rb)             # <<<<<<<<<<<<<<
- *     cdef float area_i = inter[2] *inter[3]
- *     cdef float area_a = ra[2] * ra[3]
- */
-  __pyx_t_1 = ((PyObject *)__pyx_f_5argos_8cutility_rect_intersection(((PyArrayObject *)__pyx_v_ra), ((PyArrayObject *)__pyx_v_rb), 0)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 159, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_v_inter = ((PyArrayObject *)__pyx_t_1);
-  __pyx_t_1 = 0;
-
-  /* "argos/cutility.pyx":160
- *     """
- *     cdef np.ndarray inter = rect_intersection(ra, rb)
- *     cdef float area_i = inter[2] *inter[3]             # <<<<<<<<<<<<<<
- *     cdef float area_a = ra[2] * ra[3]
- *     cdef float area_b = rb[2] * rb[3]
- */
-  __pyx_t_1 = __Pyx_GetItemInt(((PyObject *)__pyx_v_inter), 2, long, 1, __Pyx_PyInt_From_long, 0, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 160, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_GetItemInt(((PyObject *)__pyx_v_inter), 3, long, 1, __Pyx_PyInt_From_long, 0, 0, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 160, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = PyNumber_Multiply(__pyx_t_1, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 160, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_4 = __pyx_PyFloat_AsFloat(__pyx_t_3); if (unlikely((__pyx_t_4 == (float)-1) && PyErr_Occurred())) __PYX_ERR(0, 160, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_v_area_i = __pyx_t_4;
-
-  /* "argos/cutility.pyx":161
- *     cdef np.ndarray inter = rect_intersection(ra, rb)
- *     cdef float area_i = inter[2] *inter[3]
- *     cdef float area_a = ra[2] * ra[3]             # <<<<<<<<<<<<<<
- *     cdef float area_b = rb[2] * rb[3]
- *     if area_i < 0 or area_a <= 0 or area_b <= 0:
- */
-  __pyx_t_5 = 2;
-  __pyx_t_6 = 3;
-  __pyx_v_area_a = ((*__Pyx_BufPtrStrided1d(__pyx_t_5numpy_int_t *, __pyx_pybuffernd_ra.rcbuffer->pybuffer.buf, __pyx_t_5, __pyx_pybuffernd_ra.diminfo[0].strides)) * (*__Pyx_BufPtrStrided1d(__pyx_t_5numpy_int_t *, __pyx_pybuffernd_ra.rcbuffer->pybuffer.buf, __pyx_t_6, __pyx_pybuffernd_ra.diminfo[0].strides)));
-
-  /* "argos/cutility.pyx":162
- *     cdef float area_i = inter[2] *inter[3]
- *     cdef float area_a = ra[2] * ra[3]
- *     cdef float area_b = rb[2] * rb[3]             # <<<<<<<<<<<<<<
- *     if area_i < 0 or area_a <= 0 or area_b <= 0:
- *         raise ValueError('Area not positive')
- */
-  __pyx_t_6 = 2;
-  __pyx_t_5 = 3;
-  __pyx_v_area_b = ((*__Pyx_BufPtrStrided1d(__pyx_t_5numpy_int_t *, __pyx_pybuffernd_rb.rcbuffer->pybuffer.buf, __pyx_t_6, __pyx_pybuffernd_rb.diminfo[0].strides)) * (*__Pyx_BufPtrStrided1d(__pyx_t_5numpy_int_t *, __pyx_pybuffernd_rb.rcbuffer->pybuffer.buf, __pyx_t_5, __pyx_pybuffernd_rb.diminfo[0].strides)));
-
-  /* "argos/cutility.pyx":163
- *     cdef float area_a = ra[2] * ra[3]
- *     cdef float area_b = rb[2] * rb[3]
- *     if area_i < 0 or area_a <= 0 or area_b <= 0:             # <<<<<<<<<<<<<<
- *         raise ValueError('Area not positive')
- *     cdef float ret = area_i / min(area_a, area_b)
- */
-  __pyx_t_8 = ((__pyx_v_area_i < 0.0) != 0);
-  if (!__pyx_t_8) {
-  } else {
-    __pyx_t_7 = __pyx_t_8;
-    goto __pyx_L4_bool_binop_done;
-  }
-  __pyx_t_8 = ((__pyx_v_area_a <= 0.0) != 0);
-  if (!__pyx_t_8) {
-  } else {
-    __pyx_t_7 = __pyx_t_8;
-    goto __pyx_L4_bool_binop_done;
-  }
-  __pyx_t_8 = ((__pyx_v_area_b <= 0.0) != 0);
-  __pyx_t_7 = __pyx_t_8;
-  __pyx_L4_bool_binop_done:;
-  if (unlikely(__pyx_t_7)) {
-
-    /* "argos/cutility.pyx":164
- *     cdef float area_b = rb[2] * rb[3]
- *     if area_i < 0 or area_a <= 0 or area_b <= 0:
- *         raise ValueError('Area not positive')             # <<<<<<<<<<<<<<
- *     cdef float ret = area_i / min(area_a, area_b)
- *     if np.isinf(ret) or np.isnan(ret) or ret < 0:
- */
-    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__5, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 164, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __PYX_ERR(0, 164, __pyx_L1_error)
-
-    /* "argos/cutility.pyx":163
- *     cdef float area_a = ra[2] * ra[3]
- *     cdef float area_b = rb[2] * rb[3]
- *     if area_i < 0 or area_a <= 0 or area_b <= 0:             # <<<<<<<<<<<<<<
- *         raise ValueError('Area not positive')
- *     cdef float ret = area_i / min(area_a, area_b)
- */
-  }
-
-  /* "argos/cutility.pyx":165
- *     if area_i < 0 or area_a <= 0 or area_b <= 0:
- *         raise ValueError('Area not positive')
- *     cdef float ret = area_i / min(area_a, area_b)             # <<<<<<<<<<<<<<
- *     if np.isinf(ret) or np.isnan(ret) or ret < 0:
- *         raise ValueError('Invalid intersection')
- */
-  __pyx_t_4 = __pyx_v_area_b;
-  __pyx_t_9 = __pyx_v_area_a;
-  if (((__pyx_t_4 < __pyx_t_9) != 0)) {
-    __pyx_t_10 = __pyx_t_4;
-  } else {
-    __pyx_t_10 = __pyx_t_9;
-  }
-  __pyx_t_4 = __pyx_t_10;
-  if (unlikely(__pyx_t_4 == 0)) {
-    PyErr_SetString(PyExc_ZeroDivisionError, "float division");
-    __PYX_ERR(0, 165, __pyx_L1_error)
-  }
-  __pyx_v_ret = (__pyx_v_area_i / __pyx_t_4);
-
-  /* "argos/cutility.pyx":166
- *         raise ValueError('Area not positive')
- *     cdef float ret = area_i / min(area_a, area_b)
- *     if np.isinf(ret) or np.isnan(ret) or ret < 0:             # <<<<<<<<<<<<<<
- *         raise ValueError('Invalid intersection')
- *     return ret
- */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 166, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_isinf); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 166, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = PyFloat_FromDouble(__pyx_v_ret); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 166, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_11 = NULL;
-  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
-    __pyx_t_11 = PyMethod_GET_SELF(__pyx_t_1);
-    if (likely(__pyx_t_11)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
-      __Pyx_INCREF(__pyx_t_11);
-      __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_1, function);
-    }
-  }
-  __pyx_t_3 = (__pyx_t_11) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_11, __pyx_t_2) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_t_2);
-  __Pyx_XDECREF(__pyx_t_11); __pyx_t_11 = 0;
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 166, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_8 < 0)) __PYX_ERR(0, 166, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (!__pyx_t_8) {
-  } else {
-    __pyx_t_7 = __pyx_t_8;
-    goto __pyx_L8_bool_binop_done;
-  }
-  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 166, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_isnan); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 166, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = PyFloat_FromDouble(__pyx_v_ret); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 166, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_11 = NULL;
-  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
-    __pyx_t_11 = PyMethod_GET_SELF(__pyx_t_2);
-    if (likely(__pyx_t_11)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
-      __Pyx_INCREF(__pyx_t_11);
-      __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_2, function);
-    }
-  }
-  __pyx_t_3 = (__pyx_t_11) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_11, __pyx_t_1) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_1);
-  __Pyx_XDECREF(__pyx_t_11); __pyx_t_11 = 0;
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 166, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_8 < 0)) __PYX_ERR(0, 166, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (!__pyx_t_8) {
-  } else {
-    __pyx_t_7 = __pyx_t_8;
-    goto __pyx_L8_bool_binop_done;
-  }
-  __pyx_t_8 = ((__pyx_v_ret < 0.0) != 0);
-  __pyx_t_7 = __pyx_t_8;
-  __pyx_L8_bool_binop_done:;
-  if (unlikely(__pyx_t_7)) {
-
-    /* "argos/cutility.pyx":167
- *     cdef float ret = area_i / min(area_a, area_b)
- *     if np.isinf(ret) or np.isnan(ret) or ret < 0:
- *         raise ValueError('Invalid intersection')             # <<<<<<<<<<<<<<
- *     return ret
+/* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":278
  * 
+ *         @property
+ *         cdef inline npy_intp size(self) nogil:             # <<<<<<<<<<<<<<
+ *             """Returns the total size (in number of elements) of the array.
+ *             """
  */
-    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__6, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 167, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __PYX_ERR(0, 167, __pyx_L1_error)
 
-    /* "argos/cutility.pyx":166
- *         raise ValueError('Area not positive')
- *     cdef float ret = area_i / min(area_a, area_b)
- *     if np.isinf(ret) or np.isnan(ret) or ret < 0:             # <<<<<<<<<<<<<<
- *         raise ValueError('Invalid intersection')
- *     return ret
- */
-  }
+static CYTHON_INLINE npy_intp __pyx_f_5numpy_7ndarray_4size_size(PyArrayObject *__pyx_v_self) {
+  npy_intp __pyx_r;
 
-  /* "argos/cutility.pyx":168
- *     if np.isinf(ret) or np.isnan(ret) or ret < 0:
- *         raise ValueError('Invalid intersection')
- *     return ret             # <<<<<<<<<<<<<<
- * 
+  /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":281
+ *             """Returns the total size (in number of elements) of the array.
+ *             """
+ *             return PyArray_SIZE(self)             # <<<<<<<<<<<<<<
  * 
+ *         @property
  */
-  __pyx_r = __pyx_v_ret;
+  __pyx_r = PyArray_SIZE(__pyx_v_self);
   goto __pyx_L0;
 
-  /* "argos/cutility.pyx":140
- * @cython.boundscheck(False) # turn off bounds-checking for entire function
- * @cython.wraparound(False)  # turn off negative index wrapping for entire function
- * cpdef float rect_ios(np.ndarray[np.int_t, ndim=1] ra, np.ndarray[np.int_t, ndim=1] rb):             # <<<<<<<<<<<<<<
- *     """Compute intersection over area of smaller of two axis-aligned
- *     rectangles.
+  /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":278
+ * 
+ *         @property
+ *         cdef inline npy_intp size(self) nogil:             # <<<<<<<<<<<<<<
+ *             """Returns the total size (in number of elements) of the array.
+ *             """
  */
 
   /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_XDECREF(__pyx_t_2);
-  __Pyx_XDECREF(__pyx_t_3);
-  __Pyx_XDECREF(__pyx_t_11);
-  { PyObject *__pyx_type, *__pyx_value, *__pyx_tb;
-    __Pyx_PyThreadState_declare
-    __Pyx_PyThreadState_assign
-    __Pyx_ErrFetch(&__pyx_type, &__pyx_value, &__pyx_tb);
-    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_ra.rcbuffer->pybuffer);
-    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_rb.rcbuffer->pybuffer);
-  __Pyx_ErrRestore(__pyx_type, __pyx_value, __pyx_tb);}
-  __Pyx_WriteUnraisable("argos.cutility.rect_ios", __pyx_clineno, __pyx_lineno, __pyx_filename, 1, 0);
-  __pyx_r = 0;
-  goto __pyx_L2;
   __pyx_L0:;
-  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_ra.rcbuffer->pybuffer);
-  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_rb.rcbuffer->pybuffer);
-  __pyx_L2:;
-  __Pyx_XDECREF((PyObject *)__pyx_v_inter);
-  __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* Python wrapper */
-static PyObject *__pyx_pw_5argos_8cutility_13rect_ios(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static char __pyx_doc_5argos_8cutility_12rect_ios[] = "Compute intersection over area of smaller of two axis-aligned\n    rectangles.\n\n    This is the ratio of the are of intersection to the area of the smaller\n    of the two rectangles.\n\n    Parameters\n    ----------\n    ra: np.ndarray\n    rb: np.ndarray\n        Axis aligned rectangles specified as (x, y, w, h) where (x, y) is\n        the position of the lower left corner, w and h are width and height.\n\n    Returns\n    -------\n    float\n        The Intersection over area of the smaller of two rectangles.\n    ";
-static PyObject *__pyx_pw_5argos_8cutility_13rect_ios(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
-  PyArrayObject *__pyx_v_ra = 0;
-  PyArrayObject *__pyx_v_rb = 0;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("rect_ios (wrapper)", 0);
-  {
-    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_ra,&__pyx_n_s_rb,0};
-    PyObject* values[2] = {0,0};
-    if (unlikely(__pyx_kwds)) {
-      Py_ssize_t kw_args;
-      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
-      switch (pos_args) {
-        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
-        CYTHON_FALLTHROUGH;
-        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
-        CYTHON_FALLTHROUGH;
-        case  0: break;
-        default: goto __pyx_L5_argtuple_error;
-      }
-      kw_args = PyDict_Size(__pyx_kwds);
-      switch (pos_args) {
-        case  0:
-        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_ra)) != 0)) kw_args--;
-        else goto __pyx_L5_argtuple_error;
-        CYTHON_FALLTHROUGH;
-        case  1:
-        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_rb)) != 0)) kw_args--;
-        else {
-          __Pyx_RaiseArgtupleInvalid("rect_ios", 1, 2, 2, 1); __PYX_ERR(0, 140, __pyx_L3_error)
-        }
-      }
-      if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "rect_ios") < 0)) __PYX_ERR(0, 140, __pyx_L3_error)
-      }
-    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
-      goto __pyx_L5_argtuple_error;
-    } else {
-      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
-      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
-    }
-    __pyx_v_ra = ((PyArrayObject *)values[0]);
-    __pyx_v_rb = ((PyArrayObject *)values[1]);
-  }
-  goto __pyx_L4_argument_unpacking_done;
-  __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("rect_ios", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 140, __pyx_L3_error)
-  __pyx_L3_error:;
-  __Pyx_AddTraceback("argos.cutility.rect_ios", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __Pyx_RefNannyFinishContext();
-  return NULL;
-  __pyx_L4_argument_unpacking_done:;
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_ra), __pyx_ptype_5numpy_ndarray, 1, "ra", 0))) __PYX_ERR(0, 140, __pyx_L1_error)
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_rb), __pyx_ptype_5numpy_ndarray, 1, "rb", 0))) __PYX_ERR(0, 140, __pyx_L1_error)
-  __pyx_r = __pyx_pf_5argos_8cutility_12rect_ios(__pyx_self, __pyx_v_ra, __pyx_v_rb);
-
-  /* function exit code */
-  goto __pyx_L0;
-  __pyx_L1_error:;
-  __pyx_r = NULL;
-  __pyx_L0:;
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static PyObject *__pyx_pf_5argos_8cutility_12rect_ios(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_ra, PyArrayObject *__pyx_v_rb) {
-  __Pyx_LocalBuf_ND __pyx_pybuffernd_ra;
-  __Pyx_Buffer __pyx_pybuffer_ra;
-  __Pyx_LocalBuf_ND __pyx_pybuffernd_rb;
-  __Pyx_Buffer __pyx_pybuffer_rb;
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("rect_ios", 0);
-  __pyx_pybuffer_ra.pybuffer.buf = NULL;
-  __pyx_pybuffer_ra.refcount = 0;
-  __pyx_pybuffernd_ra.data = NULL;
-  __pyx_pybuffernd_ra.rcbuffer = &__pyx_pybuffer_ra;
-  __pyx_pybuffer_rb.pybuffer.buf = NULL;
-  __pyx_pybuffer_rb.refcount = 0;
-  __pyx_pybuffernd_rb.data = NULL;
-  __pyx_pybuffernd_rb.rcbuffer = &__pyx_pybuffer_rb;
-  {
-    __Pyx_BufFmt_StackElem __pyx_stack[1];
-    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_ra.rcbuffer->pybuffer, (PyObject*)__pyx_v_ra, &__Pyx_TypeInfo_nn___pyx_t_5numpy_int_t, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) __PYX_ERR(0, 140, __pyx_L1_error)
-  }
-  __pyx_pybuffernd_ra.diminfo[0].strides = __pyx_pybuffernd_ra.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_ra.diminfo[0].shape = __pyx_pybuffernd_ra.rcbuffer->pybuffer.shape[0];
-  {
-    __Pyx_BufFmt_StackElem __pyx_stack[1];
-    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_rb.rcbuffer->pybuffer, (PyObject*)__pyx_v_rb, &__Pyx_TypeInfo_nn___pyx_t_5numpy_int_t, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) __PYX_ERR(0, 140, __pyx_L1_error)
-  }
-  __pyx_pybuffernd_rb.diminfo[0].strides = __pyx_pybuffernd_rb.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_rb.diminfo[0].shape = __pyx_pybuffernd_rb.rcbuffer->pybuffer.shape[0];
-  __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = PyFloat_FromDouble(__pyx_f_5argos_8cutility_rect_ios(__pyx_v_ra, __pyx_v_rb, 0)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 140, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_r = __pyx_t_1;
-  __pyx_t_1 = 0;
-  goto __pyx_L0;
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  { PyObject *__pyx_type, *__pyx_value, *__pyx_tb;
-    __Pyx_PyThreadState_declare
-    __Pyx_PyThreadState_assign
-    __Pyx_ErrFetch(&__pyx_type, &__pyx_value, &__pyx_tb);
-    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_ra.rcbuffer->pybuffer);
-    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_rb.rcbuffer->pybuffer);
-  __Pyx_ErrRestore(__pyx_type, __pyx_value, __pyx_tb);}
-  __Pyx_AddTraceback("argos.cutility.rect_ios", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
-  goto __pyx_L2;
-  __pyx_L0:;
-  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_ra.rcbuffer->pybuffer);
-  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_rb.rcbuffer->pybuffer);
-  __pyx_L2:;
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "argos/cutility.pyx":173
- * # @cython.boundscheck(False) # turn off bounds-checking for entire function
- * @cython.wraparound(False)  # turn off negative index wrapping for entire function
- * cpdef np.ndarray[np.float_t, ndim=2] pairwise_distance(np.ndarray[np.int_t, ndim=2] new_bboxes, np.ndarray[np.int_t, ndim=2] bboxes,             # <<<<<<<<<<<<<<
- *                       object boxtype, object metric):
- *     """Takes two lists of boxes and computes the distance between every possible
- */
-
-static PyObject *__pyx_pw_5argos_8cutility_15pairwise_distance(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static PyArrayObject *__pyx_f_5argos_8cutility_pairwise_distance(PyArrayObject *__pyx_v_new_bboxes, PyArrayObject *__pyx_v_bboxes, PyObject *__pyx_v_boxtype, PyObject *__pyx_v_metric, CYTHON_UNUSED int __pyx_skip_dispatch) {
-  PyArrayObject *__pyx_v_dist = 0;
-  PyArrayObject *__pyx_v_centers = 0;
-  PyArrayObject *__pyx_v_new_centers = 0;
-  npy_intp __pyx_v_ii;
-  npy_intp __pyx_v_jj;
-  __Pyx_LocalBuf_ND __pyx_pybuffernd_bboxes;
-  __Pyx_Buffer __pyx_pybuffer_bboxes;
-  __Pyx_LocalBuf_ND __pyx_pybuffernd_new_bboxes;
-  __Pyx_Buffer __pyx_pybuffer_new_bboxes;
-  PyArrayObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  PyObject *__pyx_t_2 = NULL;
-  PyObject *__pyx_t_3 = NULL;
-  PyObject *__pyx_t_4 = NULL;
-  PyObject *__pyx_t_5 = NULL;
-  int __pyx_t_6;
-  npy_intp __pyx_t_7;
-  npy_intp __pyx_t_8;
-  npy_intp __pyx_t_9;
-  npy_intp __pyx_t_10;
-  npy_intp __pyx_t_11;
-  npy_intp __pyx_t_12;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("pairwise_distance", 0);
-  __pyx_pybuffer_new_bboxes.pybuffer.buf = NULL;
-  __pyx_pybuffer_new_bboxes.refcount = 0;
-  __pyx_pybuffernd_new_bboxes.data = NULL;
-  __pyx_pybuffernd_new_bboxes.rcbuffer = &__pyx_pybuffer_new_bboxes;
-  __pyx_pybuffer_bboxes.pybuffer.buf = NULL;
-  __pyx_pybuffer_bboxes.refcount = 0;
-  __pyx_pybuffernd_bboxes.data = NULL;
-  __pyx_pybuffernd_bboxes.rcbuffer = &__pyx_pybuffer_bboxes;
-  {
-    __Pyx_BufFmt_StackElem __pyx_stack[1];
-    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_new_bboxes.rcbuffer->pybuffer, (PyObject*)__pyx_v_new_bboxes, &__Pyx_TypeInfo_nn___pyx_t_5numpy_int_t, PyBUF_FORMAT| PyBUF_STRIDES, 2, 0, __pyx_stack) == -1)) __PYX_ERR(0, 173, __pyx_L1_error)
-  }
-  __pyx_pybuffernd_new_bboxes.diminfo[0].strides = __pyx_pybuffernd_new_bboxes.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_new_bboxes.diminfo[0].shape = __pyx_pybuffernd_new_bboxes.rcbuffer->pybuffer.shape[0]; __pyx_pybuffernd_new_bboxes.diminfo[1].strides = __pyx_pybuffernd_new_bboxes.rcbuffer->pybuffer.strides[1]; __pyx_pybuffernd_new_bboxes.diminfo[1].shape = __pyx_pybuffernd_new_bboxes.rcbuffer->pybuffer.shape[1];
-  {
-    __Pyx_BufFmt_StackElem __pyx_stack[1];
-    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_bboxes.rcbuffer->pybuffer, (PyObject*)__pyx_v_bboxes, &__Pyx_TypeInfo_nn___pyx_t_5numpy_int_t, PyBUF_FORMAT| PyBUF_STRIDES, 2, 0, __pyx_stack) == -1)) __PYX_ERR(0, 173, __pyx_L1_error)
-  }
-  __pyx_pybuffernd_bboxes.diminfo[0].strides = __pyx_pybuffernd_bboxes.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_bboxes.diminfo[0].shape = __pyx_pybuffernd_bboxes.rcbuffer->pybuffer.shape[0]; __pyx_pybuffernd_bboxes.diminfo[1].strides = __pyx_pybuffernd_bboxes.rcbuffer->pybuffer.strides[1]; __pyx_pybuffernd_bboxes.diminfo[1].shape = __pyx_pybuffernd_bboxes.rcbuffer->pybuffer.shape[1];
-
-  /* "argos/cutility.pyx":197
- *         ``new_bboxes[ii]`` and ``bboxes[jj]``.
- *      """
- *     cdef np.ndarray dist = np.zeros((new_bboxes.shape[0], bboxes.shape[0]),             # <<<<<<<<<<<<<<
- *                                     dtype=np.float)
- *     cdef np.ndarray centers = np.zeros((bboxes.shape[0], 2), dtype=np.float)
- */
-  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 197, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_zeros); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 197, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyInt_From_Py_intptr_t((__pyx_v_new_bboxes->dimensions[0])); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 197, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_3 = __Pyx_PyInt_From_Py_intptr_t((__pyx_v_bboxes->dimensions[0])); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 197, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_4 = PyTuple_New(2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 197, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __Pyx_GIVEREF(__pyx_t_1);
-  PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_1);
-  __Pyx_GIVEREF(__pyx_t_3);
-  PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_3);
-  __pyx_t_1 = 0;
-  __pyx_t_3 = 0;
-  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 197, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_GIVEREF(__pyx_t_4);
-  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_4);
-  __pyx_t_4 = 0;
-
-  /* "argos/cutility.pyx":198
- *      """
- *     cdef np.ndarray dist = np.zeros((new_bboxes.shape[0], bboxes.shape[0]),
- *                                     dtype=np.float)             # <<<<<<<<<<<<<<
- *     cdef np.ndarray centers = np.zeros((bboxes.shape[0], 2), dtype=np.float)
- *     cdef np.ndarray new_centers = np.zeros((new_bboxes.shape[0], 2), dtype=np.float)
- */
-  __pyx_t_4 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 198, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 198, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_float); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 198, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_dtype, __pyx_t_5) < 0) __PYX_ERR(0, 198, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-
-  /* "argos/cutility.pyx":197
- *         ``new_bboxes[ii]`` and ``bboxes[jj]``.
- *      """
- *     cdef np.ndarray dist = np.zeros((new_bboxes.shape[0], bboxes.shape[0]),             # <<<<<<<<<<<<<<
- *                                     dtype=np.float)
- *     cdef np.ndarray centers = np.zeros((bboxes.shape[0], 2), dtype=np.float)
- */
-  __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_3, __pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 197, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  if (!(likely(((__pyx_t_5) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_5, __pyx_ptype_5numpy_ndarray))))) __PYX_ERR(0, 197, __pyx_L1_error)
-  __pyx_v_dist = ((PyArrayObject *)__pyx_t_5);
-  __pyx_t_5 = 0;
-
-  /* "argos/cutility.pyx":199
- *     cdef np.ndarray dist = np.zeros((new_bboxes.shape[0], bboxes.shape[0]),
- *                                     dtype=np.float)
- *     cdef np.ndarray centers = np.zeros((bboxes.shape[0], 2), dtype=np.float)             # <<<<<<<<<<<<<<
- *     cdef np.ndarray new_centers = np.zeros((new_bboxes.shape[0], 2), dtype=np.float)
- *     if metric == DistanceMetric.euclidean:
- */
-  __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_np); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 199, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_zeros); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 199, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  __pyx_t_5 = __Pyx_PyInt_From_Py_intptr_t((__pyx_v_bboxes->dimensions[0])); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 199, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 199, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_GIVEREF(__pyx_t_5);
-  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_5);
-  __Pyx_INCREF(__pyx_int_2);
-  __Pyx_GIVEREF(__pyx_int_2);
-  PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_int_2);
-  __pyx_t_5 = 0;
-  __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 199, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  __Pyx_GIVEREF(__pyx_t_3);
-  PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_3);
-  __pyx_t_3 = 0;
-  __pyx_t_3 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 199, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 199, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_float); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 199, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_dtype, __pyx_t_1) < 0) __PYX_ERR(0, 199, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_5, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 199, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (!(likely(((__pyx_t_1) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_1, __pyx_ptype_5numpy_ndarray))))) __PYX_ERR(0, 199, __pyx_L1_error)
-  __pyx_v_centers = ((PyArrayObject *)__pyx_t_1);
-  __pyx_t_1 = 0;
-
-  /* "argos/cutility.pyx":200
- *                                     dtype=np.float)
- *     cdef np.ndarray centers = np.zeros((bboxes.shape[0], 2), dtype=np.float)
- *     cdef np.ndarray new_centers = np.zeros((new_bboxes.shape[0], 2), dtype=np.float)             # <<<<<<<<<<<<<<
- *     if metric == DistanceMetric.euclidean:
- *         centers[:, :] = bboxes[:, :2] + bboxes[:, 2:] * 0.5
- */
-  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 200, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_zeros); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 200, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyInt_From_Py_intptr_t((__pyx_v_new_bboxes->dimensions[0])); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 200, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_5 = PyTuple_New(2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 200, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  __Pyx_GIVEREF(__pyx_t_1);
-  PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_1);
-  __Pyx_INCREF(__pyx_int_2);
-  __Pyx_GIVEREF(__pyx_int_2);
-  PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_int_2);
-  __pyx_t_1 = 0;
-  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 200, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_GIVEREF(__pyx_t_5);
-  PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_5);
-  __pyx_t_5 = 0;
-  __pyx_t_5 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 200, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_np); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 200, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_float); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 200, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_dtype, __pyx_t_2) < 0) __PYX_ERR(0, 200, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_1, __pyx_t_5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 200, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) __PYX_ERR(0, 200, __pyx_L1_error)
-  __pyx_v_new_centers = ((PyArrayObject *)__pyx_t_2);
-  __pyx_t_2 = 0;
-
-  /* "argos/cutility.pyx":201
- *     cdef np.ndarray centers = np.zeros((bboxes.shape[0], 2), dtype=np.float)
- *     cdef np.ndarray new_centers = np.zeros((new_bboxes.shape[0], 2), dtype=np.float)
- *     if metric == DistanceMetric.euclidean:             # <<<<<<<<<<<<<<
- *         centers[:, :] = bboxes[:, :2] + bboxes[:, 2:] * 0.5
- *         new_centers = new_bboxes[:, :2] + new_bboxes[:, 2:] * 0.5
- */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_DistanceMetric); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 201, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_euclidean); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 201, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = PyObject_RichCompare(__pyx_v_metric, __pyx_t_5, Py_EQ); __Pyx_XGOTREF(__pyx_t_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 201, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 201, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (__pyx_t_6) {
-
-    /* "argos/cutility.pyx":202
- *     cdef np.ndarray new_centers = np.zeros((new_bboxes.shape[0], 2), dtype=np.float)
- *     if metric == DistanceMetric.euclidean:
- *         centers[:, :] = bboxes[:, :2] + bboxes[:, 2:] * 0.5             # <<<<<<<<<<<<<<
- *         new_centers = new_bboxes[:, :2] + new_bboxes[:, 2:] * 0.5
- *         for ii in range(new_bboxes.shape[0]):
- */
-    __pyx_t_2 = __Pyx_PyObject_GetItem(((PyObject *)__pyx_v_bboxes), __pyx_tuple__8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 202, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_5 = __Pyx_PyObject_GetItem(((PyObject *)__pyx_v_bboxes), __pyx_tuple__9); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 202, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_1 = PyNumber_Multiply(__pyx_t_5, __pyx_float_0_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 202, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __pyx_t_5 = PyNumber_Add(__pyx_t_2, __pyx_t_1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 202, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_5);
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    if (unlikely(PyObject_SetItem(((PyObject *)__pyx_v_centers), __pyx_tuple__10, __pyx_t_5) < 0)) __PYX_ERR(0, 202, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-
-    /* "argos/cutility.pyx":203
- *     if metric == DistanceMetric.euclidean:
- *         centers[:, :] = bboxes[:, :2] + bboxes[:, 2:] * 0.5
- *         new_centers = new_bboxes[:, :2] + new_bboxes[:, 2:] * 0.5             # <<<<<<<<<<<<<<
- *         for ii in range(new_bboxes.shape[0]):
- *             for jj in range(bboxes.shape[0]):
- */
-    __pyx_t_5 = __Pyx_PyObject_GetItem(((PyObject *)__pyx_v_new_bboxes), __pyx_tuple__8); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 203, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_1 = __Pyx_PyObject_GetItem(((PyObject *)__pyx_v_new_bboxes), __pyx_tuple__9); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 203, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_2 = PyNumber_Multiply(__pyx_t_1, __pyx_float_0_5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 203, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __pyx_t_1 = PyNumber_Add(__pyx_t_5, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 203, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    if (!(likely(((__pyx_t_1) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_1, __pyx_ptype_5numpy_ndarray))))) __PYX_ERR(0, 203, __pyx_L1_error)
-    __Pyx_DECREF_SET(__pyx_v_new_centers, ((PyArrayObject *)__pyx_t_1));
-    __pyx_t_1 = 0;
-
-    /* "argos/cutility.pyx":204
- *         centers[:, :] = bboxes[:, :2] + bboxes[:, 2:] * 0.5
- *         new_centers = new_bboxes[:, :2] + new_bboxes[:, 2:] * 0.5
- *         for ii in range(new_bboxes.shape[0]):             # <<<<<<<<<<<<<<
- *             for jj in range(bboxes.shape[0]):
- *                 dist[ii, jj] = np.sum((new_centers[ii] - centers[jj]) ** 2)
- */
-    __pyx_t_7 = (__pyx_v_new_bboxes->dimensions[0]);
-    __pyx_t_8 = __pyx_t_7;
-    for (__pyx_t_9 = 0; __pyx_t_9 < __pyx_t_8; __pyx_t_9+=1) {
-      __pyx_v_ii = __pyx_t_9;
-
-      /* "argos/cutility.pyx":205
- *         new_centers = new_bboxes[:, :2] + new_bboxes[:, 2:] * 0.5
- *         for ii in range(new_bboxes.shape[0]):
- *             for jj in range(bboxes.shape[0]):             # <<<<<<<<<<<<<<
- *                 dist[ii, jj] = np.sum((new_centers[ii] - centers[jj]) ** 2)
- *     elif metric == DistanceMetric.iou:
- */
-      __pyx_t_10 = (__pyx_v_bboxes->dimensions[0]);
-      __pyx_t_11 = __pyx_t_10;
-      for (__pyx_t_12 = 0; __pyx_t_12 < __pyx_t_11; __pyx_t_12+=1) {
-        __pyx_v_jj = __pyx_t_12;
-
-        /* "argos/cutility.pyx":206
- *         for ii in range(new_bboxes.shape[0]):
- *             for jj in range(bboxes.shape[0]):
- *                 dist[ii, jj] = np.sum((new_centers[ii] - centers[jj]) ** 2)             # <<<<<<<<<<<<<<
- *     elif metric == DistanceMetric.iou:
- *         if boxtype == OutlineStyle.bbox:  # This can be handled efficiently
- */
-        __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 206, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_2);
-        __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_sum); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 206, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_5);
-        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-        __pyx_t_2 = __Pyx_GetItemInt(((PyObject *)__pyx_v_new_centers), __pyx_v_ii, npy_intp, 1, __Pyx_PyInt_From_Py_intptr_t, 0, 0, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 206, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_2);
-        __pyx_t_3 = __Pyx_GetItemInt(((PyObject *)__pyx_v_centers), __pyx_v_jj, npy_intp, 1, __Pyx_PyInt_From_Py_intptr_t, 0, 0, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 206, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_3);
-        __pyx_t_4 = PyNumber_Subtract(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 206, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_4);
-        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-        __pyx_t_3 = PyNumber_Power(__pyx_t_4, __pyx_int_2, Py_None); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 206, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_3);
-        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-        __pyx_t_4 = NULL;
-        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
-          __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_5);
-          if (likely(__pyx_t_4)) {
-            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
-            __Pyx_INCREF(__pyx_t_4);
-            __Pyx_INCREF(function);
-            __Pyx_DECREF_SET(__pyx_t_5, function);
-          }
-        }
-        __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_4, __pyx_t_3) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_3);
-        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-        if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 206, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_1);
-        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-        __pyx_t_5 = __Pyx_PyInt_From_Py_intptr_t(__pyx_v_ii); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 206, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_5);
-        __pyx_t_3 = __Pyx_PyInt_From_Py_intptr_t(__pyx_v_jj); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 206, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_3);
-        __pyx_t_4 = PyTuple_New(2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 206, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_4);
-        __Pyx_GIVEREF(__pyx_t_5);
-        PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_5);
-        __Pyx_GIVEREF(__pyx_t_3);
-        PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_3);
-        __pyx_t_5 = 0;
-        __pyx_t_3 = 0;
-        if (unlikely(PyObject_SetItem(((PyObject *)__pyx_v_dist), __pyx_t_4, __pyx_t_1) < 0)) __PYX_ERR(0, 206, __pyx_L1_error)
-        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-      }
-    }
-
-    /* "argos/cutility.pyx":201
- *     cdef np.ndarray centers = np.zeros((bboxes.shape[0], 2), dtype=np.float)
- *     cdef np.ndarray new_centers = np.zeros((new_bboxes.shape[0], 2), dtype=np.float)
- *     if metric == DistanceMetric.euclidean:             # <<<<<<<<<<<<<<
- *         centers[:, :] = bboxes[:, :2] + bboxes[:, 2:] * 0.5
- *         new_centers = new_bboxes[:, :2] + new_bboxes[:, 2:] * 0.5
- */
-    goto __pyx_L3;
-  }
-
-  /* "argos/cutility.pyx":207
- *             for jj in range(bboxes.shape[0]):
- *                 dist[ii, jj] = np.sum((new_centers[ii] - centers[jj]) ** 2)
- *     elif metric == DistanceMetric.iou:             # <<<<<<<<<<<<<<
- *         if boxtype == OutlineStyle.bbox:  # This can be handled efficiently
- *             for ii in range(new_bboxes.shape[0]):
- */
-  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_DistanceMetric); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 207, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_iou); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 207, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = PyObject_RichCompare(__pyx_v_metric, __pyx_t_4, Py_EQ); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 207, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 207, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  if (__pyx_t_6) {
-
-    /* "argos/cutility.pyx":208
- *                 dist[ii, jj] = np.sum((new_centers[ii] - centers[jj]) ** 2)
- *     elif metric == DistanceMetric.iou:
- *         if boxtype == OutlineStyle.bbox:  # This can be handled efficiently             # <<<<<<<<<<<<<<
- *             for ii in range(new_bboxes.shape[0]):
- *                 for jj in range(bboxes.shape[0]):
+/* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":284
+ * 
+ *         @property
+ *         cdef inline char* data(self) nogil:             # <<<<<<<<<<<<<<
+ *             """The pointer to the data buffer as a char*.
+ *             This is provided for legacy reasons to avoid direct struct field access.
  */
-    __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_OutlineStyle); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 208, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_bbox); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 208, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_4);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __pyx_t_1 = PyObject_RichCompare(__pyx_v_boxtype, __pyx_t_4, Py_EQ); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 208, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 208, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    if (likely(__pyx_t_6)) {
-
-      /* "argos/cutility.pyx":209
- *     elif metric == DistanceMetric.iou:
- *         if boxtype == OutlineStyle.bbox:  # This can be handled efficiently
- *             for ii in range(new_bboxes.shape[0]):             # <<<<<<<<<<<<<<
- *                 for jj in range(bboxes.shape[0]):
- *                     dist[ii, jj] = 1.0 - rect_iou(bboxes[jj], new_bboxes[ii])
- */
-      __pyx_t_7 = (__pyx_v_new_bboxes->dimensions[0]);
-      __pyx_t_8 = __pyx_t_7;
-      for (__pyx_t_9 = 0; __pyx_t_9 < __pyx_t_8; __pyx_t_9+=1) {
-        __pyx_v_ii = __pyx_t_9;
-
-        /* "argos/cutility.pyx":210
- *         if boxtype == OutlineStyle.bbox:  # This can be handled efficiently
- *             for ii in range(new_bboxes.shape[0]):
- *                 for jj in range(bboxes.shape[0]):             # <<<<<<<<<<<<<<
- *                     dist[ii, jj] = 1.0 - rect_iou(bboxes[jj], new_bboxes[ii])
- *         else:
- */
-        __pyx_t_10 = (__pyx_v_bboxes->dimensions[0]);
-        __pyx_t_11 = __pyx_t_10;
-        for (__pyx_t_12 = 0; __pyx_t_12 < __pyx_t_11; __pyx_t_12+=1) {
-          __pyx_v_jj = __pyx_t_12;
-
-          /* "argos/cutility.pyx":211
- *             for ii in range(new_bboxes.shape[0]):
- *                 for jj in range(bboxes.shape[0]):
- *                     dist[ii, jj] = 1.0 - rect_iou(bboxes[jj], new_bboxes[ii])             # <<<<<<<<<<<<<<
- *         else:
- *             raise NotImplementedError(
- */
-          __pyx_t_1 = __Pyx_GetItemInt(((PyObject *)__pyx_v_bboxes), __pyx_v_jj, npy_intp, 1, __Pyx_PyInt_From_Py_intptr_t, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 211, __pyx_L1_error)
-          __Pyx_GOTREF(__pyx_t_1);
-          if (!(likely(((__pyx_t_1) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_1, __pyx_ptype_5numpy_ndarray))))) __PYX_ERR(0, 211, __pyx_L1_error)
-          __pyx_t_4 = __Pyx_GetItemInt(((PyObject *)__pyx_v_new_bboxes), __pyx_v_ii, npy_intp, 1, __Pyx_PyInt_From_Py_intptr_t, 0, 0, 1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 211, __pyx_L1_error)
-          __Pyx_GOTREF(__pyx_t_4);
-          if (!(likely(((__pyx_t_4) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_4, __pyx_ptype_5numpy_ndarray))))) __PYX_ERR(0, 211, __pyx_L1_error)
-          __pyx_t_3 = PyFloat_FromDouble((1.0 - __pyx_f_5argos_8cutility_rect_iou(((PyArrayObject *)__pyx_t_1), ((PyArrayObject *)__pyx_t_4), 0))); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 211, __pyx_L1_error)
-          __Pyx_GOTREF(__pyx_t_3);
-          __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-          __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-          __pyx_t_4 = __Pyx_PyInt_From_Py_intptr_t(__pyx_v_ii); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 211, __pyx_L1_error)
-          __Pyx_GOTREF(__pyx_t_4);
-          __pyx_t_1 = __Pyx_PyInt_From_Py_intptr_t(__pyx_v_jj); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 211, __pyx_L1_error)
-          __Pyx_GOTREF(__pyx_t_1);
-          __pyx_t_5 = PyTuple_New(2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 211, __pyx_L1_error)
-          __Pyx_GOTREF(__pyx_t_5);
-          __Pyx_GIVEREF(__pyx_t_4);
-          PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4);
-          __Pyx_GIVEREF(__pyx_t_1);
-          PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_t_1);
-          __pyx_t_4 = 0;
-          __pyx_t_1 = 0;
-          if (unlikely(PyObject_SetItem(((PyObject *)__pyx_v_dist), __pyx_t_5, __pyx_t_3) < 0)) __PYX_ERR(0, 211, __pyx_L1_error)
-          __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-          __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-        }
-      }
 
-      /* "argos/cutility.pyx":208
- *                 dist[ii, jj] = np.sum((new_centers[ii] - centers[jj]) ** 2)
- *     elif metric == DistanceMetric.iou:
- *         if boxtype == OutlineStyle.bbox:  # This can be handled efficiently             # <<<<<<<<<<<<<<
- *             for ii in range(new_bboxes.shape[0]):
- *                 for jj in range(bboxes.shape[0]):
- */
-      goto __pyx_L8;
-    }
-
-    /* "argos/cutility.pyx":213
- *                     dist[ii, jj] = 1.0 - rect_iou(bboxes[jj], new_bboxes[ii])
- *         else:
- *             raise NotImplementedError(             # <<<<<<<<<<<<<<
- *                 'Only handling axis-aligned bounding boxes')
- *     elif metric == DistanceMetric.ios:
- */
-    /*else*/ {
-      __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_NotImplementedError, __pyx_tuple__11, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 213, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_3);
-      __Pyx_Raise(__pyx_t_3, 0, 0, 0);
-      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __PYX_ERR(0, 213, __pyx_L1_error)
-    }
-    __pyx_L8:;
-
-    /* "argos/cutility.pyx":207
- *             for jj in range(bboxes.shape[0]):
- *                 dist[ii, jj] = np.sum((new_centers[ii] - centers[jj]) ** 2)
- *     elif metric == DistanceMetric.iou:             # <<<<<<<<<<<<<<
- *         if boxtype == OutlineStyle.bbox:  # This can be handled efficiently
- *             for ii in range(new_bboxes.shape[0]):
- */
-    goto __pyx_L3;
-  }
-
-  /* "argos/cutility.pyx":215
- *             raise NotImplementedError(
- *                 'Only handling axis-aligned bounding boxes')
- *     elif metric == DistanceMetric.ios:             # <<<<<<<<<<<<<<
- *         if boxtype == OutlineStyle.bbox:
- *             for ii in range(new_bboxes.shape[0]):
- */
-  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_DistanceMetric); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 215, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_ios); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 215, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_3 = PyObject_RichCompare(__pyx_v_metric, __pyx_t_5, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 215, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 215, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (likely(__pyx_t_6)) {
-
-    /* "argos/cutility.pyx":216
- *                 'Only handling axis-aligned bounding boxes')
- *     elif metric == DistanceMetric.ios:
- *         if boxtype == OutlineStyle.bbox:             # <<<<<<<<<<<<<<
- *             for ii in range(new_bboxes.shape[0]):
- *                 for jj in range(bboxes.shape[0]):
- */
-    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_OutlineStyle); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 216, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_bbox); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 216, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_5);
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __pyx_t_3 = PyObject_RichCompare(__pyx_v_boxtype, __pyx_t_5, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 216, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 216, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    if (likely(__pyx_t_6)) {
-
-      /* "argos/cutility.pyx":217
- *     elif metric == DistanceMetric.ios:
- *         if boxtype == OutlineStyle.bbox:
- *             for ii in range(new_bboxes.shape[0]):             # <<<<<<<<<<<<<<
- *                 for jj in range(bboxes.shape[0]):
- *                     dist[ii, jj] = 1.0 - rect_ios(bboxes[jj], new_bboxes[ii])
- */
-      __pyx_t_7 = (__pyx_v_new_bboxes->dimensions[0]);
-      __pyx_t_8 = __pyx_t_7;
-      for (__pyx_t_9 = 0; __pyx_t_9 < __pyx_t_8; __pyx_t_9+=1) {
-        __pyx_v_ii = __pyx_t_9;
-
-        /* "argos/cutility.pyx":218
- *         if boxtype == OutlineStyle.bbox:
- *             for ii in range(new_bboxes.shape[0]):
- *                 for jj in range(bboxes.shape[0]):             # <<<<<<<<<<<<<<
- *                     dist[ii, jj] = 1.0 - rect_ios(bboxes[jj], new_bboxes[ii])
- *         else:
- */
-        __pyx_t_10 = (__pyx_v_bboxes->dimensions[0]);
-        __pyx_t_11 = __pyx_t_10;
-        for (__pyx_t_12 = 0; __pyx_t_12 < __pyx_t_11; __pyx_t_12+=1) {
-          __pyx_v_jj = __pyx_t_12;
-
-          /* "argos/cutility.pyx":219
- *             for ii in range(new_bboxes.shape[0]):
- *                 for jj in range(bboxes.shape[0]):
- *                     dist[ii, jj] = 1.0 - rect_ios(bboxes[jj], new_bboxes[ii])             # <<<<<<<<<<<<<<
- *         else:
- *             raise NotImplementedError(
- */
-          __pyx_t_3 = __Pyx_GetItemInt(((PyObject *)__pyx_v_bboxes), __pyx_v_jj, npy_intp, 1, __Pyx_PyInt_From_Py_intptr_t, 0, 0, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 219, __pyx_L1_error)
-          __Pyx_GOTREF(__pyx_t_3);
-          if (!(likely(((__pyx_t_3) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_3, __pyx_ptype_5numpy_ndarray))))) __PYX_ERR(0, 219, __pyx_L1_error)
-          __pyx_t_5 = __Pyx_GetItemInt(((PyObject *)__pyx_v_new_bboxes), __pyx_v_ii, npy_intp, 1, __Pyx_PyInt_From_Py_intptr_t, 0, 0, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 219, __pyx_L1_error)
-          __Pyx_GOTREF(__pyx_t_5);
-          if (!(likely(((__pyx_t_5) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_5, __pyx_ptype_5numpy_ndarray))))) __PYX_ERR(0, 219, __pyx_L1_error)
-          __pyx_t_1 = PyFloat_FromDouble((1.0 - __pyx_f_5argos_8cutility_rect_ios(((PyArrayObject *)__pyx_t_3), ((PyArrayObject *)__pyx_t_5), 0))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 219, __pyx_L1_error)
-          __Pyx_GOTREF(__pyx_t_1);
-          __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-          __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-          __pyx_t_5 = __Pyx_PyInt_From_Py_intptr_t(__pyx_v_ii); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 219, __pyx_L1_error)
-          __Pyx_GOTREF(__pyx_t_5);
-          __pyx_t_3 = __Pyx_PyInt_From_Py_intptr_t(__pyx_v_jj); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 219, __pyx_L1_error)
-          __Pyx_GOTREF(__pyx_t_3);
-          __pyx_t_4 = PyTuple_New(2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 219, __pyx_L1_error)
-          __Pyx_GOTREF(__pyx_t_4);
-          __Pyx_GIVEREF(__pyx_t_5);
-          PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_5);
-          __Pyx_GIVEREF(__pyx_t_3);
-          PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_3);
-          __pyx_t_5 = 0;
-          __pyx_t_3 = 0;
-          if (unlikely(PyObject_SetItem(((PyObject *)__pyx_v_dist), __pyx_t_4, __pyx_t_1) < 0)) __PYX_ERR(0, 219, __pyx_L1_error)
-          __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-          __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-        }
-      }
-
-      /* "argos/cutility.pyx":216
- *                 'Only handling axis-aligned bounding boxes')
- *     elif metric == DistanceMetric.ios:
- *         if boxtype == OutlineStyle.bbox:             # <<<<<<<<<<<<<<
- *             for ii in range(new_bboxes.shape[0]):
- *                 for jj in range(bboxes.shape[0]):
- */
-      goto __pyx_L13;
-    }
+static CYTHON_INLINE char *__pyx_f_5numpy_7ndarray_4data_data(PyArrayObject *__pyx_v_self) {
+  char *__pyx_r;
 
-    /* "argos/cutility.pyx":221
- *                     dist[ii, jj] = 1.0 - rect_ios(bboxes[jj], new_bboxes[ii])
- *         else:
- *             raise NotImplementedError(             # <<<<<<<<<<<<<<
- *                 'Only handling axis-aligned bounding boxes')
- *     else:
- */
-    /*else*/ {
-      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_NotImplementedError, __pyx_tuple__11, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 221, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_1);
-      __Pyx_Raise(__pyx_t_1, 0, 0, 0);
-      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-      __PYX_ERR(0, 221, __pyx_L1_error)
-    }
-    __pyx_L13:;
-
-    /* "argos/cutility.pyx":215
- *             raise NotImplementedError(
- *                 'Only handling axis-aligned bounding boxes')
- *     elif metric == DistanceMetric.ios:             # <<<<<<<<<<<<<<
- *         if boxtype == OutlineStyle.bbox:
- *             for ii in range(new_bboxes.shape[0]):
- */
-    goto __pyx_L3;
-  }
-
-  /* "argos/cutility.pyx":224
- *                 'Only handling axis-aligned bounding boxes')
- *     else:
- *         raise NotImplementedError(f'Unknown metric {metric}')             # <<<<<<<<<<<<<<
- *     return dist
- */
-  /*else*/ {
-    __pyx_t_1 = __Pyx_PyObject_FormatSimple(__pyx_v_metric, __pyx_empty_unicode); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 224, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_4 = __Pyx_PyUnicode_Concat(__pyx_kp_u_Unknown_metric, __pyx_t_1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 224, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_4);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_NotImplementedError, __pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 224, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __PYX_ERR(0, 224, __pyx_L1_error)
-  }
-  __pyx_L3:;
-
-  /* "argos/cutility.pyx":225
- *     else:
- *         raise NotImplementedError(f'Unknown metric {metric}')
- *     return dist             # <<<<<<<<<<<<<<
+  /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":290
+ *             of `PyArray_DATA()` instead, which returns a 'void*'.
+ *             """
+ *             return PyArray_BYTES(self)             # <<<<<<<<<<<<<<
+ * 
+ *     ctypedef unsigned char      npy_bool
  */
-  __Pyx_XDECREF(((PyObject *)__pyx_r));
-  __Pyx_INCREF(((PyObject *)__pyx_v_dist));
-  __pyx_r = ((PyArrayObject *)__pyx_v_dist);
+  __pyx_r = PyArray_BYTES(__pyx_v_self);
   goto __pyx_L0;
 
-  /* "argos/cutility.pyx":173
- * # @cython.boundscheck(False) # turn off bounds-checking for entire function
- * @cython.wraparound(False)  # turn off negative index wrapping for entire function
- * cpdef np.ndarray[np.float_t, ndim=2] pairwise_distance(np.ndarray[np.int_t, ndim=2] new_bboxes, np.ndarray[np.int_t, ndim=2] bboxes,             # <<<<<<<<<<<<<<
- *                       object boxtype, object metric):
- *     """Takes two lists of boxes and computes the distance between every possible
+  /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":284
+ * 
+ *         @property
+ *         cdef inline char* data(self) nogil:             # <<<<<<<<<<<<<<
+ *             """The pointer to the data buffer as a char*.
+ *             This is provided for legacy reasons to avoid direct struct field access.
  */
 
   /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_XDECREF(__pyx_t_2);
-  __Pyx_XDECREF(__pyx_t_3);
-  __Pyx_XDECREF(__pyx_t_4);
-  __Pyx_XDECREF(__pyx_t_5);
-  { PyObject *__pyx_type, *__pyx_value, *__pyx_tb;
-    __Pyx_PyThreadState_declare
-    __Pyx_PyThreadState_assign
-    __Pyx_ErrFetch(&__pyx_type, &__pyx_value, &__pyx_tb);
-    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_bboxes.rcbuffer->pybuffer);
-    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_new_bboxes.rcbuffer->pybuffer);
-  __Pyx_ErrRestore(__pyx_type, __pyx_value, __pyx_tb);}
-  __Pyx_AddTraceback("argos.cutility.pairwise_distance", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = 0;
-  goto __pyx_L2;
   __pyx_L0:;
-  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_bboxes.rcbuffer->pybuffer);
-  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_new_bboxes.rcbuffer->pybuffer);
-  __pyx_L2:;
-  __Pyx_XDECREF((PyObject *)__pyx_v_dist);
-  __Pyx_XDECREF((PyObject *)__pyx_v_centers);
-  __Pyx_XDECREF((PyObject *)__pyx_v_new_centers);
-  __Pyx_XGIVEREF((PyObject *)__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* Python wrapper */
-static PyObject *__pyx_pw_5argos_8cutility_15pairwise_distance(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static char __pyx_doc_5argos_8cutility_14pairwise_distance[] = "Takes two lists of boxes and computes the distance between every possible\n    pair.\n\n    Parameters\n    ----------\n    new_bboxes: np.ndarray\n       Array of bounding boxes, each row as (x, y, w, h)\n    bboxes: np.ndarray\n       Array of bounding boxes, each row as (x, y, w, h)\n    boxtype: OutlineStyle\n       OutlineStyle.bbox for axis aligned rectangle bounding box or\n       OulineStyle.minrect for minimum area rotated rectangle\n    metric: DistanceMetric\n       iou or euclidean. When euclidean, the squared Euclidean distance is\n       used (calculating square root is expensive and unnecessary. If iou, use\n       the area of intersection divided by the area of union.\n    Returns\n    --------\n    np.ndarray\n        row ``ii``, column ``jj`` contains the computed distance `between\n        ``new_bboxes[ii]`` and ``bboxes[jj]``.\n     ";
-static PyObject *__pyx_pw_5argos_8cutility_15pairwise_distance(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
-  PyArrayObject *__pyx_v_new_bboxes = 0;
-  PyArrayObject *__pyx_v_bboxes = 0;
-  PyObject *__pyx_v_boxtype = 0;
-  PyObject *__pyx_v_metric = 0;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("pairwise_distance (wrapper)", 0);
-  {
-    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_new_bboxes,&__pyx_n_s_bboxes,&__pyx_n_s_boxtype,&__pyx_n_s_metric,0};
-    PyObject* values[4] = {0,0,0,0};
-    if (unlikely(__pyx_kwds)) {
-      Py_ssize_t kw_args;
-      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
-      switch (pos_args) {
-        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
-        CYTHON_FALLTHROUGH;
-        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
-        CYTHON_FALLTHROUGH;
-        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
-        CYTHON_FALLTHROUGH;
-        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
-        CYTHON_FALLTHROUGH;
-        case  0: break;
-        default: goto __pyx_L5_argtuple_error;
-      }
-      kw_args = PyDict_Size(__pyx_kwds);
-      switch (pos_args) {
-        case  0:
-        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_new_bboxes)) != 0)) kw_args--;
-        else goto __pyx_L5_argtuple_error;
-        CYTHON_FALLTHROUGH;
-        case  1:
-        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_bboxes)) != 0)) kw_args--;
-        else {
-          __Pyx_RaiseArgtupleInvalid("pairwise_distance", 1, 4, 4, 1); __PYX_ERR(0, 173, __pyx_L3_error)
-        }
-        CYTHON_FALLTHROUGH;
-        case  2:
-        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_boxtype)) != 0)) kw_args--;
-        else {
-          __Pyx_RaiseArgtupleInvalid("pairwise_distance", 1, 4, 4, 2); __PYX_ERR(0, 173, __pyx_L3_error)
-        }
-        CYTHON_FALLTHROUGH;
-        case  3:
-        if (likely((values[3] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_metric)) != 0)) kw_args--;
-        else {
-          __Pyx_RaiseArgtupleInvalid("pairwise_distance", 1, 4, 4, 3); __PYX_ERR(0, 173, __pyx_L3_error)
-        }
-      }
-      if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "pairwise_distance") < 0)) __PYX_ERR(0, 173, __pyx_L3_error)
-      }
-    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
-      goto __pyx_L5_argtuple_error;
-    } else {
-      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
-      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
-      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
-      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
-    }
-    __pyx_v_new_bboxes = ((PyArrayObject *)values[0]);
-    __pyx_v_bboxes = ((PyArrayObject *)values[1]);
-    __pyx_v_boxtype = values[2];
-    __pyx_v_metric = values[3];
-  }
-  goto __pyx_L4_argument_unpacking_done;
-  __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("pairwise_distance", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 173, __pyx_L3_error)
-  __pyx_L3_error:;
-  __Pyx_AddTraceback("argos.cutility.pairwise_distance", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __Pyx_RefNannyFinishContext();
-  return NULL;
-  __pyx_L4_argument_unpacking_done:;
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_new_bboxes), __pyx_ptype_5numpy_ndarray, 1, "new_bboxes", 0))) __PYX_ERR(0, 173, __pyx_L1_error)
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_bboxes), __pyx_ptype_5numpy_ndarray, 1, "bboxes", 0))) __PYX_ERR(0, 173, __pyx_L1_error)
-  __pyx_r = __pyx_pf_5argos_8cutility_14pairwise_distance(__pyx_self, __pyx_v_new_bboxes, __pyx_v_bboxes, __pyx_v_boxtype, __pyx_v_metric);
-
-  /* function exit code */
-  goto __pyx_L0;
-  __pyx_L1_error:;
-  __pyx_r = NULL;
-  __pyx_L0:;
-  __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_5argos_8cutility_14pairwise_distance(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_new_bboxes, PyArrayObject *__pyx_v_bboxes, PyObject *__pyx_v_boxtype, PyObject *__pyx_v_metric) {
-  __Pyx_LocalBuf_ND __pyx_pybuffernd_bboxes;
-  __Pyx_Buffer __pyx_pybuffer_bboxes;
-  __Pyx_LocalBuf_ND __pyx_pybuffernd_new_bboxes;
-  __Pyx_Buffer __pyx_pybuffer_new_bboxes;
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("pairwise_distance", 0);
-  __pyx_pybuffer_new_bboxes.pybuffer.buf = NULL;
-  __pyx_pybuffer_new_bboxes.refcount = 0;
-  __pyx_pybuffernd_new_bboxes.data = NULL;
-  __pyx_pybuffernd_new_bboxes.rcbuffer = &__pyx_pybuffer_new_bboxes;
-  __pyx_pybuffer_bboxes.pybuffer.buf = NULL;
-  __pyx_pybuffer_bboxes.refcount = 0;
-  __pyx_pybuffernd_bboxes.data = NULL;
-  __pyx_pybuffernd_bboxes.rcbuffer = &__pyx_pybuffer_bboxes;
-  {
-    __Pyx_BufFmt_StackElem __pyx_stack[1];
-    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_new_bboxes.rcbuffer->pybuffer, (PyObject*)__pyx_v_new_bboxes, &__Pyx_TypeInfo_nn___pyx_t_5numpy_int_t, PyBUF_FORMAT| PyBUF_STRIDES, 2, 0, __pyx_stack) == -1)) __PYX_ERR(0, 173, __pyx_L1_error)
-  }
-  __pyx_pybuffernd_new_bboxes.diminfo[0].strides = __pyx_pybuffernd_new_bboxes.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_new_bboxes.diminfo[0].shape = __pyx_pybuffernd_new_bboxes.rcbuffer->pybuffer.shape[0]; __pyx_pybuffernd_new_bboxes.diminfo[1].strides = __pyx_pybuffernd_new_bboxes.rcbuffer->pybuffer.strides[1]; __pyx_pybuffernd_new_bboxes.diminfo[1].shape = __pyx_pybuffernd_new_bboxes.rcbuffer->pybuffer.shape[1];
-  {
-    __Pyx_BufFmt_StackElem __pyx_stack[1];
-    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_bboxes.rcbuffer->pybuffer, (PyObject*)__pyx_v_bboxes, &__Pyx_TypeInfo_nn___pyx_t_5numpy_int_t, PyBUF_FORMAT| PyBUF_STRIDES, 2, 0, __pyx_stack) == -1)) __PYX_ERR(0, 173, __pyx_L1_error)
-  }
-  __pyx_pybuffernd_bboxes.diminfo[0].strides = __pyx_pybuffernd_bboxes.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_bboxes.diminfo[0].shape = __pyx_pybuffernd_bboxes.rcbuffer->pybuffer.shape[0]; __pyx_pybuffernd_bboxes.diminfo[1].strides = __pyx_pybuffernd_bboxes.rcbuffer->pybuffer.strides[1]; __pyx_pybuffernd_bboxes.diminfo[1].shape = __pyx_pybuffernd_bboxes.rcbuffer->pybuffer.shape[1];
-  __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = ((PyObject *)__pyx_f_5argos_8cutility_pairwise_distance(__pyx_v_new_bboxes, __pyx_v_bboxes, __pyx_v_boxtype, __pyx_v_metric, 0)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 173, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_r = __pyx_t_1;
-  __pyx_t_1 = 0;
-  goto __pyx_L0;
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  { PyObject *__pyx_type, *__pyx_value, *__pyx_tb;
-    __Pyx_PyThreadState_declare
-    __Pyx_PyThreadState_assign
-    __Pyx_ErrFetch(&__pyx_type, &__pyx_value, &__pyx_tb);
-    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_bboxes.rcbuffer->pybuffer);
-    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_new_bboxes.rcbuffer->pybuffer);
-  __Pyx_ErrRestore(__pyx_type, __pyx_value, __pyx_tb);}
-  __Pyx_AddTraceback("argos.cutility.pairwise_distance", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
-  goto __pyx_L2;
-  __pyx_L0:;
-  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_bboxes.rcbuffer->pybuffer);
-  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_new_bboxes.rcbuffer->pybuffer);
-  __pyx_L2:;
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":735
+/* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":773
  * ctypedef npy_cdouble     complex_t
  * 
  * cdef inline object PyArray_MultiIterNew1(a):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(1, <void*>a)
  * 
  */
 
 static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew1(PyObject *__pyx_v_a) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("PyArray_MultiIterNew1", 0);
+  __Pyx_RefNannySetupContext("PyArray_MultiIterNew1", 1);
 
-  /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":736
+  /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":774
  * 
  * cdef inline object PyArray_MultiIterNew1(a):
  *     return PyArray_MultiIterNew(1, <void*>a)             # <<<<<<<<<<<<<<
  * 
  * cdef inline object PyArray_MultiIterNew2(a, b):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = PyArray_MultiIterNew(1, ((void *)__pyx_v_a)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 736, __pyx_L1_error)
+  __pyx_t_1 = PyArray_MultiIterNew(1, ((void *)__pyx_v_a)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 774, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":735
+  /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":773
  * ctypedef npy_cdouble     complex_t
  * 
  * cdef inline object PyArray_MultiIterNew1(a):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(1, <void*>a)
  * 
  */
 
@@ -5281,46 +3527,46 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":738
+/* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":776
  *     return PyArray_MultiIterNew(1, <void*>a)
  * 
  * cdef inline object PyArray_MultiIterNew2(a, b):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)
  * 
  */
 
 static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew2(PyObject *__pyx_v_a, PyObject *__pyx_v_b) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("PyArray_MultiIterNew2", 0);
+  __Pyx_RefNannySetupContext("PyArray_MultiIterNew2", 1);
 
-  /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":739
+  /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":777
  * 
  * cdef inline object PyArray_MultiIterNew2(a, b):
  *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)             # <<<<<<<<<<<<<<
  * 
  * cdef inline object PyArray_MultiIterNew3(a, b, c):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = PyArray_MultiIterNew(2, ((void *)__pyx_v_a), ((void *)__pyx_v_b)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 739, __pyx_L1_error)
+  __pyx_t_1 = PyArray_MultiIterNew(2, ((void *)__pyx_v_a), ((void *)__pyx_v_b)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 777, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":738
+  /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":776
  *     return PyArray_MultiIterNew(1, <void*>a)
  * 
  * cdef inline object PyArray_MultiIterNew2(a, b):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)
  * 
  */
 
@@ -5331,46 +3577,46 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":741
+/* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":779
  *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)
  * 
  * cdef inline object PyArray_MultiIterNew3(a, b, c):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)
  * 
  */
 
 static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew3(PyObject *__pyx_v_a, PyObject *__pyx_v_b, PyObject *__pyx_v_c) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("PyArray_MultiIterNew3", 0);
+  __Pyx_RefNannySetupContext("PyArray_MultiIterNew3", 1);
 
-  /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":742
+  /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":780
  * 
  * cdef inline object PyArray_MultiIterNew3(a, b, c):
  *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)             # <<<<<<<<<<<<<<
  * 
  * cdef inline object PyArray_MultiIterNew4(a, b, c, d):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = PyArray_MultiIterNew(3, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 742, __pyx_L1_error)
+  __pyx_t_1 = PyArray_MultiIterNew(3, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 780, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":741
+  /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":779
  *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)
  * 
  * cdef inline object PyArray_MultiIterNew3(a, b, c):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)
  * 
  */
 
@@ -5381,46 +3627,46 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":744
+/* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":782
  *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)
  * 
  * cdef inline object PyArray_MultiIterNew4(a, b, c, d):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)
  * 
  */
 
 static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew4(PyObject *__pyx_v_a, PyObject *__pyx_v_b, PyObject *__pyx_v_c, PyObject *__pyx_v_d) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("PyArray_MultiIterNew4", 0);
+  __Pyx_RefNannySetupContext("PyArray_MultiIterNew4", 1);
 
-  /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":745
+  /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":783
  * 
  * cdef inline object PyArray_MultiIterNew4(a, b, c, d):
  *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)             # <<<<<<<<<<<<<<
  * 
  * cdef inline object PyArray_MultiIterNew5(a, b, c, d, e):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = PyArray_MultiIterNew(4, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c), ((void *)__pyx_v_d)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 745, __pyx_L1_error)
+  __pyx_t_1 = PyArray_MultiIterNew(4, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c), ((void *)__pyx_v_d)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 783, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":744
+  /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":782
  *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)
  * 
  * cdef inline object PyArray_MultiIterNew4(a, b, c, d):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)
  * 
  */
 
@@ -5431,46 +3677,46 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":747
+/* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":785
  *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)
  * 
  * cdef inline object PyArray_MultiIterNew5(a, b, c, d, e):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)
  * 
  */
 
 static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew5(PyObject *__pyx_v_a, PyObject *__pyx_v_b, PyObject *__pyx_v_c, PyObject *__pyx_v_d, PyObject *__pyx_v_e) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("PyArray_MultiIterNew5", 0);
+  __Pyx_RefNannySetupContext("PyArray_MultiIterNew5", 1);
 
-  /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":748
+  /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":786
  * 
  * cdef inline object PyArray_MultiIterNew5(a, b, c, d, e):
  *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)             # <<<<<<<<<<<<<<
  * 
  * cdef inline tuple PyDataType_SHAPE(dtype d):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = PyArray_MultiIterNew(5, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c), ((void *)__pyx_v_d), ((void *)__pyx_v_e)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 748, __pyx_L1_error)
+  __pyx_t_1 = PyArray_MultiIterNew(5, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c), ((void *)__pyx_v_d), ((void *)__pyx_v_e)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 786, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":747
+  /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":785
  *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)
  * 
  * cdef inline object PyArray_MultiIterNew5(a, b, c, d, e):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)
  * 
  */
 
@@ -5481,212 +3727,217 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":750
+/* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":788
  *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)
  * 
  * cdef inline tuple PyDataType_SHAPE(dtype d):             # <<<<<<<<<<<<<<
  *     if PyDataType_HASSUBARRAY(d):
  *         return <tuple>d.subarray.shape
  */
 
 static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyDataType_SHAPE(PyArray_Descr *__pyx_v_d) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
-  __Pyx_RefNannySetupContext("PyDataType_SHAPE", 0);
+  __Pyx_RefNannySetupContext("PyDataType_SHAPE", 1);
 
-  /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":751
+  /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":789
  * 
  * cdef inline tuple PyDataType_SHAPE(dtype d):
  *     if PyDataType_HASSUBARRAY(d):             # <<<<<<<<<<<<<<
  *         return <tuple>d.subarray.shape
  *     else:
  */
-  __pyx_t_1 = (PyDataType_HASSUBARRAY(__pyx_v_d) != 0);
+  __pyx_t_1 = PyDataType_HASSUBARRAY(__pyx_v_d);
   if (__pyx_t_1) {
 
-    /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":752
+    /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":790
  * cdef inline tuple PyDataType_SHAPE(dtype d):
  *     if PyDataType_HASSUBARRAY(d):
  *         return <tuple>d.subarray.shape             # <<<<<<<<<<<<<<
  *     else:
  *         return ()
  */
     __Pyx_XDECREF(__pyx_r);
     __Pyx_INCREF(((PyObject*)__pyx_v_d->subarray->shape));
     __pyx_r = ((PyObject*)__pyx_v_d->subarray->shape);
     goto __pyx_L0;
 
-    /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":751
+    /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":789
  * 
  * cdef inline tuple PyDataType_SHAPE(dtype d):
  *     if PyDataType_HASSUBARRAY(d):             # <<<<<<<<<<<<<<
  *         return <tuple>d.subarray.shape
  *     else:
  */
   }
 
-  /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":754
+  /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":792
  *         return <tuple>d.subarray.shape
  *     else:
  *         return ()             # <<<<<<<<<<<<<<
  * 
  * 
  */
   /*else*/ {
     __Pyx_XDECREF(__pyx_r);
     __Pyx_INCREF(__pyx_empty_tuple);
     __pyx_r = __pyx_empty_tuple;
     goto __pyx_L0;
   }
 
-  /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":750
+  /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":788
  *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)
  * 
  * cdef inline tuple PyDataType_SHAPE(dtype d):             # <<<<<<<<<<<<<<
  *     if PyDataType_HASSUBARRAY(d):
  *         return <tuple>d.subarray.shape
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":929
+/* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":968
  *     int _import_umath() except -1
  * 
  * cdef inline void set_array_base(ndarray arr, object base):             # <<<<<<<<<<<<<<
  *     Py_INCREF(base) # important to do this before stealing the reference below!
  *     PyArray_SetBaseObject(arr, base)
  */
 
 static CYTHON_INLINE void __pyx_f_5numpy_set_array_base(PyArrayObject *__pyx_v_arr, PyObject *__pyx_v_base) {
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("set_array_base", 0);
+  int __pyx_t_1;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
 
-  /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":930
+  /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":969
  * 
  * cdef inline void set_array_base(ndarray arr, object base):
  *     Py_INCREF(base) # important to do this before stealing the reference below!             # <<<<<<<<<<<<<<
  *     PyArray_SetBaseObject(arr, base)
  * 
  */
   Py_INCREF(__pyx_v_base);
 
-  /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":931
+  /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":970
  * cdef inline void set_array_base(ndarray arr, object base):
  *     Py_INCREF(base) # important to do this before stealing the reference below!
  *     PyArray_SetBaseObject(arr, base)             # <<<<<<<<<<<<<<
  * 
  * cdef inline object get_array_base(ndarray arr):
  */
-  (void)(PyArray_SetBaseObject(__pyx_v_arr, __pyx_v_base));
+  __pyx_t_1 = PyArray_SetBaseObject(__pyx_v_arr, __pyx_v_base); if (unlikely(__pyx_t_1 == ((int)-1))) __PYX_ERR(1, 970, __pyx_L1_error)
 
-  /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":929
+  /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":968
  *     int _import_umath() except -1
  * 
  * cdef inline void set_array_base(ndarray arr, object base):             # <<<<<<<<<<<<<<
  *     Py_INCREF(base) # important to do this before stealing the reference below!
  *     PyArray_SetBaseObject(arr, base)
  */
 
   /* function exit code */
-  __Pyx_RefNannyFinishContext();
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_AddTraceback("numpy.set_array_base", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_L0:;
 }
 
-/* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":933
+/* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":972
  *     PyArray_SetBaseObject(arr, base)
  * 
  * cdef inline object get_array_base(ndarray arr):             # <<<<<<<<<<<<<<
  *     base = PyArray_BASE(arr)
  *     if base is NULL:
  */
 
 static CYTHON_INLINE PyObject *__pyx_f_5numpy_get_array_base(PyArrayObject *__pyx_v_arr) {
   PyObject *__pyx_v_base;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
-  __Pyx_RefNannySetupContext("get_array_base", 0);
+  __Pyx_RefNannySetupContext("get_array_base", 1);
 
-  /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":934
+  /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":973
  * 
  * cdef inline object get_array_base(ndarray arr):
  *     base = PyArray_BASE(arr)             # <<<<<<<<<<<<<<
  *     if base is NULL:
  *         return None
  */
   __pyx_v_base = PyArray_BASE(__pyx_v_arr);
 
-  /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":935
+  /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":974
  * cdef inline object get_array_base(ndarray arr):
  *     base = PyArray_BASE(arr)
  *     if base is NULL:             # <<<<<<<<<<<<<<
  *         return None
  *     return <object>base
  */
-  __pyx_t_1 = ((__pyx_v_base == NULL) != 0);
+  __pyx_t_1 = (__pyx_v_base == NULL);
   if (__pyx_t_1) {
 
-    /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":936
+    /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":975
  *     base = PyArray_BASE(arr)
  *     if base is NULL:
  *         return None             # <<<<<<<<<<<<<<
  *     return <object>base
  * 
  */
     __Pyx_XDECREF(__pyx_r);
     __pyx_r = Py_None; __Pyx_INCREF(Py_None);
     goto __pyx_L0;
 
-    /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":935
+    /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":974
  * cdef inline object get_array_base(ndarray arr):
  *     base = PyArray_BASE(arr)
  *     if base is NULL:             # <<<<<<<<<<<<<<
  *         return None
  *     return <object>base
  */
   }
 
-  /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":937
+  /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":976
  *     if base is NULL:
  *         return None
  *     return <object>base             # <<<<<<<<<<<<<<
  * 
  * # Versions of the import_* functions which are more suitable for
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(((PyObject *)__pyx_v_base));
   __pyx_r = ((PyObject *)__pyx_v_base);
   goto __pyx_L0;
 
-  /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":933
+  /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":972
  *     PyArray_SetBaseObject(arr, base)
  * 
  * cdef inline object get_array_base(ndarray arr):             # <<<<<<<<<<<<<<
  *     base = PyArray_BASE(arr)
  *     if base is NULL:
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":941
+/* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":980
  * # Versions of the import_* functions which are more suitable for
  * # Cython code.
  * cdef inline int import_array() except -1:             # <<<<<<<<<<<<<<
  *     try:
  *         __pyx_import_array()
  */
 
@@ -5700,17 +3951,17 @@
   PyObject *__pyx_t_5 = NULL;
   PyObject *__pyx_t_6 = NULL;
   PyObject *__pyx_t_7 = NULL;
   PyObject *__pyx_t_8 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("import_array", 0);
+  __Pyx_RefNannySetupContext("import_array", 1);
 
-  /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":942
+  /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":981
  * # Cython code.
  * cdef inline int import_array() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         __pyx_import_array()
  *     except Exception:
  */
   {
@@ -5718,84 +3969,84 @@
     __Pyx_PyThreadState_assign
     __Pyx_ExceptionSave(&__pyx_t_1, &__pyx_t_2, &__pyx_t_3);
     __Pyx_XGOTREF(__pyx_t_1);
     __Pyx_XGOTREF(__pyx_t_2);
     __Pyx_XGOTREF(__pyx_t_3);
     /*try:*/ {
 
-      /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":943
+      /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":982
  * cdef inline int import_array() except -1:
  *     try:
  *         __pyx_import_array()             # <<<<<<<<<<<<<<
  *     except Exception:
  *         raise ImportError("numpy.core.multiarray failed to import")
  */
-      __pyx_t_4 = _import_array(); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(1, 943, __pyx_L3_error)
+      __pyx_t_4 = _import_array(); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(1, 982, __pyx_L3_error)
 
-      /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":942
+      /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":981
  * # Cython code.
  * cdef inline int import_array() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         __pyx_import_array()
  *     except Exception:
  */
     }
     __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
     goto __pyx_L8_try_end;
     __pyx_L3_error:;
 
-    /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":944
+    /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":983
  *     try:
  *         __pyx_import_array()
  *     except Exception:             # <<<<<<<<<<<<<<
  *         raise ImportError("numpy.core.multiarray failed to import")
  * 
  */
     __pyx_t_4 = __Pyx_PyErr_ExceptionMatches(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])));
     if (__pyx_t_4) {
       __Pyx_AddTraceback("numpy.import_array", __pyx_clineno, __pyx_lineno, __pyx_filename);
-      if (__Pyx_GetException(&__pyx_t_5, &__pyx_t_6, &__pyx_t_7) < 0) __PYX_ERR(1, 944, __pyx_L5_except_error)
-      __Pyx_GOTREF(__pyx_t_5);
-      __Pyx_GOTREF(__pyx_t_6);
-      __Pyx_GOTREF(__pyx_t_7);
+      if (__Pyx_GetException(&__pyx_t_5, &__pyx_t_6, &__pyx_t_7) < 0) __PYX_ERR(1, 983, __pyx_L5_except_error)
+      __Pyx_XGOTREF(__pyx_t_5);
+      __Pyx_XGOTREF(__pyx_t_6);
+      __Pyx_XGOTREF(__pyx_t_7);
 
-      /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":945
+      /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":984
  *         __pyx_import_array()
  *     except Exception:
  *         raise ImportError("numpy.core.multiarray failed to import")             # <<<<<<<<<<<<<<
  * 
  * cdef inline int import_umath() except -1:
  */
-      __pyx_t_8 = __Pyx_PyObject_Call(__pyx_builtin_ImportError, __pyx_tuple__12, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 945, __pyx_L5_except_error)
+      __pyx_t_8 = __Pyx_PyObject_Call(__pyx_builtin_ImportError, __pyx_tuple_, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 984, __pyx_L5_except_error)
       __Pyx_GOTREF(__pyx_t_8);
       __Pyx_Raise(__pyx_t_8, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-      __PYX_ERR(1, 945, __pyx_L5_except_error)
+      __PYX_ERR(1, 984, __pyx_L5_except_error)
     }
     goto __pyx_L5_except_error;
-    __pyx_L5_except_error:;
 
-    /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":942
+    /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":981
  * # Cython code.
  * cdef inline int import_array() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         __pyx_import_array()
  *     except Exception:
  */
+    __pyx_L5_except_error:;
     __Pyx_XGIVEREF(__pyx_t_1);
     __Pyx_XGIVEREF(__pyx_t_2);
     __Pyx_XGIVEREF(__pyx_t_3);
     __Pyx_ExceptionReset(__pyx_t_1, __pyx_t_2, __pyx_t_3);
     goto __pyx_L1_error;
     __pyx_L8_try_end:;
   }
 
-  /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":941
+  /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":980
  * # Versions of the import_* functions which are more suitable for
  * # Cython code.
  * cdef inline int import_array() except -1:             # <<<<<<<<<<<<<<
  *     try:
  *         __pyx_import_array()
  */
 
@@ -5810,15 +4061,15 @@
   __Pyx_AddTraceback("numpy.import_array", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":947
+/* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":986
  *         raise ImportError("numpy.core.multiarray failed to import")
  * 
  * cdef inline int import_umath() except -1:             # <<<<<<<<<<<<<<
  *     try:
  *         _import_umath()
  */
 
@@ -5832,17 +4083,17 @@
   PyObject *__pyx_t_5 = NULL;
   PyObject *__pyx_t_6 = NULL;
   PyObject *__pyx_t_7 = NULL;
   PyObject *__pyx_t_8 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("import_umath", 0);
+  __Pyx_RefNannySetupContext("import_umath", 1);
 
-  /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":948
+  /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":987
  * 
  * cdef inline int import_umath() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         _import_umath()
  *     except Exception:
  */
   {
@@ -5850,84 +4101,84 @@
     __Pyx_PyThreadState_assign
     __Pyx_ExceptionSave(&__pyx_t_1, &__pyx_t_2, &__pyx_t_3);
     __Pyx_XGOTREF(__pyx_t_1);
     __Pyx_XGOTREF(__pyx_t_2);
     __Pyx_XGOTREF(__pyx_t_3);
     /*try:*/ {
 
-      /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":949
+      /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":988
  * cdef inline int import_umath() except -1:
  *     try:
  *         _import_umath()             # <<<<<<<<<<<<<<
  *     except Exception:
  *         raise ImportError("numpy.core.umath failed to import")
  */
-      __pyx_t_4 = _import_umath(); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(1, 949, __pyx_L3_error)
+      __pyx_t_4 = _import_umath(); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(1, 988, __pyx_L3_error)
 
-      /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":948
+      /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":987
  * 
  * cdef inline int import_umath() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         _import_umath()
  *     except Exception:
  */
     }
     __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
     goto __pyx_L8_try_end;
     __pyx_L3_error:;
 
-    /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":950
+    /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":989
  *     try:
  *         _import_umath()
  *     except Exception:             # <<<<<<<<<<<<<<
  *         raise ImportError("numpy.core.umath failed to import")
  * 
  */
     __pyx_t_4 = __Pyx_PyErr_ExceptionMatches(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])));
     if (__pyx_t_4) {
       __Pyx_AddTraceback("numpy.import_umath", __pyx_clineno, __pyx_lineno, __pyx_filename);
-      if (__Pyx_GetException(&__pyx_t_5, &__pyx_t_6, &__pyx_t_7) < 0) __PYX_ERR(1, 950, __pyx_L5_except_error)
-      __Pyx_GOTREF(__pyx_t_5);
-      __Pyx_GOTREF(__pyx_t_6);
-      __Pyx_GOTREF(__pyx_t_7);
+      if (__Pyx_GetException(&__pyx_t_5, &__pyx_t_6, &__pyx_t_7) < 0) __PYX_ERR(1, 989, __pyx_L5_except_error)
+      __Pyx_XGOTREF(__pyx_t_5);
+      __Pyx_XGOTREF(__pyx_t_6);
+      __Pyx_XGOTREF(__pyx_t_7);
 
-      /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":951
+      /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":990
  *         _import_umath()
  *     except Exception:
  *         raise ImportError("numpy.core.umath failed to import")             # <<<<<<<<<<<<<<
  * 
  * cdef inline int import_ufunc() except -1:
  */
-      __pyx_t_8 = __Pyx_PyObject_Call(__pyx_builtin_ImportError, __pyx_tuple__13, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 951, __pyx_L5_except_error)
+      __pyx_t_8 = __Pyx_PyObject_Call(__pyx_builtin_ImportError, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 990, __pyx_L5_except_error)
       __Pyx_GOTREF(__pyx_t_8);
       __Pyx_Raise(__pyx_t_8, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-      __PYX_ERR(1, 951, __pyx_L5_except_error)
+      __PYX_ERR(1, 990, __pyx_L5_except_error)
     }
     goto __pyx_L5_except_error;
-    __pyx_L5_except_error:;
 
-    /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":948
+    /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":987
  * 
  * cdef inline int import_umath() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         _import_umath()
  *     except Exception:
  */
+    __pyx_L5_except_error:;
     __Pyx_XGIVEREF(__pyx_t_1);
     __Pyx_XGIVEREF(__pyx_t_2);
     __Pyx_XGIVEREF(__pyx_t_3);
     __Pyx_ExceptionReset(__pyx_t_1, __pyx_t_2, __pyx_t_3);
     goto __pyx_L1_error;
     __pyx_L8_try_end:;
   }
 
-  /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":947
+  /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":986
  *         raise ImportError("numpy.core.multiarray failed to import")
  * 
  * cdef inline int import_umath() except -1:             # <<<<<<<<<<<<<<
  *     try:
  *         _import_umath()
  */
 
@@ -5942,15 +4193,15 @@
   __Pyx_AddTraceback("numpy.import_umath", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":953
+/* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":992
  *         raise ImportError("numpy.core.umath failed to import")
  * 
  * cdef inline int import_ufunc() except -1:             # <<<<<<<<<<<<<<
  *     try:
  *         _import_umath()
  */
 
@@ -5964,17 +4215,17 @@
   PyObject *__pyx_t_5 = NULL;
   PyObject *__pyx_t_6 = NULL;
   PyObject *__pyx_t_7 = NULL;
   PyObject *__pyx_t_8 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("import_ufunc", 0);
+  __Pyx_RefNannySetupContext("import_ufunc", 1);
 
-  /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":954
+  /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":993
  * 
  * cdef inline int import_ufunc() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         _import_umath()
  *     except Exception:
  */
   {
@@ -5982,84 +4233,84 @@
     __Pyx_PyThreadState_assign
     __Pyx_ExceptionSave(&__pyx_t_1, &__pyx_t_2, &__pyx_t_3);
     __Pyx_XGOTREF(__pyx_t_1);
     __Pyx_XGOTREF(__pyx_t_2);
     __Pyx_XGOTREF(__pyx_t_3);
     /*try:*/ {
 
-      /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":955
+      /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":994
  * cdef inline int import_ufunc() except -1:
  *     try:
  *         _import_umath()             # <<<<<<<<<<<<<<
  *     except Exception:
  *         raise ImportError("numpy.core.umath failed to import")
  */
-      __pyx_t_4 = _import_umath(); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(1, 955, __pyx_L3_error)
+      __pyx_t_4 = _import_umath(); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(1, 994, __pyx_L3_error)
 
-      /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":954
+      /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":993
  * 
  * cdef inline int import_ufunc() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         _import_umath()
  *     except Exception:
  */
     }
     __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
     goto __pyx_L8_try_end;
     __pyx_L3_error:;
 
-    /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":956
+    /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":995
  *     try:
  *         _import_umath()
  *     except Exception:             # <<<<<<<<<<<<<<
  *         raise ImportError("numpy.core.umath failed to import")
  * 
  */
     __pyx_t_4 = __Pyx_PyErr_ExceptionMatches(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])));
     if (__pyx_t_4) {
       __Pyx_AddTraceback("numpy.import_ufunc", __pyx_clineno, __pyx_lineno, __pyx_filename);
-      if (__Pyx_GetException(&__pyx_t_5, &__pyx_t_6, &__pyx_t_7) < 0) __PYX_ERR(1, 956, __pyx_L5_except_error)
-      __Pyx_GOTREF(__pyx_t_5);
-      __Pyx_GOTREF(__pyx_t_6);
-      __Pyx_GOTREF(__pyx_t_7);
+      if (__Pyx_GetException(&__pyx_t_5, &__pyx_t_6, &__pyx_t_7) < 0) __PYX_ERR(1, 995, __pyx_L5_except_error)
+      __Pyx_XGOTREF(__pyx_t_5);
+      __Pyx_XGOTREF(__pyx_t_6);
+      __Pyx_XGOTREF(__pyx_t_7);
 
-      /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":957
+      /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":996
  *         _import_umath()
  *     except Exception:
  *         raise ImportError("numpy.core.umath failed to import")             # <<<<<<<<<<<<<<
  * 
- * cdef extern from *:
+ * 
  */
-      __pyx_t_8 = __Pyx_PyObject_Call(__pyx_builtin_ImportError, __pyx_tuple__13, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 957, __pyx_L5_except_error)
+      __pyx_t_8 = __Pyx_PyObject_Call(__pyx_builtin_ImportError, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 996, __pyx_L5_except_error)
       __Pyx_GOTREF(__pyx_t_8);
       __Pyx_Raise(__pyx_t_8, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-      __PYX_ERR(1, 957, __pyx_L5_except_error)
+      __PYX_ERR(1, 996, __pyx_L5_except_error)
     }
     goto __pyx_L5_except_error;
-    __pyx_L5_except_error:;
 
-    /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":954
+    /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":993
  * 
  * cdef inline int import_ufunc() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         _import_umath()
  *     except Exception:
  */
+    __pyx_L5_except_error:;
     __Pyx_XGIVEREF(__pyx_t_1);
     __Pyx_XGIVEREF(__pyx_t_2);
     __Pyx_XGIVEREF(__pyx_t_3);
     __Pyx_ExceptionReset(__pyx_t_1, __pyx_t_2, __pyx_t_3);
     goto __pyx_L1_error;
     __pyx_L8_try_end:;
   }
 
-  /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":953
+  /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":992
  *         raise ImportError("numpy.core.umath failed to import")
  * 
  * cdef inline int import_ufunc() except -1:             # <<<<<<<<<<<<<<
  *     try:
  *         _import_umath()
  */
 
@@ -6074,433 +4325,1534 @@
   __Pyx_AddTraceback("numpy.import_ufunc", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":967
+/* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":999
  * 
  * 
  * cdef inline bint is_timedelta64_object(object obj):             # <<<<<<<<<<<<<<
  *     """
  *     Cython equivalent of `isinstance(obj, np.timedelta64)`
  */
 
 static CYTHON_INLINE int __pyx_f_5numpy_is_timedelta64_object(PyObject *__pyx_v_obj) {
   int __pyx_r;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("is_timedelta64_object", 0);
 
-  /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":979
+  /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":1011
  *     bool
  *     """
  *     return PyObject_TypeCheck(obj, &PyTimedeltaArrType_Type)             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_r = PyObject_TypeCheck(__pyx_v_obj, (&PyTimedeltaArrType_Type));
   goto __pyx_L0;
 
-  /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":967
+  /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":999
  * 
  * 
  * cdef inline bint is_timedelta64_object(object obj):             # <<<<<<<<<<<<<<
  *     """
  *     Cython equivalent of `isinstance(obj, np.timedelta64)`
  */
 
   /* function exit code */
   __pyx_L0:;
-  __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":982
+/* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":1014
  * 
  * 
  * cdef inline bint is_datetime64_object(object obj):             # <<<<<<<<<<<<<<
  *     """
  *     Cython equivalent of `isinstance(obj, np.datetime64)`
  */
 
 static CYTHON_INLINE int __pyx_f_5numpy_is_datetime64_object(PyObject *__pyx_v_obj) {
   int __pyx_r;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("is_datetime64_object", 0);
 
-  /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":994
+  /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":1026
  *     bool
  *     """
  *     return PyObject_TypeCheck(obj, &PyDatetimeArrType_Type)             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_r = PyObject_TypeCheck(__pyx_v_obj, (&PyDatetimeArrType_Type));
   goto __pyx_L0;
 
-  /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":982
+  /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":1014
  * 
  * 
  * cdef inline bint is_datetime64_object(object obj):             # <<<<<<<<<<<<<<
  *     """
  *     Cython equivalent of `isinstance(obj, np.datetime64)`
  */
 
   /* function exit code */
   __pyx_L0:;
-  __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":997
+/* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":1029
  * 
  * 
  * cdef inline npy_datetime get_datetime64_value(object obj) nogil:             # <<<<<<<<<<<<<<
  *     """
  *     returns the int64 value underlying scalar numpy datetime64 object
  */
 
 static CYTHON_INLINE npy_datetime __pyx_f_5numpy_get_datetime64_value(PyObject *__pyx_v_obj) {
   npy_datetime __pyx_r;
 
-  /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":1004
+  /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":1036
  *     also needed.  That can be found using `get_datetime64_unit`.
  *     """
  *     return (<PyDatetimeScalarObject*>obj).obval             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_r = ((PyDatetimeScalarObject *)__pyx_v_obj)->obval;
   goto __pyx_L0;
 
-  /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":997
+  /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":1029
  * 
  * 
  * cdef inline npy_datetime get_datetime64_value(object obj) nogil:             # <<<<<<<<<<<<<<
  *     """
  *     returns the int64 value underlying scalar numpy datetime64 object
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":1007
+/* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":1039
  * 
  * 
  * cdef inline npy_timedelta get_timedelta64_value(object obj) nogil:             # <<<<<<<<<<<<<<
  *     """
  *     returns the int64 value underlying scalar numpy timedelta64 object
  */
 
 static CYTHON_INLINE npy_timedelta __pyx_f_5numpy_get_timedelta64_value(PyObject *__pyx_v_obj) {
   npy_timedelta __pyx_r;
 
-  /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":1011
+  /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":1043
  *     returns the int64 value underlying scalar numpy timedelta64 object
  *     """
  *     return (<PyTimedeltaScalarObject*>obj).obval             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_r = ((PyTimedeltaScalarObject *)__pyx_v_obj)->obval;
   goto __pyx_L0;
 
-  /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":1007
+  /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":1039
  * 
  * 
  * cdef inline npy_timedelta get_timedelta64_value(object obj) nogil:             # <<<<<<<<<<<<<<
  *     """
  *     returns the int64 value underlying scalar numpy timedelta64 object
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":1014
+/* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":1046
  * 
  * 
  * cdef inline NPY_DATETIMEUNIT get_datetime64_unit(object obj) nogil:             # <<<<<<<<<<<<<<
  *     """
  *     returns the unit part of the dtype for a numpy datetime64 object.
  */
 
 static CYTHON_INLINE NPY_DATETIMEUNIT __pyx_f_5numpy_get_datetime64_unit(PyObject *__pyx_v_obj) {
   NPY_DATETIMEUNIT __pyx_r;
 
-  /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":1018
+  /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":1050
  *     returns the unit part of the dtype for a numpy datetime64 object.
  *     """
  *     return <NPY_DATETIMEUNIT>(<PyDatetimeScalarObject*>obj).obmeta.base             # <<<<<<<<<<<<<<
  */
   __pyx_r = ((NPY_DATETIMEUNIT)((PyDatetimeScalarObject *)__pyx_v_obj)->obmeta.base);
   goto __pyx_L0;
 
-  /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":1014
+  /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":1046
  * 
  * 
  * cdef inline NPY_DATETIMEUNIT get_datetime64_unit(object obj) nogil:             # <<<<<<<<<<<<<<
  *     """
  *     returns the unit part of the dtype for a numpy datetime64 object.
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
-static PyMethodDef __pyx_methods[] = {
-  {"points2rect", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5argos_8cutility_1points2rect, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5argos_8cutility_points2rect},
-  {"rect2points", (PyCFunction)__pyx_pw_5argos_8cutility_3rect2points, METH_O, __pyx_doc_5argos_8cutility_2rect2points},
-  {"tlwh2xyrh", (PyCFunction)__pyx_pw_5argos_8cutility_5tlwh2xyrh, METH_O, __pyx_doc_5argos_8cutility_4tlwh2xyrh},
-  {"xyrh2tlwh", (PyCFunction)__pyx_pw_5argos_8cutility_7xyrh2tlwh, METH_O, __pyx_doc_5argos_8cutility_6xyrh2tlwh},
-  {"rect_intersection", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5argos_8cutility_9rect_intersection, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5argos_8cutility_8rect_intersection},
-  {"rect_iou", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5argos_8cutility_11rect_iou, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5argos_8cutility_10rect_iou},
-  {"rect_ios", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5argos_8cutility_13rect_ios, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5argos_8cutility_12rect_ios},
-  {"pairwise_distance", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5argos_8cutility_15pairwise_distance, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5argos_8cutility_14pairwise_distance},
-  {0, 0, 0, 0}
-};
+/* "yolact/utils/cython_nms.pyx":29
+ * cimport numpy as np
+ * 
+ * cdef inline np.float32_t max(np.float32_t a, np.float32_t b) nogil:             # <<<<<<<<<<<<<<
+ *     return a if a >= b else b
+ * 
+ */
 
-#if PY_MAJOR_VERSION >= 3
-#if CYTHON_PEP489_MULTI_PHASE_INIT
-static PyObject* __pyx_pymod_create(PyObject *spec, PyModuleDef *def); /*proto*/
-static int __pyx_pymod_exec_cutility(PyObject* module); /*proto*/
-static PyModuleDef_Slot __pyx_moduledef_slots[] = {
-  {Py_mod_create, (void*)__pyx_pymod_create},
-  {Py_mod_exec, (void*)__pyx_pymod_exec_cutility},
-  {0, NULL}
-};
-#endif
+static CYTHON_INLINE __pyx_t_5numpy_float32_t __pyx_f_6yolact_5utils_10cython_nms_max(__pyx_t_5numpy_float32_t __pyx_v_a, __pyx_t_5numpy_float32_t __pyx_v_b) {
+  __pyx_t_5numpy_float32_t __pyx_r;
+  __pyx_t_5numpy_float32_t __pyx_t_1;
+  int __pyx_t_2;
 
-static struct PyModuleDef __pyx_moduledef = {
-    PyModuleDef_HEAD_INIT,
-    "cutility",
-    0, /* m_doc */
-  #if CYTHON_PEP489_MULTI_PHASE_INIT
-    0, /* m_size */
-  #else
-    -1, /* m_size */
+  /* "yolact/utils/cython_nms.pyx":30
+ * 
+ * cdef inline np.float32_t max(np.float32_t a, np.float32_t b) nogil:
+ *     return a if a >= b else b             # <<<<<<<<<<<<<<
+ * 
+ * cdef inline np.float32_t min(np.float32_t a, np.float32_t b) nogil:
+ */
+  __pyx_t_2 = (__pyx_v_a >= __pyx_v_b);
+  if (__pyx_t_2) {
+    __pyx_t_1 = __pyx_v_a;
+  } else {
+    __pyx_t_1 = __pyx_v_b;
+  }
+  __pyx_r = __pyx_t_1;
+  goto __pyx_L0;
+
+  /* "yolact/utils/cython_nms.pyx":29
+ * cimport numpy as np
+ * 
+ * cdef inline np.float32_t max(np.float32_t a, np.float32_t b) nogil:             # <<<<<<<<<<<<<<
+ *     return a if a >= b else b
+ * 
+ */
+
+  /* function exit code */
+  __pyx_L0:;
+  return __pyx_r;
+}
+
+/* "yolact/utils/cython_nms.pyx":32
+ *     return a if a >= b else b
+ * 
+ * cdef inline np.float32_t min(np.float32_t a, np.float32_t b) nogil:             # <<<<<<<<<<<<<<
+ *     return a if a <= b else b
+ * 
+ */
+
+static CYTHON_INLINE __pyx_t_5numpy_float32_t __pyx_f_6yolact_5utils_10cython_nms_min(__pyx_t_5numpy_float32_t __pyx_v_a, __pyx_t_5numpy_float32_t __pyx_v_b) {
+  __pyx_t_5numpy_float32_t __pyx_r;
+  __pyx_t_5numpy_float32_t __pyx_t_1;
+  int __pyx_t_2;
+
+  /* "yolact/utils/cython_nms.pyx":33
+ * 
+ * cdef inline np.float32_t min(np.float32_t a, np.float32_t b) nogil:
+ *     return a if a <= b else b             # <<<<<<<<<<<<<<
+ * 
+ * @cython.boundscheck(False)
+ */
+  __pyx_t_2 = (__pyx_v_a <= __pyx_v_b);
+  if (__pyx_t_2) {
+    __pyx_t_1 = __pyx_v_a;
+  } else {
+    __pyx_t_1 = __pyx_v_b;
+  }
+  __pyx_r = __pyx_t_1;
+  goto __pyx_L0;
+
+  /* "yolact/utils/cython_nms.pyx":32
+ *     return a if a >= b else b
+ * 
+ * cdef inline np.float32_t min(np.float32_t a, np.float32_t b) nogil:             # <<<<<<<<<<<<<<
+ *     return a if a <= b else b
+ * 
+ */
+
+  /* function exit code */
+  __pyx_L0:;
+  return __pyx_r;
+}
+
+/* "yolact/utils/cython_nms.pyx":35
+ *     return a if a <= b else b
+ * 
+ * @cython.boundscheck(False)             # <<<<<<<<<<<<<<
+ * @cython.cdivision(True)
+ * @cython.wraparound(False)
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_6yolact_5utils_10cython_nms_1nms(PyObject *__pyx_self, 
+#if CYTHON_METH_FASTCALL
+PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
+#else
+PyObject *__pyx_args, PyObject *__pyx_kwds
+#endif
+); /*proto*/
+static PyMethodDef __pyx_mdef_6yolact_5utils_10cython_nms_1nms = {"nms", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_6yolact_5utils_10cython_nms_1nms, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
+static PyObject *__pyx_pw_6yolact_5utils_10cython_nms_1nms(PyObject *__pyx_self, 
+#if CYTHON_METH_FASTCALL
+PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
+#else
+PyObject *__pyx_args, PyObject *__pyx_kwds
+#endif
+) {
+  PyArrayObject *__pyx_v_dets = 0;
+  __pyx_t_5numpy_float32_t __pyx_v_thresh;
+  #if !CYTHON_METH_FASTCALL
+  CYTHON_UNUSED Py_ssize_t __pyx_nargs;
   #endif
-    __pyx_methods /* m_methods */,
-  #if CYTHON_PEP489_MULTI_PHASE_INIT
-    __pyx_moduledef_slots, /* m_slots */
+  CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
+  PyObject* values[2] = {0,0};
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("nms (wrapper)", 0);
+  #if !CYTHON_METH_FASTCALL
+  #if CYTHON_ASSUME_SAFE_MACROS
+  __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
   #else
-    NULL, /* m_reload */
+  __pyx_nargs = PyTuple_Size(__pyx_args); if (unlikely(__pyx_nargs < 0)) return NULL;
+  #endif
+  #endif
+  __pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
+  {
+    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_dets,&__pyx_n_s_thresh,0};
+    if (__pyx_kwds) {
+      Py_ssize_t kw_args;
+      switch (__pyx_nargs) {
+        case  2: values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
+        CYTHON_FALLTHROUGH;
+        case  1: values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
+        CYTHON_FALLTHROUGH;
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+      kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
+      switch (__pyx_nargs) {
+        case  0:
+        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_dets)) != 0)) {
+          (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
+          kw_args--;
+        }
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 35, __pyx_L3_error)
+        else goto __pyx_L5_argtuple_error;
+        CYTHON_FALLTHROUGH;
+        case  1:
+        if (likely((values[1] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_thresh)) != 0)) {
+          (void)__Pyx_Arg_NewRef_FASTCALL(values[1]);
+          kw_args--;
+        }
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 35, __pyx_L3_error)
+        else {
+          __Pyx_RaiseArgtupleInvalid("nms", 1, 2, 2, 1); __PYX_ERR(0, 35, __pyx_L3_error)
+        }
+      }
+      if (unlikely(kw_args > 0)) {
+        const Py_ssize_t kwd_pos_args = __pyx_nargs;
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "nms") < 0)) __PYX_ERR(0, 35, __pyx_L3_error)
+      }
+    } else if (unlikely(__pyx_nargs != 2)) {
+      goto __pyx_L5_argtuple_error;
+    } else {
+      values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
+      values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
+    }
+    __pyx_v_dets = ((PyArrayObject *)values[0]);
+    __pyx_v_thresh = __pyx_PyFloat_AsFloat(values[1]); if (unlikely((__pyx_v_thresh == ((npy_float32)-1)) && PyErr_Occurred())) __PYX_ERR(0, 38, __pyx_L3_error)
+  }
+  goto __pyx_L6_skip;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("nms", 1, 2, 2, __pyx_nargs); __PYX_ERR(0, 35, __pyx_L3_error)
+  __pyx_L6_skip:;
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L3_error:;
+  {
+    Py_ssize_t __pyx_temp;
+    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
+      __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
+    }
+  }
+  __Pyx_AddTraceback("yolact.utils.cython_nms.nms", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_dets), __pyx_ptype_5numpy_ndarray, 1, "dets", 0))) __PYX_ERR(0, 38, __pyx_L1_error)
+  __pyx_r = __pyx_pf_6yolact_5utils_10cython_nms_nms(__pyx_self, __pyx_v_dets, __pyx_v_thresh);
+
+  /* function exit code */
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __pyx_r = NULL;
+  __pyx_L0:;
+  {
+    Py_ssize_t __pyx_temp;
+    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
+      __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
+    }
+  }
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_6yolact_5utils_10cython_nms_nms(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_dets, __pyx_t_5numpy_float32_t __pyx_v_thresh) {
+  PyArrayObject *__pyx_v_x1 = 0;
+  PyArrayObject *__pyx_v_y1 = 0;
+  PyArrayObject *__pyx_v_x2 = 0;
+  PyArrayObject *__pyx_v_y2 = 0;
+  PyArrayObject *__pyx_v_scores = 0;
+  PyArrayObject *__pyx_v_areas = 0;
+  PyArrayObject *__pyx_v_order = 0;
+  size_t __pyx_v_ndets;
+  PyObject *__pyx_v_suppressed_np = NULL;
+  PyArrayObject *__pyx_v_suppressed = 0;
+  size_t __pyx_v__i;
+  size_t __pyx_v__j;
+  size_t __pyx_v_i;
+  size_t __pyx_v_j;
+  __pyx_t_5numpy_float32_t __pyx_v_ix1;
+  __pyx_t_5numpy_float32_t __pyx_v_iy1;
+  __pyx_t_5numpy_float32_t __pyx_v_ix2;
+  __pyx_t_5numpy_float32_t __pyx_v_iy2;
+  __pyx_t_5numpy_float32_t __pyx_v_iarea;
+  __pyx_t_5numpy_float32_t __pyx_v_xx1;
+  __pyx_t_5numpy_float32_t __pyx_v_yy1;
+  __pyx_t_5numpy_float32_t __pyx_v_xx2;
+  __pyx_t_5numpy_float32_t __pyx_v_yy2;
+  __pyx_t_5numpy_float32_t __pyx_v_w;
+  __pyx_t_5numpy_float32_t __pyx_v_h;
+  __pyx_t_5numpy_float32_t __pyx_v_inter;
+  __pyx_t_5numpy_float32_t __pyx_v_ovr;
+  __Pyx_LocalBuf_ND __pyx_pybuffernd_areas;
+  __Pyx_Buffer __pyx_pybuffer_areas;
+  __Pyx_LocalBuf_ND __pyx_pybuffernd_dets;
+  __Pyx_Buffer __pyx_pybuffer_dets;
+  __Pyx_LocalBuf_ND __pyx_pybuffernd_order;
+  __Pyx_Buffer __pyx_pybuffer_order;
+  __Pyx_LocalBuf_ND __pyx_pybuffernd_scores;
+  __Pyx_Buffer __pyx_pybuffer_scores;
+  __Pyx_LocalBuf_ND __pyx_pybuffernd_suppressed;
+  __Pyx_Buffer __pyx_pybuffer_suppressed;
+  __Pyx_LocalBuf_ND __pyx_pybuffernd_x1;
+  __Pyx_Buffer __pyx_pybuffer_x1;
+  __Pyx_LocalBuf_ND __pyx_pybuffernd_x2;
+  __Pyx_Buffer __pyx_pybuffer_x2;
+  __Pyx_LocalBuf_ND __pyx_pybuffernd_y1;
+  __Pyx_Buffer __pyx_pybuffer_y1;
+  __Pyx_LocalBuf_ND __pyx_pybuffernd_y2;
+  __Pyx_Buffer __pyx_pybuffer_y2;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyArrayObject *__pyx_t_2 = NULL;
+  PyArrayObject *__pyx_t_3 = NULL;
+  PyArrayObject *__pyx_t_4 = NULL;
+  PyArrayObject *__pyx_t_5 = NULL;
+  PyArrayObject *__pyx_t_6 = NULL;
+  PyObject *__pyx_t_7 = NULL;
+  PyObject *__pyx_t_8 = NULL;
+  int __pyx_t_9;
+  PyObject *__pyx_t_10 = NULL;
+  PyObject *__pyx_t_11 = NULL;
+  PyArrayObject *__pyx_t_12 = NULL;
+  PyArrayObject *__pyx_t_13 = NULL;
+  npy_intp *__pyx_t_14;
+  size_t __pyx_t_15;
+  size_t __pyx_t_16;
+  size_t __pyx_t_17;
+  size_t __pyx_t_18;
+  int __pyx_t_19;
+  size_t __pyx_t_20;
+  size_t __pyx_t_21;
+  size_t __pyx_t_22;
+  __pyx_t_5numpy_float32_t __pyx_t_23;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("nms", 1);
+  __pyx_pybuffer_x1.pybuffer.buf = NULL;
+  __pyx_pybuffer_x1.refcount = 0;
+  __pyx_pybuffernd_x1.data = NULL;
+  __pyx_pybuffernd_x1.rcbuffer = &__pyx_pybuffer_x1;
+  __pyx_pybuffer_y1.pybuffer.buf = NULL;
+  __pyx_pybuffer_y1.refcount = 0;
+  __pyx_pybuffernd_y1.data = NULL;
+  __pyx_pybuffernd_y1.rcbuffer = &__pyx_pybuffer_y1;
+  __pyx_pybuffer_x2.pybuffer.buf = NULL;
+  __pyx_pybuffer_x2.refcount = 0;
+  __pyx_pybuffernd_x2.data = NULL;
+  __pyx_pybuffernd_x2.rcbuffer = &__pyx_pybuffer_x2;
+  __pyx_pybuffer_y2.pybuffer.buf = NULL;
+  __pyx_pybuffer_y2.refcount = 0;
+  __pyx_pybuffernd_y2.data = NULL;
+  __pyx_pybuffernd_y2.rcbuffer = &__pyx_pybuffer_y2;
+  __pyx_pybuffer_scores.pybuffer.buf = NULL;
+  __pyx_pybuffer_scores.refcount = 0;
+  __pyx_pybuffernd_scores.data = NULL;
+  __pyx_pybuffernd_scores.rcbuffer = &__pyx_pybuffer_scores;
+  __pyx_pybuffer_areas.pybuffer.buf = NULL;
+  __pyx_pybuffer_areas.refcount = 0;
+  __pyx_pybuffernd_areas.data = NULL;
+  __pyx_pybuffernd_areas.rcbuffer = &__pyx_pybuffer_areas;
+  __pyx_pybuffer_order.pybuffer.buf = NULL;
+  __pyx_pybuffer_order.refcount = 0;
+  __pyx_pybuffernd_order.data = NULL;
+  __pyx_pybuffernd_order.rcbuffer = &__pyx_pybuffer_order;
+  __pyx_pybuffer_suppressed.pybuffer.buf = NULL;
+  __pyx_pybuffer_suppressed.refcount = 0;
+  __pyx_pybuffernd_suppressed.data = NULL;
+  __pyx_pybuffernd_suppressed.rcbuffer = &__pyx_pybuffer_suppressed;
+  __pyx_pybuffer_dets.pybuffer.buf = NULL;
+  __pyx_pybuffer_dets.refcount = 0;
+  __pyx_pybuffernd_dets.data = NULL;
+  __pyx_pybuffernd_dets.rcbuffer = &__pyx_pybuffer_dets;
+  {
+    __Pyx_BufFmt_StackElem __pyx_stack[1];
+    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_dets.rcbuffer->pybuffer, (PyObject*)__pyx_v_dets, &__Pyx_TypeInfo_nn___pyx_t_5numpy_float32_t, PyBUF_FORMAT| PyBUF_STRIDES, 2, 0, __pyx_stack) == -1)) __PYX_ERR(0, 35, __pyx_L1_error)
+  }
+  __pyx_pybuffernd_dets.diminfo[0].strides = __pyx_pybuffernd_dets.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_dets.diminfo[0].shape = __pyx_pybuffernd_dets.rcbuffer->pybuffer.shape[0]; __pyx_pybuffernd_dets.diminfo[1].strides = __pyx_pybuffernd_dets.rcbuffer->pybuffer.strides[1]; __pyx_pybuffernd_dets.diminfo[1].shape = __pyx_pybuffernd_dets.rcbuffer->pybuffer.shape[1];
+
+  /* "yolact/utils/cython_nms.pyx":39
+ * @cython.wraparound(False)
+ * def nms(np.ndarray[np.float32_t, ndim=2] dets, np.float32_t thresh):
+ *     cdef np.ndarray[np.float32_t, ndim=1] x1 = dets[:, 0]             # <<<<<<<<<<<<<<
+ *     cdef np.ndarray[np.float32_t, ndim=1] y1 = dets[:, 1]
+ *     cdef np.ndarray[np.float32_t, ndim=1] x2 = dets[:, 2]
+ */
+  __pyx_t_1 = __Pyx_PyObject_GetItem(((PyObject *)__pyx_v_dets), __pyx_tuple__4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 39, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (!(likely(((__pyx_t_1) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_1, __pyx_ptype_5numpy_ndarray))))) __PYX_ERR(0, 39, __pyx_L1_error)
+  __pyx_t_2 = ((PyArrayObject *)__pyx_t_1);
+  {
+    __Pyx_BufFmt_StackElem __pyx_stack[1];
+    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_x1.rcbuffer->pybuffer, (PyObject*)__pyx_t_2, &__Pyx_TypeInfo_nn___pyx_t_5numpy_float32_t, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) {
+      __pyx_v_x1 = ((PyArrayObject *)Py_None); __Pyx_INCREF(Py_None); __pyx_pybuffernd_x1.rcbuffer->pybuffer.buf = NULL;
+      __PYX_ERR(0, 39, __pyx_L1_error)
+    } else {__pyx_pybuffernd_x1.diminfo[0].strides = __pyx_pybuffernd_x1.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_x1.diminfo[0].shape = __pyx_pybuffernd_x1.rcbuffer->pybuffer.shape[0];
+    }
+  }
+  __pyx_t_2 = 0;
+  __pyx_v_x1 = ((PyArrayObject *)__pyx_t_1);
+  __pyx_t_1 = 0;
+
+  /* "yolact/utils/cython_nms.pyx":40
+ * def nms(np.ndarray[np.float32_t, ndim=2] dets, np.float32_t thresh):
+ *     cdef np.ndarray[np.float32_t, ndim=1] x1 = dets[:, 0]
+ *     cdef np.ndarray[np.float32_t, ndim=1] y1 = dets[:, 1]             # <<<<<<<<<<<<<<
+ *     cdef np.ndarray[np.float32_t, ndim=1] x2 = dets[:, 2]
+ *     cdef np.ndarray[np.float32_t, ndim=1] y2 = dets[:, 3]
+ */
+  __pyx_t_1 = __Pyx_PyObject_GetItem(((PyObject *)__pyx_v_dets), __pyx_tuple__5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 40, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (!(likely(((__pyx_t_1) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_1, __pyx_ptype_5numpy_ndarray))))) __PYX_ERR(0, 40, __pyx_L1_error)
+  __pyx_t_3 = ((PyArrayObject *)__pyx_t_1);
+  {
+    __Pyx_BufFmt_StackElem __pyx_stack[1];
+    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_y1.rcbuffer->pybuffer, (PyObject*)__pyx_t_3, &__Pyx_TypeInfo_nn___pyx_t_5numpy_float32_t, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) {
+      __pyx_v_y1 = ((PyArrayObject *)Py_None); __Pyx_INCREF(Py_None); __pyx_pybuffernd_y1.rcbuffer->pybuffer.buf = NULL;
+      __PYX_ERR(0, 40, __pyx_L1_error)
+    } else {__pyx_pybuffernd_y1.diminfo[0].strides = __pyx_pybuffernd_y1.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_y1.diminfo[0].shape = __pyx_pybuffernd_y1.rcbuffer->pybuffer.shape[0];
+    }
+  }
+  __pyx_t_3 = 0;
+  __pyx_v_y1 = ((PyArrayObject *)__pyx_t_1);
+  __pyx_t_1 = 0;
+
+  /* "yolact/utils/cython_nms.pyx":41
+ *     cdef np.ndarray[np.float32_t, ndim=1] x1 = dets[:, 0]
+ *     cdef np.ndarray[np.float32_t, ndim=1] y1 = dets[:, 1]
+ *     cdef np.ndarray[np.float32_t, ndim=1] x2 = dets[:, 2]             # <<<<<<<<<<<<<<
+ *     cdef np.ndarray[np.float32_t, ndim=1] y2 = dets[:, 3]
+ *     cdef np.ndarray[np.float32_t, ndim=1] scores = dets[:, 4]
+ */
+  __pyx_t_1 = __Pyx_PyObject_GetItem(((PyObject *)__pyx_v_dets), __pyx_tuple__6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 41, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (!(likely(((__pyx_t_1) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_1, __pyx_ptype_5numpy_ndarray))))) __PYX_ERR(0, 41, __pyx_L1_error)
+  __pyx_t_4 = ((PyArrayObject *)__pyx_t_1);
+  {
+    __Pyx_BufFmt_StackElem __pyx_stack[1];
+    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_x2.rcbuffer->pybuffer, (PyObject*)__pyx_t_4, &__Pyx_TypeInfo_nn___pyx_t_5numpy_float32_t, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) {
+      __pyx_v_x2 = ((PyArrayObject *)Py_None); __Pyx_INCREF(Py_None); __pyx_pybuffernd_x2.rcbuffer->pybuffer.buf = NULL;
+      __PYX_ERR(0, 41, __pyx_L1_error)
+    } else {__pyx_pybuffernd_x2.diminfo[0].strides = __pyx_pybuffernd_x2.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_x2.diminfo[0].shape = __pyx_pybuffernd_x2.rcbuffer->pybuffer.shape[0];
+    }
+  }
+  __pyx_t_4 = 0;
+  __pyx_v_x2 = ((PyArrayObject *)__pyx_t_1);
+  __pyx_t_1 = 0;
+
+  /* "yolact/utils/cython_nms.pyx":42
+ *     cdef np.ndarray[np.float32_t, ndim=1] y1 = dets[:, 1]
+ *     cdef np.ndarray[np.float32_t, ndim=1] x2 = dets[:, 2]
+ *     cdef np.ndarray[np.float32_t, ndim=1] y2 = dets[:, 3]             # <<<<<<<<<<<<<<
+ *     cdef np.ndarray[np.float32_t, ndim=1] scores = dets[:, 4]
+ * 
+ */
+  __pyx_t_1 = __Pyx_PyObject_GetItem(((PyObject *)__pyx_v_dets), __pyx_tuple__7); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 42, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (!(likely(((__pyx_t_1) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_1, __pyx_ptype_5numpy_ndarray))))) __PYX_ERR(0, 42, __pyx_L1_error)
+  __pyx_t_5 = ((PyArrayObject *)__pyx_t_1);
+  {
+    __Pyx_BufFmt_StackElem __pyx_stack[1];
+    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_y2.rcbuffer->pybuffer, (PyObject*)__pyx_t_5, &__Pyx_TypeInfo_nn___pyx_t_5numpy_float32_t, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) {
+      __pyx_v_y2 = ((PyArrayObject *)Py_None); __Pyx_INCREF(Py_None); __pyx_pybuffernd_y2.rcbuffer->pybuffer.buf = NULL;
+      __PYX_ERR(0, 42, __pyx_L1_error)
+    } else {__pyx_pybuffernd_y2.diminfo[0].strides = __pyx_pybuffernd_y2.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_y2.diminfo[0].shape = __pyx_pybuffernd_y2.rcbuffer->pybuffer.shape[0];
+    }
+  }
+  __pyx_t_5 = 0;
+  __pyx_v_y2 = ((PyArrayObject *)__pyx_t_1);
+  __pyx_t_1 = 0;
+
+  /* "yolact/utils/cython_nms.pyx":43
+ *     cdef np.ndarray[np.float32_t, ndim=1] x2 = dets[:, 2]
+ *     cdef np.ndarray[np.float32_t, ndim=1] y2 = dets[:, 3]
+ *     cdef np.ndarray[np.float32_t, ndim=1] scores = dets[:, 4]             # <<<<<<<<<<<<<<
+ * 
+ *     cdef np.ndarray[np.float32_t, ndim=1] areas = (np.asarray(x2) - np.asarray(x1) + 1) * (np.asarray(y2) - np.asarray(y1) + 1)
+ */
+  __pyx_t_1 = __Pyx_PyObject_GetItem(((PyObject *)__pyx_v_dets), __pyx_tuple__8); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 43, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (!(likely(((__pyx_t_1) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_1, __pyx_ptype_5numpy_ndarray))))) __PYX_ERR(0, 43, __pyx_L1_error)
+  __pyx_t_6 = ((PyArrayObject *)__pyx_t_1);
+  {
+    __Pyx_BufFmt_StackElem __pyx_stack[1];
+    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_scores.rcbuffer->pybuffer, (PyObject*)__pyx_t_6, &__Pyx_TypeInfo_nn___pyx_t_5numpy_float32_t, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) {
+      __pyx_v_scores = ((PyArrayObject *)Py_None); __Pyx_INCREF(Py_None); __pyx_pybuffernd_scores.rcbuffer->pybuffer.buf = NULL;
+      __PYX_ERR(0, 43, __pyx_L1_error)
+    } else {__pyx_pybuffernd_scores.diminfo[0].strides = __pyx_pybuffernd_scores.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_scores.diminfo[0].shape = __pyx_pybuffernd_scores.rcbuffer->pybuffer.shape[0];
+    }
+  }
+  __pyx_t_6 = 0;
+  __pyx_v_scores = ((PyArrayObject *)__pyx_t_1);
+  __pyx_t_1 = 0;
+
+  /* "yolact/utils/cython_nms.pyx":45
+ *     cdef np.ndarray[np.float32_t, ndim=1] scores = dets[:, 4]
+ * 
+ *     cdef np.ndarray[np.float32_t, ndim=1] areas = (np.asarray(x2) - np.asarray(x1) + 1) * (np.asarray(y2) - np.asarray(y1) + 1)             # <<<<<<<<<<<<<<
+ *     cdef np.ndarray[np.int64_t, ndim=1] order = scores.argsort()[::-1]
+ * 
+ */
+  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_np); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 45, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_7);
+  __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_asarray); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 45, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_8);
+  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+  __pyx_t_7 = NULL;
+  __pyx_t_9 = 0;
+  #if CYTHON_UNPACK_METHODS
+  if (unlikely(PyMethod_Check(__pyx_t_8))) {
+    __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_8);
+    if (likely(__pyx_t_7)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_8);
+      __Pyx_INCREF(__pyx_t_7);
+      __Pyx_INCREF(function);
+      __Pyx_DECREF_SET(__pyx_t_8, function);
+      __pyx_t_9 = 1;
+    }
+  }
+  #endif
+  {
+    PyObject *__pyx_callargs[2] = {__pyx_t_7, ((PyObject *)__pyx_v_x2)};
+    __pyx_t_1 = __Pyx_PyObject_FastCall(__pyx_t_8, __pyx_callargs+1-__pyx_t_9, 1+__pyx_t_9);
+    __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 45, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_1);
+    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+  }
+  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_np); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 45, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_7);
+  __pyx_t_10 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_asarray); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 45, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_10);
+  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+  __pyx_t_7 = NULL;
+  __pyx_t_9 = 0;
+  #if CYTHON_UNPACK_METHODS
+  if (unlikely(PyMethod_Check(__pyx_t_10))) {
+    __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_10);
+    if (likely(__pyx_t_7)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_10);
+      __Pyx_INCREF(__pyx_t_7);
+      __Pyx_INCREF(function);
+      __Pyx_DECREF_SET(__pyx_t_10, function);
+      __pyx_t_9 = 1;
+    }
+  }
+  #endif
+  {
+    PyObject *__pyx_callargs[2] = {__pyx_t_7, ((PyObject *)__pyx_v_x1)};
+    __pyx_t_8 = __Pyx_PyObject_FastCall(__pyx_t_10, __pyx_callargs+1-__pyx_t_9, 1+__pyx_t_9);
+    __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
+    if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 45, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_8);
+    __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
+  }
+  __pyx_t_10 = PyNumber_Subtract(__pyx_t_1, __pyx_t_8); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 45, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_10);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+  __pyx_t_8 = __Pyx_PyInt_AddObjC(__pyx_t_10, __pyx_int_1, 1, 0, 0); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 45, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_8);
+  __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 45, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_asarray); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 45, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_7);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_1 = NULL;
+  __pyx_t_9 = 0;
+  #if CYTHON_UNPACK_METHODS
+  if (unlikely(PyMethod_Check(__pyx_t_7))) {
+    __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_7);
+    if (likely(__pyx_t_1)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);
+      __Pyx_INCREF(__pyx_t_1);
+      __Pyx_INCREF(function);
+      __Pyx_DECREF_SET(__pyx_t_7, function);
+      __pyx_t_9 = 1;
+    }
+  }
+  #endif
+  {
+    PyObject *__pyx_callargs[2] = {__pyx_t_1, ((PyObject *)__pyx_v_y2)};
+    __pyx_t_10 = __Pyx_PyObject_FastCall(__pyx_t_7, __pyx_callargs+1-__pyx_t_9, 1+__pyx_t_9);
+    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
+    if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 45, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_10);
+    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+  }
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 45, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_11 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_asarray); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 45, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_11);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_1 = NULL;
+  __pyx_t_9 = 0;
+  #if CYTHON_UNPACK_METHODS
+  if (unlikely(PyMethod_Check(__pyx_t_11))) {
+    __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_11);
+    if (likely(__pyx_t_1)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_11);
+      __Pyx_INCREF(__pyx_t_1);
+      __Pyx_INCREF(function);
+      __Pyx_DECREF_SET(__pyx_t_11, function);
+      __pyx_t_9 = 1;
+    }
+  }
   #endif
-    NULL, /* m_traverse */
-    NULL, /* m_clear */
-    NULL /* m_free */
+  {
+    PyObject *__pyx_callargs[2] = {__pyx_t_1, ((PyObject *)__pyx_v_y1)};
+    __pyx_t_7 = __Pyx_PyObject_FastCall(__pyx_t_11, __pyx_callargs+1-__pyx_t_9, 1+__pyx_t_9);
+    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
+    if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 45, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_7);
+    __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
+  }
+  __pyx_t_11 = PyNumber_Subtract(__pyx_t_10, __pyx_t_7); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 45, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_11);
+  __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
+  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+  __pyx_t_7 = __Pyx_PyInt_AddObjC(__pyx_t_11, __pyx_int_1, 1, 0, 0); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 45, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_7);
+  __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
+  __pyx_t_11 = PyNumber_Multiply(__pyx_t_8, __pyx_t_7); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 45, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_11);
+  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+  if (!(likely(((__pyx_t_11) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_11, __pyx_ptype_5numpy_ndarray))))) __PYX_ERR(0, 45, __pyx_L1_error)
+  __pyx_t_12 = ((PyArrayObject *)__pyx_t_11);
+  {
+    __Pyx_BufFmt_StackElem __pyx_stack[1];
+    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_areas.rcbuffer->pybuffer, (PyObject*)__pyx_t_12, &__Pyx_TypeInfo_nn___pyx_t_5numpy_float32_t, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) {
+      __pyx_v_areas = ((PyArrayObject *)Py_None); __Pyx_INCREF(Py_None); __pyx_pybuffernd_areas.rcbuffer->pybuffer.buf = NULL;
+      __PYX_ERR(0, 45, __pyx_L1_error)
+    } else {__pyx_pybuffernd_areas.diminfo[0].strides = __pyx_pybuffernd_areas.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_areas.diminfo[0].shape = __pyx_pybuffernd_areas.rcbuffer->pybuffer.shape[0];
+    }
+  }
+  __pyx_t_12 = 0;
+  __pyx_v_areas = ((PyArrayObject *)__pyx_t_11);
+  __pyx_t_11 = 0;
+
+  /* "yolact/utils/cython_nms.pyx":46
+ * 
+ *     cdef np.ndarray[np.float32_t, ndim=1] areas = (np.asarray(x2) - np.asarray(x1) + 1) * (np.asarray(y2) - np.asarray(y1) + 1)
+ *     cdef np.ndarray[np.int64_t, ndim=1] order = scores.argsort()[::-1]             # <<<<<<<<<<<<<<
+ * 
+ *     cdef size_t ndets = dets.shape[0]
+ */
+  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_scores), __pyx_n_s_argsort); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 46, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_7);
+  __pyx_t_8 = NULL;
+  __pyx_t_9 = 0;
+  #if CYTHON_UNPACK_METHODS
+  if (likely(PyMethod_Check(__pyx_t_7))) {
+    __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_7);
+    if (likely(__pyx_t_8)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);
+      __Pyx_INCREF(__pyx_t_8);
+      __Pyx_INCREF(function);
+      __Pyx_DECREF_SET(__pyx_t_7, function);
+      __pyx_t_9 = 1;
+    }
+  }
+  #endif
+  {
+    PyObject *__pyx_callargs[2] = {__pyx_t_8, NULL};
+    __pyx_t_11 = __Pyx_PyObject_FastCall(__pyx_t_7, __pyx_callargs+1-__pyx_t_9, 0+__pyx_t_9);
+    __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
+    if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 46, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_11);
+    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+  }
+  __pyx_t_7 = __Pyx_PyObject_GetItem(__pyx_t_11, __pyx_slice__9); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 46, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_7);
+  __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
+  if (!(likely(((__pyx_t_7) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_7, __pyx_ptype_5numpy_ndarray))))) __PYX_ERR(0, 46, __pyx_L1_error)
+  __pyx_t_13 = ((PyArrayObject *)__pyx_t_7);
+  {
+    __Pyx_BufFmt_StackElem __pyx_stack[1];
+    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_order.rcbuffer->pybuffer, (PyObject*)__pyx_t_13, &__Pyx_TypeInfo_nn___pyx_t_5numpy_int64_t, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) {
+      __pyx_v_order = ((PyArrayObject *)Py_None); __Pyx_INCREF(Py_None); __pyx_pybuffernd_order.rcbuffer->pybuffer.buf = NULL;
+      __PYX_ERR(0, 46, __pyx_L1_error)
+    } else {__pyx_pybuffernd_order.diminfo[0].strides = __pyx_pybuffernd_order.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_order.diminfo[0].shape = __pyx_pybuffernd_order.rcbuffer->pybuffer.shape[0];
+    }
+  }
+  __pyx_t_13 = 0;
+  __pyx_v_order = ((PyArrayObject *)__pyx_t_7);
+  __pyx_t_7 = 0;
+
+  /* "yolact/utils/cython_nms.pyx":48
+ *     cdef np.ndarray[np.int64_t, ndim=1] order = scores.argsort()[::-1]
+ * 
+ *     cdef size_t ndets = dets.shape[0]             # <<<<<<<<<<<<<<
+ *     suppressed_np = np.zeros((ndets), dtype=np.int64)
+ *     cdef np.ndarray[np.int64_t, ndim=1] suppressed = suppressed_np
+ */
+  __pyx_t_14 = __pyx_f_5numpy_7ndarray_5shape_shape(((PyArrayObject *)__pyx_v_dets)); if (unlikely(__pyx_t_14 == ((npy_intp *)NULL) && PyErr_Occurred())) __PYX_ERR(0, 48, __pyx_L1_error)
+  __pyx_v_ndets = (__pyx_t_14[0]);
+
+  /* "yolact/utils/cython_nms.pyx":49
+ * 
+ *     cdef size_t ndets = dets.shape[0]
+ *     suppressed_np = np.zeros((ndets), dtype=np.int64)             # <<<<<<<<<<<<<<
+ *     cdef np.ndarray[np.int64_t, ndim=1] suppressed = suppressed_np
+ * 
+ */
+  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_np); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 49, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_7);
+  __pyx_t_11 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_zeros); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 49, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_11);
+  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+  __pyx_t_7 = __Pyx_PyInt_FromSize_t(__pyx_v_ndets); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 49, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_7);
+  __pyx_t_8 = PyTuple_New(1); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 49, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_8);
+  __Pyx_GIVEREF(__pyx_t_7);
+  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_7)) __PYX_ERR(0, 49, __pyx_L1_error);
+  __pyx_t_7 = 0;
+  __pyx_t_7 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 49, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_7);
+  __Pyx_GetModuleGlobalName(__pyx_t_10, __pyx_n_s_np); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 49, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_10);
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_10, __pyx_n_s_int64); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 49, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
+  if (PyDict_SetItem(__pyx_t_7, __pyx_n_s_dtype, __pyx_t_1) < 0) __PYX_ERR(0, 49, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_11, __pyx_t_8, __pyx_t_7); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 49, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
+  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+  __pyx_v_suppressed_np = __pyx_t_1;
+  __pyx_t_1 = 0;
+
+  /* "yolact/utils/cython_nms.pyx":50
+ *     cdef size_t ndets = dets.shape[0]
+ *     suppressed_np = np.zeros((ndets), dtype=np.int64)
+ *     cdef np.ndarray[np.int64_t, ndim=1] suppressed = suppressed_np             # <<<<<<<<<<<<<<
+ * 
+ *     # nominal indices
+ */
+  if (!(likely(((__pyx_v_suppressed_np) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_suppressed_np, __pyx_ptype_5numpy_ndarray))))) __PYX_ERR(0, 50, __pyx_L1_error)
+  __pyx_t_1 = __pyx_v_suppressed_np;
+  __Pyx_INCREF(__pyx_t_1);
+  {
+    __Pyx_BufFmt_StackElem __pyx_stack[1];
+    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_suppressed.rcbuffer->pybuffer, (PyObject*)((PyArrayObject *)__pyx_t_1), &__Pyx_TypeInfo_nn___pyx_t_5numpy_int64_t, PyBUF_FORMAT| PyBUF_STRIDES| PyBUF_WRITABLE, 1, 0, __pyx_stack) == -1)) {
+      __pyx_v_suppressed = ((PyArrayObject *)Py_None); __Pyx_INCREF(Py_None); __pyx_pybuffernd_suppressed.rcbuffer->pybuffer.buf = NULL;
+      __PYX_ERR(0, 50, __pyx_L1_error)
+    } else {__pyx_pybuffernd_suppressed.diminfo[0].strides = __pyx_pybuffernd_suppressed.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_suppressed.diminfo[0].shape = __pyx_pybuffernd_suppressed.rcbuffer->pybuffer.shape[0];
+    }
+  }
+  __pyx_v_suppressed = ((PyArrayObject *)__pyx_t_1);
+  __pyx_t_1 = 0;
+
+  /* "yolact/utils/cython_nms.pyx":63
+ *     cdef np.float32_t inter, ovr
+ * 
+ *     with nogil:             # <<<<<<<<<<<<<<
+ *       for _i in range(ndets):
+ *           i = order[_i]
+ */
+  {
+      #ifdef WITH_THREAD
+      PyThreadState *_save;
+      _save = NULL;
+      Py_UNBLOCK_THREADS
+      __Pyx_FastGIL_Remember();
+      #endif
+      /*try:*/ {
+
+        /* "yolact/utils/cython_nms.pyx":64
+ * 
+ *     with nogil:
+ *       for _i in range(ndets):             # <<<<<<<<<<<<<<
+ *           i = order[_i]
+ *           if suppressed[i] == 1:
+ */
+        __pyx_t_15 = __pyx_v_ndets;
+        __pyx_t_16 = __pyx_t_15;
+        for (__pyx_t_17 = 0; __pyx_t_17 < __pyx_t_16; __pyx_t_17+=1) {
+          __pyx_v__i = __pyx_t_17;
+
+          /* "yolact/utils/cython_nms.pyx":65
+ *     with nogil:
+ *       for _i in range(ndets):
+ *           i = order[_i]             # <<<<<<<<<<<<<<
+ *           if suppressed[i] == 1:
+ *               continue
+ */
+          __pyx_t_18 = __pyx_v__i;
+          __pyx_v_i = (*__Pyx_BufPtrStrided1d(__pyx_t_5numpy_int64_t *, __pyx_pybuffernd_order.rcbuffer->pybuffer.buf, __pyx_t_18, __pyx_pybuffernd_order.diminfo[0].strides));
+
+          /* "yolact/utils/cython_nms.pyx":66
+ *       for _i in range(ndets):
+ *           i = order[_i]
+ *           if suppressed[i] == 1:             # <<<<<<<<<<<<<<
+ *               continue
+ *           ix1 = x1[i]
+ */
+          __pyx_t_18 = __pyx_v_i;
+          __pyx_t_19 = ((*__Pyx_BufPtrStrided1d(__pyx_t_5numpy_int64_t *, __pyx_pybuffernd_suppressed.rcbuffer->pybuffer.buf, __pyx_t_18, __pyx_pybuffernd_suppressed.diminfo[0].strides)) == 1);
+          if (__pyx_t_19) {
+
+            /* "yolact/utils/cython_nms.pyx":67
+ *           i = order[_i]
+ *           if suppressed[i] == 1:
+ *               continue             # <<<<<<<<<<<<<<
+ *           ix1 = x1[i]
+ *           iy1 = y1[i]
+ */
+            goto __pyx_L6_continue;
+
+            /* "yolact/utils/cython_nms.pyx":66
+ *       for _i in range(ndets):
+ *           i = order[_i]
+ *           if suppressed[i] == 1:             # <<<<<<<<<<<<<<
+ *               continue
+ *           ix1 = x1[i]
+ */
+          }
+
+          /* "yolact/utils/cython_nms.pyx":68
+ *           if suppressed[i] == 1:
+ *               continue
+ *           ix1 = x1[i]             # <<<<<<<<<<<<<<
+ *           iy1 = y1[i]
+ *           ix2 = x2[i]
+ */
+          __pyx_t_18 = __pyx_v_i;
+          __pyx_v_ix1 = (*__Pyx_BufPtrStrided1d(__pyx_t_5numpy_float32_t *, __pyx_pybuffernd_x1.rcbuffer->pybuffer.buf, __pyx_t_18, __pyx_pybuffernd_x1.diminfo[0].strides));
+
+          /* "yolact/utils/cython_nms.pyx":69
+ *               continue
+ *           ix1 = x1[i]
+ *           iy1 = y1[i]             # <<<<<<<<<<<<<<
+ *           ix2 = x2[i]
+ *           iy2 = y2[i]
+ */
+          __pyx_t_18 = __pyx_v_i;
+          __pyx_v_iy1 = (*__Pyx_BufPtrStrided1d(__pyx_t_5numpy_float32_t *, __pyx_pybuffernd_y1.rcbuffer->pybuffer.buf, __pyx_t_18, __pyx_pybuffernd_y1.diminfo[0].strides));
+
+          /* "yolact/utils/cython_nms.pyx":70
+ *           ix1 = x1[i]
+ *           iy1 = y1[i]
+ *           ix2 = x2[i]             # <<<<<<<<<<<<<<
+ *           iy2 = y2[i]
+ *           iarea = areas[i]
+ */
+          __pyx_t_18 = __pyx_v_i;
+          __pyx_v_ix2 = (*__Pyx_BufPtrStrided1d(__pyx_t_5numpy_float32_t *, __pyx_pybuffernd_x2.rcbuffer->pybuffer.buf, __pyx_t_18, __pyx_pybuffernd_x2.diminfo[0].strides));
+
+          /* "yolact/utils/cython_nms.pyx":71
+ *           iy1 = y1[i]
+ *           ix2 = x2[i]
+ *           iy2 = y2[i]             # <<<<<<<<<<<<<<
+ *           iarea = areas[i]
+ *           for _j in range(_i + 1, ndets):
+ */
+          __pyx_t_18 = __pyx_v_i;
+          __pyx_v_iy2 = (*__Pyx_BufPtrStrided1d(__pyx_t_5numpy_float32_t *, __pyx_pybuffernd_y2.rcbuffer->pybuffer.buf, __pyx_t_18, __pyx_pybuffernd_y2.diminfo[0].strides));
+
+          /* "yolact/utils/cython_nms.pyx":72
+ *           ix2 = x2[i]
+ *           iy2 = y2[i]
+ *           iarea = areas[i]             # <<<<<<<<<<<<<<
+ *           for _j in range(_i + 1, ndets):
+ *               j = order[_j]
+ */
+          __pyx_t_18 = __pyx_v_i;
+          __pyx_v_iarea = (*__Pyx_BufPtrStrided1d(__pyx_t_5numpy_float32_t *, __pyx_pybuffernd_areas.rcbuffer->pybuffer.buf, __pyx_t_18, __pyx_pybuffernd_areas.diminfo[0].strides));
+
+          /* "yolact/utils/cython_nms.pyx":73
+ *           iy2 = y2[i]
+ *           iarea = areas[i]
+ *           for _j in range(_i + 1, ndets):             # <<<<<<<<<<<<<<
+ *               j = order[_j]
+ *               if suppressed[j] == 1:
+ */
+          __pyx_t_18 = __pyx_v_ndets;
+          __pyx_t_20 = __pyx_t_18;
+          for (__pyx_t_21 = (__pyx_v__i + 1); __pyx_t_21 < __pyx_t_20; __pyx_t_21+=1) {
+            __pyx_v__j = __pyx_t_21;
+
+            /* "yolact/utils/cython_nms.pyx":74
+ *           iarea = areas[i]
+ *           for _j in range(_i + 1, ndets):
+ *               j = order[_j]             # <<<<<<<<<<<<<<
+ *               if suppressed[j] == 1:
+ *                   continue
+ */
+            __pyx_t_22 = __pyx_v__j;
+            __pyx_v_j = (*__Pyx_BufPtrStrided1d(__pyx_t_5numpy_int64_t *, __pyx_pybuffernd_order.rcbuffer->pybuffer.buf, __pyx_t_22, __pyx_pybuffernd_order.diminfo[0].strides));
+
+            /* "yolact/utils/cython_nms.pyx":75
+ *           for _j in range(_i + 1, ndets):
+ *               j = order[_j]
+ *               if suppressed[j] == 1:             # <<<<<<<<<<<<<<
+ *                   continue
+ *               xx1 = max(ix1, x1[j])
+ */
+            __pyx_t_22 = __pyx_v_j;
+            __pyx_t_19 = ((*__Pyx_BufPtrStrided1d(__pyx_t_5numpy_int64_t *, __pyx_pybuffernd_suppressed.rcbuffer->pybuffer.buf, __pyx_t_22, __pyx_pybuffernd_suppressed.diminfo[0].strides)) == 1);
+            if (__pyx_t_19) {
+
+              /* "yolact/utils/cython_nms.pyx":76
+ *               j = order[_j]
+ *               if suppressed[j] == 1:
+ *                   continue             # <<<<<<<<<<<<<<
+ *               xx1 = max(ix1, x1[j])
+ *               yy1 = max(iy1, y1[j])
+ */
+              goto __pyx_L9_continue;
+
+              /* "yolact/utils/cython_nms.pyx":75
+ *           for _j in range(_i + 1, ndets):
+ *               j = order[_j]
+ *               if suppressed[j] == 1:             # <<<<<<<<<<<<<<
+ *                   continue
+ *               xx1 = max(ix1, x1[j])
+ */
+            }
+
+            /* "yolact/utils/cython_nms.pyx":77
+ *               if suppressed[j] == 1:
+ *                   continue
+ *               xx1 = max(ix1, x1[j])             # <<<<<<<<<<<<<<
+ *               yy1 = max(iy1, y1[j])
+ *               xx2 = min(ix2, x2[j])
+ */
+            __pyx_t_22 = __pyx_v_j;
+            __pyx_t_23 = __pyx_f_6yolact_5utils_10cython_nms_max(__pyx_v_ix1, (*__Pyx_BufPtrStrided1d(__pyx_t_5numpy_float32_t *, __pyx_pybuffernd_x1.rcbuffer->pybuffer.buf, __pyx_t_22, __pyx_pybuffernd_x1.diminfo[0].strides))); if (unlikely(__pyx_t_23 == ((__pyx_t_5numpy_float32_t)-1) && __Pyx_ErrOccurredWithGIL())) __PYX_ERR(0, 77, __pyx_L4_error)
+            __pyx_v_xx1 = __pyx_t_23;
+
+            /* "yolact/utils/cython_nms.pyx":78
+ *                   continue
+ *               xx1 = max(ix1, x1[j])
+ *               yy1 = max(iy1, y1[j])             # <<<<<<<<<<<<<<
+ *               xx2 = min(ix2, x2[j])
+ *               yy2 = min(iy2, y2[j])
+ */
+            __pyx_t_22 = __pyx_v_j;
+            __pyx_t_23 = __pyx_f_6yolact_5utils_10cython_nms_max(__pyx_v_iy1, (*__Pyx_BufPtrStrided1d(__pyx_t_5numpy_float32_t *, __pyx_pybuffernd_y1.rcbuffer->pybuffer.buf, __pyx_t_22, __pyx_pybuffernd_y1.diminfo[0].strides))); if (unlikely(__pyx_t_23 == ((__pyx_t_5numpy_float32_t)-1) && __Pyx_ErrOccurredWithGIL())) __PYX_ERR(0, 78, __pyx_L4_error)
+            __pyx_v_yy1 = __pyx_t_23;
+
+            /* "yolact/utils/cython_nms.pyx":79
+ *               xx1 = max(ix1, x1[j])
+ *               yy1 = max(iy1, y1[j])
+ *               xx2 = min(ix2, x2[j])             # <<<<<<<<<<<<<<
+ *               yy2 = min(iy2, y2[j])
+ *               w = max(0.0, xx2 - xx1 + 1)
+ */
+            __pyx_t_22 = __pyx_v_j;
+            __pyx_t_23 = __pyx_f_6yolact_5utils_10cython_nms_min(__pyx_v_ix2, (*__Pyx_BufPtrStrided1d(__pyx_t_5numpy_float32_t *, __pyx_pybuffernd_x2.rcbuffer->pybuffer.buf, __pyx_t_22, __pyx_pybuffernd_x2.diminfo[0].strides))); if (unlikely(__pyx_t_23 == ((__pyx_t_5numpy_float32_t)-1) && __Pyx_ErrOccurredWithGIL())) __PYX_ERR(0, 79, __pyx_L4_error)
+            __pyx_v_xx2 = __pyx_t_23;
+
+            /* "yolact/utils/cython_nms.pyx":80
+ *               yy1 = max(iy1, y1[j])
+ *               xx2 = min(ix2, x2[j])
+ *               yy2 = min(iy2, y2[j])             # <<<<<<<<<<<<<<
+ *               w = max(0.0, xx2 - xx1 + 1)
+ *               h = max(0.0, yy2 - yy1 + 1)
+ */
+            __pyx_t_22 = __pyx_v_j;
+            __pyx_t_23 = __pyx_f_6yolact_5utils_10cython_nms_min(__pyx_v_iy2, (*__Pyx_BufPtrStrided1d(__pyx_t_5numpy_float32_t *, __pyx_pybuffernd_y2.rcbuffer->pybuffer.buf, __pyx_t_22, __pyx_pybuffernd_y2.diminfo[0].strides))); if (unlikely(__pyx_t_23 == ((__pyx_t_5numpy_float32_t)-1) && __Pyx_ErrOccurredWithGIL())) __PYX_ERR(0, 80, __pyx_L4_error)
+            __pyx_v_yy2 = __pyx_t_23;
+
+            /* "yolact/utils/cython_nms.pyx":81
+ *               xx2 = min(ix2, x2[j])
+ *               yy2 = min(iy2, y2[j])
+ *               w = max(0.0, xx2 - xx1 + 1)             # <<<<<<<<<<<<<<
+ *               h = max(0.0, yy2 - yy1 + 1)
+ *               inter = w * h
+ */
+            __pyx_t_23 = __pyx_f_6yolact_5utils_10cython_nms_max(0.0, ((__pyx_v_xx2 - __pyx_v_xx1) + 1.0)); if (unlikely(__pyx_t_23 == ((__pyx_t_5numpy_float32_t)-1) && __Pyx_ErrOccurredWithGIL())) __PYX_ERR(0, 81, __pyx_L4_error)
+            __pyx_v_w = __pyx_t_23;
+
+            /* "yolact/utils/cython_nms.pyx":82
+ *               yy2 = min(iy2, y2[j])
+ *               w = max(0.0, xx2 - xx1 + 1)
+ *               h = max(0.0, yy2 - yy1 + 1)             # <<<<<<<<<<<<<<
+ *               inter = w * h
+ *               ovr = inter / (iarea + areas[j] - inter)
+ */
+            __pyx_t_23 = __pyx_f_6yolact_5utils_10cython_nms_max(0.0, ((__pyx_v_yy2 - __pyx_v_yy1) + 1.0)); if (unlikely(__pyx_t_23 == ((__pyx_t_5numpy_float32_t)-1) && __Pyx_ErrOccurredWithGIL())) __PYX_ERR(0, 82, __pyx_L4_error)
+            __pyx_v_h = __pyx_t_23;
+
+            /* "yolact/utils/cython_nms.pyx":83
+ *               w = max(0.0, xx2 - xx1 + 1)
+ *               h = max(0.0, yy2 - yy1 + 1)
+ *               inter = w * h             # <<<<<<<<<<<<<<
+ *               ovr = inter / (iarea + areas[j] - inter)
+ *               if ovr >= thresh:
+ */
+            __pyx_v_inter = (__pyx_v_w * __pyx_v_h);
+
+            /* "yolact/utils/cython_nms.pyx":84
+ *               h = max(0.0, yy2 - yy1 + 1)
+ *               inter = w * h
+ *               ovr = inter / (iarea + areas[j] - inter)             # <<<<<<<<<<<<<<
+ *               if ovr >= thresh:
+ *                   suppressed[j] = 1
+ */
+            __pyx_t_22 = __pyx_v_j;
+            __pyx_v_ovr = (__pyx_v_inter / ((__pyx_v_iarea + (*__Pyx_BufPtrStrided1d(__pyx_t_5numpy_float32_t *, __pyx_pybuffernd_areas.rcbuffer->pybuffer.buf, __pyx_t_22, __pyx_pybuffernd_areas.diminfo[0].strides))) - __pyx_v_inter));
+
+            /* "yolact/utils/cython_nms.pyx":85
+ *               inter = w * h
+ *               ovr = inter / (iarea + areas[j] - inter)
+ *               if ovr >= thresh:             # <<<<<<<<<<<<<<
+ *                   suppressed[j] = 1
+ * 
+ */
+            __pyx_t_19 = (__pyx_v_ovr >= __pyx_v_thresh);
+            if (__pyx_t_19) {
+
+              /* "yolact/utils/cython_nms.pyx":86
+ *               ovr = inter / (iarea + areas[j] - inter)
+ *               if ovr >= thresh:
+ *                   suppressed[j] = 1             # <<<<<<<<<<<<<<
+ * 
+ *     return np.where(suppressed_np == 0)[0]
+ */
+              __pyx_t_22 = __pyx_v_j;
+              *__Pyx_BufPtrStrided1d(__pyx_t_5numpy_int64_t *, __pyx_pybuffernd_suppressed.rcbuffer->pybuffer.buf, __pyx_t_22, __pyx_pybuffernd_suppressed.diminfo[0].strides) = 1;
+
+              /* "yolact/utils/cython_nms.pyx":85
+ *               inter = w * h
+ *               ovr = inter / (iarea + areas[j] - inter)
+ *               if ovr >= thresh:             # <<<<<<<<<<<<<<
+ *                   suppressed[j] = 1
+ * 
+ */
+            }
+            __pyx_L9_continue:;
+          }
+          __pyx_L6_continue:;
+        }
+      }
+
+      /* "yolact/utils/cython_nms.pyx":63
+ *     cdef np.float32_t inter, ovr
+ * 
+ *     with nogil:             # <<<<<<<<<<<<<<
+ *       for _i in range(ndets):
+ *           i = order[_i]
+ */
+      /*finally:*/ {
+        /*normal exit:*/{
+          #ifdef WITH_THREAD
+          __Pyx_FastGIL_Forget();
+          Py_BLOCK_THREADS
+          #endif
+          goto __pyx_L5;
+        }
+        __pyx_L4_error: {
+          #ifdef WITH_THREAD
+          __Pyx_FastGIL_Forget();
+          Py_BLOCK_THREADS
+          #endif
+          goto __pyx_L1_error;
+        }
+        __pyx_L5:;
+      }
+  }
+
+  /* "yolact/utils/cython_nms.pyx":88
+ *                   suppressed[j] = 1
+ * 
+ *     return np.where(suppressed_np == 0)[0]             # <<<<<<<<<<<<<<
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_np); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 88, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_7);
+  __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_where); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 88, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_8);
+  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+  __pyx_t_7 = __Pyx_PyInt_EqObjC(__pyx_v_suppressed_np, __pyx_int_0, 0, 0); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 88, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_7);
+  __pyx_t_11 = NULL;
+  __pyx_t_9 = 0;
+  #if CYTHON_UNPACK_METHODS
+  if (unlikely(PyMethod_Check(__pyx_t_8))) {
+    __pyx_t_11 = PyMethod_GET_SELF(__pyx_t_8);
+    if (likely(__pyx_t_11)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_8);
+      __Pyx_INCREF(__pyx_t_11);
+      __Pyx_INCREF(function);
+      __Pyx_DECREF_SET(__pyx_t_8, function);
+      __pyx_t_9 = 1;
+    }
+  }
+  #endif
+  {
+    PyObject *__pyx_callargs[2] = {__pyx_t_11, __pyx_t_7};
+    __pyx_t_1 = __Pyx_PyObject_FastCall(__pyx_t_8, __pyx_callargs+1-__pyx_t_9, 1+__pyx_t_9);
+    __Pyx_XDECREF(__pyx_t_11); __pyx_t_11 = 0;
+    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 88, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_1);
+    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+  }
+  __pyx_t_8 = __Pyx_GetItemInt(__pyx_t_1, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 0); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 88, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_8);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_r = __pyx_t_8;
+  __pyx_t_8 = 0;
+  goto __pyx_L0;
+
+  /* "yolact/utils/cython_nms.pyx":35
+ *     return a if a <= b else b
+ * 
+ * @cython.boundscheck(False)             # <<<<<<<<<<<<<<
+ * @cython.cdivision(True)
+ * @cython.wraparound(False)
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_7);
+  __Pyx_XDECREF(__pyx_t_8);
+  __Pyx_XDECREF(__pyx_t_10);
+  __Pyx_XDECREF(__pyx_t_11);
+  { PyObject *__pyx_type, *__pyx_value, *__pyx_tb;
+    __Pyx_PyThreadState_declare
+    __Pyx_PyThreadState_assign
+    __Pyx_ErrFetch(&__pyx_type, &__pyx_value, &__pyx_tb);
+    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_areas.rcbuffer->pybuffer);
+    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_dets.rcbuffer->pybuffer);
+    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_order.rcbuffer->pybuffer);
+    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_scores.rcbuffer->pybuffer);
+    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_suppressed.rcbuffer->pybuffer);
+    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_x1.rcbuffer->pybuffer);
+    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_x2.rcbuffer->pybuffer);
+    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_y1.rcbuffer->pybuffer);
+    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_y2.rcbuffer->pybuffer);
+  __Pyx_ErrRestore(__pyx_type, __pyx_value, __pyx_tb);}
+  __Pyx_AddTraceback("yolact.utils.cython_nms.nms", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  goto __pyx_L2;
+  __pyx_L0:;
+  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_areas.rcbuffer->pybuffer);
+  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_dets.rcbuffer->pybuffer);
+  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_order.rcbuffer->pybuffer);
+  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_scores.rcbuffer->pybuffer);
+  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_suppressed.rcbuffer->pybuffer);
+  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_x1.rcbuffer->pybuffer);
+  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_x2.rcbuffer->pybuffer);
+  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_y1.rcbuffer->pybuffer);
+  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_y2.rcbuffer->pybuffer);
+  __pyx_L2:;
+  __Pyx_XDECREF((PyObject *)__pyx_v_x1);
+  __Pyx_XDECREF((PyObject *)__pyx_v_y1);
+  __Pyx_XDECREF((PyObject *)__pyx_v_x2);
+  __Pyx_XDECREF((PyObject *)__pyx_v_y2);
+  __Pyx_XDECREF((PyObject *)__pyx_v_scores);
+  __Pyx_XDECREF((PyObject *)__pyx_v_areas);
+  __Pyx_XDECREF((PyObject *)__pyx_v_order);
+  __Pyx_XDECREF(__pyx_v_suppressed_np);
+  __Pyx_XDECREF((PyObject *)__pyx_v_suppressed);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyMethodDef __pyx_methods[] = {
+  {0, 0, 0, 0}
 };
-#endif
 #ifndef CYTHON_SMALL_CODE
 #if defined(__clang__)
     #define CYTHON_SMALL_CODE
 #elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3))
     #define CYTHON_SMALL_CODE __attribute__((cold))
 #else
     #define CYTHON_SMALL_CODE
 #endif
 #endif
+/* #### Code section: pystring_table ### */
 
-static __Pyx_StringTabEntry __pyx_string_tab[] = {
-  {&__pyx_kp_s_Area_not_positive, __pyx_k_Area_not_positive, sizeof(__pyx_k_Area_not_positive), 0, 0, 1, 0},
-  {&__pyx_n_s_DistanceMetric, __pyx_k_DistanceMetric, sizeof(__pyx_k_DistanceMetric), 0, 0, 1, 1},
-  {&__pyx_n_s_ImportError, __pyx_k_ImportError, sizeof(__pyx_k_ImportError), 0, 0, 1, 1},
-  {&__pyx_kp_s_Invalid_intersection, __pyx_k_Invalid_intersection, sizeof(__pyx_k_Invalid_intersection), 0, 0, 1, 0},
-  {&__pyx_n_s_NotImplementedError, __pyx_k_NotImplementedError, sizeof(__pyx_k_NotImplementedError), 0, 0, 1, 1},
-  {&__pyx_kp_s_Only_handling_axis_aligned_bound, __pyx_k_Only_handling_axis_aligned_bound, sizeof(__pyx_k_Only_handling_axis_aligned_bound), 0, 0, 1, 0},
-  {&__pyx_n_s_OutlineStyle, __pyx_k_OutlineStyle, sizeof(__pyx_k_OutlineStyle), 0, 0, 1, 1},
-  {&__pyx_kp_u_Unknown_metric, __pyx_k_Unknown_metric, sizeof(__pyx_k_Unknown_metric), 0, 1, 0, 0},
-  {&__pyx_n_s_ValueError, __pyx_k_ValueError, sizeof(__pyx_k_ValueError), 0, 0, 1, 1},
-  {&__pyx_n_s_argos_constants, __pyx_k_argos_constants, sizeof(__pyx_k_argos_constants), 0, 0, 1, 1},
-  {&__pyx_n_s_array, __pyx_k_array, sizeof(__pyx_k_array), 0, 0, 1, 1},
-  {&__pyx_n_s_asanyarray, __pyx_k_asanyarray, sizeof(__pyx_k_asanyarray), 0, 0, 1, 1},
-  {&__pyx_n_s_bbox, __pyx_k_bbox, sizeof(__pyx_k_bbox), 0, 0, 1, 1},
-  {&__pyx_n_s_bboxes, __pyx_k_bboxes, sizeof(__pyx_k_bboxes), 0, 0, 1, 1},
-  {&__pyx_n_s_boxtype, __pyx_k_boxtype, sizeof(__pyx_k_boxtype), 0, 0, 1, 1},
-  {&__pyx_n_s_cline_in_traceback, __pyx_k_cline_in_traceback, sizeof(__pyx_k_cline_in_traceback), 0, 0, 1, 1},
-  {&__pyx_n_s_dtype, __pyx_k_dtype, sizeof(__pyx_k_dtype), 0, 0, 1, 1},
-  {&__pyx_n_s_enum, __pyx_k_enum, sizeof(__pyx_k_enum), 0, 0, 1, 1},
-  {&__pyx_n_s_euclidean, __pyx_k_euclidean, sizeof(__pyx_k_euclidean), 0, 0, 1, 1},
-  {&__pyx_n_s_float, __pyx_k_float, sizeof(__pyx_k_float), 0, 0, 1, 1},
-  {&__pyx_n_s_import, __pyx_k_import, sizeof(__pyx_k_import), 0, 0, 1, 1},
-  {&__pyx_n_s_int, __pyx_k_int, sizeof(__pyx_k_int), 0, 0, 1, 1},
-  {&__pyx_n_s_ios, __pyx_k_ios, sizeof(__pyx_k_ios), 0, 0, 1, 1},
-  {&__pyx_n_s_iou, __pyx_k_iou, sizeof(__pyx_k_iou), 0, 0, 1, 1},
-  {&__pyx_n_s_isinf, __pyx_k_isinf, sizeof(__pyx_k_isinf), 0, 0, 1, 1},
-  {&__pyx_n_s_isnan, __pyx_k_isnan, sizeof(__pyx_k_isnan), 0, 0, 1, 1},
-  {&__pyx_n_s_main, __pyx_k_main, sizeof(__pyx_k_main), 0, 0, 1, 1},
-  {&__pyx_n_s_max, __pyx_k_max, sizeof(__pyx_k_max), 0, 0, 1, 1},
-  {&__pyx_n_s_metric, __pyx_k_metric, sizeof(__pyx_k_metric), 0, 0, 1, 1},
-  {&__pyx_n_s_min, __pyx_k_min, sizeof(__pyx_k_min), 0, 0, 1, 1},
-  {&__pyx_n_s_name, __pyx_k_name, sizeof(__pyx_k_name), 0, 0, 1, 1},
-  {&__pyx_n_s_new_bboxes, __pyx_k_new_bboxes, sizeof(__pyx_k_new_bboxes), 0, 0, 1, 1},
-  {&__pyx_n_s_np, __pyx_k_np, sizeof(__pyx_k_np), 0, 0, 1, 1},
-  {&__pyx_n_s_numpy, __pyx_k_numpy, sizeof(__pyx_k_numpy), 0, 0, 1, 1},
-  {&__pyx_kp_s_numpy_core_multiarray_failed_to, __pyx_k_numpy_core_multiarray_failed_to, sizeof(__pyx_k_numpy_core_multiarray_failed_to), 0, 0, 1, 0},
-  {&__pyx_kp_s_numpy_core_umath_failed_to_impor, __pyx_k_numpy_core_umath_failed_to_impor, sizeof(__pyx_k_numpy_core_umath_failed_to_impor), 0, 0, 1, 0},
-  {&__pyx_n_s_p0, __pyx_k_p0, sizeof(__pyx_k_p0), 0, 0, 1, 1},
-  {&__pyx_n_s_p1, __pyx_k_p1, sizeof(__pyx_k_p1), 0, 0, 1, 1},
-  {&__pyx_n_s_ra, __pyx_k_ra, sizeof(__pyx_k_ra), 0, 0, 1, 1},
-  {&__pyx_n_s_range, __pyx_k_range, sizeof(__pyx_k_range), 0, 0, 1, 1},
-  {&__pyx_n_s_rb, __pyx_k_rb, sizeof(__pyx_k_rb), 0, 0, 1, 1},
-  {&__pyx_n_s_round, __pyx_k_round, sizeof(__pyx_k_round), 0, 0, 1, 1},
-  {&__pyx_n_s_sum, __pyx_k_sum, sizeof(__pyx_k_sum), 0, 0, 1, 1},
-  {&__pyx_n_s_test, __pyx_k_test, sizeof(__pyx_k_test), 0, 0, 1, 1},
-  {&__pyx_n_s_vstack, __pyx_k_vstack, sizeof(__pyx_k_vstack), 0, 0, 1, 1},
-  {&__pyx_n_s_zeros, __pyx_k_zeros, sizeof(__pyx_k_zeros), 0, 0, 1, 1},
-  {0, 0, 0, 0, 0, 0, 0}
-};
+static int __Pyx_CreateStringTabAndInitStrings(void) {
+  __Pyx_StringTabEntry __pyx_string_tab[] = {
+    {&__pyx_n_s_ImportError, __pyx_k_ImportError, sizeof(__pyx_k_ImportError), 0, 0, 1, 1},
+    {&__pyx_n_s__10, __pyx_k__10, sizeof(__pyx_k__10), 0, 0, 1, 1},
+    {&__pyx_n_s__13, __pyx_k__13, sizeof(__pyx_k__13), 0, 0, 1, 1},
+    {&__pyx_n_s_areas, __pyx_k_areas, sizeof(__pyx_k_areas), 0, 0, 1, 1},
+    {&__pyx_n_s_argsort, __pyx_k_argsort, sizeof(__pyx_k_argsort), 0, 0, 1, 1},
+    {&__pyx_n_s_asarray, __pyx_k_asarray, sizeof(__pyx_k_asarray), 0, 0, 1, 1},
+    {&__pyx_n_s_asyncio_coroutines, __pyx_k_asyncio_coroutines, sizeof(__pyx_k_asyncio_coroutines), 0, 0, 1, 1},
+    {&__pyx_n_s_class_getitem, __pyx_k_class_getitem, sizeof(__pyx_k_class_getitem), 0, 0, 1, 1},
+    {&__pyx_n_s_cline_in_traceback, __pyx_k_cline_in_traceback, sizeof(__pyx_k_cline_in_traceback), 0, 0, 1, 1},
+    {&__pyx_n_s_dets, __pyx_k_dets, sizeof(__pyx_k_dets), 0, 0, 1, 1},
+    {&__pyx_n_s_dtype, __pyx_k_dtype, sizeof(__pyx_k_dtype), 0, 0, 1, 1},
+    {&__pyx_n_s_h, __pyx_k_h, sizeof(__pyx_k_h), 0, 0, 1, 1},
+    {&__pyx_n_s_i, __pyx_k_i, sizeof(__pyx_k_i), 0, 0, 1, 1},
+    {&__pyx_n_s_i_2, __pyx_k_i_2, sizeof(__pyx_k_i_2), 0, 0, 1, 1},
+    {&__pyx_n_s_iarea, __pyx_k_iarea, sizeof(__pyx_k_iarea), 0, 0, 1, 1},
+    {&__pyx_n_s_import, __pyx_k_import, sizeof(__pyx_k_import), 0, 0, 1, 1},
+    {&__pyx_n_s_initializing, __pyx_k_initializing, sizeof(__pyx_k_initializing), 0, 0, 1, 1},
+    {&__pyx_n_s_int64, __pyx_k_int64, sizeof(__pyx_k_int64), 0, 0, 1, 1},
+    {&__pyx_n_s_inter, __pyx_k_inter, sizeof(__pyx_k_inter), 0, 0, 1, 1},
+    {&__pyx_n_s_is_coroutine, __pyx_k_is_coroutine, sizeof(__pyx_k_is_coroutine), 0, 0, 1, 1},
+    {&__pyx_n_s_ix1, __pyx_k_ix1, sizeof(__pyx_k_ix1), 0, 0, 1, 1},
+    {&__pyx_n_s_ix2, __pyx_k_ix2, sizeof(__pyx_k_ix2), 0, 0, 1, 1},
+    {&__pyx_n_s_iy1, __pyx_k_iy1, sizeof(__pyx_k_iy1), 0, 0, 1, 1},
+    {&__pyx_n_s_iy2, __pyx_k_iy2, sizeof(__pyx_k_iy2), 0, 0, 1, 1},
+    {&__pyx_n_s_j, __pyx_k_j, sizeof(__pyx_k_j), 0, 0, 1, 1},
+    {&__pyx_n_s_j_2, __pyx_k_j_2, sizeof(__pyx_k_j_2), 0, 0, 1, 1},
+    {&__pyx_n_s_main, __pyx_k_main, sizeof(__pyx_k_main), 0, 0, 1, 1},
+    {&__pyx_n_s_name, __pyx_k_name, sizeof(__pyx_k_name), 0, 0, 1, 1},
+    {&__pyx_n_s_ndets, __pyx_k_ndets, sizeof(__pyx_k_ndets), 0, 0, 1, 1},
+    {&__pyx_n_s_nms, __pyx_k_nms, sizeof(__pyx_k_nms), 0, 0, 1, 1},
+    {&__pyx_n_s_np, __pyx_k_np, sizeof(__pyx_k_np), 0, 0, 1, 1},
+    {&__pyx_n_s_numpy, __pyx_k_numpy, sizeof(__pyx_k_numpy), 0, 0, 1, 1},
+    {&__pyx_kp_s_numpy_core_multiarray_failed_to, __pyx_k_numpy_core_multiarray_failed_to, sizeof(__pyx_k_numpy_core_multiarray_failed_to), 0, 0, 1, 0},
+    {&__pyx_kp_s_numpy_core_umath_failed_to_impor, __pyx_k_numpy_core_umath_failed_to_impor, sizeof(__pyx_k_numpy_core_umath_failed_to_impor), 0, 0, 1, 0},
+    {&__pyx_n_s_order, __pyx_k_order, sizeof(__pyx_k_order), 0, 0, 1, 1},
+    {&__pyx_n_s_ovr, __pyx_k_ovr, sizeof(__pyx_k_ovr), 0, 0, 1, 1},
+    {&__pyx_n_s_range, __pyx_k_range, sizeof(__pyx_k_range), 0, 0, 1, 1},
+    {&__pyx_n_s_scores, __pyx_k_scores, sizeof(__pyx_k_scores), 0, 0, 1, 1},
+    {&__pyx_n_s_spec, __pyx_k_spec, sizeof(__pyx_k_spec), 0, 0, 1, 1},
+    {&__pyx_n_s_suppressed, __pyx_k_suppressed, sizeof(__pyx_k_suppressed), 0, 0, 1, 1},
+    {&__pyx_n_s_suppressed_np, __pyx_k_suppressed_np, sizeof(__pyx_k_suppressed_np), 0, 0, 1, 1},
+    {&__pyx_n_s_test, __pyx_k_test, sizeof(__pyx_k_test), 0, 0, 1, 1},
+    {&__pyx_n_s_thresh, __pyx_k_thresh, sizeof(__pyx_k_thresh), 0, 0, 1, 1},
+    {&__pyx_n_s_w, __pyx_k_w, sizeof(__pyx_k_w), 0, 0, 1, 1},
+    {&__pyx_n_s_where, __pyx_k_where, sizeof(__pyx_k_where), 0, 0, 1, 1},
+    {&__pyx_n_s_x1, __pyx_k_x1, sizeof(__pyx_k_x1), 0, 0, 1, 1},
+    {&__pyx_n_s_x2, __pyx_k_x2, sizeof(__pyx_k_x2), 0, 0, 1, 1},
+    {&__pyx_n_s_xx1, __pyx_k_xx1, sizeof(__pyx_k_xx1), 0, 0, 1, 1},
+    {&__pyx_n_s_xx2, __pyx_k_xx2, sizeof(__pyx_k_xx2), 0, 0, 1, 1},
+    {&__pyx_n_s_y1, __pyx_k_y1, sizeof(__pyx_k_y1), 0, 0, 1, 1},
+    {&__pyx_n_s_y2, __pyx_k_y2, sizeof(__pyx_k_y2), 0, 0, 1, 1},
+    {&__pyx_n_s_yolact_utils_cython_nms, __pyx_k_yolact_utils_cython_nms, sizeof(__pyx_k_yolact_utils_cython_nms), 0, 0, 1, 1},
+    {&__pyx_kp_s_yolact_utils_cython_nms_pyx, __pyx_k_yolact_utils_cython_nms_pyx, sizeof(__pyx_k_yolact_utils_cython_nms_pyx), 0, 0, 1, 0},
+    {&__pyx_n_s_yy1, __pyx_k_yy1, sizeof(__pyx_k_yy1), 0, 0, 1, 1},
+    {&__pyx_n_s_yy2, __pyx_k_yy2, sizeof(__pyx_k_yy2), 0, 0, 1, 1},
+    {&__pyx_n_s_zeros, __pyx_k_zeros, sizeof(__pyx_k_zeros), 0, 0, 1, 1},
+    {0, 0, 0, 0, 0, 0, 0}
+  };
+  return __Pyx_InitStrings(__pyx_string_tab);
+}
+/* #### Code section: cached_builtins ### */
 static CYTHON_SMALL_CODE int __Pyx_InitCachedBuiltins(void) {
-  __pyx_builtin_min = __Pyx_GetBuiltinName(__pyx_n_s_min); if (!__pyx_builtin_min) __PYX_ERR(0, 27, __pyx_L1_error)
-  __pyx_builtin_max = __Pyx_GetBuiltinName(__pyx_n_s_max); if (!__pyx_builtin_max) __PYX_ERR(0, 28, __pyx_L1_error)
-  __pyx_builtin_round = __Pyx_GetBuiltinName(__pyx_n_s_round); if (!__pyx_builtin_round) __PYX_ERR(0, 63, __pyx_L1_error)
-  __pyx_builtin_ValueError = __Pyx_GetBuiltinName(__pyx_n_s_ValueError); if (!__pyx_builtin_ValueError) __PYX_ERR(0, 131, __pyx_L1_error)
-  __pyx_builtin_range = __Pyx_GetBuiltinName(__pyx_n_s_range); if (!__pyx_builtin_range) __PYX_ERR(0, 204, __pyx_L1_error)
-  __pyx_builtin_NotImplementedError = __Pyx_GetBuiltinName(__pyx_n_s_NotImplementedError); if (!__pyx_builtin_NotImplementedError) __PYX_ERR(0, 213, __pyx_L1_error)
-  __pyx_builtin_ImportError = __Pyx_GetBuiltinName(__pyx_n_s_ImportError); if (!__pyx_builtin_ImportError) __PYX_ERR(1, 945, __pyx_L1_error)
+  __pyx_builtin_range = __Pyx_GetBuiltinName(__pyx_n_s_range); if (!__pyx_builtin_range) __PYX_ERR(0, 64, __pyx_L1_error)
+  __pyx_builtin_ImportError = __Pyx_GetBuiltinName(__pyx_n_s_ImportError); if (!__pyx_builtin_ImportError) __PYX_ERR(1, 984, __pyx_L1_error)
   return 0;
   __pyx_L1_error:;
   return -1;
 }
+/* #### Code section: cached_constants ### */
 
 static CYTHON_SMALL_CODE int __Pyx_InitCachedConstants(void) {
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__Pyx_InitCachedConstants", 0);
 
-  /* "argos/cutility.pyx":39
- *     """Convert topleft, width, height format rectangle into four anti-clockwise
- *     vertices"""
- *     return np.vstack([rect[:2],             # <<<<<<<<<<<<<<
- *                       (rect[0], rect[1] + rect[3]),
- *                       rect[:2] + rect[2:],
- */
-  __pyx_slice_ = PySlice_New(Py_None, __pyx_int_2, Py_None); if (unlikely(!__pyx_slice_)) __PYX_ERR(0, 39, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_slice_);
-  __Pyx_GIVEREF(__pyx_slice_);
-
-  /* "argos/cutility.pyx":41
- *     return np.vstack([rect[:2],
- *                       (rect[0], rect[1] + rect[3]),
- *                       rect[:2] + rect[2:],             # <<<<<<<<<<<<<<
- *                       (rect[0] + rect[2], rect[1])])
- * 
- */
-  __pyx_slice__2 = PySlice_New(__pyx_int_2, Py_None, Py_None); if (unlikely(!__pyx_slice__2)) __PYX_ERR(0, 41, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_slice__2);
-  __Pyx_GIVEREF(__pyx_slice__2);
+  /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":984
+ *         __pyx_import_array()
+ *     except Exception:
+ *         raise ImportError("numpy.core.multiarray failed to import")             # <<<<<<<<<<<<<<
+ * 
+ * cdef inline int import_umath() except -1:
+ */
+  __pyx_tuple_ = PyTuple_Pack(1, __pyx_kp_s_numpy_core_multiarray_failed_to); if (unlikely(!__pyx_tuple_)) __PYX_ERR(1, 984, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple_);
+  __Pyx_GIVEREF(__pyx_tuple_);
 
-  /* "argos/cutility.pyx":92
- *     """
- *     cdef int x, y, dx, dy
- *     cdef np.ndarray result = np.zeros((4,), dtype=np.int)             # <<<<<<<<<<<<<<
- *     x = int(max(ra[0], rb[0]))
- *     y = int(max(ra[1], rb[1]))
- */
-  __pyx_tuple__3 = PyTuple_Pack(1, __pyx_int_4); if (unlikely(!__pyx_tuple__3)) __PYX_ERR(0, 92, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__3);
-  __Pyx_GIVEREF(__pyx_tuple__3);
-  __pyx_tuple__4 = PyTuple_Pack(1, __pyx_tuple__3); if (unlikely(!__pyx_tuple__4)) __PYX_ERR(0, 92, __pyx_L1_error)
+  /* "../../../AppData/Local/Temp/build-env-dz0q5375/Lib/site-packages/numpy/__init__.cython-30.pxd":990
+ *         _import_umath()
+ *     except Exception:
+ *         raise ImportError("numpy.core.umath failed to import")             # <<<<<<<<<<<<<<
+ * 
+ * cdef inline int import_ufunc() except -1:
+ */
+  __pyx_tuple__2 = PyTuple_Pack(1, __pyx_kp_s_numpy_core_umath_failed_to_impor); if (unlikely(!__pyx_tuple__2)) __PYX_ERR(1, 990, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__2);
+  __Pyx_GIVEREF(__pyx_tuple__2);
+
+  /* "yolact/utils/cython_nms.pyx":39
+ * @cython.wraparound(False)
+ * def nms(np.ndarray[np.float32_t, ndim=2] dets, np.float32_t thresh):
+ *     cdef np.ndarray[np.float32_t, ndim=1] x1 = dets[:, 0]             # <<<<<<<<<<<<<<
+ *     cdef np.ndarray[np.float32_t, ndim=1] y1 = dets[:, 1]
+ *     cdef np.ndarray[np.float32_t, ndim=1] x2 = dets[:, 2]
+ */
+  __pyx_slice__3 = PySlice_New(Py_None, Py_None, Py_None); if (unlikely(!__pyx_slice__3)) __PYX_ERR(0, 39, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_slice__3);
+  __Pyx_GIVEREF(__pyx_slice__3);
+  __pyx_tuple__4 = PyTuple_Pack(2, __pyx_slice__3, __pyx_int_0); if (unlikely(!__pyx_tuple__4)) __PYX_ERR(0, 39, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__4);
   __Pyx_GIVEREF(__pyx_tuple__4);
 
-  /* "argos/cutility.pyx":131
- *     area_u = ra[2] * ra[3] + rb[2] * rb[3] - area_i
- *     if area_u <= 0 or area_i < 0:
- *         raise ValueError('Area not positive')             # <<<<<<<<<<<<<<
- *     ret = 1.0 * area_i / area_u
- *     if np.isinf(ret) or np.isnan(ret) or ret < 0:
+  /* "yolact/utils/cython_nms.pyx":40
+ * def nms(np.ndarray[np.float32_t, ndim=2] dets, np.float32_t thresh):
+ *     cdef np.ndarray[np.float32_t, ndim=1] x1 = dets[:, 0]
+ *     cdef np.ndarray[np.float32_t, ndim=1] y1 = dets[:, 1]             # <<<<<<<<<<<<<<
+ *     cdef np.ndarray[np.float32_t, ndim=1] x2 = dets[:, 2]
+ *     cdef np.ndarray[np.float32_t, ndim=1] y2 = dets[:, 3]
  */
-  __pyx_tuple__5 = PyTuple_Pack(1, __pyx_kp_s_Area_not_positive); if (unlikely(!__pyx_tuple__5)) __PYX_ERR(0, 131, __pyx_L1_error)
+  __pyx_tuple__5 = PyTuple_Pack(2, __pyx_slice__3, __pyx_int_1); if (unlikely(!__pyx_tuple__5)) __PYX_ERR(0, 40, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__5);
   __Pyx_GIVEREF(__pyx_tuple__5);
 
-  /* "argos/cutility.pyx":134
- *     ret = 1.0 * area_i / area_u
- *     if np.isinf(ret) or np.isnan(ret) or ret < 0:
- *         raise ValueError('Invalid intersection')             # <<<<<<<<<<<<<<
- *     return ret
- * 
+  /* "yolact/utils/cython_nms.pyx":41
+ *     cdef np.ndarray[np.float32_t, ndim=1] x1 = dets[:, 0]
+ *     cdef np.ndarray[np.float32_t, ndim=1] y1 = dets[:, 1]
+ *     cdef np.ndarray[np.float32_t, ndim=1] x2 = dets[:, 2]             # <<<<<<<<<<<<<<
+ *     cdef np.ndarray[np.float32_t, ndim=1] y2 = dets[:, 3]
+ *     cdef np.ndarray[np.float32_t, ndim=1] scores = dets[:, 4]
  */
-  __pyx_tuple__6 = PyTuple_Pack(1, __pyx_kp_s_Invalid_intersection); if (unlikely(!__pyx_tuple__6)) __PYX_ERR(0, 134, __pyx_L1_error)
+  __pyx_tuple__6 = PyTuple_Pack(2, __pyx_slice__3, __pyx_int_2); if (unlikely(!__pyx_tuple__6)) __PYX_ERR(0, 41, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__6);
   __Pyx_GIVEREF(__pyx_tuple__6);
 
-  /* "argos/cutility.pyx":202
- *     cdef np.ndarray new_centers = np.zeros((new_bboxes.shape[0], 2), dtype=np.float)
- *     if metric == DistanceMetric.euclidean:
- *         centers[:, :] = bboxes[:, :2] + bboxes[:, 2:] * 0.5             # <<<<<<<<<<<<<<
- *         new_centers = new_bboxes[:, :2] + new_bboxes[:, 2:] * 0.5
- *         for ii in range(new_bboxes.shape[0]):
- */
-  __pyx_slice__7 = PySlice_New(Py_None, Py_None, Py_None); if (unlikely(!__pyx_slice__7)) __PYX_ERR(0, 202, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_slice__7);
-  __Pyx_GIVEREF(__pyx_slice__7);
-  __pyx_tuple__8 = PyTuple_Pack(2, __pyx_slice__7, __pyx_slice_); if (unlikely(!__pyx_tuple__8)) __PYX_ERR(0, 202, __pyx_L1_error)
+  /* "yolact/utils/cython_nms.pyx":42
+ *     cdef np.ndarray[np.float32_t, ndim=1] y1 = dets[:, 1]
+ *     cdef np.ndarray[np.float32_t, ndim=1] x2 = dets[:, 2]
+ *     cdef np.ndarray[np.float32_t, ndim=1] y2 = dets[:, 3]             # <<<<<<<<<<<<<<
+ *     cdef np.ndarray[np.float32_t, ndim=1] scores = dets[:, 4]
+ * 
+ */
+  __pyx_tuple__7 = PyTuple_Pack(2, __pyx_slice__3, __pyx_int_3); if (unlikely(!__pyx_tuple__7)) __PYX_ERR(0, 42, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__7);
+  __Pyx_GIVEREF(__pyx_tuple__7);
+
+  /* "yolact/utils/cython_nms.pyx":43
+ *     cdef np.ndarray[np.float32_t, ndim=1] x2 = dets[:, 2]
+ *     cdef np.ndarray[np.float32_t, ndim=1] y2 = dets[:, 3]
+ *     cdef np.ndarray[np.float32_t, ndim=1] scores = dets[:, 4]             # <<<<<<<<<<<<<<
+ * 
+ *     cdef np.ndarray[np.float32_t, ndim=1] areas = (np.asarray(x2) - np.asarray(x1) + 1) * (np.asarray(y2) - np.asarray(y1) + 1)
+ */
+  __pyx_tuple__8 = PyTuple_Pack(2, __pyx_slice__3, __pyx_int_4); if (unlikely(!__pyx_tuple__8)) __PYX_ERR(0, 43, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__8);
   __Pyx_GIVEREF(__pyx_tuple__8);
-  __pyx_tuple__9 = PyTuple_Pack(2, __pyx_slice__7, __pyx_slice__2); if (unlikely(!__pyx_tuple__9)) __PYX_ERR(0, 202, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__9);
-  __Pyx_GIVEREF(__pyx_tuple__9);
-  __pyx_tuple__10 = PyTuple_Pack(2, __pyx_slice__7, __pyx_slice__7); if (unlikely(!__pyx_tuple__10)) __PYX_ERR(0, 202, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__10);
-  __Pyx_GIVEREF(__pyx_tuple__10);
-
-  /* "argos/cutility.pyx":213
- *                     dist[ii, jj] = 1.0 - rect_iou(bboxes[jj], new_bboxes[ii])
- *         else:
- *             raise NotImplementedError(             # <<<<<<<<<<<<<<
- *                 'Only handling axis-aligned bounding boxes')
- *     elif metric == DistanceMetric.ios:
- */
-  __pyx_tuple__11 = PyTuple_Pack(1, __pyx_kp_s_Only_handling_axis_aligned_bound); if (unlikely(!__pyx_tuple__11)) __PYX_ERR(0, 213, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__11);
-  __Pyx_GIVEREF(__pyx_tuple__11);
 
-  /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":945
- *         __pyx_import_array()
- *     except Exception:
- *         raise ImportError("numpy.core.multiarray failed to import")             # <<<<<<<<<<<<<<
+  /* "yolact/utils/cython_nms.pyx":46
  * 
- * cdef inline int import_umath() except -1:
+ *     cdef np.ndarray[np.float32_t, ndim=1] areas = (np.asarray(x2) - np.asarray(x1) + 1) * (np.asarray(y2) - np.asarray(y1) + 1)
+ *     cdef np.ndarray[np.int64_t, ndim=1] order = scores.argsort()[::-1]             # <<<<<<<<<<<<<<
+ * 
+ *     cdef size_t ndets = dets.shape[0]
  */
-  __pyx_tuple__12 = PyTuple_Pack(1, __pyx_kp_s_numpy_core_multiarray_failed_to); if (unlikely(!__pyx_tuple__12)) __PYX_ERR(1, 945, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__12);
-  __Pyx_GIVEREF(__pyx_tuple__12);
+  __pyx_slice__9 = PySlice_New(Py_None, Py_None, __pyx_int_neg_1); if (unlikely(!__pyx_slice__9)) __PYX_ERR(0, 46, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_slice__9);
+  __Pyx_GIVEREF(__pyx_slice__9);
 
-  /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":951
- *         _import_umath()
- *     except Exception:
- *         raise ImportError("numpy.core.umath failed to import")             # <<<<<<<<<<<<<<
+  /* "yolact/utils/cython_nms.pyx":35
+ *     return a if a <= b else b
  * 
- * cdef inline int import_ufunc() except -1:
+ * @cython.boundscheck(False)             # <<<<<<<<<<<<<<
+ * @cython.cdivision(True)
+ * @cython.wraparound(False)
  */
-  __pyx_tuple__13 = PyTuple_Pack(1, __pyx_kp_s_numpy_core_umath_failed_to_impor); if (unlikely(!__pyx_tuple__13)) __PYX_ERR(1, 951, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__13);
-  __Pyx_GIVEREF(__pyx_tuple__13);
+  __pyx_tuple__11 = PyTuple_Pack(29, __pyx_n_s_dets, __pyx_n_s_thresh, __pyx_n_s_x1, __pyx_n_s_y1, __pyx_n_s_x2, __pyx_n_s_y2, __pyx_n_s_scores, __pyx_n_s_areas, __pyx_n_s_order, __pyx_n_s_ndets, __pyx_n_s_suppressed_np, __pyx_n_s_suppressed, __pyx_n_s_i, __pyx_n_s_j, __pyx_n_s_i_2, __pyx_n_s_j_2, __pyx_n_s_ix1, __pyx_n_s_iy1, __pyx_n_s_ix2, __pyx_n_s_iy2, __pyx_n_s_iarea, __pyx_n_s_xx1, __pyx_n_s_yy1, __pyx_n_s_xx2, __pyx_n_s_yy2, __pyx_n_s_w, __pyx_n_s_h, __pyx_n_s_inter, __pyx_n_s_ovr); if (unlikely(!__pyx_tuple__11)) __PYX_ERR(0, 35, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__11);
+  __Pyx_GIVEREF(__pyx_tuple__11);
+  __pyx_codeobj__12 = (PyObject*)__Pyx_PyCode_New(2, 0, 0, 29, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__11, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_yolact_utils_cython_nms_pyx, __pyx_n_s_nms, 35, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__12)) __PYX_ERR(0, 35, __pyx_L1_error)
   __Pyx_RefNannyFinishContext();
   return 0;
   __pyx_L1_error:;
   __Pyx_RefNannyFinishContext();
   return -1;
 }
+/* #### Code section: init_constants ### */
 
-static CYTHON_SMALL_CODE int __Pyx_InitGlobals(void) {
-  if (__Pyx_InitStrings(__pyx_string_tab) < 0) __PYX_ERR(0, 1, __pyx_L1_error);
-  __pyx_float_0_5 = PyFloat_FromDouble(0.5); if (unlikely(!__pyx_float_0_5)) __PYX_ERR(0, 1, __pyx_L1_error)
+static CYTHON_SMALL_CODE int __Pyx_InitConstants(void) {
+  if (__Pyx_CreateStringTabAndInitStrings() < 0) __PYX_ERR(0, 1, __pyx_L1_error);
+  __pyx_int_0 = PyInt_FromLong(0); if (unlikely(!__pyx_int_0)) __PYX_ERR(0, 1, __pyx_L1_error)
+  __pyx_int_1 = PyInt_FromLong(1); if (unlikely(!__pyx_int_1)) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_int_2 = PyInt_FromLong(2); if (unlikely(!__pyx_int_2)) __PYX_ERR(0, 1, __pyx_L1_error)
+  __pyx_int_3 = PyInt_FromLong(3); if (unlikely(!__pyx_int_3)) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_int_4 = PyInt_FromLong(4); if (unlikely(!__pyx_int_4)) __PYX_ERR(0, 1, __pyx_L1_error)
+  __pyx_int_neg_1 = PyInt_FromLong(-1); if (unlikely(!__pyx_int_neg_1)) __PYX_ERR(0, 1, __pyx_L1_error)
+  return 0;
+  __pyx_L1_error:;
+  return -1;
+}
+/* #### Code section: init_globals ### */
+
+static CYTHON_SMALL_CODE int __Pyx_InitGlobals(void) {
+  /* NumpyImportArray.init */
+  /*
+ * Cython has automatically inserted a call to _import_array since
+ * you didn't include one when you cimported numpy. To disable this
+ * add the line
+ *   <void>numpy._import_array
+ */
+#ifdef NPY_FEATURE_VERSION
+#ifndef NO_IMPORT_ARRAY
+if (unlikely(_import_array() == -1)) {
+    PyErr_SetString(PyExc_ImportError, "numpy.core.multiarray failed to import "
+    "(auto-generated because you didn't call 'numpy.import_array()' after cimporting numpy; "
+    "use '<void>numpy._import_array' to disable if you are certain you don't need it).");
+}
+#endif
+#endif
+
+if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 1, __pyx_L1_error)
+
   return 0;
   __pyx_L1_error:;
   return -1;
 }
+/* #### Code section: init_module ### */
 
 static CYTHON_SMALL_CODE int __Pyx_modinit_global_init_code(void); /*proto*/
 static CYTHON_SMALL_CODE int __Pyx_modinit_variable_export_code(void); /*proto*/
 static CYTHON_SMALL_CODE int __Pyx_modinit_function_export_code(void); /*proto*/
 static CYTHON_SMALL_CODE int __Pyx_modinit_type_init_code(void); /*proto*/
 static CYTHON_SMALL_CODE int __Pyx_modinit_type_import_code(void); /*proto*/
 static CYTHON_SMALL_CODE int __Pyx_modinit_variable_import_code(void); /*proto*/
@@ -6544,55 +5896,41 @@
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__Pyx_modinit_type_import_code", 0);
   /*--- Type import code ---*/
   __pyx_t_1 = PyImport_ImportModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 9, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_ptype_7cpython_4type_type = __Pyx_ImportType(__pyx_t_1, __Pyx_BUILTIN_MODULE_NAME, "type", 
+  __pyx_ptype_7cpython_4type_type = __Pyx_ImportType_3_0_10(__pyx_t_1, __Pyx_BUILTIN_MODULE_NAME, "type", 
   #if defined(PYPY_VERSION_NUM) && PYPY_VERSION_NUM < 0x050B0000
-  sizeof(PyTypeObject),
+  sizeof(PyTypeObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_10(PyTypeObject),
+  #elif CYTHON_COMPILING_IN_LIMITED_API
+  sizeof(PyTypeObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_10(PyTypeObject),
   #else
-  sizeof(PyHeapTypeObject),
+  sizeof(PyHeapTypeObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_10(PyHeapTypeObject),
   #endif
-  __Pyx_ImportType_CheckSize_Warn);
-   if (!__pyx_ptype_7cpython_4type_type) __PYX_ERR(2, 9, __pyx_L1_error)
+  __Pyx_ImportType_CheckSize_Warn_3_0_10); if (!__pyx_ptype_7cpython_4type_type) __PYX_ERR(2, 9, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = PyImport_ImportModule("numpy"); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 200, __pyx_L1_error)
+  __pyx_t_1 = PyImport_ImportModule("numpy"); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 202, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_ptype_5numpy_dtype = __Pyx_ImportType(__pyx_t_1, "numpy", "dtype", sizeof(PyArray_Descr), __Pyx_ImportType_CheckSize_Ignore);
-   if (!__pyx_ptype_5numpy_dtype) __PYX_ERR(1, 200, __pyx_L1_error)
-  __pyx_ptype_5numpy_flatiter = __Pyx_ImportType(__pyx_t_1, "numpy", "flatiter", sizeof(PyArrayIterObject), __Pyx_ImportType_CheckSize_Ignore);
-   if (!__pyx_ptype_5numpy_flatiter) __PYX_ERR(1, 223, __pyx_L1_error)
-  __pyx_ptype_5numpy_broadcast = __Pyx_ImportType(__pyx_t_1, "numpy", "broadcast", sizeof(PyArrayMultiIterObject), __Pyx_ImportType_CheckSize_Ignore);
-   if (!__pyx_ptype_5numpy_broadcast) __PYX_ERR(1, 227, __pyx_L1_error)
-  __pyx_ptype_5numpy_ndarray = __Pyx_ImportType(__pyx_t_1, "numpy", "ndarray", sizeof(PyArrayObject), __Pyx_ImportType_CheckSize_Ignore);
-   if (!__pyx_ptype_5numpy_ndarray) __PYX_ERR(1, 239, __pyx_L1_error)
-  __pyx_ptype_5numpy_generic = __Pyx_ImportType(__pyx_t_1, "numpy", "generic", sizeof(PyObject), __Pyx_ImportType_CheckSize_Warn);
-   if (!__pyx_ptype_5numpy_generic) __PYX_ERR(1, 771, __pyx_L1_error)
-  __pyx_ptype_5numpy_number = __Pyx_ImportType(__pyx_t_1, "numpy", "number", sizeof(PyObject), __Pyx_ImportType_CheckSize_Warn);
-   if (!__pyx_ptype_5numpy_number) __PYX_ERR(1, 773, __pyx_L1_error)
-  __pyx_ptype_5numpy_integer = __Pyx_ImportType(__pyx_t_1, "numpy", "integer", sizeof(PyObject), __Pyx_ImportType_CheckSize_Warn);
-   if (!__pyx_ptype_5numpy_integer) __PYX_ERR(1, 775, __pyx_L1_error)
-  __pyx_ptype_5numpy_signedinteger = __Pyx_ImportType(__pyx_t_1, "numpy", "signedinteger", sizeof(PyObject), __Pyx_ImportType_CheckSize_Warn);
-   if (!__pyx_ptype_5numpy_signedinteger) __PYX_ERR(1, 777, __pyx_L1_error)
-  __pyx_ptype_5numpy_unsignedinteger = __Pyx_ImportType(__pyx_t_1, "numpy", "unsignedinteger", sizeof(PyObject), __Pyx_ImportType_CheckSize_Warn);
-   if (!__pyx_ptype_5numpy_unsignedinteger) __PYX_ERR(1, 779, __pyx_L1_error)
-  __pyx_ptype_5numpy_inexact = __Pyx_ImportType(__pyx_t_1, "numpy", "inexact", sizeof(PyObject), __Pyx_ImportType_CheckSize_Warn);
-   if (!__pyx_ptype_5numpy_inexact) __PYX_ERR(1, 781, __pyx_L1_error)
-  __pyx_ptype_5numpy_floating = __Pyx_ImportType(__pyx_t_1, "numpy", "floating", sizeof(PyObject), __Pyx_ImportType_CheckSize_Warn);
-   if (!__pyx_ptype_5numpy_floating) __PYX_ERR(1, 783, __pyx_L1_error)
-  __pyx_ptype_5numpy_complexfloating = __Pyx_ImportType(__pyx_t_1, "numpy", "complexfloating", sizeof(PyObject), __Pyx_ImportType_CheckSize_Warn);
-   if (!__pyx_ptype_5numpy_complexfloating) __PYX_ERR(1, 785, __pyx_L1_error)
-  __pyx_ptype_5numpy_flexible = __Pyx_ImportType(__pyx_t_1, "numpy", "flexible", sizeof(PyObject), __Pyx_ImportType_CheckSize_Warn);
-   if (!__pyx_ptype_5numpy_flexible) __PYX_ERR(1, 787, __pyx_L1_error)
-  __pyx_ptype_5numpy_character = __Pyx_ImportType(__pyx_t_1, "numpy", "character", sizeof(PyObject), __Pyx_ImportType_CheckSize_Warn);
-   if (!__pyx_ptype_5numpy_character) __PYX_ERR(1, 789, __pyx_L1_error)
-  __pyx_ptype_5numpy_ufunc = __Pyx_ImportType(__pyx_t_1, "numpy", "ufunc", sizeof(PyUFuncObject), __Pyx_ImportType_CheckSize_Ignore);
-   if (!__pyx_ptype_5numpy_ufunc) __PYX_ERR(1, 827, __pyx_L1_error)
+  __pyx_ptype_5numpy_dtype = __Pyx_ImportType_3_0_10(__pyx_t_1, "numpy", "dtype", sizeof(PyArray_Descr), __PYX_GET_STRUCT_ALIGNMENT_3_0_10(PyArray_Descr),__Pyx_ImportType_CheckSize_Ignore_3_0_10); if (!__pyx_ptype_5numpy_dtype) __PYX_ERR(1, 202, __pyx_L1_error)
+  __pyx_ptype_5numpy_flatiter = __Pyx_ImportType_3_0_10(__pyx_t_1, "numpy", "flatiter", sizeof(PyArrayIterObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_10(PyArrayIterObject),__Pyx_ImportType_CheckSize_Ignore_3_0_10); if (!__pyx_ptype_5numpy_flatiter) __PYX_ERR(1, 225, __pyx_L1_error)
+  __pyx_ptype_5numpy_broadcast = __Pyx_ImportType_3_0_10(__pyx_t_1, "numpy", "broadcast", sizeof(PyArrayMultiIterObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_10(PyArrayMultiIterObject),__Pyx_ImportType_CheckSize_Ignore_3_0_10); if (!__pyx_ptype_5numpy_broadcast) __PYX_ERR(1, 229, __pyx_L1_error)
+  __pyx_ptype_5numpy_ndarray = __Pyx_ImportType_3_0_10(__pyx_t_1, "numpy", "ndarray", sizeof(PyArrayObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_10(PyArrayObject),__Pyx_ImportType_CheckSize_Ignore_3_0_10); if (!__pyx_ptype_5numpy_ndarray) __PYX_ERR(1, 238, __pyx_L1_error)
+  __pyx_ptype_5numpy_generic = __Pyx_ImportType_3_0_10(__pyx_t_1, "numpy", "generic", sizeof(PyObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_10(PyObject),__Pyx_ImportType_CheckSize_Warn_3_0_10); if (!__pyx_ptype_5numpy_generic) __PYX_ERR(1, 809, __pyx_L1_error)
+  __pyx_ptype_5numpy_number = __Pyx_ImportType_3_0_10(__pyx_t_1, "numpy", "number", sizeof(PyObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_10(PyObject),__Pyx_ImportType_CheckSize_Warn_3_0_10); if (!__pyx_ptype_5numpy_number) __PYX_ERR(1, 811, __pyx_L1_error)
+  __pyx_ptype_5numpy_integer = __Pyx_ImportType_3_0_10(__pyx_t_1, "numpy", "integer", sizeof(PyObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_10(PyObject),__Pyx_ImportType_CheckSize_Warn_3_0_10); if (!__pyx_ptype_5numpy_integer) __PYX_ERR(1, 813, __pyx_L1_error)
+  __pyx_ptype_5numpy_signedinteger = __Pyx_ImportType_3_0_10(__pyx_t_1, "numpy", "signedinteger", sizeof(PyObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_10(PyObject),__Pyx_ImportType_CheckSize_Warn_3_0_10); if (!__pyx_ptype_5numpy_signedinteger) __PYX_ERR(1, 815, __pyx_L1_error)
+  __pyx_ptype_5numpy_unsignedinteger = __Pyx_ImportType_3_0_10(__pyx_t_1, "numpy", "unsignedinteger", sizeof(PyObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_10(PyObject),__Pyx_ImportType_CheckSize_Warn_3_0_10); if (!__pyx_ptype_5numpy_unsignedinteger) __PYX_ERR(1, 817, __pyx_L1_error)
+  __pyx_ptype_5numpy_inexact = __Pyx_ImportType_3_0_10(__pyx_t_1, "numpy", "inexact", sizeof(PyObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_10(PyObject),__Pyx_ImportType_CheckSize_Warn_3_0_10); if (!__pyx_ptype_5numpy_inexact) __PYX_ERR(1, 819, __pyx_L1_error)
+  __pyx_ptype_5numpy_floating = __Pyx_ImportType_3_0_10(__pyx_t_1, "numpy", "floating", sizeof(PyObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_10(PyObject),__Pyx_ImportType_CheckSize_Warn_3_0_10); if (!__pyx_ptype_5numpy_floating) __PYX_ERR(1, 821, __pyx_L1_error)
+  __pyx_ptype_5numpy_complexfloating = __Pyx_ImportType_3_0_10(__pyx_t_1, "numpy", "complexfloating", sizeof(PyObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_10(PyObject),__Pyx_ImportType_CheckSize_Warn_3_0_10); if (!__pyx_ptype_5numpy_complexfloating) __PYX_ERR(1, 823, __pyx_L1_error)
+  __pyx_ptype_5numpy_flexible = __Pyx_ImportType_3_0_10(__pyx_t_1, "numpy", "flexible", sizeof(PyObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_10(PyObject),__Pyx_ImportType_CheckSize_Warn_3_0_10); if (!__pyx_ptype_5numpy_flexible) __PYX_ERR(1, 825, __pyx_L1_error)
+  __pyx_ptype_5numpy_character = __Pyx_ImportType_3_0_10(__pyx_t_1, "numpy", "character", sizeof(PyObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_10(PyObject),__Pyx_ImportType_CheckSize_Warn_3_0_10); if (!__pyx_ptype_5numpy_character) __PYX_ERR(1, 827, __pyx_L1_error)
+  __pyx_ptype_5numpy_ufunc = __Pyx_ImportType_3_0_10(__pyx_t_1, "numpy", "ufunc", sizeof(PyUFuncObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_10(PyUFuncObject),__Pyx_ImportType_CheckSize_Ignore_3_0_10); if (!__pyx_ptype_5numpy_ufunc) __PYX_ERR(1, 866, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_RefNannyFinishContext();
   return 0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_RefNannyFinishContext();
   return -1;
@@ -6611,14 +5949,63 @@
   __Pyx_RefNannySetupContext("__Pyx_modinit_function_import_code", 0);
   /*--- Function import code ---*/
   __Pyx_RefNannyFinishContext();
   return 0;
 }
 
 
+#if PY_MAJOR_VERSION >= 3
+#if CYTHON_PEP489_MULTI_PHASE_INIT
+static PyObject* __pyx_pymod_create(PyObject *spec, PyModuleDef *def); /*proto*/
+static int __pyx_pymod_exec_cython_nms(PyObject* module); /*proto*/
+static PyModuleDef_Slot __pyx_moduledef_slots[] = {
+  {Py_mod_create, (void*)__pyx_pymod_create},
+  {Py_mod_exec, (void*)__pyx_pymod_exec_cython_nms},
+  {0, NULL}
+};
+#endif
+
+#ifdef __cplusplus
+namespace {
+  struct PyModuleDef __pyx_moduledef =
+  #else
+  static struct PyModuleDef __pyx_moduledef =
+  #endif
+  {
+      PyModuleDef_HEAD_INIT,
+      "cython_nms",
+      0, /* m_doc */
+    #if CYTHON_PEP489_MULTI_PHASE_INIT
+      0, /* m_size */
+    #elif CYTHON_USE_MODULE_STATE
+      sizeof(__pyx_mstate), /* m_size */
+    #else
+      -1, /* m_size */
+    #endif
+      __pyx_methods /* m_methods */,
+    #if CYTHON_PEP489_MULTI_PHASE_INIT
+      __pyx_moduledef_slots, /* m_slots */
+    #else
+      NULL, /* m_reload */
+    #endif
+    #if CYTHON_USE_MODULE_STATE
+      __pyx_m_traverse, /* m_traverse */
+      __pyx_m_clear, /* m_clear */
+      NULL /* m_free */
+    #else
+      NULL, /* m_traverse */
+      NULL, /* m_clear */
+      NULL /* m_free */
+    #endif
+  };
+  #ifdef __cplusplus
+} /* anonymous namespace */
+#endif
+#endif
+
 #ifndef CYTHON_NO_PYINIT_EXPORT
 #define __Pyx_PyMODINIT_FUNC PyMODINIT_FUNC
 #elif PY_MAJOR_VERSION < 3
 #ifdef __cplusplus
 #define __Pyx_PyMODINIT_FUNC extern "C" void
 #else
 #define __Pyx_PyMODINIT_FUNC void
@@ -6629,19 +6016,19 @@
 #else
 #define __Pyx_PyMODINIT_FUNC PyObject *
 #endif
 #endif
 
 
 #if PY_MAJOR_VERSION < 3
-__Pyx_PyMODINIT_FUNC initcutility(void) CYTHON_SMALL_CODE; /*proto*/
-__Pyx_PyMODINIT_FUNC initcutility(void)
+__Pyx_PyMODINIT_FUNC initcython_nms(void) CYTHON_SMALL_CODE; /*proto*/
+__Pyx_PyMODINIT_FUNC initcython_nms(void)
 #else
-__Pyx_PyMODINIT_FUNC PyInit_cutility(void) CYTHON_SMALL_CODE; /*proto*/
-__Pyx_PyMODINIT_FUNC PyInit_cutility(void)
+__Pyx_PyMODINIT_FUNC PyInit_cython_nms(void) CYTHON_SMALL_CODE; /*proto*/
+__Pyx_PyMODINIT_FUNC PyInit_cython_nms(void)
 #if CYTHON_PEP489_MULTI_PHASE_INIT
 {
   return PyModuleDef_Init(&__pyx_moduledef);
 }
 static CYTHON_SMALL_CODE int __Pyx_check_single_interpreter(void) {
     #if PY_VERSION_HEX >= 0x030700A1
     static PY_INT64_T main_interpreter_id = -1;
@@ -6661,257 +6048,275 @@
         PyErr_SetString(
             PyExc_ImportError,
             "Interpreter change detected - this module can only be loaded into one interpreter per process.");
         return -1;
     }
     return 0;
 }
-static CYTHON_SMALL_CODE int __Pyx_copy_spec_to_module(PyObject *spec, PyObject *moddict, const char* from_name, const char* to_name, int allow_none) {
+#if CYTHON_COMPILING_IN_LIMITED_API
+static CYTHON_SMALL_CODE int __Pyx_copy_spec_to_module(PyObject *spec, PyObject *module, const char* from_name, const char* to_name, int allow_none)
+#else
+static CYTHON_SMALL_CODE int __Pyx_copy_spec_to_module(PyObject *spec, PyObject *moddict, const char* from_name, const char* to_name, int allow_none)
+#endif
+{
     PyObject *value = PyObject_GetAttrString(spec, from_name);
     int result = 0;
     if (likely(value)) {
         if (allow_none || value != Py_None) {
+#if CYTHON_COMPILING_IN_LIMITED_API
+            result = PyModule_AddObject(module, to_name, value);
+#else
             result = PyDict_SetItemString(moddict, to_name, value);
+#endif
         }
         Py_DECREF(value);
     } else if (PyErr_ExceptionMatches(PyExc_AttributeError)) {
         PyErr_Clear();
     } else {
         result = -1;
     }
     return result;
 }
-static CYTHON_SMALL_CODE PyObject* __pyx_pymod_create(PyObject *spec, CYTHON_UNUSED PyModuleDef *def) {
+static CYTHON_SMALL_CODE PyObject* __pyx_pymod_create(PyObject *spec, PyModuleDef *def) {
     PyObject *module = NULL, *moddict, *modname;
+    CYTHON_UNUSED_VAR(def);
     if (__Pyx_check_single_interpreter())
         return NULL;
     if (__pyx_m)
         return __Pyx_NewRef(__pyx_m);
     modname = PyObject_GetAttrString(spec, "name");
     if (unlikely(!modname)) goto bad;
     module = PyModule_NewObject(modname);
     Py_DECREF(modname);
     if (unlikely(!module)) goto bad;
+#if CYTHON_COMPILING_IN_LIMITED_API
+    moddict = module;
+#else
     moddict = PyModule_GetDict(module);
     if (unlikely(!moddict)) goto bad;
+#endif
     if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "loader", "__loader__", 1) < 0)) goto bad;
     if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "origin", "__file__", 1) < 0)) goto bad;
     if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "parent", "__package__", 1) < 0)) goto bad;
     if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "submodule_search_locations", "__path__", 0) < 0)) goto bad;
     return module;
 bad:
     Py_XDECREF(module);
     return NULL;
 }
 
 
-static CYTHON_SMALL_CODE int __pyx_pymod_exec_cutility(PyObject *__pyx_pyinit_module)
+static CYTHON_SMALL_CODE int __pyx_pymod_exec_cython_nms(PyObject *__pyx_pyinit_module)
 #endif
 #endif
 {
+  int stringtab_initialized = 0;
+  #if CYTHON_USE_MODULE_STATE
+  int pystate_addmodule_run = 0;
+  #endif
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannyDeclarations
   #if CYTHON_PEP489_MULTI_PHASE_INIT
   if (__pyx_m) {
     if (__pyx_m == __pyx_pyinit_module) return 0;
-    PyErr_SetString(PyExc_RuntimeError, "Module 'cutility' has already been imported. Re-initialisation is not supported.");
+    PyErr_SetString(PyExc_RuntimeError, "Module 'cython_nms' has already been imported. Re-initialisation is not supported.");
     return -1;
   }
   #elif PY_MAJOR_VERSION >= 3
   if (__pyx_m) return __Pyx_NewRef(__pyx_m);
   #endif
+  /*--- Module creation code ---*/
+  #if CYTHON_PEP489_MULTI_PHASE_INIT
+  __pyx_m = __pyx_pyinit_module;
+  Py_INCREF(__pyx_m);
+  #else
+  #if PY_MAJOR_VERSION < 3
+  __pyx_m = Py_InitModule4("cython_nms", __pyx_methods, 0, 0, PYTHON_API_VERSION); Py_XINCREF(__pyx_m);
+  if (unlikely(!__pyx_m)) __PYX_ERR(0, 1, __pyx_L1_error)
+  #elif CYTHON_USE_MODULE_STATE
+  __pyx_t_1 = PyModule_Create(&__pyx_moduledef); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1, __pyx_L1_error)
+  {
+    int add_module_result = PyState_AddModule(__pyx_t_1, &__pyx_moduledef);
+    __pyx_t_1 = 0; /* transfer ownership from __pyx_t_1 to "cython_nms" pseudovariable */
+    if (unlikely((add_module_result < 0))) __PYX_ERR(0, 1, __pyx_L1_error)
+    pystate_addmodule_run = 1;
+  }
+  #else
+  __pyx_m = PyModule_Create(&__pyx_moduledef);
+  if (unlikely(!__pyx_m)) __PYX_ERR(0, 1, __pyx_L1_error)
+  #endif
+  #endif
+  CYTHON_UNUSED_VAR(__pyx_t_1);
+  __pyx_d = PyModule_GetDict(__pyx_m); if (unlikely(!__pyx_d)) __PYX_ERR(0, 1, __pyx_L1_error)
+  Py_INCREF(__pyx_d);
+  __pyx_b = __Pyx_PyImport_AddModuleRef(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_b)) __PYX_ERR(0, 1, __pyx_L1_error)
+  __pyx_cython_runtime = __Pyx_PyImport_AddModuleRef((const char *) "cython_runtime"); if (unlikely(!__pyx_cython_runtime)) __PYX_ERR(0, 1, __pyx_L1_error)
+  if (PyObject_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #if CYTHON_REFNANNY
 __Pyx_RefNanny = __Pyx_RefNannyImportAPI("refnanny");
 if (!__Pyx_RefNanny) {
   PyErr_Clear();
   __Pyx_RefNanny = __Pyx_RefNannyImportAPI("Cython.Runtime.refnanny");
   if (!__Pyx_RefNanny)
       Py_FatalError("failed to import 'refnanny' module");
 }
 #endif
-  __Pyx_RefNannySetupContext("__Pyx_PyMODINIT_FUNC PyInit_cutility(void)", 0);
-  if (__Pyx_check_binary_version() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  __Pyx_RefNannySetupContext("__Pyx_PyMODINIT_FUNC PyInit_cython_nms(void)", 0);
+  if (__Pyx_check_binary_version(__PYX_LIMITED_VERSION_HEX, __Pyx_get_runtime_version(), CYTHON_COMPILING_IN_LIMITED_API) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #ifdef __Pxy_PyFrame_Initialize_Offsets
   __Pxy_PyFrame_Initialize_Offsets();
   #endif
   __pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_empty_bytes = PyBytes_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_bytes)) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_empty_unicode = PyUnicode_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_unicode)) __PYX_ERR(0, 1, __pyx_L1_error)
   #ifdef __Pyx_CyFunction_USED
-  if (__pyx_CyFunction_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  if (__pyx_CyFunction_init(__pyx_m) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #endif
   #ifdef __Pyx_FusedFunction_USED
-  if (__pyx_FusedFunction_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  if (__pyx_FusedFunction_init(__pyx_m) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #endif
   #ifdef __Pyx_Coroutine_USED
-  if (__pyx_Coroutine_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  if (__pyx_Coroutine_init(__pyx_m) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #endif
   #ifdef __Pyx_Generator_USED
-  if (__pyx_Generator_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  if (__pyx_Generator_init(__pyx_m) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #endif
   #ifdef __Pyx_AsyncGen_USED
-  if (__pyx_AsyncGen_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  if (__pyx_AsyncGen_init(__pyx_m) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #endif
   #ifdef __Pyx_StopAsyncIteration_USED
-  if (__pyx_StopAsyncIteration_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  if (__pyx_StopAsyncIteration_init(__pyx_m) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #endif
   /*--- Library function declarations ---*/
   /*--- Threads initialization code ---*/
   #if defined(WITH_THREAD) && PY_VERSION_HEX < 0x030700F0 && defined(__PYX_FORCE_INIT_THREADS) && __PYX_FORCE_INIT_THREADS
   PyEval_InitThreads();
   #endif
-  /*--- Module creation code ---*/
-  #if CYTHON_PEP489_MULTI_PHASE_INIT
-  __pyx_m = __pyx_pyinit_module;
-  Py_INCREF(__pyx_m);
-  #else
-  #if PY_MAJOR_VERSION < 3
-  __pyx_m = Py_InitModule4("cutility", __pyx_methods, 0, 0, PYTHON_API_VERSION); Py_XINCREF(__pyx_m);
-  #else
-  __pyx_m = PyModule_Create(&__pyx_moduledef);
-  #endif
-  if (unlikely(!__pyx_m)) __PYX_ERR(0, 1, __pyx_L1_error)
-  #endif
-  __pyx_d = PyModule_GetDict(__pyx_m); if (unlikely(!__pyx_d)) __PYX_ERR(0, 1, __pyx_L1_error)
-  Py_INCREF(__pyx_d);
-  __pyx_b = PyImport_AddModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_b)) __PYX_ERR(0, 1, __pyx_L1_error)
-  Py_INCREF(__pyx_b);
-  __pyx_cython_runtime = PyImport_AddModule((char *) "cython_runtime"); if (unlikely(!__pyx_cython_runtime)) __PYX_ERR(0, 1, __pyx_L1_error)
-  Py_INCREF(__pyx_cython_runtime);
-  if (PyObject_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) __PYX_ERR(0, 1, __pyx_L1_error);
   /*--- Initialize various global constants etc. ---*/
+  if (__Pyx_InitConstants() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  stringtab_initialized = 1;
   if (__Pyx_InitGlobals() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #if PY_MAJOR_VERSION < 3 && (__PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT)
   if (__Pyx_init_sys_getdefaultencoding_params() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #endif
-  if (__pyx_module_is_main_argos__cutility) {
+  if (__pyx_module_is_main_yolact__utils__cython_nms) {
     if (PyObject_SetAttr(__pyx_m, __pyx_n_s_name, __pyx_n_s_main) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   }
   #if PY_MAJOR_VERSION >= 3
   {
     PyObject *modules = PyImport_GetModuleDict(); if (unlikely(!modules)) __PYX_ERR(0, 1, __pyx_L1_error)
-    if (!PyDict_GetItemString(modules, "argos.cutility")) {
-      if (unlikely(PyDict_SetItemString(modules, "argos.cutility", __pyx_m) < 0)) __PYX_ERR(0, 1, __pyx_L1_error)
+    if (!PyDict_GetItemString(modules, "yolact.utils.cython_nms")) {
+      if (unlikely((PyDict_SetItemString(modules, "yolact.utils.cython_nms", __pyx_m) < 0))) __PYX_ERR(0, 1, __pyx_L1_error)
     }
   }
   #endif
   /*--- Builtin init code ---*/
   if (__Pyx_InitCachedBuiltins() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   /*--- Constants init code ---*/
   if (__Pyx_InitCachedConstants() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   /*--- Global type/function init code ---*/
   (void)__Pyx_modinit_global_init_code();
   (void)__Pyx_modinit_variable_export_code();
   (void)__Pyx_modinit_function_export_code();
   (void)__Pyx_modinit_type_init_code();
-  if (unlikely(__Pyx_modinit_type_import_code() < 0)) __PYX_ERR(0, 1, __pyx_L1_error)
+  if (unlikely((__Pyx_modinit_type_import_code() < 0))) __PYX_ERR(0, 1, __pyx_L1_error)
   (void)__Pyx_modinit_variable_import_code();
   (void)__Pyx_modinit_function_import_code();
   /*--- Execution code ---*/
   #if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)
   if (__Pyx_patch_abc() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #endif
 
-  /* "argos/cutility.pyx":2
+  /* "yolact/utils/cython_nms.pyx":26
+ * 
  * cimport cython
  * import numpy as np             # <<<<<<<<<<<<<<
- * 
- * import enum
- */
-  __pyx_t_1 = __Pyx_Import(__pyx_n_s_numpy, 0, -1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_np, __pyx_t_1) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-
-  /* "argos/cutility.pyx":4
- * import numpy as np
- * 
- * import enum             # <<<<<<<<<<<<<<
- * 
  * cimport numpy as np
+ * 
  */
-  __pyx_t_1 = __Pyx_Import(__pyx_n_s_enum, 0, -1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_enum, __pyx_t_1) < 0) __PYX_ERR(0, 4, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_2 = __Pyx_ImportDottedModule(__pyx_n_s_numpy, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 26, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_np, __pyx_t_2) < 0) __PYX_ERR(0, 26, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "argos/cutility.pyx":8
- * cimport numpy as np
- * 
- * from argos.constants import OutlineStyle, DistanceMetric             # <<<<<<<<<<<<<<
- * 
+  /* "yolact/utils/cython_nms.pyx":35
+ *     return a if a <= b else b
  * 
+ * @cython.boundscheck(False)             # <<<<<<<<<<<<<<
+ * @cython.cdivision(True)
+ * @cython.wraparound(False)
  */
-  __pyx_t_1 = PyList_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 8, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_INCREF(__pyx_n_s_OutlineStyle);
-  __Pyx_GIVEREF(__pyx_n_s_OutlineStyle);
-  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_OutlineStyle);
-  __Pyx_INCREF(__pyx_n_s_DistanceMetric);
-  __Pyx_GIVEREF(__pyx_n_s_DistanceMetric);
-  PyList_SET_ITEM(__pyx_t_1, 1, __pyx_n_s_DistanceMetric);
-  __pyx_t_2 = __Pyx_Import(__pyx_n_s_argos_constants, __pyx_t_1, -1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 8, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_6yolact_5utils_10cython_nms_1nms, 0, __pyx_n_s_nms, NULL, __pyx_n_s_yolact_utils_cython_nms, __pyx_d, ((PyObject *)__pyx_codeobj__12)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 35, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_OutlineStyle); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 8, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_OutlineStyle, __pyx_t_1) < 0) __PYX_ERR(0, 8, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_DistanceMetric); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 8, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_DistanceMetric, __pyx_t_1) < 0) __PYX_ERR(0, 8, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_nms, __pyx_t_2) < 0) __PYX_ERR(0, 35, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "argos/cutility.pyx":1
- * cimport cython             # <<<<<<<<<<<<<<
- * import numpy as np
- * 
+  /* "yolact/utils/cython_nms.pyx":1
+ * ## Note: Figure out the license details later.             # <<<<<<<<<<<<<<
+ * #
+ * # Based on:
  */
   __pyx_t_2 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   if (PyDict_SetItem(__pyx_d, __pyx_n_s_test, __pyx_t_2) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "../../../AppData/Local/Temp/build-env-e1goy0pt/lib/site-packages/numpy/__init__.pxd":1014
- * 
- * 
- * cdef inline NPY_DATETIMEUNIT get_datetime64_unit(object obj) nogil:             # <<<<<<<<<<<<<<
- *     """
- *     returns the unit part of the dtype for a numpy datetime64 object.
- */
-
   /*--- Wrapped vars code ---*/
 
   goto __pyx_L0;
   __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_2);
   if (__pyx_m) {
-    if (__pyx_d) {
-      __Pyx_AddTraceback("init argos.cutility", __pyx_clineno, __pyx_lineno, __pyx_filename);
+    if (__pyx_d && stringtab_initialized) {
+      __Pyx_AddTraceback("init yolact.utils.cython_nms", __pyx_clineno, __pyx_lineno, __pyx_filename);
     }
+    #if !CYTHON_USE_MODULE_STATE
     Py_CLEAR(__pyx_m);
+    #else
+    Py_DECREF(__pyx_m);
+    if (pystate_addmodule_run) {
+      PyObject *tp, *value, *tb;
+      PyErr_Fetch(&tp, &value, &tb);
+      PyState_RemoveModule(&__pyx_moduledef);
+      PyErr_Restore(tp, value, tb);
+    }
+    #endif
   } else if (!PyErr_Occurred()) {
-    PyErr_SetString(PyExc_ImportError, "init argos.cutility");
+    PyErr_SetString(PyExc_ImportError, "init yolact.utils.cython_nms");
   }
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   #if CYTHON_PEP489_MULTI_PHASE_INIT
   return (__pyx_m != NULL) ? 0 : -1;
   #elif PY_MAJOR_VERSION >= 3
   return __pyx_m;
   #else
   return;
   #endif
 }
+/* #### Code section: cleanup_globals ### */
+/* #### Code section: cleanup_module ### */
+/* #### Code section: main_method ### */
+/* #### Code section: utility_code_pragmas ### */
+#ifdef _MSC_VER
+#pragma warning( push )
+/* Warning 4127: conditional expression is constant
+ * Cython uses constant conditional expressions to allow in inline functions to be optimized at
+ * compile-time, so this warning is not useful
+ */
+#pragma warning( disable : 4127 )
+#endif
+
+
+
+/* #### Code section: utility_code_def ### */
 
 /* --- Runtime support code --- */
 /* Refnanny */
 #if CYTHON_REFNANNY
 static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname) {
     PyObject *m = NULL, *p = NULL;
     void *r = NULL;
@@ -6923,453 +6328,760 @@
 end:
     Py_XDECREF(p);
     Py_XDECREF(m);
     return (__Pyx_RefNannyAPIStruct *)r;
 }
 #endif
 
+/* PyErrExceptionMatches */
+#if CYTHON_FAST_THREAD_STATE
+static int __Pyx_PyErr_ExceptionMatchesTuple(PyObject *exc_type, PyObject *tuple) {
+    Py_ssize_t i, n;
+    n = PyTuple_GET_SIZE(tuple);
+#if PY_MAJOR_VERSION >= 3
+    for (i=0; i<n; i++) {
+        if (exc_type == PyTuple_GET_ITEM(tuple, i)) return 1;
+    }
+#endif
+    for (i=0; i<n; i++) {
+        if (__Pyx_PyErr_GivenExceptionMatches(exc_type, PyTuple_GET_ITEM(tuple, i))) return 1;
+    }
+    return 0;
+}
+static CYTHON_INLINE int __Pyx_PyErr_ExceptionMatchesInState(PyThreadState* tstate, PyObject* err) {
+    int result;
+    PyObject *exc_type;
+#if PY_VERSION_HEX >= 0x030C00A6
+    PyObject *current_exception = tstate->current_exception;
+    if (unlikely(!current_exception)) return 0;
+    exc_type = (PyObject*) Py_TYPE(current_exception);
+    if (exc_type == err) return 1;
+#else
+    exc_type = tstate->curexc_type;
+    if (exc_type == err) return 1;
+    if (unlikely(!exc_type)) return 0;
+#endif
+    #if CYTHON_AVOID_BORROWED_REFS
+    Py_INCREF(exc_type);
+    #endif
+    if (unlikely(PyTuple_Check(err))) {
+        result = __Pyx_PyErr_ExceptionMatchesTuple(exc_type, err);
+    } else {
+        result = __Pyx_PyErr_GivenExceptionMatches(exc_type, err);
+    }
+    #if CYTHON_AVOID_BORROWED_REFS
+    Py_DECREF(exc_type);
+    #endif
+    return result;
+}
+#endif
+
+/* PyErrFetchRestore */
+#if CYTHON_FAST_THREAD_STATE
+static CYTHON_INLINE void __Pyx_ErrRestoreInState(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb) {
+#if PY_VERSION_HEX >= 0x030C00A6
+    PyObject *tmp_value;
+    assert(type == NULL || (value != NULL && type == (PyObject*) Py_TYPE(value)));
+    if (value) {
+        #if CYTHON_COMPILING_IN_CPYTHON
+        if (unlikely(((PyBaseExceptionObject*) value)->traceback != tb))
+        #endif
+            PyException_SetTraceback(value, tb);
+    }
+    tmp_value = tstate->current_exception;
+    tstate->current_exception = value;
+    Py_XDECREF(tmp_value);
+    Py_XDECREF(type);
+    Py_XDECREF(tb);
+#else
+    PyObject *tmp_type, *tmp_value, *tmp_tb;
+    tmp_type = tstate->curexc_type;
+    tmp_value = tstate->curexc_value;
+    tmp_tb = tstate->curexc_traceback;
+    tstate->curexc_type = type;
+    tstate->curexc_value = value;
+    tstate->curexc_traceback = tb;
+    Py_XDECREF(tmp_type);
+    Py_XDECREF(tmp_value);
+    Py_XDECREF(tmp_tb);
+#endif
+}
+static CYTHON_INLINE void __Pyx_ErrFetchInState(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
+#if PY_VERSION_HEX >= 0x030C00A6
+    PyObject* exc_value;
+    exc_value = tstate->current_exception;
+    tstate->current_exception = 0;
+    *value = exc_value;
+    *type = NULL;
+    *tb = NULL;
+    if (exc_value) {
+        *type = (PyObject*) Py_TYPE(exc_value);
+        Py_INCREF(*type);
+        #if CYTHON_COMPILING_IN_CPYTHON
+        *tb = ((PyBaseExceptionObject*) exc_value)->traceback;
+        Py_XINCREF(*tb);
+        #else
+        *tb = PyException_GetTraceback(exc_value);
+        #endif
+    }
+#else
+    *type = tstate->curexc_type;
+    *value = tstate->curexc_value;
+    *tb = tstate->curexc_traceback;
+    tstate->curexc_type = 0;
+    tstate->curexc_value = 0;
+    tstate->curexc_traceback = 0;
+#endif
+}
+#endif
+
 /* PyObjectGetAttrStr */
 #if CYTHON_USE_TYPE_SLOTS
 static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStr(PyObject* obj, PyObject* attr_name) {
     PyTypeObject* tp = Py_TYPE(obj);
     if (likely(tp->tp_getattro))
         return tp->tp_getattro(obj, attr_name);
 #if PY_MAJOR_VERSION < 3
     if (likely(tp->tp_getattr))
         return tp->tp_getattr(obj, PyString_AS_STRING(attr_name));
 #endif
     return PyObject_GetAttr(obj, attr_name);
 }
 #endif
 
+/* PyObjectGetAttrStrNoError */
+#if __PYX_LIMITED_VERSION_HEX < 0x030d00A1
+static void __Pyx_PyObject_GetAttrStr_ClearAttributeError(void) {
+    __Pyx_PyThreadState_declare
+    __Pyx_PyThreadState_assign
+    if (likely(__Pyx_PyErr_ExceptionMatches(PyExc_AttributeError)))
+        __Pyx_PyErr_Clear();
+}
+#endif
+static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStrNoError(PyObject* obj, PyObject* attr_name) {
+    PyObject *result;
+#if __PYX_LIMITED_VERSION_HEX >= 0x030d00A1
+    (void) PyObject_GetOptionalAttr(obj, attr_name, &result);
+    return result;
+#else
+#if CYTHON_COMPILING_IN_CPYTHON && CYTHON_USE_TYPE_SLOTS && PY_VERSION_HEX >= 0x030700B1
+    PyTypeObject* tp = Py_TYPE(obj);
+    if (likely(tp->tp_getattro == PyObject_GenericGetAttr)) {
+        return _PyObject_GenericGetAttrWithDict(obj, attr_name, NULL, 1);
+    }
+#endif
+    result = __Pyx_PyObject_GetAttrStr(obj, attr_name);
+    if (unlikely(!result)) {
+        __Pyx_PyObject_GetAttrStr_ClearAttributeError();
+    }
+    return result;
+#endif
+}
+
 /* GetBuiltinName */
 static PyObject *__Pyx_GetBuiltinName(PyObject *name) {
-    PyObject* result = __Pyx_PyObject_GetAttrStr(__pyx_b, name);
-    if (unlikely(!result)) {
+    PyObject* result = __Pyx_PyObject_GetAttrStrNoError(__pyx_b, name);
+    if (unlikely(!result) && !PyErr_Occurred()) {
         PyErr_Format(PyExc_NameError,
 #if PY_MAJOR_VERSION >= 3
             "name '%U' is not defined", name);
 #else
             "name '%.200s' is not defined", PyString_AS_STRING(name));
 #endif
     }
     return result;
 }
 
-/* GetItemInt */
-static PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j) {
-    PyObject *r;
-    if (!j) return NULL;
-    r = PyObject_GetItem(o, j);
-    Py_DECREF(j);
-    return r;
-}
-static CYTHON_INLINE PyObject *__Pyx_GetItemInt_List_Fast(PyObject *o, Py_ssize_t i,
-                                                              CYTHON_NCP_UNUSED int wraparound,
-                                                              CYTHON_NCP_UNUSED int boundscheck) {
-#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-    Py_ssize_t wrapped_i = i;
-    if (wraparound & unlikely(i < 0)) {
-        wrapped_i += PyList_GET_SIZE(o);
-    }
-    if ((!boundscheck) || likely(__Pyx_is_valid_index(wrapped_i, PyList_GET_SIZE(o)))) {
-        PyObject *r = PyList_GET_ITEM(o, wrapped_i);
-        Py_INCREF(r);
-        return r;
+/* GetTopmostException */
+#if CYTHON_USE_EXC_INFO_STACK && CYTHON_FAST_THREAD_STATE
+static _PyErr_StackItem *
+__Pyx_PyErr_GetTopmostException(PyThreadState *tstate)
+{
+    _PyErr_StackItem *exc_info = tstate->exc_info;
+    while ((exc_info->exc_value == NULL || exc_info->exc_value == Py_None) &&
+           exc_info->previous_item != NULL)
+    {
+        exc_info = exc_info->previous_item;
     }
-    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
-#else
-    return PySequence_GetItem(o, i);
-#endif
+    return exc_info;
 }
-static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i,
-                                                              CYTHON_NCP_UNUSED int wraparound,
-                                                              CYTHON_NCP_UNUSED int boundscheck) {
-#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-    Py_ssize_t wrapped_i = i;
-    if (wraparound & unlikely(i < 0)) {
-        wrapped_i += PyTuple_GET_SIZE(o);
-    }
-    if ((!boundscheck) || likely(__Pyx_is_valid_index(wrapped_i, PyTuple_GET_SIZE(o)))) {
-        PyObject *r = PyTuple_GET_ITEM(o, wrapped_i);
-        Py_INCREF(r);
-        return r;
-    }
-    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
-#else
-    return PySequence_GetItem(o, i);
 #endif
-}
-static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i, int is_list,
-                                                     CYTHON_NCP_UNUSED int wraparound,
-                                                     CYTHON_NCP_UNUSED int boundscheck) {
-#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS && CYTHON_USE_TYPE_SLOTS
-    if (is_list || PyList_CheckExact(o)) {
-        Py_ssize_t n = ((!wraparound) | likely(i >= 0)) ? i : i + PyList_GET_SIZE(o);
-        if ((!boundscheck) || (likely(__Pyx_is_valid_index(n, PyList_GET_SIZE(o))))) {
-            PyObject *r = PyList_GET_ITEM(o, n);
-            Py_INCREF(r);
-            return r;
-        }
-    }
-    else if (PyTuple_CheckExact(o)) {
-        Py_ssize_t n = ((!wraparound) | likely(i >= 0)) ? i : i + PyTuple_GET_SIZE(o);
-        if ((!boundscheck) || likely(__Pyx_is_valid_index(n, PyTuple_GET_SIZE(o)))) {
-            PyObject *r = PyTuple_GET_ITEM(o, n);
-            Py_INCREF(r);
-            return r;
-        }
-    } else {
-        PySequenceMethods *m = Py_TYPE(o)->tp_as_sequence;
-        if (likely(m && m->sq_item)) {
-            if (wraparound && unlikely(i < 0) && likely(m->sq_length)) {
-                Py_ssize_t l = m->sq_length(o);
-                if (likely(l >= 0)) {
-                    i += l;
-                } else {
-                    if (!PyErr_ExceptionMatches(PyExc_OverflowError))
-                        return NULL;
-                    PyErr_Clear();
-                }
-            }
-            return m->sq_item(o, i);
-        }
-    }
-#else
-    if (is_list || PySequence_Check(o)) {
-        return PySequence_GetItem(o, i);
-    }
-#endif
-    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
-}
 
-/* PyCFunctionFastCall */
-#if CYTHON_FAST_PYCCALL
-static CYTHON_INLINE PyObject * __Pyx_PyCFunction_FastCall(PyObject *func_obj, PyObject **args, Py_ssize_t nargs) {
-    PyCFunctionObject *func = (PyCFunctionObject*)func_obj;
-    PyCFunction meth = PyCFunction_GET_FUNCTION(func);
-    PyObject *self = PyCFunction_GET_SELF(func);
-    int flags = PyCFunction_GET_FLAGS(func);
-    assert(PyCFunction_Check(func));
-    assert(METH_FASTCALL == (flags & ~(METH_CLASS | METH_STATIC | METH_COEXIST | METH_KEYWORDS | METH_STACKLESS)));
-    assert(nargs >= 0);
-    assert(nargs == 0 || args != NULL);
-    /* _PyCFunction_FastCallDict() must not be called with an exception set,
-       because it may clear it (directly or indirectly) and so the
-       caller loses its exception */
-    assert(!PyErr_Occurred());
-    if ((PY_VERSION_HEX < 0x030700A0) || unlikely(flags & METH_KEYWORDS)) {
-        return (*((__Pyx_PyCFunctionFastWithKeywords)(void*)meth)) (self, args, nargs, NULL);
+/* SaveResetException */
+#if CYTHON_FAST_THREAD_STATE
+static CYTHON_INLINE void __Pyx__ExceptionSave(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
+  #if CYTHON_USE_EXC_INFO_STACK && PY_VERSION_HEX >= 0x030B00a4
+    _PyErr_StackItem *exc_info = __Pyx_PyErr_GetTopmostException(tstate);
+    PyObject *exc_value = exc_info->exc_value;
+    if (exc_value == NULL || exc_value == Py_None) {
+        *value = NULL;
+        *type = NULL;
+        *tb = NULL;
     } else {
-        return (*((__Pyx_PyCFunctionFast)(void*)meth)) (self, args, nargs);
+        *value = exc_value;
+        Py_INCREF(*value);
+        *type = (PyObject*) Py_TYPE(exc_value);
+        Py_INCREF(*type);
+        *tb = PyException_GetTraceback(exc_value);
     }
+  #elif CYTHON_USE_EXC_INFO_STACK
+    _PyErr_StackItem *exc_info = __Pyx_PyErr_GetTopmostException(tstate);
+    *type = exc_info->exc_type;
+    *value = exc_info->exc_value;
+    *tb = exc_info->exc_traceback;
+    Py_XINCREF(*type);
+    Py_XINCREF(*value);
+    Py_XINCREF(*tb);
+  #else
+    *type = tstate->exc_type;
+    *value = tstate->exc_value;
+    *tb = tstate->exc_traceback;
+    Py_XINCREF(*type);
+    Py_XINCREF(*value);
+    Py_XINCREF(*tb);
+  #endif
+}
+static CYTHON_INLINE void __Pyx__ExceptionReset(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb) {
+  #if CYTHON_USE_EXC_INFO_STACK && PY_VERSION_HEX >= 0x030B00a4
+    _PyErr_StackItem *exc_info = tstate->exc_info;
+    PyObject *tmp_value = exc_info->exc_value;
+    exc_info->exc_value = value;
+    Py_XDECREF(tmp_value);
+    Py_XDECREF(type);
+    Py_XDECREF(tb);
+  #else
+    PyObject *tmp_type, *tmp_value, *tmp_tb;
+    #if CYTHON_USE_EXC_INFO_STACK
+    _PyErr_StackItem *exc_info = tstate->exc_info;
+    tmp_type = exc_info->exc_type;
+    tmp_value = exc_info->exc_value;
+    tmp_tb = exc_info->exc_traceback;
+    exc_info->exc_type = type;
+    exc_info->exc_value = value;
+    exc_info->exc_traceback = tb;
+    #else
+    tmp_type = tstate->exc_type;
+    tmp_value = tstate->exc_value;
+    tmp_tb = tstate->exc_traceback;
+    tstate->exc_type = type;
+    tstate->exc_value = value;
+    tstate->exc_traceback = tb;
+    #endif
+    Py_XDECREF(tmp_type);
+    Py_XDECREF(tmp_value);
+    Py_XDECREF(tmp_tb);
+  #endif
 }
 #endif
 
-/* PyFunctionFastCall */
-#if CYTHON_FAST_PYCALL
-static PyObject* __Pyx_PyFunction_FastCallNoKw(PyCodeObject *co, PyObject **args, Py_ssize_t na,
-                                               PyObject *globals) {
-    PyFrameObject *f;
-    PyThreadState *tstate = __Pyx_PyThreadState_Current;
-    PyObject **fastlocals;
-    Py_ssize_t i;
-    PyObject *result;
-    assert(globals != NULL);
-    /* XXX Perhaps we should create a specialized
-       PyFrame_New() that doesn't take locals, but does
-       take builtins without sanity checking them.
-       */
-    assert(tstate != NULL);
-    f = PyFrame_New(tstate, co, globals, NULL);
-    if (f == NULL) {
-        return NULL;
-    }
-    fastlocals = __Pyx_PyFrame_GetLocalsplus(f);
-    for (i = 0; i < na; i++) {
-        Py_INCREF(*args);
-        fastlocals[i] = *args++;
-    }
-    result = PyEval_EvalFrameEx(f,0);
-    ++tstate->recursion_depth;
-    Py_DECREF(f);
-    --tstate->recursion_depth;
-    return result;
-}
-#if 1 || PY_VERSION_HEX < 0x030600B1
-static PyObject *__Pyx_PyFunction_FastCallDict(PyObject *func, PyObject **args, Py_ssize_t nargs, PyObject *kwargs) {
-    PyCodeObject *co = (PyCodeObject *)PyFunction_GET_CODE(func);
-    PyObject *globals = PyFunction_GET_GLOBALS(func);
-    PyObject *argdefs = PyFunction_GET_DEFAULTS(func);
-    PyObject *closure;
-#if PY_MAJOR_VERSION >= 3
-    PyObject *kwdefs;
+/* GetException */
+#if CYTHON_FAST_THREAD_STATE
+static int __Pyx__GetException(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb)
+#else
+static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb)
 #endif
-    PyObject *kwtuple, **k;
-    PyObject **d;
-    Py_ssize_t nd;
-    Py_ssize_t nk;
-    PyObject *result;
-    assert(kwargs == NULL || PyDict_Check(kwargs));
-    nk = kwargs ? PyDict_Size(kwargs) : 0;
-    if (Py_EnterRecursiveCall((char*)" while calling a Python object")) {
-        return NULL;
+{
+    PyObject *local_type = NULL, *local_value, *local_tb = NULL;
+#if CYTHON_FAST_THREAD_STATE
+    PyObject *tmp_type, *tmp_value, *tmp_tb;
+  #if PY_VERSION_HEX >= 0x030C00A6
+    local_value = tstate->current_exception;
+    tstate->current_exception = 0;
+    if (likely(local_value)) {
+        local_type = (PyObject*) Py_TYPE(local_value);
+        Py_INCREF(local_type);
+        local_tb = PyException_GetTraceback(local_value);
     }
-    if (
-#if PY_MAJOR_VERSION >= 3
-            co->co_kwonlyargcount == 0 &&
+  #else
+    local_type = tstate->curexc_type;
+    local_value = tstate->curexc_value;
+    local_tb = tstate->curexc_traceback;
+    tstate->curexc_type = 0;
+    tstate->curexc_value = 0;
+    tstate->curexc_traceback = 0;
+  #endif
+#else
+    PyErr_Fetch(&local_type, &local_value, &local_tb);
 #endif
-            likely(kwargs == NULL || nk == 0) &&
-            co->co_flags == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE)) {
-        if (argdefs == NULL && co->co_argcount == nargs) {
-            result = __Pyx_PyFunction_FastCallNoKw(co, args, nargs, globals);
-            goto done;
-        }
-        else if (nargs == 0 && argdefs != NULL
-                 && co->co_argcount == Py_SIZE(argdefs)) {
-            /* function called with no arguments, but all parameters have
-               a default value: use default values as arguments .*/
-            args = &PyTuple_GET_ITEM(argdefs, 0);
-            result =__Pyx_PyFunction_FastCallNoKw(co, args, Py_SIZE(argdefs), globals);
-            goto done;
-        }
-    }
-    if (kwargs != NULL) {
-        Py_ssize_t pos, i;
-        kwtuple = PyTuple_New(2 * nk);
-        if (kwtuple == NULL) {
-            result = NULL;
-            goto done;
-        }
-        k = &PyTuple_GET_ITEM(kwtuple, 0);
-        pos = i = 0;
-        while (PyDict_Next(kwargs, &pos, &k[i], &k[i+1])) {
-            Py_INCREF(k[i]);
-            Py_INCREF(k[i+1]);
-            i += 2;
-        }
-        nk = i / 2;
-    }
-    else {
-        kwtuple = NULL;
-        k = NULL;
-    }
-    closure = PyFunction_GET_CLOSURE(func);
-#if PY_MAJOR_VERSION >= 3
-    kwdefs = PyFunction_GET_KW_DEFAULTS(func);
+    PyErr_NormalizeException(&local_type, &local_value, &local_tb);
+#if CYTHON_FAST_THREAD_STATE && PY_VERSION_HEX >= 0x030C00A6
+    if (unlikely(tstate->current_exception))
+#elif CYTHON_FAST_THREAD_STATE
+    if (unlikely(tstate->curexc_type))
+#else
+    if (unlikely(PyErr_Occurred()))
 #endif
-    if (argdefs != NULL) {
-        d = &PyTuple_GET_ITEM(argdefs, 0);
-        nd = Py_SIZE(argdefs);
+        goto bad;
+    #if PY_MAJOR_VERSION >= 3
+    if (local_tb) {
+        if (unlikely(PyException_SetTraceback(local_value, local_tb) < 0))
+            goto bad;
     }
-    else {
-        d = NULL;
-        nd = 0;
+    #endif
+    Py_XINCREF(local_tb);
+    Py_XINCREF(local_type);
+    Py_XINCREF(local_value);
+    *type = local_type;
+    *value = local_value;
+    *tb = local_tb;
+#if CYTHON_FAST_THREAD_STATE
+    #if CYTHON_USE_EXC_INFO_STACK
+    {
+        _PyErr_StackItem *exc_info = tstate->exc_info;
+      #if PY_VERSION_HEX >= 0x030B00a4
+        tmp_value = exc_info->exc_value;
+        exc_info->exc_value = local_value;
+        tmp_type = NULL;
+        tmp_tb = NULL;
+        Py_XDECREF(local_type);
+        Py_XDECREF(local_tb);
+      #else
+        tmp_type = exc_info->exc_type;
+        tmp_value = exc_info->exc_value;
+        tmp_tb = exc_info->exc_traceback;
+        exc_info->exc_type = local_type;
+        exc_info->exc_value = local_value;
+        exc_info->exc_traceback = local_tb;
+      #endif
     }
-#if PY_MAJOR_VERSION >= 3
-    result = PyEval_EvalCodeEx((PyObject*)co, globals, (PyObject *)NULL,
-                               args, (int)nargs,
-                               k, (int)nk,
-                               d, (int)nd, kwdefs, closure);
+    #else
+    tmp_type = tstate->exc_type;
+    tmp_value = tstate->exc_value;
+    tmp_tb = tstate->exc_traceback;
+    tstate->exc_type = local_type;
+    tstate->exc_value = local_value;
+    tstate->exc_traceback = local_tb;
+    #endif
+    Py_XDECREF(tmp_type);
+    Py_XDECREF(tmp_value);
+    Py_XDECREF(tmp_tb);
 #else
-    result = PyEval_EvalCodeEx(co, globals, (PyObject *)NULL,
-                               args, (int)nargs,
-                               k, (int)nk,
-                               d, (int)nd, closure);
+    PyErr_SetExcInfo(local_type, local_value, local_tb);
 #endif
-    Py_XDECREF(kwtuple);
-done:
-    Py_LeaveRecursiveCall();
-    return result;
+    return 0;
+bad:
+    *type = 0;
+    *value = 0;
+    *tb = 0;
+    Py_XDECREF(local_type);
+    Py_XDECREF(local_value);
+    Py_XDECREF(local_tb);
+    return -1;
 }
-#endif
-#endif
 
 /* PyObjectCall */
 #if CYTHON_COMPILING_IN_CPYTHON
 static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw) {
     PyObject *result;
     ternaryfunc call = Py_TYPE(func)->tp_call;
     if (unlikely(!call))
         return PyObject_Call(func, arg, kw);
+    #if PY_MAJOR_VERSION < 3
     if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
         return NULL;
+    #else
+    if (unlikely(Py_EnterRecursiveCall(" while calling a Python object")))
+        return NULL;
+    #endif
     result = (*call)(func, arg, kw);
     Py_LeaveRecursiveCall();
     if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
         PyErr_SetString(
             PyExc_SystemError,
             "NULL result without error in PyObject_Call");
     }
     return result;
 }
 #endif
 
-/* PyObjectCallMethO */
-#if CYTHON_COMPILING_IN_CPYTHON
-static CYTHON_INLINE PyObject* __Pyx_PyObject_CallMethO(PyObject *func, PyObject *arg) {
-    PyObject *self, *result;
-    PyCFunction cfunc;
-    cfunc = PyCFunction_GET_FUNCTION(func);
-    self = PyCFunction_GET_SELF(func);
-    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
-        return NULL;
-    result = cfunc(self, arg);
-    Py_LeaveRecursiveCall();
-    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
-        PyErr_SetString(
-            PyExc_SystemError,
-            "NULL result without error in PyObject_Call");
+/* RaiseException */
+#if PY_MAJOR_VERSION < 3
+static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause) {
+    __Pyx_PyThreadState_declare
+    CYTHON_UNUSED_VAR(cause);
+    Py_XINCREF(type);
+    if (!value || value == Py_None)
+        value = NULL;
+    else
+        Py_INCREF(value);
+    if (!tb || tb == Py_None)
+        tb = NULL;
+    else {
+        Py_INCREF(tb);
+        if (!PyTraceBack_Check(tb)) {
+            PyErr_SetString(PyExc_TypeError,
+                "raise: arg 3 must be a traceback or None");
+            goto raise_error;
+        }
     }
-    return result;
-}
+    if (PyType_Check(type)) {
+#if CYTHON_COMPILING_IN_PYPY
+        if (!value) {
+            Py_INCREF(Py_None);
+            value = Py_None;
+        }
 #endif
-
-/* PyObjectCallOneArg */
-#if CYTHON_COMPILING_IN_CPYTHON
-static PyObject* __Pyx__PyObject_CallOneArg(PyObject *func, PyObject *arg) {
-    PyObject *result;
-    PyObject *args = PyTuple_New(1);
-    if (unlikely(!args)) return NULL;
-    Py_INCREF(arg);
-    PyTuple_SET_ITEM(args, 0, arg);
-    result = __Pyx_PyObject_Call(func, args, NULL);
-    Py_DECREF(args);
-    return result;
+        PyErr_NormalizeException(&type, &value, &tb);
+    } else {
+        if (value) {
+            PyErr_SetString(PyExc_TypeError,
+                "instance exception may not have a separate value");
+            goto raise_error;
+        }
+        value = type;
+        type = (PyObject*) Py_TYPE(type);
+        Py_INCREF(type);
+        if (!PyType_IsSubtype((PyTypeObject *)type, (PyTypeObject *)PyExc_BaseException)) {
+            PyErr_SetString(PyExc_TypeError,
+                "raise: exception class must be a subclass of BaseException");
+            goto raise_error;
+        }
+    }
+    __Pyx_PyThreadState_assign
+    __Pyx_ErrRestore(type, value, tb);
+    return;
+raise_error:
+    Py_XDECREF(value);
+    Py_XDECREF(type);
+    Py_XDECREF(tb);
+    return;
 }
-static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg) {
-#if CYTHON_FAST_PYCALL
-    if (PyFunction_Check(func)) {
-        return __Pyx_PyFunction_FastCall(func, &arg, 1);
+#else
+static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause) {
+    PyObject* owned_instance = NULL;
+    if (tb == Py_None) {
+        tb = 0;
+    } else if (tb && !PyTraceBack_Check(tb)) {
+        PyErr_SetString(PyExc_TypeError,
+            "raise: arg 3 must be a traceback or None");
+        goto bad;
     }
-#endif
-    if (likely(PyCFunction_Check(func))) {
-        if (likely(PyCFunction_GET_FLAGS(func) & METH_O)) {
-            return __Pyx_PyObject_CallMethO(func, arg);
-#if CYTHON_FAST_PYCCALL
-        } else if (__Pyx_PyFastCFunction_Check(func)) {
-            return __Pyx_PyCFunction_FastCall(func, &arg, 1);
-#endif
+    if (value == Py_None)
+        value = 0;
+    if (PyExceptionInstance_Check(type)) {
+        if (value) {
+            PyErr_SetString(PyExc_TypeError,
+                "instance exception may not have a separate value");
+            goto bad;
         }
+        value = type;
+        type = (PyObject*) Py_TYPE(value);
+    } else if (PyExceptionClass_Check(type)) {
+        PyObject *instance_class = NULL;
+        if (value && PyExceptionInstance_Check(value)) {
+            instance_class = (PyObject*) Py_TYPE(value);
+            if (instance_class != type) {
+                int is_subclass = PyObject_IsSubclass(instance_class, type);
+                if (!is_subclass) {
+                    instance_class = NULL;
+                } else if (unlikely(is_subclass == -1)) {
+                    goto bad;
+                } else {
+                    type = instance_class;
+                }
+            }
+        }
+        if (!instance_class) {
+            PyObject *args;
+            if (!value)
+                args = PyTuple_New(0);
+            else if (PyTuple_Check(value)) {
+                Py_INCREF(value);
+                args = value;
+            } else
+                args = PyTuple_Pack(1, value);
+            if (!args)
+                goto bad;
+            owned_instance = PyObject_Call(type, args, NULL);
+            Py_DECREF(args);
+            if (!owned_instance)
+                goto bad;
+            value = owned_instance;
+            if (!PyExceptionInstance_Check(value)) {
+                PyErr_Format(PyExc_TypeError,
+                             "calling %R should have returned an instance of "
+                             "BaseException, not %R",
+                             type, Py_TYPE(value));
+                goto bad;
+            }
+        }
+    } else {
+        PyErr_SetString(PyExc_TypeError,
+            "raise: exception class must be a subclass of BaseException");
+        goto bad;
     }
-    return __Pyx__PyObject_CallOneArg(func, arg);
-}
+    if (cause) {
+        PyObject *fixed_cause;
+        if (cause == Py_None) {
+            fixed_cause = NULL;
+        } else if (PyExceptionClass_Check(cause)) {
+            fixed_cause = PyObject_CallObject(cause, NULL);
+            if (fixed_cause == NULL)
+                goto bad;
+        } else if (PyExceptionInstance_Check(cause)) {
+            fixed_cause = cause;
+            Py_INCREF(fixed_cause);
+        } else {
+            PyErr_SetString(PyExc_TypeError,
+                            "exception causes must derive from "
+                            "BaseException");
+            goto bad;
+        }
+        PyException_SetCause(value, fixed_cause);
+    }
+    PyErr_SetObject(type, value);
+    if (tb) {
+      #if PY_VERSION_HEX >= 0x030C00A6
+        PyException_SetTraceback(value, tb);
+      #elif CYTHON_FAST_THREAD_STATE
+        PyThreadState *tstate = __Pyx_PyThreadState_Current;
+        PyObject* tmp_tb = tstate->curexc_traceback;
+        if (tb != tmp_tb) {
+            Py_INCREF(tb);
+            tstate->curexc_traceback = tb;
+            Py_XDECREF(tmp_tb);
+        }
 #else
-static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg) {
-    PyObject *result;
-    PyObject *args = PyTuple_Pack(1, arg);
-    if (unlikely(!args)) return NULL;
-    result = __Pyx_PyObject_Call(func, args, NULL);
-    Py_DECREF(args);
-    return result;
+        PyObject *tmp_type, *tmp_value, *tmp_tb;
+        PyErr_Fetch(&tmp_type, &tmp_value, &tmp_tb);
+        Py_INCREF(tb);
+        PyErr_Restore(tmp_type, tmp_value, tb);
+        Py_XDECREF(tmp_tb);
+#endif
+    }
+bad:
+    Py_XDECREF(owned_instance);
+    return;
 }
 #endif
 
-/* PyDictVersioning */
-#if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_TYPE_SLOTS
-static CYTHON_INLINE PY_UINT64_T __Pyx_get_tp_dict_version(PyObject *obj) {
-    PyObject *dict = Py_TYPE(obj)->tp_dict;
-    return likely(dict) ? __PYX_GET_DICT_VERSION(dict) : 0;
-}
-static CYTHON_INLINE PY_UINT64_T __Pyx_get_object_dict_version(PyObject *obj) {
-    PyObject **dictptr = NULL;
-    Py_ssize_t offset = Py_TYPE(obj)->tp_dictoffset;
-    if (offset) {
+/* TupleAndListFromArray */
 #if CYTHON_COMPILING_IN_CPYTHON
-        dictptr = (likely(offset > 0)) ? (PyObject **) ((char *)obj + offset) : _PyObject_GetDictPtr(obj);
-#else
-        dictptr = _PyObject_GetDictPtr(obj);
-#endif
+static CYTHON_INLINE void __Pyx_copy_object_array(PyObject *const *CYTHON_RESTRICT src, PyObject** CYTHON_RESTRICT dest, Py_ssize_t length) {
+    PyObject *v;
+    Py_ssize_t i;
+    for (i = 0; i < length; i++) {
+        v = dest[i] = src[i];
+        Py_INCREF(v);
     }
-    return (dictptr && *dictptr) ? __PYX_GET_DICT_VERSION(*dictptr) : 0;
 }
-static CYTHON_INLINE int __Pyx_object_dict_version_matches(PyObject* obj, PY_UINT64_T tp_dict_version, PY_UINT64_T obj_dict_version) {
-    PyObject *dict = Py_TYPE(obj)->tp_dict;
-    if (unlikely(!dict) || unlikely(tp_dict_version != __PYX_GET_DICT_VERSION(dict)))
-        return 0;
-    return obj_dict_version == __Pyx_get_object_dict_version(obj);
+static CYTHON_INLINE PyObject *
+__Pyx_PyTuple_FromArray(PyObject *const *src, Py_ssize_t n)
+{
+    PyObject *res;
+    if (n <= 0) {
+        Py_INCREF(__pyx_empty_tuple);
+        return __pyx_empty_tuple;
+    }
+    res = PyTuple_New(n);
+    if (unlikely(res == NULL)) return NULL;
+    __Pyx_copy_object_array(src, ((PyTupleObject*)res)->ob_item, n);
+    return res;
+}
+static CYTHON_INLINE PyObject *
+__Pyx_PyList_FromArray(PyObject *const *src, Py_ssize_t n)
+{
+    PyObject *res;
+    if (n <= 0) {
+        return PyList_New(0);
+    }
+    res = PyList_New(n);
+    if (unlikely(res == NULL)) return NULL;
+    __Pyx_copy_object_array(src, ((PyListObject*)res)->ob_item, n);
+    return res;
 }
 #endif
 
-/* GetModuleGlobalName */
-#if CYTHON_USE_DICT_VERSIONS
-static PyObject *__Pyx__GetModuleGlobalName(PyObject *name, PY_UINT64_T *dict_version, PyObject **dict_cached_value)
+/* BytesEquals */
+static CYTHON_INLINE int __Pyx_PyBytes_Equals(PyObject* s1, PyObject* s2, int equals) {
+#if CYTHON_COMPILING_IN_PYPY || CYTHON_COMPILING_IN_LIMITED_API
+    return PyObject_RichCompareBool(s1, s2, equals);
+#else
+    if (s1 == s2) {
+        return (equals == Py_EQ);
+    } else if (PyBytes_CheckExact(s1) & PyBytes_CheckExact(s2)) {
+        const char *ps1, *ps2;
+        Py_ssize_t length = PyBytes_GET_SIZE(s1);
+        if (length != PyBytes_GET_SIZE(s2))
+            return (equals == Py_NE);
+        ps1 = PyBytes_AS_STRING(s1);
+        ps2 = PyBytes_AS_STRING(s2);
+        if (ps1[0] != ps2[0]) {
+            return (equals == Py_NE);
+        } else if (length == 1) {
+            return (equals == Py_EQ);
+        } else {
+            int result;
+#if CYTHON_USE_UNICODE_INTERNALS && (PY_VERSION_HEX < 0x030B0000)
+            Py_hash_t hash1, hash2;
+            hash1 = ((PyBytesObject*)s1)->ob_shash;
+            hash2 = ((PyBytesObject*)s2)->ob_shash;
+            if (hash1 != hash2 && hash1 != -1 && hash2 != -1) {
+                return (equals == Py_NE);
+            }
+#endif
+            result = memcmp(ps1, ps2, (size_t)length);
+            return (equals == Py_EQ) ? (result == 0) : (result != 0);
+        }
+    } else if ((s1 == Py_None) & PyBytes_CheckExact(s2)) {
+        return (equals == Py_NE);
+    } else if ((s2 == Py_None) & PyBytes_CheckExact(s1)) {
+        return (equals == Py_NE);
+    } else {
+        int result;
+        PyObject* py_result = PyObject_RichCompare(s1, s2, equals);
+        if (!py_result)
+            return -1;
+        result = __Pyx_PyObject_IsTrue(py_result);
+        Py_DECREF(py_result);
+        return result;
+    }
+#endif
+}
+
+/* UnicodeEquals */
+static CYTHON_INLINE int __Pyx_PyUnicode_Equals(PyObject* s1, PyObject* s2, int equals) {
+#if CYTHON_COMPILING_IN_PYPY || CYTHON_COMPILING_IN_LIMITED_API
+    return PyObject_RichCompareBool(s1, s2, equals);
 #else
-static CYTHON_INLINE PyObject *__Pyx__GetModuleGlobalName(PyObject *name)
+#if PY_MAJOR_VERSION < 3
+    PyObject* owned_ref = NULL;
 #endif
-{
-    PyObject *result;
-#if !CYTHON_AVOID_BORROWED_REFS
-#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030500A1
-    result = _PyDict_GetItem_KnownHash(__pyx_d, name, ((PyASCIIObject *) name)->hash);
-    __PYX_UPDATE_DICT_CACHE(__pyx_d, result, *dict_cached_value, *dict_version)
-    if (likely(result)) {
-        return __Pyx_NewRef(result);
-    } else if (unlikely(PyErr_Occurred())) {
-        return NULL;
+    int s1_is_unicode, s2_is_unicode;
+    if (s1 == s2) {
+        goto return_eq;
     }
-#else
-    result = PyDict_GetItem(__pyx_d, name);
-    __PYX_UPDATE_DICT_CACHE(__pyx_d, result, *dict_cached_value, *dict_version)
-    if (likely(result)) {
-        return __Pyx_NewRef(result);
+    s1_is_unicode = PyUnicode_CheckExact(s1);
+    s2_is_unicode = PyUnicode_CheckExact(s2);
+#if PY_MAJOR_VERSION < 3
+    if ((s1_is_unicode & (!s2_is_unicode)) && PyString_CheckExact(s2)) {
+        owned_ref = PyUnicode_FromObject(s2);
+        if (unlikely(!owned_ref))
+            return -1;
+        s2 = owned_ref;
+        s2_is_unicode = 1;
+    } else if ((s2_is_unicode & (!s1_is_unicode)) && PyString_CheckExact(s1)) {
+        owned_ref = PyUnicode_FromObject(s1);
+        if (unlikely(!owned_ref))
+            return -1;
+        s1 = owned_ref;
+        s1_is_unicode = 1;
+    } else if (((!s2_is_unicode) & (!s1_is_unicode))) {
+        return __Pyx_PyBytes_Equals(s1, s2, equals);
     }
 #endif
-#else
-    result = PyObject_GetItem(__pyx_d, name);
-    __PYX_UPDATE_DICT_CACHE(__pyx_d, result, *dict_cached_value, *dict_version)
-    if (likely(result)) {
-        return __Pyx_NewRef(result);
+    if (s1_is_unicode & s2_is_unicode) {
+        Py_ssize_t length;
+        int kind;
+        void *data1, *data2;
+        if (unlikely(__Pyx_PyUnicode_READY(s1) < 0) || unlikely(__Pyx_PyUnicode_READY(s2) < 0))
+            return -1;
+        length = __Pyx_PyUnicode_GET_LENGTH(s1);
+        if (length != __Pyx_PyUnicode_GET_LENGTH(s2)) {
+            goto return_ne;
+        }
+#if CYTHON_USE_UNICODE_INTERNALS
+        {
+            Py_hash_t hash1, hash2;
+        #if CYTHON_PEP393_ENABLED
+            hash1 = ((PyASCIIObject*)s1)->hash;
+            hash2 = ((PyASCIIObject*)s2)->hash;
+        #else
+            hash1 = ((PyUnicodeObject*)s1)->hash;
+            hash2 = ((PyUnicodeObject*)s2)->hash;
+        #endif
+            if (hash1 != hash2 && hash1 != -1 && hash2 != -1) {
+                goto return_ne;
+            }
+        }
+#endif
+        kind = __Pyx_PyUnicode_KIND(s1);
+        if (kind != __Pyx_PyUnicode_KIND(s2)) {
+            goto return_ne;
+        }
+        data1 = __Pyx_PyUnicode_DATA(s1);
+        data2 = __Pyx_PyUnicode_DATA(s2);
+        if (__Pyx_PyUnicode_READ(kind, data1, 0) != __Pyx_PyUnicode_READ(kind, data2, 0)) {
+            goto return_ne;
+        } else if (length == 1) {
+            goto return_eq;
+        } else {
+            int result = memcmp(data1, data2, (size_t)(length * kind));
+            #if PY_MAJOR_VERSION < 3
+            Py_XDECREF(owned_ref);
+            #endif
+            return (equals == Py_EQ) ? (result == 0) : (result != 0);
+        }
+    } else if ((s1 == Py_None) & s2_is_unicode) {
+        goto return_ne;
+    } else if ((s2 == Py_None) & s1_is_unicode) {
+        goto return_ne;
+    } else {
+        int result;
+        PyObject* py_result = PyObject_RichCompare(s1, s2, equals);
+        #if PY_MAJOR_VERSION < 3
+        Py_XDECREF(owned_ref);
+        #endif
+        if (!py_result)
+            return -1;
+        result = __Pyx_PyObject_IsTrue(py_result);
+        Py_DECREF(py_result);
+        return result;
     }
-    PyErr_Clear();
+return_eq:
+    #if PY_MAJOR_VERSION < 3
+    Py_XDECREF(owned_ref);
+    #endif
+    return (equals == Py_EQ);
+return_ne:
+    #if PY_MAJOR_VERSION < 3
+    Py_XDECREF(owned_ref);
+    #endif
+    return (equals == Py_NE);
 #endif
-    return __Pyx_GetBuiltinName(name);
 }
 
-/* PyObjectCall2Args */
-static CYTHON_UNUSED PyObject* __Pyx_PyObject_Call2Args(PyObject* function, PyObject* arg1, PyObject* arg2) {
-    PyObject *args, *result = NULL;
-    #if CYTHON_FAST_PYCALL
-    if (PyFunction_Check(function)) {
-        PyObject *args[2] = {arg1, arg2};
-        return __Pyx_PyFunction_FastCall(function, args, 2);
+/* fastcall */
+#if CYTHON_METH_FASTCALL
+static CYTHON_INLINE PyObject * __Pyx_GetKwValue_FASTCALL(PyObject *kwnames, PyObject *const *kwvalues, PyObject *s)
+{
+    Py_ssize_t i, n = PyTuple_GET_SIZE(kwnames);
+    for (i = 0; i < n; i++)
+    {
+        if (s == PyTuple_GET_ITEM(kwnames, i)) return kwvalues[i];
     }
-    #endif
-    #if CYTHON_FAST_PYCCALL
-    if (__Pyx_PyFastCFunction_Check(function)) {
-        PyObject *args[2] = {arg1, arg2};
-        return __Pyx_PyCFunction_FastCall(function, args, 2);
+    for (i = 0; i < n; i++)
+    {
+        int eq = __Pyx_PyUnicode_Equals(s, PyTuple_GET_ITEM(kwnames, i), Py_EQ);
+        if (unlikely(eq != 0)) {
+            if (unlikely(eq < 0)) return NULL;
+            return kwvalues[i];
+        }
     }
-    #endif
-    args = PyTuple_New(2);
-    if (unlikely(!args)) goto done;
-    Py_INCREF(arg1);
-    PyTuple_SET_ITEM(args, 0, arg1);
-    Py_INCREF(arg2);
-    PyTuple_SET_ITEM(args, 1, arg2);
-    Py_INCREF(function);
-    result = __Pyx_PyObject_Call(function, args, NULL);
-    Py_DECREF(args);
-    Py_DECREF(function);
-done:
-    return result;
+    return NULL;
 }
-
-/* ExtTypeTest */
-static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type) {
-    if (unlikely(!type)) {
-        PyErr_SetString(PyExc_SystemError, "Missing type object");
-        return 0;
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030d0000
+CYTHON_UNUSED static PyObject *__Pyx_KwargsAsDict_FASTCALL(PyObject *kwnames, PyObject *const *kwvalues) {
+    Py_ssize_t i, nkwargs = PyTuple_GET_SIZE(kwnames);
+    PyObject *dict;
+    dict = PyDict_New();
+    if (unlikely(!dict))
+        return NULL;
+    for (i=0; i<nkwargs; i++) {
+        PyObject *key = PyTuple_GET_ITEM(kwnames, i);
+        if (unlikely(PyDict_SetItem(dict, key, kwvalues[i]) < 0))
+            goto bad;
     }
-    if (likely(__Pyx_TypeCheck(obj, type)))
-        return 1;
-    PyErr_Format(PyExc_TypeError, "Cannot convert %.200s to %.200s",
-                 Py_TYPE(obj)->tp_name, type->tp_name);
-    return 0;
+    return dict;
+bad:
+    Py_DECREF(dict);
+    return NULL;
 }
+#endif
+#endif
 
 /* RaiseArgTupleInvalid */
 static void __Pyx_RaiseArgtupleInvalid(
     const char* func_name,
     int exact,
     Py_ssize_t num_min,
     Py_ssize_t num_max,
@@ -7406,38 +7118,83 @@
         PyString_AsString(kw_name));
         #endif
 }
 
 /* ParseKeywords */
 static int __Pyx_ParseOptionalKeywords(
     PyObject *kwds,
+    PyObject *const *kwvalues,
     PyObject **argnames[],
     PyObject *kwds2,
     PyObject *values[],
     Py_ssize_t num_pos_args,
     const char* function_name)
 {
     PyObject *key = 0, *value = 0;
     Py_ssize_t pos = 0;
     PyObject*** name;
     PyObject*** first_kw_arg = argnames + num_pos_args;
-    while (PyDict_Next(kwds, &pos, &key, &value)) {
+    int kwds_is_tuple = CYTHON_METH_FASTCALL && likely(PyTuple_Check(kwds));
+    while (1) {
+        Py_XDECREF(key); key = NULL;
+        Py_XDECREF(value); value = NULL;
+        if (kwds_is_tuple) {
+            Py_ssize_t size;
+#if CYTHON_ASSUME_SAFE_MACROS
+            size = PyTuple_GET_SIZE(kwds);
+#else
+            size = PyTuple_Size(kwds);
+            if (size < 0) goto bad;
+#endif
+            if (pos >= size) break;
+#if CYTHON_AVOID_BORROWED_REFS
+            key = __Pyx_PySequence_ITEM(kwds, pos);
+            if (!key) goto bad;
+#elif CYTHON_ASSUME_SAFE_MACROS
+            key = PyTuple_GET_ITEM(kwds, pos);
+#else
+            key = PyTuple_GetItem(kwds, pos);
+            if (!key) goto bad;
+#endif
+            value = kwvalues[pos];
+            pos++;
+        }
+        else
+        {
+            if (!PyDict_Next(kwds, &pos, &key, &value)) break;
+#if CYTHON_AVOID_BORROWED_REFS
+            Py_INCREF(key);
+#endif
+        }
         name = first_kw_arg;
         while (*name && (**name != key)) name++;
         if (*name) {
             values[name-argnames] = value;
+#if CYTHON_AVOID_BORROWED_REFS
+            Py_INCREF(value);
+            Py_DECREF(key);
+#endif
+            key = NULL;
+            value = NULL;
             continue;
         }
+#if !CYTHON_AVOID_BORROWED_REFS
+        Py_INCREF(key);
+#endif
+        Py_INCREF(value);
         name = first_kw_arg;
         #if PY_MAJOR_VERSION < 3
         if (likely(PyString_Check(key))) {
             while (*name) {
                 if ((CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**name) == PyString_GET_SIZE(key))
                         && _PyString_Eq(**name, key)) {
                     values[name-argnames] = value;
+#if CYTHON_AVOID_BORROWED_REFS
+                    value = NULL;
+#endif
                     break;
                 }
                 name++;
             }
             if (*name) continue;
             else {
                 PyObject*** argname = argnames;
@@ -7450,22 +7207,26 @@
                     argname++;
                 }
             }
         } else
         #endif
         if (likely(PyUnicode_Check(key))) {
             while (*name) {
-                int cmp = (**name == key) ? 0 :
+                int cmp = (
                 #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
                     (__Pyx_PyUnicode_GET_LENGTH(**name) != __Pyx_PyUnicode_GET_LENGTH(key)) ? 1 :
                 #endif
-                    PyUnicode_Compare(**name, key);
+                    PyUnicode_Compare(**name, key)
+                );
                 if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
                 if (cmp == 0) {
                     values[name-argnames] = value;
+#if CYTHON_AVOID_BORROWED_REFS
+                    value = NULL;
+#endif
                     break;
                 }
                 name++;
             }
             if (*name) continue;
             else {
                 PyObject*** argname = argnames;
@@ -7484,53 +7245,64 @@
             goto invalid_keyword_type;
         if (kwds2) {
             if (unlikely(PyDict_SetItem(kwds2, key, value))) goto bad;
         } else {
             goto invalid_keyword;
         }
     }
+    Py_XDECREF(key);
+    Py_XDECREF(value);
     return 0;
 arg_passed_twice:
     __Pyx_RaiseDoubleKeywordsError(function_name, key);
     goto bad;
 invalid_keyword_type:
     PyErr_Format(PyExc_TypeError,
         "%.200s() keywords must be strings", function_name);
     goto bad;
 invalid_keyword:
-    PyErr_Format(PyExc_TypeError,
     #if PY_MAJOR_VERSION < 3
+    PyErr_Format(PyExc_TypeError,
         "%.200s() got an unexpected keyword argument '%.200s'",
         function_name, PyString_AsString(key));
     #else
+    PyErr_Format(PyExc_TypeError,
         "%s() got an unexpected keyword argument '%U'",
         function_name, key);
     #endif
 bad:
+    Py_XDECREF(key);
+    Py_XDECREF(value);
     return -1;
 }
 
 /* ArgTypeTest */
 static int __Pyx__ArgTypeTest(PyObject *obj, PyTypeObject *type, const char *name, int exact)
 {
+    __Pyx_TypeName type_name;
+    __Pyx_TypeName obj_type_name;
     if (unlikely(!type)) {
         PyErr_SetString(PyExc_SystemError, "Missing type object");
         return 0;
     }
     else if (exact) {
         #if PY_MAJOR_VERSION == 2
         if ((type == &PyBaseString_Type) && likely(__Pyx_PyBaseString_CheckExact(obj))) return 1;
         #endif
     }
     else {
         if (likely(__Pyx_TypeCheck(obj, type))) return 1;
     }
+    type_name = __Pyx_PyType_GetName(type);
+    obj_type_name = __Pyx_PyType_GetName(Py_TYPE(obj));
     PyErr_Format(PyExc_TypeError,
-        "Argument '%.200s' has incorrect type (expected %.200s, got %.200s)",
-        name, type->tp_name, Py_TYPE(obj)->tp_name);
+        "Argument '%.200s' has incorrect type (expected " __Pyx_FMT_TYPENAME
+        ", got " __Pyx_FMT_TYPENAME ")", name, type_name, obj_type_name);
+    __Pyx_DECREF_TypeName(type_name);
+    __Pyx_DECREF_TypeName(obj_type_name);
     return 0;
 }
 
 /* IsLittleEndian */
 static CYTHON_INLINE int __Pyx_Is_Little_Endian(void)
 {
   union {
@@ -7613,15 +7385,15 @@
     case 'd': return (is_complex ? "'complex double'" : "'double'");
     case 'g': return (is_complex ? "'complex long double'" : "'long double'");
     case 'T': return "a struct";
     case 'O': return "Python object";
     case 'P': return "a pointer";
     case 's': case 'p': return "a string";
     case 0: return "end";
-    default: return "unparseable format string";
+    default: return "unparsable format string";
   }
 }
 static size_t __Pyx_BufFmt_TypeCharToStandardSize(char ch, int is_complex) {
   switch (ch) {
     case '?': case 'c': case 'b': case 'B': case 's': case 'p': return 1;
     case 'h': case 'H': return 2;
     case 'i': case 'I': case 'l': case 'L': return 4;
@@ -7663,15 +7435,16 @@
 typedef struct { char c; float x; } __Pyx_st_float;
 typedef struct { char c; double x; } __Pyx_st_double;
 typedef struct { char c; long double x; } __Pyx_st_longdouble;
 typedef struct { char c; void *x; } __Pyx_st_void_p;
 #ifdef HAVE_LONG_LONG
 typedef struct { char c; PY_LONG_LONG x; } __Pyx_st_longlong;
 #endif
-static size_t __Pyx_BufFmt_TypeCharToAlignment(char ch, CYTHON_UNUSED int is_complex) {
+static size_t __Pyx_BufFmt_TypeCharToAlignment(char ch, int is_complex) {
+  CYTHON_UNUSED_VAR(is_complex);
   switch (ch) {
     case '?': case 'c': case 'b': case 'B': case 's': case 'p': return 1;
     case 'h': case 'H': return sizeof(__Pyx_st_short) - sizeof(short);
     case 'i': case 'I': return sizeof(__Pyx_st_int) - sizeof(int);
     case 'l': case 'L': return sizeof(__Pyx_st_long) - sizeof(long);
 #ifdef HAVE_LONG_LONG
     case 'q': case 'Q': return sizeof(__Pyx_st_longlong) - sizeof(PY_LONG_LONG);
@@ -7695,15 +7468,16 @@
 typedef struct { float x; char c; } __Pyx_pad_float;
 typedef struct { double x; char c; } __Pyx_pad_double;
 typedef struct { long double x; char c; } __Pyx_pad_longdouble;
 typedef struct { void *x; char c; } __Pyx_pad_void_p;
 #ifdef HAVE_LONG_LONG
 typedef struct { PY_LONG_LONG x; char c; } __Pyx_pad_longlong;
 #endif
-static size_t __Pyx_BufFmt_TypeCharToPadding(char ch, CYTHON_UNUSED int is_complex) {
+static size_t __Pyx_BufFmt_TypeCharToPadding(char ch, int is_complex) {
+  CYTHON_UNUSED_VAR(is_complex);
   switch (ch) {
     case '?': case 'c': case 'b': case 'B': case 's': case 'p': return 1;
     case 'h': case 'H': return sizeof(__Pyx_pad_short) - sizeof(short);
     case 'i': case 'I': return sizeof(__Pyx_pad_int) - sizeof(int);
     case 'l': case 'L': return sizeof(__Pyx_pad_long) - sizeof(long);
 #ifdef HAVE_LONG_LONG
     case 'q': case 'Q': return sizeof(__Pyx_pad_longlong) - sizeof(PY_LONG_LONG);
@@ -7860,56 +7634,62 @@
       }
     }
   } while (ctx->enc_count);
   ctx->enc_type = 0;
   ctx->is_complex = 0;
   return 0;
 }
-static PyObject *
+static int
 __pyx_buffmt_parse_array(__Pyx_BufFmt_Context* ctx, const char** tsp)
 {
     const char *ts = *tsp;
     int i = 0, number, ndim;
     ++ts;
     if (ctx->new_count != 1) {
         PyErr_SetString(PyExc_ValueError,
                         "Cannot handle repeated arrays in format string");
-        return NULL;
+        return -1;
     }
-    if (__Pyx_BufFmt_ProcessTypeChunk(ctx) == -1) return NULL;
+    if (__Pyx_BufFmt_ProcessTypeChunk(ctx) == -1) return -1;
     ndim = ctx->head->field->type->ndim;
     while (*ts && *ts != ')') {
         switch (*ts) {
             case ' ': case '\f': case '\r': case '\n': case '\t': case '\v':  continue;
             default:  break;
         }
         number = __Pyx_BufFmt_ExpectNumber(&ts);
-        if (number == -1) return NULL;
-        if (i < ndim && (size_t) number != ctx->head->field->type->arraysize[i])
-            return PyErr_Format(PyExc_ValueError,
+        if (number == -1) return -1;
+        if (i < ndim && (size_t) number != ctx->head->field->type->arraysize[i]) {
+            PyErr_Format(PyExc_ValueError,
                         "Expected a dimension of size %zu, got %d",
                         ctx->head->field->type->arraysize[i], number);
-        if (*ts != ',' && *ts != ')')
-            return PyErr_Format(PyExc_ValueError,
+            return -1;
+        }
+        if (*ts != ',' && *ts != ')') {
+            PyErr_Format(PyExc_ValueError,
                                 "Expected a comma in format string, got '%c'", *ts);
+            return -1;
+        }
         if (*ts == ',') ts++;
         i++;
     }
-    if (i != ndim)
-        return PyErr_Format(PyExc_ValueError, "Expected %d dimension(s), got %d",
+    if (i != ndim) {
+        PyErr_Format(PyExc_ValueError, "Expected %d dimension(s), got %d",
                             ctx->head->field->type->ndim, i);
+        return -1;
+    }
     if (!*ts) {
         PyErr_SetString(PyExc_ValueError,
                         "Unexpected end of format string, expected ')'");
-        return NULL;
+        return -1;
     }
     ctx->is_valid_array = 1;
     ctx->new_count = 1;
     *tsp = ++ts;
-    return Py_None;
+    return 0;
 }
 static const char* __Pyx_BufFmt_CheckString(__Pyx_BufFmt_Context* ctx, const char* ts) {
   int got_Z = 0;
   while (1) {
     switch(*ts) {
       case 0:
         if (ctx->enc_type != 0 && ctx->head == NULL) {
@@ -8027,15 +7807,15 @@
         break;
       case ':':
         ++ts;
         while(*ts != ':') ++ts;
         ++ts;
         break;
       case '(':
-        if (!__pyx_buffmt_parse_array(ctx, &ts)) return NULL;
+        if (__pyx_buffmt_parse_array(ctx, &ts) < 0) return NULL;
         break;
       default:
         {
           int number = __Pyx_BufFmt_ExpectNumber(&ts);
           if (number == -1) return NULL;
           ctx->new_count = (size_t)number;
         }
@@ -8086,520 +7866,765 @@
   if (buf->suboffsets == NULL) buf->suboffsets = __Pyx_minusones;
   return 0;
 fail:;
   __Pyx_SafeReleaseBuffer(buf);
   return -1;
 }
 
-/* ObjectGetItem */
-  #if CYTHON_USE_TYPE_SLOTS
-static PyObject *__Pyx_PyObject_GetIndex(PyObject *obj, PyObject* index) {
-    PyObject *runerr;
-    Py_ssize_t key_value;
-    PySequenceMethods *m = Py_TYPE(obj)->tp_as_sequence;
-    if (unlikely(!(m && m->sq_item))) {
-        PyErr_Format(PyExc_TypeError, "'%.200s' object is not subscriptable", Py_TYPE(obj)->tp_name);
-        return NULL;
-    }
-    key_value = __Pyx_PyIndex_AsSsize_t(index);
-    if (likely(key_value != -1 || !(runerr = PyErr_Occurred()))) {
-        return __Pyx_GetItemInt_Fast(obj, key_value, 0, 1, 1);
-    }
-    if (PyErr_GivenExceptionMatches(runerr, PyExc_OverflowError)) {
-        PyErr_Clear();
-        PyErr_Format(PyExc_IndexError, "cannot fit '%.200s' into an index-sized integer", Py_TYPE(index)->tp_name);
-    }
-    return NULL;
+/* GetItemInt */
+  static PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j) {
+    PyObject *r;
+    if (unlikely(!j)) return NULL;
+    r = PyObject_GetItem(o, j);
+    Py_DECREF(j);
+    return r;
 }
-static PyObject *__Pyx_PyObject_GetItem(PyObject *obj, PyObject* key) {
-    PyMappingMethods *m = Py_TYPE(obj)->tp_as_mapping;
-    if (likely(m && m->mp_subscript)) {
-        return m->mp_subscript(obj, key);
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_List_Fast(PyObject *o, Py_ssize_t i,
+                                                              CYTHON_NCP_UNUSED int wraparound,
+                                                              CYTHON_NCP_UNUSED int boundscheck) {
+#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+    Py_ssize_t wrapped_i = i;
+    if (wraparound & unlikely(i < 0)) {
+        wrapped_i += PyList_GET_SIZE(o);
     }
-    return __Pyx_PyObject_GetIndex(obj, key);
-}
+    if ((!boundscheck) || likely(__Pyx_is_valid_index(wrapped_i, PyList_GET_SIZE(o)))) {
+        PyObject *r = PyList_GET_ITEM(o, wrapped_i);
+        Py_INCREF(r);
+        return r;
+    }
+    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
+#else
+    return PySequence_GetItem(o, i);
 #endif
-
-/* PyErrFetchRestore */
-  #if CYTHON_FAST_THREAD_STATE
-static CYTHON_INLINE void __Pyx_ErrRestoreInState(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb) {
-    PyObject *tmp_type, *tmp_value, *tmp_tb;
-    tmp_type = tstate->curexc_type;
-    tmp_value = tstate->curexc_value;
-    tmp_tb = tstate->curexc_traceback;
-    tstate->curexc_type = type;
-    tstate->curexc_value = value;
-    tstate->curexc_traceback = tb;
-    Py_XDECREF(tmp_type);
-    Py_XDECREF(tmp_value);
-    Py_XDECREF(tmp_tb);
-}
-static CYTHON_INLINE void __Pyx_ErrFetchInState(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
-    *type = tstate->curexc_type;
-    *value = tstate->curexc_value;
-    *tb = tstate->curexc_traceback;
-    tstate->curexc_type = 0;
-    tstate->curexc_value = 0;
-    tstate->curexc_traceback = 0;
 }
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i,
+                                                              CYTHON_NCP_UNUSED int wraparound,
+                                                              CYTHON_NCP_UNUSED int boundscheck) {
+#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+    Py_ssize_t wrapped_i = i;
+    if (wraparound & unlikely(i < 0)) {
+        wrapped_i += PyTuple_GET_SIZE(o);
+    }
+    if ((!boundscheck) || likely(__Pyx_is_valid_index(wrapped_i, PyTuple_GET_SIZE(o)))) {
+        PyObject *r = PyTuple_GET_ITEM(o, wrapped_i);
+        Py_INCREF(r);
+        return r;
+    }
+    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
+#else
+    return PySequence_GetItem(o, i);
 #endif
-
-/* SetItemInt */
-  static int __Pyx_SetItemInt_Generic(PyObject *o, PyObject *j, PyObject *v) {
-    int r;
-    if (!j) return -1;
-    r = PyObject_SetItem(o, j, v);
-    Py_DECREF(j);
-    return r;
 }
-static CYTHON_INLINE int __Pyx_SetItemInt_Fast(PyObject *o, Py_ssize_t i, PyObject *v, int is_list,
-                                               CYTHON_NCP_UNUSED int wraparound, CYTHON_NCP_UNUSED int boundscheck) {
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i, int is_list,
+                                                     CYTHON_NCP_UNUSED int wraparound,
+                                                     CYTHON_NCP_UNUSED int boundscheck) {
 #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS && CYTHON_USE_TYPE_SLOTS
     if (is_list || PyList_CheckExact(o)) {
-        Py_ssize_t n = (!wraparound) ? i : ((likely(i >= 0)) ? i : i + PyList_GET_SIZE(o));
-        if ((!boundscheck) || likely(__Pyx_is_valid_index(n, PyList_GET_SIZE(o)))) {
-            PyObject* old = PyList_GET_ITEM(o, n);
-            Py_INCREF(v);
-            PyList_SET_ITEM(o, n, v);
-            Py_DECREF(old);
-            return 1;
+        Py_ssize_t n = ((!wraparound) | likely(i >= 0)) ? i : i + PyList_GET_SIZE(o);
+        if ((!boundscheck) || (likely(__Pyx_is_valid_index(n, PyList_GET_SIZE(o))))) {
+            PyObject *r = PyList_GET_ITEM(o, n);
+            Py_INCREF(r);
+            return r;
+        }
+    }
+    else if (PyTuple_CheckExact(o)) {
+        Py_ssize_t n = ((!wraparound) | likely(i >= 0)) ? i : i + PyTuple_GET_SIZE(o);
+        if ((!boundscheck) || likely(__Pyx_is_valid_index(n, PyTuple_GET_SIZE(o)))) {
+            PyObject *r = PyTuple_GET_ITEM(o, n);
+            Py_INCREF(r);
+            return r;
         }
     } else {
-        PySequenceMethods *m = Py_TYPE(o)->tp_as_sequence;
-        if (likely(m && m->sq_ass_item)) {
-            if (wraparound && unlikely(i < 0) && likely(m->sq_length)) {
-                Py_ssize_t l = m->sq_length(o);
+        PyMappingMethods *mm = Py_TYPE(o)->tp_as_mapping;
+        PySequenceMethods *sm = Py_TYPE(o)->tp_as_sequence;
+        if (mm && mm->mp_subscript) {
+            PyObject *r, *key = PyInt_FromSsize_t(i);
+            if (unlikely(!key)) return NULL;
+            r = mm->mp_subscript(o, key);
+            Py_DECREF(key);
+            return r;
+        }
+        if (likely(sm && sm->sq_item)) {
+            if (wraparound && unlikely(i < 0) && likely(sm->sq_length)) {
+                Py_ssize_t l = sm->sq_length(o);
                 if (likely(l >= 0)) {
                     i += l;
                 } else {
                     if (!PyErr_ExceptionMatches(PyExc_OverflowError))
-                        return -1;
+                        return NULL;
                     PyErr_Clear();
                 }
             }
-            return m->sq_ass_item(o, i, v);
+            return sm->sq_item(o, i);
         }
     }
 #else
-#if CYTHON_COMPILING_IN_PYPY
-    if (is_list || (PySequence_Check(o) && !PyDict_Check(o)))
-#else
-    if (is_list || PySequence_Check(o))
-#endif
-    {
-        return PySequence_SetItem(o, i, v);
+    if (is_list || !PyMapping_Check(o)) {
+        return PySequence_GetItem(o, i);
     }
 #endif
-    return __Pyx_SetItemInt_Generic(o, PyInt_FromSsize_t(i), v);
+    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
 }
 
-/* RaiseException */
-  #if PY_MAJOR_VERSION < 3
-static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb,
-                        CYTHON_UNUSED PyObject *cause) {
-    __Pyx_PyThreadState_declare
-    Py_XINCREF(type);
-    if (!value || value == Py_None)
-        value = NULL;
-    else
-        Py_INCREF(value);
-    if (!tb || tb == Py_None)
-        tb = NULL;
-    else {
-        Py_INCREF(tb);
-        if (!PyTraceBack_Check(tb)) {
-            PyErr_SetString(PyExc_TypeError,
-                "raise: arg 3 must be a traceback or None");
-            goto raise_error;
-        }
+/* PyFunctionFastCall */
+  #if CYTHON_FAST_PYCALL && !CYTHON_VECTORCALL
+static PyObject* __Pyx_PyFunction_FastCallNoKw(PyCodeObject *co, PyObject **args, Py_ssize_t na,
+                                               PyObject *globals) {
+    PyFrameObject *f;
+    PyThreadState *tstate = __Pyx_PyThreadState_Current;
+    PyObject **fastlocals;
+    Py_ssize_t i;
+    PyObject *result;
+    assert(globals != NULL);
+    /* XXX Perhaps we should create a specialized
+       PyFrame_New() that doesn't take locals, but does
+       take builtins without sanity checking them.
+       */
+    assert(tstate != NULL);
+    f = PyFrame_New(tstate, co, globals, NULL);
+    if (f == NULL) {
+        return NULL;
     }
-    if (PyType_Check(type)) {
-#if CYTHON_COMPILING_IN_PYPY
-        if (!value) {
-            Py_INCREF(Py_None);
-            value = Py_None;
-        }
-#endif
-        PyErr_NormalizeException(&type, &value, &tb);
-    } else {
-        if (value) {
-            PyErr_SetString(PyExc_TypeError,
-                "instance exception may not have a separate value");
-            goto raise_error;
-        }
-        value = type;
-        type = (PyObject*) Py_TYPE(type);
-        Py_INCREF(type);
-        if (!PyType_IsSubtype((PyTypeObject *)type, (PyTypeObject *)PyExc_BaseException)) {
-            PyErr_SetString(PyExc_TypeError,
-                "raise: exception class must be a subclass of BaseException");
-            goto raise_error;
-        }
+    fastlocals = __Pyx_PyFrame_GetLocalsplus(f);
+    for (i = 0; i < na; i++) {
+        Py_INCREF(*args);
+        fastlocals[i] = *args++;
     }
-    __Pyx_PyThreadState_assign
-    __Pyx_ErrRestore(type, value, tb);
-    return;
-raise_error:
-    Py_XDECREF(value);
-    Py_XDECREF(type);
-    Py_XDECREF(tb);
-    return;
+    result = PyEval_EvalFrameEx(f,0);
+    ++tstate->recursion_depth;
+    Py_DECREF(f);
+    --tstate->recursion_depth;
+    return result;
 }
-#else
-static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause) {
-    PyObject* owned_instance = NULL;
-    if (tb == Py_None) {
-        tb = 0;
-    } else if (tb && !PyTraceBack_Check(tb)) {
-        PyErr_SetString(PyExc_TypeError,
-            "raise: arg 3 must be a traceback or None");
-        goto bad;
+static PyObject *__Pyx_PyFunction_FastCallDict(PyObject *func, PyObject **args, Py_ssize_t nargs, PyObject *kwargs) {
+    PyCodeObject *co = (PyCodeObject *)PyFunction_GET_CODE(func);
+    PyObject *globals = PyFunction_GET_GLOBALS(func);
+    PyObject *argdefs = PyFunction_GET_DEFAULTS(func);
+    PyObject *closure;
+#if PY_MAJOR_VERSION >= 3
+    PyObject *kwdefs;
+#endif
+    PyObject *kwtuple, **k;
+    PyObject **d;
+    Py_ssize_t nd;
+    Py_ssize_t nk;
+    PyObject *result;
+    assert(kwargs == NULL || PyDict_Check(kwargs));
+    nk = kwargs ? PyDict_Size(kwargs) : 0;
+    #if PY_MAJOR_VERSION < 3
+    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object"))) {
+        return NULL;
     }
-    if (value == Py_None)
-        value = 0;
-    if (PyExceptionInstance_Check(type)) {
-        if (value) {
-            PyErr_SetString(PyExc_TypeError,
-                "instance exception may not have a separate value");
-            goto bad;
-        }
-        value = type;
-        type = (PyObject*) Py_TYPE(value);
-    } else if (PyExceptionClass_Check(type)) {
-        PyObject *instance_class = NULL;
-        if (value && PyExceptionInstance_Check(value)) {
-            instance_class = (PyObject*) Py_TYPE(value);
-            if (instance_class != type) {
-                int is_subclass = PyObject_IsSubclass(instance_class, type);
-                if (!is_subclass) {
-                    instance_class = NULL;
-                } else if (unlikely(is_subclass == -1)) {
-                    goto bad;
-                } else {
-                    type = instance_class;
-                }
-            }
+    #else
+    if (unlikely(Py_EnterRecursiveCall(" while calling a Python object"))) {
+        return NULL;
+    }
+    #endif
+    if (
+#if PY_MAJOR_VERSION >= 3
+            co->co_kwonlyargcount == 0 &&
+#endif
+            likely(kwargs == NULL || nk == 0) &&
+            co->co_flags == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE)) {
+        if (argdefs == NULL && co->co_argcount == nargs) {
+            result = __Pyx_PyFunction_FastCallNoKw(co, args, nargs, globals);
+            goto done;
         }
-        if (!instance_class) {
-            PyObject *args;
-            if (!value)
-                args = PyTuple_New(0);
-            else if (PyTuple_Check(value)) {
-                Py_INCREF(value);
-                args = value;
-            } else
-                args = PyTuple_Pack(1, value);
-            if (!args)
-                goto bad;
-            owned_instance = PyObject_Call(type, args, NULL);
-            Py_DECREF(args);
-            if (!owned_instance)
-                goto bad;
-            value = owned_instance;
-            if (!PyExceptionInstance_Check(value)) {
-                PyErr_Format(PyExc_TypeError,
-                             "calling %R should have returned an instance of "
-                             "BaseException, not %R",
-                             type, Py_TYPE(value));
-                goto bad;
-            }
+        else if (nargs == 0 && argdefs != NULL
+                 && co->co_argcount == Py_SIZE(argdefs)) {
+            /* function called with no arguments, but all parameters have
+               a default value: use default values as arguments .*/
+            args = &PyTuple_GET_ITEM(argdefs, 0);
+            result =__Pyx_PyFunction_FastCallNoKw(co, args, Py_SIZE(argdefs), globals);
+            goto done;
         }
-    } else {
-        PyErr_SetString(PyExc_TypeError,
-            "raise: exception class must be a subclass of BaseException");
-        goto bad;
     }
-    if (cause) {
-        PyObject *fixed_cause;
-        if (cause == Py_None) {
-            fixed_cause = NULL;
-        } else if (PyExceptionClass_Check(cause)) {
-            fixed_cause = PyObject_CallObject(cause, NULL);
-            if (fixed_cause == NULL)
-                goto bad;
-        } else if (PyExceptionInstance_Check(cause)) {
-            fixed_cause = cause;
-            Py_INCREF(fixed_cause);
-        } else {
-            PyErr_SetString(PyExc_TypeError,
-                            "exception causes must derive from "
-                            "BaseException");
-            goto bad;
+    if (kwargs != NULL) {
+        Py_ssize_t pos, i;
+        kwtuple = PyTuple_New(2 * nk);
+        if (kwtuple == NULL) {
+            result = NULL;
+            goto done;
         }
-        PyException_SetCause(value, fixed_cause);
+        k = &PyTuple_GET_ITEM(kwtuple, 0);
+        pos = i = 0;
+        while (PyDict_Next(kwargs, &pos, &k[i], &k[i+1])) {
+            Py_INCREF(k[i]);
+            Py_INCREF(k[i+1]);
+            i += 2;
+        }
+        nk = i / 2;
     }
-    PyErr_SetObject(type, value);
-    if (tb) {
-#if CYTHON_COMPILING_IN_PYPY
-        PyObject *tmp_type, *tmp_value, *tmp_tb;
-        PyErr_Fetch(&tmp_type, &tmp_value, &tmp_tb);
-        Py_INCREF(tb);
-        PyErr_Restore(tmp_type, tmp_value, tb);
-        Py_XDECREF(tmp_tb);
+    else {
+        kwtuple = NULL;
+        k = NULL;
+    }
+    closure = PyFunction_GET_CLOSURE(func);
+#if PY_MAJOR_VERSION >= 3
+    kwdefs = PyFunction_GET_KW_DEFAULTS(func);
+#endif
+    if (argdefs != NULL) {
+        d = &PyTuple_GET_ITEM(argdefs, 0);
+        nd = Py_SIZE(argdefs);
+    }
+    else {
+        d = NULL;
+        nd = 0;
+    }
+#if PY_MAJOR_VERSION >= 3
+    result = PyEval_EvalCodeEx((PyObject*)co, globals, (PyObject *)NULL,
+                               args, (int)nargs,
+                               k, (int)nk,
+                               d, (int)nd, kwdefs, closure);
 #else
-        PyThreadState *tstate = __Pyx_PyThreadState_Current;
-        PyObject* tmp_tb = tstate->curexc_traceback;
-        if (tb != tmp_tb) {
-            Py_INCREF(tb);
-            tstate->curexc_traceback = tb;
-            Py_XDECREF(tmp_tb);
-        }
+    result = PyEval_EvalCodeEx(co, globals, (PyObject *)NULL,
+                               args, (int)nargs,
+                               k, (int)nk,
+                               d, (int)nd, closure);
 #endif
+    Py_XDECREF(kwtuple);
+done:
+    Py_LeaveRecursiveCall();
+    return result;
+}
+#endif
+
+/* PyObjectCallMethO */
+  #if CYTHON_COMPILING_IN_CPYTHON
+static CYTHON_INLINE PyObject* __Pyx_PyObject_CallMethO(PyObject *func, PyObject *arg) {
+    PyObject *self, *result;
+    PyCFunction cfunc;
+    cfunc = __Pyx_CyOrPyCFunction_GET_FUNCTION(func);
+    self = __Pyx_CyOrPyCFunction_GET_SELF(func);
+    #if PY_MAJOR_VERSION < 3
+    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
+        return NULL;
+    #else
+    if (unlikely(Py_EnterRecursiveCall(" while calling a Python object")))
+        return NULL;
+    #endif
+    result = cfunc(self, arg);
+    Py_LeaveRecursiveCall();
+    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
+        PyErr_SetString(
+            PyExc_SystemError,
+            "NULL result without error in PyObject_Call");
     }
-bad:
-    Py_XDECREF(owned_instance);
-    return;
+    return result;
 }
 #endif
 
-/* WriteUnraisableException */
-  static void __Pyx_WriteUnraisable(const char *name, CYTHON_UNUSED int clineno,
-                                  CYTHON_UNUSED int lineno, CYTHON_UNUSED const char *filename,
-                                  int full_traceback, CYTHON_UNUSED int nogil) {
-    PyObject *old_exc, *old_val, *old_tb;
-    PyObject *ctx;
-    __Pyx_PyThreadState_declare
-#ifdef WITH_THREAD
-    PyGILState_STATE state;
-    if (nogil)
-        state = PyGILState_Ensure();
-#ifdef _MSC_VER
-    else state = (PyGILState_STATE)-1;
+/* PyObjectFastCall */
+  #if PY_VERSION_HEX < 0x03090000 || CYTHON_COMPILING_IN_LIMITED_API
+static PyObject* __Pyx_PyObject_FastCall_fallback(PyObject *func, PyObject **args, size_t nargs, PyObject *kwargs) {
+    PyObject *argstuple;
+    PyObject *result = 0;
+    size_t i;
+    argstuple = PyTuple_New((Py_ssize_t)nargs);
+    if (unlikely(!argstuple)) return NULL;
+    for (i = 0; i < nargs; i++) {
+        Py_INCREF(args[i]);
+        if (__Pyx_PyTuple_SET_ITEM(argstuple, (Py_ssize_t)i, args[i]) < 0) goto bad;
+    }
+    result = __Pyx_PyObject_Call(func, argstuple, kwargs);
+  bad:
+    Py_DECREF(argstuple);
+    return result;
+}
 #endif
+static CYTHON_INLINE PyObject* __Pyx_PyObject_FastCallDict(PyObject *func, PyObject **args, size_t _nargs, PyObject *kwargs) {
+    Py_ssize_t nargs = __Pyx_PyVectorcall_NARGS(_nargs);
+#if CYTHON_COMPILING_IN_CPYTHON
+    if (nargs == 0 && kwargs == NULL) {
+        if (__Pyx_CyOrPyCFunction_Check(func) && likely( __Pyx_CyOrPyCFunction_GET_FLAGS(func) & METH_NOARGS))
+            return __Pyx_PyObject_CallMethO(func, NULL);
+    }
+    else if (nargs == 1 && kwargs == NULL) {
+        if (__Pyx_CyOrPyCFunction_Check(func) && likely( __Pyx_CyOrPyCFunction_GET_FLAGS(func) & METH_O))
+            return __Pyx_PyObject_CallMethO(func, args[0]);
+    }
 #endif
-    __Pyx_PyThreadState_assign
-    __Pyx_ErrFetch(&old_exc, &old_val, &old_tb);
-    if (full_traceback) {
-        Py_XINCREF(old_exc);
-        Py_XINCREF(old_val);
-        Py_XINCREF(old_tb);
-        __Pyx_ErrRestore(old_exc, old_val, old_tb);
-        PyErr_PrintEx(1);
+    #if PY_VERSION_HEX < 0x030800B1
+    #if CYTHON_FAST_PYCCALL
+    if (PyCFunction_Check(func)) {
+        if (kwargs) {
+            return _PyCFunction_FastCallDict(func, args, nargs, kwargs);
+        } else {
+            return _PyCFunction_FastCallKeywords(func, args, nargs, NULL);
+        }
+    }
+    #if PY_VERSION_HEX >= 0x030700A1
+    if (!kwargs && __Pyx_IS_TYPE(func, &PyMethodDescr_Type)) {
+        return _PyMethodDescr_FastCallKeywords(func, args, nargs, NULL);
     }
-    #if PY_MAJOR_VERSION < 3
-    ctx = PyString_FromString(name);
-    #else
-    ctx = PyUnicode_FromString(name);
     #endif
-    __Pyx_ErrRestore(old_exc, old_val, old_tb);
-    if (!ctx) {
-        PyErr_WriteUnraisable(Py_None);
-    } else {
-        PyErr_WriteUnraisable(ctx);
-        Py_DECREF(ctx);
+    #endif
+    #if CYTHON_FAST_PYCALL
+    if (PyFunction_Check(func)) {
+        return __Pyx_PyFunction_FastCallDict(func, args, nargs, kwargs);
     }
-#ifdef WITH_THREAD
-    if (nogil)
-        PyGILState_Release(state);
-#endif
+    #endif
+    #endif
+    if (kwargs == NULL) {
+        #if CYTHON_VECTORCALL
+        #if PY_VERSION_HEX < 0x03090000
+        vectorcallfunc f = _PyVectorcall_Function(func);
+        #else
+        vectorcallfunc f = PyVectorcall_Function(func);
+        #endif
+        if (f) {
+            return f(func, args, (size_t)nargs, NULL);
+        }
+        #elif defined(__Pyx_CyFunction_USED) && CYTHON_BACKPORT_VECTORCALL
+        if (__Pyx_CyFunction_CheckExact(func)) {
+            __pyx_vectorcallfunc f = __Pyx_CyFunction_func_vectorcall(func);
+            if (f) return f(func, args, (size_t)nargs, NULL);
+        }
+        #endif
+    }
+    if (nargs == 0) {
+        return __Pyx_PyObject_Call(func, __pyx_empty_tuple, kwargs);
+    }
+    #if PY_VERSION_HEX >= 0x03090000 && !CYTHON_COMPILING_IN_LIMITED_API
+    return PyObject_VectorcallDict(func, args, (size_t)nargs, kwargs);
+    #else
+    return __Pyx_PyObject_FastCall_fallback(func, args, (size_t)nargs, kwargs);
+    #endif
 }
 
-/* GetTopmostException */
-  #if CYTHON_USE_EXC_INFO_STACK
-static _PyErr_StackItem *
-__Pyx_PyErr_GetTopmostException(PyThreadState *tstate)
-{
-    _PyErr_StackItem *exc_info = tstate->exc_info;
-    while ((exc_info->exc_type == NULL || exc_info->exc_type == Py_None) &&
-           exc_info->previous_item != NULL)
-    {
-        exc_info = exc_info->previous_item;
+/* PyObjectCallOneArg */
+  static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg) {
+    PyObject *args[2] = {NULL, arg};
+    return __Pyx_PyObject_FastCall(func, args+1, 1 | __Pyx_PY_VECTORCALL_ARGUMENTS_OFFSET);
+}
+
+/* ObjectGetItem */
+  #if CYTHON_USE_TYPE_SLOTS
+static PyObject *__Pyx_PyObject_GetIndex(PyObject *obj, PyObject *index) {
+    PyObject *runerr = NULL;
+    Py_ssize_t key_value;
+    key_value = __Pyx_PyIndex_AsSsize_t(index);
+    if (likely(key_value != -1 || !(runerr = PyErr_Occurred()))) {
+        return __Pyx_GetItemInt_Fast(obj, key_value, 0, 1, 1);
     }
-    return exc_info;
+    if (PyErr_GivenExceptionMatches(runerr, PyExc_OverflowError)) {
+        __Pyx_TypeName index_type_name = __Pyx_PyType_GetName(Py_TYPE(index));
+        PyErr_Clear();
+        PyErr_Format(PyExc_IndexError,
+            "cannot fit '" __Pyx_FMT_TYPENAME "' into an index-sized integer", index_type_name);
+        __Pyx_DECREF_TypeName(index_type_name);
+    }
+    return NULL;
+}
+static PyObject *__Pyx_PyObject_GetItem_Slow(PyObject *obj, PyObject *key) {
+    __Pyx_TypeName obj_type_name;
+    if (likely(PyType_Check(obj))) {
+        PyObject *meth = __Pyx_PyObject_GetAttrStrNoError(obj, __pyx_n_s_class_getitem);
+        if (!meth) {
+            PyErr_Clear();
+        } else {
+            PyObject *result = __Pyx_PyObject_CallOneArg(meth, key);
+            Py_DECREF(meth);
+            return result;
+        }
+    }
+    obj_type_name = __Pyx_PyType_GetName(Py_TYPE(obj));
+    PyErr_Format(PyExc_TypeError,
+        "'" __Pyx_FMT_TYPENAME "' object is not subscriptable", obj_type_name);
+    __Pyx_DECREF_TypeName(obj_type_name);
+    return NULL;
+}
+static PyObject *__Pyx_PyObject_GetItem(PyObject *obj, PyObject *key) {
+    PyTypeObject *tp = Py_TYPE(obj);
+    PyMappingMethods *mm = tp->tp_as_mapping;
+    PySequenceMethods *sm = tp->tp_as_sequence;
+    if (likely(mm && mm->mp_subscript)) {
+        return mm->mp_subscript(obj, key);
+    }
+    if (likely(sm && sm->sq_item)) {
+        return __Pyx_PyObject_GetIndex(obj, key);
+    }
+    return __Pyx_PyObject_GetItem_Slow(obj, key);
 }
 #endif
 
-/* SaveResetException */
-  #if CYTHON_FAST_THREAD_STATE
-static CYTHON_INLINE void __Pyx__ExceptionSave(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
-    #if CYTHON_USE_EXC_INFO_STACK
-    _PyErr_StackItem *exc_info = __Pyx_PyErr_GetTopmostException(tstate);
-    *type = exc_info->exc_type;
-    *value = exc_info->exc_value;
-    *tb = exc_info->exc_traceback;
-    #else
-    *type = tstate->exc_type;
-    *value = tstate->exc_value;
-    *tb = tstate->exc_traceback;
-    #endif
-    Py_XINCREF(*type);
-    Py_XINCREF(*value);
-    Py_XINCREF(*tb);
+/* ExtTypeTest */
+  static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type) {
+    __Pyx_TypeName obj_type_name;
+    __Pyx_TypeName type_name;
+    if (unlikely(!type)) {
+        PyErr_SetString(PyExc_SystemError, "Missing type object");
+        return 0;
+    }
+    if (likely(__Pyx_TypeCheck(obj, type)))
+        return 1;
+    obj_type_name = __Pyx_PyType_GetName(Py_TYPE(obj));
+    type_name = __Pyx_PyType_GetName(type);
+    PyErr_Format(PyExc_TypeError,
+                 "Cannot convert " __Pyx_FMT_TYPENAME " to " __Pyx_FMT_TYPENAME,
+                 obj_type_name, type_name);
+    __Pyx_DECREF_TypeName(obj_type_name);
+    __Pyx_DECREF_TypeName(type_name);
+    return 0;
 }
-static CYTHON_INLINE void __Pyx__ExceptionReset(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb) {
-    PyObject *tmp_type, *tmp_value, *tmp_tb;
-    #if CYTHON_USE_EXC_INFO_STACK
-    _PyErr_StackItem *exc_info = tstate->exc_info;
-    tmp_type = exc_info->exc_type;
-    tmp_value = exc_info->exc_value;
-    tmp_tb = exc_info->exc_traceback;
-    exc_info->exc_type = type;
-    exc_info->exc_value = value;
-    exc_info->exc_traceback = tb;
-    #else
-    tmp_type = tstate->exc_type;
-    tmp_value = tstate->exc_value;
-    tmp_tb = tstate->exc_traceback;
-    tstate->exc_type = type;
-    tstate->exc_value = value;
-    tstate->exc_traceback = tb;
+
+/* PyIntBinop */
+  #if !CYTHON_COMPILING_IN_PYPY
+static PyObject* __Pyx_PyInt_AddObjC(PyObject *op1, PyObject *op2, long intval, int inplace, int zerodivision_check) {
+    CYTHON_MAYBE_UNUSED_VAR(intval);
+    CYTHON_MAYBE_UNUSED_VAR(inplace);
+    CYTHON_UNUSED_VAR(zerodivision_check);
+    #if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_CheckExact(op1))) {
+        const long b = intval;
+        long x;
+        long a = PyInt_AS_LONG(op1);
+        
+            x = (long)((unsigned long)a + (unsigned long)b);
+            if (likely((x^a) >= 0 || (x^b) >= 0))
+                return PyInt_FromLong(x);
+            return PyLong_Type.tp_as_number->nb_add(op1, op2);
+    }
     #endif
-    Py_XDECREF(tmp_type);
-    Py_XDECREF(tmp_value);
-    Py_XDECREF(tmp_tb);
+    #if CYTHON_USE_PYLONG_INTERNALS
+    if (likely(PyLong_CheckExact(op1))) {
+        const long b = intval;
+        long a, x;
+#ifdef HAVE_LONG_LONG
+        const PY_LONG_LONG llb = intval;
+        PY_LONG_LONG lla, llx;
+#endif
+        if (unlikely(__Pyx_PyLong_IsZero(op1))) {
+            return __Pyx_NewRef(op2);
+        }
+        if (likely(__Pyx_PyLong_IsCompact(op1))) {
+            a = __Pyx_PyLong_CompactValue(op1);
+        } else {
+            const digit* digits = __Pyx_PyLong_Digits(op1);
+            const Py_ssize_t size = __Pyx_PyLong_SignedDigitCount(op1);
+            switch (size) {
+                case -2:
+                    if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
+                        a = -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
+                        break;
+                    #ifdef HAVE_LONG_LONG
+                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 2 * PyLong_SHIFT) {
+                        lla = -(PY_LONG_LONG) (((((unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
+                        goto long_long;
+                    #endif
+                    }
+                    CYTHON_FALLTHROUGH;
+                case 2:
+                    if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
+                        a = (long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
+                        break;
+                    #ifdef HAVE_LONG_LONG
+                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 2 * PyLong_SHIFT) {
+                        lla = (PY_LONG_LONG) (((((unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
+                        goto long_long;
+                    #endif
+                    }
+                    CYTHON_FALLTHROUGH;
+                case -3:
+                    if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
+                        a = -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
+                        break;
+                    #ifdef HAVE_LONG_LONG
+                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 3 * PyLong_SHIFT) {
+                        lla = -(PY_LONG_LONG) (((((((unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
+                        goto long_long;
+                    #endif
+                    }
+                    CYTHON_FALLTHROUGH;
+                case 3:
+                    if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
+                        a = (long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
+                        break;
+                    #ifdef HAVE_LONG_LONG
+                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 3 * PyLong_SHIFT) {
+                        lla = (PY_LONG_LONG) (((((((unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
+                        goto long_long;
+                    #endif
+                    }
+                    CYTHON_FALLTHROUGH;
+                case -4:
+                    if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
+                        a = -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
+                        break;
+                    #ifdef HAVE_LONG_LONG
+                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 4 * PyLong_SHIFT) {
+                        lla = -(PY_LONG_LONG) (((((((((unsigned PY_LONG_LONG)digits[3]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
+                        goto long_long;
+                    #endif
+                    }
+                    CYTHON_FALLTHROUGH;
+                case 4:
+                    if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
+                        a = (long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
+                        break;
+                    #ifdef HAVE_LONG_LONG
+                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 4 * PyLong_SHIFT) {
+                        lla = (PY_LONG_LONG) (((((((((unsigned PY_LONG_LONG)digits[3]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
+                        goto long_long;
+                    #endif
+                    }
+                    CYTHON_FALLTHROUGH;
+                default: return PyLong_Type.tp_as_number->nb_add(op1, op2);
+            }
+        }
+                x = a + b;
+            return PyLong_FromLong(x);
+#ifdef HAVE_LONG_LONG
+        long_long:
+                llx = lla + llb;
+            return PyLong_FromLongLong(llx);
+#endif
+        
+        
+    }
+    #endif
+    if (PyFloat_CheckExact(op1)) {
+        const long b = intval;
+#if CYTHON_COMPILING_IN_LIMITED_API
+        double a = __pyx_PyFloat_AsDouble(op1);
+#else
+        double a = PyFloat_AS_DOUBLE(op1);
+#endif
+            double result;
+            
+            PyFPE_START_PROTECT("add", return NULL)
+            result = ((double)a) + (double)b;
+            PyFPE_END_PROTECT(result)
+            return PyFloat_FromDouble(result);
+    }
+    return (inplace ? PyNumber_InPlaceAdd : PyNumber_Add)(op1, op2);
 }
 #endif
 
-/* PyErrExceptionMatches */
-  #if CYTHON_FAST_THREAD_STATE
-static int __Pyx_PyErr_ExceptionMatchesTuple(PyObject *exc_type, PyObject *tuple) {
-    Py_ssize_t i, n;
-    n = PyTuple_GET_SIZE(tuple);
-#if PY_MAJOR_VERSION >= 3
-    for (i=0; i<n; i++) {
-        if (exc_type == PyTuple_GET_ITEM(tuple, i)) return 1;
-    }
+/* PyDictVersioning */
+  #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_TYPE_SLOTS
+static CYTHON_INLINE PY_UINT64_T __Pyx_get_tp_dict_version(PyObject *obj) {
+    PyObject *dict = Py_TYPE(obj)->tp_dict;
+    return likely(dict) ? __PYX_GET_DICT_VERSION(dict) : 0;
+}
+static CYTHON_INLINE PY_UINT64_T __Pyx_get_object_dict_version(PyObject *obj) {
+    PyObject **dictptr = NULL;
+    Py_ssize_t offset = Py_TYPE(obj)->tp_dictoffset;
+    if (offset) {
+#if CYTHON_COMPILING_IN_CPYTHON
+        dictptr = (likely(offset > 0)) ? (PyObject **) ((char *)obj + offset) : _PyObject_GetDictPtr(obj);
+#else
+        dictptr = _PyObject_GetDictPtr(obj);
 #endif
-    for (i=0; i<n; i++) {
-        if (__Pyx_PyErr_GivenExceptionMatches(exc_type, PyTuple_GET_ITEM(tuple, i))) return 1;
     }
-    return 0;
+    return (dictptr && *dictptr) ? __PYX_GET_DICT_VERSION(*dictptr) : 0;
 }
-static CYTHON_INLINE int __Pyx_PyErr_ExceptionMatchesInState(PyThreadState* tstate, PyObject* err) {
-    PyObject *exc_type = tstate->curexc_type;
-    if (exc_type == err) return 1;
-    if (unlikely(!exc_type)) return 0;
-    if (unlikely(PyTuple_Check(err)))
-        return __Pyx_PyErr_ExceptionMatchesTuple(exc_type, err);
-    return __Pyx_PyErr_GivenExceptionMatches(exc_type, err);
+static CYTHON_INLINE int __Pyx_object_dict_version_matches(PyObject* obj, PY_UINT64_T tp_dict_version, PY_UINT64_T obj_dict_version) {
+    PyObject *dict = Py_TYPE(obj)->tp_dict;
+    if (unlikely(!dict) || unlikely(tp_dict_version != __PYX_GET_DICT_VERSION(dict)))
+        return 0;
+    return obj_dict_version == __Pyx_get_object_dict_version(obj);
 }
 #endif
 
-/* GetException */
-  #if CYTHON_FAST_THREAD_STATE
-static int __Pyx__GetException(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb)
+/* GetModuleGlobalName */
+  #if CYTHON_USE_DICT_VERSIONS
+static PyObject *__Pyx__GetModuleGlobalName(PyObject *name, PY_UINT64_T *dict_version, PyObject **dict_cached_value)
 #else
-static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb)
+static CYTHON_INLINE PyObject *__Pyx__GetModuleGlobalName(PyObject *name)
 #endif
 {
-    PyObject *local_type, *local_value, *local_tb;
-#if CYTHON_FAST_THREAD_STATE
-    PyObject *tmp_type, *tmp_value, *tmp_tb;
-    local_type = tstate->curexc_type;
-    local_value = tstate->curexc_value;
-    local_tb = tstate->curexc_traceback;
-    tstate->curexc_type = 0;
-    tstate->curexc_value = 0;
-    tstate->curexc_traceback = 0;
+    PyObject *result;
+#if !CYTHON_AVOID_BORROWED_REFS
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030500A1 && PY_VERSION_HEX < 0x030d0000
+    result = _PyDict_GetItem_KnownHash(__pyx_d, name, ((PyASCIIObject *) name)->hash);
+    __PYX_UPDATE_DICT_CACHE(__pyx_d, result, *dict_cached_value, *dict_version)
+    if (likely(result)) {
+        return __Pyx_NewRef(result);
+    } else if (unlikely(PyErr_Occurred())) {
+        return NULL;
+    }
+#elif CYTHON_COMPILING_IN_LIMITED_API
+    if (unlikely(!__pyx_m)) {
+        return NULL;
+    }
+    result = PyObject_GetAttr(__pyx_m, name);
+    if (likely(result)) {
+        return result;
+    }
 #else
-    PyErr_Fetch(&local_type, &local_value, &local_tb);
+    result = PyDict_GetItem(__pyx_d, name);
+    __PYX_UPDATE_DICT_CACHE(__pyx_d, result, *dict_cached_value, *dict_version)
+    if (likely(result)) {
+        return __Pyx_NewRef(result);
+    }
 #endif
-    PyErr_NormalizeException(&local_type, &local_value, &local_tb);
-#if CYTHON_FAST_THREAD_STATE
-    if (unlikely(tstate->curexc_type))
 #else
-    if (unlikely(PyErr_Occurred()))
+    result = PyObject_GetItem(__pyx_d, name);
+    __PYX_UPDATE_DICT_CACHE(__pyx_d, result, *dict_cached_value, *dict_version)
+    if (likely(result)) {
+        return __Pyx_NewRef(result);
+    }
+    PyErr_Clear();
 #endif
-        goto bad;
-    #if PY_MAJOR_VERSION >= 3
-    if (local_tb) {
-        if (unlikely(PyException_SetTraceback(local_value, local_tb) < 0))
-            goto bad;
+    return __Pyx_GetBuiltinName(name);
+}
+
+/* ErrOccurredWithGIL */
+  static CYTHON_INLINE int __Pyx_ErrOccurredWithGIL(void) {
+  int err;
+  #ifdef WITH_THREAD
+  PyGILState_STATE _save = PyGILState_Ensure();
+  #endif
+  err = !!PyErr_Occurred();
+  #ifdef WITH_THREAD
+  PyGILState_Release(_save);
+  #endif
+  return err;
+}
+
+/* PyIntCompare */
+  static CYTHON_INLINE PyObject* __Pyx_PyInt_EqObjC(PyObject *op1, PyObject *op2, long intval, long inplace) {
+    CYTHON_MAYBE_UNUSED_VAR(intval);
+    CYTHON_UNUSED_VAR(inplace);
+    if (op1 == op2) {
+        Py_RETURN_TRUE;
+    }
+    #if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_CheckExact(op1))) {
+        const long b = intval;
+        long a = PyInt_AS_LONG(op1);
+        if (a == b) Py_RETURN_TRUE; else Py_RETURN_FALSE;
     }
     #endif
-    Py_XINCREF(local_tb);
-    Py_XINCREF(local_type);
-    Py_XINCREF(local_value);
-    *type = local_type;
-    *value = local_value;
-    *tb = local_tb;
-#if CYTHON_FAST_THREAD_STATE
-    #if CYTHON_USE_EXC_INFO_STACK
-    {
-        _PyErr_StackItem *exc_info = tstate->exc_info;
-        tmp_type = exc_info->exc_type;
-        tmp_value = exc_info->exc_value;
-        tmp_tb = exc_info->exc_traceback;
-        exc_info->exc_type = local_type;
-        exc_info->exc_value = local_value;
-        exc_info->exc_traceback = local_tb;
+    #if CYTHON_USE_PYLONG_INTERNALS
+    if (likely(PyLong_CheckExact(op1))) {
+        int unequal;
+        unsigned long uintval;
+        Py_ssize_t size = __Pyx_PyLong_DigitCount(op1);
+        const digit* digits = __Pyx_PyLong_Digits(op1);
+        if (intval == 0) {
+            if (__Pyx_PyLong_IsZero(op1) == 1) Py_RETURN_TRUE; else Py_RETURN_FALSE;
+        } else if (intval < 0) {
+            if (__Pyx_PyLong_IsNonNeg(op1))
+                Py_RETURN_FALSE;
+            intval = -intval;
+        } else {
+            if (__Pyx_PyLong_IsNeg(op1))
+                Py_RETURN_FALSE;
+        }
+        uintval = (unsigned long) intval;
+#if PyLong_SHIFT * 4 < SIZEOF_LONG*8
+        if (uintval >> (PyLong_SHIFT * 4)) {
+            unequal = (size != 5) || (digits[0] != (uintval & (unsigned long) PyLong_MASK))
+                 | (digits[1] != ((uintval >> (1 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK)) | (digits[2] != ((uintval >> (2 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK)) | (digits[3] != ((uintval >> (3 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK)) | (digits[4] != ((uintval >> (4 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK));
+        } else
+#endif
+#if PyLong_SHIFT * 3 < SIZEOF_LONG*8
+        if (uintval >> (PyLong_SHIFT * 3)) {
+            unequal = (size != 4) || (digits[0] != (uintval & (unsigned long) PyLong_MASK))
+                 | (digits[1] != ((uintval >> (1 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK)) | (digits[2] != ((uintval >> (2 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK)) | (digits[3] != ((uintval >> (3 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK));
+        } else
+#endif
+#if PyLong_SHIFT * 2 < SIZEOF_LONG*8
+        if (uintval >> (PyLong_SHIFT * 2)) {
+            unequal = (size != 3) || (digits[0] != (uintval & (unsigned long) PyLong_MASK))
+                 | (digits[1] != ((uintval >> (1 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK)) | (digits[2] != ((uintval >> (2 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK));
+        } else
+#endif
+#if PyLong_SHIFT * 1 < SIZEOF_LONG*8
+        if (uintval >> (PyLong_SHIFT * 1)) {
+            unequal = (size != 2) || (digits[0] != (uintval & (unsigned long) PyLong_MASK))
+                 | (digits[1] != ((uintval >> (1 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK));
+        } else
+#endif
+            unequal = (size != 1) || (((unsigned long) digits[0]) != (uintval & (unsigned long) PyLong_MASK));
+        if (unequal == 0) Py_RETURN_TRUE; else Py_RETURN_FALSE;
     }
-    #else
-    tmp_type = tstate->exc_type;
-    tmp_value = tstate->exc_value;
-    tmp_tb = tstate->exc_traceback;
-    tstate->exc_type = local_type;
-    tstate->exc_value = local_value;
-    tstate->exc_traceback = local_tb;
     #endif
-    Py_XDECREF(tmp_type);
-    Py_XDECREF(tmp_value);
-    Py_XDECREF(tmp_tb);
+    if (PyFloat_CheckExact(op1)) {
+        const long b = intval;
+#if CYTHON_COMPILING_IN_LIMITED_API
+        double a = __pyx_PyFloat_AsDouble(op1);
 #else
-    PyErr_SetExcInfo(local_type, local_value, local_tb);
+        double a = PyFloat_AS_DOUBLE(op1);
 #endif
-    return 0;
-bad:
-    *type = 0;
-    *value = 0;
-    *tb = 0;
-    Py_XDECREF(local_type);
-    Py_XDECREF(local_value);
-    Py_XDECREF(local_tb);
-    return -1;
+        if ((double)a == (double)b) Py_RETURN_TRUE; else Py_RETURN_FALSE;
+    }
+    return (
+        PyObject_RichCompare(op1, op2, Py_EQ));
 }
 
 /* TypeImport */
-  #ifndef __PYX_HAVE_RT_ImportType
-#define __PYX_HAVE_RT_ImportType
-static PyTypeObject *__Pyx_ImportType(PyObject *module, const char *module_name, const char *class_name,
-    size_t size, enum __Pyx_ImportType_CheckSize check_size)
+  #ifndef __PYX_HAVE_RT_ImportType_3_0_10
+#define __PYX_HAVE_RT_ImportType_3_0_10
+static PyTypeObject *__Pyx_ImportType_3_0_10(PyObject *module, const char *module_name, const char *class_name,
+    size_t size, size_t alignment, enum __Pyx_ImportType_CheckSize_3_0_10 check_size)
 {
     PyObject *result = 0;
     char warning[200];
     Py_ssize_t basicsize;
-#ifdef Py_LIMITED_API
+    Py_ssize_t itemsize;
+#if CYTHON_COMPILING_IN_LIMITED_API
     PyObject *py_basicsize;
+    PyObject *py_itemsize;
 #endif
     result = PyObject_GetAttrString(module, class_name);
     if (!result)
         goto bad;
     if (!PyType_Check(result)) {
         PyErr_Format(PyExc_TypeError,
             "%.200s.%.200s is not a type object",
             module_name, class_name);
         goto bad;
     }
-#ifndef Py_LIMITED_API
+#if !CYTHON_COMPILING_IN_LIMITED_API
     basicsize = ((PyTypeObject *)result)->tp_basicsize;
+    itemsize = ((PyTypeObject *)result)->tp_itemsize;
 #else
     py_basicsize = PyObject_GetAttrString(result, "__basicsize__");
     if (!py_basicsize)
         goto bad;
     basicsize = PyLong_AsSsize_t(py_basicsize);
     Py_DECREF(py_basicsize);
     py_basicsize = 0;
     if (basicsize == (Py_ssize_t)-1 && PyErr_Occurred())
         goto bad;
+    py_itemsize = PyObject_GetAttrString(result, "__itemsize__");
+    if (!py_itemsize)
+        goto bad;
+    itemsize = PyLong_AsSsize_t(py_itemsize);
+    Py_DECREF(py_itemsize);
+    py_itemsize = 0;
+    if (itemsize == (Py_ssize_t)-1 && PyErr_Occurred())
+        goto bad;
 #endif
-    if ((size_t)basicsize < size) {
+    if (itemsize) {
+        if (size % alignment) {
+            alignment = size % alignment;
+        }
+        if (itemsize < (Py_ssize_t)alignment)
+            itemsize = (Py_ssize_t)alignment;
+    }
+    if ((size_t)(basicsize + itemsize) < size) {
         PyErr_Format(PyExc_ValueError,
             "%.200s.%.200s size changed, may indicate binary incompatibility. "
             "Expected %zd from C header, got %zd from PyObject",
-            module_name, class_name, size, basicsize);
+            module_name, class_name, size, basicsize+itemsize);
         goto bad;
     }
-    if (check_size == __Pyx_ImportType_CheckSize_Error && (size_t)basicsize != size) {
+    if (check_size == __Pyx_ImportType_CheckSize_Error_3_0_10 &&
+            ((size_t)basicsize > size || (size_t)(basicsize + itemsize) < size)) {
         PyErr_Format(PyExc_ValueError,
             "%.200s.%.200s size changed, may indicate binary incompatibility. "
-            "Expected %zd from C header, got %zd from PyObject",
-            module_name, class_name, size, basicsize);
+            "Expected %zd from C header, got %zd-%zd from PyObject",
+            module_name, class_name, size, basicsize, basicsize+itemsize);
         goto bad;
     }
-    else if (check_size == __Pyx_ImportType_CheckSize_Warn && (size_t)basicsize > size) {
+    else if (check_size == __Pyx_ImportType_CheckSize_Warn_3_0_10 && (size_t)basicsize > size) {
         PyOS_snprintf(warning, sizeof(warning),
             "%s.%s size changed, may indicate binary incompatibility. "
             "Expected %zd from C header, got %zd from PyObject",
             module_name, class_name, size, basicsize);
         if (PyErr_WarnEx(NULL, warning, 0) < 0) goto bad;
     }
     return (PyTypeObject *)result;
@@ -8607,113 +8632,1471 @@
     Py_XDECREF(result);
     return NULL;
 }
 #endif
 
 /* Import */
   static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level) {
-    PyObject *empty_list = 0;
     PyObject *module = 0;
-    PyObject *global_dict = 0;
     PyObject *empty_dict = 0;
-    PyObject *list;
+    PyObject *empty_list = 0;
     #if PY_MAJOR_VERSION < 3
     PyObject *py_import;
     py_import = __Pyx_PyObject_GetAttrStr(__pyx_b, __pyx_n_s_import);
-    if (!py_import)
+    if (unlikely(!py_import))
         goto bad;
-    #endif
-    if (from_list)
-        list = from_list;
-    else {
+    if (!from_list) {
         empty_list = PyList_New(0);
-        if (!empty_list)
+        if (unlikely(!empty_list))
             goto bad;
-        list = empty_list;
+        from_list = empty_list;
     }
-    global_dict = PyModule_GetDict(__pyx_m);
-    if (!global_dict)
-        goto bad;
+    #endif
     empty_dict = PyDict_New();
-    if (!empty_dict)
+    if (unlikely(!empty_dict))
         goto bad;
     {
         #if PY_MAJOR_VERSION >= 3
         if (level == -1) {
-            if ((1) && (strchr(__Pyx_MODULE_NAME, '.'))) {
+            if (strchr(__Pyx_MODULE_NAME, '.') != NULL) {
                 module = PyImport_ImportModuleLevelObject(
-                    name, global_dict, empty_dict, list, 1);
-                if (!module) {
-                    if (!PyErr_ExceptionMatches(PyExc_ImportError))
+                    name, __pyx_d, empty_dict, from_list, 1);
+                if (unlikely(!module)) {
+                    if (unlikely(!PyErr_ExceptionMatches(PyExc_ImportError)))
                         goto bad;
                     PyErr_Clear();
                 }
             }
             level = 0;
         }
         #endif
         if (!module) {
             #if PY_MAJOR_VERSION < 3
             PyObject *py_level = PyInt_FromLong(level);
-            if (!py_level)
+            if (unlikely(!py_level))
                 goto bad;
             module = PyObject_CallFunctionObjArgs(py_import,
-                name, global_dict, empty_dict, list, py_level, (PyObject *)NULL);
+                name, __pyx_d, empty_dict, from_list, py_level, (PyObject *)NULL);
             Py_DECREF(py_level);
             #else
             module = PyImport_ImportModuleLevelObject(
-                name, global_dict, empty_dict, list, level);
+                name, __pyx_d, empty_dict, from_list, level);
             #endif
         }
     }
 bad:
+    Py_XDECREF(empty_dict);
+    Py_XDECREF(empty_list);
     #if PY_MAJOR_VERSION < 3
     Py_XDECREF(py_import);
     #endif
-    Py_XDECREF(empty_list);
-    Py_XDECREF(empty_dict);
     return module;
 }
 
-/* ImportFrom */
-  static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name) {
-    PyObject* value = __Pyx_PyObject_GetAttrStr(module, name);
-    if (unlikely(!value) && PyErr_ExceptionMatches(PyExc_AttributeError)) {
-        PyErr_Format(PyExc_ImportError,
-        #if PY_MAJOR_VERSION < 3
-            "cannot import name %.230s", PyString_AS_STRING(name));
-        #else
-            "cannot import name %S", name);
-        #endif
+/* ImportDottedModule */
+  #if PY_MAJOR_VERSION >= 3
+static PyObject *__Pyx__ImportDottedModule_Error(PyObject *name, PyObject *parts_tuple, Py_ssize_t count) {
+    PyObject *partial_name = NULL, *slice = NULL, *sep = NULL;
+    if (unlikely(PyErr_Occurred())) {
+        PyErr_Clear();
     }
-    return value;
+    if (likely(PyTuple_GET_SIZE(parts_tuple) == count)) {
+        partial_name = name;
+    } else {
+        slice = PySequence_GetSlice(parts_tuple, 0, count);
+        if (unlikely(!slice))
+            goto bad;
+        sep = PyUnicode_FromStringAndSize(".", 1);
+        if (unlikely(!sep))
+            goto bad;
+        partial_name = PyUnicode_Join(sep, slice);
+    }
+    PyErr_Format(
+#if PY_MAJOR_VERSION < 3
+        PyExc_ImportError,
+        "No module named '%s'", PyString_AS_STRING(partial_name));
+#else
+#if PY_VERSION_HEX >= 0x030600B1
+        PyExc_ModuleNotFoundError,
+#else
+        PyExc_ImportError,
+#endif
+        "No module named '%U'", partial_name);
+#endif
+bad:
+    Py_XDECREF(sep);
+    Py_XDECREF(slice);
+    Py_XDECREF(partial_name);
+    return NULL;
+}
+#endif
+#if PY_MAJOR_VERSION >= 3
+static PyObject *__Pyx__ImportDottedModule_Lookup(PyObject *name) {
+    PyObject *imported_module;
+#if PY_VERSION_HEX < 0x030700A1 || (CYTHON_COMPILING_IN_PYPY && PYPY_VERSION_NUM  < 0x07030400)
+    PyObject *modules = PyImport_GetModuleDict();
+    if (unlikely(!modules))
+        return NULL;
+    imported_module = __Pyx_PyDict_GetItemStr(modules, name);
+    Py_XINCREF(imported_module);
+#else
+    imported_module = PyImport_GetModule(name);
+#endif
+    return imported_module;
+}
+#endif
+#if PY_MAJOR_VERSION >= 3
+static PyObject *__Pyx_ImportDottedModule_WalkParts(PyObject *module, PyObject *name, PyObject *parts_tuple) {
+    Py_ssize_t i, nparts;
+    nparts = PyTuple_GET_SIZE(parts_tuple);
+    for (i=1; i < nparts && module; i++) {
+        PyObject *part, *submodule;
+#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+        part = PyTuple_GET_ITEM(parts_tuple, i);
+#else
+        part = PySequence_ITEM(parts_tuple, i);
+#endif
+        submodule = __Pyx_PyObject_GetAttrStrNoError(module, part);
+#if !(CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS)
+        Py_DECREF(part);
+#endif
+        Py_DECREF(module);
+        module = submodule;
+    }
+    if (unlikely(!module)) {
+        return __Pyx__ImportDottedModule_Error(name, parts_tuple, i);
+    }
+    return module;
+}
+#endif
+static PyObject *__Pyx__ImportDottedModule(PyObject *name, PyObject *parts_tuple) {
+#if PY_MAJOR_VERSION < 3
+    PyObject *module, *from_list, *star = __pyx_n_s__10;
+    CYTHON_UNUSED_VAR(parts_tuple);
+    from_list = PyList_New(1);
+    if (unlikely(!from_list))
+        return NULL;
+    Py_INCREF(star);
+    PyList_SET_ITEM(from_list, 0, star);
+    module = __Pyx_Import(name, from_list, 0);
+    Py_DECREF(from_list);
+    return module;
+#else
+    PyObject *imported_module;
+    PyObject *module = __Pyx_Import(name, NULL, 0);
+    if (!parts_tuple || unlikely(!module))
+        return module;
+    imported_module = __Pyx__ImportDottedModule_Lookup(name);
+    if (likely(imported_module)) {
+        Py_DECREF(module);
+        return imported_module;
+    }
+    PyErr_Clear();
+    return __Pyx_ImportDottedModule_WalkParts(module, name, parts_tuple);
+#endif
+}
+static PyObject *__Pyx_ImportDottedModule(PyObject *name, PyObject *parts_tuple) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030400B1
+    PyObject *module = __Pyx__ImportDottedModule_Lookup(name);
+    if (likely(module)) {
+        PyObject *spec = __Pyx_PyObject_GetAttrStrNoError(module, __pyx_n_s_spec);
+        if (likely(spec)) {
+            PyObject *unsafe = __Pyx_PyObject_GetAttrStrNoError(spec, __pyx_n_s_initializing);
+            if (likely(!unsafe || !__Pyx_PyObject_IsTrue(unsafe))) {
+                Py_DECREF(spec);
+                spec = NULL;
+            }
+            Py_XDECREF(unsafe);
+        }
+        if (likely(!spec)) {
+            PyErr_Clear();
+            return module;
+        }
+        Py_DECREF(spec);
+        Py_DECREF(module);
+    } else if (PyErr_Occurred()) {
+        PyErr_Clear();
+    }
+#endif
+    return __Pyx__ImportDottedModule(name, parts_tuple);
+}
+
+/* FixUpExtensionType */
+  #if CYTHON_USE_TYPE_SPECS
+static int __Pyx_fix_up_extension_type_from_spec(PyType_Spec *spec, PyTypeObject *type) {
+#if PY_VERSION_HEX > 0x030900B1 || CYTHON_COMPILING_IN_LIMITED_API
+    CYTHON_UNUSED_VAR(spec);
+    CYTHON_UNUSED_VAR(type);
+#else
+    const PyType_Slot *slot = spec->slots;
+    while (slot && slot->slot && slot->slot != Py_tp_members)
+        slot++;
+    if (slot && slot->slot == Py_tp_members) {
+        int changed = 0;
+#if !(PY_VERSION_HEX <= 0x030900b1 && CYTHON_COMPILING_IN_CPYTHON)
+        const
+#endif
+            PyMemberDef *memb = (PyMemberDef*) slot->pfunc;
+        while (memb && memb->name) {
+            if (memb->name[0] == '_' && memb->name[1] == '_') {
+#if PY_VERSION_HEX < 0x030900b1
+                if (strcmp(memb->name, "__weaklistoffset__") == 0) {
+                    assert(memb->type == T_PYSSIZET);
+                    assert(memb->flags == READONLY);
+                    type->tp_weaklistoffset = memb->offset;
+                    changed = 1;
+                }
+                else if (strcmp(memb->name, "__dictoffset__") == 0) {
+                    assert(memb->type == T_PYSSIZET);
+                    assert(memb->flags == READONLY);
+                    type->tp_dictoffset = memb->offset;
+                    changed = 1;
+                }
+#if CYTHON_METH_FASTCALL
+                else if (strcmp(memb->name, "__vectorcalloffset__") == 0) {
+                    assert(memb->type == T_PYSSIZET);
+                    assert(memb->flags == READONLY);
+#if PY_VERSION_HEX >= 0x030800b4
+                    type->tp_vectorcall_offset = memb->offset;
+#else
+                    type->tp_print = (printfunc) memb->offset;
+#endif
+                    changed = 1;
+                }
+#endif
+#else
+                if ((0));
+#endif
+#if PY_VERSION_HEX <= 0x030900b1 && CYTHON_COMPILING_IN_CPYTHON
+                else if (strcmp(memb->name, "__module__") == 0) {
+                    PyObject *descr;
+                    assert(memb->type == T_OBJECT);
+                    assert(memb->flags == 0 || memb->flags == READONLY);
+                    descr = PyDescr_NewMember(type, memb);
+                    if (unlikely(!descr))
+                        return -1;
+                    if (unlikely(PyDict_SetItem(type->tp_dict, PyDescr_NAME(descr), descr) < 0)) {
+                        Py_DECREF(descr);
+                        return -1;
+                    }
+                    Py_DECREF(descr);
+                    changed = 1;
+                }
+#endif
+            }
+            memb++;
+        }
+        if (changed)
+            PyType_Modified(type);
+    }
+#endif
+    return 0;
+}
+#endif
+
+/* FetchSharedCythonModule */
+  static PyObject *__Pyx_FetchSharedCythonABIModule(void) {
+    return __Pyx_PyImport_AddModuleRef((char*) __PYX_ABI_MODULE_NAME);
+}
+
+/* FetchCommonType */
+  static int __Pyx_VerifyCachedType(PyObject *cached_type,
+                               const char *name,
+                               Py_ssize_t basicsize,
+                               Py_ssize_t expected_basicsize) {
+    if (!PyType_Check(cached_type)) {
+        PyErr_Format(PyExc_TypeError,
+            "Shared Cython type %.200s is not a type object", name);
+        return -1;
+    }
+    if (basicsize != expected_basicsize) {
+        PyErr_Format(PyExc_TypeError,
+            "Shared Cython type %.200s has the wrong size, try recompiling",
+            name);
+        return -1;
+    }
+    return 0;
+}
+#if !CYTHON_USE_TYPE_SPECS
+static PyTypeObject* __Pyx_FetchCommonType(PyTypeObject* type) {
+    PyObject* abi_module;
+    const char* object_name;
+    PyTypeObject *cached_type = NULL;
+    abi_module = __Pyx_FetchSharedCythonABIModule();
+    if (!abi_module) return NULL;
+    object_name = strrchr(type->tp_name, '.');
+    object_name = object_name ? object_name+1 : type->tp_name;
+    cached_type = (PyTypeObject*) PyObject_GetAttrString(abi_module, object_name);
+    if (cached_type) {
+        if (__Pyx_VerifyCachedType(
+              (PyObject *)cached_type,
+              object_name,
+              cached_type->tp_basicsize,
+              type->tp_basicsize) < 0) {
+            goto bad;
+        }
+        goto done;
+    }
+    if (!PyErr_ExceptionMatches(PyExc_AttributeError)) goto bad;
+    PyErr_Clear();
+    if (PyType_Ready(type) < 0) goto bad;
+    if (PyObject_SetAttrString(abi_module, object_name, (PyObject *)type) < 0)
+        goto bad;
+    Py_INCREF(type);
+    cached_type = type;
+done:
+    Py_DECREF(abi_module);
+    return cached_type;
+bad:
+    Py_XDECREF(cached_type);
+    cached_type = NULL;
+    goto done;
+}
+#else
+static PyTypeObject *__Pyx_FetchCommonTypeFromSpec(PyObject *module, PyType_Spec *spec, PyObject *bases) {
+    PyObject *abi_module, *cached_type = NULL;
+    const char* object_name = strrchr(spec->name, '.');
+    object_name = object_name ? object_name+1 : spec->name;
+    abi_module = __Pyx_FetchSharedCythonABIModule();
+    if (!abi_module) return NULL;
+    cached_type = PyObject_GetAttrString(abi_module, object_name);
+    if (cached_type) {
+        Py_ssize_t basicsize;
+#if CYTHON_COMPILING_IN_LIMITED_API
+        PyObject *py_basicsize;
+        py_basicsize = PyObject_GetAttrString(cached_type, "__basicsize__");
+        if (unlikely(!py_basicsize)) goto bad;
+        basicsize = PyLong_AsSsize_t(py_basicsize);
+        Py_DECREF(py_basicsize);
+        py_basicsize = 0;
+        if (unlikely(basicsize == (Py_ssize_t)-1) && PyErr_Occurred()) goto bad;
+#else
+        basicsize = likely(PyType_Check(cached_type)) ? ((PyTypeObject*) cached_type)->tp_basicsize : -1;
+#endif
+        if (__Pyx_VerifyCachedType(
+              cached_type,
+              object_name,
+              basicsize,
+              spec->basicsize) < 0) {
+            goto bad;
+        }
+        goto done;
+    }
+    if (!PyErr_ExceptionMatches(PyExc_AttributeError)) goto bad;
+    PyErr_Clear();
+    CYTHON_UNUSED_VAR(module);
+    cached_type = __Pyx_PyType_FromModuleAndSpec(abi_module, spec, bases);
+    if (unlikely(!cached_type)) goto bad;
+    if (unlikely(__Pyx_fix_up_extension_type_from_spec(spec, (PyTypeObject *) cached_type) < 0)) goto bad;
+    if (PyObject_SetAttrString(abi_module, object_name, cached_type) < 0) goto bad;
+done:
+    Py_DECREF(abi_module);
+    assert(cached_type == NULL || PyType_Check(cached_type));
+    return (PyTypeObject *) cached_type;
+bad:
+    Py_XDECREF(cached_type);
+    cached_type = NULL;
+    goto done;
+}
+#endif
+
+/* PyVectorcallFastCallDict */
+  #if CYTHON_METH_FASTCALL
+static PyObject *__Pyx_PyVectorcall_FastCallDict_kw(PyObject *func, __pyx_vectorcallfunc vc, PyObject *const *args, size_t nargs, PyObject *kw)
+{
+    PyObject *res = NULL;
+    PyObject *kwnames;
+    PyObject **newargs;
+    PyObject **kwvalues;
+    Py_ssize_t i, pos;
+    size_t j;
+    PyObject *key, *value;
+    unsigned long keys_are_strings;
+    Py_ssize_t nkw = PyDict_GET_SIZE(kw);
+    newargs = (PyObject **)PyMem_Malloc((nargs + (size_t)nkw) * sizeof(args[0]));
+    if (unlikely(newargs == NULL)) {
+        PyErr_NoMemory();
+        return NULL;
+    }
+    for (j = 0; j < nargs; j++) newargs[j] = args[j];
+    kwnames = PyTuple_New(nkw);
+    if (unlikely(kwnames == NULL)) {
+        PyMem_Free(newargs);
+        return NULL;
+    }
+    kwvalues = newargs + nargs;
+    pos = i = 0;
+    keys_are_strings = Py_TPFLAGS_UNICODE_SUBCLASS;
+    while (PyDict_Next(kw, &pos, &key, &value)) {
+        keys_are_strings &= Py_TYPE(key)->tp_flags;
+        Py_INCREF(key);
+        Py_INCREF(value);
+        PyTuple_SET_ITEM(kwnames, i, key);
+        kwvalues[i] = value;
+        i++;
+    }
+    if (unlikely(!keys_are_strings)) {
+        PyErr_SetString(PyExc_TypeError, "keywords must be strings");
+        goto cleanup;
+    }
+    res = vc(func, newargs, nargs, kwnames);
+cleanup:
+    Py_DECREF(kwnames);
+    for (i = 0; i < nkw; i++)
+        Py_DECREF(kwvalues[i]);
+    PyMem_Free(newargs);
+    return res;
+}
+static CYTHON_INLINE PyObject *__Pyx_PyVectorcall_FastCallDict(PyObject *func, __pyx_vectorcallfunc vc, PyObject *const *args, size_t nargs, PyObject *kw)
+{
+    if (likely(kw == NULL) || PyDict_GET_SIZE(kw) == 0) {
+        return vc(func, args, nargs, NULL);
+    }
+    return __Pyx_PyVectorcall_FastCallDict_kw(func, vc, args, nargs, kw);
+}
+#endif
+
+/* CythonFunctionShared */
+  #if CYTHON_COMPILING_IN_LIMITED_API
+static CYTHON_INLINE int __Pyx__IsSameCyOrCFunction(PyObject *func, void *cfunc) {
+    if (__Pyx_CyFunction_Check(func)) {
+        return PyCFunction_GetFunction(((__pyx_CyFunctionObject*)func)->func) == (PyCFunction) cfunc;
+    } else if (PyCFunction_Check(func)) {
+        return PyCFunction_GetFunction(func) == (PyCFunction) cfunc;
+    }
+    return 0;
+}
+#else
+static CYTHON_INLINE int __Pyx__IsSameCyOrCFunction(PyObject *func, void *cfunc) {
+    return __Pyx_CyOrPyCFunction_Check(func) && __Pyx_CyOrPyCFunction_GET_FUNCTION(func) == (PyCFunction) cfunc;
+}
+#endif
+static CYTHON_INLINE void __Pyx__CyFunction_SetClassObj(__pyx_CyFunctionObject* f, PyObject* classobj) {
+#if PY_VERSION_HEX < 0x030900B1 || CYTHON_COMPILING_IN_LIMITED_API
+    __Pyx_Py_XDECREF_SET(
+        __Pyx_CyFunction_GetClassObj(f),
+            ((classobj) ? __Pyx_NewRef(classobj) : NULL));
+#else
+    __Pyx_Py_XDECREF_SET(
+        ((PyCMethodObject *) (f))->mm_class,
+        (PyTypeObject*)((classobj) ? __Pyx_NewRef(classobj) : NULL));
+#endif
+}
+static PyObject *
+__Pyx_CyFunction_get_doc(__pyx_CyFunctionObject *op, void *closure)
+{
+    CYTHON_UNUSED_VAR(closure);
+    if (unlikely(op->func_doc == NULL)) {
+#if CYTHON_COMPILING_IN_LIMITED_API
+        op->func_doc = PyObject_GetAttrString(op->func, "__doc__");
+        if (unlikely(!op->func_doc)) return NULL;
+#else
+        if (((PyCFunctionObject*)op)->m_ml->ml_doc) {
+#if PY_MAJOR_VERSION >= 3
+            op->func_doc = PyUnicode_FromString(((PyCFunctionObject*)op)->m_ml->ml_doc);
+#else
+            op->func_doc = PyString_FromString(((PyCFunctionObject*)op)->m_ml->ml_doc);
+#endif
+            if (unlikely(op->func_doc == NULL))
+                return NULL;
+        } else {
+            Py_INCREF(Py_None);
+            return Py_None;
+        }
+#endif
+    }
+    Py_INCREF(op->func_doc);
+    return op->func_doc;
+}
+static int
+__Pyx_CyFunction_set_doc(__pyx_CyFunctionObject *op, PyObject *value, void *context)
+{
+    CYTHON_UNUSED_VAR(context);
+    if (value == NULL) {
+        value = Py_None;
+    }
+    Py_INCREF(value);
+    __Pyx_Py_XDECREF_SET(op->func_doc, value);
+    return 0;
+}
+static PyObject *
+__Pyx_CyFunction_get_name(__pyx_CyFunctionObject *op, void *context)
+{
+    CYTHON_UNUSED_VAR(context);
+    if (unlikely(op->func_name == NULL)) {
+#if CYTHON_COMPILING_IN_LIMITED_API
+        op->func_name = PyObject_GetAttrString(op->func, "__name__");
+#elif PY_MAJOR_VERSION >= 3
+        op->func_name = PyUnicode_InternFromString(((PyCFunctionObject*)op)->m_ml->ml_name);
+#else
+        op->func_name = PyString_InternFromString(((PyCFunctionObject*)op)->m_ml->ml_name);
+#endif
+        if (unlikely(op->func_name == NULL))
+            return NULL;
+    }
+    Py_INCREF(op->func_name);
+    return op->func_name;
+}
+static int
+__Pyx_CyFunction_set_name(__pyx_CyFunctionObject *op, PyObject *value, void *context)
+{
+    CYTHON_UNUSED_VAR(context);
+#if PY_MAJOR_VERSION >= 3
+    if (unlikely(value == NULL || !PyUnicode_Check(value)))
+#else
+    if (unlikely(value == NULL || !PyString_Check(value)))
+#endif
+    {
+        PyErr_SetString(PyExc_TypeError,
+                        "__name__ must be set to a string object");
+        return -1;
+    }
+    Py_INCREF(value);
+    __Pyx_Py_XDECREF_SET(op->func_name, value);
+    return 0;
+}
+static PyObject *
+__Pyx_CyFunction_get_qualname(__pyx_CyFunctionObject *op, void *context)
+{
+    CYTHON_UNUSED_VAR(context);
+    Py_INCREF(op->func_qualname);
+    return op->func_qualname;
+}
+static int
+__Pyx_CyFunction_set_qualname(__pyx_CyFunctionObject *op, PyObject *value, void *context)
+{
+    CYTHON_UNUSED_VAR(context);
+#if PY_MAJOR_VERSION >= 3
+    if (unlikely(value == NULL || !PyUnicode_Check(value)))
+#else
+    if (unlikely(value == NULL || !PyString_Check(value)))
+#endif
+    {
+        PyErr_SetString(PyExc_TypeError,
+                        "__qualname__ must be set to a string object");
+        return -1;
+    }
+    Py_INCREF(value);
+    __Pyx_Py_XDECREF_SET(op->func_qualname, value);
+    return 0;
+}
+static PyObject *
+__Pyx_CyFunction_get_dict(__pyx_CyFunctionObject *op, void *context)
+{
+    CYTHON_UNUSED_VAR(context);
+    if (unlikely(op->func_dict == NULL)) {
+        op->func_dict = PyDict_New();
+        if (unlikely(op->func_dict == NULL))
+            return NULL;
+    }
+    Py_INCREF(op->func_dict);
+    return op->func_dict;
+}
+static int
+__Pyx_CyFunction_set_dict(__pyx_CyFunctionObject *op, PyObject *value, void *context)
+{
+    CYTHON_UNUSED_VAR(context);
+    if (unlikely(value == NULL)) {
+        PyErr_SetString(PyExc_TypeError,
+               "function's dictionary may not be deleted");
+        return -1;
+    }
+    if (unlikely(!PyDict_Check(value))) {
+        PyErr_SetString(PyExc_TypeError,
+               "setting function's dictionary to a non-dict");
+        return -1;
+    }
+    Py_INCREF(value);
+    __Pyx_Py_XDECREF_SET(op->func_dict, value);
+    return 0;
+}
+static PyObject *
+__Pyx_CyFunction_get_globals(__pyx_CyFunctionObject *op, void *context)
+{
+    CYTHON_UNUSED_VAR(context);
+    Py_INCREF(op->func_globals);
+    return op->func_globals;
+}
+static PyObject *
+__Pyx_CyFunction_get_closure(__pyx_CyFunctionObject *op, void *context)
+{
+    CYTHON_UNUSED_VAR(op);
+    CYTHON_UNUSED_VAR(context);
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+static PyObject *
+__Pyx_CyFunction_get_code(__pyx_CyFunctionObject *op, void *context)
+{
+    PyObject* result = (op->func_code) ? op->func_code : Py_None;
+    CYTHON_UNUSED_VAR(context);
+    Py_INCREF(result);
+    return result;
+}
+static int
+__Pyx_CyFunction_init_defaults(__pyx_CyFunctionObject *op) {
+    int result = 0;
+    PyObject *res = op->defaults_getter((PyObject *) op);
+    if (unlikely(!res))
+        return -1;
+    #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+    op->defaults_tuple = PyTuple_GET_ITEM(res, 0);
+    Py_INCREF(op->defaults_tuple);
+    op->defaults_kwdict = PyTuple_GET_ITEM(res, 1);
+    Py_INCREF(op->defaults_kwdict);
+    #else
+    op->defaults_tuple = __Pyx_PySequence_ITEM(res, 0);
+    if (unlikely(!op->defaults_tuple)) result = -1;
+    else {
+        op->defaults_kwdict = __Pyx_PySequence_ITEM(res, 1);
+        if (unlikely(!op->defaults_kwdict)) result = -1;
+    }
+    #endif
+    Py_DECREF(res);
+    return result;
+}
+static int
+__Pyx_CyFunction_set_defaults(__pyx_CyFunctionObject *op, PyObject* value, void *context) {
+    CYTHON_UNUSED_VAR(context);
+    if (!value) {
+        value = Py_None;
+    } else if (unlikely(value != Py_None && !PyTuple_Check(value))) {
+        PyErr_SetString(PyExc_TypeError,
+                        "__defaults__ must be set to a tuple object");
+        return -1;
+    }
+    PyErr_WarnEx(PyExc_RuntimeWarning, "changes to cyfunction.__defaults__ will not "
+                 "currently affect the values used in function calls", 1);
+    Py_INCREF(value);
+    __Pyx_Py_XDECREF_SET(op->defaults_tuple, value);
+    return 0;
+}
+static PyObject *
+__Pyx_CyFunction_get_defaults(__pyx_CyFunctionObject *op, void *context) {
+    PyObject* result = op->defaults_tuple;
+    CYTHON_UNUSED_VAR(context);
+    if (unlikely(!result)) {
+        if (op->defaults_getter) {
+            if (unlikely(__Pyx_CyFunction_init_defaults(op) < 0)) return NULL;
+            result = op->defaults_tuple;
+        } else {
+            result = Py_None;
+        }
+    }
+    Py_INCREF(result);
+    return result;
+}
+static int
+__Pyx_CyFunction_set_kwdefaults(__pyx_CyFunctionObject *op, PyObject* value, void *context) {
+    CYTHON_UNUSED_VAR(context);
+    if (!value) {
+        value = Py_None;
+    } else if (unlikely(value != Py_None && !PyDict_Check(value))) {
+        PyErr_SetString(PyExc_TypeError,
+                        "__kwdefaults__ must be set to a dict object");
+        return -1;
+    }
+    PyErr_WarnEx(PyExc_RuntimeWarning, "changes to cyfunction.__kwdefaults__ will not "
+                 "currently affect the values used in function calls", 1);
+    Py_INCREF(value);
+    __Pyx_Py_XDECREF_SET(op->defaults_kwdict, value);
+    return 0;
+}
+static PyObject *
+__Pyx_CyFunction_get_kwdefaults(__pyx_CyFunctionObject *op, void *context) {
+    PyObject* result = op->defaults_kwdict;
+    CYTHON_UNUSED_VAR(context);
+    if (unlikely(!result)) {
+        if (op->defaults_getter) {
+            if (unlikely(__Pyx_CyFunction_init_defaults(op) < 0)) return NULL;
+            result = op->defaults_kwdict;
+        } else {
+            result = Py_None;
+        }
+    }
+    Py_INCREF(result);
+    return result;
+}
+static int
+__Pyx_CyFunction_set_annotations(__pyx_CyFunctionObject *op, PyObject* value, void *context) {
+    CYTHON_UNUSED_VAR(context);
+    if (!value || value == Py_None) {
+        value = NULL;
+    } else if (unlikely(!PyDict_Check(value))) {
+        PyErr_SetString(PyExc_TypeError,
+                        "__annotations__ must be set to a dict object");
+        return -1;
+    }
+    Py_XINCREF(value);
+    __Pyx_Py_XDECREF_SET(op->func_annotations, value);
+    return 0;
+}
+static PyObject *
+__Pyx_CyFunction_get_annotations(__pyx_CyFunctionObject *op, void *context) {
+    PyObject* result = op->func_annotations;
+    CYTHON_UNUSED_VAR(context);
+    if (unlikely(!result)) {
+        result = PyDict_New();
+        if (unlikely(!result)) return NULL;
+        op->func_annotations = result;
+    }
+    Py_INCREF(result);
+    return result;
+}
+static PyObject *
+__Pyx_CyFunction_get_is_coroutine(__pyx_CyFunctionObject *op, void *context) {
+    int is_coroutine;
+    CYTHON_UNUSED_VAR(context);
+    if (op->func_is_coroutine) {
+        return __Pyx_NewRef(op->func_is_coroutine);
+    }
+    is_coroutine = op->flags & __Pyx_CYFUNCTION_COROUTINE;
+#if PY_VERSION_HEX >= 0x03050000
+    if (is_coroutine) {
+        PyObject *module, *fromlist, *marker = __pyx_n_s_is_coroutine;
+        fromlist = PyList_New(1);
+        if (unlikely(!fromlist)) return NULL;
+        Py_INCREF(marker);
+#if CYTHON_ASSUME_SAFE_MACROS
+        PyList_SET_ITEM(fromlist, 0, marker);
+#else
+        if (unlikely(PyList_SetItem(fromlist, 0, marker) < 0)) {
+            Py_DECREF(marker);
+            Py_DECREF(fromlist);
+            return NULL;
+        }
+#endif
+        module = PyImport_ImportModuleLevelObject(__pyx_n_s_asyncio_coroutines, NULL, NULL, fromlist, 0);
+        Py_DECREF(fromlist);
+        if (unlikely(!module)) goto ignore;
+        op->func_is_coroutine = __Pyx_PyObject_GetAttrStr(module, marker);
+        Py_DECREF(module);
+        if (likely(op->func_is_coroutine)) {
+            return __Pyx_NewRef(op->func_is_coroutine);
+        }
+ignore:
+        PyErr_Clear();
+    }
+#endif
+    op->func_is_coroutine = __Pyx_PyBool_FromLong(is_coroutine);
+    return __Pyx_NewRef(op->func_is_coroutine);
+}
+#if CYTHON_COMPILING_IN_LIMITED_API
+static PyObject *
+__Pyx_CyFunction_get_module(__pyx_CyFunctionObject *op, void *context) {
+    CYTHON_UNUSED_VAR(context);
+    return PyObject_GetAttrString(op->func, "__module__");
+}
+static int
+__Pyx_CyFunction_set_module(__pyx_CyFunctionObject *op, PyObject* value, void *context) {
+    CYTHON_UNUSED_VAR(context);
+    return PyObject_SetAttrString(op->func, "__module__", value);
+}
+#endif
+static PyGetSetDef __pyx_CyFunction_getsets[] = {
+    {(char *) "func_doc", (getter)__Pyx_CyFunction_get_doc, (setter)__Pyx_CyFunction_set_doc, 0, 0},
+    {(char *) "__doc__",  (getter)__Pyx_CyFunction_get_doc, (setter)__Pyx_CyFunction_set_doc, 0, 0},
+    {(char *) "func_name", (getter)__Pyx_CyFunction_get_name, (setter)__Pyx_CyFunction_set_name, 0, 0},
+    {(char *) "__name__", (getter)__Pyx_CyFunction_get_name, (setter)__Pyx_CyFunction_set_name, 0, 0},
+    {(char *) "__qualname__", (getter)__Pyx_CyFunction_get_qualname, (setter)__Pyx_CyFunction_set_qualname, 0, 0},
+    {(char *) "func_dict", (getter)__Pyx_CyFunction_get_dict, (setter)__Pyx_CyFunction_set_dict, 0, 0},
+    {(char *) "__dict__", (getter)__Pyx_CyFunction_get_dict, (setter)__Pyx_CyFunction_set_dict, 0, 0},
+    {(char *) "func_globals", (getter)__Pyx_CyFunction_get_globals, 0, 0, 0},
+    {(char *) "__globals__", (getter)__Pyx_CyFunction_get_globals, 0, 0, 0},
+    {(char *) "func_closure", (getter)__Pyx_CyFunction_get_closure, 0, 0, 0},
+    {(char *) "__closure__", (getter)__Pyx_CyFunction_get_closure, 0, 0, 0},
+    {(char *) "func_code", (getter)__Pyx_CyFunction_get_code, 0, 0, 0},
+    {(char *) "__code__", (getter)__Pyx_CyFunction_get_code, 0, 0, 0},
+    {(char *) "func_defaults", (getter)__Pyx_CyFunction_get_defaults, (setter)__Pyx_CyFunction_set_defaults, 0, 0},
+    {(char *) "__defaults__", (getter)__Pyx_CyFunction_get_defaults, (setter)__Pyx_CyFunction_set_defaults, 0, 0},
+    {(char *) "__kwdefaults__", (getter)__Pyx_CyFunction_get_kwdefaults, (setter)__Pyx_CyFunction_set_kwdefaults, 0, 0},
+    {(char *) "__annotations__", (getter)__Pyx_CyFunction_get_annotations, (setter)__Pyx_CyFunction_set_annotations, 0, 0},
+    {(char *) "_is_coroutine", (getter)__Pyx_CyFunction_get_is_coroutine, 0, 0, 0},
+#if CYTHON_COMPILING_IN_LIMITED_API
+    {"__module__", (getter)__Pyx_CyFunction_get_module, (setter)__Pyx_CyFunction_set_module, 0, 0},
+#endif
+    {0, 0, 0, 0, 0}
+};
+static PyMemberDef __pyx_CyFunction_members[] = {
+#if !CYTHON_COMPILING_IN_LIMITED_API
+    {(char *) "__module__", T_OBJECT, offsetof(PyCFunctionObject, m_module), 0, 0},
+#endif
+#if CYTHON_USE_TYPE_SPECS
+    {(char *) "__dictoffset__", T_PYSSIZET, offsetof(__pyx_CyFunctionObject, func_dict), READONLY, 0},
+#if CYTHON_METH_FASTCALL
+#if CYTHON_BACKPORT_VECTORCALL
+    {(char *) "__vectorcalloffset__", T_PYSSIZET, offsetof(__pyx_CyFunctionObject, func_vectorcall), READONLY, 0},
+#else
+#if !CYTHON_COMPILING_IN_LIMITED_API
+    {(char *) "__vectorcalloffset__", T_PYSSIZET, offsetof(PyCFunctionObject, vectorcall), READONLY, 0},
+#endif
+#endif
+#endif
+#if PY_VERSION_HEX < 0x030500A0 || CYTHON_COMPILING_IN_LIMITED_API
+    {(char *) "__weaklistoffset__", T_PYSSIZET, offsetof(__pyx_CyFunctionObject, func_weakreflist), READONLY, 0},
+#else
+    {(char *) "__weaklistoffset__", T_PYSSIZET, offsetof(PyCFunctionObject, m_weakreflist), READONLY, 0},
+#endif
+#endif
+    {0, 0, 0,  0, 0}
+};
+static PyObject *
+__Pyx_CyFunction_reduce(__pyx_CyFunctionObject *m, PyObject *args)
+{
+    CYTHON_UNUSED_VAR(args);
+#if PY_MAJOR_VERSION >= 3
+    Py_INCREF(m->func_qualname);
+    return m->func_qualname;
+#else
+    return PyString_FromString(((PyCFunctionObject*)m)->m_ml->ml_name);
+#endif
+}
+static PyMethodDef __pyx_CyFunction_methods[] = {
+    {"__reduce__", (PyCFunction)__Pyx_CyFunction_reduce, METH_VARARGS, 0},
+    {0, 0, 0, 0}
+};
+#if PY_VERSION_HEX < 0x030500A0 || CYTHON_COMPILING_IN_LIMITED_API
+#define __Pyx_CyFunction_weakreflist(cyfunc) ((cyfunc)->func_weakreflist)
+#else
+#define __Pyx_CyFunction_weakreflist(cyfunc) (((PyCFunctionObject*)cyfunc)->m_weakreflist)
+#endif
+static PyObject *__Pyx_CyFunction_Init(__pyx_CyFunctionObject *op, PyMethodDef *ml, int flags, PyObject* qualname,
+                                       PyObject *closure, PyObject *module, PyObject* globals, PyObject* code) {
+#if !CYTHON_COMPILING_IN_LIMITED_API
+    PyCFunctionObject *cf = (PyCFunctionObject*) op;
+#endif
+    if (unlikely(op == NULL))
+        return NULL;
+#if CYTHON_COMPILING_IN_LIMITED_API
+    op->func = PyCFunction_NewEx(ml, (PyObject*)op, module);
+    if (unlikely(!op->func)) return NULL;
+#endif
+    op->flags = flags;
+    __Pyx_CyFunction_weakreflist(op) = NULL;
+#if !CYTHON_COMPILING_IN_LIMITED_API
+    cf->m_ml = ml;
+    cf->m_self = (PyObject *) op;
+#endif
+    Py_XINCREF(closure);
+    op->func_closure = closure;
+#if !CYTHON_COMPILING_IN_LIMITED_API
+    Py_XINCREF(module);
+    cf->m_module = module;
+#endif
+    op->func_dict = NULL;
+    op->func_name = NULL;
+    Py_INCREF(qualname);
+    op->func_qualname = qualname;
+    op->func_doc = NULL;
+#if PY_VERSION_HEX < 0x030900B1 || CYTHON_COMPILING_IN_LIMITED_API
+    op->func_classobj = NULL;
+#else
+    ((PyCMethodObject*)op)->mm_class = NULL;
+#endif
+    op->func_globals = globals;
+    Py_INCREF(op->func_globals);
+    Py_XINCREF(code);
+    op->func_code = code;
+    op->defaults_pyobjects = 0;
+    op->defaults_size = 0;
+    op->defaults = NULL;
+    op->defaults_tuple = NULL;
+    op->defaults_kwdict = NULL;
+    op->defaults_getter = NULL;
+    op->func_annotations = NULL;
+    op->func_is_coroutine = NULL;
+#if CYTHON_METH_FASTCALL
+    switch (ml->ml_flags & (METH_VARARGS | METH_FASTCALL | METH_NOARGS | METH_O | METH_KEYWORDS | METH_METHOD)) {
+    case METH_NOARGS:
+        __Pyx_CyFunction_func_vectorcall(op) = __Pyx_CyFunction_Vectorcall_NOARGS;
+        break;
+    case METH_O:
+        __Pyx_CyFunction_func_vectorcall(op) = __Pyx_CyFunction_Vectorcall_O;
+        break;
+    case METH_METHOD | METH_FASTCALL | METH_KEYWORDS:
+        __Pyx_CyFunction_func_vectorcall(op) = __Pyx_CyFunction_Vectorcall_FASTCALL_KEYWORDS_METHOD;
+        break;
+    case METH_FASTCALL | METH_KEYWORDS:
+        __Pyx_CyFunction_func_vectorcall(op) = __Pyx_CyFunction_Vectorcall_FASTCALL_KEYWORDS;
+        break;
+    case METH_VARARGS | METH_KEYWORDS:
+        __Pyx_CyFunction_func_vectorcall(op) = NULL;
+        break;
+    default:
+        PyErr_SetString(PyExc_SystemError, "Bad call flags for CyFunction");
+        Py_DECREF(op);
+        return NULL;
+    }
+#endif
+    return (PyObject *) op;
+}
+static int
+__Pyx_CyFunction_clear(__pyx_CyFunctionObject *m)
+{
+    Py_CLEAR(m->func_closure);
+#if CYTHON_COMPILING_IN_LIMITED_API
+    Py_CLEAR(m->func);
+#else
+    Py_CLEAR(((PyCFunctionObject*)m)->m_module);
+#endif
+    Py_CLEAR(m->func_dict);
+    Py_CLEAR(m->func_name);
+    Py_CLEAR(m->func_qualname);
+    Py_CLEAR(m->func_doc);
+    Py_CLEAR(m->func_globals);
+    Py_CLEAR(m->func_code);
+#if !CYTHON_COMPILING_IN_LIMITED_API
+#if PY_VERSION_HEX < 0x030900B1
+    Py_CLEAR(__Pyx_CyFunction_GetClassObj(m));
+#else
+    {
+        PyObject *cls = (PyObject*) ((PyCMethodObject *) (m))->mm_class;
+        ((PyCMethodObject *) (m))->mm_class = NULL;
+        Py_XDECREF(cls);
+    }
+#endif
+#endif
+    Py_CLEAR(m->defaults_tuple);
+    Py_CLEAR(m->defaults_kwdict);
+    Py_CLEAR(m->func_annotations);
+    Py_CLEAR(m->func_is_coroutine);
+    if (m->defaults) {
+        PyObject **pydefaults = __Pyx_CyFunction_Defaults(PyObject *, m);
+        int i;
+        for (i = 0; i < m->defaults_pyobjects; i++)
+            Py_XDECREF(pydefaults[i]);
+        PyObject_Free(m->defaults);
+        m->defaults = NULL;
+    }
+    return 0;
+}
+static void __Pyx__CyFunction_dealloc(__pyx_CyFunctionObject *m)
+{
+    if (__Pyx_CyFunction_weakreflist(m) != NULL)
+        PyObject_ClearWeakRefs((PyObject *) m);
+    __Pyx_CyFunction_clear(m);
+    __Pyx_PyHeapTypeObject_GC_Del(m);
+}
+static void __Pyx_CyFunction_dealloc(__pyx_CyFunctionObject *m)
+{
+    PyObject_GC_UnTrack(m);
+    __Pyx__CyFunction_dealloc(m);
+}
+static int __Pyx_CyFunction_traverse(__pyx_CyFunctionObject *m, visitproc visit, void *arg)
+{
+    Py_VISIT(m->func_closure);
+#if CYTHON_COMPILING_IN_LIMITED_API
+    Py_VISIT(m->func);
+#else
+    Py_VISIT(((PyCFunctionObject*)m)->m_module);
+#endif
+    Py_VISIT(m->func_dict);
+    Py_VISIT(m->func_name);
+    Py_VISIT(m->func_qualname);
+    Py_VISIT(m->func_doc);
+    Py_VISIT(m->func_globals);
+    Py_VISIT(m->func_code);
+#if !CYTHON_COMPILING_IN_LIMITED_API
+    Py_VISIT(__Pyx_CyFunction_GetClassObj(m));
+#endif
+    Py_VISIT(m->defaults_tuple);
+    Py_VISIT(m->defaults_kwdict);
+    Py_VISIT(m->func_is_coroutine);
+    if (m->defaults) {
+        PyObject **pydefaults = __Pyx_CyFunction_Defaults(PyObject *, m);
+        int i;
+        for (i = 0; i < m->defaults_pyobjects; i++)
+            Py_VISIT(pydefaults[i]);
+    }
+    return 0;
+}
+static PyObject*
+__Pyx_CyFunction_repr(__pyx_CyFunctionObject *op)
+{
+#if PY_MAJOR_VERSION >= 3
+    return PyUnicode_FromFormat("<cyfunction %U at %p>",
+                                op->func_qualname, (void *)op);
+#else
+    return PyString_FromFormat("<cyfunction %s at %p>",
+                               PyString_AsString(op->func_qualname), (void *)op);
+#endif
+}
+static PyObject * __Pyx_CyFunction_CallMethod(PyObject *func, PyObject *self, PyObject *arg, PyObject *kw) {
+#if CYTHON_COMPILING_IN_LIMITED_API
+    PyObject *f = ((__pyx_CyFunctionObject*)func)->func;
+    PyObject *py_name = NULL;
+    PyCFunction meth;
+    int flags;
+    meth = PyCFunction_GetFunction(f);
+    if (unlikely(!meth)) return NULL;
+    flags = PyCFunction_GetFlags(f);
+    if (unlikely(flags < 0)) return NULL;
+#else
+    PyCFunctionObject* f = (PyCFunctionObject*)func;
+    PyCFunction meth = f->m_ml->ml_meth;
+    int flags = f->m_ml->ml_flags;
+#endif
+    Py_ssize_t size;
+    switch (flags & (METH_VARARGS | METH_KEYWORDS | METH_NOARGS | METH_O)) {
+    case METH_VARARGS:
+        if (likely(kw == NULL || PyDict_Size(kw) == 0))
+            return (*meth)(self, arg);
+        break;
+    case METH_VARARGS | METH_KEYWORDS:
+        return (*(PyCFunctionWithKeywords)(void*)meth)(self, arg, kw);
+    case METH_NOARGS:
+        if (likely(kw == NULL || PyDict_Size(kw) == 0)) {
+#if CYTHON_ASSUME_SAFE_MACROS
+            size = PyTuple_GET_SIZE(arg);
+#else
+            size = PyTuple_Size(arg);
+            if (unlikely(size < 0)) return NULL;
+#endif
+            if (likely(size == 0))
+                return (*meth)(self, NULL);
+#if CYTHON_COMPILING_IN_LIMITED_API
+            py_name = __Pyx_CyFunction_get_name((__pyx_CyFunctionObject*)func, NULL);
+            if (!py_name) return NULL;
+            PyErr_Format(PyExc_TypeError,
+                "%.200S() takes no arguments (%" CYTHON_FORMAT_SSIZE_T "d given)",
+                py_name, size);
+            Py_DECREF(py_name);
+#else
+            PyErr_Format(PyExc_TypeError,
+                "%.200s() takes no arguments (%" CYTHON_FORMAT_SSIZE_T "d given)",
+                f->m_ml->ml_name, size);
+#endif
+            return NULL;
+        }
+        break;
+    case METH_O:
+        if (likely(kw == NULL || PyDict_Size(kw) == 0)) {
+#if CYTHON_ASSUME_SAFE_MACROS
+            size = PyTuple_GET_SIZE(arg);
+#else
+            size = PyTuple_Size(arg);
+            if (unlikely(size < 0)) return NULL;
+#endif
+            if (likely(size == 1)) {
+                PyObject *result, *arg0;
+                #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+                arg0 = PyTuple_GET_ITEM(arg, 0);
+                #else
+                arg0 = __Pyx_PySequence_ITEM(arg, 0); if (unlikely(!arg0)) return NULL;
+                #endif
+                result = (*meth)(self, arg0);
+                #if !(CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS)
+                Py_DECREF(arg0);
+                #endif
+                return result;
+            }
+#if CYTHON_COMPILING_IN_LIMITED_API
+            py_name = __Pyx_CyFunction_get_name((__pyx_CyFunctionObject*)func, NULL);
+            if (!py_name) return NULL;
+            PyErr_Format(PyExc_TypeError,
+                "%.200S() takes exactly one argument (%" CYTHON_FORMAT_SSIZE_T "d given)",
+                py_name, size);
+            Py_DECREF(py_name);
+#else
+            PyErr_Format(PyExc_TypeError,
+                "%.200s() takes exactly one argument (%" CYTHON_FORMAT_SSIZE_T "d given)",
+                f->m_ml->ml_name, size);
+#endif
+            return NULL;
+        }
+        break;
+    default:
+        PyErr_SetString(PyExc_SystemError, "Bad call flags for CyFunction");
+        return NULL;
+    }
+#if CYTHON_COMPILING_IN_LIMITED_API
+    py_name = __Pyx_CyFunction_get_name((__pyx_CyFunctionObject*)func, NULL);
+    if (!py_name) return NULL;
+    PyErr_Format(PyExc_TypeError, "%.200S() takes no keyword arguments",
+                 py_name);
+    Py_DECREF(py_name);
+#else
+    PyErr_Format(PyExc_TypeError, "%.200s() takes no keyword arguments",
+                 f->m_ml->ml_name);
+#endif
+    return NULL;
+}
+static CYTHON_INLINE PyObject *__Pyx_CyFunction_Call(PyObject *func, PyObject *arg, PyObject *kw) {
+    PyObject *self, *result;
+#if CYTHON_COMPILING_IN_LIMITED_API
+    self = PyCFunction_GetSelf(((__pyx_CyFunctionObject*)func)->func);
+    if (unlikely(!self) && PyErr_Occurred()) return NULL;
+#else
+    self = ((PyCFunctionObject*)func)->m_self;
+#endif
+    result = __Pyx_CyFunction_CallMethod(func, self, arg, kw);
+    return result;
+}
+static PyObject *__Pyx_CyFunction_CallAsMethod(PyObject *func, PyObject *args, PyObject *kw) {
+    PyObject *result;
+    __pyx_CyFunctionObject *cyfunc = (__pyx_CyFunctionObject *) func;
+#if CYTHON_METH_FASTCALL
+     __pyx_vectorcallfunc vc = __Pyx_CyFunction_func_vectorcall(cyfunc);
+    if (vc) {
+#if CYTHON_ASSUME_SAFE_MACROS
+        return __Pyx_PyVectorcall_FastCallDict(func, vc, &PyTuple_GET_ITEM(args, 0), (size_t)PyTuple_GET_SIZE(args), kw);
+#else
+        (void) &__Pyx_PyVectorcall_FastCallDict;
+        return PyVectorcall_Call(func, args, kw);
+#endif
+    }
+#endif
+    if ((cyfunc->flags & __Pyx_CYFUNCTION_CCLASS) && !(cyfunc->flags & __Pyx_CYFUNCTION_STATICMETHOD)) {
+        Py_ssize_t argc;
+        PyObject *new_args;
+        PyObject *self;
+#if CYTHON_ASSUME_SAFE_MACROS
+        argc = PyTuple_GET_SIZE(args);
+#else
+        argc = PyTuple_Size(args);
+        if (unlikely(!argc) < 0) return NULL;
+#endif
+        new_args = PyTuple_GetSlice(args, 1, argc);
+        if (unlikely(!new_args))
+            return NULL;
+        self = PyTuple_GetItem(args, 0);
+        if (unlikely(!self)) {
+            Py_DECREF(new_args);
+#if PY_MAJOR_VERSION > 2
+            PyErr_Format(PyExc_TypeError,
+                         "unbound method %.200S() needs an argument",
+                         cyfunc->func_qualname);
+#else
+            PyErr_SetString(PyExc_TypeError,
+                            "unbound method needs an argument");
+#endif
+            return NULL;
+        }
+        result = __Pyx_CyFunction_CallMethod(func, self, new_args, kw);
+        Py_DECREF(new_args);
+    } else {
+        result = __Pyx_CyFunction_Call(func, args, kw);
+    }
+    return result;
+}
+#if CYTHON_METH_FASTCALL
+static CYTHON_INLINE int __Pyx_CyFunction_Vectorcall_CheckArgs(__pyx_CyFunctionObject *cyfunc, Py_ssize_t nargs, PyObject *kwnames)
+{
+    int ret = 0;
+    if ((cyfunc->flags & __Pyx_CYFUNCTION_CCLASS) && !(cyfunc->flags & __Pyx_CYFUNCTION_STATICMETHOD)) {
+        if (unlikely(nargs < 1)) {
+            PyErr_Format(PyExc_TypeError, "%.200s() needs an argument",
+                         ((PyCFunctionObject*)cyfunc)->m_ml->ml_name);
+            return -1;
+        }
+        ret = 1;
+    }
+    if (unlikely(kwnames) && unlikely(PyTuple_GET_SIZE(kwnames))) {
+        PyErr_Format(PyExc_TypeError,
+                     "%.200s() takes no keyword arguments", ((PyCFunctionObject*)cyfunc)->m_ml->ml_name);
+        return -1;
+    }
+    return ret;
+}
+static PyObject * __Pyx_CyFunction_Vectorcall_NOARGS(PyObject *func, PyObject *const *args, size_t nargsf, PyObject *kwnames)
+{
+    __pyx_CyFunctionObject *cyfunc = (__pyx_CyFunctionObject *)func;
+    PyMethodDef* def = ((PyCFunctionObject*)cyfunc)->m_ml;
+#if CYTHON_BACKPORT_VECTORCALL
+    Py_ssize_t nargs = (Py_ssize_t)nargsf;
+#else
+    Py_ssize_t nargs = PyVectorcall_NARGS(nargsf);
+#endif
+    PyObject *self;
+    switch (__Pyx_CyFunction_Vectorcall_CheckArgs(cyfunc, nargs, kwnames)) {
+    case 1:
+        self = args[0];
+        args += 1;
+        nargs -= 1;
+        break;
+    case 0:
+        self = ((PyCFunctionObject*)cyfunc)->m_self;
+        break;
+    default:
+        return NULL;
+    }
+    if (unlikely(nargs != 0)) {
+        PyErr_Format(PyExc_TypeError,
+            "%.200s() takes no arguments (%" CYTHON_FORMAT_SSIZE_T "d given)",
+            def->ml_name, nargs);
+        return NULL;
+    }
+    return def->ml_meth(self, NULL);
+}
+static PyObject * __Pyx_CyFunction_Vectorcall_O(PyObject *func, PyObject *const *args, size_t nargsf, PyObject *kwnames)
+{
+    __pyx_CyFunctionObject *cyfunc = (__pyx_CyFunctionObject *)func;
+    PyMethodDef* def = ((PyCFunctionObject*)cyfunc)->m_ml;
+#if CYTHON_BACKPORT_VECTORCALL
+    Py_ssize_t nargs = (Py_ssize_t)nargsf;
+#else
+    Py_ssize_t nargs = PyVectorcall_NARGS(nargsf);
+#endif
+    PyObject *self;
+    switch (__Pyx_CyFunction_Vectorcall_CheckArgs(cyfunc, nargs, kwnames)) {
+    case 1:
+        self = args[0];
+        args += 1;
+        nargs -= 1;
+        break;
+    case 0:
+        self = ((PyCFunctionObject*)cyfunc)->m_self;
+        break;
+    default:
+        return NULL;
+    }
+    if (unlikely(nargs != 1)) {
+        PyErr_Format(PyExc_TypeError,
+            "%.200s() takes exactly one argument (%" CYTHON_FORMAT_SSIZE_T "d given)",
+            def->ml_name, nargs);
+        return NULL;
+    }
+    return def->ml_meth(self, args[0]);
+}
+static PyObject * __Pyx_CyFunction_Vectorcall_FASTCALL_KEYWORDS(PyObject *func, PyObject *const *args, size_t nargsf, PyObject *kwnames)
+{
+    __pyx_CyFunctionObject *cyfunc = (__pyx_CyFunctionObject *)func;
+    PyMethodDef* def = ((PyCFunctionObject*)cyfunc)->m_ml;
+#if CYTHON_BACKPORT_VECTORCALL
+    Py_ssize_t nargs = (Py_ssize_t)nargsf;
+#else
+    Py_ssize_t nargs = PyVectorcall_NARGS(nargsf);
+#endif
+    PyObject *self;
+    switch (__Pyx_CyFunction_Vectorcall_CheckArgs(cyfunc, nargs, NULL)) {
+    case 1:
+        self = args[0];
+        args += 1;
+        nargs -= 1;
+        break;
+    case 0:
+        self = ((PyCFunctionObject*)cyfunc)->m_self;
+        break;
+    default:
+        return NULL;
+    }
+    return ((__Pyx_PyCFunctionFastWithKeywords)(void(*)(void))def->ml_meth)(self, args, nargs, kwnames);
+}
+static PyObject * __Pyx_CyFunction_Vectorcall_FASTCALL_KEYWORDS_METHOD(PyObject *func, PyObject *const *args, size_t nargsf, PyObject *kwnames)
+{
+    __pyx_CyFunctionObject *cyfunc = (__pyx_CyFunctionObject *)func;
+    PyMethodDef* def = ((PyCFunctionObject*)cyfunc)->m_ml;
+    PyTypeObject *cls = (PyTypeObject *) __Pyx_CyFunction_GetClassObj(cyfunc);
+#if CYTHON_BACKPORT_VECTORCALL
+    Py_ssize_t nargs = (Py_ssize_t)nargsf;
+#else
+    Py_ssize_t nargs = PyVectorcall_NARGS(nargsf);
+#endif
+    PyObject *self;
+    switch (__Pyx_CyFunction_Vectorcall_CheckArgs(cyfunc, nargs, NULL)) {
+    case 1:
+        self = args[0];
+        args += 1;
+        nargs -= 1;
+        break;
+    case 0:
+        self = ((PyCFunctionObject*)cyfunc)->m_self;
+        break;
+    default:
+        return NULL;
+    }
+    return ((__Pyx_PyCMethod)(void(*)(void))def->ml_meth)(self, cls, args, (size_t)nargs, kwnames);
+}
+#endif
+#if CYTHON_USE_TYPE_SPECS
+static PyType_Slot __pyx_CyFunctionType_slots[] = {
+    {Py_tp_dealloc, (void *)__Pyx_CyFunction_dealloc},
+    {Py_tp_repr, (void *)__Pyx_CyFunction_repr},
+    {Py_tp_call, (void *)__Pyx_CyFunction_CallAsMethod},
+    {Py_tp_traverse, (void *)__Pyx_CyFunction_traverse},
+    {Py_tp_clear, (void *)__Pyx_CyFunction_clear},
+    {Py_tp_methods, (void *)__pyx_CyFunction_methods},
+    {Py_tp_members, (void *)__pyx_CyFunction_members},
+    {Py_tp_getset, (void *)__pyx_CyFunction_getsets},
+    {Py_tp_descr_get, (void *)__Pyx_PyMethod_New},
+    {0, 0},
+};
+static PyType_Spec __pyx_CyFunctionType_spec = {
+    __PYX_TYPE_MODULE_PREFIX "cython_function_or_method",
+    sizeof(__pyx_CyFunctionObject),
+    0,
+#ifdef Py_TPFLAGS_METHOD_DESCRIPTOR
+    Py_TPFLAGS_METHOD_DESCRIPTOR |
+#endif
+#if (defined(_Py_TPFLAGS_HAVE_VECTORCALL) && CYTHON_METH_FASTCALL)
+    _Py_TPFLAGS_HAVE_VECTORCALL |
+#endif
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_BASETYPE,
+    __pyx_CyFunctionType_slots
+};
+#else
+static PyTypeObject __pyx_CyFunctionType_type = {
+    PyVarObject_HEAD_INIT(0, 0)
+    __PYX_TYPE_MODULE_PREFIX "cython_function_or_method",
+    sizeof(__pyx_CyFunctionObject),
+    0,
+    (destructor) __Pyx_CyFunction_dealloc,
+#if !CYTHON_METH_FASTCALL
+    0,
+#elif CYTHON_BACKPORT_VECTORCALL
+    (printfunc)offsetof(__pyx_CyFunctionObject, func_vectorcall),
+#else
+    offsetof(PyCFunctionObject, vectorcall),
+#endif
+    0,
+    0,
+#if PY_MAJOR_VERSION < 3
+    0,
+#else
+    0,
+#endif
+    (reprfunc) __Pyx_CyFunction_repr,
+    0,
+    0,
+    0,
+    0,
+    __Pyx_CyFunction_CallAsMethod,
+    0,
+    0,
+    0,
+    0,
+#ifdef Py_TPFLAGS_METHOD_DESCRIPTOR
+    Py_TPFLAGS_METHOD_DESCRIPTOR |
+#endif
+#if defined(_Py_TPFLAGS_HAVE_VECTORCALL) && CYTHON_METH_FASTCALL
+    _Py_TPFLAGS_HAVE_VECTORCALL |
+#endif
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_BASETYPE,
+    0,
+    (traverseproc) __Pyx_CyFunction_traverse,
+    (inquiry) __Pyx_CyFunction_clear,
+    0,
+#if PY_VERSION_HEX < 0x030500A0
+    offsetof(__pyx_CyFunctionObject, func_weakreflist),
+#else
+    offsetof(PyCFunctionObject, m_weakreflist),
+#endif
+    0,
+    0,
+    __pyx_CyFunction_methods,
+    __pyx_CyFunction_members,
+    __pyx_CyFunction_getsets,
+    0,
+    0,
+    __Pyx_PyMethod_New,
+    0,
+    offsetof(__pyx_CyFunctionObject, func_dict),
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+#if PY_VERSION_HEX >= 0x030400a1
+    0,
+#endif
+#if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
+    0,
+#endif
+#if __PYX_NEED_TP_PRINT_SLOT
+    0,
+#endif
+#if PY_VERSION_HEX >= 0x030C0000
+    0,
+#endif
+#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
+    0,
+#endif
+};
+#endif
+static int __pyx_CyFunction_init(PyObject *module) {
+#if CYTHON_USE_TYPE_SPECS
+    __pyx_CyFunctionType = __Pyx_FetchCommonTypeFromSpec(module, &__pyx_CyFunctionType_spec, NULL);
+#else
+    CYTHON_UNUSED_VAR(module);
+    __pyx_CyFunctionType = __Pyx_FetchCommonType(&__pyx_CyFunctionType_type);
+#endif
+    if (unlikely(__pyx_CyFunctionType == NULL)) {
+        return -1;
+    }
+    return 0;
+}
+static CYTHON_INLINE void *__Pyx_CyFunction_InitDefaults(PyObject *func, size_t size, int pyobjects) {
+    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
+    m->defaults = PyObject_Malloc(size);
+    if (unlikely(!m->defaults))
+        return PyErr_NoMemory();
+    memset(m->defaults, 0, size);
+    m->defaults_pyobjects = pyobjects;
+    m->defaults_size = size;
+    return m->defaults;
+}
+static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsTuple(PyObject *func, PyObject *tuple) {
+    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
+    m->defaults_tuple = tuple;
+    Py_INCREF(tuple);
+}
+static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsKwDict(PyObject *func, PyObject *dict) {
+    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
+    m->defaults_kwdict = dict;
+    Py_INCREF(dict);
+}
+static CYTHON_INLINE void __Pyx_CyFunction_SetAnnotationsDict(PyObject *func, PyObject *dict) {
+    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
+    m->func_annotations = dict;
+    Py_INCREF(dict);
+}
+
+/* CythonFunction */
+  static PyObject *__Pyx_CyFunction_New(PyMethodDef *ml, int flags, PyObject* qualname,
+                                      PyObject *closure, PyObject *module, PyObject* globals, PyObject* code) {
+    PyObject *op = __Pyx_CyFunction_Init(
+        PyObject_GC_New(__pyx_CyFunctionObject, __pyx_CyFunctionType),
+        ml, flags, qualname, closure, module, globals, code
+    );
+    if (likely(op)) {
+        PyObject_GC_Track(op);
+    }
+    return op;
 }
 
 /* CLineInTraceback */
   #ifndef CYTHON_CLINE_IN_TRACEBACK
-static int __Pyx_CLineForTraceback(CYTHON_NCP_UNUSED PyThreadState *tstate, int c_line) {
+static int __Pyx_CLineForTraceback(PyThreadState *tstate, int c_line) {
     PyObject *use_cline;
     PyObject *ptype, *pvalue, *ptraceback;
 #if CYTHON_COMPILING_IN_CPYTHON
     PyObject **cython_runtime_dict;
 #endif
+    CYTHON_MAYBE_UNUSED_VAR(tstate);
     if (unlikely(!__pyx_cython_runtime)) {
         return c_line;
     }
     __Pyx_ErrFetchInState(tstate, &ptype, &pvalue, &ptraceback);
 #if CYTHON_COMPILING_IN_CPYTHON
     cython_runtime_dict = _PyObject_GetDictPtr(__pyx_cython_runtime);
     if (likely(cython_runtime_dict)) {
         __PYX_PY_DICT_LOOKUP_IF_MODIFIED(
             use_cline, *cython_runtime_dict,
             __Pyx_PyDict_GetItemStr(*cython_runtime_dict, __pyx_n_s_cline_in_traceback))
     } else
 #endif
     {
-      PyObject *use_cline_obj = __Pyx_PyObject_GetAttrStr(__pyx_cython_runtime, __pyx_n_s_cline_in_traceback);
+      PyObject *use_cline_obj = __Pyx_PyObject_GetAttrStrNoError(__pyx_cython_runtime, __pyx_n_s_cline_in_traceback);
       if (use_cline_obj) {
         use_cline = PyObject_Not(use_cline_obj) ? Py_False : Py_True;
         Py_DECREF(use_cline_obj);
       } else {
         PyErr_Clear();
         use_cline = NULL;
       }
@@ -8727,15 +10110,16 @@
     }
     __Pyx_ErrRestoreInState(tstate, ptype, pvalue, ptraceback);
     return c_line;
 }
 #endif
 
 /* CodeObjectCache */
-  static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line) {
+  #if !CYTHON_COMPILING_IN_LIMITED_API
+static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line) {
     int start = 0, mid = 0, end = count - 1;
     if (end >= 0 && code_line > entries[end].code_line) {
         return count;
     }
     while (start < end) {
         mid = start + (end - start) / 2;
         if (code_line < entries[mid].code_line) {
@@ -8805,25 +10189,109 @@
         entries[i] = entries[i-1];
     }
     entries[pos].code_line = code_line;
     entries[pos].code_object = code_object;
     __pyx_code_cache.count++;
     Py_INCREF(code_object);
 }
+#endif
 
 /* AddTraceback */
   #include "compile.h"
 #include "frameobject.h"
 #include "traceback.h"
-#if PY_VERSION_HEX >= 0x030b00a6
+#if PY_VERSION_HEX >= 0x030b00a6 && !CYTHON_COMPILING_IN_LIMITED_API
   #ifndef Py_BUILD_CORE
     #define Py_BUILD_CORE 1
   #endif
   #include "internal/pycore_frame.h"
 #endif
+#if CYTHON_COMPILING_IN_LIMITED_API
+static PyObject *__Pyx_PyCode_Replace_For_AddTraceback(PyObject *code, PyObject *scratch_dict,
+                                                       PyObject *firstlineno, PyObject *name) {
+    PyObject *replace = NULL;
+    if (unlikely(PyDict_SetItemString(scratch_dict, "co_firstlineno", firstlineno))) return NULL;
+    if (unlikely(PyDict_SetItemString(scratch_dict, "co_name", name))) return NULL;
+    replace = PyObject_GetAttrString(code, "replace");
+    if (likely(replace)) {
+        PyObject *result;
+        result = PyObject_Call(replace, __pyx_empty_tuple, scratch_dict);
+        Py_DECREF(replace);
+        return result;
+    }
+    PyErr_Clear();
+    #if __PYX_LIMITED_VERSION_HEX < 0x030780000
+    {
+        PyObject *compiled = NULL, *result = NULL;
+        if (unlikely(PyDict_SetItemString(scratch_dict, "code", code))) return NULL;
+        if (unlikely(PyDict_SetItemString(scratch_dict, "type", (PyObject*)(&PyType_Type)))) return NULL;
+        compiled = Py_CompileString(
+            "out = type(code)(\n"
+            "  code.co_argcount, code.co_kwonlyargcount, code.co_nlocals, code.co_stacksize,\n"
+            "  code.co_flags, code.co_code, code.co_consts, code.co_names,\n"
+            "  code.co_varnames, code.co_filename, co_name, co_firstlineno,\n"
+            "  code.co_lnotab)\n", "<dummy>", Py_file_input);
+        if (!compiled) return NULL;
+        result = PyEval_EvalCode(compiled, scratch_dict, scratch_dict);
+        Py_DECREF(compiled);
+        if (!result) PyErr_Print();
+        Py_DECREF(result);
+        result = PyDict_GetItemString(scratch_dict, "out");
+        if (result) Py_INCREF(result);
+        return result;
+    }
+    #else
+    return NULL;
+    #endif
+}
+static void __Pyx_AddTraceback(const char *funcname, int c_line,
+                               int py_line, const char *filename) {
+    PyObject *code_object = NULL, *py_py_line = NULL, *py_funcname = NULL, *dict = NULL;
+    PyObject *replace = NULL, *getframe = NULL, *frame = NULL;
+    PyObject *exc_type, *exc_value, *exc_traceback;
+    int success = 0;
+    if (c_line) {
+        (void) __pyx_cfilenm;
+        (void) __Pyx_CLineForTraceback(__Pyx_PyThreadState_Current, c_line);
+    }
+    PyErr_Fetch(&exc_type, &exc_value, &exc_traceback);
+    code_object = Py_CompileString("_getframe()", filename, Py_eval_input);
+    if (unlikely(!code_object)) goto bad;
+    py_py_line = PyLong_FromLong(py_line);
+    if (unlikely(!py_py_line)) goto bad;
+    py_funcname = PyUnicode_FromString(funcname);
+    if (unlikely(!py_funcname)) goto bad;
+    dict = PyDict_New();
+    if (unlikely(!dict)) goto bad;
+    {
+        PyObject *old_code_object = code_object;
+        code_object = __Pyx_PyCode_Replace_For_AddTraceback(code_object, dict, py_py_line, py_funcname);
+        Py_DECREF(old_code_object);
+    }
+    if (unlikely(!code_object)) goto bad;
+    getframe = PySys_GetObject("_getframe");
+    if (unlikely(!getframe)) goto bad;
+    if (unlikely(PyDict_SetItemString(dict, "_getframe", getframe))) goto bad;
+    frame = PyEval_EvalCode(code_object, dict, dict);
+    if (unlikely(!frame) || frame == Py_None) goto bad;
+    success = 1;
+  bad:
+    PyErr_Restore(exc_type, exc_value, exc_traceback);
+    Py_XDECREF(code_object);
+    Py_XDECREF(py_py_line);
+    Py_XDECREF(py_funcname);
+    Py_XDECREF(dict);
+    Py_XDECREF(replace);
+    if (success) {
+        PyTraceBack_Here(
+            (struct _frame*)frame);
+    }
+    Py_XDECREF(frame);
+}
+#else
 static PyCodeObject* __Pyx_CreateCodeObjectForTraceback(
             const char *funcname, int c_line,
             int py_line, const char *filename) {
     PyCodeObject *py_code = NULL;
     PyObject *py_funcname = NULL;
     #if PY_MAJOR_VERSION < 3
     PyObject *py_srcfile = NULL;
@@ -8850,14 +10318,15 @@
     #if PY_MAJOR_VERSION < 3
     py_code = __Pyx_PyCode_New(
         0,
         0,
         0,
         0,
         0,
+        0,
         __pyx_empty_bytes, /*PyObject *code,*/
         __pyx_empty_tuple, /*PyObject *consts,*/
         __pyx_empty_tuple, /*PyObject *names,*/
         __pyx_empty_tuple, /*PyObject *varnames,*/
         __pyx_empty_tuple, /*PyObject *freevars,*/
         __pyx_empty_tuple, /*PyObject *cellvars,*/
         py_srcfile,   /*PyObject *filename,*/
@@ -8865,15 +10334,15 @@
         py_line,
         __pyx_empty_bytes  /*PyObject *lnotab*/
     );
     Py_DECREF(py_srcfile);
     #else
     py_code = PyCode_NewEmpty(filename, funcname, py_line);
     #endif
-    Py_XDECREF(py_funcname);  // XDECREF since it's only set on Py3 if cline
+    Py_XDECREF(py_funcname);
     return py_code;
 bad:
     Py_XDECREF(py_funcname);
     #if PY_MAJOR_VERSION < 3
     Py_XDECREF(py_srcfile);
     #endif
     return NULL;
@@ -8912,19 +10381,25 @@
     if (!py_frame) goto bad;
     __Pyx_PyFrame_SetLineNumber(py_frame, py_line);
     PyTraceBack_Here(py_frame);
 bad:
     Py_XDECREF(py_code);
     Py_XDECREF(py_frame);
 }
+#endif
 
 #if PY_MAJOR_VERSION < 3
 static int __Pyx_GetBuffer(PyObject *obj, Py_buffer *view, int flags) {
+    __Pyx_TypeName obj_type_name;
     if (PyObject_CheckBuffer(obj)) return PyObject_GetBuffer(obj, view, flags);
-    PyErr_Format(PyExc_TypeError, "'%.200s' does not have the buffer interface", Py_TYPE(obj)->tp_name);
+    obj_type_name = __Pyx_PyType_GetName(Py_TYPE(obj));
+    PyErr_Format(PyExc_TypeError,
+                 "'" __Pyx_FMT_TYPENAME "' does not have the buffer interface",
+                 obj_type_name);
+    __Pyx_DECREF_TypeName(obj_type_name);
     return -1;
 }
 static void __Pyx_ReleaseBuffer(Py_buffer *view) {
     PyObject *obj = view->obj;
     if (!obj) return;
     if (PyObject_CheckBuffer(obj)) {
         PyBuffer_Release(view);
@@ -8956,15 +10431,15 @@
                     goto raise_overflow;\
             }\
         }\
         return (target_type) value;\
     }
 
 /* Declarations */
-  #if CYTHON_CCOMPLEX
+  #if CYTHON_CCOMPLEX && (1) && (!0 || __cplusplus)
   #ifdef __cplusplus
     static CYTHON_INLINE __pyx_t_float_complex __pyx_t_float_complex_from_parts(float x, float y) {
       return ::std::complex< float >(x, y);
     }
   #else
     static CYTHON_INLINE __pyx_t_float_complex __pyx_t_float_complex_from_parts(float x, float y) {
       return x + y*(__pyx_t_float_complex)_Complex_I;
@@ -8976,15 +10451,15 @@
       z.real = x;
       z.imag = y;
       return z;
     }
 #endif
 
 /* Arithmetic */
-  #if CYTHON_CCOMPLEX
+  #if CYTHON_CCOMPLEX && (1) && (!0 || __cplusplus)
 #else
     static CYTHON_INLINE int __Pyx_c_eq_float(__pyx_t_float_complex a, __pyx_t_float_complex b) {
        return (a.real == b.real) && (a.imag == b.imag);
     }
     static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_sum_float(__pyx_t_float_complex a, __pyx_t_float_complex b) {
         __pyx_t_float_complex z;
         z.real = a.real + b.real;
@@ -9084,15 +10559,15 @@
                         z = __Pyx_c_prod_float(a, a);
                         return __Pyx_c_prod_float(z, z);
                 }
             }
             if (a.imag == 0) {
                 if (a.real == 0) {
                     return a;
-                } else if (b.imag == 0) {
+                } else if ((b.imag == 0) && (a.real >= 0)) {
                     z.real = powf(a.real, b.real);
                     z.imag = 0;
                     return z;
                 } else if (a.real > 0) {
                     r = a.real;
                     theta = 0;
                 } else {
@@ -9110,15 +10585,15 @@
             z.imag = z_r * sinf(z_theta);
             return z;
         }
     #endif
 #endif
 
 /* Declarations */
-  #if CYTHON_CCOMPLEX
+  #if CYTHON_CCOMPLEX && (1) && (!0 || __cplusplus)
   #ifdef __cplusplus
     static CYTHON_INLINE __pyx_t_double_complex __pyx_t_double_complex_from_parts(double x, double y) {
       return ::std::complex< double >(x, y);
     }
   #else
     static CYTHON_INLINE __pyx_t_double_complex __pyx_t_double_complex_from_parts(double x, double y) {
       return x + y*(__pyx_t_double_complex)_Complex_I;
@@ -9130,15 +10605,15 @@
       z.real = x;
       z.imag = y;
       return z;
     }
 #endif
 
 /* Arithmetic */
-  #if CYTHON_CCOMPLEX
+  #if CYTHON_CCOMPLEX && (1) && (!0 || __cplusplus)
 #else
     static CYTHON_INLINE int __Pyx_c_eq_double(__pyx_t_double_complex a, __pyx_t_double_complex b) {
        return (a.real == b.real) && (a.imag == b.imag);
     }
     static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_sum_double(__pyx_t_double_complex a, __pyx_t_double_complex b) {
         __pyx_t_double_complex z;
         z.real = a.real + b.real;
@@ -9238,15 +10713,15 @@
                         z = __Pyx_c_prod_double(a, a);
                         return __Pyx_c_prod_double(z, z);
                 }
             }
             if (a.imag == 0) {
                 if (a.real == 0) {
                     return a;
-                } else if (b.imag == 0) {
+                } else if ((b.imag == 0) && (a.real >= 0)) {
                     z.real = pow(a.real, b.real);
                     z.imag = 0;
                     return z;
                 } else if (a.real > 0) {
                     r = a.real;
                     theta = 0;
                 } else {
@@ -9263,759 +10738,918 @@
             z.real = z_r * cos(z_theta);
             z.imag = z_r * sin(z_theta);
             return z;
         }
     #endif
 #endif
 
-/* CIntToPy */
-  static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value) {
-#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wconversion"
-#endif
-    const long neg_one = (long) -1, const_zero = (long) 0;
-#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
-#pragma GCC diagnostic pop
-#endif
-    const int is_unsigned = neg_one > const_zero;
-    if (is_unsigned) {
-        if (sizeof(long) < sizeof(long)) {
-            return PyInt_FromLong((long) value);
-        } else if (sizeof(long) <= sizeof(unsigned long)) {
-            return PyLong_FromUnsignedLong((unsigned long) value);
-#ifdef HAVE_LONG_LONG
-        } else if (sizeof(long) <= sizeof(unsigned PY_LONG_LONG)) {
-            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
-#endif
-        }
-    } else {
-        if (sizeof(long) <= sizeof(long)) {
-            return PyInt_FromLong((long) value);
-#ifdef HAVE_LONG_LONG
-        } else if (sizeof(long) <= sizeof(PY_LONG_LONG)) {
-            return PyLong_FromLongLong((PY_LONG_LONG) value);
-#endif
-        }
-    }
-    {
-        int one = 1; int little = (int)*(unsigned char *)&one;
-        unsigned char *bytes = (unsigned char *)&value;
-        return _PyLong_FromByteArray(bytes, sizeof(long),
-                                     little, !is_unsigned);
-    }
-}
-
-/* CIntToPy */
-  static CYTHON_INLINE PyObject* __Pyx_PyInt_From_npy_long(npy_long value) {
-#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wconversion"
-#endif
-    const npy_long neg_one = (npy_long) -1, const_zero = (npy_long) 0;
-#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
-#pragma GCC diagnostic pop
-#endif
-    const int is_unsigned = neg_one > const_zero;
-    if (is_unsigned) {
-        if (sizeof(npy_long) < sizeof(long)) {
-            return PyInt_FromLong((long) value);
-        } else if (sizeof(npy_long) <= sizeof(unsigned long)) {
-            return PyLong_FromUnsignedLong((unsigned long) value);
-#ifdef HAVE_LONG_LONG
-        } else if (sizeof(npy_long) <= sizeof(unsigned PY_LONG_LONG)) {
-            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
-#endif
-        }
-    } else {
-        if (sizeof(npy_long) <= sizeof(long)) {
-            return PyInt_FromLong((long) value);
-#ifdef HAVE_LONG_LONG
-        } else if (sizeof(npy_long) <= sizeof(PY_LONG_LONG)) {
-            return PyLong_FromLongLong((PY_LONG_LONG) value);
-#endif
-        }
-    }
-    {
-        int one = 1; int little = (int)*(unsigned char *)&one;
-        unsigned char *bytes = (unsigned char *)&value;
-        return _PyLong_FromByteArray(bytes, sizeof(npy_long),
-                                     little, !is_unsigned);
-    }
-}
-
 /* CIntFromPy */
-  static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *x) {
+  static CYTHON_INLINE size_t __Pyx_PyInt_As_size_t(PyObject *x) {
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wconversion"
 #endif
-    const int neg_one = (int) -1, const_zero = (int) 0;
+    const size_t neg_one = (size_t) -1, const_zero = (size_t) 0;
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic pop
 #endif
     const int is_unsigned = neg_one > const_zero;
 #if PY_MAJOR_VERSION < 3
     if (likely(PyInt_Check(x))) {
-        if (sizeof(int) < sizeof(long)) {
-            __PYX_VERIFY_RETURN_INT(int, long, PyInt_AS_LONG(x))
+        if ((sizeof(size_t) < sizeof(long))) {
+            __PYX_VERIFY_RETURN_INT(size_t, long, PyInt_AS_LONG(x))
         } else {
             long val = PyInt_AS_LONG(x);
             if (is_unsigned && unlikely(val < 0)) {
                 goto raise_neg_overflow;
             }
-            return (int) val;
+            return (size_t) val;
         }
     } else
 #endif
     if (likely(PyLong_Check(x))) {
         if (is_unsigned) {
 #if CYTHON_USE_PYLONG_INTERNALS
-            const digit* digits = ((PyLongObject*)x)->ob_digit;
-            switch (Py_SIZE(x)) {
-                case  0: return (int) 0;
-                case  1: __PYX_VERIFY_RETURN_INT(int, digit, digits[0])
-                case 2:
-                    if (8 * sizeof(int) > 1 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(int) >= 2 * PyLong_SHIFT) {
-                            return (int) (((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
+            if (unlikely(__Pyx_PyLong_IsNeg(x))) {
+                goto raise_neg_overflow;
+            } else if (__Pyx_PyLong_IsCompact(x)) {
+                __PYX_VERIFY_RETURN_INT(size_t, __Pyx_compact_upylong, __Pyx_PyLong_CompactValueUnsigned(x))
+            } else {
+                const digit* digits = __Pyx_PyLong_Digits(x);
+                assert(__Pyx_PyLong_DigitCount(x) > 1);
+                switch (__Pyx_PyLong_DigitCount(x)) {
+                    case 2:
+                        if ((8 * sizeof(size_t) > 1 * PyLong_SHIFT)) {
+                            if ((8 * sizeof(unsigned long) > 2 * PyLong_SHIFT)) {
+                                __PYX_VERIFY_RETURN_INT(size_t, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                            } else if ((8 * sizeof(size_t) >= 2 * PyLong_SHIFT)) {
+                                return (size_t) (((((size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
+                            }
                         }
-                    }
-                    break;
-                case 3:
-                    if (8 * sizeof(int) > 2 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(int) >= 3 * PyLong_SHIFT) {
-                            return (int) (((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
+                        break;
+                    case 3:
+                        if ((8 * sizeof(size_t) > 2 * PyLong_SHIFT)) {
+                            if ((8 * sizeof(unsigned long) > 3 * PyLong_SHIFT)) {
+                                __PYX_VERIFY_RETURN_INT(size_t, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                            } else if ((8 * sizeof(size_t) >= 3 * PyLong_SHIFT)) {
+                                return (size_t) (((((((size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
+                            }
                         }
-                    }
-                    break;
-                case 4:
-                    if (8 * sizeof(int) > 3 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(int) >= 4 * PyLong_SHIFT) {
-                            return (int) (((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
+                        break;
+                    case 4:
+                        if ((8 * sizeof(size_t) > 3 * PyLong_SHIFT)) {
+                            if ((8 * sizeof(unsigned long) > 4 * PyLong_SHIFT)) {
+                                __PYX_VERIFY_RETURN_INT(size_t, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                            } else if ((8 * sizeof(size_t) >= 4 * PyLong_SHIFT)) {
+                                return (size_t) (((((((((size_t)digits[3]) << PyLong_SHIFT) | (size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
+                            }
                         }
-                    }
-                    break;
+                        break;
+                }
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
-                    return (int) -1;
+                    return (size_t) -1;
                 if (unlikely(result == 1))
                     goto raise_neg_overflow;
             }
 #endif
-            if (sizeof(int) <= sizeof(unsigned long)) {
-                __PYX_VERIFY_RETURN_INT_EXC(int, unsigned long, PyLong_AsUnsignedLong(x))
+            if ((sizeof(size_t) <= sizeof(unsigned long))) {
+                __PYX_VERIFY_RETURN_INT_EXC(size_t, unsigned long, PyLong_AsUnsignedLong(x))
 #ifdef HAVE_LONG_LONG
-            } else if (sizeof(int) <= sizeof(unsigned PY_LONG_LONG)) {
-                __PYX_VERIFY_RETURN_INT_EXC(int, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
+            } else if ((sizeof(size_t) <= sizeof(unsigned PY_LONG_LONG))) {
+                __PYX_VERIFY_RETURN_INT_EXC(size_t, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
 #endif
             }
         } else {
 #if CYTHON_USE_PYLONG_INTERNALS
-            const digit* digits = ((PyLongObject*)x)->ob_digit;
-            switch (Py_SIZE(x)) {
-                case  0: return (int) 0;
-                case -1: __PYX_VERIFY_RETURN_INT(int, sdigit, (sdigit) (-(sdigit)digits[0]))
-                case  1: __PYX_VERIFY_RETURN_INT(int,  digit, +digits[0])
-                case -2:
-                    if (8 * sizeof(int) - 1 > 1 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
-                            return (int) (((int)-1)*(((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
+            if (__Pyx_PyLong_IsCompact(x)) {
+                __PYX_VERIFY_RETURN_INT(size_t, __Pyx_compact_pylong, __Pyx_PyLong_CompactValue(x))
+            } else {
+                const digit* digits = __Pyx_PyLong_Digits(x);
+                assert(__Pyx_PyLong_DigitCount(x) > 1);
+                switch (__Pyx_PyLong_SignedDigitCount(x)) {
+                    case -2:
+                        if ((8 * sizeof(size_t) - 1 > 1 * PyLong_SHIFT)) {
+                            if ((8 * sizeof(unsigned long) > 2 * PyLong_SHIFT)) {
+                                __PYX_VERIFY_RETURN_INT(size_t, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                            } else if ((8 * sizeof(size_t) - 1 > 2 * PyLong_SHIFT)) {
+                                return (size_t) (((size_t)-1)*(((((size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0])));
+                            }
                         }
-                    }
-                    break;
-                case 2:
-                    if (8 * sizeof(int) > 1 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
-                            return (int) ((((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
+                        break;
+                    case 2:
+                        if ((8 * sizeof(size_t) > 1 * PyLong_SHIFT)) {
+                            if ((8 * sizeof(unsigned long) > 2 * PyLong_SHIFT)) {
+                                __PYX_VERIFY_RETURN_INT(size_t, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                            } else if ((8 * sizeof(size_t) - 1 > 2 * PyLong_SHIFT)) {
+                                return (size_t) ((((((size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0])));
+                            }
                         }
-                    }
-                    break;
-                case -3:
-                    if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
-                            return (int) (((int)-1)*(((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
+                        break;
+                    case -3:
+                        if ((8 * sizeof(size_t) - 1 > 2 * PyLong_SHIFT)) {
+                            if ((8 * sizeof(unsigned long) > 3 * PyLong_SHIFT)) {
+                                __PYX_VERIFY_RETURN_INT(size_t, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                            } else if ((8 * sizeof(size_t) - 1 > 3 * PyLong_SHIFT)) {
+                                return (size_t) (((size_t)-1)*(((((((size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0])));
+                            }
                         }
-                    }
-                    break;
-                case 3:
-                    if (8 * sizeof(int) > 2 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
-                            return (int) ((((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
+                        break;
+                    case 3:
+                        if ((8 * sizeof(size_t) > 2 * PyLong_SHIFT)) {
+                            if ((8 * sizeof(unsigned long) > 3 * PyLong_SHIFT)) {
+                                __PYX_VERIFY_RETURN_INT(size_t, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                            } else if ((8 * sizeof(size_t) - 1 > 3 * PyLong_SHIFT)) {
+                                return (size_t) ((((((((size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0])));
+                            }
                         }
-                    }
-                    break;
-                case -4:
-                    if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(int) - 1 > 4 * PyLong_SHIFT) {
-                            return (int) (((int)-1)*(((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
+                        break;
+                    case -4:
+                        if ((8 * sizeof(size_t) - 1 > 3 * PyLong_SHIFT)) {
+                            if ((8 * sizeof(unsigned long) > 4 * PyLong_SHIFT)) {
+                                __PYX_VERIFY_RETURN_INT(size_t, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                            } else if ((8 * sizeof(size_t) - 1 > 4 * PyLong_SHIFT)) {
+                                return (size_t) (((size_t)-1)*(((((((((size_t)digits[3]) << PyLong_SHIFT) | (size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0])));
+                            }
                         }
-                    }
-                    break;
-                case 4:
-                    if (8 * sizeof(int) > 3 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(int) - 1 > 4 * PyLong_SHIFT) {
-                            return (int) ((((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
+                        break;
+                    case 4:
+                        if ((8 * sizeof(size_t) > 3 * PyLong_SHIFT)) {
+                            if ((8 * sizeof(unsigned long) > 4 * PyLong_SHIFT)) {
+                                __PYX_VERIFY_RETURN_INT(size_t, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                            } else if ((8 * sizeof(size_t) - 1 > 4 * PyLong_SHIFT)) {
+                                return (size_t) ((((((((((size_t)digits[3]) << PyLong_SHIFT) | (size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0])));
+                            }
                         }
-                    }
-                    break;
+                        break;
+                }
             }
 #endif
-            if (sizeof(int) <= sizeof(long)) {
-                __PYX_VERIFY_RETURN_INT_EXC(int, long, PyLong_AsLong(x))
+            if ((sizeof(size_t) <= sizeof(long))) {
+                __PYX_VERIFY_RETURN_INT_EXC(size_t, long, PyLong_AsLong(x))
 #ifdef HAVE_LONG_LONG
-            } else if (sizeof(int) <= sizeof(PY_LONG_LONG)) {
-                __PYX_VERIFY_RETURN_INT_EXC(int, PY_LONG_LONG, PyLong_AsLongLong(x))
+            } else if ((sizeof(size_t) <= sizeof(PY_LONG_LONG))) {
+                __PYX_VERIFY_RETURN_INT_EXC(size_t, PY_LONG_LONG, PyLong_AsLongLong(x))
 #endif
             }
         }
         {
-#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
-            PyErr_SetString(PyExc_RuntimeError,
-                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
-#else
-            int val;
+            size_t val;
             PyObject *v = __Pyx_PyNumber_IntOrLong(x);
- #if PY_MAJOR_VERSION < 3
+#if PY_MAJOR_VERSION < 3
             if (likely(v) && !PyLong_Check(v)) {
                 PyObject *tmp = v;
                 v = PyNumber_Long(tmp);
                 Py_DECREF(tmp);
             }
- #endif
+#endif
             if (likely(v)) {
+                int ret = -1;
+#if PY_VERSION_HEX < 0x030d0000 && !(CYTHON_COMPILING_IN_PYPY || CYTHON_COMPILING_IN_LIMITED_API) || defined(_PyLong_AsByteArray)
                 int one = 1; int is_little = (int)*(unsigned char *)&one;
                 unsigned char *bytes = (unsigned char *)&val;
-                int ret = _PyLong_AsByteArray((PyLongObject *)v,
-                                              bytes, sizeof(val),
-                                              is_little, !is_unsigned);
+                ret = _PyLong_AsByteArray((PyLongObject *)v,
+                                           bytes, sizeof(val),
+                                           is_little, !is_unsigned);
+#else
+                PyObject *stepval = NULL, *mask = NULL, *shift = NULL;
+                int bits, remaining_bits, is_negative = 0;
+                long idigit;
+                int chunk_size = (sizeof(long) < 8) ? 30 : 62;
+                if (unlikely(!PyLong_CheckExact(v))) {
+                    PyObject *tmp = v;
+                    v = PyNumber_Long(v);
+                    assert(PyLong_CheckExact(v));
+                    Py_DECREF(tmp);
+                    if (unlikely(!v)) return (size_t) -1;
+                }
+#if CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030B0000
+                if (Py_SIZE(x) == 0)
+                    return (size_t) 0;
+                is_negative = Py_SIZE(x) < 0;
+#else
+                {
+                    int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
+                    if (unlikely(result < 0))
+                        return (size_t) -1;
+                    is_negative = result == 1;
+                }
+#endif
+                if (is_unsigned && unlikely(is_negative)) {
+                    goto raise_neg_overflow;
+                } else if (is_negative) {
+                    stepval = PyNumber_Invert(v);
+                    if (unlikely(!stepval))
+                        return (size_t) -1;
+                } else {
+                    stepval = __Pyx_NewRef(v);
+                }
+                val = (size_t) 0;
+                mask = PyLong_FromLong((1L << chunk_size) - 1); if (unlikely(!mask)) goto done;
+                shift = PyLong_FromLong(chunk_size); if (unlikely(!shift)) goto done;
+                for (bits = 0; bits < (int) sizeof(size_t) * 8 - chunk_size; bits += chunk_size) {
+                    PyObject *tmp, *digit;
+                    digit = PyNumber_And(stepval, mask);
+                    if (unlikely(!digit)) goto done;
+                    idigit = PyLong_AsLong(digit);
+                    Py_DECREF(digit);
+                    if (unlikely(idigit < 0)) goto done;
+                    tmp = PyNumber_Rshift(stepval, shift);
+                    if (unlikely(!tmp)) goto done;
+                    Py_DECREF(stepval); stepval = tmp;
+                    val |= ((size_t) idigit) << bits;
+                    #if CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030B0000
+                    if (Py_SIZE(stepval) == 0)
+                        goto unpacking_done;
+                    #endif
+                }
+                idigit = PyLong_AsLong(stepval);
+                if (unlikely(idigit < 0)) goto done;
+                remaining_bits = ((int) sizeof(size_t) * 8) - bits - (is_unsigned ? 0 : 1);
+                if (unlikely(idigit >= (1L << remaining_bits)))
+                    goto raise_overflow;
+                val |= ((size_t) idigit) << bits;
+            #if CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030B0000
+            unpacking_done:
+            #endif
+                if (!is_unsigned) {
+                    if (unlikely(val & (((size_t) 1) << (sizeof(size_t) * 8 - 1))))
+                        goto raise_overflow;
+                    if (is_negative)
+                        val = ~val;
+                }
+                ret = 0;
+            done:
+                Py_XDECREF(shift);
+                Py_XDECREF(mask);
+                Py_XDECREF(stepval);
+#endif
                 Py_DECREF(v);
                 if (likely(!ret))
                     return val;
             }
-#endif
-            return (int) -1;
+            return (size_t) -1;
         }
     } else {
-        int val;
+        size_t val;
         PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
-        if (!tmp) return (int) -1;
-        val = __Pyx_PyInt_As_int(tmp);
+        if (!tmp) return (size_t) -1;
+        val = __Pyx_PyInt_As_size_t(tmp);
         Py_DECREF(tmp);
         return val;
     }
 raise_overflow:
     PyErr_SetString(PyExc_OverflowError,
-        "value too large to convert to int");
-    return (int) -1;
+        "value too large to convert to size_t");
+    return (size_t) -1;
 raise_neg_overflow:
     PyErr_SetString(PyExc_OverflowError,
-        "can't convert negative value to int");
-    return (int) -1;
+        "can't convert negative value to size_t");
+    return (size_t) -1;
 }
 
 /* CIntToPy */
-  static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int(int value) {
+  static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value) {
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wconversion"
 #endif
-    const int neg_one = (int) -1, const_zero = (int) 0;
+    const long neg_one = (long) -1, const_zero = (long) 0;
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic pop
 #endif
     const int is_unsigned = neg_one > const_zero;
     if (is_unsigned) {
-        if (sizeof(int) < sizeof(long)) {
+        if (sizeof(long) < sizeof(long)) {
             return PyInt_FromLong((long) value);
-        } else if (sizeof(int) <= sizeof(unsigned long)) {
+        } else if (sizeof(long) <= sizeof(unsigned long)) {
             return PyLong_FromUnsignedLong((unsigned long) value);
 #ifdef HAVE_LONG_LONG
-        } else if (sizeof(int) <= sizeof(unsigned PY_LONG_LONG)) {
+        } else if (sizeof(long) <= sizeof(unsigned PY_LONG_LONG)) {
             return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
 #endif
         }
     } else {
-        if (sizeof(int) <= sizeof(long)) {
+        if (sizeof(long) <= sizeof(long)) {
             return PyInt_FromLong((long) value);
 #ifdef HAVE_LONG_LONG
-        } else if (sizeof(int) <= sizeof(PY_LONG_LONG)) {
+        } else if (sizeof(long) <= sizeof(PY_LONG_LONG)) {
             return PyLong_FromLongLong((PY_LONG_LONG) value);
 #endif
         }
     }
     {
         int one = 1; int little = (int)*(unsigned char *)&one;
         unsigned char *bytes = (unsigned char *)&value;
-        return _PyLong_FromByteArray(bytes, sizeof(int),
+#if !CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030d0000
+        return _PyLong_FromByteArray(bytes, sizeof(long),
                                      little, !is_unsigned);
-    }
-}
-
-/* CIntToPy */
-  static CYTHON_INLINE PyObject* __Pyx_PyInt_From_Py_intptr_t(Py_intptr_t value) {
-#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wconversion"
-#endif
-    const Py_intptr_t neg_one = (Py_intptr_t) -1, const_zero = (Py_intptr_t) 0;
-#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
-#pragma GCC diagnostic pop
-#endif
-    const int is_unsigned = neg_one > const_zero;
-    if (is_unsigned) {
-        if (sizeof(Py_intptr_t) < sizeof(long)) {
-            return PyInt_FromLong((long) value);
-        } else if (sizeof(Py_intptr_t) <= sizeof(unsigned long)) {
-            return PyLong_FromUnsignedLong((unsigned long) value);
-#ifdef HAVE_LONG_LONG
-        } else if (sizeof(Py_intptr_t) <= sizeof(unsigned PY_LONG_LONG)) {
-            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
-#endif
+#else
+        PyObject *from_bytes, *result = NULL;
+        PyObject *py_bytes = NULL, *arg_tuple = NULL, *kwds = NULL, *order_str = NULL;
+        from_bytes = PyObject_GetAttrString((PyObject*)&PyLong_Type, "from_bytes");
+        if (!from_bytes) return NULL;
+        py_bytes = PyBytes_FromStringAndSize((char*)bytes, sizeof(long));
+        if (!py_bytes) goto limited_bad;
+        order_str = PyUnicode_FromString(little ? "little" : "big");
+        if (!order_str) goto limited_bad;
+        arg_tuple = PyTuple_Pack(2, py_bytes, order_str);
+        if (!arg_tuple) goto limited_bad;
+        if (!is_unsigned) {
+            kwds = PyDict_New();
+            if (!kwds) goto limited_bad;
+            if (PyDict_SetItemString(kwds, "signed", __Pyx_NewRef(Py_True))) goto limited_bad;
         }
-    } else {
-        if (sizeof(Py_intptr_t) <= sizeof(long)) {
-            return PyInt_FromLong((long) value);
-#ifdef HAVE_LONG_LONG
-        } else if (sizeof(Py_intptr_t) <= sizeof(PY_LONG_LONG)) {
-            return PyLong_FromLongLong((PY_LONG_LONG) value);
+        result = PyObject_Call(from_bytes, arg_tuple, kwds);
+        limited_bad:
+        Py_XDECREF(kwds);
+        Py_XDECREF(arg_tuple);
+        Py_XDECREF(order_str);
+        Py_XDECREF(py_bytes);
+        Py_XDECREF(from_bytes);
+        return result;
 #endif
-        }
     }
-    {
-        int one = 1; int little = (int)*(unsigned char *)&one;
-        unsigned char *bytes = (unsigned char *)&value;
-        return _PyLong_FromByteArray(bytes, sizeof(Py_intptr_t),
-                                     little, !is_unsigned);
+}
+
+/* FormatTypeName */
+  #if CYTHON_COMPILING_IN_LIMITED_API
+static __Pyx_TypeName
+__Pyx_PyType_GetName(PyTypeObject* tp)
+{
+    PyObject *name = __Pyx_PyObject_GetAttrStr((PyObject *)tp,
+                                               __pyx_n_s_name);
+    if (unlikely(name == NULL) || unlikely(!PyUnicode_Check(name))) {
+        PyErr_Clear();
+        Py_XDECREF(name);
+        name = __Pyx_NewRef(__pyx_n_s__13);
     }
+    return name;
 }
+#endif
 
 /* CIntFromPy */
-  static CYTHON_INLINE Py_intptr_t __Pyx_PyInt_As_Py_intptr_t(PyObject *x) {
+  static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *x) {
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wconversion"
 #endif
-    const Py_intptr_t neg_one = (Py_intptr_t) -1, const_zero = (Py_intptr_t) 0;
+    const long neg_one = (long) -1, const_zero = (long) 0;
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic pop
 #endif
     const int is_unsigned = neg_one > const_zero;
 #if PY_MAJOR_VERSION < 3
     if (likely(PyInt_Check(x))) {
-        if (sizeof(Py_intptr_t) < sizeof(long)) {
-            __PYX_VERIFY_RETURN_INT(Py_intptr_t, long, PyInt_AS_LONG(x))
+        if ((sizeof(long) < sizeof(long))) {
+            __PYX_VERIFY_RETURN_INT(long, long, PyInt_AS_LONG(x))
         } else {
             long val = PyInt_AS_LONG(x);
             if (is_unsigned && unlikely(val < 0)) {
                 goto raise_neg_overflow;
             }
-            return (Py_intptr_t) val;
+            return (long) val;
         }
     } else
 #endif
     if (likely(PyLong_Check(x))) {
         if (is_unsigned) {
 #if CYTHON_USE_PYLONG_INTERNALS
-            const digit* digits = ((PyLongObject*)x)->ob_digit;
-            switch (Py_SIZE(x)) {
-                case  0: return (Py_intptr_t) 0;
-                case  1: __PYX_VERIFY_RETURN_INT(Py_intptr_t, digit, digits[0])
-                case 2:
-                    if (8 * sizeof(Py_intptr_t) > 1 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(Py_intptr_t, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(Py_intptr_t) >= 2 * PyLong_SHIFT) {
-                            return (Py_intptr_t) (((((Py_intptr_t)digits[1]) << PyLong_SHIFT) | (Py_intptr_t)digits[0]));
+            if (unlikely(__Pyx_PyLong_IsNeg(x))) {
+                goto raise_neg_overflow;
+            } else if (__Pyx_PyLong_IsCompact(x)) {
+                __PYX_VERIFY_RETURN_INT(long, __Pyx_compact_upylong, __Pyx_PyLong_CompactValueUnsigned(x))
+            } else {
+                const digit* digits = __Pyx_PyLong_Digits(x);
+                assert(__Pyx_PyLong_DigitCount(x) > 1);
+                switch (__Pyx_PyLong_DigitCount(x)) {
+                    case 2:
+                        if ((8 * sizeof(long) > 1 * PyLong_SHIFT)) {
+                            if ((8 * sizeof(unsigned long) > 2 * PyLong_SHIFT)) {
+                                __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                            } else if ((8 * sizeof(long) >= 2 * PyLong_SHIFT)) {
+                                return (long) (((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
+                            }
                         }
-                    }
-                    break;
-                case 3:
-                    if (8 * sizeof(Py_intptr_t) > 2 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(Py_intptr_t, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(Py_intptr_t) >= 3 * PyLong_SHIFT) {
-                            return (Py_intptr_t) (((((((Py_intptr_t)digits[2]) << PyLong_SHIFT) | (Py_intptr_t)digits[1]) << PyLong_SHIFT) | (Py_intptr_t)digits[0]));
+                        break;
+                    case 3:
+                        if ((8 * sizeof(long) > 2 * PyLong_SHIFT)) {
+                            if ((8 * sizeof(unsigned long) > 3 * PyLong_SHIFT)) {
+                                __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                            } else if ((8 * sizeof(long) >= 3 * PyLong_SHIFT)) {
+                                return (long) (((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
+                            }
                         }
-                    }
-                    break;
-                case 4:
-                    if (8 * sizeof(Py_intptr_t) > 3 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(Py_intptr_t, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(Py_intptr_t) >= 4 * PyLong_SHIFT) {
-                            return (Py_intptr_t) (((((((((Py_intptr_t)digits[3]) << PyLong_SHIFT) | (Py_intptr_t)digits[2]) << PyLong_SHIFT) | (Py_intptr_t)digits[1]) << PyLong_SHIFT) | (Py_intptr_t)digits[0]));
+                        break;
+                    case 4:
+                        if ((8 * sizeof(long) > 3 * PyLong_SHIFT)) {
+                            if ((8 * sizeof(unsigned long) > 4 * PyLong_SHIFT)) {
+                                __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                            } else if ((8 * sizeof(long) >= 4 * PyLong_SHIFT)) {
+                                return (long) (((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
+                            }
                         }
-                    }
-                    break;
+                        break;
+                }
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
-                    return (Py_intptr_t) -1;
+                    return (long) -1;
                 if (unlikely(result == 1))
                     goto raise_neg_overflow;
             }
 #endif
-            if (sizeof(Py_intptr_t) <= sizeof(unsigned long)) {
-                __PYX_VERIFY_RETURN_INT_EXC(Py_intptr_t, unsigned long, PyLong_AsUnsignedLong(x))
+            if ((sizeof(long) <= sizeof(unsigned long))) {
+                __PYX_VERIFY_RETURN_INT_EXC(long, unsigned long, PyLong_AsUnsignedLong(x))
 #ifdef HAVE_LONG_LONG
-            } else if (sizeof(Py_intptr_t) <= sizeof(unsigned PY_LONG_LONG)) {
-                __PYX_VERIFY_RETURN_INT_EXC(Py_intptr_t, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
+            } else if ((sizeof(long) <= sizeof(unsigned PY_LONG_LONG))) {
+                __PYX_VERIFY_RETURN_INT_EXC(long, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
 #endif
             }
         } else {
 #if CYTHON_USE_PYLONG_INTERNALS
-            const digit* digits = ((PyLongObject*)x)->ob_digit;
-            switch (Py_SIZE(x)) {
-                case  0: return (Py_intptr_t) 0;
-                case -1: __PYX_VERIFY_RETURN_INT(Py_intptr_t, sdigit, (sdigit) (-(sdigit)digits[0]))
-                case  1: __PYX_VERIFY_RETURN_INT(Py_intptr_t,  digit, +digits[0])
-                case -2:
-                    if (8 * sizeof(Py_intptr_t) - 1 > 1 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(Py_intptr_t, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(Py_intptr_t) - 1 > 2 * PyLong_SHIFT) {
-                            return (Py_intptr_t) (((Py_intptr_t)-1)*(((((Py_intptr_t)digits[1]) << PyLong_SHIFT) | (Py_intptr_t)digits[0])));
+            if (__Pyx_PyLong_IsCompact(x)) {
+                __PYX_VERIFY_RETURN_INT(long, __Pyx_compact_pylong, __Pyx_PyLong_CompactValue(x))
+            } else {
+                const digit* digits = __Pyx_PyLong_Digits(x);
+                assert(__Pyx_PyLong_DigitCount(x) > 1);
+                switch (__Pyx_PyLong_SignedDigitCount(x)) {
+                    case -2:
+                        if ((8 * sizeof(long) - 1 > 1 * PyLong_SHIFT)) {
+                            if ((8 * sizeof(unsigned long) > 2 * PyLong_SHIFT)) {
+                                __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                            } else if ((8 * sizeof(long) - 1 > 2 * PyLong_SHIFT)) {
+                                return (long) (((long)-1)*(((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
+                            }
                         }
-                    }
-                    break;
-                case 2:
-                    if (8 * sizeof(Py_intptr_t) > 1 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(Py_intptr_t, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(Py_intptr_t) - 1 > 2 * PyLong_SHIFT) {
-                            return (Py_intptr_t) ((((((Py_intptr_t)digits[1]) << PyLong_SHIFT) | (Py_intptr_t)digits[0])));
+                        break;
+                    case 2:
+                        if ((8 * sizeof(long) > 1 * PyLong_SHIFT)) {
+                            if ((8 * sizeof(unsigned long) > 2 * PyLong_SHIFT)) {
+                                __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                            } else if ((8 * sizeof(long) - 1 > 2 * PyLong_SHIFT)) {
+                                return (long) ((((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
+                            }
                         }
-                    }
-                    break;
-                case -3:
-                    if (8 * sizeof(Py_intptr_t) - 1 > 2 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(Py_intptr_t, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(Py_intptr_t) - 1 > 3 * PyLong_SHIFT) {
-                            return (Py_intptr_t) (((Py_intptr_t)-1)*(((((((Py_intptr_t)digits[2]) << PyLong_SHIFT) | (Py_intptr_t)digits[1]) << PyLong_SHIFT) | (Py_intptr_t)digits[0])));
+                        break;
+                    case -3:
+                        if ((8 * sizeof(long) - 1 > 2 * PyLong_SHIFT)) {
+                            if ((8 * sizeof(unsigned long) > 3 * PyLong_SHIFT)) {
+                                __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                            } else if ((8 * sizeof(long) - 1 > 3 * PyLong_SHIFT)) {
+                                return (long) (((long)-1)*(((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
+                            }
                         }
-                    }
-                    break;
-                case 3:
-                    if (8 * sizeof(Py_intptr_t) > 2 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(Py_intptr_t, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(Py_intptr_t) - 1 > 3 * PyLong_SHIFT) {
-                            return (Py_intptr_t) ((((((((Py_intptr_t)digits[2]) << PyLong_SHIFT) | (Py_intptr_t)digits[1]) << PyLong_SHIFT) | (Py_intptr_t)digits[0])));
+                        break;
+                    case 3:
+                        if ((8 * sizeof(long) > 2 * PyLong_SHIFT)) {
+                            if ((8 * sizeof(unsigned long) > 3 * PyLong_SHIFT)) {
+                                __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                            } else if ((8 * sizeof(long) - 1 > 3 * PyLong_SHIFT)) {
+                                return (long) ((((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
+                            }
                         }
-                    }
-                    break;
-                case -4:
-                    if (8 * sizeof(Py_intptr_t) - 1 > 3 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(Py_intptr_t, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(Py_intptr_t) - 1 > 4 * PyLong_SHIFT) {
-                            return (Py_intptr_t) (((Py_intptr_t)-1)*(((((((((Py_intptr_t)digits[3]) << PyLong_SHIFT) | (Py_intptr_t)digits[2]) << PyLong_SHIFT) | (Py_intptr_t)digits[1]) << PyLong_SHIFT) | (Py_intptr_t)digits[0])));
+                        break;
+                    case -4:
+                        if ((8 * sizeof(long) - 1 > 3 * PyLong_SHIFT)) {
+                            if ((8 * sizeof(unsigned long) > 4 * PyLong_SHIFT)) {
+                                __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                            } else if ((8 * sizeof(long) - 1 > 4 * PyLong_SHIFT)) {
+                                return (long) (((long)-1)*(((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
+                            }
                         }
-                    }
-                    break;
-                case 4:
-                    if (8 * sizeof(Py_intptr_t) > 3 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(Py_intptr_t, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(Py_intptr_t) - 1 > 4 * PyLong_SHIFT) {
-                            return (Py_intptr_t) ((((((((((Py_intptr_t)digits[3]) << PyLong_SHIFT) | (Py_intptr_t)digits[2]) << PyLong_SHIFT) | (Py_intptr_t)digits[1]) << PyLong_SHIFT) | (Py_intptr_t)digits[0])));
+                        break;
+                    case 4:
+                        if ((8 * sizeof(long) > 3 * PyLong_SHIFT)) {
+                            if ((8 * sizeof(unsigned long) > 4 * PyLong_SHIFT)) {
+                                __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                            } else if ((8 * sizeof(long) - 1 > 4 * PyLong_SHIFT)) {
+                                return (long) ((((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
+                            }
                         }
-                    }
-                    break;
+                        break;
+                }
             }
 #endif
-            if (sizeof(Py_intptr_t) <= sizeof(long)) {
-                __PYX_VERIFY_RETURN_INT_EXC(Py_intptr_t, long, PyLong_AsLong(x))
+            if ((sizeof(long) <= sizeof(long))) {
+                __PYX_VERIFY_RETURN_INT_EXC(long, long, PyLong_AsLong(x))
 #ifdef HAVE_LONG_LONG
-            } else if (sizeof(Py_intptr_t) <= sizeof(PY_LONG_LONG)) {
-                __PYX_VERIFY_RETURN_INT_EXC(Py_intptr_t, PY_LONG_LONG, PyLong_AsLongLong(x))
+            } else if ((sizeof(long) <= sizeof(PY_LONG_LONG))) {
+                __PYX_VERIFY_RETURN_INT_EXC(long, PY_LONG_LONG, PyLong_AsLongLong(x))
 #endif
             }
         }
         {
-#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
-            PyErr_SetString(PyExc_RuntimeError,
-                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
-#else
-            Py_intptr_t val;
+            long val;
             PyObject *v = __Pyx_PyNumber_IntOrLong(x);
- #if PY_MAJOR_VERSION < 3
+#if PY_MAJOR_VERSION < 3
             if (likely(v) && !PyLong_Check(v)) {
                 PyObject *tmp = v;
                 v = PyNumber_Long(tmp);
                 Py_DECREF(tmp);
             }
- #endif
+#endif
             if (likely(v)) {
+                int ret = -1;
+#if PY_VERSION_HEX < 0x030d0000 && !(CYTHON_COMPILING_IN_PYPY || CYTHON_COMPILING_IN_LIMITED_API) || defined(_PyLong_AsByteArray)
                 int one = 1; int is_little = (int)*(unsigned char *)&one;
                 unsigned char *bytes = (unsigned char *)&val;
-                int ret = _PyLong_AsByteArray((PyLongObject *)v,
-                                              bytes, sizeof(val),
-                                              is_little, !is_unsigned);
+                ret = _PyLong_AsByteArray((PyLongObject *)v,
+                                           bytes, sizeof(val),
+                                           is_little, !is_unsigned);
+#else
+                PyObject *stepval = NULL, *mask = NULL, *shift = NULL;
+                int bits, remaining_bits, is_negative = 0;
+                long idigit;
+                int chunk_size = (sizeof(long) < 8) ? 30 : 62;
+                if (unlikely(!PyLong_CheckExact(v))) {
+                    PyObject *tmp = v;
+                    v = PyNumber_Long(v);
+                    assert(PyLong_CheckExact(v));
+                    Py_DECREF(tmp);
+                    if (unlikely(!v)) return (long) -1;
+                }
+#if CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030B0000
+                if (Py_SIZE(x) == 0)
+                    return (long) 0;
+                is_negative = Py_SIZE(x) < 0;
+#else
+                {
+                    int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
+                    if (unlikely(result < 0))
+                        return (long) -1;
+                    is_negative = result == 1;
+                }
+#endif
+                if (is_unsigned && unlikely(is_negative)) {
+                    goto raise_neg_overflow;
+                } else if (is_negative) {
+                    stepval = PyNumber_Invert(v);
+                    if (unlikely(!stepval))
+                        return (long) -1;
+                } else {
+                    stepval = __Pyx_NewRef(v);
+                }
+                val = (long) 0;
+                mask = PyLong_FromLong((1L << chunk_size) - 1); if (unlikely(!mask)) goto done;
+                shift = PyLong_FromLong(chunk_size); if (unlikely(!shift)) goto done;
+                for (bits = 0; bits < (int) sizeof(long) * 8 - chunk_size; bits += chunk_size) {
+                    PyObject *tmp, *digit;
+                    digit = PyNumber_And(stepval, mask);
+                    if (unlikely(!digit)) goto done;
+                    idigit = PyLong_AsLong(digit);
+                    Py_DECREF(digit);
+                    if (unlikely(idigit < 0)) goto done;
+                    tmp = PyNumber_Rshift(stepval, shift);
+                    if (unlikely(!tmp)) goto done;
+                    Py_DECREF(stepval); stepval = tmp;
+                    val |= ((long) idigit) << bits;
+                    #if CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030B0000
+                    if (Py_SIZE(stepval) == 0)
+                        goto unpacking_done;
+                    #endif
+                }
+                idigit = PyLong_AsLong(stepval);
+                if (unlikely(idigit < 0)) goto done;
+                remaining_bits = ((int) sizeof(long) * 8) - bits - (is_unsigned ? 0 : 1);
+                if (unlikely(idigit >= (1L << remaining_bits)))
+                    goto raise_overflow;
+                val |= ((long) idigit) << bits;
+            #if CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030B0000
+            unpacking_done:
+            #endif
+                if (!is_unsigned) {
+                    if (unlikely(val & (((long) 1) << (sizeof(long) * 8 - 1))))
+                        goto raise_overflow;
+                    if (is_negative)
+                        val = ~val;
+                }
+                ret = 0;
+            done:
+                Py_XDECREF(shift);
+                Py_XDECREF(mask);
+                Py_XDECREF(stepval);
+#endif
                 Py_DECREF(v);
                 if (likely(!ret))
                     return val;
             }
-#endif
-            return (Py_intptr_t) -1;
+            return (long) -1;
         }
     } else {
-        Py_intptr_t val;
+        long val;
         PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
-        if (!tmp) return (Py_intptr_t) -1;
-        val = __Pyx_PyInt_As_Py_intptr_t(tmp);
+        if (!tmp) return (long) -1;
+        val = __Pyx_PyInt_As_long(tmp);
         Py_DECREF(tmp);
         return val;
     }
 raise_overflow:
     PyErr_SetString(PyExc_OverflowError,
-        "value too large to convert to Py_intptr_t");
-    return (Py_intptr_t) -1;
+        "value too large to convert to long");
+    return (long) -1;
 raise_neg_overflow:
     PyErr_SetString(PyExc_OverflowError,
-        "can't convert negative value to Py_intptr_t");
-    return (Py_intptr_t) -1;
+        "can't convert negative value to long");
+    return (long) -1;
 }
 
 /* CIntFromPy */
-  static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *x) {
+  static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *x) {
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wconversion"
 #endif
-    const long neg_one = (long) -1, const_zero = (long) 0;
+    const int neg_one = (int) -1, const_zero = (int) 0;
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic pop
 #endif
     const int is_unsigned = neg_one > const_zero;
 #if PY_MAJOR_VERSION < 3
     if (likely(PyInt_Check(x))) {
-        if (sizeof(long) < sizeof(long)) {
-            __PYX_VERIFY_RETURN_INT(long, long, PyInt_AS_LONG(x))
+        if ((sizeof(int) < sizeof(long))) {
+            __PYX_VERIFY_RETURN_INT(int, long, PyInt_AS_LONG(x))
         } else {
             long val = PyInt_AS_LONG(x);
             if (is_unsigned && unlikely(val < 0)) {
                 goto raise_neg_overflow;
             }
-            return (long) val;
+            return (int) val;
         }
     } else
 #endif
     if (likely(PyLong_Check(x))) {
         if (is_unsigned) {
 #if CYTHON_USE_PYLONG_INTERNALS
-            const digit* digits = ((PyLongObject*)x)->ob_digit;
-            switch (Py_SIZE(x)) {
-                case  0: return (long) 0;
-                case  1: __PYX_VERIFY_RETURN_INT(long, digit, digits[0])
-                case 2:
-                    if (8 * sizeof(long) > 1 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(long) >= 2 * PyLong_SHIFT) {
-                            return (long) (((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
+            if (unlikely(__Pyx_PyLong_IsNeg(x))) {
+                goto raise_neg_overflow;
+            } else if (__Pyx_PyLong_IsCompact(x)) {
+                __PYX_VERIFY_RETURN_INT(int, __Pyx_compact_upylong, __Pyx_PyLong_CompactValueUnsigned(x))
+            } else {
+                const digit* digits = __Pyx_PyLong_Digits(x);
+                assert(__Pyx_PyLong_DigitCount(x) > 1);
+                switch (__Pyx_PyLong_DigitCount(x)) {
+                    case 2:
+                        if ((8 * sizeof(int) > 1 * PyLong_SHIFT)) {
+                            if ((8 * sizeof(unsigned long) > 2 * PyLong_SHIFT)) {
+                                __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                            } else if ((8 * sizeof(int) >= 2 * PyLong_SHIFT)) {
+                                return (int) (((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
+                            }
                         }
-                    }
-                    break;
-                case 3:
-                    if (8 * sizeof(long) > 2 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(long) >= 3 * PyLong_SHIFT) {
-                            return (long) (((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
+                        break;
+                    case 3:
+                        if ((8 * sizeof(int) > 2 * PyLong_SHIFT)) {
+                            if ((8 * sizeof(unsigned long) > 3 * PyLong_SHIFT)) {
+                                __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                            } else if ((8 * sizeof(int) >= 3 * PyLong_SHIFT)) {
+                                return (int) (((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
+                            }
                         }
-                    }
-                    break;
-                case 4:
-                    if (8 * sizeof(long) > 3 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(long) >= 4 * PyLong_SHIFT) {
-                            return (long) (((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
+                        break;
+                    case 4:
+                        if ((8 * sizeof(int) > 3 * PyLong_SHIFT)) {
+                            if ((8 * sizeof(unsigned long) > 4 * PyLong_SHIFT)) {
+                                __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                            } else if ((8 * sizeof(int) >= 4 * PyLong_SHIFT)) {
+                                return (int) (((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
+                            }
                         }
-                    }
-                    break;
+                        break;
+                }
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
-                    return (long) -1;
+                    return (int) -1;
                 if (unlikely(result == 1))
                     goto raise_neg_overflow;
             }
 #endif
-            if (sizeof(long) <= sizeof(unsigned long)) {
-                __PYX_VERIFY_RETURN_INT_EXC(long, unsigned long, PyLong_AsUnsignedLong(x))
+            if ((sizeof(int) <= sizeof(unsigned long))) {
+                __PYX_VERIFY_RETURN_INT_EXC(int, unsigned long, PyLong_AsUnsignedLong(x))
 #ifdef HAVE_LONG_LONG
-            } else if (sizeof(long) <= sizeof(unsigned PY_LONG_LONG)) {
-                __PYX_VERIFY_RETURN_INT_EXC(long, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
+            } else if ((sizeof(int) <= sizeof(unsigned PY_LONG_LONG))) {
+                __PYX_VERIFY_RETURN_INT_EXC(int, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
 #endif
             }
         } else {
 #if CYTHON_USE_PYLONG_INTERNALS
-            const digit* digits = ((PyLongObject*)x)->ob_digit;
-            switch (Py_SIZE(x)) {
-                case  0: return (long) 0;
-                case -1: __PYX_VERIFY_RETURN_INT(long, sdigit, (sdigit) (-(sdigit)digits[0]))
-                case  1: __PYX_VERIFY_RETURN_INT(long,  digit, +digits[0])
-                case -2:
-                    if (8 * sizeof(long) - 1 > 1 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
-                            return (long) (((long)-1)*(((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
+            if (__Pyx_PyLong_IsCompact(x)) {
+                __PYX_VERIFY_RETURN_INT(int, __Pyx_compact_pylong, __Pyx_PyLong_CompactValue(x))
+            } else {
+                const digit* digits = __Pyx_PyLong_Digits(x);
+                assert(__Pyx_PyLong_DigitCount(x) > 1);
+                switch (__Pyx_PyLong_SignedDigitCount(x)) {
+                    case -2:
+                        if ((8 * sizeof(int) - 1 > 1 * PyLong_SHIFT)) {
+                            if ((8 * sizeof(unsigned long) > 2 * PyLong_SHIFT)) {
+                                __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                            } else if ((8 * sizeof(int) - 1 > 2 * PyLong_SHIFT)) {
+                                return (int) (((int)-1)*(((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
+                            }
                         }
-                    }
-                    break;
-                case 2:
-                    if (8 * sizeof(long) > 1 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
-                            return (long) ((((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
+                        break;
+                    case 2:
+                        if ((8 * sizeof(int) > 1 * PyLong_SHIFT)) {
+                            if ((8 * sizeof(unsigned long) > 2 * PyLong_SHIFT)) {
+                                __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                            } else if ((8 * sizeof(int) - 1 > 2 * PyLong_SHIFT)) {
+                                return (int) ((((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
+                            }
                         }
-                    }
-                    break;
-                case -3:
-                    if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
-                            return (long) (((long)-1)*(((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
+                        break;
+                    case -3:
+                        if ((8 * sizeof(int) - 1 > 2 * PyLong_SHIFT)) {
+                            if ((8 * sizeof(unsigned long) > 3 * PyLong_SHIFT)) {
+                                __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                            } else if ((8 * sizeof(int) - 1 > 3 * PyLong_SHIFT)) {
+                                return (int) (((int)-1)*(((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
+                            }
                         }
-                    }
-                    break;
-                case 3:
-                    if (8 * sizeof(long) > 2 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
-                            return (long) ((((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
+                        break;
+                    case 3:
+                        if ((8 * sizeof(int) > 2 * PyLong_SHIFT)) {
+                            if ((8 * sizeof(unsigned long) > 3 * PyLong_SHIFT)) {
+                                __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                            } else if ((8 * sizeof(int) - 1 > 3 * PyLong_SHIFT)) {
+                                return (int) ((((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
+                            }
                         }
-                    }
-                    break;
-                case -4:
-                    if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
-                            return (long) (((long)-1)*(((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
+                        break;
+                    case -4:
+                        if ((8 * sizeof(int) - 1 > 3 * PyLong_SHIFT)) {
+                            if ((8 * sizeof(unsigned long) > 4 * PyLong_SHIFT)) {
+                                __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                            } else if ((8 * sizeof(int) - 1 > 4 * PyLong_SHIFT)) {
+                                return (int) (((int)-1)*(((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
+                            }
                         }
-                    }
-                    break;
-                case 4:
-                    if (8 * sizeof(long) > 3 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
-                            return (long) ((((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
+                        break;
+                    case 4:
+                        if ((8 * sizeof(int) > 3 * PyLong_SHIFT)) {
+                            if ((8 * sizeof(unsigned long) > 4 * PyLong_SHIFT)) {
+                                __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                            } else if ((8 * sizeof(int) - 1 > 4 * PyLong_SHIFT)) {
+                                return (int) ((((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
+                            }
                         }
-                    }
-                    break;
+                        break;
+                }
             }
 #endif
-            if (sizeof(long) <= sizeof(long)) {
-                __PYX_VERIFY_RETURN_INT_EXC(long, long, PyLong_AsLong(x))
+            if ((sizeof(int) <= sizeof(long))) {
+                __PYX_VERIFY_RETURN_INT_EXC(int, long, PyLong_AsLong(x))
 #ifdef HAVE_LONG_LONG
-            } else if (sizeof(long) <= sizeof(PY_LONG_LONG)) {
-                __PYX_VERIFY_RETURN_INT_EXC(long, PY_LONG_LONG, PyLong_AsLongLong(x))
+            } else if ((sizeof(int) <= sizeof(PY_LONG_LONG))) {
+                __PYX_VERIFY_RETURN_INT_EXC(int, PY_LONG_LONG, PyLong_AsLongLong(x))
 #endif
             }
         }
         {
-#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
-            PyErr_SetString(PyExc_RuntimeError,
-                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
-#else
-            long val;
+            int val;
             PyObject *v = __Pyx_PyNumber_IntOrLong(x);
- #if PY_MAJOR_VERSION < 3
+#if PY_MAJOR_VERSION < 3
             if (likely(v) && !PyLong_Check(v)) {
                 PyObject *tmp = v;
                 v = PyNumber_Long(tmp);
                 Py_DECREF(tmp);
             }
- #endif
+#endif
             if (likely(v)) {
+                int ret = -1;
+#if PY_VERSION_HEX < 0x030d0000 && !(CYTHON_COMPILING_IN_PYPY || CYTHON_COMPILING_IN_LIMITED_API) || defined(_PyLong_AsByteArray)
                 int one = 1; int is_little = (int)*(unsigned char *)&one;
                 unsigned char *bytes = (unsigned char *)&val;
-                int ret = _PyLong_AsByteArray((PyLongObject *)v,
-                                              bytes, sizeof(val),
-                                              is_little, !is_unsigned);
+                ret = _PyLong_AsByteArray((PyLongObject *)v,
+                                           bytes, sizeof(val),
+                                           is_little, !is_unsigned);
+#else
+                PyObject *stepval = NULL, *mask = NULL, *shift = NULL;
+                int bits, remaining_bits, is_negative = 0;
+                long idigit;
+                int chunk_size = (sizeof(long) < 8) ? 30 : 62;
+                if (unlikely(!PyLong_CheckExact(v))) {
+                    PyObject *tmp = v;
+                    v = PyNumber_Long(v);
+                    assert(PyLong_CheckExact(v));
+                    Py_DECREF(tmp);
+                    if (unlikely(!v)) return (int) -1;
+                }
+#if CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030B0000
+                if (Py_SIZE(x) == 0)
+                    return (int) 0;
+                is_negative = Py_SIZE(x) < 0;
+#else
+                {
+                    int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
+                    if (unlikely(result < 0))
+                        return (int) -1;
+                    is_negative = result == 1;
+                }
+#endif
+                if (is_unsigned && unlikely(is_negative)) {
+                    goto raise_neg_overflow;
+                } else if (is_negative) {
+                    stepval = PyNumber_Invert(v);
+                    if (unlikely(!stepval))
+                        return (int) -1;
+                } else {
+                    stepval = __Pyx_NewRef(v);
+                }
+                val = (int) 0;
+                mask = PyLong_FromLong((1L << chunk_size) - 1); if (unlikely(!mask)) goto done;
+                shift = PyLong_FromLong(chunk_size); if (unlikely(!shift)) goto done;
+                for (bits = 0; bits < (int) sizeof(int) * 8 - chunk_size; bits += chunk_size) {
+                    PyObject *tmp, *digit;
+                    digit = PyNumber_And(stepval, mask);
+                    if (unlikely(!digit)) goto done;
+                    idigit = PyLong_AsLong(digit);
+                    Py_DECREF(digit);
+                    if (unlikely(idigit < 0)) goto done;
+                    tmp = PyNumber_Rshift(stepval, shift);
+                    if (unlikely(!tmp)) goto done;
+                    Py_DECREF(stepval); stepval = tmp;
+                    val |= ((int) idigit) << bits;
+                    #if CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030B0000
+                    if (Py_SIZE(stepval) == 0)
+                        goto unpacking_done;
+                    #endif
+                }
+                idigit = PyLong_AsLong(stepval);
+                if (unlikely(idigit < 0)) goto done;
+                remaining_bits = ((int) sizeof(int) * 8) - bits - (is_unsigned ? 0 : 1);
+                if (unlikely(idigit >= (1L << remaining_bits)))
+                    goto raise_overflow;
+                val |= ((int) idigit) << bits;
+            #if CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030B0000
+            unpacking_done:
+            #endif
+                if (!is_unsigned) {
+                    if (unlikely(val & (((int) 1) << (sizeof(int) * 8 - 1))))
+                        goto raise_overflow;
+                    if (is_negative)
+                        val = ~val;
+                }
+                ret = 0;
+            done:
+                Py_XDECREF(shift);
+                Py_XDECREF(mask);
+                Py_XDECREF(stepval);
+#endif
                 Py_DECREF(v);
                 if (likely(!ret))
                     return val;
             }
-#endif
-            return (long) -1;
+            return (int) -1;
         }
     } else {
-        long val;
+        int val;
         PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
-        if (!tmp) return (long) -1;
-        val = __Pyx_PyInt_As_long(tmp);
+        if (!tmp) return (int) -1;
+        val = __Pyx_PyInt_As_int(tmp);
         Py_DECREF(tmp);
         return val;
     }
 raise_overflow:
     PyErr_SetString(PyExc_OverflowError,
-        "value too large to convert to long");
-    return (long) -1;
+        "value too large to convert to int");
+    return (int) -1;
 raise_neg_overflow:
     PyErr_SetString(PyExc_OverflowError,
-        "can't convert negative value to long");
-    return (long) -1;
+        "can't convert negative value to int");
+    return (int) -1;
 }
 
 /* FastTypeChecks */
   #if CYTHON_COMPILING_IN_CPYTHON
 static int __Pyx_InBases(PyTypeObject *a, PyTypeObject *b) {
     while (a) {
-        a = a->tp_base;
+        a = __Pyx_PyType_GetSlot(a, tp_base, PyTypeObject*);
         if (a == b)
             return 1;
     }
     return b == &PyBaseObject_Type;
 }
 static CYTHON_INLINE int __Pyx_IsSubtype(PyTypeObject *a, PyTypeObject *b) {
     PyObject *mro;
@@ -10028,14 +11662,30 @@
             if (PyTuple_GET_ITEM(mro, i) == (PyObject *)b)
                 return 1;
         }
         return 0;
     }
     return __Pyx_InBases(a, b);
 }
+static CYTHON_INLINE int __Pyx_IsAnySubtype2(PyTypeObject *cls, PyTypeObject *a, PyTypeObject *b) {
+    PyObject *mro;
+    if (cls == a || cls == b) return 1;
+    mro = cls->tp_mro;
+    if (likely(mro)) {
+        Py_ssize_t i, n;
+        n = PyTuple_GET_SIZE(mro);
+        for (i = 0; i < n; i++) {
+            PyObject *base = PyTuple_GET_ITEM(mro, i);
+            if (base == (PyObject *)a || base == (PyObject *)b)
+                return 1;
+        }
+        return 0;
+    }
+    return __Pyx_InBases(cls, a) || __Pyx_InBases(cls, b);
+}
 #if PY_MAJOR_VERSION == 2
 static int __Pyx_inner_PyErr_GivenExceptionMatches2(PyObject *err, PyObject* exc_type1, PyObject* exc_type2) {
     PyObject *exception, *value, *tb;
     int res;
     __Pyx_PyThreadState_declare
     __Pyx_PyThreadState_assign
     __Pyx_ErrFetch(&exception, &value, &tb);
@@ -10052,19 +11702,19 @@
         }
     }
     __Pyx_ErrRestore(exception, value, tb);
     return res;
 }
 #else
 static CYTHON_INLINE int __Pyx_inner_PyErr_GivenExceptionMatches2(PyObject *err, PyObject* exc_type1, PyObject *exc_type2) {
-    int res = exc_type1 ? __Pyx_IsSubtype((PyTypeObject*)err, (PyTypeObject*)exc_type1) : 0;
-    if (!res) {
-        res = __Pyx_IsSubtype((PyTypeObject*)err, (PyTypeObject*)exc_type2);
+    if (exc_type1) {
+        return __Pyx_IsAnySubtype2((PyTypeObject*)err, (PyTypeObject*)exc_type1, (PyTypeObject*)exc_type2);
+    } else {
+        return __Pyx_IsSubtype((PyTypeObject*)err, (PyTypeObject*)exc_type2);
     }
-    return res;
 }
 #endif
 static int __Pyx_PyErr_GivenExceptionMatchesTuple(PyObject *exc_type, PyObject *tuple) {
     Py_ssize_t i, n;
     assert(PyExceptionClass_Check(exc_type));
     n = PyTuple_GET_SIZE(tuple);
 #if PY_MAJOR_VERSION >= 3
@@ -10104,86 +11754,121 @@
         return __Pyx_inner_PyErr_GivenExceptionMatches2(err, exc_type1, exc_type2);
     }
     return (PyErr_GivenExceptionMatches(err, exc_type1) || PyErr_GivenExceptionMatches(err, exc_type2));
 }
 #endif
 
 /* CheckBinaryVersion */
-  static int __Pyx_check_binary_version(void) {
-    char ctversion[5];
-    int same=1, i, found_dot;
-    const char* rt_from_call = Py_GetVersion();
-    PyOS_snprintf(ctversion, 5, "%d.%d", PY_MAJOR_VERSION, PY_MINOR_VERSION);
-    found_dot = 0;
-    for (i = 0; i < 4; i++) {
-        if (!ctversion[i]) {
-            same = (rt_from_call[i] < '0' || rt_from_call[i] > '9');
-            break;
+  static unsigned long __Pyx_get_runtime_version(void) {
+#if __PYX_LIMITED_VERSION_HEX >= 0x030B00A4
+    return Py_Version & ~0xFFUL;
+#else
+    const char* rt_version = Py_GetVersion();
+    unsigned long version = 0;
+    unsigned long factor = 0x01000000UL;
+    unsigned int digit = 0;
+    int i = 0;
+    while (factor) {
+        while ('0' <= rt_version[i] && rt_version[i] <= '9') {
+            digit = digit * 10 + (unsigned int) (rt_version[i] - '0');
+            ++i;
         }
-        if (rt_from_call[i] != ctversion[i]) {
-            same = 0;
+        version += factor * digit;
+        if (rt_version[i] != '.')
             break;
-        }
+        digit = 0;
+        factor >>= 8;
+        ++i;
     }
-    if (!same) {
-        char rtversion[5] = {'\0'};
+    return version;
+#endif
+}
+static int __Pyx_check_binary_version(unsigned long ct_version, unsigned long rt_version, int allow_newer) {
+    const unsigned long MAJOR_MINOR = 0xFFFF0000UL;
+    if ((rt_version & MAJOR_MINOR) == (ct_version & MAJOR_MINOR))
+        return 0;
+    if (likely(allow_newer && (rt_version & MAJOR_MINOR) > (ct_version & MAJOR_MINOR)))
+        return 1;
+    {
         char message[200];
-        for (i=0; i<4; ++i) {
-            if (rt_from_call[i] == '.') {
-                if (found_dot) break;
-                found_dot = 1;
-            } else if (rt_from_call[i] < '0' || rt_from_call[i] > '9') {
-                break;
-            }
-            rtversion[i] = rt_from_call[i];
-        }
         PyOS_snprintf(message, sizeof(message),
-                      "compiletime version %s of module '%.100s' "
-                      "does not match runtime version %s",
-                      ctversion, __Pyx_MODULE_NAME, rtversion);
+                      "compile time Python version %d.%d "
+                      "of module '%.100s' "
+                      "%s "
+                      "runtime version %d.%d",
+                       (int) (ct_version >> 24), (int) ((ct_version >> 16) & 0xFF),
+                       __Pyx_MODULE_NAME,
+                       (allow_newer) ? "was newer than" : "does not match",
+                       (int) (rt_version >> 24), (int) ((rt_version >> 16) & 0xFF)
+       );
         return PyErr_WarnEx(NULL, message, 1);
     }
-    return 0;
 }
 
 /* InitStrings */
-  static int __Pyx_InitStrings(__Pyx_StringTabEntry *t) {
+  #if PY_MAJOR_VERSION >= 3
+static int __Pyx_InitString(__Pyx_StringTabEntry t, PyObject **str) {
+    if (t.is_unicode | t.is_str) {
+        if (t.intern) {
+            *str = PyUnicode_InternFromString(t.s);
+        } else if (t.encoding) {
+            *str = PyUnicode_Decode(t.s, t.n - 1, t.encoding, NULL);
+        } else {
+            *str = PyUnicode_FromStringAndSize(t.s, t.n - 1);
+        }
+    } else {
+        *str = PyBytes_FromStringAndSize(t.s, t.n - 1);
+    }
+    if (!*str)
+        return -1;
+    if (PyObject_Hash(*str) == -1)
+        return -1;
+    return 0;
+}
+#endif
+static int __Pyx_InitStrings(__Pyx_StringTabEntry *t) {
     while (t->p) {
-        #if PY_MAJOR_VERSION < 3
+        #if PY_MAJOR_VERSION >= 3
+        __Pyx_InitString(*t, t->p);
+        #else
         if (t->is_unicode) {
             *t->p = PyUnicode_DecodeUTF8(t->s, t->n - 1, NULL);
         } else if (t->intern) {
             *t->p = PyString_InternFromString(t->s);
         } else {
             *t->p = PyString_FromStringAndSize(t->s, t->n - 1);
         }
-        #else
-        if (t->is_unicode | t->is_str) {
-            if (t->intern) {
-                *t->p = PyUnicode_InternFromString(t->s);
-            } else if (t->encoding) {
-                *t->p = PyUnicode_Decode(t->s, t->n - 1, t->encoding, NULL);
-            } else {
-                *t->p = PyUnicode_FromStringAndSize(t->s, t->n - 1);
-            }
-        } else {
-            *t->p = PyBytes_FromStringAndSize(t->s, t->n - 1);
-        }
-        #endif
         if (!*t->p)
             return -1;
         if (PyObject_Hash(*t->p) == -1)
             return -1;
+        #endif
         ++t;
     }
     return 0;
 }
 
+#include <string.h>
+static CYTHON_INLINE Py_ssize_t __Pyx_ssize_strlen(const char *s) {
+    size_t len = strlen(s);
+    if (unlikely(len > (size_t) PY_SSIZE_T_MAX)) {
+        PyErr_SetString(PyExc_OverflowError, "byte string is too long");
+        return -1;
+    }
+    return (Py_ssize_t) len;
+}
 static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(const char* c_str) {
-    return __Pyx_PyUnicode_FromStringAndSize(c_str, (Py_ssize_t)strlen(c_str));
+    Py_ssize_t len = __Pyx_ssize_strlen(c_str);
+    if (unlikely(len < 0)) return NULL;
+    return __Pyx_PyUnicode_FromStringAndSize(c_str, len);
+}
+static CYTHON_INLINE PyObject* __Pyx_PyByteArray_FromString(const char* c_str) {
+    Py_ssize_t len = __Pyx_ssize_strlen(c_str);
+    if (unlikely(len < 0)) return NULL;
+    return PyByteArray_FromStringAndSize(c_str, len);
 }
 static CYTHON_INLINE const char* __Pyx_PyObject_AsString(PyObject* o) {
     Py_ssize_t ignore;
     return __Pyx_PyObject_AsStringAndSize(o, &ignore);
 }
 #if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
 #if !CYTHON_PEP393_ENABLED
@@ -10230,15 +11915,15 @@
 #if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
             __Pyx_sys_getdefaultencoding_not_ascii &&
 #endif
             PyUnicode_Check(o)) {
         return __Pyx_PyUnicode_AsStringAndSize(o, length);
     } else
 #endif
-#if (!CYTHON_COMPILING_IN_PYPY) || (defined(PyByteArray_AS_STRING) && defined(PyByteArray_GET_SIZE))
+#if (!CYTHON_COMPILING_IN_PYPY && !CYTHON_COMPILING_IN_LIMITED_API) || (defined(PyByteArray_AS_STRING) && defined(PyByteArray_GET_SIZE))
     if (PyByteArray_Check(o)) {
         *length = PyByteArray_GET_SIZE(o);
         return PyByteArray_AS_STRING(o);
     } else
 #endif
     {
         char* result;
@@ -10259,30 +11944,34 @@
     int retval;
     if (unlikely(!x)) return -1;
     retval = __Pyx_PyObject_IsTrue(x);
     Py_DECREF(x);
     return retval;
 }
 static PyObject* __Pyx_PyNumber_IntOrLongWrongResultType(PyObject* result, const char* type_name) {
+    __Pyx_TypeName result_type_name = __Pyx_PyType_GetName(Py_TYPE(result));
 #if PY_MAJOR_VERSION >= 3
     if (PyLong_Check(result)) {
         if (PyErr_WarnFormat(PyExc_DeprecationWarning, 1,
-                "__int__ returned non-int (type %.200s).  "
-                "The ability to return an instance of a strict subclass of int "
-                "is deprecated, and may be removed in a future version of Python.",
-                Py_TYPE(result)->tp_name)) {
+                "__int__ returned non-int (type " __Pyx_FMT_TYPENAME ").  "
+                "The ability to return an instance of a strict subclass of int is deprecated, "
+                "and may be removed in a future version of Python.",
+                result_type_name)) {
+            __Pyx_DECREF_TypeName(result_type_name);
             Py_DECREF(result);
             return NULL;
         }
+        __Pyx_DECREF_TypeName(result_type_name);
         return result;
     }
 #endif
     PyErr_Format(PyExc_TypeError,
-                 "__%.4s__ returned non-%.4s (type %.200s)",
-                 type_name, type_name, Py_TYPE(result)->tp_name);
+                 "__%.4s__ returned non-%.4s (type " __Pyx_FMT_TYPENAME ")",
+                 type_name, type_name, result_type_name);
+    __Pyx_DECREF_TypeName(result_type_name);
     Py_DECREF(result);
     return NULL;
 }
 static CYTHON_INLINE PyObject* __Pyx_PyNumber_IntOrLong(PyObject* x) {
 #if CYTHON_USE_TYPE_SLOTS
   PyNumberMethods *m;
 #endif
@@ -10340,21 +12029,19 @@
         return PyInt_AS_LONG(b);
     else
         return PyInt_AsSsize_t(b);
   }
 #endif
   if (likely(PyLong_CheckExact(b))) {
     #if CYTHON_USE_PYLONG_INTERNALS
-    const digit* digits = ((PyLongObject*)b)->ob_digit;
-    const Py_ssize_t size = Py_SIZE(b);
-    if (likely(__Pyx_sst_abs(size) <= 1)) {
-        ival = likely(size) ? digits[0] : 0;
-        if (size == -1) ival = -ival;
-        return ival;
+    if (likely(__Pyx_PyLong_IsCompact(b))) {
+        return __Pyx_PyLong_CompactValue(b);
     } else {
+      const digit* digits = __Pyx_PyLong_Digits(b);
+      const Py_ssize_t size = __Pyx_PyLong_SignedDigitCount(b);
       switch (size) {
          case 2:
            if (8 * sizeof(Py_ssize_t) > 2 * PyLong_SHIFT) {
              return (Py_ssize_t) (((((size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
            }
            break;
          case -2:
@@ -10414,8 +12101,16 @@
   return b ? __Pyx_NewRef(Py_True) : __Pyx_NewRef(Py_False);
 }
 static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t ival) {
     return PyInt_FromSize_t(ival);
 }
 
 
+/* #### Code section: utility_code_pragmas_end ### */
+#ifdef _MSC_VER
+#pragma warning( pop )
+#endif
+
+
+
+/* #### Code section: end ### */
 #endif /* Py_PYTHON_H */
```

### Comparing `argos_toolkit-0.1.3.post3/argos/cutility.pyx` & `argos_toolkit-0.2.0/argos/cutility.pyx`

 * *Files 5% similar despite different names*

```diff
@@ -28,52 +28,52 @@
     w = max(x) - xleft
     ytop = min(y)
     h = max(y) - ytop
     return np.array((xleft, ytop, w, h))
 
 @cython.boundscheck(False)
 @cython.wraparound(False)
-cpdef np.ndarray[np.int_t, ndim=2] rect2points(
-    np.ndarray[np.int_t, ndim=1] rect):
+cpdef np.ndarray[int, ndim=2] rect2points(
+    np.ndarray[int, ndim=1] rect):
     """Convert topleft, width, height format rectangle into four anti-clockwise
     vertices"""
     return np.vstack([rect[:2],
                       (rect[0], rect[1] + rect[3]),
                       rect[:2] + rect[2:],
                       (rect[0] + rect[2], rect[1])])
 
 
 @cython.boundscheck(False) # turn off bounds-checking for entire function
 @cython.wraparound(False)  # turn off negative index wrapping for entire function
-cpdef np.ndarray[np.float_t, ndim=1] tlwh2xyrh(np.ndarray[np.int_t, ndim=1] rect):
+cpdef np.ndarray[np.float64_t, ndim=1] tlwh2xyrh(np.ndarray[int, ndim=1] rect):
     """Convert rectangle in top-left, width, height format into center, aspect ratio, height"""
-    cdef np.ndarray ret = np.asanyarray(rect, dtype=np.float)
+    cdef np.ndarray ret = np.asanyarray(rect, dtype=np.float64)
     ret[0] += ret[2] * 0.5
     ret[1] += ret[3] * 0.5
     # ret[:2] += ret[2:] * 0.5
     ret[2] /= ret[3]
     return ret
 
 
 @cython.boundscheck(False) # turn off bounds-checking for entire function
 @cython.wraparound(False)  # turn off negative index wrapping for entire function
-cpdef np.ndarray[np.int_t, ndim=1] xyrh2tlwh(np.ndarray[np.float_t, ndim=1] rect):
+cpdef np.ndarray[int, ndim=1] xyrh2tlwh(np.ndarray[np.float64_t, ndim=1] rect):
     """Convert centre, aspect ratio, height into top-left, width, height
     format"""
-    cdef float w = rect[2] * rect[3]
+    cdef np.float64_t w = rect[2] * rect[3]
     cdef np.ndarray ret = np.asanyarray((round(rect[0] - w / 2.0),
                                          round(rect[1] - rect[3] / 2.0),
                                          round(w), round(rect[3])),
                                         dtype=int)
     return ret
 
 
 @cython.boundscheck(False) # turn off bounds-checking for entire function
 @cython.wraparound(False)  # turn off negative index wrapping for entire function
-cpdef np.ndarray[np.int_t, ndim=1] rect_intersection(np.ndarray[np.int_t, ndim=1] ra, np.ndarray[np.int_t, ndim=1] rb):
+cpdef np.ndarray[int, ndim=1] rect_intersection(np.ndarray[int, ndim=1] ra, np.ndarray[int, ndim=1] rb):
     """Find if two axis-aligned rectangles intersect.
 
     This runs almost 50 times faster than Polygon intersection in shapely.
     and ~5 times faster than cv2.intersectConvexConvex.
 
     Parameters
     ----------
@@ -85,30 +85,30 @@
     Returns
     -------
     np.ndarray
         (x, y, dx, dy) specifying the overlap rectangle. If there is no
         overlap, all entries are 0.
     """
     cdef int x, y, dx, dy
-    cdef np.ndarray result = np.zeros((4,), dtype=np.int)
+    cdef np.ndarray result = np.zeros((4,), dtype=int)
     x = int(max(ra[0], rb[0]))
     y = int(max(ra[1], rb[1]))
     dx = int(min(ra[0] + ra[2], rb[0] + rb[2]) - x)
     dy = int(min(ra[1] + ra[3], rb[1] + rb[3]) - y)
     if (dx > 0) and (dy > 0):
         result[0] = x
         result[1] = y
         result[2] = dx
         result[3] = dy
     return result
 
 
 @cython.boundscheck(False) # turn off bounds-checking for entire function
 @cython.wraparound(False)  # turn off negative index wrapping for entire function
-cpdef float rect_iou(np.ndarray[np.int_t, ndim=1] ra, np.ndarray[np.int_t, ndim=1] rb):
+cpdef np.float64_t rect_iou(np.ndarray[int, ndim=1] ra, np.ndarray[int, ndim=1] rb):
     """Compute Intersection over Union of two axis-aligned rectangles.
 
     This is the ratio of the are of intersection to the area of the union
     of the two rectangles.
 
     Parameters
     ----------
@@ -119,29 +119,29 @@
 
     Returns
     -------
     float
         The Intersection over Union of two rectangles.
     """
     cdef np.ndarray inter = rect_intersection(ra, rb)
-    cdef float area_i, area_u
-    cdef float ret
+    cdef np.float64_t area_i, area_u
+    cdef np.float64_t ret
     area_i = inter[2] * inter[3]
     area_u = ra[2] * ra[3] + rb[2] * rb[3] - area_i
     if area_u <= 0 or area_i < 0:
         raise ValueError('Area not positive')
     ret = 1.0 * area_i / area_u
     if np.isinf(ret) or np.isnan(ret) or ret < 0:
         raise ValueError('Invalid intersection')
     return ret
 
 
 @cython.boundscheck(False) # turn off bounds-checking for entire function
 @cython.wraparound(False)  # turn off negative index wrapping for entire function
-cpdef float rect_ios(np.ndarray[np.int_t, ndim=1] ra, np.ndarray[np.int_t, ndim=1] rb):
+cpdef np.float64_t rect_ios(np.ndarray[int, ndim=1] ra, np.ndarray[int, ndim=1] rb):
     """Compute intersection over area of smaller of two axis-aligned
     rectangles.
 
     This is the ratio of the are of intersection to the area of the smaller
     of the two rectangles.
 
     Parameters
@@ -153,28 +153,28 @@
 
     Returns
     -------
     float
         The Intersection over area of the smaller of two rectangles.
     """
     cdef np.ndarray inter = rect_intersection(ra, rb)
-    cdef float area_i = inter[2] *inter[3]
-    cdef float area_a = ra[2] * ra[3]
-    cdef float area_b = rb[2] * rb[3]
+    cdef np.float64_t area_i = inter[2] *inter[3]
+    cdef np.float64_t area_a = ra[2] * ra[3]
+    cdef np.float64_t area_b = rb[2] * rb[3]
     if area_i < 0 or area_a <= 0 or area_b <= 0:
         raise ValueError('Area not positive')
-    cdef float ret = area_i / min(area_a, area_b)
+    cdef np.float64_t ret = area_i / min(area_a, area_b)
     if np.isinf(ret) or np.isnan(ret) or ret < 0:
         raise ValueError('Invalid intersection')
     return ret
 
 
 # @cython.boundscheck(False) # turn off bounds-checking for entire function
 @cython.wraparound(False)  # turn off negative index wrapping for entire function
-cpdef np.ndarray[np.float_t, ndim=2] pairwise_distance(np.ndarray[np.int_t, ndim=2] new_bboxes, np.ndarray[np.int_t, ndim=2] bboxes,
+cpdef np.ndarray[np.float64_t, ndim=2] pairwise_distance(np.ndarray[int, ndim=2] new_bboxes, np.ndarray[int, ndim=2] bboxes,
                       object boxtype, object metric):
     """Takes two lists of boxes and computes the distance between every possible
     pair.
 
     Parameters
     ----------
     new_bboxes: np.ndarray
@@ -191,17 +191,17 @@
     Returns
     --------
     np.ndarray
         row ``ii``, column ``jj`` contains the computed distance `between
         ``new_bboxes[ii]`` and ``bboxes[jj]``.
      """
     cdef np.ndarray dist = np.zeros((new_bboxes.shape[0], bboxes.shape[0]),
-                                    dtype=np.float)
-    cdef np.ndarray centers = np.zeros((bboxes.shape[0], 2), dtype=np.float)
-    cdef np.ndarray new_centers = np.zeros((new_bboxes.shape[0], 2), dtype=np.float)
+                                    dtype=np.float64)
+    cdef np.ndarray centers = np.zeros((bboxes.shape[0], 2), dtype=np.float64)
+    cdef np.ndarray new_centers = np.zeros((new_bboxes.shape[0], 2), dtype=np.float64)
     if metric == DistanceMetric.euclidean:
         centers[:, :] = bboxes[:, :2] + bboxes[:, 2:] * 0.5
         new_centers = new_bboxes[:, :2] + new_bboxes[:, 2:] * 0.5
         for ii in range(new_bboxes.shape[0]):
             for jj in range(bboxes.shape[0]):
                 dist[ii, jj] = np.sum((new_centers[ii] - centers[jj]) ** 2)
     elif metric == DistanceMetric.iou:
```

### Comparing `argos_toolkit-0.1.3.post3/argos/extract_frames.py` & `argos_toolkit-0.2.0/argos/extract_frames.py`

 * *Files identical despite different names*

### Comparing `argos_toolkit-0.1.3.post3/argos/frameview.py` & `argos_toolkit-0.2.0/argos/frameview.py`

 * *Files identical despite different names*

### Comparing `argos_toolkit-0.1.3.post3/argos/limitswidget.py` & `argos_toolkit-0.2.0/argos/limitswidget.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,26 +1,16 @@
 # -*- coding: utf-8 -*-
 # Author: Subhasis Ray <ray dot subhasis at gmail dot com>
 # Created: 2020-08-11 9:20 PM
 """Widget to apply size constraints and ROI to filter segmented objects"""
-from typing import List, Tuple
 import logging
-from collections import OrderedDict
 import numpy as np
-import cv2
-from sklearn import cluster
-from PyQt5 import (
-    QtWidgets as qw,
-    QtCore as qc,
-    QtGui as qg
-)
+from PyQt5 import QtWidgets as qw, QtCore as qc, QtGui as qg
 
-import argos.constants as const
 from argos import utility as ut
-from argos.frameview import FrameView
 
 settings = ut.init()
 
 
 class LimitsWidget(qw.QWidget):
     sigProcessed = qc.pyqtSignal(np.ndarray, int)
     sigQuit = qc.pyqtSignal()
@@ -89,29 +79,32 @@
 
     @qc.pyqtSlot()
     def resetRoi(self):
         self.roi = None
 
     @qc.pyqtSlot(np.ndarray, int)
     def process(self, bboxes: np.ndarray, pos: int) -> None:
-        logging.debug(bboxes.shape)
+        logging.debug(f'Received bboxes: {bboxes.shape}, pos: {pos}')
         if len(bboxes) == 0:
             self.sigProcessed.emit(bboxes.copy(), pos)
             return
         wh = np.sort(bboxes[:, 2:], axis=1)
-        valid = bboxes[(wh[:, 0] >= self._wmin_edit.value()) &
-                       (wh[:, 0] <= self._wmax_edit.value()) &
-                       (wh[:, 1] >= self._hmin_edit.value()) &
-                       (wh[:, 1] <= self._hmax_edit.value())]
+        min_wide = wh[:, 0] >= self._wmin_edit.value()
+        max_wide = wh[:, 0] <= self._wmax_edit.value()
+        min_high = wh[:, 1] >= self._hmin_edit.value()
+        max_high = wh[:, 1] <= self._hmax_edit.value()
+        fit = min_wide & max_wide & min_high & max_high
+        valid = bboxes[fit]
+        logging.debug(f'Sending bboxes: {len(valid)}')
         if self.roi is None:
             self.sigProcessed.emit(valid.copy(), pos)
             return
         vidx = []
         for ii in range(valid.shape[0]):
             vertices = ut.rect2points(valid[ii, :])
-            contained = [self.roi.containsPoint(qc.QPointF(*vtx),
-                                                qc.Qt.OddEvenFill)
-                         for vtx in vertices]
+            contained = [
+                self.roi.containsPoint(qc.QPointF(*vtx), qc.Qt.OddEvenFill)
+                for vtx in vertices
+            ]
             if np.any(contained):
                 vidx.append(ii)
         self.sigProcessed.emit(valid[vidx].copy(), pos)
-
```

### Comparing `argos_toolkit-0.1.3.post3/argos/plot_tracks.py` & `argos_toolkit-0.2.0/argos/plot_tracks.py`

 * *Files identical despite different names*

### Comparing `argos_toolkit-0.1.3.post3/argos/plotutil.py` & `argos_toolkit-0.2.0/argos/plotutil.py`

 * *Files identical despite different names*

### Comparing `argos_toolkit-0.1.3.post3/argos/review.py` & `argos_toolkit-0.2.0/argos/review.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,12 +1,11 @@
 # -*- coding: utf-8 -*-
 # Author: Subhasis Ray <ray dot subhasis at gmail dot com>
 # Created: 2020-07-09 1:20 PM
-"""
-=========================
+"""=========================
 Review and correct tracks
 =========================
 Usage:
 ::
     python -m argos.review
 
 
@@ -206,14 +205,22 @@
 pressing ``Ctrl + Down Arrow``. The maximum speed is limited by the
 time needed to read and display a frame.
 
 Instead of going through the entire video, you can jump to the next
 frame where a new trackid was introduced, press ``N`` key (``Jump to
 next new track``).
 
+Sometimes tracking algorithms can mix up the identities of two
+animals, and this will appear as a sudden jump in the position in the
+frame where their ids were swapped. To check these, you can use
+``Ctrl+N`` to go to the next jump in position, and ``Ctrl+P`` for the
+previous jump. The threshold for the jump can be set in ``Diff
+settings`` menu, using the ``Set displacement threshold to flag
+jumps``.
+
 You can jump forward 10 frames by pressing ``Ctrl + PgDn`` and
 backward by pressing ``Ctrl + PgUp`` on the keyboard.
 
 To jump to a specific frame number, press ``G`` (``Go to frame``)
 and enter the frame number in the dialog box that pops up.
 
 To remember the current location (frame number) in the video, you can
@@ -415,45 +422,38 @@
 designed for playing sequentially, and jumping back and forth (``seek``)
 by arbitrary number of frames is not easy.
 
 With such videos, attempt to jump frames will result in error, and the
 review tool will disable ``seek`` when it detects this. To enable seek
 when the video format permits it, uncheck the ``Disable seek`` item
 in the ``Play`` menu.
+
 """
 
 import sys
 import os
-import csv
-import time
-from typing import List, Dict
 import logging
 import threading
 from collections import OrderedDict
 import numpy as np
-from datetime import datetime
 import cv2
-import pandas as pd
 from sortedcontainers import SortedKeyList
 from PyQt5 import QtWidgets as qw, QtCore as qc, QtGui as qg
 
 from argos.constants import (
-    Change,
-    ChangeCode,
     change_name,
-    ColorMode,
     STYLE_SHEETS,
 )
 from argos import utility as ut
-from argos.utility import make_color, get_cmap_color, rect2points
-from argos.frameview import FrameScene, FrameView
 from argos.vreader import VideoReader
 from argos.limitswidget import LimitsWidget
 from argos.vwidget import VidInfo
-
+from argos.tracklist import TrackList
+from argos.trackreader import TrackReader
+from argos.trackview import TrackView
 
 settings = ut.init()
 
 
 def displayAbout():
     msgBox = qw.QMessageBox()
     msgBox.setWindowTitle('About Argos Review tool')
@@ -474,732 +474,55 @@
 
 
 def displayDoc():
     DOC_LINK = 'https://argos.readthedocs.io/en/latest/'
     qg.QDesktopServices.openUrl(qc.QUrl(DOC_LINK))
 
 
-class TrackReader(qc.QObject):
-    """Class to read the tracking data.
-
-    It also keeps a list of changes made by the user and applies them
-    before handing over the track information.
-
-    """
-
-    sigEnd = qc.pyqtSignal()
-    sigSavedFrames = qc.pyqtSignal(int)
-    sigChangeList = qc.pyqtSignal(SortedKeyList)
-
-    def __init__(self, data_file):
-        super(TrackReader, self).__init__()
-        self.data_path = data_file
-        if data_file.endswith('.hdf') or data_file.endswith('.h5'):
-            self.track_data = pd.read_hdf(self.data_path, 'tracked')
-        else:  # assume text file
-            has_header = False
-            col_count = -1
-            # MOT format
-            names = [
-                'frame',
-                'trackid',
-                'x',
-                'y',
-                'w',
-                'h',
-                'confidence',
-                'xc',
-                'yc',
-                'zc',
-            ]
-            with open(self.data_path, 'r') as fd:
-                reader = csv.reader(fd)
-                row = reader.__next__()
-                col_count = len(row)
-                try:
-                    _ = float(row[0])
-                    has_header = False
-                except ValueError:
-                    has_header = True
-
-                if has_header:
-                    self.track_data = pd.read_csv(self.data_path)
-                else:
-                    names = names[:col_count]
-                    self.track_data = pd.read_csv(self.data_path, names=names)
-
-        self.track_data = self.track_data.astype(
-            {'frame': int, 'trackid': int}
-        )
-        self.last_frame = self.track_data.frame.max()
-        self.wmin = settings.value('segment/min_width', 0)
-        self.wmax = settings.value('segment/max_width', 1000)
-        self.hmin = settings.value('segment/min_height', 0)
-        self.hmax = settings.value('segment/max_height', 1000)
-
-        def keyfn(change):
-            return (change.frame, change.idx)
-
-        self.changeList = SortedKeyList(key=keyfn)
-        self._change_idx = 0
-        self.undone_changes = set()
-
-    @property
-    def max_id(self):
-        return self.track_data.trackid.max()
-
-    @qc.pyqtSlot(int)
-    def setWmin(self, val: int):
-        self.wmin = val
-
-    @qc.pyqtSlot(int)
-    def setWmax(self, val: int):
-        self.wmax = val
-
-    @qc.pyqtSlot(int)
-    def setHmin(self, val: int):
-        self.hmin = val
-
-    @qc.pyqtSlot(int)
-    def setHmax(self, val: int):
-        self.hmax = val
-
-    def getTrackId(self, track_id, frame_no=None, hist=10):
-        """Get all entries for a track across frames.
-
-        Parameters
-        ----------
-        frame_no: int, default None
-            If specified, only entries around this frame are
-            returned. If `None`, return all entries for this track.
-        hist: int, default 10
-            Number of past and future entries around `frame_no`
-            to select.
-
-        Returns
-        -------
-        pd.DataFrame
-            The data for track `track_id` for frames `frame_no` -
-            `hist` to `frame_no` + `hist`.
-
-            If `frame_no` is `None`, data for `track_id` across all frames.
-
-            `None` if no track matches the specified `track_id` in frame `frame_no`.
-
-        """
-        track = self.track_data[self.track_data.trackid == track_id].copy()
-        if frame_no is None:
-            return track
-        tgt = track[track.frame == frame_no]
-        if len(tgt) == 0:
-            return None
-        pos = track.index.get_loc(tgt.iloc[0].name)
-        pre = max(0, pos - hist)
-        post = min(len(track), pos + hist)
-        return track.iloc[pre:post].copy()
-
-    def getFramePrevNew(self, frame_no):
-        """Return the previous frame where a new object ID was detected"""
-        if frame_no <= 0:
-            return 0
-        entry_frame = []
-        cur_tracks = self.track_data[self.track_data.frame < frame_no][
-            ['trackid', 'frame']
-        ]
-        for trackid, fgrp in cur_tracks.groupby('trackid'):
-            entry_frame.append((fgrp['frame'].min(), trackid))
-        if len(entry_frame) == 0:
-            return frame_no
-        entry_frame = pd.DataFrame(
-            data=entry_frame, columns=['frame', 'trackid']
-        )
-        entry_frame.sort_values(by='frame', ascending=False, inplace=True)
-        fno = entry_frame.iloc[0]['frame']
-        return fno
-
-    def getFrameNextNew(self, frame_no):
-        """Return the next frame where a new object ID was detected"""
-        if frame_no > self.last_frame:
-            return self.last_frame + 1
-        cur_tracks = set(
-            self.track_data[self.track_data.frame <= frame_no]['trackid']
-        )
-        for fno in range(frame_no, self.last_frame + 1):
-            tracks = set(
-                self.track_data[self.track_data.frame == fno]['trackid']
-            )
-            if len(tracks - cur_tracks) > 0:
-                return fno
-        logging.debug(
-            f'Reached last frame with tracks: frame no {self.last_frame}'
-        )
-        return self.last_frame + 1
-
-    def getTracks(self, frame_no):
-        if frame_no > self.last_frame:
-            logging.debug(
-                f'Reached last frame with tracks: frame no {frame_no}'
-            )
-            self.sigEnd.emit()
-            return {}
-        self.frame_pos = frame_no
-        tracks = self.track_data[self.track_data.frame == frame_no]
-        # Filter bboxes violating size constraints
-        wh = np.sort(tracks[['w', 'h']].values, axis=1)
-        # print('Excluded', tracks.iloc[(
-        sel = np.flatnonzero(
-            (wh[:, 0] >= self.wmin)
-            & (wh[:, 0] <= self.wmax)
-            & (wh[:, 1] >= self.hmin)
-            & (wh[:, 1] <= self.hmax)
-        )
-        tracks = tracks.iloc[sel]
-        tracks = self.applyChanges(tracks)
-        return tracks
-
-    @qc.pyqtSlot(int, int, int)
-    def changeTrack(self, frame_no, orig_id, new_id, endFrame=-1):
-        """When user assigns `newId` to `orig_id` keep it in undo buffer"""
-        change = Change(
-            frame=frame_no,
-            end=endFrame,
-            change=ChangeCode.op_assign,
-            orig=orig_id,
-            new=new_id,
-            idx=self._change_idx,
-        )
-        self._change_idx += 1
-        self.changeList.add(change)
-        self.sigChangeList.emit(self.changeList)
-        logging.debug(
-            f'Changin track: frame: {frame_no}, old: {orig_id}, new: {new_id}'
-        )
-
-    @qc.pyqtSlot(int, int, int)
-    def swapTrack(self, frameNo, origId, newId, endFrame=-1):
-        """When user swaps `newId` with `orig_id` keep it in swap buffer"""
-        change = Change(
-            frame=frameNo,
-            end=endFrame,
-            change=ChangeCode.op_swap,
-            orig=origId,
-            new=newId,
-            idx=self._change_idx,
-        )
-        self._change_idx += 1
-        self.changeList.add(change)
-        logging.debug(
-            f'Swap track: frame: {frameNo}, old: {origId}, new: {newId}'
-        )
-
-    def deleteTrack(self, frameNo, origId, endFrame=-1):
-        change = Change(
-            frame=frameNo,
-            end=endFrame,
-            change=ChangeCode.op_delete,
-            orig=origId,
-            new=-1,
-            idx=self._change_idx,
-        )
-        self._change_idx += 1
-        self.changeList.add(change)
-
-    @qc.pyqtSlot(int)
-    def undoChangeTrack(self, frameNo):
-        """This puts the specified frame in a blacklist so all changes applied
-        on it are ignored"""
-        while True:
-            loc = self.changeList.bisect_key_left((frameNo, 0))
-            if (
-                loc < len(self.changeList)
-                and self.changeList[loc].frame == frameNo
-            ):
-                self.changeList.pop(loc)
-            else:
-                return
-
-    def applyChanges(self, tdata):
-        """Apply the changes in `changeList` to traks in `trackdf`
-        `trackdf` should have a single `frame` value - changes  only
-        upto and including this frame are applied.
-        """
-        if len(tdata) == 0:
-            return {}
-        tracks = []
-        idx_dict = {}
-        for ii, row in enumerate(tdata.itertuples()):
-            tracks.append([row.trackid, row.x, row.y, row.w, row.h, row.frame])
-            idx_dict[row.trackid] = ii
-        frameNo = tdata.frame.values[0]
-        delete_idx = set()
-        for change in self.changeList:
-            if change.frame > frameNo:
-                break
-            if (change.frame in self.undone_changes) or (
-                0 <= change.end < frameNo
-            ):
-                continue
-            orig_idx = idx_dict.pop(change.orig, None)
-            if change.change == ChangeCode.op_swap:
-                new_idx = idx_dict.pop(change.new, None)
-                if new_idx is not None:
-                    tracks[new_idx][0] = change.orig
-                    idx_dict[change.orig] = new_idx
-                if orig_idx is not None:
-                    tracks[orig_idx][0] = change.new
-                    idx_dict[change.new] = orig_idx
-            elif (orig_idx is not None) and (
-                (change.change == ChangeCode.op_assign)
-                or (change.change == ChangeCode.op_merge)
-            ):
-                # TODO - assign is same as merge now - but maybe in future
-                #  differentiate between assign, which should remove
-                #  pre-existing change.new item if change.orig is not present
-                #  in current tracks, and merge, which should keep
-                #  change.new even if change.orig is not present
-                tracks[orig_idx][0] = change.new
-                new_idx = idx_dict.pop(change.new, None)
-                idx_dict[change.new] = orig_idx
-                if new_idx is not None:
-                    delete_idx.add(new_idx)
-            elif (
-                change.change == ChangeCode.op_delete
-            ) and orig_idx is not None:
-                delete_idx.add(orig_idx)
-            elif orig_idx is not None:  # push the orig index back
-                idx_dict[change.orig] = orig_idx
-        tracks = {
-            t[0]: t[1:] for ii, t in enumerate(tracks) if ii not in delete_idx
-        }
-        return tracks
-
-    def saveChanges(self, filepath):
-        """Consolidate all the changes made in track id assignment.
-
-        Assumptions: as tracking progresses, only new, bigger numbers are
-        assigned for track ids. track_id never goes down.
-
-        track ids can be swapped.
-        """
-        # assignments = self.consolidateChanges()
-        data = []
-
-        for frame_no, tdata in self.track_data.groupby('frame'):
-            tracks = self.applyChanges(tdata)
-            for tid, tdata in tracks.items():
-                data.append([frame_no, tid] + tdata[:4])
-                qw.QApplication.processEvents()
-            self.sigSavedFrames.emit(frame_no)
-        data = pd.DataFrame(
-            data=data, columns=['frame', 'trackid', 'x', 'y', 'w', 'h']
-        )
-        changes = [
-            (
-                change.frame,
-                change.end,
-                change.change.name,
-                change.change.value,
-                change.orig,
-                change.new,
-                change.idx,
-            )
-            for change in self.changeList
-            if change.frame not in self.undone_changes
-        ]
-
-        changes = pd.DataFrame(
-            data=changes,
-            columns=['frame', 'end', 'change', 'code', 'orig', 'new', 'idx'],
-        )
-
-        ts = datetime.now().strftime('%Y%m%d_%H%M%S')
-        if filepath.endswith('.csv'):
-            data.to_csv(filepath, index=False)
-            changes.to_csv(f'{filepath}.changelist_{ts}.csv')
-        else:
-            data.to_hdf(filepath, 'tracked', mode='a', format='table')
-            changes.to_hdf(
-                filepath, f'changes/changelist_{ts}', mode='a', format='table'
-            )
-        self.track_data = data
-        self.changeList.clear()
-        self.sigChangeList.emit(self.changeList)
-
-    @qc.pyqtSlot(str)
-    def saveChangeList(self, fname: str) -> None:
-        # self.changeList = sorted(self.changeList, key=attrgetter('frame'))
-        with open(fname, 'w') as fd:
-            writer = csv.writer(fd)
-            writer.writerow(['frame', 'end', 'change', 'code', 'old', 'new'])
-            for change in self.changeList:
-                if change.frame not in self.undone_changes:
-                    writer.writerow(
-                        [
-                            change.frame,
-                            change.end,
-                            change.change.name,
-                            change.change.value,
-                            change.orig,
-                            change.new,
-                        ]
-                    )
-
-    @qc.pyqtSlot(str)
-    def loadChangeList(self, fname: str) -> None:
-        self.changeList.clear()
-        with open(fname) as fd:
-            reader = csv.DictReader(fd)
-            idx = 0
-            for row in reader:
-                new = int(row['new']) if len(row['new']) > 0 else None
-                chcode = getattr(ChangeCode, row['change'])
-                change = Change(
-                    frame=int(row['frame']),
-                    end=int(row['end']),
-                    change=chcode,
-                    orig=int(row['orig']),
-                    new=new,
-                    idx=idx,
-                )
-                self.changeList.add(change)
-                idx += 1
-        self.sigChangeList.emit(self.changeList)
-
-
-class ReviewScene(FrameScene):
-    def __init__(self, *args, **kwargs):
-        super(ReviewScene, self).__init__(*args, **kwargs)
-        self.drawingDisabled = True
-        self.lineStyleOldTrack = qc.Qt.DashLine
-        self.histGradient = 1
-        self.trackHist = []
-        self.markerThickness = settings.value(
-            'review/marker_thickness', 2.0, type=float
-        )
-        self.pathDia = settings.value('review/path_diameter', 5)
-        self.trackStyle = '-'  # `-` for line, `o` for ellipse
-        # TODO implement choice of the style
-
-    @qc.pyqtSlot(int)
-    def setHistGradient(self, age: int) -> None:
-        self.histGradient = age
-
-    @qc.pyqtSlot(float)
-    def setTrackMarkerThickness(self, thickness: float) -> None:
-        """Set the thickness of the marker-edge for drawing paths"""
-        self.markerThickness = thickness
-        settings.setValue('review/marker_thickness', thickness)
-
-    @qc.pyqtSlot(np.ndarray, str)
-    def showTrackHist(self, track: np.ndarray, cmap: str) -> None:
-        for item in self.trackHist:
-            try:
-                self.removeItem(item)
-            except Exception as e:
-                logging.debug(f'{e}')
-                pass
-        self.trackHist = []
-        if self._frame is None:
-            return
-        colors = [
-            qg.QColor(*get_cmap_color(ii, len(track), cmap))
-            for ii in range(len(track))
-        ]
-        pens = [
-            qg.QPen(qg.QBrush(color), self.markerThickness) for color in colors
-        ]
-        if self.trackStyle == '-':
-            self.trackHist = [
-                self.addLine(
-                    track[ii - 1][0],
-                    track[ii - 1][1],
-                    track[ii][0],
-                    track[ii][1],
-                    pens[ii],
-                )
-                for ii in range(1, len(track))
-            ]
-        elif self.trackStyle == 'o':
-            self.trackHist = [
-                self.addEllipse(
-                    track[ii][0],
-                    track[ii][1],
-                    self.pathDia,
-                    self.pathDia,
-                    pens[ii],
-                )
-                for ii in range(len(track))
-            ]
-
-    @qc.pyqtSlot(float)
-    def setPathDia(self, val):
-        self.pathDia = val
-
-    @qc.pyqtSlot(dict)
-    def setRectangles(self, rects: Dict[int, np.ndarray]) -> None:
-        """rects: a dict of id: (x, y, w, h, frame)
-
-        This overrides the same slot in FrameScene where each rectangle has
-        a fifth entry indicating frame no of the rectangle.
-
-        The ones from earlier frame that are not present in the current frame
-        are displayed with a special line style (default: dashes)
-        """
-        logging.debug(
-            f'{self.objectName()} Received rectangles from {self.sender().objectName()}'
-        )
-        logging.debug(f'{self.objectName()} Rectangles: {rects}')
-        logging.debug(f'{self.objectName()} cleared')
-        self.clearItems()
-        tmpRects = {id_: rect[:4] for id_, rect in rects.items()}
-        super(ReviewScene, self).setRectangles(tmpRects)
-
-        for id_, tdata in rects.items():
-            if tdata.shape[0] != 5:
-                raise ValueError(f'Incorrectly sized entry: {id_}: {tdata}')
-            item = self.itemDict[id_]
-            label = self.labelDict[id_]
-            if tdata[4] < self.frameno:
-                alpha = int(
-                    255
-                    * (
-                        1
-                        - 0.9
-                        * min(
-                            np.abs(self.frameno - tdata[4]), self.histGradient
-                        )
-                        / self.histGradient
-                    )
-                )
-                pen = item.pen()
-                color = pen.color()
-                color.setAlpha(alpha)
-                pen.setColor(color)
-                pen.setStyle(self.lineStyleOldTrack)
-                item.setPen(pen)
-                label.setDefaultTextColor(color)
-                label.setFont(self.font)
-                label.adjustSize()
-        self.update()
-
-    def clearAll(self):
-        super(ReviewScene, self).clearAll()
-        self.trackHist = []
-        self.selected = []
-
-
-class TrackView(FrameView):
-    """Visualization of bboxes of objects on video frame with facility to set
-    visible area of scene"""
-
-    sigSelected = qc.pyqtSignal(list)
-    sigTrackDia = qc.pyqtSignal(float)
-    sigTrackMarkerThickness = qc.pyqtSignal(float)
-
-    def __init__(self, *args, **kwargs):
-        super(TrackView, self).__init__(*args, **kwargs)
-        self.sigSelected.connect(self.scene().setSelected)
-        self.sigTrackDia.connect(self.scene().setPathDia)
-        self.sigTrackMarkerThickness.connect(
-            self.frameScene.setTrackMarkerThickness
-        )
-
-    def setViewportRect(self, rect: qc.QRectF) -> None:
-        self.fitInView(
-            rect.x(),
-            rect.y(),
-            rect.width(),
-            rect.height(),
-            qc.Qt.KeepAspectRatio,
-        )
-
-    def _makeScene(self):
-        self.frameScene = ReviewScene()
-        self.setScene(self.frameScene)
-
-    @qc.pyqtSlot()
-    def setPathDia(self):
-        input_, accept = qw.QInputDialog.getDouble(
-            self,
-            'Diameter of path markers',
-            'pixels',
-            self.frameScene.pathDia,
-            min=0,
-            max=500,
-        )
-        if accept:
-            self.sigTrackDia.emit(input_)
-
-    @qc.pyqtSlot()
-    def setTrackMarkerThickness(self):
-        input_, accept = qw.QInputDialog.getDouble(
-            self,
-            'Thickness of path markers',
-            'pixels',
-            self.frameScene.markerThickness,
-            min=0,
-            max=500,
-        )
-        if accept:
-            self.sigTrackMarkerThickness.emit(input_)
-
-    @qc.pyqtSlot(bool)
-    def enableDraw(self, enable: bool):
-        """Activate arena drawing"""
-        self.frameScene.disableDrawing(not enable)
-
-
-class TrackList(qw.QListWidget):
-    """
-    Attributes
-    ----------
-    keepSelection: bool
-        Whether to maintain selection of list item across frames. When the path
-        of the selected item is drawn, this makes things VERY SLOW.
-
-    selected: list of int
-        IDs of selected objects (in Review tool only a single selection is
-        allowed).
-
-    """
-
-    # Map tracks: source-id, target-id, end-frame, swap
-    sigMapTracks = qc.pyqtSignal(int, int, int, bool)
-    sigSelected = qc.pyqtSignal(list)
-
-    def __init__(self, *args, **kwargs):
-        super(TrackList, self).__init__(*args, **kwargs)
-        self._drag_button = qc.Qt.NoButton
-        self.setSelectionMode(qw.QAbstractItemView.SingleSelection)
-        self.itemSelectionChanged.connect(self.sendSelected)
-        self.itemClicked.connect(self.sendSelected)
-        self.keepSelection = settings.value('review/keepselection', type=bool)
-        self.currentFrame = -1
-        self.selected = []
-
-    @qc.pyqtSlot(int)
-    def setCurrentFrame(self, val):
-        self.currentFrame = val
-
-    @qc.pyqtSlot(bool)
-    def setKeepSelection(self, val):
-        self.keepSelection = val
-        settings.setValue('review/keepselection', val)
-
-    def decode_item_data(
-        self, mime_data: qc.QMimeData
-    ) -> List[Dict[qc.Qt.ItemDataRole, qc.QVariant]]:
-        """This was a test trick found here:
-        https://wiki.python.org/moin/PyQt/Handling%20Qt%27s%20internal%20item%20MIME%20type
-        but a much simpler solution for my case was here:
-        https://stackoverflow.com/questions/9715171/how-to-drop-items-on-qlistwidget-between-some-items
-        """
-        data = mime_data.data('application/x-qabstractitemmodeldatalist')
-        ds = qc.QDataStream(data)
-        item = {}
-        item_list = []
-        while not ds.atEnd():
-            ds.readInt32()  # row
-            ds.readInt32()  # col
-            map_items = ds.readInt32()
-            for ii in range(map_items):
-                key = ds.readInt32()
-                value = qc.QVariant()
-                ds >> value
-                item[qc.Qt.ItemDataRole(key)] = value
-            item_list.append(item)
-        return item_list
-
-    def dragMoveEvent(self, e: qg.QDragMoveEvent) -> None:
-        """This is just for tracking left vs right mouse button drag"""
-        self._drag_button = e.mouseButtons()
-        super(TrackList, self).dragMoveEvent(e)
-
-    def dropEvent(self, event: qg.QDropEvent) -> None:
-        """If dragged with left button, assign dropped trackid to the target
-        trackid, if right button, swap the two.  If Shift key was
-        pressed, then apply these only for the current frame,
-        otherwise also all future frames.
-
-        """
-        # items = self.decode_item_data(event.mimeData())
-        # assert  len(items) == 1, 'Only allowed to drop a single item'
-        # item = items[0]
-        # logging.debug(f'data: {item[qc.Qt.DisplayRole].value()}')
-        # If dragged with left button, rename. if right button, swap
-        source = event.source().currentItem()
-        target = self.itemAt(event.pos())
-        if target is None:
-            event.ignore()
-            return
-        endFrame = -1
-        if qw.QApplication.keyboardModifiers() == qc.Qt.AltModifier:
-            endFrame, accept = qw.QInputDialog.getInt(
-                self,
-                'Frame range',
-                'Apply till frame',
-                self.currentFrame,
-                self.currentFrame,
-                2 ** 31 - 1,
-            )
-            if not accept:
-                endFrame = -1
-        elif qw.QApplication.keyboardModifiers() == qc.Qt.ShiftModifier:
-            endFrame = self.currentFrame
-
-        self.sigMapTracks.emit(
-            int(source.text()),
-            int(target.text()),
-            endFrame,
-            self._drag_button == qc.Qt.RightButton,
-        )
-        event.ignore()
-
-    @qc.pyqtSlot(list)
-    def replaceAll(self, track_list: List[int]):
-        """Replace all items with keys from new tracks dictionary"""
-        self.blockSignals(True)
-        self.clear()
-        sorted_tracks = sorted(track_list)
-        self.addItems([str(x) for x in sorted_tracks])
-        # print(self, 'keep selection', self.keepSelection, 'selected:', self.selected)
-        if self.keepSelection and len(self.selected) > 0:
-            try:
-                idx = sorted_tracks.index(self.selected[0])
-                self.setCurrentRow(idx)
-            except ValueError:
-                pass
-            self.blockSignals(False)
-            # self.sigSelected.emit(self.selected)
-            return
-        self.blockSignals(False)
-        # print('Updating selection')
-        self.sendSelected()
-
-    @qc.pyqtSlot()
-    def sendSelected(self):
-        """Intermediate slot to convert text labels into integer track ids"""
-        self.selected = [int(item.text()) for item in self.selectedItems()]
-        self.sigSelected.emit(self.selected)
-        # Note: even if this is sent multiple times (e.g., both
-        # itemSelectionChanged and itemClicked connected to this slot,
-        # the destination FrameView keeps track of current selection and
-        # ignores if the selection has not changed).
-
-
-class LimitWin(qw.QMainWindow):
+class LimitWin(qw.QDialog):
     sigClose = qc.pyqtSignal(bool)  # connected to action checked state
 
     def __init__(self, *args, **kwargs):
         super(LimitWin, self).__init__(*args, **kwargs)
+        self.lim_widget = LimitsWidget(self)
+        layout = qw.QVBoxLayout()
+        layout.addWidget(self.lim_widget)
+        self.ok_button = qw.QPushButton('OK', self)
+        layout.addWidget(self.ok_button)
+        self.setLayout(layout)
+        self.ok_button.clicked.connect(self.close)
 
     def closeEvent(self, a0: qg.QCloseEvent) -> None:
         self.sigClose.emit(False)
         super(LimitWin, self).closeEvent(a0)
 
+    def connectLimitSignals(
+        self,
+        wminSlot=None,
+        wmaxSlot=None,
+        hminSlot=None,
+        hmaxSlot=None,
+        roiSignal=None,
+        resetRoiSignal=None,
+    ):
+        """Connect the signals from `lim_widget` to corresponding
+        slots passed as arguments and `roiSignal` to `setRoi` slot"""
+        if wminSlot is not None:
+            self.lim_widget.sigWmin.connect(wminSlot)
+        if wmaxSlot is not None:
+            self.lim_widget.sigWmax.connect(wmaxSlot)
+        if hminSlot is not None:
+            self.lim_widget.sigHmin.connect(hminSlot)
+        if hmaxSlot is not None:
+            self.lim_widget.sigHmax.connect(hmaxSlot)
+        if roiSignal is not None:
+            roiSignal.connect(self.lim_widget.setRoi)
+        if resetRoiSignal is not None:
+            resetRoiSignal.connect(self.lim_widget.resetRoi)
+
 
 class ChangeWindow(qw.QMainWindow):
     cols = ['frame', 'end', 'change', 'old id', 'new id']
 
     def __init__(self):
         super(ChangeWindow, self).__init__()
         self.table = qw.QTableWidget()
@@ -1263,31 +586,25 @@
         self.jump_step = 10
         self.history_length = 1
         self.all_tracks = OrderedDict()
         self.pathCmap = {
             'left': settings.value('review/path_cmap_left', 'inferno'),
             'right': settings.value('review/path_cmap_right', 'viridis'),
         }
-        self.left_frame = None
-        self.right_frame = None
-        self.right_tracks = None
-        self.frame_no = -1
+        self.prev = {'frame': None, 'tracks': None, 'pos': -1}
+        self.cur = {'frame': None, 'tracks': None, 'pos': -1}
         self.speed = 1.0
         self.timer = qc.QTimer(self)
         self.timer.setSingleShot(True)
         self.video_reader = None
         self.trackReader = None
         self.track_filename = None
         self.vid_info = VidInfo()
-        self.left_tracks = {}
-        self.right_tracks = {}
         self.roi = None
         # Since video seek is buggy, we have to do continuous reading
-        self.left_frame = None
-        self.right_frame = None
         self.save_indicator = None
         layout = qw.QVBoxLayout()
         panes_layout = qw.QHBoxLayout()
         self.leftView = TrackView()
         self.leftView.setObjectName('LeftView')
         self.leftView.frameScene.setObjectName('LeftScene')
         # self.leftView.setSizePolicy(qw.QSizePolicy.MinimumExpanding, qw.QSizePolicy.MinimumExpanding)
@@ -1335,37 +652,44 @@
         # self.rightView.setSizePolicy(qw.QSizePolicy.Expanding,
         #                              qw.QSizePolicy.Expanding)
         self.rightView.setHorizontalScrollBarPolicy(qc.Qt.ScrollBarAlwaysOn)
         self.rightView.setVerticalScrollBarPolicy(qc.Qt.ScrollBarAlwaysOn)
         panes_layout.addWidget(self.rightView, 1)
         layout.addLayout(panes_layout)
         self.play_button = qw.QPushButton('Play')
+        self.play_button.setIcon(
+            self.style().standardIcon(qw.QStyle.SP_MediaPlay)
+        )
         self.slider = qw.QSlider(qc.Qt.Horizontal)
         self.pos_spin = qw.QSpinBox()
         self.reset_button = qw.QPushButton('Reset')
+        self.reset_button.setIcon(
+            self.style().standardIcon(qw.QStyle.SP_MediaStop)
+        )
         self.reset_button.clicked.connect(self.reset)
         ctrl_layout = qw.QHBoxLayout()
         ctrl_layout.addWidget(self.play_button)
         ctrl_layout.addWidget(self.slider)
         ctrl_layout.addWidget(self.pos_spin)
         ctrl_layout.addWidget(self.reset_button)
         layout.addLayout(ctrl_layout)
         self.setLayout(layout)
-        self.lim_widget = LimitsWidget(self)
-        self.lim_win = LimitWin()
-        self.lim_win.setCentralWidget(self.lim_widget)
+        self.lim_win = LimitWin(self)
         self.changelist_widget = ChangeWindow()
         self.changelist_widget.setVisible(False)
         self.makeActions()
         self.makeShortcuts()
         self.timer.timeout.connect(self.nextFrame)
         self.sigLeftFrame.connect(self.leftView.setFrame)
         self.sigRightFrame.connect(self.rightView.setFrame)
-        self.rightView.sigArena.connect(self.setRoi)
-        self.rightView.sigArena.connect(self.lim_widget.setRoi)
+        # self.rightView.sigArena.connect(self.setRoi)
+        self.lim_win.connectLimitSignals(
+            roiSignal=self.rightView.sigArena,
+            resetRoiSignal=self.rightView.resetArenaAction.triggered,
+        )
         self.rightView.sigArena.connect(self.leftView.frameScene.setArena)
         self.sigLeftTracks.connect(self.leftView.sigSetRectangles)
         self.sigLeftTrackList.connect(self.left_list.replaceAll)
         self.sigRightTracks.connect(self.rightView.sigSetRectangles)
         self.sigRightTrackList.connect(self.right_list.replaceAll)
         self.sigAllTracksList.connect(self.all_list.replaceAll)
         self.left_list.sigSelected.connect(self.leftView.sigSelected)
@@ -1475,16 +799,17 @@
                     np.empty(0), self.pathCmap['left']
                 )
             if len(self.rightView.frameScene.trackHist) > 0:
                 self.sigProjectTrackHistRight.emit(
                     np.empty(0), self.pathCmap['right']
                 )
             return
-
-        if self.sender() == self.right_list:
+        if self.sender() == self.right_list or (
+            not self.toggleSideBySideAction.isChecked()
+        ):
             self._projectTrackHist(selected, 'right')
         else:
             self._projectTrackHist(selected, 'left')
 
     @qc.pyqtSlot(Exception)
     def catchSeekError(self, err: Exception) -> None:
         qw.QMessageBox.critical(self, 'Error jumping frames', str(err))
@@ -1507,15 +832,15 @@
     @qc.pyqtSlot()
     def clearBreakpoint(self):
         if self.video_reader is not None:
             self.breakpoint = self.video_reader.frame_count
 
     @qc.pyqtSlot()
     def setBreakpointAtCurrent(self):
-        self.breakpoint = self.frame_no
+        self.breakpoint = self.cur['pos']
 
     @qc.pyqtSlot()
     def setBreakpointAtEntry(self):
         val, ok = qw.QInputDialog.getInt(
             self,
             'Set breakpoint at entry',
             'Pause at appearance of trackid #',
@@ -1553,18 +878,26 @@
                 self,
                 'Processing paused',
                 f'Reached breakpoint at frame # {self.breakpoint}',
             )
 
     def entryExitMessage(self, left, right):
         do_break = False
-        if (self.entry_break in right) and (self.entry_break not in left):
+        if (
+            (self.entry_break in right)
+            and (left is not None)
+            and (self.entry_break not in left)
+        ):
             do_break = True
             message = f'Reached breakpoint at entry of # {self.entry_break}'
-        elif (self.exit_break in left) and (self.exit_break not in right):
+        elif (
+            (left is not None)
+            and (self.exit_break in left)
+            and (self.exit_break not in right)
+        ):
             do_break = True
             message = f'Reached breakpoint at exit of # {self.exit_break}'
         if do_break:
             self.play_button.setChecked(False)
             self.playVideo(False)
             qw.QMessageBox.information(self, 'Processing paused', message)
 
@@ -1660,15 +993,15 @@
             return
 
         for step in range(1, abs(steps) + 1):
             if direction == -1:
                 fwd()
             elif direction == 1:
                 bak()
-            if self.frame_no == self.breakpoint:
+            if self.cur['pos'] == self.breakpoint:
                 break
 
     def makeActions(self):
         self.disableSeekAction = qw.QAction('Disable seek')
         self.disableSeekAction.setToolTip(
             'Most video formats do not allow '
             'jumping back and forth by arbitrary number of frames.'
@@ -1758,21 +1091,30 @@
         self.setRoiAction = qw.QAction('Set polygon ROI')
         self.setRoiAction.triggered.connect(self.rightView.setArenaMode)
         self.enableDrawArenaAction = qw.QAction('Draw arena')
         self.enableDrawArenaAction.setCheckable(True)
         self.enableDrawArenaAction.triggered.connect(self.rightView.enableDraw)
         self.enableDrawArenaAction.triggered.connect(self.leftView.enableDraw)
         self.enableDrawArenaAction.setChecked(False)
-        self.rightView.resetArenaAction.triggered.connect(self.resetRoi)
+        # self.rightView.resetArenaAction.triggered.connect(self.resetRoi)
+
         self.rightView.resetArenaAction.triggered.connect(
             self.leftView.resetArenaAction.trigger
         )
         self.openAction = qw.QAction('Open tracked data (Ctrl+o)')
+        self.openAction.setIcon(
+            self.style().standardIcon(qw.QStyle.StandardPixmap.SP_DirOpenIcon)
+        )
         self.openAction.triggered.connect(self.openTrackedData)
         self.saveAction = qw.QAction('Save reviewed data (Ctrl+s)')
+        self.saveAction.setIcon(
+            self.style().standardIcon(
+                qw.QStyle.StandardPixmap.SP_DialogSaveButton
+            )
+        )
         self.saveAction.triggered.connect(self.saveReviewedTracks)
         self.speedUpAction = qw.QAction('Double speed (Ctrl+Up arrow)')
         self.speedUpAction.triggered.connect(self.speedUp)
         self.slowDownAction = qw.QAction('Half speed (Ctrl+Down arrow)')
         self.slowDownAction.triggered.connect(self.slowDown)
         self.zoomInLeftAction = qw.QAction('Zoom-in left (+)')
         self.zoomInLeftAction.triggered.connect(self.leftView.zoomIn)
@@ -1782,16 +1124,22 @@
         self.zoomOutLeftAction.triggered.connect(self.leftView.zoomOut)
         self.zoomOutRightAction = qw.QAction('Zoom-out right (-)')
         self.zoomOutRightAction.triggered.connect(self.rightView.zoomOut)
         self.showOldTracksAction = qw.QAction('Show old tracks (o)')
         self.showOldTracksAction.setCheckable(True)
         # self.showOldTracksAction.triggered.connect(self.all_list.setEnabled)
         self.playAction = qw.QAction('Play (Space)')
+        self.playAction.setIcon(
+            self.style().standardIcon(qw.QStyle.StandardPixmap.SP_MediaPlay)
+        )
         self.playAction.triggered.connect(self.playVideo)
         self.resetAction = qw.QAction('Reset')
+        self.resetAction.setIcon(
+            self.style().standardIcon(qw.QStyle.StandardPixmap.SP_MediaStop)
+        )
         self.resetAction.setToolTip(
             'Reset to initial state.' ' Lose all unsaved changes.'
         )
 
         self.nextFrameAction = qw.QAction('Next frame (Page down)')
         self.nextFrameAction.triggered.connect(self.nextFrame)
         self.prevFrameAction = qw.QAction('Previous frame (Page up)')
@@ -1799,25 +1147,29 @@
         self.gotoFrameAction = qw.QAction('Go to frame (g)')
         self.gotoFrameAction.triggered.connect(self.gotoFrameDialog)
         self.jumpForwardAction = qw.QAction('Jump forward (Ctrl+Page down)')
         self.jumpForwardAction.triggered.connect(self.jumpForward)
         self.jumpBackwardAction = qw.QAction('Jump backward (Ctrl+Page up)')
         self.jumpBackwardAction.triggered.connect(self.jumpBackward)
 
-        self.jumpNextNewAction = qw.QAction('Jump to next new track (n)')
+        self.jumpNextNewAction = qw.QAction('Go to next new track (n)')
         self.jumpNextNewAction.triggered.connect(self.jumpNextNew)
-        self.jumpPrevNewAction = qw.QAction('Jump to previous new track (p)')
+        self.jumpPrevNewAction = qw.QAction('Go to previous new track (p)')
         self.jumpPrevNewAction.triggered.connect(self.jumpPrevNew)
 
-        self.jumpNextChangeAction = qw.QAction('Jump to next change (c)')
-        self.jumpNextChangeAction.triggered.connect(self.gotoNextChange)
+        self.jumpNextChangeAction = qw.QAction('Go to next change (c)')
+        self.jumpNextChangeAction.triggered.connect(self.jumpNextChange)
         self.jumpPrevChangeAction = qw.QAction(
-            'Jump to previous change (Shift+c)'
+            'Go to previous change (Shift+c)'
         )
-        self.jumpPrevChangeAction.triggered.connect(self.gotoPrevChange)
+        self.jumpPrevChangeAction.triggered.connect(self.jumpPrevChange)
+        self.jumpNextJumpAction = qw.QAction('Go to next jump (Ctrl+n)')
+        self.jumpNextJumpAction.triggered.connect(self.jumpNextJump)
+        self.jumpPrevJumpAction = qw.QAction('Go to previous jump (Ctrl+p)')
+        self.jumpPrevJumpAction.triggered.connect(self.jumpPrevJump)
 
         self.frameBreakpointAction = qw.QAction('Set breakpoint at frame (b)')
         self.frameBreakpointAction.triggered.connect(self.setBreakpoint)
         self.curBreakpointAction = qw.QAction(
             'Set breakpoint at current frame (Ctrl+b)'
         )
         self.curBreakpointAction.triggered.connect(self.setBreakpointAtCurrent)
@@ -1853,14 +1205,16 @@
         self.resetAction.triggered.connect(self.reset)
         self.showDifferenceAction = qw.QAction(
             'Show popup message for left/right mismatch'
         )
         self.showDifferenceAction.setCheckable(True)
         show_difference = settings.value('review/showdiff', 2, type=int)
         self.showDifferenceAction.setChecked(show_difference == 2)
+        self.setJumpThresholdAction = qw.QAction('Set displacement threshold to flag jumps')
+        self.setJumpThresholdAction.triggered.connect(self._setJumpThreshold)
         self.showNewAction = qw.QAction('Show popup message for new tracks')
         self.showNewAction.setCheckable(True)
         self.showNewAction.setChecked(show_difference == 1)
         self.showNoneAction = qw.QAction('No popup message for tracks')
         self.showNoneAction.setCheckable(True)
         self.showNoneAction.setChecked(show_difference == 0)
         self.showHistoryAction = qw.QAction('Show track positions (t)')
@@ -1948,15 +1302,16 @@
         self.lim_win.sigClose.connect(self.showLimitsAction.setChecked)
         self.histlenAction = qw.QAction('Set oldest tracks to remember')
         self.histlenAction.triggered.connect(self.setHistLen)
         self.histGradientAction = qw.QAction('Set oldest tracks to display')
         self.histGradientAction.triggered.connect(self.setHistGradient)
         self.showChangeListAction = qw.QAction('Show list of changes (Alt+c)')
         self.showChangeListAction.setCheckable(True)
-        self.showChangeListAction.triggered.connect(self.showChangeList)
+        self.showChangeListAction.triggered.connect(self.updateChangeList)
+        self.sigDataFile.connect(self.updateChangeList)
         self.loadChangeListAction = qw.QAction('Load list of changes')
         self.loadChangeListAction.triggered.connect(self.loadChangeList)
         self.saveChangeListAction = qw.QAction('Save list of changes')
         self.saveChangeListAction.triggered.connect(self.saveChangeList)
         self.toggleSideBySideAction = qw.QAction('View side-by-side')
         self.toggleSideBySideAction.setToolTip(
             'Show previous and current frame side by side'
@@ -1965,14 +1320,19 @@
         checked = settings.value('review/sidebyside', True, type=bool)
         self.toggleSideBySideAction.setChecked(checked)
         self.toggleSideBySideAction.triggered.connect(
             self.toggleSideBySideView
         )
         self.toggleSideBySideView(checked)
         self.vidinfoAction = qw.QAction('Video information')
+        self.vidinfoAction.setIcon(
+            self.style().standardIcon(
+                qw.QStyle.StandardPixmap.SP_FileDialogInfoView
+            )
+        )
         self.vidinfoAction.triggered.connect(self.vid_info.show)
 
     def makeShortcuts(self):
         self.sc_play = qw.QShortcut(qg.QKeySequence(qc.Qt.Key_Space), self)
         self.sc_play.activated.connect(self.togglePlay)
         # Break point operations
         self.sc_break = qw.QShortcut(qg.QKeySequence('B'), self)
@@ -2005,20 +1365,29 @@
             qg.QKeySequence(qc.Qt.CTRL + qc.Qt.Key_PageUp), self
         )
         self.sc_jump_back.activated.connect(self.jumpBackward)
         self.sc_jump_nextnew = qw.QShortcut(qg.QKeySequence('N'), self)
         self.sc_jump_nextnew.activated.connect(self.jumpNextNew)
         self.sc_jump_prevnew = qw.QShortcut(qg.QKeySequence('P'), self)
         self.sc_jump_prevnew.activated.connect(self.jumpPrevNew)
+        self.sc_jump_next_jump = qw.QShortcut(
+            qg.QKeySequence(qc.Qt.CTRL + qc.Qt.Key_N), self
+        )
+        self.sc_jump_next_jump.activated.connect(self.jumpNextJump)
+        self.sc_jump_prev_jump = qw.QShortcut(
+            qg.QKeySequence(qc.Qt.CTRL + qc.Qt.Key_P), self
+        )
+        self.sc_jump_prev_jump.activated.connect(self.jumpPrevJump)
+
         self.sc_jump_nextchange = qw.QShortcut(qg.QKeySequence('C'), self)
-        self.sc_jump_nextchange.activated.connect(self.gotoNextChange)
+        self.sc_jump_nextchange.activated.connect(self.jumpNextChange)
         self.sc_jump_prevchange = qw.QShortcut(
             qg.QKeySequence('Shift+C'), self
         )
-        self.sc_jump_prevchange.activated.connect(self.gotoPrevChange)
+        self.sc_jump_prevchange.activated.connect(self.jumpPrevChange)
 
         self.sc_zoom_in_left = qw.QShortcut(qg.QKeySequence('+'), self)
         self.sc_zoom_in_left.activated.connect(self.leftView.zoomIn)
         self.sc_zoom_in_right = qw.QShortcut(qg.QKeySequence('='), self)
         self.sc_zoom_in_right.activated.connect(self.rightView.zoomIn)
         self.sc_zoom_out_right = qw.QShortcut(qg.QKeySequence('-'), self)
         self.sc_zoom_out_right.activated.connect(self.rightView.zoomOut)
@@ -2108,27 +1477,27 @@
         self.rightView.scene().removeSelected()
         endFrame = -1
         if range:
             endFrame, ok = qw.QInputDialog.getInt(
                 self,
                 'Delete in frame range',
                 'Delete till frame',
-                self.frame_no,
-                self.frame_no,
-                2 ** 31 - 1,
+                self.cur['pos'],
+                self.cur['pos'],
+                2**31 - 1,
             )
             if not ok:
                 return
         if cur:
-            endFrame = self.frame_no
+            endFrame = self.cur['pos']
         for sel in selected:
-            self.trackReader.deleteTrack(self.frame_no, sel, endFrame)
-            if sel not in self.right_tracks:
+            self.trackReader.deleteTrack(self.cur['pos'], sel, endFrame)
+            if sel not in self.cur['tracks']:
                 continue
-            self.right_tracks.pop(sel)
+            self.cur['tracks'].pop(sel)
             right_items = self.right_list.findItems(
                 items[0].text(), qc.Qt.MatchExactly
             )
             for item in right_items:
                 self.right_list.takeItem(self.right_list.row(item))
         self.sigDataFile.emit(self.track_filename, True)
 
@@ -2164,15 +1533,15 @@
             return
         tid = int(target[0].text())
         val, ok = qw.QInputDialog.getInt(
             self, 'Rename track', 'New track id', value=tid
         )
         if ok:
             print(f'Renaming track {tid} to {val}')
-            self.mapTracks(val, tid, self.frame_no, False)
+            self.mapTracks(val, tid, self.cur['pos'], False)
 
     @qc.pyqtSlot()
     def swapTracks(self):
         source = self.all_list.selectedItems()
         target = self.right_list.selectedItems()
         if len(source) == 0 or len(target) == 0:
             return
@@ -2189,60 +1558,60 @@
     @qc.pyqtSlot()
     def swapTracksCur(self):
         source = self.all_list.selectedItems()
         target = self.right_list.selectedItems()
         if len(source) == 0 or len(target) == 0:
             return
         self.mapTracks(
-            int(source[0].text()), int(target[0].text()), self.frame_no, True
+            int(source[0].text()), int(target[0].text()), self.cur['pos'], True
         )
 
     @qc.pyqtSlot()
     def swapTracksRange(self):
         source = self.all_list.selectedItems()
         target = self.right_list.selectedItems()
         if len(source) == 0 or len(target) == 0:
             return
         endFrame, accept = qw.QInputDialog.getInt(
             self,
             'Frame range',
             'Apply till frame',
-            self.frame_no,
-            self.frame_no,
-            2 ** 31 - 1,
+            self.cur['pos'],
+            self.cur['pos'],
+            2**31 - 1,
         )
         if not accept:
             return
         self.mapTracks(
             int(source[0].text()), int(target[0].text()), endFrame, True
         )
 
     @qc.pyqtSlot()
     def replaceTrackCur(self):
         source = self.all_list.selectedItems()
         target = self.right_list.selectedItems()
         if len(source) == 0 or len(target) == 0:
             return
         self.mapTracks(
-            int(source[0].text()), int(target[0].text()), self.frame_no, True
+            int(source[0].text()), int(target[0].text()), self.cur['pos'], True
         )
 
     @qc.pyqtSlot()
     def replaceTracksRange(self):
         source = self.all_list.selectedItems()
         target = self.right_list.selectedItems()
         if len(source) == 0 or len(target) == 0:
             return
         endFrame, accept = qw.QInputDialog.getInt(
             self,
             'Frame range',
             'Apply till frame',
-            self.frame_no,
-            self.frame_no,
-            2 ** 31 - 1,
+            self.cur['pos'],
+            self.cur['pos'],
+            2**31 - 1,
         )
         if not accept:
             return
         self.mapTracks(
             int(source[0].text()), int(target[0].text()), endFrame, False
         )
 
@@ -2252,131 +1621,174 @@
             frame_no = 0
         if self.trackReader is None or self.video_reader is None:  # or \
             #                frame_no > self.trackReader.last_frame:
             return
         if self.disableSeekAction.isChecked():
             self.sigNextFrame.emit()
         else:
-            self.frame_no = frame_no
-            logging.debug(f'Frame no set: {frame_no}')
-            if self.frame_no > 0:
-                self.sigGotoFrame.emit(self.frame_no - 1)
-            self.sigGotoFrame.emit(self.frame_no)
+            self.sigGotoFrame.emit(frame_no)
 
     @qc.pyqtSlot()
     def gotoFrameDialog(self):
         val, ok = qw.QInputDialog.getInt(
-            self, 'Goto frame', 'Jump to frame #', value=self.frame_no, min=0
+            self, 'Goto frame', 'Jump to frame #', value=self.cur['pos'], min=0
         )
         if ok and val >= 0:
+            self.gotoFrame(val - 1)
             self.gotoFrame(val)
 
     @qc.pyqtSlot()
     def jumpToBreakpoint(self):
         if self.breakpoint >= 0 and not self.disableSeekAction.isChecked():
+            self.gotoFrame(self.breakpoint - 1)
             self.gotoFrame(self.breakpoint)
 
     @qc.pyqtSlot()
     def jumpForward(self):
-        target = self.frame_no + self.jump_step
-        if (self.frame_no < self.breakpoint) and (target > self.breakpoint):
+        target = self.cur['pos'] + self.jump_step
+        if (self.cur['pos'] < self.breakpoint) and (target > self.breakpoint):
             target = self.breakpoint
+        self.gotoFrame(target - 1)
         self.gotoFrame(target)
 
     @qc.pyqtSlot()
     def jumpBackward(self):
-        target = self.frame_no - self.jump_step
-        if (self.frame_no > self.breakpoint) and (target < self.breakpoint):
+        target = self.cur['pos'] - self.jump_step
+        if (self.cur['pos'] > self.breakpoint) and (target < self.breakpoint):
             target = self.breakpoint
+        self.gotoFrame(target - 1)
         self.gotoFrame(target)
 
     @qc.pyqtSlot()
     def jumpNextNew(self):
         if self.trackReader is None:
             return
-        frame = self.trackReader.getFrameNextNew(self.frame_no)
+        frame = self.trackReader.getFrameNextNew(self.cur['pos'])
+        self.gotoFrame(frame - 1)
         self.gotoFrame(frame)
+        if set(self.cur['tracks']) == set(self.prev['tracks']):
+            self.sigDiffMessage.emit(
+                f'{self.prev["pos"]} - {self.cur["pos"]}'
+                ': tracks differ but filtered out'
+            )
 
     @qc.pyqtSlot()
     def jumpPrevNew(self):
         if self.trackReader is None:
             return
-        frame = self.trackReader.getFramePrevNew(self.frame_no)
+        frame = self.trackReader.getFramePrevNew(self.cur['pos'])
+        self.gotoFrame(frame - 1)
         self.gotoFrame(frame)
+        if set(self.cur['tracks']) == set(self.prev['tracks']):
+            self.sigDiffMessage.emit(
+                f'{self.prev["pos"]} - {self.cur["pos"]}'
+                ': tracks differ but filtered out'
+            )
 
     @qc.pyqtSlot()
-    def gotoNextChange(self):
+    def jumpNextJump(self):
+        if self.trackReader is None:
+            return
+        jumpThreshold = settings.value('review/jumpthreshold', 50.0, type=float)        
+        frame, tracks = self.trackReader.getFrameNextJump(self.cur['pos'], jumpThreshold)
+        self.gotoFrame(frame - 1)
+        self.gotoFrame(frame)
+        self.sigDiffMessage.emit(
+            f'{self.prev["pos"]} - {self.cur["pos"]} Jump in: {tracks}'
+            )
+
+    @qc.pyqtSlot()
+    def jumpPrevJump(self):
+        if self.trackReader is None:
+            return
+        jumpThreshold = settings.value('review/jumpthreshold', 50.0, type=float)        
+        frame, tracks = self.trackReader.getFramePrevJump(self.cur['pos'], jumpThreshold)
+        self.gotoFrame(frame - 1)
+        self.gotoFrame(frame)
+        self.sigDiffMessage.emit(
+            f'{self.prev["pos"]} - {self.cur["pos"]} Jump in tracks: {tracks}'
+            )
+
+    @qc.pyqtSlot()
+    def jumpNextChange(self):
         if self.trackReader is None:
             return
         change_frames = [
             change.frame
             for change in self.trackReader.changeList
             if change.frame not in self.trackReader.undone_changes
         ]
-        pos = np.searchsorted(change_frames, self.frame_no, side='right')
+        pos = np.searchsorted(change_frames, self.cur['pos'], side='right')
         if 0 <= pos < len(change_frames):
+            # this ensures we have two successive frames on left and right pane
+            self.gotoFrame(change_frames[pos] - 1)
             self.gotoFrame(change_frames[pos])
 
     @qc.pyqtSlot()
-    def gotoPrevChange(self):
+    def jumpPrevChange(self):
         if self.trackReader is None:
             return
         change_frames = [
             change.frame
             for change in self.trackReader.changeList
             if change.frame not in self.trackReader.undone_changes
         ]
-        pos = np.searchsorted(change_frames, self.frame_no, side='left') - 1
+        pos = np.searchsorted(change_frames, self.cur['pos'], side='left') - 1
         if pos < 0:
             return
+        # this ensures we have two successive frames on left and right pane
+        self.gotoFrame(change_frames[pos] - 1)
         self.gotoFrame(change_frames[pos])
 
     @qc.pyqtSlot()
     def gotoEditedPos(self):
         frame_no = int(self.pos_spin.text())
+        # this ensures we have two successive frames on left and right pane
+        self.gotoFrame(frame_no - 1)
         self.gotoFrame(frame_no)
 
     @qc.pyqtSlot()
     def nextFrame(self):
-        self.gotoFrame(self.frame_no + 1)
+        self.gotoFrame(self.cur['pos'] + 1)
         if self.play_button.isChecked():
             self.timer.start(int(self.frame_interval / self.speed))
 
     @qc.pyqtSlot()
     def prevFrame(self):
-        if self.frame_no > 0:
-            self.gotoFrame(self.frame_no - 1)
+        # Since going backwards changes the left frame, and keeps cur to one
+        # frame ahead, we move two frames back from cur pos
+        pos = self.cur['pos']
+        self.gotoFrame(pos - 2)
+        self.gotoFrame(pos - 1)
 
     def _flag_tracks(self, all_tracks, cur_tracks):
-        """Change the track info to include it age, if age is more than
+        """Change the track info to include its age, if age is more than
         `history_length` then remove this track from all tracks -
         this avoids cluttering the view with very old tracks that have not been
         seen in a long time."""
         ret = {}
         for tid, rect in all_tracks.items():
-            if self.frame_no - rect[4] <= self.history_length:
+            if self.cur['pos'] - rect[4] <= self.history_length:
                 ret[tid] = rect.copy()
         for tid, rect in cur_tracks.items():
             ret[tid] = np.array(rect)
         return ret
 
-    @qc.pyqtSlot(bool)
-    def showChangeList(self, checked):
+    @qc.pyqtSlot()
+    @qc.pyqtSlot(str, bool)
+    def updateChangeList(self, filepath='', checked=True):
+        """Catches `self.sigDataFile` to update the changelist"""
         if self.trackReader is None:
             return
-        if not checked:
-            self.changelist_widget.setVisible(False)
-            return
         change_list = [
             change
             for change in self.trackReader.changeList
             if change.frame not in self.trackReader.undone_changes
         ]
         self.changelist_widget.setChangeList(change_list)
-        self.changelist_widget.setVisible(True)
 
     @qc.pyqtSlot()
     def saveChangeList(self):
         if self.trackReader is None:
             return
         fname, _ = qw.QFileDialog.getSaveFileName(
             self, 'Save list of changes', filter='Text (*.csv)'
@@ -2419,152 +1831,122 @@
                 pass
 
         else:
             self.sigProjectTrackHistLeft.connect(
                 self.rightView.frameScene.showTrackHist
             )
             self.left_list.sigSelected.connect(self.rightView.sigSelected)
-        self.all_list.sigSelected.connect(self.rightView.sigSelected)
-
-    @qc.pyqtSlot(qg.QPolygonF)
-    def setRoi(self, roi: qg.QPolygonF) -> None:
-        self.roi = roi
+            self.all_list.sigSelected.connect(self.rightView.sigSelected)
 
-    @qc.pyqtSlot()
-    def resetRoi(self) -> None:
-        self.roi = None
+    # @qc.pyqtSlot(qg.QPolygonF)
+    # def setRoi(self, roi: qg.QPolygonF) -> None:
+    #     self.roi = roi
+    #
+    # @qc.pyqtSlot()
+    # def resetRoi(self) -> None:
+    #     self.roi = None
 
     @qc.pyqtSlot()
     def undoCurrentChanges(self):
-        self.sigUndoCurrentChanges.emit(self.frame_no)
+        self.sigUndoCurrentChanges.emit(self.cur['pos'])
 
     @qc.pyqtSlot(np.ndarray, int)
     def setFrame(self, frame: np.ndarray, pos: int) -> None:
+        """Set the current frame, called by signal from video reader.
+        This assumes we are moving forward sequentially.
+        So call twice when jumping around."""
         logging.debug(f'Received frame: {pos}')
+        if pos == self.cur['pos']:
+            return
+        tracks = self.trackReader.getTracks(pos)
+        flagged_tracks = self._flag_tracks({}, tracks)
+        # ts = time.perf_counter_ns()
+        # if self.roi is not None:
+        #     # flag tracks outside ROI
+        #     keys = list(tracks.keys())
+        #     for tid in keys:
+        #         bbox = qg.QPolygonF(qc.QRectF(*tracks[tid][:4]))
+        #         if not self.roi.intersects(bbox):
+        #             self.trackReader.deleteTrack(pos, tid)
+        #             tracks.pop(tid)
+
+        if pos > 0:
+            self.prev = self.cur
+        else:
+            self.prev = {
+                'frame': np.zeros(frame.shape, dtype=frame.dtype),
+                'tracks': {},
+                'pos': -1,
+            }
+        self.cur = {'frame': frame, 'tracks': flagged_tracks, 'pos': pos}
+        # When overlay is checked, show the diff on the right
+        if (
+            self.overlayAction.isChecked()
+            and (self.prev['frame'] is not None)
+            and len(frame.shape) == 3
+        ):
+            diff = np.zeros(
+                (frame.shape[0], frame.shape[1], 3), dtype=np.uint8
+            )
+            diff[:, :, 1] = 0
+            diff[:, :, 0] = cv2.cvtColor(self.cur['frame'], cv2.COLOR_BGR2GRAY)
+            diff[:, :, 2] = cv2.cvtColor(
+                self.prev['frame'], cv2.COLOR_BGR2GRAY
+            )
+            if self.invertOverlayColorAction.isChecked():
+                diff = 255 - diff
+            self.sigRightFrame.emit(diff, self.cur['pos'])
+        else:
+            self.sigRightFrame.emit(self.cur['frame'], self.cur['pos'])
+
+        self.sigLeftFrame.emit(self.prev['frame'], self.prev['pos'])
+
         self.slider.blockSignals(True)
-        self.slider.setValue(pos)
+        self.slider.setValue(self.cur['pos'])
         self.slider.blockSignals(False)
         self.pos_spin.blockSignals(True)
-        self.pos_spin.setValue(pos)
+        self.pos_spin.setValue(self.cur['pos'])
         self.pos_spin.blockSignals(False)
-        tracks = self.trackReader.getTracks(pos)
-        # ts = time.perf_counter_ns()
-        if self.roi is not None:
-            # flag tracks outside ROI
-            keys = list(tracks.keys())
-            for tid in keys:
-                bbox = qg.QPolygonF(qc.QRectF(*tracks[tid][:4]))
-                if not self.roi.intersects(bbox):
-                    self.trackReader.deleteTrack(self.frame_no, tid)
-                    tracks.pop(tid)
+
         # te = time.perf_counter_ns()
         # print(f'Time with roi "{self.roi}": {(te - ts) * 1e-6} ms')
         self.old_all_tracks = self.all_tracks.copy()
         self.all_tracks = self._flag_tracks(self.all_tracks, tracks)
         self.sigAllTracksList.emit(list(self.all_tracks.keys()))
-        if self.disableSeekAction.isChecked():
-            # Going sequentially through frames - copy right to left
-            self.frame_no = pos
-            self.left_frame = self.right_frame
-            if self.left_frame is not None:
-                self.sigLeftFrame.emit(self.left_frame, pos - 1)
-            self.right_frame = frame
-            if (
-                self.overlayAction.isChecked()
-                and (self.left_frame is not None)
-                and len(frame.shape) == 3
-            ):
-                tmp = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
-                frame = np.zeros(
-                    (frame.shape[0], frame.shape[1], 3), dtype=np.uint8
-                )
-                frame[:, :, 1] = 0
-                frame[:, :, 0] = tmp
-                frame[:, :, 2] = cv2.cvtColor(
-                    self.left_frame, cv2.COLOR_BGR2GRAY
-                )
-                if self.invertOverlayColorAction.isChecked():
-                    frame = 255 - frame
-            self.sigRightFrame.emit(frame, pos)
-            self.left_tracks = self.right_tracks
-            self.right_tracks = self._flag_tracks({}, tracks)
-            if self.showOldTracksAction.isChecked():
-                self.sigLeftTracks.emit(self.old_all_tracks)
-                self.sigRightTracks.emit(self.all_tracks)
-            else:
-                self.sigLeftTracks.emit(self.left_tracks)
-                self.sigRightTracks.emit(self.right_tracks)
-            self.sigLeftTrackList.emit(list(self.left_tracks.keys()))
-            self.sigRightTrackList.emit(list(self.right_tracks.keys()))
-        elif pos == self.frame_no - 1:
-            logging.debug(f'Received left frame: {pos}')
-            self.left_frame = frame
-            self.sigLeftFrame.emit(self.left_frame, pos)
-            self.left_tracks = self._flag_tracks({}, tracks)
-            if self.showOldTracksAction.isChecked():
-                self.sigLeftTracks.emit(self.all_tracks)
-            else:
-                self.sigLeftTracks.emit(self.left_tracks)
-            self.sigLeftTrackList.emit(list(self.left_tracks.keys()))
-            self._wait_cond.set()
-            return  # do not show popup message for old frame
-        elif pos == self.frame_no:
-            logging.debug(f'right frame: {pos}')
-            self.right_frame = frame
-            if (
-                self.overlayAction.isChecked()
-                and (self.left_frame is not None)
-                and len(frame.shape) == 3
-            ):
-                tmp = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
-                frame = np.zeros(
-                    (frame.shape[0], frame.shape[1], 3), dtype=np.uint8
-                )
-                frame[:, :, 1] = 0
-                frame[:, :, 0] = tmp
-                frame[:, :, 2] = cv2.cvtColor(
-                    self.left_frame, cv2.COLOR_BGR2GRAY
-                )
-                if self.invertOverlayColorAction.isChecked():
-                    frame = 255 - frame
-            self.sigRightFrame.emit(frame, pos)
-            self.right_tracks = self._flag_tracks({}, tracks)
-            if self.showOldTracksAction.isChecked():
-                self.sigRightTracks.emit(self.all_tracks)
-            else:
-                self.sigRightTracks.emit(self.right_tracks)
-            self.sigRightTrackList.emit(list(self.right_tracks.keys()))
-            # Pause if there is a mismatch with the earlier tracks
+        # If showing old tracks, display all trak ids
+        if self.showOldTracksAction.isChecked():
+            self.sigLeftTracks.emit(self.old_all_tracks)
+            self.sigRightTracks.emit(self.all_tracks)
         else:
-            self._wait_cond.set()
-            raise Exception('This should not be reached')
+            self.sigLeftTracks.emit(self.prev['tracks'])
+            self.sigRightTracks.emit(self.cur['tracks'])
+        self.sigLeftTrackList.emit(list(self.prev['tracks'].keys()))
+        self.sigRightTrackList.emit(list(self.cur['tracks'].keys()))
         self.breakpointMessage(pos)
-        self.entryExitMessage(self.left_tracks, self.right_tracks)
+        self.entryExitMessage(self.prev['tracks'], self.cur['tracks'])
         message = self._get_diff(self.showNewAction.isChecked())
         if len(message) > 0:
             if (
                 self.showDifferenceAction.isChecked()
                 or self.showNewAction.isChecked()
             ):
                 self.play_button.setChecked(False)
                 self.playVideo(False)
                 qw.QMessageBox.information(self, 'Track mismatch', message)
             self.sigDiffMessage.emit(message)
-        self._wait_cond.set()
-        logging.debug('wait condition set')
 
     def _get_diff(self, show_new):
-        right_keys = set(self.right_tracks.keys())
+        right_keys = set(self.cur['tracks'].keys())
         all_keys = set(self.old_all_tracks.keys())
         new = right_keys - all_keys
         if show_new:
             if len(new) > 0:
-                return f'Frame {self.frame_no - 1}-{self.frame_no}: New track on right: {new}.'
+                return f'Frame {self.cur["pos"] - 1}-{self.cur["pos"]}: New track on right: {new}.'
             return ''
-        left_keys = set(self.left_tracks.keys())
+        left_keys = set(self.prev['tracks'].keys())
         if left_keys != right_keys:
             # logging.info(f'Tracks don\'t match between frames {self.frame_no - 1} '
             #              f'and {self.frame_no}: '
             #              f'{left_keys.symmetric_difference(right_keys)}')
             left_only = left_keys - right_keys
             left_message = (
                 f'Tracks only on left: {left_only}.'
@@ -2575,20 +1957,35 @@
             right_message = (
                 f'Tracks only on right: {right_only}.'
                 if len(right_only) > 0
                 else ''
             )
             if len(new) > 0:
                 right_message += f'New tracks: <b>{new}</b>'
-            return f'Frame {self.frame_no - 1}-{self.frame_no}: {left_message} {right_message}'
+            return (
+                f'Frame {self.cur["pos"] - 1}-{self.cur["pos"]}:'
+                f'{left_message} {right_message}'
+            )
         else:
             return ''
 
+    def _setJumpThreshold(self):
+        """Set the threshold distance in positions between successive frames to flag it as a jump"""
+        jumpThreshold = settings.value('review/jumpthreshold', 50.0, type=float)
+        jumpThreshold, accept = qw.QInputDialog.getDouble(
+            self,
+            'Threshold displacement for jumps',
+            'Displacement', jumpThreshold, min=0.1
+        )
+        if not accept:
+            return
+        settings.setValue('review/jumpthreshold', jumpThreshold)
+        
     def _setPathCmap(self, side):
-        input, accept = qw.QInputDialog.getItem(
+        cmap, accept = qw.QInputDialog.getItem(
             self,
             'Select colormap',
             'Colormap',
             [
                 'jet',
                 'viridis',
                 'rainbow',
@@ -2596,19 +1993,19 @@
                 'summer',
                 'winter',
                 'spring',
                 'cool',
                 'hot',
             ],
         )
-        logging.debug(f'Setting colormap to {input}')
+        logging.debug(f'Setting colormap to {cmap}')
         if not accept:
             return
-        self.pathCmap[side] = input
-        settings.setValue(f'review/path_cmap_{side}', input)
+        self.pathCmap[side] = cmap
+        settings.setValue(f'review/path_cmap_{side}', cmap)
 
     @qc.pyqtSlot()
     def setPathCmapLeft(self):
         self._setPathCmap('left')
 
     @qc.pyqtSlot()
     def setPathCmapRight(self):
@@ -2666,26 +2063,30 @@
         self.vid_info.frame_width.setText(f'{self.video_reader.frame_width}')
         self.vid_info.frame_height.setText(f'{self.video_reader.frame_height}')
         self.leftView.clearAll()
         self.leftView.update()
         self.all_tracks.clear()
         self.left_list.clear()
         self.right_list.clear()
-        self.left_tracks = {}
-        self.right_tracks = {}
-        self.left_frame = None
-        self.right_frame = None
+        self.prev = {'frame': None, 'tracks': None, 'pos': -1}
+        self.cur = {'frame': None, 'tracks': None, 'pos': -1}
         self.history_length = self.trackReader.last_frame
         self.leftView.frameScene.setHistGradient(self.history_length)
         self.rightView.frameScene.setHistGradient(self.history_length)
         self.rightView.resetArenaAction.trigger()
-        self.lim_widget.sigWmin.connect(self.trackReader.setWmin)
-        self.lim_widget.sigWmax.connect(self.trackReader.setWmax)
-        self.lim_widget.sigHmin.connect(self.trackReader.setHmin)
-        self.lim_widget.sigHmax.connect(self.trackReader.setHmax)
+        self.lim_win.connectLimitSignals(
+            wminSlot=self.trackReader.setWmin,
+            wmaxSlot=self.trackReader.setWmax,
+            hminSlot=self.trackReader.setHmin,
+            hmaxSlot=self.trackReader.setHmax,
+        )
+        self.rightView.sigArena.connect(self.trackReader.setRoi)
+        self.rightView.resetArenaAction.triggered.connect(
+            self.trackReader.resetRoi
+        )
         if self.disableSeekAction.isChecked():
             self.sigNextFrame.connect(self.video_reader.read)
         else:
             self.sigGotoFrame.connect(self.video_reader.gotoFrame)
         self.video_reader.sigFrameRead.connect(self.setFrame)
         self.video_reader.sigSeekError.connect(self.catchSeekError)
         self.video_reader.sigVideoEnd.connect(self.videoEnd)
@@ -2785,19 +2186,31 @@
 
     @qc.pyqtSlot(bool)
     def playVideo(self, play: bool):
         if self.video_reader is None:
             return
         if play:
             self.play_button.setText('Pause (Space)')
+            self.play_button.setIcon(
+                self.style().standardIcon(qw.QStyle.SP_MediaPause)
+            )
             self.playAction.setText('Pause (Space)')
+            self.playAction.setIcon(
+                self.style().standardIcon(qw.QStyle.SP_MediaPause)
+            )
             self.timer.start(int(self.frame_interval / self.speed))
         else:
             self.play_button.setText('Play (Space)')
+            self.play_button.setIcon(
+                self.style().standardIcon(qw.QStyle.SP_MediaPlay)
+            )
             self.playAction.setText('Play (Space)')
+            self.playAction.setIcon(
+                self.style().standardIcon(qw.QStyle.SP_MediaPlay)
+            )
             self.timer.stop()
 
     @qc.pyqtSlot()
     def togglePlay(self):
         if self.video_reader is None:
             return
         if self.play_button.isChecked():
@@ -2837,23 +2250,25 @@
     ) -> None:
         """Map newId to origId, up to and including endFrame.
         If swap is True, do a swap, otherwise assign.
         """
         if newId == origId:
             return
         if swap:
-            self.trackReader.swapTrack(self.frame_no, origId, newId, endFrame)
+            self.trackReader.swapTrack(
+                self.cur['pos'], origId, newId, endFrame
+            )
         else:
             self.trackReader.changeTrack(
-                self.frame_no, origId, newId, endFrame
+                self.cur['pos'], origId, newId, endFrame
             )
-        tracks = self.trackReader.getTracks(self.frame_no)
+        tracks = self.trackReader.getTracks(self.cur['pos'])
         self.sigRightTrackList.emit(list(tracks.keys()))
-        self.right_tracks = self._flag_tracks({}, tracks)
-        self.sigRightTracks.emit(self.right_tracks)
+        self.cur['tracks'] = self._flag_tracks({}, tracks)
+        self.sigRightTracks.emit(self.cur['tracks'])
         self.sigDataFile.emit(self.track_filename, True)
 
     @qc.pyqtSlot()
     def videoEnd(self):
         self.playVideo(False)
         self.play_button.setChecked(False)
         qw.QMessageBox.information(
@@ -2871,14 +2286,26 @@
 
 class ReviewerMain(qw.QMainWindow):
     sigQuit = qc.pyqtSignal()
 
     def __init__(self):
         super(ReviewerMain, self).__init__()
         self.reviewWidget = ReviewWidget()
+        self.rightDock = qw.QDockWidget('Changes')
+        self.rightDock.setFeatures(
+            qw.QDockWidget.DockWidgetMovable
+            | qw.QDockWidget.DockWidgetFloatable
+        )
+        self.rightDock.setWidget(self.reviewWidget.changelist_widget)
+        self.rightDock.setVisible(False)
+        self.reviewWidget.showChangeListAction.triggered.connect(
+            self.rightDock.setVisible
+        )
+        self.addDockWidget(qc.Qt.RightDockWidgetArea, self.rightDock)
+
         fileMenu = self.menuBar().addMenu('&File')
         fileMenu.addAction(self.reviewWidget.openAction)
         fileMenu.addAction(self.reviewWidget.saveAction)
         fileMenu.addAction(self.reviewWidget.loadChangeListAction)
         fileMenu.addAction(self.reviewWidget.saveChangeListAction)
 
         self.sc_quit = qw.QShortcut(qg.QKeySequence('Ctrl+Q'), self)
@@ -2891,14 +2318,15 @@
         diffMenu.addAction(self.reviewWidget.overlayAction)
         diffMenu.addAction(self.reviewWidget.invertOverlayColorAction)
         diffMenu.addAction(self.reviewWidget.toggleSideBySideAction)
         diffgrp = qw.QActionGroup(self)
         diffgrp.addAction(self.reviewWidget.showDifferenceAction)
         diffgrp.addAction(self.reviewWidget.showNewAction)
         diffgrp.addAction(self.reviewWidget.showNoneAction)
+        diffgrp.addAction(self.reviewWidget.setJumpThresholdAction)
         diffgrp.setExclusive(True)
         diffMenu.addActions(diffgrp.actions())
 
         viewMenu = self.menuBar().addMenu('&View')
         viewMenu.addAction(self.reviewWidget.tieViewsAction)
         viewMenu.addAction(self.reviewWidget.showGrayscaleAction)
         viewMenu.addAction(self.reviewWidget.setColorAction)
@@ -2972,14 +2400,16 @@
         playMenu.addAction(self.reviewWidget.clearExitBreakpointAction)
         playMenu.addSeparator()
         playMenu.addAction(self.reviewWidget.jumpToBreakpointAction)
         playMenu.addAction(self.reviewWidget.jumpNextNewAction)
         playMenu.addAction(self.reviewWidget.jumpPrevNewAction)
         playMenu.addAction(self.reviewWidget.jumpNextChangeAction)
         playMenu.addAction(self.reviewWidget.jumpPrevChangeAction)
+        playMenu.addAction(self.reviewWidget.jumpNextJumpAction)
+        playMenu.addAction(self.reviewWidget.jumpPrevJumpAction)
 
         actionMenu = self.menuBar().addMenu('Action')
         actionMenu.addActions(
             [
                 self.reviewWidget.swapTracksAction,
                 self.reviewWidget.swapTracksCurAction,
                 self.reviewWidget.swapTracksRangeAction,
@@ -3007,16 +2437,26 @@
         self.setDebug(v == logging.DEBUG)
         self.debugAction.setChecked(v == logging.DEBUG)
         self.debugAction.triggered.connect(self.setDebug)
         actionMenu.addAction(self.debugAction)
 
         helpMenu = self.menuBar().addMenu('Help')
         aboutAction = helpMenu.addAction('&About')
+        aboutAction.setIcon(
+            self.style().standardIcon(
+                qw.QStyle.StandardPixmap.SP_MessageBoxInformation
+            )
+        )
         aboutAction.triggered.connect(displayAbout)
         docAction = helpMenu.addAction('Documentation')
+        docAction.setIcon(
+            self.style().standardIcon(
+                qw.QStyle.StandardPixmap.SP_MessageBoxQuestion
+            )
+        )
         docAction.triggered.connect(displayDoc)
         helpMenu.addAction(self.reviewWidget.vidinfoAction)
 
         toolbar = self.addToolBar('View')
         toolbar.addActions(
             [
                 self.reviewWidget.zoomInLeftAction,
@@ -3040,14 +2480,16 @@
         self.sigQuit.connect(self.reviewWidget.doQuit)
         self.statusLabel = qw.QLabel()
         self.reviewWidget.sigDiffMessage.connect(self.statusLabel.setText)
         self.statusBar().addWidget(self.statusLabel)
         self.posLabel = qw.QLabel()
         self.statusBar().addPermanentWidget(self.posLabel)
         self.reviewWidget.sigMousePosMessage.connect(self.posLabel.setText)
+        # make sure to show change list at first
+        self.reviewWidget.showChangeListAction.trigger()
         self.setCentralWidget(self.reviewWidget)
 
     @qc.pyqtSlot(bool)
     def setDebug(self, val: bool):
         level = logging.DEBUG if val else logging.INFO
         logging.getLogger().setLevel(level)
         settings.setValue('review/debug', level)
```

### Comparing `argos_toolkit-0.1.3.post3/argos/segment.py` & `argos_toolkit-0.2.0/argos/segment.py`

 * *Files identical despite different names*

### Comparing `argos_toolkit-0.1.3.post3/argos/segwidget.py` & `argos_toolkit-0.2.0/argos/segwidget.py`

 * *Files 4% similar despite different names*

```diff
@@ -5,54 +5,56 @@
 """Classical image-processing-based segmentation"""
 
 import logging
 from collections import OrderedDict
 import time
 import numpy as np
 import cv2
-from PyQt5 import (
-    QtWidgets as qw,
-    QtCore as qc,
-    QtGui as qg
-)
+from PyQt5 import QtWidgets as qw, QtCore as qc, QtGui as qg
 
 import argos.constants as consts
 from argos import utility as ut
 from argos.frameview import FrameView
 from argos.segment import (
     segment_by_dbscan,
     segment_by_contours,
     segment_by_contour_bbox,
     segment_by_watershed,
     extract_valid,
-    get_bounding_poly
+    get_bounding_poly,
 )
 
 settings = ut.init()
 
-segstep_dict = OrderedDict([
-    ('Blurred', consts.SegStep.blur),
-    ('Thresholded', consts.SegStep.threshold),
-    ('Segmented', consts.SegStep.segmented),
-    ('Filtered', consts.SegStep.filtered),
-])
-
-segmethod_dict = OrderedDict([
-    ('Threshold', consts.SegmentationMethod.threshold),
-    ('Contour', consts.SegmentationMethod.contour),
-    ('Watershed', consts.SegmentationMethod.watershed),
-    ('DBSCAN', consts.SegmentationMethod.dbscan)
-])
-
-outline_dict = OrderedDict([
-    ('bbox', ut.OutlineStyle.bbox),
-    ('minrect', ut.OutlineStyle.minrect),
-    ('contour', ut.OutlineStyle.contour),
-    ('fill', ut.OutlineStyle.fill)
-])
+segstep_dict = OrderedDict(
+    [
+        ('Blurred', consts.SegStep.blur),
+        ('Thresholded', consts.SegStep.threshold),
+        ('Segmented', consts.SegStep.segmented),
+        ('Filtered', consts.SegStep.filtered),
+    ]
+)
+
+segmethod_dict = OrderedDict(
+    [
+        ('Threshold', consts.SegmentationMethod.threshold),
+        ('Contour', consts.SegmentationMethod.contour),
+        ('Watershed', consts.SegmentationMethod.watershed),
+        ('DBSCAN', consts.SegmentationMethod.dbscan),
+    ]
+)
+
+outline_dict = OrderedDict(
+    [
+        ('bbox', ut.OutlineStyle.bbox),
+        ('minrect', ut.OutlineStyle.minrect),
+        ('contour', ut.OutlineStyle.contour),
+        ('fill', ut.OutlineStyle.fill),
+    ]
+)
 
 
 class SegWorker(qc.QObject):
     """Worker class for carrying out segmentation.
 
     This class provides access to three different segmentation methods:
 
@@ -112,20 +114,23 @@
         deciding best parameters for various steps in the segmentation process.
 
     cmap: int, cv2 colormap
         Colormap for converting label image from grayscale to RGB for better
         visualization of intermediate segmentation result.
 
     """
+
     # bboxes of segmented objects and frame no.
     sigProcessed = qc.pyqtSignal(np.ndarray, int)
     # outlines of segmented objects and frame no.
     sigSegPolygons = qc.pyqtSignal(dict, int)
     # intermediate processed image and frame no.
     sigIntermediate = qc.pyqtSignal(np.ndarray, int)
+    # settings changed, ask to rerun segmentation pipeline
+    sigSettingsChanged = qc.pyqtSignal()
 
     def __init__(self, mode=ut.OutlineStyle.bbox):
         super(SegWorker, self).__init__()
         self.outline_style = mode
         # blurring parameters
         self.kernel_width = 7
         self.kernel_sd = 1.0
@@ -157,123 +162,141 @@
     @qc.pyqtSlot(ut.OutlineStyle)
     def setOutlineStyle(self, mode: ut.OutlineStyle) -> None:
         self.outline_style = mode
 
     @qc.pyqtSlot(consts.SegStep)
     def setIntermediateOutput(self, step: consts.SegStep) -> None:
         self.intermediate = step
+        self.sigSettingsChanged.emit()
 
     @qc.pyqtSlot(int)
     def setBlurWidth(self, width: int) -> None:
         if width % 2 == 0:
             width += 1
         settings.setValue('segment/blur_width', width)
         self.kernel_width = width
+        self.sigSettingsChanged.emit()
 
     @qc.pyqtSlot(float)
     def setBlurSigma(self, sigma: float) -> None:
         settings.setValue('segment/blur_sd', sigma)
         self.kernel_sd = sigma
+        self.sigSettingsChanged.emit()
 
     @qc.pyqtSlot(int)
     def setInvertThreshold(self, invert: int) -> None:
         settings.setValue('segment/thresh_invert', invert)
         self.invert = invert
+        self.sigSettingsChanged.emit()
 
     @qc.pyqtSlot(int)
     def setThresholdMethod(self, method: int) -> None:
         if method == cv2.ADAPTIVE_THRESH_GAUSSIAN_C:
             settings.setValue('segment/thresh_method', 'gaussian')
         else:
             settings.setValue('segment/thresh_method', 'mean')
         self.thresh_method = method
+        self.sigSettingsChanged.emit()
 
     @qc.pyqtSlot(int)
     def setMaxIntensity(self, value: int) -> None:
-        settings.setValue('segment/thresh_max_intensity',
-                          value)
+        settings.setValue('segment/thresh_max_intensity', value)
         self.max_intensity = value
+        self.sigSettingsChanged.emit()
 
     @qc.pyqtSlot(int)
     def setBaseline(self, value: int) -> None:
         settings.setValue('segment/thresh_baseline', value)
         self.baseline = value
+        self.sigSettingsChanged.emit()
 
     @qc.pyqtSlot(int)
     def setBlockSize(self, value: int) -> None:
         if value % 2 == 0:
             self.block_size = value + 1
         else:
             self.block_size = value
         settings.setValue('segment/thresh_blocksize', self.block_size)
+        self.sigSettingsChanged.emit()
 
     @qc.pyqtSlot(consts.SegmentationMethod)
-    def setSegmentationMethod(self,
-                              method: consts.SegmentationMethod) -> None:
+    def setSegmentationMethod(self, method: consts.SegmentationMethod) -> None:
         if method == consts.SegmentationMethod.dbscan:
             settings.setValue('segment/method', 'DBSCAN')
         elif method == consts.SegmentationMethod.watershed:
             settings.setValue('segment/method', 'Watershed')
         else:
             settings.setValue('segment/method', 'Threshold')
 
         self.seg_method = method
+        self.sigSettingsChanged.emit()
 
     @qc.pyqtSlot(float)
     def setEpsDBSCAN(self, value: int) -> None:
         settings.setValue('segment/dbscan_eps', value)
         self.dbscan_eps = value
+        self.sigSettingsChanged.emit()
 
     @qc.pyqtSlot(int)
     def setMinSamplesDBSCAN(self, value: int) -> None:
         settings.setValue('segment/dbscan_minsamples', value)
         self.dbscan_min_samples = value
+        self.sigSettingsChanged.emit()
 
     @qc.pyqtSlot(float)
     def setDistThreshWatershed(self, value: float) -> None:
         settings.setValue('segment/watershed_distthresh', value)
         self.wdist_thresh = value
+        self.sigSettingsChanged.emit()
 
     @qc.pyqtSlot(int)
     def setMinPixels(self, value: int) -> None:
         settings.setValue('segment/min_pixels', value)
         self.pmin = value
+        self.sigSettingsChanged.emit()
 
     @qc.pyqtSlot(int)
     def setMaxPixels(self, value: int) -> None:
         settings.setValue('segment/max_pixels', value)
         self.pmax = value
+        self.sigSettingsChanged.emit()
 
     @qc.pyqtSlot(int)
     def setMinWidth(self, value: int) -> None:
         settings.setValue('segment/min_width', value)
         self.wmin = value
+        self.sigSettingsChanged.emit()
 
     @qc.pyqtSlot(int)
     def setMaxWidth(self, value: int) -> None:
         settings.setValue('segment/max_width', value)
         self.wmax = value
+        self.sigSettingsChanged.emit()
 
     @qc.pyqtSlot(int)
     def setMinHeight(self, value: int) -> None:
         settings.setValue('segment/min_height', value)
         self.hmin = value
+        self.sigSettingsChanged.emit()
 
     @qc.pyqtSlot(int)
     def setMaxHeight(self, value: int) -> None:
         settings.setValue('segment/max_height', value)
         self.hmax = value
+        self.sigSettingsChanged.emit()
 
     @qc.pyqtSlot(qg.QPolygonF)
     def setRoi(self, roi: qg.QPolygonF):
         self.roi = roi
+        self.sigSettingsChanged.emit()
 
     @qc.pyqtSlot()
     def resetRoi(self):
         self.roi = None
+        self.sigSettingsChanged.emit()
 
     @qc.pyqtSlot(np.ndarray, int)
     def process(self, image: np.ndarray, pos: int) -> None:
         """Segment image
 
         Parameters
         ----------
@@ -296,111 +319,137 @@
         with different color values for each segmented object.
         """
         _ts = time.perf_counter()
         gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
         gray = cv2.GaussianBlur(
             gray,
             ksize=(self.kernel_width, self.kernel_width),
-            sigmaX=self.kernel_sd)
+            sigmaX=self.kernel_sd,
+        )
         if self.intermediate == consts.SegStep.blur:
             self.sigIntermediate.emit(gray, pos)
         if self.invert:
             thresh_type = cv2.THRESH_BINARY_INV
         else:
             thresh_type = cv2.THRESH_BINARY
-        binary = cv2.adaptiveThreshold(gray,
-                                       maxValue=self.max_intensity,
-                                       adaptiveMethod=self.thresh_method,
-                                       thresholdType=thresh_type,
-                                       blockSize=self.block_size,
-                                       C=self.baseline)
+        binary = cv2.adaptiveThreshold(
+            gray,
+            maxValue=self.max_intensity,
+            adaptiveMethod=self.thresh_method,
+            thresholdType=thresh_type,
+            blockSize=self.block_size,
+            C=self.baseline,
+        )
         if self.intermediate == consts.SegStep.threshold:
             self.sigIntermediate.emit(binary, pos)
         if self.seg_method == consts.SegmentationMethod.threshold:
             seg = segment_by_contour_bbox(binary)
         elif self.seg_method == consts.SegmentationMethod.contour:
             seg = segment_by_contours(binary)
         elif self.seg_method == consts.SegmentationMethod.dbscan:
-            seg = segment_by_dbscan(binary, self.dbscan_eps,
-                                    self.dbscan_min_samples)
+            seg = segment_by_dbscan(
+                binary, self.dbscan_eps, self.dbscan_min_samples
+            )
         elif self.seg_method == consts.SegmentationMethod.watershed:
-            seg = segment_by_watershed(binary, image,
-                                       self.wdist_thresh)
+            seg = segment_by_watershed(binary, image, self.wdist_thresh)
         if self.intermediate == consts.SegStep.segmented:
             for ii, points in enumerate(seg):
                 binary[points[:, 1], points[:, 0]] = ii + 1
             colored = cv2.applyColorMap(binary, self.cmap)
             for ii, points in enumerate(seg):
                 mr = cv2.minAreaRect(points)[1]
                 width = min(mr)
                 height = max(mr)
                 label = f'{len(points)}px{width:.1f}x{height:.1f}'
-                cv2.putText(colored, label,
-                            (max(points[:, 0]), max(points[:, 1])),
-                            cv2.FONT_HERSHEY_PLAIN, 1.0, (255, 0, 0))
+                cv2.putText(
+                    colored,
+                    label,
+                    (max(points[:, 0]), max(points[:, 1])),
+                    cv2.FONT_HERSHEY_PLAIN,
+                    1.0,
+                    (255, 0, 0),
+                )
             self.sigIntermediate.emit(colored, pos)
-        seg = extract_valid(seg, self.pmin, self.pmax, self.wmin, self.wmax,
-                            self.hmin, self.hmax, roi=self.roi)
+        seg = extract_valid(
+            seg,
+            self.pmin,
+            self.pmax,
+            self.wmin,
+            self.wmax,
+            self.hmin,
+            self.hmax,
+            roi=self.roi,
+        )
         if self.intermediate == consts.SegStep.filtered:
             for ii, points in enumerate(seg):
                 binary[points[:, 1], points[:, 0]] = ii + 1
             filtered = cv2.applyColorMap(binary, self.cmap)
             for ii, points in enumerate(seg):
                 mr = cv2.minAreaRect(points)[1]
                 width = min(mr)
                 height = max(mr)
                 label = f'{len(points)}px{width:.1f}x{height:.1f}'
-                cv2.putText(filtered, label,
-                            (max(points[:, 0]), max(points[:, 1])),
-                            cv2.FONT_HERSHEY_PLAIN, 0.5, (255, 0, 0))
+                cv2.putText(
+                    filtered,
+                    label,
+                    (max(points[:, 0]), max(points[:, 1])),
+                    cv2.FONT_HERSHEY_PLAIN,
+                    0.5,
+                    (255, 0, 0),
+                )
             self.sigIntermediate.emit(filtered, pos)
         bboxes = [cv2.boundingRect(points) for points in seg]
         if self.outline_style == ut.OutlineStyle.bbox:
             self.sigProcessed.emit(np.array(bboxes), pos)
             # logging.debug(f'Emitted bboxes for frame {pos}: {bboxes}')
         elif self.outline_style == ut.OutlineStyle.contour:
             if self.seg_method == consts.SegmentationMethod.threshold:
                 contours = {ii: contour for ii, contour in enumerate(seg)}
             else:
                 contours = get_bounding_poly(seg, ut.OutlineStyle.contour)
                 contours = {ii: contour for ii, contour in enumerate(contours)}
             self.sigSegPolygons.emit(contours, pos)
 
         elif self.outline_style == ut.OutlineStyle.minrect:
-            minrects = [cv2.boxPoints(cv2.minAreaRect(points)) for points in
-                        seg]
+            minrects = [
+                cv2.boxPoints(cv2.minAreaRect(points)) for points in seg
+            ]
             minrects = {ii: box for ii, box in enumerate(minrects)}
             self.sigSegPolygons.emit(minrects, pos)
         elif self.outline_style == ut.OutlineStyle.fill:
             filled = {ii: points for ii, points in enumerate(seg)}
             self.sigSegPolygons.emit(filled, pos)
 
         _dt = time.perf_counter() - _ts
-        logging.debug(f'{__name__}.{self.__class__.__name__}.process: Runtime: {_dt}s')
+        logging.debug(
+            f'{__name__}.{self.__class__.__name__}.process: Runtime: {_dt}s'
+        )
+
 
-        
 class SegWidget(qw.QWidget):
     """Widget for classical segmentation.
 
     Provides controls for parameters used in segmentation.
     """
+
     # pass on the signal from worker
     sigProcessed = qc.pyqtSignal(np.ndarray, int)
     # pass on the signal from worker
     sigSegPolygons = qc.pyqtSignal(dict, int)
     # pass on the image to worker
     sigProcess = qc.pyqtSignal(np.ndarray, int)
 
     sigSetOutlineStyle = qc.pyqtSignal(ut.OutlineStyle)
 
     sigThreshMethod = qc.pyqtSignal(int)
     sigSegMethod = qc.pyqtSignal(consts.SegmentationMethod)
     sigIntermediateOutput = qc.pyqtSignal(consts.SegStep)
     # sigIntermediateWindowClosed = qc.pyqtSignal()
     sigQuit = qc.pyqtSignal()
+    sigSettingsChanged = qc.pyqtSignal()
 
     setWmin = qc.pyqtSignal(int)
     setWmax = qc.pyqtSignal(int)
     setHmin = qc.pyqtSignal(int)
     setHmax = qc.pyqtSignal(int)
     setRoi = qc.pyqtSignal(qg.QPolygonF)
     resetRoi = qc.pyqtSignal()
@@ -409,182 +458,198 @@
         super(SegWidget, self).__init__(*args, **kwargs)
         self.worker = SegWorker()
         layout = qw.QFormLayout()
         self._blur_width_label = qw.QLabel('Blur width')
         self._blur_width_edit = qw.QSpinBox()
         self._blur_width_edit.setRange(1, 999)
         self._blur_width_edit.setSingleStep(2)
-        value = settings.value('segment/blur_width', self.worker.kernel_width,
-                               type=int)
+        value = settings.value(
+            'segment/blur_width', self.worker.kernel_width, type=int
+        )
         self._blur_width_edit.setValue(value)
         self.worker.kernel_width = value
         layout.addRow(self._blur_width_label, self._blur_width_edit)
         self._blur_sd_label = qw.QLabel('Blur sd')
         self._blur_sd_edit = qw.QDoubleSpinBox()
         self._blur_sd_edit.setRange(1, 100)
-        value = settings.value('segment/blur_sd', self.worker.kernel_sd,
-                               type=float)
+        value = settings.value(
+            'segment/blur_sd', self.worker.kernel_sd, type=float
+        )
         self._blur_sd_edit.setValue(value)
         self.worker.kernel_sd = value
         layout.addRow(self._blur_sd_label, self._blur_sd_edit)
         self._invert_label = qw.QLabel('Invert thresholding')
         self._invert_check = qw.QCheckBox()
-        self._invert_check.setToolTip('Check this if the objects of interest'
-                                      ' are darker than background.')
-        value = settings.value('segment/thresh_invert', self.worker.invert,
-                               type=bool)
+        self._invert_check.setToolTip(
+            'Check this if the objects of interest'
+            ' are darker than background.'
+        )
+        value = settings.value(
+            'segment/thresh_invert', self.worker.invert, type=bool
+        )
         self._invert_check.setChecked(value)
         self.worker.invert = value
         layout.addRow(self._invert_label, self._invert_check)
         self._thresh_label = qw.QLabel('Thresholding method')
         self._thresh_method = qw.QComboBox()
         self._thresh_method.addItems(['Adaptive Gaussian', 'Adaptive Mean'])
         layout.addRow(self._thresh_label, self._thresh_method)
         self._maxint_label = qw.QLabel('Threshold maximum intensity')
         self._maxint_edit = qw.QSpinBox()
         self._maxint_edit.setRange(0, 255)
-        value = settings.value('segment/thresh_max_intensity',
-                               self.worker.max_intensity, type=int)
+        value = settings.value(
+            'segment/thresh_max_intensity', self.worker.max_intensity, type=int
+        )
         self.worker.max_intensity = value
         self._maxint_edit.setValue(value)
         layout.addRow(self._maxint_label, self._maxint_edit)
         self._baseline_label = qw.QLabel('Threshold baseline')
         self._baseline_edit = qw.QSpinBox()
         self._baseline_edit.setRange(0, 255)
-        self._baseline_edit.setToolTip('This value is subtracted from the'
-                                       ' (weighted) mean pixel value in the'
-                                       ' neighborhood of a pixel to get the'
-                                       ' threshold value at that pixel.')
-        value = settings.value('segment/thresh_baseline', self.worker.baseline,
-                               type=int)
+        self._baseline_edit.setToolTip(
+            'This value is subtracted from the'
+            ' (weighted) mean pixel value in the'
+            ' neighborhood of a pixel to get the'
+            ' threshold value at that pixel.'
+        )
+        value = settings.value(
+            'segment/thresh_baseline', self.worker.baseline, type=int
+        )
         self._baseline_edit.setValue(value)
         self.worker.baseline = value
         layout.addRow(self._baseline_label, self._baseline_edit)
         self._blocksize_label = qw.QLabel('Thresholding block size')
         self._blocksize_edit = qw.QSpinBox()
         self._blocksize_edit.setRange(3, 501)
         self._blocksize_edit.setSingleStep(2)
-        self._blocksize_edit.setToolTip('Adapaive thresholding block size. Size'
-                                        ' of neighborhood for computing local'
-                                        ' threshold at each pixel. Should be'
-                                        ' odd number >= 3.')
-        value = settings.value('segment/thresh_blocksize',
-                               self.worker.block_size,
-                               type=int)
+        self._blocksize_edit.setToolTip(
+            'Adapaive thresholding block size. Size'
+            ' of neighborhood for computing local'
+            ' threshold at each pixel. Should be'
+            ' odd number >= 3.'
+        )
+        value = settings.value(
+            'segment/thresh_blocksize', self.worker.block_size, type=int
+        )
         if value % 2 == 0:
             value += 1
         self.worker.block_size = value
         self._blocksize_edit.setValue(value)
         layout.addRow(self._blocksize_label, self._blocksize_edit)
         self._seg_label = qw.QLabel('Segmentation method')
         self._seg_method = qw.QComboBox()
         self._seg_method.addItems(segmethod_dict.keys())
 
         layout.addRow(self._seg_label, self._seg_method)
         self._dbscan_minsamples_label = qw.QLabel('DBSCAN minimum samples')
         self._dbscan_minsamples = qw.QSpinBox()
         self._dbscan_minsamples.setRange(1, 10000)
-        value = settings.value('segment/dbscan_minsamples',
-                               self.worker.dbscan_min_samples,
-                               type=int)
+        value = settings.value(
+            'segment/dbscan_minsamples',
+            self.worker.dbscan_min_samples,
+            type=int,
+        )
         self._dbscan_minsamples.setValue(value)
         self.worker.dbscan_min_samples = value
         layout.addRow(self._dbscan_minsamples_label, self._dbscan_minsamples)
         self._dbscan_eps_label = qw.QLabel('DBSCAN epsilon')
         self._dbscan_eps = qw.QDoubleSpinBox()
         self._dbscan_eps.setRange(0.1, 100)
         try:
             # setStepType was added in Qt v 5.12 only
             self._dbscan_eps.setStepType(
-                qw.QAbstractSpinBox.AdaptiveDecimalStepType)
+                qw.QAbstractSpinBox.AdaptiveDecimalStepType
+            )
         except AttributeError:
             pass  # Avoid problem with older Qt versions
-        value = settings.value('segment/dbscan_eps',
-                               self.worker.dbscan_eps,
-                               type=float)
+        value = settings.value(
+            'segment/dbscan_eps', self.worker.dbscan_eps, type=float
+        )
         self._dbscan_eps.setValue(value)
         self.worker.dbscan_eps = value
         layout.addRow(self._dbscan_eps_label, self._dbscan_eps)
         self._pmin_label = qw.QLabel('Minimum pixels')
         self._pmin_edit = qw.QSpinBox()
         self._pmin_edit.setRange(1, 10000)
-        value = settings.value('segment/min_pixels',
-                               self.worker.pmin,
-                               type=int)
+        value = settings.value(
+            'segment/min_pixels', self.worker.pmin, type=int
+        )
         self._pmin_edit.setValue(value)
         self.worker.pmin = value
         layout.addRow(self._pmin_label, self._pmin_edit)
         self._pmax_label = qw.QLabel('Maximum pixels')
         self._pmax_edit = qw.QSpinBox()
         self._pmax_edit.setRange(1, 10000)
-        value = settings.value('segment/max_pixels',
-                               self.worker.pmax,
-                               type=int)
+        value = settings.value(
+            'segment/max_pixels', self.worker.pmax, type=int
+        )
         self._pmax_edit.setValue(value)
         self.worker.pmax = value
         layout.addRow(self._pmax_label, self._pmax_edit)
         # self._wmin_label = qw.QLabel('Minimum width')
         # self._wmin_edit = qw.QSpinBox()
         # self._wmin_edit.setRange(1, 1000)
-        value = settings.value('segment/min_width',
-                               self.worker.wmin,
-                               type=int)
+        value = settings.value('segment/min_width', self.worker.wmin, type=int)
         # self._wmin_edit.setValue(value)
         self.worker.wmin = value
         # layout.addRow(self._wmin_label, self._wmin_edit)
         # self._wmax_label = qw.QLabel('Maximum width')
         # self._wmax_edit = qw.QSpinBox()
         # self._wmax_edit.setRange(1, 1000)
-        value = settings.value('segment/max_width',
-                               self.worker.wmax,
-                               type=int)
+        value = settings.value('segment/max_width', self.worker.wmax, type=int)
         # self._wmax_edit.setValue(value)
         self.worker.wmax = value
         # layout.addRow(self._wmax_label, self._wmax_edit)
         # self._hmin_label = qw.QLabel('Minimum length')
         # self._hmin_edit = qw.QSpinBox()
         # self._hmin_edit.setRange(1, 1000)
-        value = settings.value('segment/min_height',
-                               self.worker.hmin,
-                               type=int)
+        value = settings.value(
+            'segment/min_height', self.worker.hmin, type=int
+        )
         # self._hmin_edit.setValue(value)
         self.worker.hmin = value
         # layout.addRow(self._hmin_label, self._hmin_edit)
         # self._hmax_label = qw.QLabel('Maximum length')
         # self._hmax_edit = qw.QSpinBox()
         # self._hmax_edit.setRange(1, 1000)
-        value = settings.value('segment/max_height',
-                               self.worker.hmax,
-                               type=int)
+        value = settings.value(
+            'segment/max_height', self.worker.hmax, type=int
+        )
         # self._hmax_edit.setValue(value)
         self.worker.hmax = value
         # layout.addRow(self._hmax_label, self._hmax_edit)
         self._wdist_label = qw.QLabel('Distance threshold')
         self._wdist = qw.QDoubleSpinBox()
         self._wdist.setRange(0, 10)
         try:
-            self._wdist.setStepType(qw.QAbstractSpinBox.AdaptiveDecimalStepType)
+            self._wdist.setStepType(
+                qw.QAbstractSpinBox.AdaptiveDecimalStepType
+            )
         except AttributeError:
             pass
         self._wdist.setSingleStep(0.1)
-        value = settings.value('segment/watershed_distthresh',
-                               self.worker.wdist_thresh,
-                               type=float)
+        value = settings.value(
+            'segment/watershed_distthresh',
+            self.worker.wdist_thresh,
+            type=float,
+        )
         self._wdist.setValue(value)
         self.worker.wdist_thresh = value
-        self._wdist.setToolTip('Distance threshold for Watershed segmentation.'
-                               ' This is used for finding foreground areas in'
-                               ' the thresholded image. The pixels which are at'
-                               ' least this much (in pixel units) away from all'
-                               ' background pixels, are considered to be part'
-                               ' of the foreground.\n'
-                               ' If set between 0 and 1, it is assumed to be'
-                               ' the fraction of maximum of the distances of'
-                               ' each pixel from a zero-valued pixel in the'
-                               ' thresholded image.')
+        self._wdist.setToolTip(
+            'Distance threshold for Watershed segmentation.'
+            ' This is used for finding foreground areas in'
+            ' the thresholded image. The pixels which are at'
+            ' least this much (in pixel units) away from all'
+            ' background pixels, are considered to be part'
+            ' of the foreground.\n'
+            ' If set between 0 and 1, it is assumed to be'
+            ' the fraction of maximum of the distances of'
+            ' each pixel from a zero-valued pixel in the'
+            ' thresholded image.'
+        )
         layout.addRow(self._wdist_label, self._wdist)
         self.showIntermediateAction = qw.QAction('Show intermediate result')
         self.showIntermediateAction.setCheckable(True)
         self._intermediate_button = qw.QToolButton(self)
         self._intermediate_button.setDefaultAction(self.showIntermediateAction)
         self._intermediate_combo = qw.QComboBox()
         self._intermediate_combo.addItems(segstep_dict.keys())
@@ -594,32 +659,40 @@
         self.outlineCombo = qw.QComboBox()
         self.outlineCombo.addItems(list(outline_dict.keys()))
         self.outlineCombo.currentTextChanged.connect(self.setOutlineStyle)
         layout.addRow(self._outline_label, self.outlineCombo)
 
         self.setLayout(layout)
 
-        self._intermediate_win = FrameView()        
+        self._intermediate_win = FrameView()
         self._intermediate_win.scene().disableDrawing(True)
         self.resetRoi.connect(self._intermediate_win.resetArenaAction.trigger)
-        flags = qc.Qt.WindowFlags(qc.Qt.CustomizeWindowHint +
-                                  qc.Qt.WindowStaysOnTopHint +
-                                  qc.Qt.WindowTitleHint +
-                                  qc.Qt.WindowMinMaxButtonsHint +
-                                  qc.Qt.WindowCloseButtonHint)
+        flags = qc.Qt.WindowFlags(
+            qc.Qt.CustomizeWindowHint
+            + qc.Qt.WindowStaysOnTopHint
+            + qc.Qt.WindowTitleHint
+            + qc.Qt.WindowMinMaxButtonsHint
+            + qc.Qt.WindowCloseButtonHint
+        )
         self._intermediate_win.setWindowFlags(flags)
-        self._intermediate_win.sigClosed.connect(self._intermediate_button.toggle)
+        self._intermediate_win.sigClosed.connect(
+            self._intermediate_button.toggle
+        )
         self._intermediate_win.hide()
 
         # Housekeeping - widgets to be shown or hidden based on choice of method
         self._seg_param_widgets = {
             'Threshold': [],
-            'DBSCAN': [self._dbscan_eps, self._dbscan_minsamples,
-                       self._dbscan_minsamples_label, self._dbscan_eps_label],
-            'Watershed': [self._wdist_label, self._wdist]
+            'DBSCAN': [
+                self._dbscan_eps,
+                self._dbscan_minsamples,
+                self._dbscan_minsamples_label,
+                self._dbscan_eps_label,
+            ],
+            'Watershed': [self._wdist_label, self._wdist],
         }
 
         value = settings.value('segment/method', 'Threshold', type=str)
         self.worker.seg_method = segmethod_dict[value]
         self._seg_method.setCurrentText(value)
         self.setSegmentationMethod(value)
         ###################################
@@ -636,42 +709,45 @@
         self._maxint_edit.valueChanged.connect(self.worker.setMaxIntensity)
         self._baseline_edit.valueChanged.connect(self.worker.setBaseline)
         self._blocksize_edit.valueChanged.connect(self.worker.setBlockSize)
         self._seg_method.currentTextChanged.connect(self.setSegmentationMethod)
         self.sigThreshMethod.connect(self.worker.setThresholdMethod)
         self.sigSegMethod.connect(self.worker.setSegmentationMethod)
         self._dbscan_minsamples.valueChanged.connect(
-            self.worker.setMinSamplesDBSCAN)
-        self._dbscan_eps.valueChanged.connect(
-            self.worker.setEpsDBSCAN
+            self.worker.setMinSamplesDBSCAN
         )
+        self._dbscan_eps.valueChanged.connect(self.worker.setEpsDBSCAN)
         self._pmin_edit.valueChanged.connect(self.worker.setMinPixels)
         self._pmax_edit.valueChanged.connect(self.worker.setMaxPixels)
         # self._wmin_edit.valueChanged.connect(self.worker.setMinWidth)
         # self._wmax_edit.valueChanged.connect(self.worker.setMaxWidth)
         # self._hmin_edit.valueChanged.connect(self.worker.setMinHeight)
         # self._hmax_edit.valueChanged.connect(self.worker.setMaxHeight)
         self.setWmin.connect(self.worker.setMinWidth)
         self.setWmax.connect(self.worker.setMaxWidth)
         self.setHmin.connect(self.worker.setMinHeight)
         self.setHmax.connect(self.worker.setMaxHeight)
         self.setRoi.connect(self.worker.setRoi)
         self.resetRoi.connect(self.worker.resetRoi)
         self._wdist.valueChanged.connect(self.worker.setDistThreshWatershed)
         self._intermediate_combo.currentTextChanged.connect(
-            self.setIntermediateOutput)
+            self.setIntermediateOutput
+        )
         self.sigIntermediateOutput.connect(self.worker.setIntermediateOutput)
-        self.showIntermediateAction.triggered.connect(self.showIntermediateOutput)
+        self.showIntermediateAction.triggered.connect(
+            self.showIntermediateOutput
+        )
         self.sigProcess.connect(self.worker.process)
         self.sigSetOutlineStyle.connect(self.worker.setOutlineStyle)
         self.worker.sigProcessed.connect(self.sigProcessed)
         self.worker.sigSegPolygons.connect(self.sigSegPolygons)
         self.worker.sigIntermediate.connect(self._intermediate_win.setFrame)
         self.sigQuit.connect(self.saveSettings)
         self.sigQuit.connect(self._intermediate_win.close)
+        self.worker.sigSettingsChanged.connect(self.sigSettingsChanged)
         ###################
         # Thread setup
         self.sigQuit.connect(self.thread.quit)
         self.thread.finished.connect(self.thread.deleteLater)
         self.thread.start()
 
     def setOutlineStyle(self, style: str) -> None:
@@ -718,33 +794,36 @@
             self._intermediate_combo.setCurrentText('Final')
             self.sigIntermediateOutput.emit(consts.SegStep.final)
             self._intermediate_win.hide()
 
     @qc.pyqtSlot()
     def hideIntermediateOutput(self):
         self.showIntermediateOutput(False)
-        self._intermediate_button.setChecked(False)        
+        self._intermediate_button.setChecked(False)
 
     @qc.pyqtSlot()
     def saveSettings(self):
         """Save the worker parameters"""
         settings.setValue('segment/blur_width', self.worker.kernel_width)
         settings.setValue('segment/blur_sd', self.worker.kernel_sd)
         settings.setValue('segment/thresh_invert', self.worker.invert)
-        settings.setValue('segment/thresh_max_intensity',
-                          self.worker.max_intensity)
+        settings.setValue(
+            'segment/thresh_max_intensity', self.worker.max_intensity
+        )
         settings.setValue('segment/thresh_baseline', self.worker.baseline)
         settings.setValue('segment/thresh_blocksize', self.worker.block_size)
-        settings.setValue('segment/dbscan_minsamples',
-                          self.worker.dbscan_min_samples)
+        settings.setValue(
+            'segment/dbscan_minsamples', self.worker.dbscan_min_samples
+        )
         settings.setValue('segment/dbscan_eps', self.worker.dbscan_eps)
         settings.setValue('segment/min_pixels', self.worker.pmin)
         settings.setValue('segment/max_pixels', self.worker.pmax)
-        settings.setValue('segment/watershed_distthresh',
-                          self.worker.wdist_thresh)
+        settings.setValue(
+            'segment/watershed_distthresh', self.worker.wdist_thresh
+        )
 
     def loadConfig(self, config):
         """TODO implement loading of configuration from YAML/dict"""
         raise NotImplementedError('This method is yet to be implemented')
         if 'blur_width' in config:
             self._blur_width_edit.setValue(config['blur_width'])
         if 'blur_sd' in config:
```

### Comparing `argos_toolkit-0.1.3.post3/argos/test_ccap.py` & `argos_toolkit-0.2.0/argos/test_ccap.py`

 * *Files identical despite different names*

### Comparing `argos_toolkit-0.1.3.post3/argos/test_tracker.py` & `argos_toolkit-0.2.0/argos/test_tracker.py`

 * *Files identical despite different names*

### Comparing `argos_toolkit-0.1.3.post3/argos/utility.py` & `argos_toolkit-0.2.0/argos/utility.py`

 * *Files 5% similar despite different names*

```diff
@@ -285,15 +285,15 @@
     bool
         `True` if the centres of mass (mean position) of `points_a` and
         `points_b` are closer than `min_dist`, `False` otherwise.
     """
     sigma = np.std(points_a, axis=0) * np.std(points_b, axis=0)
     dx2 = (np.mean(points_a[:, 0]) - np.mean(points_b[:, 0])) ** 2 / sigma[0]
     dy2 = (np.mean(points_a[:, 1]) - np.mean(points_b[:, 1])) ** 2 / sigma[1]
-    return dx2 + dy2 < min_dist ** 2
+    return dx2 + dy2 < min_dist**2
 
 
 def cv2qimage(frame: np.ndarray, copy: bool = False) -> qg.QImage:
     """Convert BGR/gray/bw frame from array into QImage".
 
     OpenCV reads images into 2D or 3D matrix. This function converts it into
     Qt QImage.
@@ -321,14 +321,42 @@
             frame.tobytes(), w, h, w * 1, qg.QImage.Format_Grayscale8
         )
     if copy:
         return qimg.copy()
     return qimg
 
 
+def vec_rect_intersection(ra, rb):
+    """Vectorized rectangle intersection.
+
+    Parameters
+    ----------
+    ra: np.ndarray
+        Coordinates of a single rectangle as 1D array, xywh format
+    rb: np.ndarray
+        Coordinates of other rectangles, one in each row, xywh format
+
+    Returns
+    -------
+    np.ndarray:
+        Intersections of ra with rectangles in rbvec with
+        columns (x, y, dx, dy). If no intersection, dx or dy <= 0
+    """
+    result = np.zeros(len(rb), dtype=np.int32)
+    result[:, 0] = np.maximum(ra[0], rb[:, 0])
+    result[:, 1] = np.maximum(ra[1], rb[:, 1])
+    result[:, 2] = (
+        np.minimum(ra[0] + ra[2], rb[:, 0] + rb[:, 2]) - result[:, 0]
+    )
+    result[:, 3] = (
+        np.minimum(ra[1] + ra[3], rb[:, 1] + rb[:, 3]) - result[:, 1]
+    )
+    return result
+
+
 # Try to import cython version of these functions, otherwise define them in
 # pure python
 try:
     # import pyximport
 
     # pyximport.install(setup_args={"include_dirs": np.get_include()},
     #                  reload_support=True)
@@ -516,15 +544,15 @@
 
         Returns
         --------
         np.ndarray
             Row ``ii``, column ``jj`` contains the computed distance between
             ``new_bboxes[ii]`` and ``bboxes[jj]``.
         """
-        dist = np.zeros((new_bboxes.shape[0], bboxes.shape[0]), dtype=np.float)
+        dist = np.zeros((new_bboxes.shape[0], bboxes.shape[0]), dtype=float)
         if metric == DistanceMetric.euclidean:
             centers = bboxes[:, :2] + bboxes[:, 2:] * 0.5
             new_centers = new_bboxes[:, :2] + new_bboxes[:, 2:] * 0.5
             for ii in range(len(new_bboxes)):
                 for jj in range(len(bboxes)):
                     dist[ii, jj] = np.sum((new_centers[ii] - centers[jj]) ** 2)
         elif metric == DistanceMetric.iou:
@@ -679,37 +707,35 @@
     int_rgb = (max(0, min(255, floor(v * 256))) for v in rgba[:3])
     return int_rgb
 
 
 def extract_frames(vidfile, nframes, scale=1.0, outdir='.', random=False):
     """Extract `nframes` frames from `vidfile` into `outdir`"""
     cap = cv2.VideoCapture(vidfile)
+    if not cap.isOpened():
+        raise Exception(f'Could not open file {vidfile}')
     fname = os.path.basename(vidfile)
     prefix = fname.rpartition('.')[0]
     frame_count = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
     idx = np.arange(frame_count, dtype=int)
-    if frame_count < nframes:
+    print('Frame count', frame_count, ', extracting', nframes)
+    if frame_count > nframes:
         if random:
             np.random.shuffle(idx)
             idx = idx[:nframes]
         else:
             step = frame_count // nframes
             idx = idx[::step]
     idx = sorted(idx)
     ii = 0
-    jj = 0
-    while cap.isOpened():
+    for ii in idx:
+        cap.set(cv2.CAP_PROP_POS_FRAMES, ii - 1)
         ret, frame = cap.read()
         if frame is None:
             break
-        if idx[jj] == ii:
-            size = (int(frame.shape[1] * scale), int(frame.shape[0] * scale))
-            if scale < 1:
-                frame = cv2.resize(frame, size, cv2.INTER_AREA)
-            elif scale > 1:
-                frame = cv2.resize(frame, size, cv2.INTER_CUBIC)
-            cv2.imwrite(
-                os.path.join(outdir, f'{prefix}_{idx[jj]:06d}.png'), frame
-            )
-            jj += 1
-        ii += 1
+        size = (int(frame.shape[1] * scale), int(frame.shape[0] * scale))
+        if scale < 1:
+            frame = cv2.resize(frame, size, cv2.INTER_AREA)
+        elif scale > 1:
+            frame = cv2.resize(frame, size, cv2.INTER_CUBIC)
+        cv2.imwrite(os.path.join(outdir, f'{prefix}_{ii:06d}.png'), frame)
     cap.release()
```

### Comparing `argos_toolkit-0.1.3.post3/argos/vreader.py` & `argos_toolkit-0.2.0/argos/vreader.py`

 * *Files identical despite different names*

### Comparing `argos_toolkit-0.1.3.post3/argos/vwidget.py` & `argos_toolkit-0.2.0/argos/vwidget.py`

 * *Files 1% similar despite different names*

```diff
@@ -242,14 +242,17 @@
                 'video/directory', os.path.dirname(self.video_filename)
             )
             self.currentFrame = -1
             self.startTime = None
         except IOError as err:
             qw.QMessageBox.critical(self, 'Video open failed', str(err))
             return
+        except AssertionError as err:
+            qw.QMessageBox.critical(self, 'Could not open camera', str(err))
+            return
         ## Set-up for saving data
         self.writer = None
         directory = os.path.dirname(self.video_filename)
         filename = writer.makepath(directory, self.video_filename)
         self.outfile, _ = qw.QFileDialog.getSaveFileName(
             self, 'Save data as', filename, 'HDF5 (*.h5 *.hdf);;Text (*.csv)'
         )
@@ -453,15 +456,15 @@
         if play:
             if self.startTime is None:  # indicates video was just initialized
                 print('Starting at first frame')
                 self.sigGotoFrame.emit(0)
             self.startTime = time.perf_counter()
             self.playAction.setText('Pause')
             t = int(np.round(1000.0 / self.video_reader.fps))
-            t = 10 if t < 1 else t
+            t = 10 if t < 1 else t  # too small
             self.timer.start(t)
         else:
             self.pauseVideo()
 
     @qc.pyqtSlot()
     def pauseVideo(self):
         self.playAction.setChecked(False)
```

### Comparing `argos_toolkit-0.1.3.post3/argos/writer.py` & `argos_toolkit-0.2.0/argos/writer.py`

 * *Files 2% similar despite different names*

```diff
@@ -53,16 +53,15 @@
         self._segmented = OrderedDict()
         self._tracked = OrderedDict()
 
 
 class HDFWriter(DataHandler):
     def __init__(self, filename, mode='w'):
         super(HDFWriter, self).__init__(filename, mode)
-        self.data_store = pd.HDFStore(filename, mode=mode,
-                                      complib='blosc')
+        self.data_store = pd.HDFStore(filename, mode=mode, complib='blosc')
 
     def _write(self):
         """
         Not going to append, for even long videos the numbers should be
         small enough to fit in the RAM of a half-decent laptop.
         Writing should happen only at the end.
         """
@@ -84,39 +83,44 @@
             ids = np.array(list(trk.keys()))
             pos = np.array(list(trk.values()))
             data.append(np.c_[[frame_no] * len(trk), ids, pos])
         if len(data) == 0:
             logging.info('No tracking data.')
             return
         data = np.concatenate(data)
-        data = pd.DataFrame(data=data, columns=['frame', 'trackid',
-                                                'x', 'y', 'w', 'h'])
+        data = pd.DataFrame(
+            data=data, columns=['frame', 'trackid', 'x', 'y', 'w', 'h']
+        )
         self.data_store.put(tracked_key, data, format='table', append=False)
 
     @qc.pyqtSlot()
     def close(self):
         if self.data_store.is_open:
             self._write()
             self.data_store.close()
         super(HDFWriter, self).close()
 
     @qc.pyqtSlot()
     def reset(self):
         """Overwrite current files, going back to start."""
         self.close()
-        self.data_store = pd.HDFStore(self.filename,
-                                      mode=self.mode,
-                                      complib='blosc')
-
-    def __del__(self):
-        self.close()
+        self.data_store = pd.HDFStore(
+            self.filename, mode=self.mode, complib='blosc'
+        )
+
+    # def __del__(self):
+    #     try:
+    #         self.close()
+    #     except Exception as e:
+    #         logging.warn('Exception when closing file writer', e)
 
 
 class CSVWriter(DataHandler):
     """Not used any more. Using HDF5 is much faster"""
+
     def __init__(self, filename, mode='w'):
         super(CSVWriter, self).__init__(filename, mode)
         prefix, _, ext = filename.rpartition('.')
         self.seg_filename = f'{prefix}.seg.csv'
         self.track_filename = f'{prefix}.trk.csv'
         self.seg_file = open(self.seg_filename, 'w', newline='')
         self.seg_writer = csv.writer(self.seg_file)
@@ -152,8 +156,8 @@
         self.seg_writer = csv.writer(self.seg_file)
         self.seg_writer.writerow('frame,x,y,w,h'.split(','))
         self.track_file = open(self.track_filename, 'w', newline='')
         self.track_writer = csv.writer(self.track_file)
         self.track_writer.writerow('frame,trackid,x,y,w,h'.split(','))
 
     def __del__(self):
-        self.close()
+        self.close()
```

### Comparing `argos_toolkit-0.1.3.post3/argos/yolactwidget.py` & `argos_toolkit-0.2.0/argos/yolactwidget.py`

 * *Files 1% similar despite different names*

```diff
@@ -27,14 +27,15 @@
 import torch.backends.cudnn as cudnn
 
 from PyQt5 import QtCore as qc, QtWidgets as qw
 
 from yolact import Yolact
 from yolact.data import config as yconfig, get_label_map
 
+
 # This is actually yolact.utils
 from yolact.utils.augmentations import FastBaseTransform
 from yolact.layers import output_utils as oututils
 
 from argos.utility import init, pairwise_distance
 from argos.constants import OutlineStyle, DistanceMetric
 
@@ -195,14 +196,23 @@
                 print('Kept', set(classes.cpu().numpy()))
             idx = scores.argsort(0, descending=True)[: self.top_k]
             # if self.config.eval_mask_branch:
             #     masks = masks[idx]
             classes, scores, boxes = [
                 x[idx].cpu().numpy() for x in (classes, scores, boxes)
             ]
+            logging.debug(
+                '\n'.join(
+                    [
+                        f'\tclass: {c}={self.config.dataset.class_names[c]},'
+                        f'score: {s}, bbox: {b}'
+                        for c, s, b in zip(classes, scores, boxes)
+                    ]
+                )
+            )
             # This is probably not required, `postprocess` uses
             # `score_thresh` already
             num_dets_to_consider = min(self.top_k, classes.shape[0])
             for j in range(num_dets_to_consider):
                 if scores[j] < self.score_threshold:
                     num_dets_to_consider = j
                     break
@@ -228,18 +238,18 @@
                     if dist_matrix[ii, jj] < 1 - self.overlap_thresh
                 ]
                 good_idx = list(set(range(boxes.shape[0])) - set(bad_idx))
                 boxes = boxes[good_idx].copy()
 
             toc = time.perf_counter_ns()
             logging.debug(
-                'Time to process single _image: %f s', 1e-9 * (toc - tic)
+                f'Time to process single _image: {1e-9 * (toc - tic)} s.'
             )
             self.sigProcessed.emit(boxes, pos)
-            logging.debug(f'Emitted bboxes for frame {pos}: {boxes}')
+            logging.debug(f'Emitted bboxes for frame {pos}:\n{boxes}')
         _dt = time.perf_counter() - _ts
         logging.debug(
             f'{__name__}.{self.__class__.__name__}.process: Runtime: {_dt}s'
         )
 
 
 class YolactWidget(qw.QWidget):
```

### Comparing `argos_toolkit-0.1.3.post3/argos_toolkit.egg-info/PKG-INFO` & `argos_toolkit-0.2.0/argos_toolkit.egg-info/PKG-INFO`

 * *Files 4% similar despite different names*

```diff
@@ -1,44 +1,54 @@
 Metadata-Version: 2.1
-Name: argos-toolkit
-Version: 0.1.3.post3
+Name: argos_toolkit
+Version: 0.2.0
 Summary: Software tools to facilitate tracking multiple objects (animals) in a video.
 Home-page: https://github.com/subhacom/argos
 Author: Subhasis Ray
 Author-email: ray.subhasis@gmail.com
 Project-URL: Documentation, https://argos.readthedocs.io
 Project-URL: Source, https://github.com/subhacom/argos
 Project-URL: Tracker, https://github.com/subhacom/argos/issues
 Classifier: Programming Language :: Python :: 3
-Classifier: License :: Public Domain
+Classifier: License :: OSI Approved :: GNU General Public License (GPL)
 Classifier: Operating System :: Microsoft :: Windows
 Classifier: Operating System :: MacOS
 Classifier: Operating System :: POSIX :: Linux
 Classifier: Topic :: Scientific/Engineering
 Classifier: Topic :: Utilities
 Requires-Python: >=3.6
 Description-Content-Type: text/markdown
+License-File: LICENSE
 License-File: LICENSE.txt
+Requires-Dist: cython
+Requires-Dist: torch
+Requires-Dist: torchvision
+Requires-Dist: numpy
+Requires-Dist: scipy
+Requires-Dist: scikit-learn
+Requires-Dist: pandas
+Requires-Dist: tables
+Requires-Dist: sortedcontainers
+Requires-Dist: pyqt5
+Requires-Dist: opencv-contrib-python
+Requires-Dist: pyyaml
+Requires-Dist: matplotlib
+Requires-Dist: qdarkstyle
 
 # Argos: tracking multiple objects ([documentation](https://argos.readthedocs.io/en/latest/))
 Argos is a free, open source software toolkit to facilitate tracking
 multiple objects (animals) in videos. 
 
-It is distributed in two packages, this, providing tools for video
-capture, annotation of training dataset, and review and correction of
-tracks detected automatically by the Argos Tracking tool. The other
-package is the Argos Tracking tool, distributed in the package
-[argos-tracker](https://github.com/subhacom/argos_tracker).
-
 It is described in this article: 
 ```
-Ray, S., & Stopfer, M. A. (2021). 
+Ray, S., Stopfer, M.A., 2022. 
 Argos: A toolkit for tracking multiple animals in complex visual environments. 
-Methods in Ecology and Evolution, 00, 1-11. 
+Methods in Ecology and Evolution 13, 585â€“595. 
 https://doi.org/10.1111/2041-210X.13776
+
 ```
 
 Please feel free to create an issue in the [issue tracker](
 https://github.com/subhacom/argos/issues) if you have questions,
 suggestions, or bugs to report.
 
 
@@ -59,17 +69,15 @@
    3. Track animals in videos (as described above) using either a GUI
       or in batch mode.
    4. Review and correct detected tracks using a GUI.
 
 The user documentation for Argos is available on
 [readthedocs](https://argos.readthedocs.io/en/latest/).
 
-Argos is in the Public Domain, while the 
-[tracker tool](https://github.com/subhacom/argos_tracker) 
-is released under GPL. Both are free and open source.
+Argos 0.2.0 onwards is released free and open source GPL3 license. 
 
 Instead of reinventing the wheel, we put together algorithms developed
 by researchers in computer vision in a simple graphical interface to
 facilitate the work of biologists.
 
 The components of Argos are loosely coupled. Specifically, the
 tracking does not use neural nets, so no need for training it with
@@ -110,14 +118,16 @@
    
 5. Install PyTorch.
 
    If you have a CUDA capable GPU, see  [pytorch website](https://pytorch.org/get-started/locally/)
    to select the  right command. But note that you will need to install the appropriate 
    [NVIDIA driver](https://www.nvidia.com/Download/index.aspx) for it to work.
 
+   *NOTE: Feb 2024 YOLACT does not work on PyTorch with CUDA 12 due to a device mismatch. Use CUDA  11.8 version of PyTorch*
+   
    In case you do not have a CUDA capable GPU, you have to use
    *CPU-only* version (which can be ~10 times slower), in the Anaconda
    prompt
 
    ``` 
    conda install pytorch torchvision cpuonly -c pytorch 
    ``` 
@@ -149,24 +159,19 @@
    ```
 
 7. Install Argos with this command:
 
    ```
    pip install argos_toolkit
    ```
-   and the Tracking utility:
-   ```
-   pip install argos_tracker
-   ```
 
    If you want the development versions of these, do this instead:
 
    ```
    pip install https://github.com/subhacom/argos/archive/master.zip
-   pip install https://github.com/subhacom/argos_tracker/archive/master.zip
    ```
 
 ### Usage
 
 To try Argos tracking on objects in COCO dataset, download the
 pretrained model released with YOLACT
 [here](https://drive.google.com/file/d/1UYy3dMapbH1BnmtZU4WH1zbYgOzzHHf_/view?usp=sharing)
@@ -196,24 +201,24 @@
 ```
 
 Continue reading below, or refer to the documentation for specific
 cases.
 
 #### Interactive tracking
 
-The `argos_track` utility provides a graphical
+The `argos.track` utility provides a graphical
 interface to set the parameters, choose algorithms for detection
 (instance segmentation) and tracking, and to view the performance as
 tracking proceeds. Follow the steps below to start and use this
 program.
 
 1. Run `argos` tracking script on the Anaconda prompt:
    
    ```
-   python -m argos_track
+   python -m argos.track
    ```
 
    This will start the Graphical User Interface for the
    tracker. Follow the steps below in the GUI to track objects while
    visualizing the tracking.
 
 2. Open the video file using either the `File` menu. After selecting
@@ -282,20 +287,20 @@
 	
 #### Batch tracking 
 You can also run the tracking in batch mode from the command
 line. This is useful for processing a number of files from a shell
 script. This uses YOLACT for decteting objects and SORT for tracking.
 
 ```
-python -m argos_track.batchtrack -i {input_file} -o {output_file} -c {yolact_config} -w {yolact_weights} -s {score} -k {max_objects} --hmin {minimum_height} --hmax {maximum_height} --wmin {minimum_width} --wmax {maximum_width} --overlap {minimum_overlap} --max_age {maximum_misses}
+python -m argos.batchtrack -i {input_file} -o {output_file} -c {yolact_config} -w {yolact_weights} -s {score} -k {max_objects} --hmin {minimum_height} --hmax {maximum_height} --wmin {minimum_width} --wmax {maximum_width} --overlap {minimum_overlap} --max_age {maximum_misses}
 ```	
 
 where every entry inside braces is to be replaced by the appropriate
 value. The arguments are described below (full list can be obtained by
-the command `python -m argos_track.batchtrack -h`)
+the command `python -m argos.batchtrack -h`)
 
 - `input_file`: path of input video file
 
 - `output_file`: path of output data
 
 - `yolact_config`: path of yolact configuration file (as described above
   in step 10)
@@ -352,15 +357,15 @@
 these animals in `config/weights.pth`, the recorded video in
 `myvideo.avi`, where we know that no more than 20 animals (including
 misdetection of other objects as the animal, e.g. a scratch in the
 arena) should be detected in the video, the following command may
 work:
 
 ```
-python -m argos_track.batchtrack -i myvideo.avi -o myvideo.h5 -c config/yolact.yml -w config/weights.pth -s 0.3 -k 20 --hmin 10 --hmax 100 --wmin 5 --wmax 50 --overlap 0.3 --max_age 20
+python -m argos.batchtrack -i myvideo.avi -o myvideo.h5 -c config/yolact.yml -w config/weights.pth -s 0.3 -k 20 --hmin 10 --hmax 100 --wmin 5 --wmax 50 --overlap 0.3 --max_age 20
 ```
 
 This will give a new label to an object if it is missing for 20 frames
 or more. If there are misdetections, they can be corrected manually by
 the `review` tool described below.
 
 Before embarking on processing a series of similar videos in batch
@@ -389,15 +394,15 @@
    running the reviewer.
 2. Start the GUI using the command
 
   ```
   python -m argos.review
   ```
 
-3. From the File menu open the track generated by `argos_track` and it
+3. From the File menu open the track generated by the tracking utility and it
    will ask for the corresponding video file.
    
    Once both are selected, you will see the current frame in the right
    pane and the previous frame in the left pane (initially empty).
 
 4. Press Play (keyboard shortcut: `space bar`) to start going through the video.
 
@@ -582,15 +587,15 @@
   instrctions above).
   
   On Unix-like systems (Linux/Mac) you can install pycocotools with
   ```
   pip install pycocotools
   ```
   
-- I get this error when trying `python -m argos_track`:
+- I get this error when trying `python -m argos.track`:
   ```
   RuntimeError: Found no NVIDIA driver on your system. Please check that you have an NVIDIA GPU and installed a driver from http://www.nvidia.com/Download/index.aspx
   ```
   
   Check if you have NVIDIA drivers for CUDA installed. Also note that
   CUDA does not work from Windows Subsystem for Linux (WSL). In
   general it is a good idea to install Argos on the native platform.
@@ -635,7 +640,9 @@
   ```
 
 - If you use Argos for a publication, please cite the article describing it:
 
     Ray, S., & Stopfer, M. A. (2021).  Argos: A toolkit for tracking
     multiple animals in complex visual environments. Methods in Ecology
     and Evolution, 00, 1- 11. https://doi.org/10.1111/2041-210X.13776
+	
+- Funding: During the initial development of Argos (v0.1) the author was funded by the National Institutes of Health. Since June 2021 Args does not receive any funding and the author develops it in his free time as a contribution to the community.
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `argos_toolkit-0.1.3.post3/argos_toolkit.egg-info/SOURCES.txt` & `argos_toolkit-0.2.0/argos_toolkit.egg-info/SOURCES.txt`

 * *Files 3% similar despite different names*

```diff
@@ -1,37 +1,46 @@
+LICENSE
 LICENSE.txt
 MANIFEST.in
 README.md
 pyproject.toml
 setup.py
 argos/__init__.py
 argos/annotate.py
 argos/batch_motion_track.py
+argos/batchtrack.py
 argos/batchtrack_queue.py
 argos/breeze_resources.py
 argos/capture.py
 argos/capture.updated.py
 argos/caputil.py
 argos/ccapture.c
 argos/ccapture.pyx
 argos/ccapture.updated.pyx
 argos/constants.py
+argos/convert_dlc.py
 argos/csrtracker.py
 argos/cutility.c
 argos/cutility.pyx
 argos/extract_frames.py
 argos/frameview.py
 argos/limitswidget.py
 argos/plot_tracks.py
 argos/plotutil.py
 argos/review.py
 argos/segment.py
 argos/segwidget.py
+argos/sortracker.py
+argos/sortrackerwidget.py
 argos/test_ccap.py
 argos/test_tracker.py
+argos/track.py
+argos/tracklist.py
+argos/trackreader.py
+argos/trackview.py
 argos/utility.py
 argos/vreader.py
 argos/vwidget.py
 argos/writer.py
 argos/yolactwidget.py
 argos/_stylesheets/breeze.qrc
 argos/_stylesheets/dark/stylesheet.qss
```

### Comparing `argos_toolkit-0.1.3.post3/config/yolact_base/yolact_base_config.yml` & `argos_toolkit-0.2.0/config/yolact_base/yolact_base_config.yml`

 * *Files identical despite different names*

### Comparing `argos_toolkit-0.1.3.post3/setup.py` & `argos_toolkit-0.2.0/setup.py`

 * *Files 2% similar despite different names*

```diff
@@ -14,15 +14,15 @@
       python -m twine upload --repository pypi dist/*
 
 - Install from TestPyPI
 
       pip install --index-url https://test.pypi.org/simple/ --no-deps argos-toolkit --extra-index-url https://pypi.org/simple
 
 
-``argos-tracker`` is just PyPI name, the installed package is named
+``argos-toolkit`` is just PyPI name, the installed package is named
 ``argos``. This is to avoid name conflict with another package on
 PyPI.
 
 There is an existing, unrelated ``argos`` package for viewing HDF5
 files. If you must use both, see this:
 https://stackoverflow.com/questions/27532112/how-to-handle-python-packages-with-conflicting-names
 
@@ -93,15 +93,15 @@
         'Source': 'https://github.com/subhacom/argos',
         'Tracker': 'https://github.com/subhacom/argos/issues',
     },
     packages=find_packages(),
     ext_modules=cythonize(ext_modules),
     classifiers=[
         'Programming Language :: Python :: 3',
-        'License :: Public Domain',
+        'License :: OSI Approved :: GNU General Public License (GPL)',
         'Operating System :: Microsoft :: Windows',
         'Operating System :: MacOS',
         'Operating System :: POSIX :: Linux',
         'Topic :: Scientific/Engineering',
         'Topic :: Utilities',
     ],
     python_requires='>=3.6',
@@ -115,9 +115,10 @@
         'pandas',
         'tables',
         'sortedcontainers',
         'pyqt5',
         'opencv-contrib-python',
         'pyyaml',
         'matplotlib',
+        'qdarkstyle'
     ],
 )
```

### Comparing `argos_toolkit-0.1.3.post3/yolact/backbone.py` & `argos_toolkit-0.2.0/yolact/backbone.py`

 * *Files identical despite different names*

### Comparing `argos_toolkit-0.1.3.post3/yolact/data/coco.py` & `argos_toolkit-0.2.0/yolact/data/coco.py`

 * *Files identical despite different names*

### Comparing `argos_toolkit-0.1.3.post3/yolact/data/config.py` & `argos_toolkit-0.2.0/yolact/data/config.py`

 * *Files identical despite different names*

### Comparing `argos_toolkit-0.1.3.post3/yolact/data/config_20200305.py` & `argos_toolkit-0.2.0/yolact/data/config_20200305.py`

 * *Files identical despite different names*

### Comparing `argos_toolkit-0.1.3.post3/yolact/data/scripts/mix_sets.py` & `argos_toolkit-0.2.0/yolact/data/scripts/mix_sets.py`

 * *Files identical despite different names*

### Comparing `argos_toolkit-0.1.3.post3/yolact/external/DCNv2/dcn_v2.py` & `argos_toolkit-0.2.0/yolact/external/DCNv2/dcn_v2.py`

 * *Files identical despite different names*

### Comparing `argos_toolkit-0.1.3.post3/yolact/external/DCNv2/setup.py` & `argos_toolkit-0.2.0/yolact/external/DCNv2/setup.py`

 * *Files identical despite different names*

### Comparing `argos_toolkit-0.1.3.post3/yolact/external/DCNv2/test.py` & `argos_toolkit-0.2.0/yolact/external/DCNv2/test.py`

 * *Files identical despite different names*

### Comparing `argos_toolkit-0.1.3.post3/yolact/layers/box_utils.py` & `argos_toolkit-0.2.0/yolact/layers/box_utils.py`

 * *Files identical despite different names*

### Comparing `argos_toolkit-0.1.3.post3/yolact/layers/functions/detection.py` & `argos_toolkit-0.2.0/yolact/layers/functions/detection.py`

 * *Ordering differences only*

 * *Files 19% similar despite different names*

```diff
@@ -1,228 +1,228 @@
-import torch
-import torch.nn.functional as F
-from yolact.layers.box_utils import decode, jaccard, index2d
-from yolact.utils import timer
-
-from yolact.data import cfg, mask_type
-
-import numpy as np
-
-
-class Detect(object):
-    """At test time, Detect is the final layer of SSD.  Decode location preds,
-    apply non-maximum suppression to location predictions based on conf
-    scores and threshold to a top_k number of output predictions for both
-    confidence score and locations, as the predicted masks.
-    """
-    # TODO: Refactor this whole class away. It needs to go.
-
-    def __init__(self, num_classes, bkg_label, top_k, conf_thresh, nms_thresh):
-        self.num_classes = num_classes
-        self.background_label = bkg_label
-        self.top_k = top_k
-        # Parameters used in nms.
-        self.nms_thresh = nms_thresh
-        if nms_thresh <= 0:
-            raise ValueError('nms_threshold must be non negative.')
-        self.conf_thresh = conf_thresh
-        
-        self.use_cross_class_nms = False
-        self.use_fast_nms = False
-
-    def __call__(self, predictions, net):
-        """
-        Args:
-             loc_data: (tensor) Loc preds from loc layers
-                Shape: [batch, num_priors, 4]
-            conf_data: (tensor) Shape: Conf preds from conf layers
-                Shape: [batch, num_priors, num_classes]
-            mask_data: (tensor) Mask preds from mask layers
-                Shape: [batch, num_priors, mask_dim]
-            prior_data: (tensor) Prior boxes and variances from priorbox layers
-                Shape: [num_priors, 4]
-            proto_data: (tensor) If using mask_type.lincomb, the prototype masks
-                Shape: [batch, mask_h, mask_w, mask_dim]
-        
-        Returns:
-            output of shape (batch_size, top_k, 1 + 1 + 4 + mask_dim)
-            These outputs are in the order: class idx, confidence, bbox coords, and mask.
-
-            Note that the outputs are sorted only if cross_class_nms is False
-        """
-
-        loc_data   = predictions['loc']
-        conf_data  = predictions['conf']
-        mask_data  = predictions['mask']
-        prior_data = predictions['priors']
-
-        proto_data = predictions['proto'] if 'proto' in predictions else None
-        inst_data  = predictions['inst']  if 'inst'  in predictions else None
-
-        out = []
-
-        with timer.env('Detect'):
-            batch_size = loc_data.size(0)
-            num_priors = prior_data.size(0)
-
-            conf_preds = conf_data.view(batch_size, num_priors, self.num_classes).transpose(2, 1).contiguous()
-
-            for batch_idx in range(batch_size):
-                decoded_boxes = decode(loc_data[batch_idx], prior_data)
-                result = self.detect(batch_idx, conf_preds, decoded_boxes, mask_data, inst_data)
-
-                if result is not None and proto_data is not None:
-                    result['proto'] = proto_data[batch_idx]
-
-                out.append({'detection': result, 'net': net})
-        
-        return out
-
-
-    def detect(self, batch_idx, conf_preds, decoded_boxes, mask_data, inst_data):
-        """ Perform nms for only the max scoring class that isn't background (class 0) """
-        cur_scores = conf_preds[batch_idx, 1:, :]
-        conf_scores, _ = torch.max(cur_scores, dim=0)
-
-        keep = (conf_scores > self.conf_thresh)
-        scores = cur_scores[:, keep]
-        boxes = decoded_boxes[keep, :]
-        masks = mask_data[batch_idx, keep, :]
-
-        if inst_data is not None:
-            inst = inst_data[batch_idx, keep, :]
-    
-        if scores.size(1) == 0:
-            return None
-        
-        if self.use_fast_nms:
-            if self.use_cross_class_nms:
-                boxes, masks, classes, scores = self.cc_fast_nms(boxes, masks, scores, self.nms_thresh, self.top_k)
-            else:
-                boxes, masks, classes, scores = self.fast_nms(boxes, masks, scores, self.nms_thresh, self.top_k)
-        else:
-            boxes, masks, classes, scores = self.traditional_nms(boxes, masks, scores, self.nms_thresh, self.conf_thresh)
-
-            if self.use_cross_class_nms:
-                print('Warning: Cross Class Traditional NMS is not implemented.')
-
-        return {'box': boxes, 'mask': masks, 'class': classes, 'score': scores}
-
-
-    def cc_fast_nms(self, boxes, masks, scores, iou_threshold:float=0.5, top_k:int=200):
-        # Collapse all the classes into 1 
-        scores, classes = scores.max(dim=0)
-
-        _, idx = scores.sort(0, descending=True)
-        idx = idx[:top_k]
-
-        boxes_idx = boxes[idx]
-
-        # Compute the pairwise IoU between the boxes
-        iou = jaccard(boxes_idx, boxes_idx)
-        
-        # Zero out the lower triangle of the cosine similarity matrix and diagonal
-        iou.triu_(diagonal=1)
-
-        # Now that everything in the diagonal and below is zeroed out, if we take the max
-        # of the IoU matrix along the columns, each column will represent the maximum IoU
-        # between this element and every element with a higher score than this element.
-        iou_max, _ = torch.max(iou, dim=0)
-
-        # Now just filter out the ones greater than the threshold, i.e., only keep boxes that
-        # don't have a higher scoring box that would supress it in normal NMS.
-        idx_out = idx[iou_max <= iou_threshold]
-        
-        return boxes[idx_out], masks[idx_out], classes[idx_out], scores[idx_out]
-
-    def fast_nms(self, boxes, masks, scores, iou_threshold:float=0.5, top_k:int=200, second_threshold:bool=False):
-        scores, idx = scores.sort(1, descending=True)
-
-        idx = idx[:, :top_k].contiguous()
-        scores = scores[:, :top_k]
-    
-        num_classes, num_dets = idx.size()
-
-        boxes = boxes[idx.view(-1), :].view(num_classes, num_dets, 4)
-        masks = masks[idx.view(-1), :].view(num_classes, num_dets, -1)
-
-        iou = jaccard(boxes, boxes)
-        iou.triu_(diagonal=1)
-        iou_max, _ = iou.max(dim=1)
-
-        # Now just filter out the ones higher than the threshold
-        keep = (iou_max <= iou_threshold)
-
-        # We should also only keep detections over the confidence threshold, but at the cost of
-        # maxing out your detection count for every image, you can just not do that. Because we
-        # have such a minimal amount of computation per detection (matrix mulitplication only),
-        # this increase doesn't affect us much (+0.2 mAP for 34 -> 33 fps), so we leave it out.
-        # However, when you implement this in your method, you should do this second threshold.
-        if second_threshold:
-            keep *= (scores > self.conf_thresh)
-
-        # Assign each kept detection to its corresponding class
-        classes = torch.arange(num_classes, device=boxes.device)[:, None].expand_as(keep)
-        classes = classes[keep]
-
-        boxes = boxes[keep]
-        masks = masks[keep]
-        scores = scores[keep]
-        
-        # Only keep the top cfg.max_num_detections highest scores across all classes
-        scores, idx = scores.sort(0, descending=True)
-        idx = idx[:cfg.max_num_detections]
-        scores = scores[:cfg.max_num_detections]
-
-        classes = classes[idx]
-        boxes = boxes[idx]
-        masks = masks[idx]
-
-        return boxes, masks, classes, scores
-
-    def traditional_nms(self, boxes, masks, scores, iou_threshold=0.5, conf_thresh=0.05):
-        import pyximport
-        pyximport.install(setup_args={"include_dirs":np.get_include()}, reload_support=True)
-
-        from yolact.utils.cython_nms import nms as cnms
-
-        num_classes = scores.size(0)
-
-        idx_lst = []
-        cls_lst = []
-        scr_lst = []
-
-        # Multiplying by max_size is necessary because of how cnms computes its area and intersections
-        boxes = boxes * cfg.max_size
-
-        for _cls in range(num_classes):
-            cls_scores = scores[_cls, :]
-            conf_mask = cls_scores > conf_thresh
-            idx = torch.arange(cls_scores.size(0), device=boxes.device)
-
-            cls_scores = cls_scores[conf_mask]
-            idx = idx[conf_mask]
-
-            if cls_scores.size(0) == 0:
-                continue
-            
-            preds = torch.cat([boxes[conf_mask], cls_scores[:, None]], dim=1).cpu().numpy()
-            keep = cnms(preds, iou_threshold)
-            keep = torch.Tensor(keep, device=boxes.device).long()
-
-            idx_lst.append(idx[keep])
-            cls_lst.append(keep * 0 + _cls)
-            scr_lst.append(cls_scores[keep])
-        
-        idx     = torch.cat(idx_lst, dim=0)
-        classes = torch.cat(cls_lst, dim=0)
-        scores  = torch.cat(scr_lst, dim=0)
-
-        scores, idx2 = scores.sort(0, descending=True)
-        idx2 = idx2[:cfg.max_num_detections]
-        scores = scores[:cfg.max_num_detections]
-
-        idx = idx[idx2]
-        classes = classes[idx2]
-
-        # Undo the multiplication above
-        return boxes[idx] / cfg.max_size, masks[idx], classes, scores
+import torch
+import torch.nn.functional as F
+from yolact.layers.box_utils import decode, jaccard, index2d
+from yolact.utils import timer
+
+from yolact.data import cfg, mask_type
+
+import numpy as np
+
+
+class Detect(object):
+    """At test time, Detect is the final layer of SSD.  Decode location preds,
+    apply non-maximum suppression to location predictions based on conf
+    scores and threshold to a top_k number of output predictions for both
+    confidence score and locations, as the predicted masks.
+    """
+    # TODO: Refactor this whole class away. It needs to go.
+
+    def __init__(self, num_classes, bkg_label, top_k, conf_thresh, nms_thresh):
+        self.num_classes = num_classes
+        self.background_label = bkg_label
+        self.top_k = top_k
+        # Parameters used in nms.
+        self.nms_thresh = nms_thresh
+        if nms_thresh <= 0:
+            raise ValueError('nms_threshold must be non negative.')
+        self.conf_thresh = conf_thresh
+        
+        self.use_cross_class_nms = False
+        self.use_fast_nms = False
+
+    def __call__(self, predictions, net):
+        """
+        Args:
+             loc_data: (tensor) Loc preds from loc layers
+                Shape: [batch, num_priors, 4]
+            conf_data: (tensor) Shape: Conf preds from conf layers
+                Shape: [batch, num_priors, num_classes]
+            mask_data: (tensor) Mask preds from mask layers
+                Shape: [batch, num_priors, mask_dim]
+            prior_data: (tensor) Prior boxes and variances from priorbox layers
+                Shape: [num_priors, 4]
+            proto_data: (tensor) If using mask_type.lincomb, the prototype masks
+                Shape: [batch, mask_h, mask_w, mask_dim]
+        
+        Returns:
+            output of shape (batch_size, top_k, 1 + 1 + 4 + mask_dim)
+            These outputs are in the order: class idx, confidence, bbox coords, and mask.
+
+            Note that the outputs are sorted only if cross_class_nms is False
+        """
+
+        loc_data   = predictions['loc']
+        conf_data  = predictions['conf']
+        mask_data  = predictions['mask']
+        prior_data = predictions['priors']
+
+        proto_data = predictions['proto'] if 'proto' in predictions else None
+        inst_data  = predictions['inst']  if 'inst'  in predictions else None
+
+        out = []
+
+        with timer.env('Detect'):
+            batch_size = loc_data.size(0)
+            num_priors = prior_data.size(0)
+
+            conf_preds = conf_data.view(batch_size, num_priors, self.num_classes).transpose(2, 1).contiguous()
+
+            for batch_idx in range(batch_size):
+                decoded_boxes = decode(loc_data[batch_idx], prior_data)
+                result = self.detect(batch_idx, conf_preds, decoded_boxes, mask_data, inst_data)
+
+                if result is not None and proto_data is not None:
+                    result['proto'] = proto_data[batch_idx]
+
+                out.append({'detection': result, 'net': net})
+        
+        return out
+
+
+    def detect(self, batch_idx, conf_preds, decoded_boxes, mask_data, inst_data):
+        """ Perform nms for only the max scoring class that isn't background (class 0) """
+        cur_scores = conf_preds[batch_idx, 1:, :]
+        conf_scores, _ = torch.max(cur_scores, dim=0)
+
+        keep = (conf_scores > self.conf_thresh)
+        scores = cur_scores[:, keep]
+        boxes = decoded_boxes[keep, :]
+        masks = mask_data[batch_idx, keep, :]
+
+        if inst_data is not None:
+            inst = inst_data[batch_idx, keep, :]
+    
+        if scores.size(1) == 0:
+            return None
+        
+        if self.use_fast_nms:
+            if self.use_cross_class_nms:
+                boxes, masks, classes, scores = self.cc_fast_nms(boxes, masks, scores, self.nms_thresh, self.top_k)
+            else:
+                boxes, masks, classes, scores = self.fast_nms(boxes, masks, scores, self.nms_thresh, self.top_k)
+        else:
+            boxes, masks, classes, scores = self.traditional_nms(boxes, masks, scores, self.nms_thresh, self.conf_thresh)
+
+            if self.use_cross_class_nms:
+                print('Warning: Cross Class Traditional NMS is not implemented.')
+
+        return {'box': boxes, 'mask': masks, 'class': classes, 'score': scores}
+
+
+    def cc_fast_nms(self, boxes, masks, scores, iou_threshold:float=0.5, top_k:int=200):
+        # Collapse all the classes into 1 
+        scores, classes = scores.max(dim=0)
+
+        _, idx = scores.sort(0, descending=True)
+        idx = idx[:top_k]
+
+        boxes_idx = boxes[idx]
+
+        # Compute the pairwise IoU between the boxes
+        iou = jaccard(boxes_idx, boxes_idx)
+        
+        # Zero out the lower triangle of the cosine similarity matrix and diagonal
+        iou.triu_(diagonal=1)
+
+        # Now that everything in the diagonal and below is zeroed out, if we take the max
+        # of the IoU matrix along the columns, each column will represent the maximum IoU
+        # between this element and every element with a higher score than this element.
+        iou_max, _ = torch.max(iou, dim=0)
+
+        # Now just filter out the ones greater than the threshold, i.e., only keep boxes that
+        # don't have a higher scoring box that would supress it in normal NMS.
+        idx_out = idx[iou_max <= iou_threshold]
+        
+        return boxes[idx_out], masks[idx_out], classes[idx_out], scores[idx_out]
+
+    def fast_nms(self, boxes, masks, scores, iou_threshold:float=0.5, top_k:int=200, second_threshold:bool=False):
+        scores, idx = scores.sort(1, descending=True)
+
+        idx = idx[:, :top_k].contiguous()
+        scores = scores[:, :top_k]
+    
+        num_classes, num_dets = idx.size()
+
+        boxes = boxes[idx.view(-1), :].view(num_classes, num_dets, 4)
+        masks = masks[idx.view(-1), :].view(num_classes, num_dets, -1)
+
+        iou = jaccard(boxes, boxes)
+        iou.triu_(diagonal=1)
+        iou_max, _ = iou.max(dim=1)
+
+        # Now just filter out the ones higher than the threshold
+        keep = (iou_max <= iou_threshold)
+
+        # We should also only keep detections over the confidence threshold, but at the cost of
+        # maxing out your detection count for every image, you can just not do that. Because we
+        # have such a minimal amount of computation per detection (matrix mulitplication only),
+        # this increase doesn't affect us much (+0.2 mAP for 34 -> 33 fps), so we leave it out.
+        # However, when you implement this in your method, you should do this second threshold.
+        if second_threshold:
+            keep *= (scores > self.conf_thresh)
+
+        # Assign each kept detection to its corresponding class
+        classes = torch.arange(num_classes, device=boxes.device)[:, None].expand_as(keep)
+        classes = classes[keep]
+
+        boxes = boxes[keep]
+        masks = masks[keep]
+        scores = scores[keep]
+        
+        # Only keep the top cfg.max_num_detections highest scores across all classes
+        scores, idx = scores.sort(0, descending=True)
+        idx = idx[:cfg.max_num_detections]
+        scores = scores[:cfg.max_num_detections]
+
+        classes = classes[idx]
+        boxes = boxes[idx]
+        masks = masks[idx]
+
+        return boxes, masks, classes, scores
+
+    def traditional_nms(self, boxes, masks, scores, iou_threshold=0.5, conf_thresh=0.05):
+        import pyximport
+        pyximport.install(setup_args={"include_dirs":np.get_include()}, reload_support=True)
+
+        from yolact.utils.cython_nms import nms as cnms
+
+        num_classes = scores.size(0)
+
+        idx_lst = []
+        cls_lst = []
+        scr_lst = []
+
+        # Multiplying by max_size is necessary because of how cnms computes its area and intersections
+        boxes = boxes * cfg.max_size
+
+        for _cls in range(num_classes):
+            cls_scores = scores[_cls, :]
+            conf_mask = cls_scores > conf_thresh
+            idx = torch.arange(cls_scores.size(0), device=boxes.device)
+
+            cls_scores = cls_scores[conf_mask]
+            idx = idx[conf_mask]
+
+            if cls_scores.size(0) == 0:
+                continue
+            
+            preds = torch.cat([boxes[conf_mask], cls_scores[:, None]], dim=1).cpu().numpy()
+            keep = cnms(preds, iou_threshold)
+            keep = torch.Tensor(keep, device=boxes.device).long()
+
+            idx_lst.append(idx[keep])
+            cls_lst.append(keep * 0 + _cls)
+            scr_lst.append(cls_scores[keep])
+        
+        idx     = torch.cat(idx_lst, dim=0)
+        classes = torch.cat(cls_lst, dim=0)
+        scores  = torch.cat(scr_lst, dim=0)
+
+        scores, idx2 = scores.sort(0, descending=True)
+        idx2 = idx2[:cfg.max_num_detections]
+        scores = scores[:cfg.max_num_detections]
+
+        idx = idx[idx2]
+        classes = classes[idx2]
+
+        # Undo the multiplication above
+        return boxes[idx] / cfg.max_size, masks[idx], classes, scores
```

### Comparing `argos_toolkit-0.1.3.post3/yolact/layers/modules/multibox_loss.py` & `argos_toolkit-0.2.0/yolact/layers/modules/multibox_loss.py`

 * *Files identical despite different names*

### Comparing `argos_toolkit-0.1.3.post3/yolact/layers/output_utils.py` & `argos_toolkit-0.2.0/yolact/layers/output_utils.py`

 * *Files 3% similar despite different names*

```diff
@@ -26,15 +26,16 @@
 
     Returns 4 torch Tensors (in the following order):
         - classes [num_det]: The class idx for each detection.
         - scores  [num_det]: The confidence score for each detection.
         - boxes   [num_det, 4]: The bounding box for each detection in absolute point form.
         - masks   [num_det, h, w]: Full image masks for each detection.
     """
-    
+    if det_output is None:
+        return torch.empty(0), torch.empty(0), torch.empty(0), torch.empty(0)
     dets = det_output[batch_idx]
     net = dets['net']
     dets = dets['detection']
 
     if dets is None:
         return [torch.Tensor()] * 4 # Warning, this is 4 copies of the same thing
```

### Comparing `argos_toolkit-0.1.3.post3/yolact/run_coco_eval.py` & `argos_toolkit-0.2.0/yolact/run_coco_eval.py`

 * *Files identical despite different names*

### Comparing `argos_toolkit-0.1.3.post3/yolact/scripts/augment_bbox.py` & `argos_toolkit-0.2.0/yolact/scripts/augment_bbox.py`

 * *Files identical despite different names*

### Comparing `argos_toolkit-0.1.3.post3/yolact/scripts/bbox_recall.py` & `argos_toolkit-0.2.0/yolact/scripts/bbox_recall.py`

 * *Files identical despite different names*

### Comparing `argos_toolkit-0.1.3.post3/yolact/scripts/cluster_bbox_sizes.py` & `argos_toolkit-0.2.0/yolact/scripts/cluster_bbox_sizes.py`

 * *Files identical despite different names*

### Comparing `argos_toolkit-0.1.3.post3/yolact/scripts/compute_masks.py` & `argos_toolkit-0.2.0/yolact/scripts/compute_masks.py`

 * *Files identical despite different names*

### Comparing `argos_toolkit-0.1.3.post3/yolact/scripts/convert_darknet.py` & `argos_toolkit-0.2.0/yolact/scripts/convert_darknet.py`

 * *Files identical despite different names*

### Comparing `argos_toolkit-0.1.3.post3/yolact/scripts/convert_sbd.py` & `argos_toolkit-0.2.0/yolact/scripts/convert_sbd.py`

 * *Files identical despite different names*

### Comparing `argos_toolkit-0.1.3.post3/yolact/scripts/make_grid.py` & `argos_toolkit-0.2.0/yolact/scripts/make_grid.py`

 * *Files identical despite different names*

### Comparing `argos_toolkit-0.1.3.post3/yolact/scripts/optimize_bboxes.py` & `argos_toolkit-0.2.0/yolact/scripts/optimize_bboxes.py`

 * *Files identical despite different names*

### Comparing `argos_toolkit-0.1.3.post3/yolact/scripts/parse_eval.py` & `argos_toolkit-0.2.0/yolact/scripts/parse_eval.py`

 * *Files identical despite different names*

### Comparing `argos_toolkit-0.1.3.post3/yolact/scripts/plot_loss.py` & `argos_toolkit-0.2.0/yolact/scripts/plot_loss.py`

 * *Files identical despite different names*

### Comparing `argos_toolkit-0.1.3.post3/yolact/scripts/save_bboxes.py` & `argos_toolkit-0.2.0/yolact/scripts/save_bboxes.py`

 * *Files identical despite different names*

### Comparing `argos_toolkit-0.1.3.post3/yolact/train.py` & `argos_toolkit-0.2.0/yolact/train.py`

 * *Files 4% similar despite different names*

```diff
@@ -24,14 +24,18 @@
 from yolact.utils import timer
 from yolact.layers.modules import MultiBoxLoss
 from yolact import Yolact
 
 import yolact.evaluate as eval_script
 
 
+torch_version = torch.__version__.split('.')
+torch_major_version = int(torch_version[0])
+torch_minor_version = int(torch_version[1])
+
 # Reduce memory usage
 torch.cuda.empty_cache()
 
 # This is managed by set_lr
 cur_lr = 1e-3
 loss_types = ['B', 'C', 'M', 'P', 'D', 'E', 'S', 'I']
 
@@ -105,15 +109,17 @@
         '--save_folder',
         default='weights/',
         help='Directory for saving checkpoint models.',
     )
     parser.add_argument(
         '--log_folder', default='logs/', help='Directory for saving logs.'
     )
-    parser.add_argument('--config', default=None, help='The config object to use.')
+    parser.add_argument(
+        '--config', default=None, help='The config object to use.'
+    )
     parser.add_argument(
         '--save_interval',
         default=10000,
         type=int,
         help='The number of iterations between saving the model.',
     )
     parser.add_argument(
@@ -184,15 +190,19 @@
         action='store_false',
         help='YOLACT will automatically scale the lr and'
         ' the number of iterations depending on the batch size.'
         ' Set this if you want to disable that.',
     )
 
     parser.set_defaults(
-        keep_latest=False, log=True, log_gpu=False, interrupt=True, autoscale=True
+        keep_latest=False,
+        log=True,
+        log_gpu=False,
+        interrupt=True,
+        autoscale=True,
     )
 
     return parser
 
 
 # Update training parameters from the config if necessary
 def replace(args, name):
@@ -214,14 +224,47 @@
 
     def forward(self, images, targets, masks, num_crowds):
         preds = self.net(images)
         losses = self.criterion(self.net, preds, targets, masks, num_crowds)
         return losses
 
 
+# ScatterWrapper is old code removed from yolact repo - see here: https://github.com/dbolya/yolact/issues/410
+class ScatterWrapper:
+    """Input is any number of lists. This will preserve them through a dataparallel scatter."""
+
+    def __init__(self, *args):
+        for arg in args:
+            if not isinstance(arg, list):
+                print('Warning: ScatterWrapper got input of non-list type.')
+        self.args = args
+        self.batch_size = len(args[0])
+
+    def make_mask(self):
+        out = torch.Tensor(list(range(self.batch_size))).long()
+        if args.cuda:
+            return out.cuda()
+        else:
+            return out
+
+    def get_args(self, mask):
+        device = mask.device
+        mask = [int(x) for x in mask]
+        out_args = [[] for _ in self.args]
+
+        for out, arg in zip(out_args, self.args):
+            for idx in mask:
+                x = arg[idx]
+                if isinstance(x, torch.Tensor):
+                    x = x.to(device)
+                out.append(x)
+
+        return out_args
+
+
 class CustomDataParallel(nn.DataParallel):
     """
     This is a custom version of DataParallel that works better with our training data.
     It should also be faster than the general case.
     """
 
     def scatter(self, inputs, kwargs, device_ids):
@@ -238,15 +281,17 @@
             [kwargs] * len(devices),
         )
 
     def gather(self, outputs, output_device):
         out = {}
 
         for k in outputs[0]:
-            out[k] = torch.stack([output[k].to(output_device) for output in outputs])
+            out[k] = torch.stack(
+                [output[k].to(output_device) for output in outputs]
+            )
 
         return out
 
 
 def train(args):
     global loc_loss
     global conf_loss
@@ -301,15 +346,18 @@
     else:
         print('Initializing weights...')
         yolact_net.init_weights(
             backbone_path=os.path.join(args.save_folder, cfg.backbone.path)
         )
 
     optimizer = optim.SGD(
-        net.parameters(), lr=args.lr, momentum=args.momentum, weight_decay=args.decay
+        net.parameters(),
+        lr=args.lr,
+        momentum=args.momentum,
+        weight_decay=args.decay,
     )
     criterion = MultiBoxLoss(
         num_classes=cfg.num_classes,
         pos_threshold=cfg.positive_iou_threshold,
         neg_threshold=cfg.negative_iou_threshold,
         negpos_ratio=cfg.ohem_negpos_ratio,
     )
@@ -350,15 +398,15 @@
     data_loader = data.DataLoader(
         dataset,
         args.batch_size,
         num_workers=args.num_workers,
         shuffle=True,
         collate_fn=detection_collate,
         pin_memory=True,
-        generator=generator
+        generator=generator,
     )
 
     time_avg = MovingAverage()
 
     global loss_types  # Forms the print order
     loss_avgs = {k: MovingAverage(100) for k in loss_types}
 
@@ -394,29 +442,32 @@
                 # If a config setting was changed, remove it from the list so we don't keep checking
                 if changed:
                     cfg.delayed_settings = [
                         x for x in cfg.delayed_settings if x[0] > iteration
                     ]
 
                 # Warm up by linearly interpolating the learning rate from some smaller value
-                if cfg.lr_warmup_until > 0 and iteration <= cfg.lr_warmup_until:
+                if (
+                    cfg.lr_warmup_until > 0
+                    and iteration <= cfg.lr_warmup_until
+                ):
                     set_lr(
                         optimizer,
                         (args.lr - cfg.lr_warmup_init)
                         * (iteration / cfg.lr_warmup_until)
                         + cfg.lr_warmup_init,
                     )
 
                 # Adjust the learning rate at the given iterations, but also if we resume from past that iteration
                 while (
                     step_index < len(cfg.lr_steps)
                     and iteration >= cfg.lr_steps[step_index]
                 ):
                     step_index += 1
-                    set_lr(optimizer, args.lr * (args.gamma ** step_index))
+                    set_lr(optimizer, args.lr * (args.gamma**step_index))
 
                 # Zero the grad to get ready to compute gradients
                 optimizer.zero_grad()
 
                 # Forward Pass + Compute loss at the same time (see CustomDataParallel and NetLoss)
                 losses = net(datum)
 
@@ -444,59 +495,73 @@
                 # Exclude graph setup from the timing information
                 if iteration != args.start_iter:
                     time_avg.add(elapsed)
 
                 if iteration % 10 == 0:
                     eta_str = str(
                         datetime.timedelta(
-                            seconds=(cfg.max_iter - iteration) * time_avg.get_avg()
+                            seconds=(cfg.max_iter - iteration)
+                            * time_avg.get_avg()
                         )
                     ).split('.')[0]
 
                     total = sum([loss_avgs[k].get_avg() for k in losses])
                     loss_labels = sum(
                         [
                             [k, loss_avgs[k].get_avg()]
                             for k in loss_types
                             if k in losses
                         ],
                         [],
                     )
                     print(
-                        f'[{epoch:3d}] {iteration:7d} ||' +
-                        ' '.join([f' {loss_labels[ii]}: {loss_labels[ii+1]:.3f} |'
-                                  for ii in range(0, len(loss_labels), 2)]) +
-                        f' T: {total:.3f} || ETA: {eta_str} || timer: {elapsed:.3f}',
+                        f'[{epoch:3d}] {iteration:7d} ||'
+                        + ' '.join(
+                            [
+                                f' {loss_labels[ii]}: {loss_labels[ii+1]:.3f} |'
+                                for ii in range(0, len(loss_labels), 2)
+                            ]
+                        )
+                        + f' T: {total:.3f} || ETA: {eta_str} || timer: {elapsed:.3f}',
                         flush=True,
                     )
 
                 if args.log:
                     precision = 5
-                    loss_info = {k: round(losses[k].item(), precision) for k in losses}
+                    loss_info = {
+                        k: round(losses[k].item(), precision) for k in losses
+                    }
                     loss_info['T'] = round(loss.item(), precision)
 
                     if args.log_gpu:
-                        log.log_gpu_stats = iteration % 10 == 0  # nvidia-smi is sloooow
+                        log.log_gpu_stats = (
+                            iteration % 10 == 0
+                        )  # nvidia-smi is sloooow
 
                     log.log(
                         'train',
                         loss=loss_info,
                         epoch=epoch,
                         iter=iteration,
                         lr=round(cur_lr, 10),
                         elapsed=elapsed,
                     )
 
                     log.log_gpu_stats = args.log_gpu
 
                 iteration += 1
 
-                if iteration % args.save_interval == 0 and iteration != args.start_iter:
+                if (
+                    iteration % args.save_interval == 0
+                    and iteration != args.start_iter
+                ):
                     if args.keep_latest:
-                        latest = SavePath.get_latest(args.save_folder, cfg.name)
+                        latest = SavePath.get_latest(
+                            args.save_folder, cfg.name
+                        )
                     path = save_path(epoch, iteration)
                     print(f'Saving state, iter: {iteration} in "{path}"')
                     yolact_net.save_weights(path)
 
                     if args.keep_latest and latest is not None:
                         if (
                             args.keep_latest_interval <= 0
@@ -515,24 +580,30 @@
                         yolact_net,
                         val_dataset,
                         log if args.log else None,
                     )
 
         # Compute validation mAP after training is finished
         compute_validation_map(
-            epoch, iteration, yolact_net, val_dataset, log if args.log else None
+            epoch,
+            iteration,
+            yolact_net,
+            val_dataset,
+            log if args.log else None,
         )
     except KeyboardInterrupt:
         if args.interrupt:
             print('Stopping early. Saving network...')
 
             # Delete previous copy of the interrupted network so we don't spam the weights folder
             SavePath.remove_interrupt(args.save_folder)
 
-            yolact_net.save_weights(save_path(epoch, repr(iteration) + '_interrupt'))
+            yolact_net.save_weights(
+                save_path(epoch, repr(iteration) + '_interrupt')
+            )
         exit()
 
     yolact_net.save_weights(save_path(epoch, iteration))
 
 
 def set_lr(optimizer, new_lr):
     for param_group in optimizer.param_groups:
@@ -570,17 +641,20 @@
         if cfg.preserve_aspect_ratio:
             # Choose a random size from the batch
             _, h, w = images[random.randint(0, len(images) - 1)].size()
 
             for idx, (image, target, mask, num_crowd) in enumerate(
                 zip(images, targets, masks, num_crowds)
             ):
-                images[idx], targets[idx], masks[idx], num_crowds[idx] = enforce_size(
-                    image, target, mask, num_crowd, w, h
-                )
+                (
+                    images[idx],
+                    targets[idx],
+                    masks[idx],
+                    num_crowds[idx],
+                ) = enforce_size(image, target, mask, num_crowd, w, h)
 
         cur_idx = 0
         split_images, split_targets, split_masks, split_numcrowds = [
             [None for alloc in allocation] for _ in range(4)
         ]
 
         for device_idx, alloc in enumerate(allocation):
@@ -635,41 +709,59 @@
             iterations += 1
             if args.validation_size <= iterations * args.batch_size:
                 break
 
         for k in losses:
             losses[k] /= iterations
 
-        loss_labels = sum([[k, losses[k]] for k in loss_types if k in losses], [])
+        loss_labels = sum(
+            [[k, losses[k]] for k in loss_types if k in losses], []
+        )
         print(
-            f'Validation ||' +
-            ' '.join([f'{loss_labels[ii]}: {loss_labels[ii+1]:%.3f}'
-                      for ii in range(0, len(loss_labels), 2)]),
+            'Validation || '
+            + ' '.join(
+                [
+                    f'{loss_labels[ii]}: {loss_labels[ii+1]:%.3f}'
+                    for ii in range(0, len(loss_labels), 2)
+                ]
+            ),
             flush=True,
         )
 
 
-def compute_validation_map(epoch, iteration, yolact_net, dataset, log: Log = None):
+def compute_validation_map(
+    epoch, iteration, yolact_net, dataset, log: Log = None
+):
     with torch.no_grad():
         yolact_net.eval()
 
         start = time.time()
         print()
-        print("Computing validation mAP (this may take a while)...", flush=True)
+        print(
+            "Computing validation mAP (this may take a while)...", flush=True
+        )
         val_info = eval_script.evaluate(yolact_net, dataset, train_mode=True)
         end = time.time()
 
         if log is not None:
-            log.log('val', val_info, elapsed=(end - start), epoch=epoch, iter=iteration)
+            log.log(
+                'val',
+                val_info,
+                elapsed=(end - start),
+                epoch=epoch,
+                iter=iteration,
+            )
 
         yolact_net.train()
 
 
 def setup_eval():
-    eval_script.parse_args(['--no_bar', '--max_images=' + str(args.validation_size)])
+    eval_script.parse_args(
+        ['--no_bar', '--max_images=' + str(args.validation_size)]
+    )
 
 
 if __name__ == '__main__':
     parser = make_parser()
     args = parser.parse_args()
 
     if args.config is not None:
@@ -695,22 +787,32 @@
             'Per-GPU batch size is less than the recommended limit'
             ' for batch norm. Disabling batch norm.'
         )
         cfg.freeze_bn = True
 
     if torch.cuda.is_available():
         if args.cuda:
-            torch.set_default_tensor_type('torch.cuda.FloatTensor')
-        if not args.cuda:
+            if (torch_major_version >= 2) and (torch_minor_version >= 1):
+                # print(
+                #     f'Torch version {torch_major_version}.{torch_minor_version}: Setting default device cuda'
+                # )
+                torch.set_default_device('cuda')
+                # torch.set_default_dtype('torch.cuda.FloatTensor')
+            else:
+                torch.set_default_tensor_type('torch.cuda.FloatTensor')
+        else:
             print(
                 "WARNING: It looks like you have a CUDA device, but aren't "
                 "using CUDA.\nRun with --cuda for optimal training speed."
             )
             torch.set_default_tensor_type('torch.FloatTensor')
     else:
+        print(
+            "WARNING: It looks like you don't have a CUDA device. Training will be slow"
+        )
         torch.set_default_tensor_type('torch.FloatTensor')
 
     if args.autoscale and args.batch_size != 8:
         factor = args.batch_size / 8
         print(
             f'Scaling parameters by {factor:.2f} to account for'
             f' a batch size of {args.batch_size:d}.'
```

### Comparing `argos_toolkit-0.1.3.post3/yolact/utils/augmentations.py` & `argos_toolkit-0.2.0/yolact/utils/augmentations.py`

 * *Files identical despite different names*

### Comparing `argos_toolkit-0.1.3.post3/yolact/utils/functions.py` & `argos_toolkit-0.2.0/yolact/utils/functions.py`

 * *Files identical despite different names*

### Comparing `argos_toolkit-0.1.3.post3/yolact/utils/logger.py` & `argos_toolkit-0.2.0/yolact/utils/logger.py`

 * *Files identical despite different names*

### Comparing `argos_toolkit-0.1.3.post3/yolact/utils/nvinfo.py` & `argos_toolkit-0.2.0/yolact/utils/nvinfo.py`

 * *Files identical despite different names*

### Comparing `argos_toolkit-0.1.3.post3/yolact/utils/timer.py` & `argos_toolkit-0.2.0/yolact/utils/timer.py`

 * *Files identical despite different names*

### Comparing `argos_toolkit-0.1.3.post3/yolact/web/server.py` & `argos_toolkit-0.2.0/yolact/web/server.py`

 * *Files identical despite different names*

### Comparing `argos_toolkit-0.1.3.post3/yolact/yolact.py` & `argos_toolkit-0.2.0/yolact/yolact.py`

 * *Files 2% similar despite different names*

```diff
@@ -4,14 +4,16 @@
 from torchvision.models.resnet import Bottleneck
 import numpy as np
 from itertools import product
 from math import sqrt
 from typing import List
 from collections import defaultdict
 
+print(f'In module products __package__="{__package__}", __name__="{__name__}"')
+
 from .data.config import cfg, mask_type
 from .layers import Detect
 from .layers.interpolate import InterpolateModule
 from .backbone import construct_backbone
 
 import torch.backends.cudnn as cudnn
 from .utils import timer
@@ -20,14 +22,19 @@
 # This is required for Pytorch 1.0.1 on Windows to initialize Cuda on some driver versions.
 # See the bug report here: https://github.com/pytorch/pytorch/issues/17108
 try:
     torch.cuda.current_device()
 except AssertionError:
     print('WARNING: CUDA not supported in this installation of PyTorch')
 
+torch_version = torch.__version__.split('.')
+torch_major_version = int(torch_version[0])
+torch_minor_version = int(torch_version[1])
+    
+
 # As of March 10, 2019, Pytorch DataParallel still doesn't support JIT Script Modules
 use_jit = torch.cuda.device_count() <= 1
 if not use_jit:
     print('Multiple GPUs detected! Turning off JIT.')
 
 ScriptModuleWrapper = torch.jit.ScriptModule if use_jit else nn.Module
 script_method_wrapper = torch.jit.script_method if use_jit else lambda fn, _rcn=None: fn
@@ -697,15 +704,19 @@
 
     net = Yolact()
     net.train()
     net.init_weights(backbone_path='weights/' + cfg.backbone.path)
 
     # GPU
     net = net.cuda()
-    torch.set_default_tensor_type('torch.cuda.FloatTensor')
+    if (torch_major_version >= 2) and (torch_minor_version >= 1):
+        torch.set_default_device('cuda')
+        # torch.set_default_dtype('torch.cuda.FloatTensor')
+    else:
+        torch.set_default_tensor_type('torch.cuda.FloatTensor')
 
     x = torch.zeros((1, 3, cfg.max_size, cfg.max_size))
     y = net(x)
 
     for p in net.prediction_layers:
         print(p.last_conv_size)
```

### Comparing `argos_toolkit-0.1.3.post3/yolact/yolact_.py` & `argos_toolkit-0.2.0/yolact/yolact_.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,8 +1,9 @@
-import torch, torchvision
+import torch
+import torchvision
 import torch.nn as nn
 import torch.nn.functional as F
 from torchvision.models.resnet import Bottleneck
 import numpy as np
 from itertools import product
 from math import sqrt
 from typing import List
@@ -17,40 +18,46 @@
 from .utils import timer
 from .utils.functions import MovingAverage, make_net
 
 # This is required for Pytorch 1.0.1 on Windows to initialize Cuda on some driver versions.
 # See the bug report here: https://github.com/pytorch/pytorch/issues/17108
 try:
     torch.cuda.current_device()
+    print('Torch version', torch.__version__)
 except (AssertionError, RuntimeError):
     print('WARNING: CUDA not supported in this installation of PyTorch')
 
 # As of March 10, 2019, Pytorch DataParallel still doesn't support JIT Script Modules
 use_jit = torch.cuda.device_count() <= 1
 if not use_jit:
     print('Multiple GPUs detected! Turning off JIT.')
 
 ScriptModuleWrapper = torch.jit.ScriptModule if use_jit else nn.Module
-script_method_wrapper = torch.jit.script_method if use_jit else lambda fn, _rcn=None: fn
-
+script_method_wrapper = (
+    torch.jit.script_method if use_jit else lambda fn, _rcn=None: fn
+)
 
 
 class Concat(nn.Module):
     def __init__(self, nets, extra_params):
         super().__init__()
 
         self.nets = nn.ModuleList(nets)
         self.extra_params = extra_params
-    
+
     def forward(self, x):
         # Concat each along the channel dimension
-        return torch.cat([net(x) for net in self.nets], dim=1, **self.extra_params)
+        return torch.cat(
+            [net(x) for net in self.nets], dim=1, **self.extra_params
+        )
+
 
 prior_cache = defaultdict(lambda: None)
 
+
 class PredictionModule(nn.Module):
     """
     The (c) prediction module adapted from DSSD:
     https://arxiv.org/pdf/1701.06659.pdf
 
     Note that this is slightly different to the module in the paper
     because the Bottleneck block actually has a 3x3 convolution in
@@ -68,67 +75,121 @@
                                        of 1) for this layer would produce bounding
                                        boxes with an area of 20x20px. If the scale is
                                        .5 on the other hand, this layer would consider
                                        bounding boxes with area 10x10px, etc.
         - parent:        If parent is a PredictionModule, this module will use all the layers
                          from parent instead of from this module.
     """
-    
-    def __init__(self, in_channels, out_channels=1024, aspect_ratios=[[1]], scales=[1], parent=None, index=0):
+
+    def __init__(
+        self,
+        in_channels,
+        out_channels=1024,
+        aspect_ratios=[[1]],
+        scales=[1],
+        parent=None,
+        index=0,
+    ):
         super().__init__()
 
         self.num_classes = cfg.num_classes
-        self.mask_dim    = cfg.mask_dim # Defined by Yolact
-        self.num_priors  = sum(len(x)*len(scales) for x in aspect_ratios)
-        self.parent      = [parent] # Don't include this in the state dict
-        self.index       = index
-        self.num_heads   = cfg.num_heads # Defined by Yolact
-
-        if cfg.mask_proto_split_prototypes_by_head and cfg.mask_type == mask_type.lincomb:
+        self.mask_dim = cfg.mask_dim  # Defined by Yolact
+        self.num_priors = sum(len(x) * len(scales) for x in aspect_ratios)
+        self.parent = [parent]  # Don't include this in the state dict
+        self.index = index
+        self.num_heads = cfg.num_heads  # Defined by Yolact
+
+        if (
+            cfg.mask_proto_split_prototypes_by_head
+            and cfg.mask_type == mask_type.lincomb
+        ):
             self.mask_dim = self.mask_dim // self.num_heads
 
         if cfg.mask_proto_prototypes_as_features:
             in_channels += self.mask_dim
-        
+
         if parent is None:
             if cfg.extra_head_net is None:
                 out_channels = in_channels
             else:
-                self.upfeature, out_channels = make_net(in_channels, cfg.extra_head_net)
+                self.upfeature, out_channels = make_net(
+                    in_channels, cfg.extra_head_net
+                )
 
             if cfg.use_prediction_module:
                 self.block = Bottleneck(out_channels, out_channels // 4)
-                self.conv = nn.Conv2d(out_channels, out_channels, kernel_size=1, bias=True)
+                self.conv = nn.Conv2d(
+                    out_channels, out_channels, kernel_size=1, bias=True
+                )
                 self.bn = nn.BatchNorm2d(out_channels)
 
-            self.bbox_layer = nn.Conv2d(out_channels, self.num_priors * 4,                **cfg.head_layer_params)
-            self.conf_layer = nn.Conv2d(out_channels, self.num_priors * self.num_classes, **cfg.head_layer_params)
-            self.mask_layer = nn.Conv2d(out_channels, self.num_priors * self.mask_dim,    **cfg.head_layer_params)
-            
+            self.bbox_layer = nn.Conv2d(
+                out_channels, self.num_priors * 4, **cfg.head_layer_params
+            )
+            self.conf_layer = nn.Conv2d(
+                out_channels,
+                self.num_priors * self.num_classes,
+                **cfg.head_layer_params
+            )
+            self.mask_layer = nn.Conv2d(
+                out_channels,
+                self.num_priors * self.mask_dim,
+                **cfg.head_layer_params
+            )
+
             if cfg.use_mask_scoring:
-                self.score_layer = nn.Conv2d(out_channels, self.num_priors, **cfg.head_layer_params)
+                self.score_layer = nn.Conv2d(
+                    out_channels, self.num_priors, **cfg.head_layer_params
+                )
 
             if cfg.use_instance_coeff:
-                self.inst_layer = nn.Conv2d(out_channels, self.num_priors * cfg.num_instance_coeffs, **cfg.head_layer_params)
-            
+                self.inst_layer = nn.Conv2d(
+                    out_channels,
+                    self.num_priors * cfg.num_instance_coeffs,
+                    **cfg.head_layer_params
+                )
+
             # What is this ugly lambda doing in the middle of all this clean prediction module code?
             def make_extra(num_layers):
                 if num_layers == 0:
                     return lambda x: x
                 else:
                     # Looks more complicated than it is. This just creates an array of num_layers alternating conv-relu
-                    return nn.Sequential(*sum([[
-                        nn.Conv2d(out_channels, out_channels, kernel_size=3, padding=1),
-                        nn.ReLU(inplace=True)
-                    ] for _ in range(num_layers)], []))
-
-            self.bbox_extra, self.conf_extra, self.mask_extra = [make_extra(x) for x in cfg.extra_layers]
-            
-            if cfg.mask_type == mask_type.lincomb and cfg.mask_proto_coeff_gate:
-                self.gate_layer = nn.Conv2d(out_channels, self.num_priors * self.mask_dim, kernel_size=3, padding=1)
+                    return nn.Sequential(
+                        *sum(
+                            [
+                                [
+                                    nn.Conv2d(
+                                        out_channels,
+                                        out_channels,
+                                        kernel_size=3,
+                                        padding=1,
+                                    ),
+                                    nn.ReLU(inplace=True),
+                                ]
+                                for _ in range(num_layers)
+                            ],
+                            [],
+                        )
+                    )
+
+            self.bbox_extra, self.conf_extra, self.mask_extra = [
+                make_extra(x) for x in cfg.extra_layers
+            ]
+
+            if (
+                cfg.mask_type == mask_type.lincomb
+                and cfg.mask_proto_coeff_gate
+            ):
+                self.gate_layer = nn.Conv2d(
+                    out_channels,
+                    self.num_priors * self.mask_dim,
+                    kernel_size=3,
+                    padding=1,
+                )
 
         self.aspect_ratios = aspect_ratios
         self.scales = scales
 
         self.priors = None
         self.last_conv_size = None
         self.last_img_size = None
@@ -143,132 +204,178 @@
             - bbox_coords: [batch_size, conv_h*conv_w*num_priors, 4]
             - class_confs: [batch_size, conv_h*conv_w*num_priors, num_classes]
             - mask_output: [batch_size, conv_h*conv_w*num_priors, mask_dim]
             - prior_boxes: [conv_h*conv_w*num_priors, 4]
         """
         # In case we want to use another module's layers
         src = self if self.parent[0] is None else self.parent[0]
-        
+
         conv_h = x.size(2)
         conv_w = x.size(3)
-        
+
         if cfg.extra_head_net is not None:
             x = src.upfeature(x)
-        
+
         if cfg.use_prediction_module:
             # The two branches of PM design (c)
             a = src.block(x)
-            
+
             b = src.conv(x)
             b = src.bn(b)
             b = F.relu(b)
-            
+
             # TODO: Possibly switch this out for a product
             x = a + b
 
         bbox_x = src.bbox_extra(x)
         conf_x = src.conf_extra(x)
         mask_x = src.mask_extra(x)
 
-        bbox = src.bbox_layer(bbox_x).permute(0, 2, 3, 1).contiguous().view(x.size(0), -1, 4)
-        conf = src.conf_layer(conf_x).permute(0, 2, 3, 1).contiguous().view(x.size(0), -1, self.num_classes)
-        
+        bbox = (
+            src.bbox_layer(bbox_x)
+            .permute(0, 2, 3, 1)
+            .contiguous()
+            .view(x.size(0), -1, 4)
+        )
+        conf = (
+            src.conf_layer(conf_x)
+            .permute(0, 2, 3, 1)
+            .contiguous()
+            .view(x.size(0), -1, self.num_classes)
+        )
+
         if cfg.eval_mask_branch:
-            mask = src.mask_layer(mask_x).permute(0, 2, 3, 1).contiguous().view(x.size(0), -1, self.mask_dim)
+            mask = (
+                src.mask_layer(mask_x)
+                .permute(0, 2, 3, 1)
+                .contiguous()
+                .view(x.size(0), -1, self.mask_dim)
+            )
         else:
-            mask = torch.zeros(x.size(0), bbox.size(1), self.mask_dim, device=bbox.device)
+            mask = torch.zeros(
+                x.size(0), bbox.size(1), self.mask_dim, device=bbox.device
+            )
 
         if cfg.use_mask_scoring:
-            score = src.score_layer(x).permute(0, 2, 3, 1).contiguous().view(x.size(0), -1, 1)
+            score = (
+                src.score_layer(x)
+                .permute(0, 2, 3, 1)
+                .contiguous()
+                .view(x.size(0), -1, 1)
+            )
 
         if cfg.use_instance_coeff:
-            inst = src.inst_layer(x).permute(0, 2, 3, 1).contiguous().view(x.size(0), -1, cfg.num_instance_coeffs)    
+            inst = (
+                src.inst_layer(x)
+                .permute(0, 2, 3, 1)
+                .contiguous()
+                .view(x.size(0), -1, cfg.num_instance_coeffs)
+            )
 
         # See box_utils.decode for an explanation of this
         if cfg.use_yolo_regressors:
             bbox[:, :, :2] = torch.sigmoid(bbox[:, :, :2]) - 0.5
             bbox[:, :, 0] /= conv_w
             bbox[:, :, 1] /= conv_h
 
         if cfg.eval_mask_branch:
             if cfg.mask_type == mask_type.direct:
                 mask = torch.sigmoid(mask)
             elif cfg.mask_type == mask_type.lincomb:
                 mask = cfg.mask_proto_coeff_activation(mask)
 
                 if cfg.mask_proto_coeff_gate:
-                    gate = src.gate_layer(x).permute(0, 2, 3, 1).contiguous().view(x.size(0), -1, self.mask_dim)
+                    gate = (
+                        src.gate_layer(x)
+                        .permute(0, 2, 3, 1)
+                        .contiguous()
+                        .view(x.size(0), -1, self.mask_dim)
+                    )
                     mask = mask * torch.sigmoid(gate)
 
-        if cfg.mask_proto_split_prototypes_by_head and cfg.mask_type == mask_type.lincomb:
-            mask = F.pad(mask, (self.index * self.mask_dim, (self.num_heads - self.index - 1) * self.mask_dim), mode='constant', value=0)
-        
+        if (
+            cfg.mask_proto_split_prototypes_by_head
+            and cfg.mask_type == mask_type.lincomb
+        ):
+            mask = F.pad(
+                mask,
+                (
+                    self.index * self.mask_dim,
+                    (self.num_heads - self.index - 1) * self.mask_dim,
+                ),
+                mode='constant',
+                value=0,
+            )
+
         priors = self.make_priors(conv_h, conv_w, x.device)
 
-        preds = { 'loc': bbox, 'conf': conf, 'mask': mask, 'priors': priors }
+        preds = {'loc': bbox, 'conf': conf, 'mask': mask, 'priors': priors}
 
         if cfg.use_mask_scoring:
             preds['score'] = score
 
         if cfg.use_instance_coeff:
             preds['inst'] = inst
-        
+
         return preds
 
     def make_priors(self, conv_h, conv_w, device):
-        """ Note that priors are [x,y,width,height] where (x,y) is the center of the box. """
+        """Note that priors are [x,y,width,height] where (x,y) is the center of the box."""
         global prior_cache
         size = (conv_h, conv_w)
 
         with timer.env('makepriors'):
             if self.last_img_size != (cfg._tmp_img_w, cfg._tmp_img_h):
                 prior_data = []
 
                 # Iteration order is important (it has to sync up with the convout)
                 for j, i in product(range(conv_h), range(conv_w)):
                     # +0.5 because priors are in center-size notation
                     x = (i + 0.5) / conv_w
                     y = (j + 0.5) / conv_h
-                    
+
                     for ars in self.aspect_ratios:
                         for scale in self.scales:
                             for ar in ars:
                                 if not cfg.backbone.preapply_sqrt:
                                     ar = sqrt(ar)
 
                                 if cfg.backbone.use_pixel_scales:
                                     w = scale * ar / cfg.max_size
                                     h = scale / ar / cfg.max_size
                                 else:
                                     w = scale * ar / conv_w
                                     h = scale / ar / conv_h
-                                
+
                                 # This is for backward compatability with a bug where I made everything square by accident
                                 if cfg.backbone.use_square_anchors:
                                     h = w
 
                                 prior_data += [x, y, w, h]
 
-                self.priors = torch.Tensor(prior_data, device=device).view(-1, 4).detach()
+                self.priors = (
+                    torch.tensor(prior_data).view(-1, 4).to(device).detach()
+                )
                 self.priors.requires_grad = False
                 self.last_img_size = (cfg._tmp_img_w, cfg._tmp_img_h)
                 self.last_conv_size = (conv_w, conv_h)
                 prior_cache[size] = None
             elif self.priors.device != device:
                 # This whole weird situation is so that DataParalell doesn't copy the priors each iteration
                 if prior_cache[size] is None:
                     prior_cache[size] = {}
-                
+
                 if device not in prior_cache[size]:
                     prior_cache[size][device] = self.priors.to(device)
 
                 self.priors = prior_cache[size][device]
-        
+
         return self.priors
 
+
 class FPN(ScriptModuleWrapper):
     """
     Implements a general version of the FPN introduced in
     https://arxiv.org/pdf/1612.03144.pdf
 
     Parameters (in cfg.fpn):
         - num_features (int): The number of output features in the fpn layers.
@@ -276,46 +383,72 @@
         - num_downsample (int): The number of downsampled layers to add onto the selected layers.
                                 These extra layers are downsampled from the last selected layer.
 
     Args:
         - in_channels (list): For each conv layer you supply in the forward pass,
                               how many features will it have?
     """
-    __constants__ = ['interpolation_mode', 'num_downsample', 'use_conv_downsample', 'relu_pred_layers',
-                     'lat_layers', 'pred_layers', 'downsample_layers', 'relu_downsample_layers']
+
+    __constants__ = [
+        'interpolation_mode',
+        'num_downsample',
+        'use_conv_downsample',
+        'relu_pred_layers',
+        'lat_layers',
+        'pred_layers',
+        'downsample_layers',
+        'relu_downsample_layers',
+    ]
 
     def __init__(self, in_channels):
         super().__init__()
 
-        self.lat_layers  = nn.ModuleList([
-            nn.Conv2d(x, cfg.fpn.num_features, kernel_size=1)
-            for x in reversed(in_channels)
-        ])
+        self.lat_layers = nn.ModuleList(
+            [
+                nn.Conv2d(x, cfg.fpn.num_features, kernel_size=1)
+                for x in reversed(in_channels)
+            ]
+        )
 
         # This is here for backwards compatability
         padding = 1 if cfg.fpn.pad else 0
-        self.pred_layers = nn.ModuleList([
-            nn.Conv2d(cfg.fpn.num_features, cfg.fpn.num_features, kernel_size=3, padding=padding)
-            for _ in in_channels
-        ])
+        self.pred_layers = nn.ModuleList(
+            [
+                nn.Conv2d(
+                    cfg.fpn.num_features,
+                    cfg.fpn.num_features,
+                    kernel_size=3,
+                    padding=padding,
+                )
+                for _ in in_channels
+            ]
+        )
 
         if cfg.fpn.use_conv_downsample:
-            self.downsample_layers = nn.ModuleList([
-                nn.Conv2d(cfg.fpn.num_features, cfg.fpn.num_features, kernel_size=3, padding=1, stride=2)
-                for _ in range(cfg.fpn.num_downsample)
-            ])
-        
-        self.interpolation_mode     = cfg.fpn.interpolation_mode
-        self.num_downsample         = cfg.fpn.num_downsample
-        self.use_conv_downsample    = cfg.fpn.use_conv_downsample
+            self.downsample_layers = nn.ModuleList(
+                [
+                    nn.Conv2d(
+                        cfg.fpn.num_features,
+                        cfg.fpn.num_features,
+                        kernel_size=3,
+                        padding=1,
+                        stride=2,
+                    )
+                    for _ in range(cfg.fpn.num_downsample)
+                ]
+            )
+
+        self.interpolation_mode = cfg.fpn.interpolation_mode
+        self.num_downsample = cfg.fpn.num_downsample
+        self.use_conv_downsample = cfg.fpn.use_conv_downsample
         self.relu_downsample_layers = cfg.fpn.relu_downsample_layers
-        self.relu_pred_layers       = cfg.fpn.relu_pred_layers
+        self.relu_pred_layers = cfg.fpn.relu_pred_layers
 
     @script_method_wrapper
-    def forward(self, convouts:List[torch.Tensor]):
+    def forward(self, convouts: List[torch.Tensor]):
         """
         Args:
             - convouts (list): A list of convouts for the corresponding layers in in_channels.
         Returns:
             - A list of FPN convouts in the same order as x with extra downsample layers if requested.
         """
 
@@ -328,19 +461,24 @@
         # given in the correct order. Thus, use j=-i-1 for the input and output and i for the conv layers.
         j = len(convouts)
         for lat_layer in self.lat_layers:
             j -= 1
 
             if j < len(convouts) - 1:
                 _, _, h, w = convouts[j].size()
-                x = F.interpolate(x, size=(h, w), mode=self.interpolation_mode, align_corners=False)
-            
+                x = F.interpolate(
+                    x,
+                    size=(h, w),
+                    mode=self.interpolation_mode,
+                    align_corners=False,
+                )
+
             x = x + lat_layer(convouts[j])
             out[j] = x
-        
+
         # This janky second loop is here because TorchScript.
         j = len(convouts)
         for pred_layer in self.pred_layers:
             j -= 1
             out[j] = pred_layer(out[j])
 
             if self.relu_pred_layers:
@@ -359,40 +497,45 @@
 
         if self.relu_downsample_layers:
             for idx in range(len(out) - cur_idx):
                 out[idx] = F.relu(out[idx + cur_idx], inplace=False)
 
         return out
 
-class FastMaskIoUNet(ScriptModuleWrapper):
 
+class FastMaskIoUNet(ScriptModuleWrapper):
     def __init__(self):
         super().__init__()
         input_channels = 1
-        last_layer = [(cfg.num_classes-1, 1, {})]
-        self.maskiou_net, _ = make_net(input_channels, cfg.maskiou_net + last_layer, include_last_relu=True)
+        last_layer = [(cfg.num_classes - 1, 1, {})]
+        self.maskiou_net, _ = make_net(
+            input_channels,
+            cfg.maskiou_net + last_layer,
+            include_last_relu=True,
+        )
 
     def forward(self, x):
         x = self.maskiou_net(x)
-        maskiou_p = F.max_pool2d(x, kernel_size=x.size()[2:]).squeeze(-1).squeeze(-1)
+        maskiou_p = (
+            F.max_pool2d(x, kernel_size=x.size()[2:]).squeeze(-1).squeeze(-1)
+        )
 
         return maskiou_p
 
 
-
 class Yolact(nn.Module):
     """
 
 
-    ██╗   ██╗ ██████╗ ██╗      █████╗  ██████╗████████╗
-    ╚██╗ ██╔╝██╔═══██╗██║     ██╔══██╗██╔════╝╚══██╔══╝
-     ╚████╔╝ ██║   ██║██║     ███████║██║        ██║   
-      ╚██╔╝  ██║   ██║██║     ██╔══██║██║        ██║   
-       ██║   ╚██████╔╝███████╗██║  ██║╚██████╗   ██║   
-       ╚═╝    ╚═════╝ ╚══════╝╚═╝  ╚═╝ ╚═════╝   ╚═╝ 
+
+
+
+
+
+
 
 
     You can set the arguments by changing them in the backbone config object in config.py.
 
     Parameters (in cfg.backbone):
         - selected_layers: The indices of the conv layers to use for prediction.
         - pred_scales:     A list with len(selected_layers) containing tuples of scales (see PredictionModule)
@@ -414,98 +557,120 @@
             if cfg.mask_proto_use_grid:
                 self.grid = torch.Tensor(np.load(cfg.mask_proto_grid_file))
                 self.num_grids = self.grid.size(0)
             else:
                 self.num_grids = 0
 
             self.proto_src = cfg.mask_proto_src
-            
-            if self.proto_src is None: in_channels = 3
-            elif cfg.fpn is not None: in_channels = cfg.fpn.num_features
-            else: in_channels = self.backbone.channels[self.proto_src]
+
+            if self.proto_src is None:
+                in_channels = 3
+            elif cfg.fpn is not None:
+                in_channels = cfg.fpn.num_features
+            else:
+                in_channels = self.backbone.channels[self.proto_src]
             in_channels += self.num_grids
 
             # The include_last_relu=false here is because we might want to change it to another function
-            self.proto_net, cfg.mask_dim = make_net(in_channels, cfg.mask_proto_net, include_last_relu=False)
+            self.proto_net, cfg.mask_dim = make_net(
+                in_channels, cfg.mask_proto_net, include_last_relu=False
+            )
 
             if cfg.mask_proto_bias:
                 cfg.mask_dim += 1
 
-
         self.selected_layers = cfg.backbone.selected_layers
         src_channels = self.backbone.channels
 
         if cfg.use_maskiou:
             self.maskiou_net = FastMaskIoUNet()
 
         if cfg.fpn is not None:
             # Some hacky rewiring to accomodate the FPN
             self.fpn = FPN([src_channels[i] for i in self.selected_layers])
-            self.selected_layers = list(range(len(self.selected_layers) + cfg.fpn.num_downsample))
+            self.selected_layers = list(
+                range(len(self.selected_layers) + cfg.fpn.num_downsample)
+            )
             src_channels = [cfg.fpn.num_features] * len(self.selected_layers)
 
-
         self.prediction_layers = nn.ModuleList()
         cfg.num_heads = len(self.selected_layers)
 
         for idx, layer_idx in enumerate(self.selected_layers):
             # If we're sharing prediction module weights, have every module's parent be the first one
             parent = None
             if cfg.share_prediction_module and idx > 0:
                 parent = self.prediction_layers[0]
 
-            pred = PredictionModule(src_channels[layer_idx], src_channels[layer_idx],
-                                    aspect_ratios = cfg.backbone.pred_aspect_ratios[idx],
-                                    scales        = cfg.backbone.pred_scales[idx],
-                                    parent        = parent,
-                                    index         = idx)
+            pred = PredictionModule(
+                src_channels[layer_idx],
+                src_channels[layer_idx],
+                aspect_ratios=cfg.backbone.pred_aspect_ratios[idx],
+                scales=cfg.backbone.pred_scales[idx],
+                parent=parent,
+                index=idx,
+            )
             self.prediction_layers.append(pred)
 
         # Extra parameters for the extra losses
         if cfg.use_class_existence_loss:
             # This comes from the smallest layer selected
             # Also note that cfg.num_classes includes background
-            self.class_existence_fc = nn.Linear(src_channels[-1], cfg.num_classes - 1)
-        
+            self.class_existence_fc = nn.Linear(
+                src_channels[-1], cfg.num_classes - 1
+            )
+
         if cfg.use_semantic_segmentation_loss:
-            self.semantic_seg_conv = nn.Conv2d(src_channels[0], cfg.num_classes-1, kernel_size=1)
+            self.semantic_seg_conv = nn.Conv2d(
+                src_channels[0], cfg.num_classes - 1, kernel_size=1
+            )
 
         # For use in evaluation
-        self.detect = Detect(cfg.num_classes, bkg_label=0, top_k=cfg.nms_top_k,
-            conf_thresh=cfg.nms_conf_thresh, nms_thresh=cfg.nms_thresh)
+        self.detect = Detect(
+            cfg.num_classes,
+            bkg_label=0,
+            top_k=cfg.nms_top_k,
+            conf_thresh=cfg.nms_conf_thresh,
+            nms_thresh=cfg.nms_thresh,
+        )
 
     def save_weights(self, path):
-        """ Saves the model's weights using compression because the file sizes were getting too big. """
+        """Saves the model's weights using compression because the file sizes were getting too big."""
         torch.save(self.state_dict(), path)
-    
+
     def load_weights(self, path, cuda=torch.cuda.is_available()):
-        """ Loads weights from a compressed save file. """
+        """Loads weights from a compressed save file."""
         if cuda:
             state_dict = torch.load(path)
         else:
             state_dict = torch.load(path, map_location=torch.device('cpu'))
 
         # For backward compatability, remove these (the new variable is called layers)
         for key in list(state_dict.keys()):
-            if key.startswith('backbone.layer') and not key.startswith('backbone.layers'):
+            if key.startswith('backbone.layer') and not key.startswith(
+                'backbone.layers'
+            ):
                 del state_dict[key]
-        
+
             # Also for backward compatibility with v1.0 weights, do this check
             if key.startswith('fpn.downsample_layers.'):
-                if cfg.fpn is not None and int(key.split('.')[2]) >= cfg.fpn.num_downsample:
+                if (
+                    cfg.fpn is not None
+                    and int(key.split('.')[2]) >= cfg.fpn.num_downsample
+                ):
                     del state_dict[key]
         self.load_state_dict(state_dict)
 
     def init_weights(self, backbone_path):
-        """ Initialize weights for training. """
+        """Initialize weights for training."""
         # Initialize the backbone with the pretrained weights.
         self.backbone.init_backbone(backbone_path)
 
         conv_constants = getattr(nn.Conv2d(1, 1, 1), '__constants__')
-        
+
         # Quick lambda to test if one list contains the other
         def all_in(x, y):
             for _x in x:
                 if _x not in y:
                     return False
             return True
 
@@ -518,18 +683,20 @@
             is_script_conv = False
             if 'Script' in type(module).__name__:
                 # 1.4 workaround: now there's an original_name member so just use that
                 if hasattr(module, 'original_name'):
                     is_script_conv = 'Conv' in module.original_name
                 # 1.3 workaround: check if this has the same constants as a conv module
                 else:
-                    is_script_conv = (
-                        all_in(module.__dict__['_constants_set'], conv_constants)
-                        and all_in(conv_constants, module.__dict__['_constants_set']))
-            
+                    is_script_conv = all_in(
+                        module.__dict__['_constants_set'], conv_constants
+                    ) and all_in(
+                        conv_constants, module.__dict__['_constants_set']
+                    )
+
             is_conv_layer = isinstance(module, nn.Conv2d) or is_script_conv
 
             if is_conv_layer and module not in self.backbone.backbone_modules:
                 nn.init.xavier_uniform_(module.weight.data)
 
                 if module.bias is not None:
                     if cfg.use_focal_loss and 'conf_layer' in name:
@@ -540,116 +707,143 @@
                             # Then let z = sum(exp(x)) - exp(x_0). Finally let c be the number of foreground classes.
                             # Chugging through the math, this gives us
                             #   x_0 = log(z * (1 - pi) / pi)    where 0 is the background class
                             #   x_i = log(z / c)                for all i > 0
                             # For simplicity (and because we have a degree of freedom here), set z = 1. Then we have
                             #   x_0 =  log((1 - pi) / pi)       note: don't split up the log for numerical stability
                             #   x_i = -log(c)                   for all i > 0
-                            module.bias.data[0]  = np.log((1 - cfg.focal_loss_init_pi) / cfg.focal_loss_init_pi)
-                            module.bias.data[1:] = -np.log(module.bias.size(0) - 1)
+                            module.bias.data[0] = np.log(
+                                (1 - cfg.focal_loss_init_pi)
+                                / cfg.focal_loss_init_pi
+                            )
+                            module.bias.data[1:] = -np.log(
+                                module.bias.size(0) - 1
+                            )
                         else:
-                            module.bias.data[0]  = -np.log(cfg.focal_loss_init_pi / (1 - cfg.focal_loss_init_pi))
-                            module.bias.data[1:] = -np.log((1 - cfg.focal_loss_init_pi) / cfg.focal_loss_init_pi)
+                            module.bias.data[0] = -np.log(
+                                cfg.focal_loss_init_pi
+                                / (1 - cfg.focal_loss_init_pi)
+                            )
+                            module.bias.data[1:] = -np.log(
+                                (1 - cfg.focal_loss_init_pi)
+                                / cfg.focal_loss_init_pi
+                            )
                     else:
                         module.bias.data.zero_()
-    
+
     def train(self, mode=True):
         super().train(mode)
 
         if cfg.freeze_bn:
             self.freeze_bn()
 
     def freeze_bn(self, enable=False):
-        """ Adapted from https://discuss.pytorch.org/t/how-to-train-with-frozen-batchnorm/12106/8 """
+        """Adapted from https://discuss.pytorch.org/t/how-to-train-with-frozen-batchnorm/12106/8"""
         for module in self.modules():
             if isinstance(module, nn.BatchNorm2d):
                 module.train() if enable else module.eval()
 
                 module.weight.requires_grad = enable
                 module.bias.requires_grad = enable
-    
+
     def forward(self, x):
-        """ The input should be of size [batch_size, 3, img_h, img_w] """
+        """The input should be of size [batch_size, 3, img_h, img_w]"""
         _, _, img_h, img_w = x.size()
         cfg._tmp_img_h = img_h
         cfg._tmp_img_w = img_w
-        
+
         with timer.env('backbone'):
             outs = self.backbone(x)
 
         if cfg.fpn is not None:
             with timer.env('fpn'):
                 # Use backbone.selected_layers because we overwrote self.selected_layers
                 outs = [outs[i] for i in cfg.backbone.selected_layers]
                 outs = self.fpn(outs)
 
         proto_out = None
         if cfg.mask_type == mask_type.lincomb and cfg.eval_mask_branch:
             with timer.env('proto'):
                 proto_x = x if self.proto_src is None else outs[self.proto_src]
-                
+
                 if self.num_grids > 0:
                     grids = self.grid.repeat(proto_x.size(0), 1, 1, 1)
                     proto_x = torch.cat([proto_x, grids], dim=1)
 
                 proto_out = self.proto_net(proto_x)
                 proto_out = cfg.mask_proto_prototype_activation(proto_out)
 
                 if cfg.mask_proto_prototypes_as_features:
                     # Clone here because we don't want to permute this, though idk if contiguous makes this unnecessary
                     proto_downsampled = proto_out.clone()
 
                     if cfg.mask_proto_prototypes_as_features_no_grad:
                         proto_downsampled = proto_out.detach()
-                
+
                 # Move the features last so the multiplication is easy
                 proto_out = proto_out.permute(0, 2, 3, 1).contiguous()
 
                 if cfg.mask_proto_bias:
                     bias_shape = [x for x in proto_out.size()]
                     bias_shape[-1] = 1
-                    proto_out = torch.cat([proto_out, torch.ones(*bias_shape)], -1)
-
+                    proto_out = torch.cat(
+                        [proto_out, torch.ones(*bias_shape)], -1
+                    )
 
         with timer.env('pred_heads'):
-            pred_outs = { 'loc': [], 'conf': [], 'mask': [], 'priors': [] }
+            pred_outs = {'loc': [], 'conf': [], 'mask': [], 'priors': []}
 
             if cfg.use_mask_scoring:
                 pred_outs['score'] = []
 
             if cfg.use_instance_coeff:
                 pred_outs['inst'] = []
-            
-            for idx, pred_layer in zip(self.selected_layers, self.prediction_layers):
+
+            for idx, pred_layer in zip(
+                self.selected_layers, self.prediction_layers
+            ):
                 pred_x = outs[idx]
 
-                if cfg.mask_type == mask_type.lincomb and cfg.mask_proto_prototypes_as_features:
+                if (
+                    cfg.mask_type == mask_type.lincomb
+                    and cfg.mask_proto_prototypes_as_features
+                ):
                     # Scale the prototypes down to the current prediction layer's size and add it as inputs
-                    proto_downsampled = F.interpolate(proto_downsampled, size=outs[idx].size()[2:], mode='bilinear', align_corners=False)
+                    proto_downsampled = F.interpolate(
+                        proto_downsampled,
+                        size=outs[idx].size()[2:],
+                        mode='bilinear',
+                        align_corners=False,
+                    )
                     pred_x = torch.cat([pred_x, proto_downsampled], dim=1)
 
                 # A hack for the way dataparallel works
-                if cfg.share_prediction_module and pred_layer is not self.prediction_layers[0]:
+                if (
+                    cfg.share_prediction_module
+                    and pred_layer is not self.prediction_layers[0]
+                ):
                     pred_layer.parent = [self.prediction_layers[0]]
 
                 p = pred_layer(pred_x)
-                
+
                 for k, v in p.items():
                     pred_outs[k].append(v)
 
         for k, v in pred_outs.items():
             pred_outs[k] = torch.cat(v, -2)
 
         if proto_out is not None:
             pred_outs['proto'] = proto_out
 
         if self.training:
             # For the extra loss functions
             if cfg.use_class_existence_loss:
-                pred_outs['classes'] = self.class_existence_fc(outs[-1].mean(dim=(2, 3)))
+                pred_outs['classes'] = self.class_existence_fc(
+                    outs[-1].mean(dim=(2, 3))
+                )
 
             if cfg.use_semantic_segmentation_loss:
                 pred_outs['segm'] = self.semantic_seg_conv(outs[0])
 
             return pred_outs
         else:
             if cfg.use_mask_scoring:
@@ -660,43 +854,46 @@
                     # Note: even though conf[0] exists, this mode doesn't train it so don't use it
                     pred_outs['conf'] = torch.sigmoid(pred_outs['conf'])
                     if cfg.use_mask_scoring:
                         pred_outs['conf'] *= pred_outs['score']
                 elif cfg.use_objectness_score:
                     # See focal_loss_sigmoid in multibox_loss.py for details
                     objectness = torch.sigmoid(pred_outs['conf'][:, :, 0])
-                    pred_outs['conf'][:, :, 1:] = objectness[:, :, None] * F.softmax(pred_outs['conf'][:, :, 1:], -1)
-                    pred_outs['conf'][:, :, 0 ] = 1 - objectness
+                    pred_outs['conf'][:, :, 1:] = objectness[
+                        :, :, None
+                    ] * F.softmax(pred_outs['conf'][:, :, 1:], -1)
+                    pred_outs['conf'][:, :, 0] = 1 - objectness
                 else:
                     pred_outs['conf'] = F.softmax(pred_outs['conf'], -1)
             else:
-
                 if cfg.use_objectness_score:
                     objectness = torch.sigmoid(pred_outs['conf'][:, :, 0])
-                    
-                    pred_outs['conf'][:, :, 1:] = (objectness > 0.10)[..., None] \
-                        * F.softmax(pred_outs['conf'][:, :, 1:], dim=-1)
-                    
+
+                    pred_outs['conf'][:, :, 1:] = (objectness > 0.10)[
+                        ..., None
+                    ] * F.softmax(pred_outs['conf'][:, :, 1:], dim=-1)
+
                 else:
                     pred_outs['conf'] = F.softmax(pred_outs['conf'], -1)
 
             return self.detect(pred_outs, self)
 
 
-
-
 # Some testing code
 if __name__ == '__main__':
     from utils.functions import init_console
+
     init_console()
 
     # Use the first argument to set the config if you want
     import sys
+
     if len(sys.argv) > 1:
         from data.config import set_cfg
+
         set_cfg(sys.argv[1])
 
     net = Yolact()
     net.train()
     net.init_weights(backbone_path='weights/' + cfg.backbone.path)
 
     # GPU
@@ -709,22 +906,25 @@
     for p in net.prediction_layers:
         print(p.last_conv_size)
 
     print()
     for k, a in y.items():
         print(k + ': ', a.size(), torch.sum(a))
     exit()
-    
+
     net(x)
     # timer.disable('pass2')
     avg = MovingAverage()
     try:
         while True:
             timer.reset()
             with timer.env('everything else'):
                 net(x)
             avg.add(timer.total_time())
-            print('\033[2J') # Moves console cursor to 0,0
+            print('\033[2J')  # Moves console cursor to 0,0
             timer.print_stats()
-            print('Avg fps: %.2f\tAvg ms: %.2f         ' % (1/avg.get_avg(), avg.get_avg()*1000))
+            print(
+                'Avg fps: %.2f\tAvg ms: %.2f         '
+                % (1 / avg.get_avg(), avg.get_avg() * 1000)
+            )
     except KeyboardInterrupt:
         pass
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

