# Comparing `tmp/ntnx-dataprotection-py-client-4.0.1a4.tar.gz` & `tmp/ntnx_dataprotection_py_client-4.0.1b1.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "/home/circleci/project/verify/pip-release-verify/prod-package-dataprotection/dist/.tmp-ta7pveen/ntnx-dataprotection-py-client-4", last modified: Mon Sep 18 22:30:25 2023, max compression
+gzip compressed data, was "/home/circleci/project/verify/pip-release-verify/prod-package-dataprotection/dist/.tmp-a83wse3k/ntnx_dataprotection_py_client-4", last modified: Fri May 17 07:11:56 2024, max compression
```

## Comparing `ntnx-dataprotection-py-client-4.0.1a4.tar` & `ntnx_dataprotection_py_client-4.0.1b1.tar`

### file list

```diff
@@ -1,200 +1,170 @@
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:25.872526 ntnx-dataprotection-py-client-4.0.1a4/
--rw-r--r--   0 circleci  (3434) circleci  (3434)    18137 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/LICENSE.txt
--rw-r--r--   0 circleci  (3434) circleci  (3434)    11915 2023-09-18 22:30:25.872526 ntnx-dataprotection-py-client-4.0.1a4/PKG-INFO
--rw-r--r--   0 circleci  (3434) circleci  (3434)    11467 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/README.md
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:25.839526 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/
--rw-r--r--   0 circleci  (3434) circleci  (3434)    17724 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:25.841526 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/api/
--rw-r--r--   0 circleci  (3434) circleci  (3434)      176 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/api/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    28203 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/api/consistency_group_api.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    48880 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/api_client.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     2634 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/api_response.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    15969 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/configuration.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:25.841526 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:25.841526 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfcommon/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfcommon/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:25.841526 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfcommon/v1/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfcommon/v1/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:25.842526 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfcommon/v1/config/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6776 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfcommon/v1/config/KVPairvalue.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfcommon/v1/config/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:25.842526 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:25.842526 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:25.848526 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6957 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/ChangedRegionsListApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6947 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/ConsistencyGroupApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7117 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/ConsistencyGroupListApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7032 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/ConsistencyGroupMigrateApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7148 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/CreateConsistencyGroupRecoveryPointApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7036 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/CreateRecoveryPointApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6891 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/DeleteConsistencyGroupApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7004 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/DeleteRecoveryPointApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6956 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/DiskRecoveryPointApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6996 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/DiskRecoveryPointListApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6956 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/ProtectedResourceApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6979 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/ProtectedResourcePromoteApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6979 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/ProtectedResourceRestoreApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6920 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/RecoveryPointApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6960 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/RecoveryPointListApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7025 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/RecoveryPointReplicateApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7011 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/RecoveryPointRestoreApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6994 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/SyncedVolumeGroupByIdApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6986 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/SynchronousReplicaPromoteApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7042 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/UpdateRecoveryPointExpirationTimeApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6938 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/VMRecoveryPointApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6978 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/VMRecoveryPointListApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7079 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/ValidateRestoreVmRecoveryPointApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7025 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/VmRecoveryPointRestoreApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7019 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/VolumeGroupRecoveryPointApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7059 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/VolumeGroupRecoveryPointListApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7088 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/VolumeGroupRecoveryPointRestoreApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6866 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/WitnessApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:25.848526 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/error/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6870 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/error/ErrorResponseerror.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/error/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    17521 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:25.848526 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/common/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/common/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:25.848526 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/common/v1/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/common/v1/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:25.850526 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/common/v1/config/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6921 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/common/v1/config/Flag.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7765 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/common/v1/config/IPv4Address.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7371 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/common/v1/config/KVPair.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8101 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/common/v1/config/Message.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4921 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/common/v1/config/MessageSeverity.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7580 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/common/v1/config/TenantAwareModel.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/common/v1/config/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:25.851526 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/common/v1/response/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7227 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/common/v1/response/ApiLink.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    10507 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/common/v1/response/ApiResponseMetadata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6086 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/common/v1/response/ExternalizableAbstractModel.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/common/v1/response/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:25.851526 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:25.851526 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:25.852526 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/common/
--rw-r--r--   0 circleci  (3434) circleci  (3434)    10572 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/common/BaseRecoveryPoint.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     5263 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/common/RecoveryPointStatus.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     5213 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/common/RecoveryPointType.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7584 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/common/VendorSpecificProperty.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/common/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:25.869526 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6620 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/AhvVmOverrideSpec.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6988 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/Category.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7881 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ChangedRegions.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7891 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ChangedRegionsListApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7431 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ClusterReference.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7236 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ConsistencyGroup.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7763 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ConsistencyGroupApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7905 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ConsistencyGroupListApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8908 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ConsistencyGroupMember.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     5094 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ConsistencyGroupMemberType.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7914 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ConsistencyGroupMigrateApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8718 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ConsistencyGroupMigrationSpec.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     5669 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ConsistencyGroupProjection.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7686 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ConsistencyGroupRecoveryPointSpec.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8040 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/CreateConsistencyGroupRecoveryPointApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7870 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/CreateRecoveryPointApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7776 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/DataProtectionInfo.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7890 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/DataProtectionSiteReference.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7706 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/DeleteConsistencyGroupApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7864 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/DeleteRecoveryPointApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8172 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/DisasterRecoveryLocation.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7581 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/Disk.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6036 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/DiskRecoveryPoint.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7889 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/DiskRecoveryPointApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7896 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/DiskRecoveryPointListApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6626 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/EsxiVmOverrideSpec.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4965 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/HardwareArchitecture.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     5366 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/HostReference.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4859 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/HostType.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4961 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/HypervisorType.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6770 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/IpAddress.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7050 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/LocationReference.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4895 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/PowerState.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     9779 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ProtectedResource.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7773 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ProtectedResourceApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4979 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ProtectedResourceEntityType.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7834 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ProtectedResourcePromoteApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     5729 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ProtectedResourceReplicationStatus.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7834 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ProtectedResourceRestoreApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8338 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ProtectedResourceRestoreSpec.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6980 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/RecoveryInfo.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    12229 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/RecoveryPoint.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7733 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/RecoveryPointApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7757 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/RecoveryPointListApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7905 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/RecoveryPointReplicateApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     5974 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/RecoveryPointReplicationSpec.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    11708 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/RecoveryPointRestorationSpec.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7887 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/RecoveryPointRestoreApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6992 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/Regions.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    10207 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ReplicationState.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7464 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/RestorableTimeRange.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7000 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/SetExpirationTimeSpec.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8533 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/SiteReference.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6438 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/Subnet.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7811 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/SyncedVolumeGroupByIdApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7843 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/SynchronousReplicaPromoteApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7914 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/UpdateRecoveryPointExpirationTimeApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7382 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/VMRecoveryPoint.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7806 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/VMRecoveryPointApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7815 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/VMRecoveryPointListApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7966 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ValidateRecoveryPointResult.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7965 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ValidateRestoreVmRecoveryPointApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4965 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ValidationSeverity.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    12702 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/Vm.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     9467 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/VmRecoveryPointRestorationSpec.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7958 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/VmRecoveryPointRestoreApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     9217 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/VmRecoveryPointRestoreOverride.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    12039 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/VmSubRecoveryPoint.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     5553 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/VmSubRecoveryPointProjection.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7706 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/VolumeGroup.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6688 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/VolumeGroupOverrideSpec.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7652 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/VolumeGroupRecoveryPoint.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7906 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/VolumeGroupRecoveryPointApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7906 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/VolumeGroupRecoveryPointListApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8269 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/VolumeGroupRecoveryPointRestorationSpec.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8049 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/VolumeGroupRecoveryPointRestoreApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8664 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/VolumeGroupRecoveryPointRestoreOverride.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    12751 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/VolumeGroupSubRecoveryPoint.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     5901 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/VolumeGroupSubRecoveryPointProjection.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7728 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/VolumeGroupSyncContext.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7337 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/VpcReference.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6984 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/Witness.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7671 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/WitnessApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4991 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/WitnessAvailabilityStatus.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:25.870526 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/error/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     9172 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/error/AppMessage.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6933 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/error/ErrorResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8944 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/error/SchemaValidationError.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7541 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/error/SchemaValidationErrorMessage.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/error/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:25.870526 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/prism/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/prism/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:25.870526 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/prism/v4/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/prism/v4/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:25.871526 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/prism/v4/config/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6924 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/prism/v4/config/TaskReference.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/prism/v4/config/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:25.871526 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/storage/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/storage/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:25.871526 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/storage/v4/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/storage/v4/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:25.871526 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/storage/v4/config/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6690 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/storage/v4/config/Task.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/storage/v4/config/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    16168 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/rest.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:25.840526 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client.egg-info/
--rw-r--r--   0 circleci  (3434) circleci  (3434)    11915 2023-09-18 22:30:25.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client.egg-info/PKG-INFO
--rw-r--r--   0 circleci  (3434) circleci  (3434)    14301 2023-09-18 22:30:25.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client.egg-info/SOURCES.txt
--rw-r--r--   0 circleci  (3434) circleci  (3434)        1 2023-09-18 22:30:25.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client.egg-info/dependency_links.txt
--rw-r--r--   0 circleci  (3434) circleci  (3434)       78 2023-09-18 22:30:25.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client.egg-info/requires.txt
--rw-r--r--   0 circleci  (3434) circleci  (3434)       30 2023-09-18 22:30:25.000000 ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client.egg-info/top_level.txt
--rw-r--r--   0 circleci  (3434) circleci  (3434)       38 2023-09-18 22:30:25.872526 ntnx-dataprotection-py-client-4.0.1a4/setup.cfg
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1533 2023-09-18 22:30:16.000000 ntnx-dataprotection-py-client-4.0.1a4/setup.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:56.993674 ntnx_dataprotection_py_client-4.0.1b1/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    18137 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/LICENSE.txt
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    12102 2024-05-17 07:11:56.992673 ntnx_dataprotection_py_client-4.0.1b1/PKG-INFO
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    11641 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/README.md
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:56.964673 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    14514 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:56.966673 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/api/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      264 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/api/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    16491 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/api/protected_resources_api.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    41324 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/api/recovery_points_api.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    48696 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/api_client.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2633 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/api_response.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    16895 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/configuration.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:56.966673 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:56.966673 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfcommon/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfcommon/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:56.966673 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfcommon/v1/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfcommon/v1/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:56.967673 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfcommon/v1/config/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7179 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfcommon/v1/config/KVPairvalue.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfcommon/v1/config/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:56.967673 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfdataprotection/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfdataprotection/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:56.967673 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:56.971673 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7425 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/ComputeChangedRegionsResponseModeldata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7406 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/ComputeChangedRegionsResponseresponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7392 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/CreateConsistencyGroupApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7347 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/CreateRecoveryPointApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7294 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/DeleteConsistencyGroupApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7347 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/DeleteRecoveryPointApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7380 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/GetProtectedResourceApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7344 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/GetRecoveryPointApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7494 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/ListRecoveryPointsApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7375 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/MigrateConsistencyGroupApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7382 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/ProtectedResourcePromoteApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7382 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/ProtectedResourceRestoreApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7523 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/ProtectedResourceRestoreSpecoverrides.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7368 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/RecoveryPointReplicateApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7678 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/RecoveryPointRepositoryProjectionobject_storage_reference.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7608 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/RecoveryPointRepositoryobject_storage_reference.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7354 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/RecoveryPointRestoreApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7389 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/SynchronousReplicaPromoteApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7390 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/UpdateConsistencyGroupApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7445 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/UpdateRecoveryPointExpirationTimeApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:56.972674 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/error/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7273 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/error/ErrorResponseerror.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/error/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    14223 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:56.972674 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/common/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/common/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:56.972674 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/common/v1/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/common/v1/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:56.974673 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/common/v1/config/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7305 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/common/v1/config/Flag.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8142 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/common/v1/config/IPv4Address.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7753 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/common/v1/config/KVPair.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8482 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/common/v1/config/Message.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5368 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/common/v1/config/MessageSeverity.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7954 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/common/v1/config/TenantAwareModel.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/common/v1/config/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:56.974673 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/common/v1/response/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7606 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/common/v1/response/ApiLink.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    10894 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/common/v1/response/ApiResponseMetadata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6352 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/common/v1/response/ExternalizableAbstractModel.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/common/v1/response/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:56.975674 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:56.975674 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:56.976673 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/common/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     9569 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/common/BaseRecoveryPoint.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5582 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/common/RecoveryPointStatus.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5534 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/common/RecoveryPointType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/common/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:56.990674 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7000 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/AhvVmOverrideSpec.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7436 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/AmazonS3Bucket.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7813 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/AzureBlobStorageContainer.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7360 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/Category.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7795 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ClusterReference.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7729 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ComputeChangedRegionsResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8312 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ComputeChangedRegionsResponseModel.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    10126 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ConsistencyGroup.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8369 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ConsistencyGroupMember.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5406 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ConsistencyGroupMemberType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8807 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ConsistencyGroupMigrationSpec.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6588 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ConsistencyGroupProjection.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8151 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/CreateConsistencyGroupApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8115 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/CreateRecoveryPointApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8452 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/DataProtectionSiteReference.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8053 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/DeleteConsistencyGroupApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8125 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/DeleteRecoveryPointApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8528 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/DisasterRecoveryLocation.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8612 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/DiskRecoveryPoint.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7005 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/EsxiVmOverrideSpec.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7289 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ExpirationTimeSpec.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8146 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/GetProtectedResourceApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8110 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/GetRecoveryPointApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5802 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/HostReference.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5189 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/HostType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7141 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/IpAddress.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8231 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ListRecoveryPointsApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7413 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/LocationReference.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8171 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/MigrateConsistencyGroupApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6846 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/NutanixObjectsBucket.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5426 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ObjectStorageType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5376 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ProtectedEntityType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    11129 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ProtectedResource.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8179 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ProtectedResourcePromoteApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5795 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ProtectedResourceReplicationStatus.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8179 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ProtectedResourceRestoreApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    10254 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ProtectedResourceRestoreSpec.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7348 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/RecoveryInfo.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    10755 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/RecoveryPoint.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8728 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/RecoveryPointProjection.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8163 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/RecoveryPointReplicateApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8350 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/RecoveryPointReplicationSpec.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7915 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/RecoveryPointRepository.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6436 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/RecoveryPointRepositoryProjection.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    12060 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/RecoveryPointRestorationSpec.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8147 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/RecoveryPointRestoreApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7722 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/RedirectionResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8347 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/Region.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8003 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/RegionResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5251 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/RegionType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    11173 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ReplicationState.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7825 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/RestorableTimeRange.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8148 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/SiteProtectionInfo.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8900 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/SiteReference.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6812 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/Subnet.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8187 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/SynchronousReplicaPromoteApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8151 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/UpdateConsistencyGroupApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8250 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/UpdateRecoveryPointExpirationTimeApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8970 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/VmRecoveryPoint.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    13257 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/VmRecoveryPointComputeChangedRegionsRequest.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7845 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/VmRecoveryPointRestoreOverride.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7064 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/VolumeGroupOverrideSpec.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8491 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/VolumeGroupRecoveryPoint.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    13552 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/VolumeGroupRecoveryPointComputeChangedRegionsRequest.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8971 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/VolumeGroupRecoveryPointRestoreOverride.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8086 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/VolumeGroupSyncContext.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7676 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/VpcReference.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7392 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/Witness.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5304 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/WitnessAvailabilityStatus.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:56.991674 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/error/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    10122 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/error/AppMessage.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7301 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/error/ErrorResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     9660 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/error/SchemaValidationError.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8338 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/error/SchemaValidationErrorMessage.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/error/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:56.991674 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/prism/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/prism/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:56.991674 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/prism/v4/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/prism/v4/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:56.992673 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/prism/v4/config/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7302 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/prism/v4/config/TaskReference.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/prism/v4/config/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    16791 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/rest.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:56.992673 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client.egg-info/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    12102 2024-05-17 07:11:56.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client.egg-info/PKG-INFO
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    11811 2024-05-17 07:11:56.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client.egg-info/SOURCES.txt
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        1 2024-05-17 07:11:56.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client.egg-info/dependency_links.txt
+-rw-r--r--   0 circleci  (3434) circleci  (3434)       91 2024-05-17 07:11:56.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client.egg-info/requires.txt
+-rw-r--r--   0 circleci  (3434) circleci  (3434)       30 2024-05-17 07:11:56.000000 ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client.egg-info/top_level.txt
+-rw-r--r--   0 circleci  (3434) circleci  (3434)       38 2024-05-17 07:11:56.993674 ntnx_dataprotection_py_client-4.0.1b1/setup.cfg
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1544 2024-05-17 07:11:51.000000 ntnx_dataprotection_py_client-4.0.1b1/setup.py
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/LICENSE.txt` & `ntnx_dataprotection_py_client-4.0.1b1/LICENSE.txt`

 * *Files identical despite different names*

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/PKG-INFO` & `ntnx_dataprotection_py_client-4.0.1b1/PKG-INFO`

 * *Files 3% similar despite different names*

```diff
@@ -1,37 +1,37 @@
 Metadata-Version: 2.1
 Name: ntnx-dataprotection-py-client
-Version: 4.0.1a4
+Version: 4.0.1b1
 Summary: Nutanix Dataprotection Versioned APIs
 Home-page: 
 Author-email: sdk@nutanix.com
 Keywords: Nutanix,v4,SDK,Nutanix Dataprotection Versioned APIs
 Description-Content-Type: text/markdown
 License-File: LICENSE.txt
 Requires-Dist: urllib3~=1.26
 Requires-Dist: six~=1.16
-Requires-Dist: certifi==2020.4.5.1
+Requires-Dist: certifi<=2023.11.17,>=2020.4.5.1
 Requires-Dist: python-dateutil~=2.8
 Requires-Dist: pysocks~=1.7
 
 # Python Client For Nutanix Dataprotection Versioned APIs
 
 The Python client for Nutanix Dataprotection Versioned APIs is designed for Python client application developers offering them simple and flexible access to APIs that business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.
 ## Features
 - Invoke Nutanix APIs with a simple interface.
 - Handle Authentication seamlessly.
 - Reduce boilerplate code implementation.
 - Use standard methods for installation.
 
 ## Version
-- API version: v4.0.a4
-- Package version: 4.0.1a4
+- API version: v4.0.b1
+- Package version: 4.0.1b1
 
 ## Requirements.
-Python 3.6, 3.7, and 3.8 are fully supported and tested.
+Python 3.6, 3.7, 3.8 and 3.9 are fully supported and tested.
 
 
 ## Installation & Usage
 
 ### Installing in a virtual environment
 [virtualenv](https://virtualenv.pypa.io/en/latest/) is a tool to create isolated Python environments. The basic problem it addresses is one of dependencies and versions, and indirectly permissions. virtualenv can help you install this client without needing system install permissions. It creates an environment that has its own installation directories without sharing libraries with other virtualenv environments or the system installation.
 
@@ -85,14 +85,15 @@
 | debug     | Runs the client in debug mode if specified                                       | No       | False        |
 | verify_ssl| Verify SSL certificate of cluster the client will connect to                     | No       | True         |
 | max_retry_attempts| Maximum number of retry attempts while connecting to the cluster         | No       | 5            |
 | backoff_factor| A backoff factor to apply between attempts after the second try.             | No       | 3            |
 | logger_file | File location to which debug logs are written to                               | No       | N/A          |
 | connect_timeout | Connection timeout in milliseconds for all operations                      | No       | 30000        |
 | read_timeout | Read timeout in milliseconds for all operations                               | No       | 30000        |
+| download_directory| Directory where downloaded files will be stored in                       | No       | Current Working Directory|
 
 
 ### Sample Configuration
 ```python
 config = Configuration()
 config.host = '10.19.50.27' # IPv4/IPv6 address or FQDN of the cluster
 config.port = 9440 # Port to which to connect to
@@ -142,79 +143,79 @@
 ```
 
 ## Usage
 
 ### Invoking an operation
 ```python
 # Initialize the API
-consistency_group_api_instance = ConsistencyGroupApi(api_client=client) # client configured in previous step
+consistency_groups_api_instance = ConsistencyGroupsApi(api_client=client) # client configured in previous step
 extId = 'extId_example' # UUID.
 
-# Get a Consistency group.
+# Get a Consistency group
 try:
-    api_response = consistency_group_api_instance.get_consistency_group(extId)
+    api_response = consistency_groups_api_instance.get_consistency_group_by_id(extId)
 except ApiException as e:
 ```
 
 ### Setting headers for individual operations
 Headers can be configured globally on the python client using the [method to set default headers](#additional-headers). However, sometimes headers need to be set on an individual operation basis. Nutanix APIs require that concurrent updates are protected using [ETag headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag).
 
 ```python
 # Initialize the API
-consistency_group_api_instance = ConsistencyGroupApi(api_client=client) # client configured in previous step
+consistency_groups_api_instance = ConsistencyGroupsApi(api_client=client) # client configured in previous step
 extId = 'extId_example' # UUID.
 
-# Get a Consistency group.
+# Get a Consistency group
 try:
-    api_response = consistency_group_api_instance.get_consistency_group(extId)
+    api_response = consistency_groups_api_instance.get_consistency_group_by_id(extId)
 except ApiException as e:
 
 # Extract E-Tag Header
 etag_value = ApiClient.get_etag(api_response)
 
-# Update a Consistency group.
+# Update a Consistency group
 try:
     # The body parameter in the following operation is received from the previous GET request's response which needs to be updated.
-    api_response = consistency_group_api_instance.update_consistency_group(body, extId, if_match=etag_value) # Use the extracted etag value
+    api_response = consistency_groups_api_instance.update_consistency_group_by_id(body, extId, if_match=etag_value) # Use the extracted etag value
 except ApiException as e:
 ```
 
 ### List Operations
 List Operations for Nutanix APIs support pagination, filtering, sorting and projections. The table below details the parameters that can be used to set the options for pagination etc.
 
 | Parameter | Description
 |-----------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
 | _page     | specifies the page number of the result set. Must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range will lead to no results being returned.|
 | _limit    | specifies the total number of records returned in the result set. Must be a positive integer between 0 and 100. Any number out of this range will lead to a validation error. If the limit is not provided a default value of 50 records will be returned in the result set|
 | _filter   | allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the [OData V4.01 URL](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part2-url-conventions.html#sec_SystemQueryOptionfilter) conventions. |
 | _orderby  | allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified the resources will be sorted in ascending order by default. For example, 'orderby=templateName desc' would get all templates sorted by templateName in desc order. |
-| _select   | allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the OData V4.01 URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e. *), then all properties on the matching resource will be returned. |
-| _expand   | allows clients to request related resources when a resource that satisfies a particular request is retrieved. Each expand item is evaluated relative to the entity containing the property being expanded. Other query options can be applied to an expanded property by appending a semicolon-separated list of query options, enclosed in parentheses, to the property name. Allowed system query options are $filter,$select, $orderby. |
+| _select   | allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the OData V4.01 URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e., *), then all properties on the matching resource will be returned. |
+| _expand   | allows clients to request related resources when a resource that satisfies a particular request is retrieved. Each expanded item is evaluated relative to the entity containing the property being expanded. Other query options can be applied to an expanded property by appending a semicolon-separated list of query options, enclosed in parentheses, to the property name. Permissible system query options are $filter,$select and $orderby. |
 
 ```python
 # Initialize the API
-consistency_group_api_instance = ConsistencyGroupApi(api_client=client) # client configured in previous step
+consistency_groups_api_instance = ConsistencyGroupsApi(api_client=client) # client configured in previous step
 extId = 'extId_example' # UUID.
 
-# List Consistency groups.
+# List Consistency groups
 try:
-    api_response = consistency_group_api_instance.get_consistency_groups(
+    api_response = consistency_groups_api_instance.list_consistency_groups(
 	                   _page=page, # if page parameter is present
 	                   _limit=limit, # if limit parameter is present
 	                   _filter=_filter, # if filter parameter is present
 	                   _orderby=_orderby, # if orderby parameter is present
 	                   _select=select, # if select parameter is present
 	                   _expand=expand) # if expand parameter is present
 except ApiException as e:
 
 ```
 The list of filterable and sortable fields with expansion keys can be found in the documentation [here](https://developers.nutanix.com/).
 
 ## API Reference
 
-This library has a full set of [API Reference Documentation](https://developers.nutanix.com/sdk-reference?namespace=dataprotection&version=v4.0.a4&language=python). This documentation is auto-generated, and the location may change.
+This library has a full set of [API Reference Documentation](https://developers.nutanix.com/sdk-reference?namespace=dataprotection&version=v4.0.b1&language=python). This documentation is auto-generated, and the location may change.
 
 ## License
 This library is licensed under Nutanix proprietary license. Full license text is available in [LICENSE](https://developers.nutanix.com/license).
 
 ## Contact us
 In case of issues please reach out to us at the [mailing list](mailto:sdk@nutanix.com)
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/README.md` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client.egg-info/PKG-INFO`

 * *Files 3% similar despite different names*

```diff
@@ -1,22 +1,37 @@
+Metadata-Version: 2.1
+Name: ntnx-dataprotection-py-client
+Version: 4.0.1b1
+Summary: Nutanix Dataprotection Versioned APIs
+Home-page: 
+Author-email: sdk@nutanix.com
+Keywords: Nutanix,v4,SDK,Nutanix Dataprotection Versioned APIs
+Description-Content-Type: text/markdown
+License-File: LICENSE.txt
+Requires-Dist: urllib3~=1.26
+Requires-Dist: six~=1.16
+Requires-Dist: certifi<=2023.11.17,>=2020.4.5.1
+Requires-Dist: python-dateutil~=2.8
+Requires-Dist: pysocks~=1.7
+
 # Python Client For Nutanix Dataprotection Versioned APIs
 
 The Python client for Nutanix Dataprotection Versioned APIs is designed for Python client application developers offering them simple and flexible access to APIs that business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.
 ## Features
 - Invoke Nutanix APIs with a simple interface.
 - Handle Authentication seamlessly.
 - Reduce boilerplate code implementation.
 - Use standard methods for installation.
 
 ## Version
-- API version: v4.0.a4
-- Package version: 4.0.1a4
+- API version: v4.0.b1
+- Package version: 4.0.1b1
 
 ## Requirements.
-Python 3.6, 3.7, and 3.8 are fully supported and tested.
+Python 3.6, 3.7, 3.8 and 3.9 are fully supported and tested.
 
 
 ## Installation & Usage
 
 ### Installing in a virtual environment
 [virtualenv](https://virtualenv.pypa.io/en/latest/) is a tool to create isolated Python environments. The basic problem it addresses is one of dependencies and versions, and indirectly permissions. virtualenv can help you install this client without needing system install permissions. It creates an environment that has its own installation directories without sharing libraries with other virtualenv environments or the system installation.
 
@@ -70,14 +85,15 @@
 | debug     | Runs the client in debug mode if specified                                       | No       | False        |
 | verify_ssl| Verify SSL certificate of cluster the client will connect to                     | No       | True         |
 | max_retry_attempts| Maximum number of retry attempts while connecting to the cluster         | No       | 5            |
 | backoff_factor| A backoff factor to apply between attempts after the second try.             | No       | 3            |
 | logger_file | File location to which debug logs are written to                               | No       | N/A          |
 | connect_timeout | Connection timeout in milliseconds for all operations                      | No       | 30000        |
 | read_timeout | Read timeout in milliseconds for all operations                               | No       | 30000        |
+| download_directory| Directory where downloaded files will be stored in                       | No       | Current Working Directory|
 
 
 ### Sample Configuration
 ```python
 config = Configuration()
 config.host = '10.19.50.27' # IPv4/IPv6 address or FQDN of the cluster
 config.port = 9440 # Port to which to connect to
@@ -127,79 +143,79 @@
 ```
 
 ## Usage
 
 ### Invoking an operation
 ```python
 # Initialize the API
-consistency_group_api_instance = ConsistencyGroupApi(api_client=client) # client configured in previous step
+consistency_groups_api_instance = ConsistencyGroupsApi(api_client=client) # client configured in previous step
 extId = 'extId_example' # UUID.
 
-# Get a Consistency group.
+# Get a Consistency group
 try:
-    api_response = consistency_group_api_instance.get_consistency_group(extId)
+    api_response = consistency_groups_api_instance.get_consistency_group_by_id(extId)
 except ApiException as e:
 ```
 
 ### Setting headers for individual operations
 Headers can be configured globally on the python client using the [method to set default headers](#additional-headers). However, sometimes headers need to be set on an individual operation basis. Nutanix APIs require that concurrent updates are protected using [ETag headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag).
 
 ```python
 # Initialize the API
-consistency_group_api_instance = ConsistencyGroupApi(api_client=client) # client configured in previous step
+consistency_groups_api_instance = ConsistencyGroupsApi(api_client=client) # client configured in previous step
 extId = 'extId_example' # UUID.
 
-# Get a Consistency group.
+# Get a Consistency group
 try:
-    api_response = consistency_group_api_instance.get_consistency_group(extId)
+    api_response = consistency_groups_api_instance.get_consistency_group_by_id(extId)
 except ApiException as e:
 
 # Extract E-Tag Header
 etag_value = ApiClient.get_etag(api_response)
 
-# Update a Consistency group.
+# Update a Consistency group
 try:
     # The body parameter in the following operation is received from the previous GET request's response which needs to be updated.
-    api_response = consistency_group_api_instance.update_consistency_group(body, extId, if_match=etag_value) # Use the extracted etag value
+    api_response = consistency_groups_api_instance.update_consistency_group_by_id(body, extId, if_match=etag_value) # Use the extracted etag value
 except ApiException as e:
 ```
 
 ### List Operations
 List Operations for Nutanix APIs support pagination, filtering, sorting and projections. The table below details the parameters that can be used to set the options for pagination etc.
 
 | Parameter | Description
 |-----------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
 | _page     | specifies the page number of the result set. Must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range will lead to no results being returned.|
 | _limit    | specifies the total number of records returned in the result set. Must be a positive integer between 0 and 100. Any number out of this range will lead to a validation error. If the limit is not provided a default value of 50 records will be returned in the result set|
 | _filter   | allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the [OData V4.01 URL](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part2-url-conventions.html#sec_SystemQueryOptionfilter) conventions. |
 | _orderby  | allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified the resources will be sorted in ascending order by default. For example, 'orderby=templateName desc' would get all templates sorted by templateName in desc order. |
-| _select   | allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the OData V4.01 URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e. *), then all properties on the matching resource will be returned. |
-| _expand   | allows clients to request related resources when a resource that satisfies a particular request is retrieved. Each expand item is evaluated relative to the entity containing the property being expanded. Other query options can be applied to an expanded property by appending a semicolon-separated list of query options, enclosed in parentheses, to the property name. Allowed system query options are $filter,$select, $orderby. |
+| _select   | allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the OData V4.01 URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e., *), then all properties on the matching resource will be returned. |
+| _expand   | allows clients to request related resources when a resource that satisfies a particular request is retrieved. Each expanded item is evaluated relative to the entity containing the property being expanded. Other query options can be applied to an expanded property by appending a semicolon-separated list of query options, enclosed in parentheses, to the property name. Permissible system query options are $filter,$select and $orderby. |
 
 ```python
 # Initialize the API
-consistency_group_api_instance = ConsistencyGroupApi(api_client=client) # client configured in previous step
+consistency_groups_api_instance = ConsistencyGroupsApi(api_client=client) # client configured in previous step
 extId = 'extId_example' # UUID.
 
-# List Consistency groups.
+# List Consistency groups
 try:
-    api_response = consistency_group_api_instance.get_consistency_groups(
+    api_response = consistency_groups_api_instance.list_consistency_groups(
 	                   _page=page, # if page parameter is present
 	                   _limit=limit, # if limit parameter is present
 	                   _filter=_filter, # if filter parameter is present
 	                   _orderby=_orderby, # if orderby parameter is present
 	                   _select=select, # if select parameter is present
 	                   _expand=expand) # if expand parameter is present
 except ApiException as e:
 
 ```
 The list of filterable and sortable fields with expansion keys can be found in the documentation [here](https://developers.nutanix.com/).
 
 ## API Reference
 
-This library has a full set of [API Reference Documentation](https://developers.nutanix.com/sdk-reference?namespace=dataprotection&version=v4.0.a4&language=python). This documentation is auto-generated, and the location may change.
+This library has a full set of [API Reference Documentation](https://developers.nutanix.com/sdk-reference?namespace=dataprotection&version=v4.0.b1&language=python). This documentation is auto-generated, and the location may change.
 
 ## License
 This library is licensed under Nutanix proprietary license. Full license text is available in [LICENSE](https://developers.nutanix.com/license).
 
 ## Contact us
-In case of issues please reach out to us at the [mailing list](mailto:sdk@nutanix.com)
+In case of issues please reach out to us at the [mailing list](mailto:sdk@nutanix.com)
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/__init__.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -5,153 +5,129 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 from __future__ import absolute_import
 
 # import apis into sdk package
-from ntnx_dataprotection_py_client.api.consistency_group_api import ConsistencyGroupApi
+from ntnx_dataprotection_py_client.api.protected_resources_api import ProtectedResourcesApi
+from ntnx_dataprotection_py_client.api.recovery_points_api import RecoveryPointsApi
 # import ApiClient
 from ntnx_dataprotection_py_client.api_client import ApiClient
 from ntnx_dataprotection_py_client.configuration import Configuration
 # import models into sdk package
 from ntnx_dataprotection_py_client.models.OneOfcommon.v1.config.KVPairvalue import KVPairvalue
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.ChangedRegionsListApiResponsedata import ChangedRegionsListApiResponsedata
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.ConsistencyGroupApiResponsedata import ConsistencyGroupApiResponsedata
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.ConsistencyGroupListApiResponsedata import ConsistencyGroupListApiResponsedata
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.ConsistencyGroupMigrateApiResponsedata import ConsistencyGroupMigrateApiResponsedata
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.CreateConsistencyGroupRecoveryPointApiResponsedata import CreateConsistencyGroupRecoveryPointApiResponsedata
+from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.ComputeChangedRegionsResponseModeldata import ComputeChangedRegionsResponseModeldata
+from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.ComputeChangedRegionsResponseresponse import ComputeChangedRegionsResponseresponse
+from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.CreateConsistencyGroupApiResponsedata import CreateConsistencyGroupApiResponsedata
 from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.CreateRecoveryPointApiResponsedata import CreateRecoveryPointApiResponsedata
 from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.DeleteConsistencyGroupApiResponsedata import DeleteConsistencyGroupApiResponsedata
 from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.DeleteRecoveryPointApiResponsedata import DeleteRecoveryPointApiResponsedata
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.DiskRecoveryPointApiResponsedata import DiskRecoveryPointApiResponsedata
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.DiskRecoveryPointListApiResponsedata import DiskRecoveryPointListApiResponsedata
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.ProtectedResourceApiResponsedata import ProtectedResourceApiResponsedata
+from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.GetProtectedResourceApiResponsedata import GetProtectedResourceApiResponsedata
+from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.GetRecoveryPointApiResponsedata import GetRecoveryPointApiResponsedata
+from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.ListRecoveryPointsApiResponsedata import ListRecoveryPointsApiResponsedata
+from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.MigrateConsistencyGroupApiResponsedata import MigrateConsistencyGroupApiResponsedata
 from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.ProtectedResourcePromoteApiResponsedata import ProtectedResourcePromoteApiResponsedata
 from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.ProtectedResourceRestoreApiResponsedata import ProtectedResourceRestoreApiResponsedata
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.RecoveryPointApiResponsedata import RecoveryPointApiResponsedata
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.RecoveryPointListApiResponsedata import RecoveryPointListApiResponsedata
+from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.ProtectedResourceRestoreSpecoverrides import ProtectedResourceRestoreSpecoverrides
 from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.RecoveryPointReplicateApiResponsedata import RecoveryPointReplicateApiResponsedata
+from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.RecoveryPointRepositoryProjectionobject_storage_reference import RecoveryPointRepositoryProjectionobject_storage_reference
+from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.RecoveryPointRepositoryobject_storage_reference import RecoveryPointRepositoryobject_storage_reference
 from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.RecoveryPointRestoreApiResponsedata import RecoveryPointRestoreApiResponsedata
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.SyncedVolumeGroupByIdApiResponsedata import SyncedVolumeGroupByIdApiResponsedata
 from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.SynchronousReplicaPromoteApiResponsedata import SynchronousReplicaPromoteApiResponsedata
+from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.UpdateConsistencyGroupApiResponsedata import UpdateConsistencyGroupApiResponsedata
 from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.UpdateRecoveryPointExpirationTimeApiResponsedata import UpdateRecoveryPointExpirationTimeApiResponsedata
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.VMRecoveryPointApiResponsedata import VMRecoveryPointApiResponsedata
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.VMRecoveryPointListApiResponsedata import VMRecoveryPointListApiResponsedata
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.ValidateRestoreVmRecoveryPointApiResponsedata import ValidateRestoreVmRecoveryPointApiResponsedata
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.VmRecoveryPointRestoreApiResponsedata import VmRecoveryPointRestoreApiResponsedata
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.VolumeGroupRecoveryPointApiResponsedata import VolumeGroupRecoveryPointApiResponsedata
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.VolumeGroupRecoveryPointListApiResponsedata import VolumeGroupRecoveryPointListApiResponsedata
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.VolumeGroupRecoveryPointRestoreApiResponsedata import VolumeGroupRecoveryPointRestoreApiResponsedata
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.WitnessApiResponsedata import WitnessApiResponsedata
 from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.error.ErrorResponseerror import ErrorResponseerror
 from ntnx_dataprotection_py_client.models.common.v1.config.Flag import Flag
 from ntnx_dataprotection_py_client.models.common.v1.config.IPv4Address import IPv4Address
 from ntnx_dataprotection_py_client.models.common.v1.config.KVPair import KVPair
 from ntnx_dataprotection_py_client.models.common.v1.config.Message import Message
 from ntnx_dataprotection_py_client.models.common.v1.config.MessageSeverity import MessageSeverity
 from ntnx_dataprotection_py_client.models.common.v1.config.TenantAwareModel import TenantAwareModel
 from ntnx_dataprotection_py_client.models.common.v1.response.ApiLink import ApiLink
 from ntnx_dataprotection_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata
 from ntnx_dataprotection_py_client.models.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel
 from ntnx_dataprotection_py_client.models.dataprotection.v4.common.BaseRecoveryPoint import BaseRecoveryPoint
 from ntnx_dataprotection_py_client.models.dataprotection.v4.common.RecoveryPointStatus import RecoveryPointStatus
 from ntnx_dataprotection_py_client.models.dataprotection.v4.common.RecoveryPointType import RecoveryPointType
-from ntnx_dataprotection_py_client.models.dataprotection.v4.common.VendorSpecificProperty import VendorSpecificProperty
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.AhvVmOverrideSpec import AhvVmOverrideSpec
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.AmazonS3Bucket import AmazonS3Bucket
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.AzureBlobStorageContainer import AzureBlobStorageContainer
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.Category import Category
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ChangedRegions import ChangedRegions
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ChangedRegionsListApiResponse import ChangedRegionsListApiResponse
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ClusterReference import ClusterReference
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ComputeChangedRegionsResponse import ComputeChangedRegionsResponse
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ComputeChangedRegionsResponseModel import ComputeChangedRegionsResponseModel
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ConsistencyGroup import ConsistencyGroup
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ConsistencyGroupApiResponse import ConsistencyGroupApiResponse
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ConsistencyGroupListApiResponse import ConsistencyGroupListApiResponse
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ConsistencyGroupMember import ConsistencyGroupMember
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ConsistencyGroupMemberType import ConsistencyGroupMemberType
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ConsistencyGroupMigrateApiResponse import ConsistencyGroupMigrateApiResponse
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ConsistencyGroupMigrationSpec import ConsistencyGroupMigrationSpec
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ConsistencyGroupProjection import ConsistencyGroupProjection
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ConsistencyGroupRecoveryPointSpec import ConsistencyGroupRecoveryPointSpec
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.CreateConsistencyGroupRecoveryPointApiResponse import CreateConsistencyGroupRecoveryPointApiResponse
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.CreateConsistencyGroupApiResponse import CreateConsistencyGroupApiResponse
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.CreateRecoveryPointApiResponse import CreateRecoveryPointApiResponse
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.DataProtectionInfo import DataProtectionInfo
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.DataProtectionSiteReference import DataProtectionSiteReference
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.DeleteConsistencyGroupApiResponse import DeleteConsistencyGroupApiResponse
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.DeleteRecoveryPointApiResponse import DeleteRecoveryPointApiResponse
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.DisasterRecoveryLocation import DisasterRecoveryLocation
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.Disk import Disk
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.DiskRecoveryPoint import DiskRecoveryPoint
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.DiskRecoveryPointApiResponse import DiskRecoveryPointApiResponse
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.DiskRecoveryPointListApiResponse import DiskRecoveryPointListApiResponse
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.EsxiVmOverrideSpec import EsxiVmOverrideSpec
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.HardwareArchitecture import HardwareArchitecture
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ExpirationTimeSpec import ExpirationTimeSpec
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.GetProtectedResourceApiResponse import GetProtectedResourceApiResponse
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.GetRecoveryPointApiResponse import GetRecoveryPointApiResponse
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.HostReference import HostReference
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.HostType import HostType
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.HypervisorType import HypervisorType
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.IpAddress import IpAddress
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ListRecoveryPointsApiResponse import ListRecoveryPointsApiResponse
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.LocationReference import LocationReference
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.PowerState import PowerState
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.MigrateConsistencyGroupApiResponse import MigrateConsistencyGroupApiResponse
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.NutanixObjectsBucket import NutanixObjectsBucket
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ObjectStorageType import ObjectStorageType
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ProtectedEntityType import ProtectedEntityType
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ProtectedResource import ProtectedResource
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ProtectedResourceApiResponse import ProtectedResourceApiResponse
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ProtectedResourceEntityType import ProtectedResourceEntityType
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ProtectedResourcePromoteApiResponse import ProtectedResourcePromoteApiResponse
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ProtectedResourceReplicationStatus import ProtectedResourceReplicationStatus
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ProtectedResourceRestoreApiResponse import ProtectedResourceRestoreApiResponse
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ProtectedResourceRestoreSpec import ProtectedResourceRestoreSpec
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.RecoveryInfo import RecoveryInfo
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.RecoveryPoint import RecoveryPoint
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.RecoveryPointApiResponse import RecoveryPointApiResponse
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.RecoveryPointListApiResponse import RecoveryPointListApiResponse
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.RecoveryPointProjection import RecoveryPointProjection
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.RecoveryPointReplicateApiResponse import RecoveryPointReplicateApiResponse
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.RecoveryPointReplicationSpec import RecoveryPointReplicationSpec
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.RecoveryPointRepository import RecoveryPointRepository
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.RecoveryPointRepositoryProjection import RecoveryPointRepositoryProjection
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.RecoveryPointRestorationSpec import RecoveryPointRestorationSpec
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.RecoveryPointRestoreApiResponse import RecoveryPointRestoreApiResponse
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.Regions import Regions
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.RedirectionResponse import RedirectionResponse
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.Region import Region
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.RegionResponse import RegionResponse
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.RegionType import RegionType
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ReplicationState import ReplicationState
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.RestorableTimeRange import RestorableTimeRange
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.SetExpirationTimeSpec import SetExpirationTimeSpec
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.SiteProtectionInfo import SiteProtectionInfo
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.SiteReference import SiteReference
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.Subnet import Subnet
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.SyncedVolumeGroupByIdApiResponse import SyncedVolumeGroupByIdApiResponse
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.SynchronousReplicaPromoteApiResponse import SynchronousReplicaPromoteApiResponse
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.UpdateConsistencyGroupApiResponse import UpdateConsistencyGroupApiResponse
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.UpdateRecoveryPointExpirationTimeApiResponse import UpdateRecoveryPointExpirationTimeApiResponse
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VMRecoveryPoint import VMRecoveryPoint
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VMRecoveryPointApiResponse import VMRecoveryPointApiResponse
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VMRecoveryPointListApiResponse import VMRecoveryPointListApiResponse
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ValidateRecoveryPointResult import ValidateRecoveryPointResult
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ValidateRestoreVmRecoveryPointApiResponse import ValidateRestoreVmRecoveryPointApiResponse
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ValidationSeverity import ValidationSeverity
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.Vm import Vm
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VmRecoveryPointRestorationSpec import VmRecoveryPointRestorationSpec
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VmRecoveryPointRestoreApiResponse import VmRecoveryPointRestoreApiResponse
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VmRecoveryPoint import VmRecoveryPoint
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VmRecoveryPointComputeChangedRegionsRequest import VmRecoveryPointComputeChangedRegionsRequest
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VmRecoveryPointRestoreOverride import VmRecoveryPointRestoreOverride
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VmSubRecoveryPoint import VmSubRecoveryPoint
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VmSubRecoveryPointProjection import VmSubRecoveryPointProjection
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VolumeGroup import VolumeGroup
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VolumeGroupOverrideSpec import VolumeGroupOverrideSpec
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VolumeGroupRecoveryPoint import VolumeGroupRecoveryPoint
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VolumeGroupRecoveryPointApiResponse import VolumeGroupRecoveryPointApiResponse
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VolumeGroupRecoveryPointListApiResponse import VolumeGroupRecoveryPointListApiResponse
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VolumeGroupRecoveryPointRestorationSpec import VolumeGroupRecoveryPointRestorationSpec
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VolumeGroupRecoveryPointRestoreApiResponse import VolumeGroupRecoveryPointRestoreApiResponse
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VolumeGroupRecoveryPointComputeChangedRegionsRequest import VolumeGroupRecoveryPointComputeChangedRegionsRequest
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VolumeGroupRecoveryPointRestoreOverride import VolumeGroupRecoveryPointRestoreOverride
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VolumeGroupSubRecoveryPoint import VolumeGroupSubRecoveryPoint
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VolumeGroupSubRecoveryPointProjection import VolumeGroupSubRecoveryPointProjection
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VolumeGroupSyncContext import VolumeGroupSyncContext
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VpcReference import VpcReference
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.Witness import Witness
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.WitnessApiResponse import WitnessApiResponse
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.WitnessAvailabilityStatus import WitnessAvailabilityStatus
 from ntnx_dataprotection_py_client.models.dataprotection.v4.error.AppMessage import AppMessage
 from ntnx_dataprotection_py_client.models.dataprotection.v4.error.ErrorResponse import ErrorResponse
 from ntnx_dataprotection_py_client.models.dataprotection.v4.error.SchemaValidationError import SchemaValidationError
 from ntnx_dataprotection_py_client.models.dataprotection.v4.error.SchemaValidationErrorMessage import SchemaValidationErrorMessage
 from ntnx_dataprotection_py_client.models.prism.v4.config.TaskReference import TaskReference
-from ntnx_dataprotection_py_client.models.storage.v4.config.Task import Task
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/api_client.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/api_client.py`

 * *Files 11% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 from __future__ import absolute_import
 
 import datetime
@@ -25,14 +25,22 @@
 import uuid
 import logging
 
 # python 2 and python 3 compatibility library
 import six
 from six.moves.urllib.parse import quote
 
+from pathlib import Path
+
+
+try:
+    import urllib3
+except ImportError:
+    raise ImportError('Api client requires urllib3.')
+
 from ntnx_dataprotection_py_client.configuration import Configuration
 import ntnx_dataprotection_py_client.models
 from ntnx_dataprotection_py_client import rest
 
 PY2 = sys.version_info[0] < 3
 
 logger = logging.getLogger(__name__)
@@ -41,160 +49,135 @@
 
     """API client to handle the client-server communication, and is invariant across implementations.
 
     :param configuration: Configuration object for this client
     :type configuration: :class:`~ntnx_vmm_py_client.configuration.Configuration`, required
     """  # noqa: E501
 
-    SDK_VERSION = "v4.0.a4"
+    SDK_VERSION = "v4.0.b1"
     PRIMITIVE_TYPES = (float, bool, bytes, six.text_type) + six.integer_types
     NATIVE_TYPES_MAPPING = {
         'int': int,
         'long': int if six.PY3 else long,  # noqa: F821
         'float': float,
         'str': str,
         'bool': bool,
         'date': datetime.date,
         'datetime': datetime.datetime,
         'object': object,
     }
     DUPLICATE_SCHEMA_MAPPING = {
     # Populated if multiple schemas exist with the same name
         'OneOfdataprotection.v4.config.ProtectedResourcePromoteApiResponsedata' : 'ProtectedResourcePromoteApiResponsedata',
+        'dataprotection.v4.config.ListRecoveryPointsApiResponse' : 'ListRecoveryPointsApiResponse',
         'dataprotection.v4.config.RestorableTimeRange' : 'RestorableTimeRange',
         'dataprotection.v4.config.DisasterRecoveryLocation' : 'DisasterRecoveryLocation',
         'common.v1.config.IPv4Address' : 'IPv4Address',
         'dataprotection.v4.config.RecoveryPointRestorationSpec' : 'RecoveryPointRestorationSpec',
+        'dataprotection.v4.config.RecoveryPointProjection' : 'RecoveryPointProjection',
         'dataprotection.v4.common.RecoveryPointType' : 'RecoveryPointType',
-        'dataprotection.v4.config.Regions' : 'Regions',
         'OneOfdataprotection.v4.config.DeleteRecoveryPointApiResponsedata' : 'DeleteRecoveryPointApiResponsedata',
         'common.v1.config.Flag' : 'Flag',
         'dataprotection.v4.config.ReplicationState' : 'ReplicationState',
-        'dataprotection.v4.config.ProtectedResourceEntityType' : 'ProtectedResourceEntityType',
+        'dataprotection.v4.config.Region' : 'Region',
         'dataprotection.v4.error.SchemaValidationError' : 'SchemaValidationError',
-        'dataprotection.v4.config.SyncedVolumeGroupByIdApiResponse' : 'SyncedVolumeGroupByIdApiResponse',
-        'dataprotection.v4.config.VMRecoveryPointListApiResponse' : 'VMRecoveryPointListApiResponse',
-        'OneOfdataprotection.v4.config.ConsistencyGroupListApiResponsedata' : 'ConsistencyGroupListApiResponsedata',
+        'dataprotection.v4.config.UpdateConsistencyGroupApiResponse' : 'UpdateConsistencyGroupApiResponse',
         'OneOfdataprotection.v4.config.CreateRecoveryPointApiResponsedata' : 'CreateRecoveryPointApiResponsedata',
         'dataprotection.v4.config.VolumeGroupRecoveryPointRestoreOverride' : 'VolumeGroupRecoveryPointRestoreOverride',
-        'OneOfdataprotection.v4.config.ValidateRestoreVmRecoveryPointApiResponsedata' : 'ValidateRestoreVmRecoveryPointApiResponsedata',
-        'storage.v4.config.Task' : 'Task',
-        'OneOfdataprotection.v4.config.CreateConsistencyGroupRecoveryPointApiResponsedata' : 'CreateConsistencyGroupRecoveryPointApiResponsedata',
+        'OneOfdataprotection.v4.config.CreateConsistencyGroupApiResponsedata' : 'CreateConsistencyGroupApiResponsedata',
+        'OneOfdataprotection.v4.config.ComputeChangedRegionsResponseModeldata' : 'ComputeChangedRegionsResponseModeldata',
+        'OneOfdataprotection.v4.config.ListRecoveryPointsApiResponsedata' : 'ListRecoveryPointsApiResponsedata',
         'dataprotection.v4.config.Subnet' : 'Subnet',
         'prism.v4.config.TaskReference' : 'TaskReference',
         'dataprotection.v4.common.RecoveryPointStatus' : 'RecoveryPointStatus',
+        'OneOfdataprotection.v4.config.GetProtectedResourceApiResponsedata' : 'GetProtectedResourceApiResponsedata',
         'OneOfdataprotection.v4.config.RecoveryPointRestoreApiResponsedata' : 'RecoveryPointRestoreApiResponsedata',
-        'dataprotection.v4.config.VolumeGroupSubRecoveryPointProjection' : 'VolumeGroupSubRecoveryPointProjection',
         'OneOfdataprotection.v4.config.RecoveryPointReplicateApiResponsedata' : 'RecoveryPointReplicateApiResponsedata',
         'dataprotection.v4.config.LocationReference' : 'LocationReference',
         'dataprotection.v4.config.ConsistencyGroupProjection' : 'ConsistencyGroupProjection',
+        'dataprotection.v4.config.SiteProtectionInfo' : 'SiteProtectionInfo',
         'dataprotection.v4.config.ClusterReference' : 'ClusterReference',
-        'dataprotection.v4.config.VolumeGroupSubRecoveryPoint' : 'VolumeGroupSubRecoveryPoint',
         'dataprotection.v4.config.RecoveryPointReplicationSpec' : 'RecoveryPointReplicationSpec',
         'dataprotection.v4.error.SchemaValidationErrorMessage' : 'SchemaValidationErrorMessage',
-        'OneOfdataprotection.v4.config.VolumeGroupRecoveryPointRestoreApiResponsedata' : 'VolumeGroupRecoveryPointRestoreApiResponsedata',
-        'dataprotection.v4.config.ConsistencyGroupApiResponse' : 'ConsistencyGroupApiResponse',
-        'dataprotection.v4.config.ValidationSeverity' : 'ValidationSeverity',
-        'dataprotection.v4.config.ConsistencyGroupMigrateApiResponse' : 'ConsistencyGroupMigrateApiResponse',
         'dataprotection.v4.config.RecoveryPointReplicateApiResponse' : 'RecoveryPointReplicateApiResponse',
-        'OneOfdataprotection.v4.config.VMRecoveryPointApiResponsedata' : 'VMRecoveryPointApiResponsedata',
+        'dataprotection.v4.config.MigrateConsistencyGroupApiResponse' : 'MigrateConsistencyGroupApiResponse',
         'dataprotection.v4.config.VolumeGroupSyncContext' : 'VolumeGroupSyncContext',
         'dataprotection.v4.config.VpcReference' : 'VpcReference',
-        'dataprotection.v4.config.WitnessApiResponse' : 'WitnessApiResponse',
         'dataprotection.v4.config.ConsistencyGroupMember' : 'ConsistencyGroupMember',
-        'dataprotection.v4.config.ConsistencyGroupRecoveryPointSpec' : 'ConsistencyGroupRecoveryPointSpec',
-        'dataprotection.v4.config.VmRecoveryPointRestorationSpec' : 'VmRecoveryPointRestorationSpec',
+        'dataprotection.v4.config.VolumeGroupRecoveryPointComputeChangedRegionsRequest' : 'VolumeGroupRecoveryPointComputeChangedRegionsRequest',
         'dataprotection.v4.config.DeleteConsistencyGroupApiResponse' : 'DeleteConsistencyGroupApiResponse',
         'dataprotection.v4.config.ConsistencyGroupMigrationSpec' : 'ConsistencyGroupMigrationSpec',
-        'OneOfdataprotection.v4.config.ChangedRegionsListApiResponsedata' : 'ChangedRegionsListApiResponsedata',
         'dataprotection.v4.config.SynchronousReplicaPromoteApiResponse' : 'SynchronousReplicaPromoteApiResponse',
         'dataprotection.v4.config.RecoveryPoint' : 'RecoveryPoint',
-        'dataprotection.v4.common.VendorSpecificProperty' : 'VendorSpecificProperty',
-        'dataprotection.v4.config.RecoveryPointApiResponse' : 'RecoveryPointApiResponse',
-        'OneOfdataprotection.v4.config.VolumeGroupRecoveryPointApiResponsedata' : 'VolumeGroupRecoveryPointApiResponsedata',
+        'dataprotection.v4.config.RegionResponse' : 'RegionResponse',
+        'OneOfdataprotection.v4.config.ProtectedResourceRestoreSpecoverrides' : 'ProtectedResourceRestoreSpecoverrides',
         'dataprotection.v4.config.WitnessAvailabilityStatus' : 'WitnessAvailabilityStatus',
-        'dataprotection.v4.config.HypervisorType' : 'HypervisorType',
-        'OneOfdataprotection.v4.config.SyncedVolumeGroupByIdApiResponsedata' : 'SyncedVolumeGroupByIdApiResponsedata',
+        'dataprotection.v4.config.RegionType' : 'RegionType',
         'dataprotection.v4.config.AhvVmOverrideSpec' : 'AhvVmOverrideSpec',
         'dataprotection.v4.config.VolumeGroupRecoveryPoint' : 'VolumeGroupRecoveryPoint',
+        'OneOfdataprotection.v4.config.RecoveryPointRepositoryProjectionobject_storage_reference' : 'RecoveryPointRepositoryProjectionobject_storage_reference',
         'OneOfdataprotection.v4.config.UpdateRecoveryPointExpirationTimeApiResponsedata' : 'UpdateRecoveryPointExpirationTimeApiResponsedata',
-        'dataprotection.v4.config.VMRecoveryPoint' : 'VMRecoveryPoint',
         'common.v1.response.ApiResponseMetadata' : 'ApiResponseMetadata',
         'dataprotection.v4.common.BaseRecoveryPoint' : 'BaseRecoveryPoint',
-        'OneOfdataprotection.v4.config.DiskRecoveryPointApiResponsedata' : 'DiskRecoveryPointApiResponsedata',
         'dataprotection.v4.config.ProtectedResource' : 'ProtectedResource',
-        'OneOfdataprotection.v4.config.ConsistencyGroupMigrateApiResponsedata' : 'ConsistencyGroupMigrateApiResponsedata',
+        'dataprotection.v4.config.AmazonS3Bucket' : 'AmazonS3Bucket',
         'OneOfdataprotection.v4.config.ProtectedResourceRestoreApiResponsedata' : 'ProtectedResourceRestoreApiResponsedata',
         'dataprotection.v4.config.CreateRecoveryPointApiResponse' : 'CreateRecoveryPointApiResponse',
-        'dataprotection.v4.config.CreateConsistencyGroupRecoveryPointApiResponse' : 'CreateConsistencyGroupRecoveryPointApiResponse',
-        'dataprotection.v4.config.ValidateRestoreVmRecoveryPointApiResponse' : 'ValidateRestoreVmRecoveryPointApiResponse',
+        'OneOfdataprotection.v4.config.RecoveryPointRepositoryobject_storage_reference' : 'RecoveryPointRepositoryobject_storage_reference',
+        'OneOfdataprotection.v4.config.GetRecoveryPointApiResponsedata' : 'GetRecoveryPointApiResponsedata',
+        'dataprotection.v4.config.VmRecoveryPointComputeChangedRegionsRequest' : 'VmRecoveryPointComputeChangedRegionsRequest',
         'common.v1.response.ExternalizableAbstractModel' : 'ExternalizableAbstractModel',
-        'dataprotection.v4.config.ChangedRegions' : 'ChangedRegions',
-        'dataprotection.v4.config.VolumeGroupRecoveryPointListApiResponse' : 'VolumeGroupRecoveryPointListApiResponse',
         'dataprotection.v4.config.EsxiVmOverrideSpec' : 'EsxiVmOverrideSpec',
         'common.v1.config.Message' : 'Message',
         'dataprotection.v4.config.Category' : 'Category',
         'dataprotection.v4.config.HostReference' : 'HostReference',
         'dataprotection.v4.config.RecoveryInfo' : 'RecoveryInfo',
-        'OneOfdataprotection.v4.config.VMRecoveryPointListApiResponsedata' : 'VMRecoveryPointListApiResponsedata',
-        'dataprotection.v4.config.DiskRecoveryPointListApiResponse' : 'DiskRecoveryPointListApiResponse',
-        'dataprotection.v4.config.VolumeGroupRecoveryPointRestorationSpec' : 'VolumeGroupRecoveryPointRestorationSpec',
+        'dataprotection.v4.config.RecoveryPointRepositoryProjection' : 'RecoveryPointRepositoryProjection',
         'dataprotection.v4.config.DiskRecoveryPoint' : 'DiskRecoveryPoint',
         'OneOfcommon.v1.config.KVPairvalue' : 'KVPairvalue',
         'dataprotection.v4.config.ProtectedResourcePromoteApiResponse' : 'ProtectedResourcePromoteApiResponse',
+        'OneOfdataprotection.v4.config.MigrateConsistencyGroupApiResponsedata' : 'MigrateConsistencyGroupApiResponsedata',
+        'dataprotection.v4.config.ExpirationTimeSpec' : 'ExpirationTimeSpec',
         'dataprotection.v4.config.HostType' : 'HostType',
         'dataprotection.v4.config.IpAddress' : 'IpAddress',
-        'dataprotection.v4.config.ValidateRecoveryPointResult' : 'ValidateRecoveryPointResult',
         'dataprotection.v4.error.AppMessage' : 'AppMessage',
         'dataprotection.v4.error.ErrorResponse' : 'ErrorResponse',
-        'OneOfdataprotection.v4.config.WitnessApiResponsedata' : 'WitnessApiResponsedata',
         'dataprotection.v4.config.ProtectedResourceReplicationStatus' : 'ProtectedResourceReplicationStatus',
         'dataprotection.v4.config.UpdateRecoveryPointExpirationTimeApiResponse' : 'UpdateRecoveryPointExpirationTimeApiResponse',
-        'dataprotection.v4.config.VmSubRecoveryPointProjection' : 'VmSubRecoveryPointProjection',
+        'dataprotection.v4.config.ObjectStorageType' : 'ObjectStorageType',
         'common.v1.config.MessageSeverity' : 'MessageSeverity',
-        'dataprotection.v4.config.SetExpirationTimeSpec' : 'SetExpirationTimeSpec',
-        'dataprotection.v4.config.ProtectedResourceApiResponse' : 'ProtectedResourceApiResponse',
+        'dataprotection.v4.config.AzureBlobStorageContainer' : 'AzureBlobStorageContainer',
         'OneOfdataprotection.v4.config.DeleteConsistencyGroupApiResponsedata' : 'DeleteConsistencyGroupApiResponsedata',
         'dataprotection.v4.config.SiteReference' : 'SiteReference',
         'common.v1.response.ApiLink' : 'ApiLink',
-        'dataprotection.v4.config.DiskRecoveryPointApiResponse' : 'DiskRecoveryPointApiResponse',
+        'dataprotection.v4.config.NutanixObjectsBucket' : 'NutanixObjectsBucket',
         'dataprotection.v4.config.DeleteRecoveryPointApiResponse' : 'DeleteRecoveryPointApiResponse',
-        'dataprotection.v4.config.VMRecoveryPointApiResponse' : 'VMRecoveryPointApiResponse',
-        'dataprotection.v4.config.HardwareArchitecture' : 'HardwareArchitecture',
-        'OneOfdataprotection.v4.config.RecoveryPointApiResponsedata' : 'RecoveryPointApiResponsedata',
+        'dataprotection.v4.config.RedirectionResponse' : 'RedirectionResponse',
         'dataprotection.v4.config.ConsistencyGroup' : 'ConsistencyGroup',
         'dataprotection.v4.config.Witness' : 'Witness',
-        'dataprotection.v4.config.VolumeGroupRecoveryPointApiResponse' : 'VolumeGroupRecoveryPointApiResponse',
-        'dataprotection.v4.config.ConsistencyGroupListApiResponse' : 'ConsistencyGroupListApiResponse',
-        'OneOfdataprotection.v4.config.DiskRecoveryPointListApiResponsedata' : 'DiskRecoveryPointListApiResponsedata',
+        'dataprotection.v4.config.CreateConsistencyGroupApiResponse' : 'CreateConsistencyGroupApiResponse',
+        'dataprotection.v4.config.ComputeChangedRegionsResponse' : 'ComputeChangedRegionsResponse',
         'dataprotection.v4.config.DataProtectionSiteReference' : 'DataProtectionSiteReference',
-        'OneOfdataprotection.v4.config.VmRecoveryPointRestoreApiResponsedata' : 'VmRecoveryPointRestoreApiResponsedata',
+        'dataprotection.v4.config.VmRecoveryPoint' : 'VmRecoveryPoint',
         'dataprotection.v4.config.VolumeGroupOverrideSpec' : 'VolumeGroupOverrideSpec',
-        'dataprotection.v4.config.VmRecoveryPointRestoreApiResponse' : 'VmRecoveryPointRestoreApiResponse',
-        'dataprotection.v4.config.VolumeGroupRecoveryPointRestoreApiResponse' : 'VolumeGroupRecoveryPointRestoreApiResponse',
-        'dataprotection.v4.config.VolumeGroup' : 'VolumeGroup',
+        'OneOfdataprotection.v4.config.UpdateConsistencyGroupApiResponsedata' : 'UpdateConsistencyGroupApiResponsedata',
         'dataprotection.v4.config.ProtectedResourceRestoreSpec' : 'ProtectedResourceRestoreSpec',
-        'dataprotection.v4.config.RecoveryPointListApiResponse' : 'RecoveryPointListApiResponse',
         'dataprotection.v4.config.ProtectedResourceRestoreApiResponse' : 'ProtectedResourceRestoreApiResponse',
         'dataprotection.v4.config.VmRecoveryPointRestoreOverride' : 'VmRecoveryPointRestoreOverride',
-        'dataprotection.v4.config.ChangedRegionsListApiResponse' : 'ChangedRegionsListApiResponse',
         'dataprotection.v4.config.ConsistencyGroupMemberType' : 'ConsistencyGroupMemberType',
         'OneOfdataprotection.v4.error.ErrorResponseerror' : 'ErrorResponseerror',
-        'dataprotection.v4.config.DataProtectionInfo' : 'DataProtectionInfo',
-        'dataprotection.v4.config.PowerState' : 'PowerState',
-        'OneOfdataprotection.v4.config.ConsistencyGroupApiResponsedata' : 'ConsistencyGroupApiResponsedata',
+        'OneOfdataprotection.v4.config.ComputeChangedRegionsResponseresponse' : 'ComputeChangedRegionsResponseresponse',
         'common.v1.config.TenantAwareModel' : 'TenantAwareModel',
-        'dataprotection.v4.config.VmSubRecoveryPoint' : 'VmSubRecoveryPoint',
-        'dataprotection.v4.config.Disk' : 'Disk',
+        'dataprotection.v4.config.GetRecoveryPointApiResponse' : 'GetRecoveryPointApiResponse',
+        'dataprotection.v4.config.ComputeChangedRegionsResponseModel' : 'ComputeChangedRegionsResponseModel',
+        'dataprotection.v4.config.GetProtectedResourceApiResponse' : 'GetProtectedResourceApiResponse',
         'dataprotection.v4.config.RecoveryPointRestoreApiResponse' : 'RecoveryPointRestoreApiResponse',
         'OneOfdataprotection.v4.config.SynchronousReplicaPromoteApiResponsedata' : 'SynchronousReplicaPromoteApiResponsedata',
-        'OneOfdataprotection.v4.config.VolumeGroupRecoveryPointListApiResponsedata' : 'VolumeGroupRecoveryPointListApiResponsedata',
-        'OneOfdataprotection.v4.config.ProtectedResourceApiResponsedata' : 'ProtectedResourceApiResponsedata',
-        'dataprotection.v4.config.Vm' : 'Vm',
-        'OneOfdataprotection.v4.config.RecoveryPointListApiResponsedata' : 'RecoveryPointListApiResponsedata',
+        'dataprotection.v4.config.ProtectedEntityType' : 'ProtectedEntityType',
+        'dataprotection.v4.config.RecoveryPointRepository' : 'RecoveryPointRepository',
         'common.v1.config.KVPair' : 'KVPair'
     }
 
     def __init__(self, configuration=None):
         if configuration is None:
             configuration = Configuration()
         self.configuration = configuration
@@ -349,15 +332,15 @@
         # post parameters
         if post_params or files:
             post_params = self.__prepare_post_parameters(post_params, files)
             post_params = self.__sanitize_for_serialization(post_params)
             post_params = self.__parameters_to_tuples(post_params, collection_formats)
 
         # body
-        if body:
+        if body and 'application/octet-stream' not in header_params['Content-Type']:
             body = self.__sanitize_for_serialization(body)
 
         # request url
         url = config.scheme + '://' + config.host + ':' + str(config.port) + resource_path
 
         # perform request and return response
         response_data = self.request(
@@ -386,28 +369,57 @@
                 raise ntnx_dataprotection_py_client.rest.ApiException(http_resp=response_data)
 
         if self.__refresh_cookie:
             self.__update_cookies(response_data)
 
         self.last_response = response_data
         return_data = response_data
-        if _preload_content:
-            # deserialize response data
+
+        # deserialize response data
+        try:
             if response_data.status != 204:
-                return_data = json.loads(response_data.data)
-                return_data = self.__add_header_to_reserved(response_data, return_data, "ETag")
-                if response_type is None and "$objectType" in return_data:
-                    response_type = return_data.get("$objectType")
-                if PY2:
-                    inner_response_type = response_type.encode('utf-8', 'ignore')
+                # Download a file
+                if response_data.getheader(name='Content-Type') == 'application/octet-stream':
+                    download_path = self.__deserialize_file(response_data)
+                    download_path = Path(download_path)
+
+                    # convert response type to class
+                    response_type = self.__getattr(response_type)
+                    data = {"path": download_path}
+                    data["$objectType"] = "pathlib.Path"
+                    data["$reserved"] = {}
+                    data["$unknownFields"] = {}
+                    return response_type(data=data)
                 else:
-                    inner_response_type = response_type
-                return self.deserialize(return_data, inner_response_type)
+                    if _preload_content:
+                        # Read the data from original urllib3 response
+                        response_data.data = response_data.urllib3_response.data
+                        # In the python 3, the response.data is bytes which needs to be decoded to string.
+                        if six.PY3:
+                            response_data.data = response_data.data.decode('utf-8')
+
+                        return_data = json.loads(response_data.data)
+                        return_data = self.__add_header_to_reserved(response_data, return_data, "ETag")
+                        if response_type is None and "$objectType" in return_data:
+                            response_type = return_data.get("$objectType")
+                        if PY2:
+                            inner_response_type = response_type.encode('utf-8', 'ignore')
+                        else:
+                            inner_response_type = response_type
+
+                        return self.deserialize(return_data, inner_response_type)
+                    else:
+                        return_data = response_data
             else:
-                return_data = None
+                if _preload_content:
+                    return_data = None
+        finally:
+            if 'Content-Type' in header_params and header_params['Content-Type'] == 'application/octet-stream':
+                response_data.urllib3_response.drain_conn()
+                response_data.urllib3_response.release_conn()
         if _return_http_data_only:
             return (return_data)
         else:
             return (return_data, response_data.status,
                     response_data.getheaders())
     def __sanitize_for_serialization(self, obj):
         """Builds a JSON POST object.
@@ -482,14 +494,17 @@
         :type discriminator: :class:`str`
         :return: Deserialized object
         :rtype: :class:`object`
         """  # noqa: E501
         if data is None:
             return None
         if type(klass) == str:
+            if klass == 'pathlib.Path':
+                data['path'] = Path(data['path'])
+                return data
             if klass.startswith('list['):
                 sub_kls = re.match(r'list\[(.*)\]', klass).group(1)
                 return [self.deserialize(sub_data, sub_kls)
                         for sub_data in data]
             if klass.startswith('dict('):
                 sub_kls = re.match(r'dict\(([^,]*), (.*)\)', klass).group(2)
                 return {str(k): self.deserialize(v, sub_kls)
@@ -701,19 +716,17 @@
         :type accepts: :class:`list`
         :return: If application/json is available, returns that.
             Otherwise, returns a comma separated string of all the provided Accept types
         """  # noqa: E501
 
         if not accepts:
             return
+
         accepts = [x.lower() for x in accepts]
-        if 'application/json' in accepts:
-            return 'application/json'
-        else:
-            return ', '.join(accepts)
+        return ', '.join(accepts)
 
     def _select_header_content_type(self, content_types):
         """Returns `Content-Type` based on an array of content_types provided.
 
         :param content_types: List of content-types
         :type content_types: :class:`list`
         :return: Content-Type (e.g. application/json)
@@ -798,24 +811,32 @@
 
         Saves response body into a file in a temporary folder, using the filename from the `Content-Disposition` header if provided.
 
         :param response: :class:`~ntnx_dataprotection_py_client.rest.RESTResponse`
         :return: File path
         """
 
-        fd, path = tempfile.mkstemp(dir=self.configuration.temp_folder_path)
-        os.close(fd)
-        os.remove(path)
+        path = ''
         content_disposition = response.getheader("Content-Disposition")
         if content_disposition:
-            filename = re.search(r'filename=[\'"]?([^\'"\s]+)[\'"]?',
-                                 content_disposition).group(1)
-            path = os.path.join(os.path.dirname(path), filename)
+            filename = re.search(r'filename=[\'"]?([^\'"*]+)[\'"]?', content_disposition).group(1)
+            path = os.path.join(self.configuration.download_directory, filename)
+        else:
+            fd, path = tempfile.mkstemp(dir=self.configuration.download_directory)
+            os.close(fd)
+
+        path_tup = os.path.splitext(path)
+        timestring = datetime.datetime.now().strftime("%Y-%m-%dT%H:%M:%S.%f")[:-3]
+        path = "%s_%s%s" % (path_tup[0], timestring, path_tup[1])
+        logger.info('Writing response data to file at %s' % path)
         with open(path, "wb") as f:
-            f.write(response.data)
+            if isinstance(response.urllib3_response, urllib3.response.HTTPResponse):
+                for chunk in response.urllib3_response.stream(self.configuration.download_chunk_size):
+                    f.write(chunk)
+
         return path
 
     def __deserialize_primitive(self, data, klass):
         """Deserializes string to primitive type.
 
         :param data:
         :type data: :class:`str`
@@ -920,15 +941,16 @@
                                 if type(value_item) is not dict:
                                     one_of_value.append(self.deserialize(value_item, type(value_item)))
                                 else:
                                     one_of_value.append(self.deserialize(value_item, self.__getattr(value_item['$objectType'])))
                         elif type(value) is dict:
                             # OneOf of dict type can be a single response object or a map of primitive types
                             if '$objectType' in value:
-                                one_of_value = self.deserialize(value, self.__getattr(value['$objectType']))
+                                one_of_value = self.deserialize(value, value['$objectType']
+                                    if value['$objectType'] == 'pathlib.Path' else self.__getattr(value['$objectType']))
                             else:
                                 one_of_value = {}
                                 for item_key, item_value in six.iteritems(value):
                                     one_of_value[item_key] = self.deserialize(item_value, type(item_value))
                         else:
                             one_of_value = value
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/api_response.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/api_response.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import re  # noqa: F401
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/configuration.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/configuration.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,21 +3,22 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 from __future__ import absolute_import
 
+import os
 import copy
 import logging
 from logging.handlers import TimedRotatingFileHandler
 import multiprocessing
 import sys
 import urllib3
 
@@ -68,14 +69,18 @@
     :type backoff_factor: :class:`float`
     :param logger_file: (:attr:`logger_file`) File location to which logs are written to
     :type logger_file: :class:`str`
     :param connect_timeout: (:attr:`connect_timeout`) Connection timeout in milliseconds for all operations (**Default** 30000)
     :type connect_timeout: :class:`int`
     :param read_timeout: (:attr:`read_timeout`) Read timeout in milliseconds for all operations (**Default** 30000)
     :type read_timeout: :class:`int`
+    :param download_directory: (:attr:`download_directory`) Directory location on local for files to download
+    :type download_directory: :class:`str`
+    :param download_chunk_size: (:attr:`download_chunk_size`) Chunk size in bytes for files to download (**Default** 8*1024 bytes)
+    :type download_chunk_size: :class:`int`
     """  # noqa: E501
 
     def __init__(self):
 
         """Constructor"""
         self.__scheme = "https"
 
@@ -87,18 +92,20 @@
 
         # Maximum number of allowed retries for a HTTP call
         self.__max_retry_attempts = 5
 
         # Backoff factor by which the retry request is delayed with specific number of seconds.
         self.__backoff_factor = 3
 
-        self.__user_agent = 'Nutanix-ntnx_dataprotection_py_client/4.0.1a4'
+        self.__user_agent = 'Nutanix-ntnx_dataprotection_py_client/4.0.1b1'
 
-        # Temp file folder for downloading files
-        self.temp_folder_path = None
+        # Directory path for downloading files
+        self.__download_directory = os.path.abspath(os.getcwd())
+        # Chunk size for downloading files
+        self.__download_chunk_size = 8*1024
 
         # Authentication Settings
         # HTTP Basic Auth
         self.__username = None
         self.__password = None
 
         # API Key authentication (NOTE: SDK currently supports basic auth only)
@@ -191,14 +198,38 @@
         return self.__port
 
     @port.setter
     def port(self, value):
         self.__port = value
 
     @property
+    def download_directory(self):
+        """Directory path for downloading files (**Default** current directory).
+
+        :type: :class:`str`
+        """
+        return self.__download_directory
+
+    @download_directory.setter
+    def download_directory(self, value):
+        self.__download_directory = value
+
+    @property
+    def download_chunk_size(self):
+        """Chunk size for downloading files (**Default** 8*1024 bytes).
+
+        :type: :class:`int`
+        """
+        return self.__download_chunk_size
+
+    @download_chunk_size.setter
+    def download_chunk_size(self, value):
+        self.__download_chunk_size = value
+
+    @property
     def max_retry_attempts(self):
         """Maximum allowed retry attempts for a HTTP call in case of response status codes [408, 503, 504] (**Default** 5).
 
         :type: :class:`int`
         """
         return self.__max_retry_attempts
 
@@ -376,23 +407,19 @@
     @debug.setter
     def debug(self, value):
         self.__debug = value
         if self.__debug:
             # if debug status is True, turn on debug logging
             for _, logger in six.iteritems(self.logger):
                 logger.setLevel(logging.DEBUG)
-            # turn on httplib debug
-            httplib.HTTPConnection.debuglevel = 1
         else:
             # if debug status is False, turn off debug logging,
             # setting log level to default `logging.INFO`
             for _, logger in six.iteritems(self.logger):
                 logger.setLevel(logging.INFO)
-            # turn off httplib debug
-            httplib.HTTPConnection.debuglevel = 0
 
     @property
     def logger_format(self):
         """The log format for file or stream log handler.
 
         :type: :class:`str`
         """
@@ -487,10 +514,10 @@
 
     def to_debug_report(self):
         """Prints the information about current OS, Python, API and SDK versions for debugging purposes
         """
         return "Python SDK Debug Report:\n"\
                "OS: {env}\n"\
                "Python Version: {pyversion}\n"\
-               "Version of the API: 4.0.1-alpha-4\n"\
-               "SDK Package Version: 4.0.1a4".\
+               "Version of the API: 4.0.1-beta-1\n"\
+               "SDK Package Version: 4.0.1b1".\
                format(env=sys.platform, pyversion=sys.version)
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfcommon/v1/config/KVPairvalue.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/SynchronousReplicaPromoteApiResponsedata.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class KVPairvalue(object):
+class SynchronousReplicaPromoteApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,51 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'String': 'str',
-        'Integer': 'int',
-        'Boolean': 'bool',
-        'List<String>': 'list[str]',
-        'Map<String, String>': 'dict(str, str)'
+        'prism.v4.config.TaskReference': 'prism.v4.config.TaskReference',
+        'dataprotection.v4.error.ErrorResponse': 'dataprotection.v4.error.ErrorResponse'
     }
 
-    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$valueItemDiscriminator'
+    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfcommon.v1.config.KVPairvalue'
+        return 'OneOfdataprotection.v4.config.SynchronousReplicaPromoteApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -117,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in KVPairvalue.discriminator_value_class_map.values():
-            return list(KVPairvalue.discriminator_value_class_map.keys())[list(KVPairvalue.discriminator_value_class_map.values()).index(disc)]
+        if disc in SynchronousReplicaPromoteApiResponsedata.discriminator_value_class_map.values():
+            return list(SynchronousReplicaPromoteApiResponsedata.discriminator_value_class_map.keys())[list(SynchronousReplicaPromoteApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(KVPairvalue, dict):
+        if issubclass(SynchronousReplicaPromoteApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -172,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, KVPairvalue):
+        if not isinstance(other, SynchronousReplicaPromoteApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/ChangedRegionsListApiResponsedata.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/ComputeChangedRegionsResponseresponse.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class ChangedRegionsListApiResponsedata(object):
+class ComputeChangedRegionsResponseresponse(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'dataprotection.v4.config.ChangedRegions': 'dataprotection.v4.config.ChangedRegions',
-        'dataprotection.v4.error.ErrorResponse': 'dataprotection.v4.error.ErrorResponse'
+        'dataprotection.v4.config.RegionResponse': 'dataprotection.v4.config.RegionResponse',
+        'dataprotection.v4.config.RedirectionResponse': 'dataprotection.v4.config.RedirectionResponse'
     }
 
-    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
+    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$responseItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfdataprotection.v4.config.ChangedRegionsListApiResponsedata'
+        return 'OneOfdataprotection.v4.config.ComputeChangedRegionsResponseresponse'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in ChangedRegionsListApiResponsedata.discriminator_value_class_map.values():
-            return list(ChangedRegionsListApiResponsedata.discriminator_value_class_map.keys())[list(ChangedRegionsListApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in ComputeChangedRegionsResponseresponse.discriminator_value_class_map.values():
+            return list(ComputeChangedRegionsResponseresponse.discriminator_value_class_map.keys())[list(ComputeChangedRegionsResponseresponse.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ChangedRegionsListApiResponsedata, dict):
+        if issubclass(ComputeChangedRegionsResponseresponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ChangedRegionsListApiResponsedata):
+        if not isinstance(other, ComputeChangedRegionsResponseresponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/ConsistencyGroupApiResponsedata.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfcommon/v1/config/KVPairvalue.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class ConsistencyGroupApiResponsedata(object):
+class KVPairvalue(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,51 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'dataprotection.v4.config.ConsistencyGroup': 'dataprotection.v4.config.ConsistencyGroup',
-        'dataprotection.v4.error.ErrorResponse': 'dataprotection.v4.error.ErrorResponse'
+        'String': 'str',
+        'Integer': 'int',
+        'Boolean': 'bool',
+        'List<String>': 'list[str]',
+        'Map<String, String>': 'dict(str, str)'
     }
 
-    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
+    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$valueItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfdataprotection.v4.config.ConsistencyGroupApiResponsedata'
+        return 'OneOfcommon.v1.config.KVPairvalue'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +118,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in ConsistencyGroupApiResponsedata.discriminator_value_class_map.values():
-            return list(ConsistencyGroupApiResponsedata.discriminator_value_class_map.keys())[list(ConsistencyGroupApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in KVPairvalue.discriminator_value_class_map.values():
+            return list(KVPairvalue.discriminator_value_class_map.keys())[list(KVPairvalue.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ConsistencyGroupApiResponsedata, dict):
+        if issubclass(KVPairvalue, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +178,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ConsistencyGroupApiResponsedata):
+        if not isinstance(other, KVPairvalue):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/ConsistencyGroupListApiResponsedata.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/RecoveryPointRepositoryobject_storage_reference.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class ConsistencyGroupListApiResponsedata(object):
+class RecoveryPointRepositoryobject_storage_reference(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,49 +40,49 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'List<dataprotection.v4.config.ConsistencyGroup>': 'list[dataprotection.v4.config.ConsistencyGroup]',
-        'dataprotection.v4.error.ErrorResponse': 'dataprotection.v4.error.ErrorResponse',
-        'List<dataprotection.v4.config.ConsistencyGroupProjection>': 'list[dataprotection.v4.config.ConsistencyGroupProjection]'
+        'dataprotection.v4.config.AzureBlobStorageContainer': 'dataprotection.v4.config.AzureBlobStorageContainer',
+        'dataprotection.v4.config.AmazonS3Bucket': 'dataprotection.v4.config.AmazonS3Bucket',
+        'dataprotection.v4.config.NutanixObjectsBucket': 'dataprotection.v4.config.NutanixObjectsBucket'
     }
 
-    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
+    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$objectStorageReferenceItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfdataprotection.v4.config.ConsistencyGroupListApiResponsedata'
+        return 'OneOfdataprotection.v4.config.RecoveryPointRepositoryobject_storage_reference'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -115,50 +116,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in ConsistencyGroupListApiResponsedata.discriminator_value_class_map.values():
-            return list(ConsistencyGroupListApiResponsedata.discriminator_value_class_map.keys())[list(ConsistencyGroupListApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in RecoveryPointRepositoryobject_storage_reference.discriminator_value_class_map.values():
+            return list(RecoveryPointRepositoryobject_storage_reference.discriminator_value_class_map.keys())[list(RecoveryPointRepositoryobject_storage_reference.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ConsistencyGroupListApiResponsedata, dict):
+        if issubclass(RecoveryPointRepositoryobject_storage_reference, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -170,15 +176,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ConsistencyGroupListApiResponsedata):
+        if not isinstance(other, RecoveryPointRepositoryobject_storage_reference):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/ConsistencyGroupMigrateApiResponsedata.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/MigrateConsistencyGroupApiResponsedata.py`

 * *Files 11% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class ConsistencyGroupMigrateApiResponsedata(object):
+class MigrateConsistencyGroupApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,49 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'storage.v4.config.Task': 'storage.v4.config.Task',
         'prism.v4.config.TaskReference': 'prism.v4.config.TaskReference',
         'dataprotection.v4.error.ErrorResponse': 'dataprotection.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfdataprotection.v4.config.ConsistencyGroupMigrateApiResponsedata'
+        return 'OneOfdataprotection.v4.config.MigrateConsistencyGroupApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -115,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in ConsistencyGroupMigrateApiResponsedata.discriminator_value_class_map.values():
-            return list(ConsistencyGroupMigrateApiResponsedata.discriminator_value_class_map.keys())[list(ConsistencyGroupMigrateApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in MigrateConsistencyGroupApiResponsedata.discriminator_value_class_map.values():
+            return list(MigrateConsistencyGroupApiResponsedata.discriminator_value_class_map.keys())[list(MigrateConsistencyGroupApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ConsistencyGroupMigrateApiResponsedata, dict):
+        if issubclass(MigrateConsistencyGroupApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -170,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ConsistencyGroupMigrateApiResponsedata):
+        if not isinstance(other, MigrateConsistencyGroupApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/CreateConsistencyGroupRecoveryPointApiResponsedata.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/GetRecoveryPointApiResponsedata.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class CreateConsistencyGroupRecoveryPointApiResponsedata(object):
+class GetRecoveryPointApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,49 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'prism.v4.config.TaskReference': 'prism.v4.config.TaskReference',
         'dataprotection.v4.config.RecoveryPoint': 'dataprotection.v4.config.RecoveryPoint',
         'dataprotection.v4.error.ErrorResponse': 'dataprotection.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfdataprotection.v4.config.CreateConsistencyGroupRecoveryPointApiResponsedata'
+        return 'OneOfdataprotection.v4.config.GetRecoveryPointApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -115,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in CreateConsistencyGroupRecoveryPointApiResponsedata.discriminator_value_class_map.values():
-            return list(CreateConsistencyGroupRecoveryPointApiResponsedata.discriminator_value_class_map.keys())[list(CreateConsistencyGroupRecoveryPointApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in GetRecoveryPointApiResponsedata.discriminator_value_class_map.values():
+            return list(GetRecoveryPointApiResponsedata.discriminator_value_class_map.keys())[list(GetRecoveryPointApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(CreateConsistencyGroupRecoveryPointApiResponsedata, dict):
+        if issubclass(GetRecoveryPointApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -170,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, CreateConsistencyGroupRecoveryPointApiResponsedata):
+        if not isinstance(other, GetRecoveryPointApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/CreateRecoveryPointApiResponsedata.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/ListRecoveryPointsApiResponsedata.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class CreateRecoveryPointApiResponsedata(object):
+class ListRecoveryPointsApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,49 +40,49 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'prism.v4.config.TaskReference': 'prism.v4.config.TaskReference',
-        'dataprotection.v4.config.RecoveryPoint': 'dataprotection.v4.config.RecoveryPoint',
-        'dataprotection.v4.error.ErrorResponse': 'dataprotection.v4.error.ErrorResponse'
+        'List<dataprotection.v4.config.RecoveryPoint>': 'list[dataprotection.v4.config.RecoveryPoint]',
+        'dataprotection.v4.error.ErrorResponse': 'dataprotection.v4.error.ErrorResponse',
+        'List<dataprotection.v4.config.RecoveryPointProjection>': 'list[dataprotection.v4.config.RecoveryPointProjection]'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfdataprotection.v4.config.CreateRecoveryPointApiResponsedata'
+        return 'OneOfdataprotection.v4.config.ListRecoveryPointsApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -115,50 +116,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in CreateRecoveryPointApiResponsedata.discriminator_value_class_map.values():
-            return list(CreateRecoveryPointApiResponsedata.discriminator_value_class_map.keys())[list(CreateRecoveryPointApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in ListRecoveryPointsApiResponsedata.discriminator_value_class_map.values():
+            return list(ListRecoveryPointsApiResponsedata.discriminator_value_class_map.keys())[list(ListRecoveryPointsApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(CreateRecoveryPointApiResponsedata, dict):
+        if issubclass(ListRecoveryPointsApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -170,15 +176,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, CreateRecoveryPointApiResponsedata):
+        if not isinstance(other, ListRecoveryPointsApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/DeleteConsistencyGroupApiResponsedata.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/ProtectedResourceRestoreApiResponsedata.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class DeleteConsistencyGroupApiResponsedata(object):
+class ProtectedResourceRestoreApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,47 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
+        'prism.v4.config.TaskReference': 'prism.v4.config.TaskReference',
         'dataprotection.v4.error.ErrorResponse': 'dataprotection.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfdataprotection.v4.config.DeleteConsistencyGroupApiResponsedata'
+        return 'OneOfdataprotection.v4.config.ProtectedResourceRestoreApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -113,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in DeleteConsistencyGroupApiResponsedata.discriminator_value_class_map.values():
-            return list(DeleteConsistencyGroupApiResponsedata.discriminator_value_class_map.keys())[list(DeleteConsistencyGroupApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in ProtectedResourceRestoreApiResponsedata.discriminator_value_class_map.values():
+            return list(ProtectedResourceRestoreApiResponsedata.discriminator_value_class_map.keys())[list(ProtectedResourceRestoreApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(DeleteConsistencyGroupApiResponsedata, dict):
+        if issubclass(ProtectedResourceRestoreApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -168,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, DeleteConsistencyGroupApiResponsedata):
+        if not isinstance(other, ProtectedResourceRestoreApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/DeleteRecoveryPointApiResponsedata.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/UpdateRecoveryPointExpirationTimeApiResponsedata.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class DeleteRecoveryPointApiResponsedata(object):
+class UpdateRecoveryPointExpirationTimeApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,49 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'storage.v4.config.Task': 'storage.v4.config.Task',
         'prism.v4.config.TaskReference': 'prism.v4.config.TaskReference',
         'dataprotection.v4.error.ErrorResponse': 'dataprotection.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfdataprotection.v4.config.DeleteRecoveryPointApiResponsedata'
+        return 'OneOfdataprotection.v4.config.UpdateRecoveryPointExpirationTimeApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -115,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in DeleteRecoveryPointApiResponsedata.discriminator_value_class_map.values():
-            return list(DeleteRecoveryPointApiResponsedata.discriminator_value_class_map.keys())[list(DeleteRecoveryPointApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in UpdateRecoveryPointExpirationTimeApiResponsedata.discriminator_value_class_map.values():
+            return list(UpdateRecoveryPointExpirationTimeApiResponsedata.discriminator_value_class_map.keys())[list(UpdateRecoveryPointExpirationTimeApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(DeleteRecoveryPointApiResponsedata, dict):
+        if issubclass(UpdateRecoveryPointExpirationTimeApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -170,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, DeleteRecoveryPointApiResponsedata):
+        if not isinstance(other, UpdateRecoveryPointExpirationTimeApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/DiskRecoveryPointApiResponsedata.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/error/ErrorResponseerror.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class DiskRecoveryPointApiResponsedata(object):
+class ErrorResponseerror(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'dataprotection.v4.config.DiskRecoveryPoint': 'dataprotection.v4.config.DiskRecoveryPoint',
-        'dataprotection.v4.error.ErrorResponse': 'dataprotection.v4.error.ErrorResponse'
+        'List<dataprotection.v4.error.AppMessage>': 'list[dataprotection.v4.error.AppMessage]',
+        'dataprotection.v4.error.SchemaValidationError': 'dataprotection.v4.error.SchemaValidationError'
     }
 
-    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
+    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$errorItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfdataprotection.v4.config.DiskRecoveryPointApiResponsedata'
+        return 'OneOfdataprotection.v4.error.ErrorResponseerror'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in DiskRecoveryPointApiResponsedata.discriminator_value_class_map.values():
-            return list(DiskRecoveryPointApiResponsedata.discriminator_value_class_map.keys())[list(DiskRecoveryPointApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in ErrorResponseerror.discriminator_value_class_map.values():
+            return list(ErrorResponseerror.discriminator_value_class_map.keys())[list(ErrorResponseerror.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(DiskRecoveryPointApiResponsedata, dict):
+        if issubclass(ErrorResponseerror, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, DiskRecoveryPointApiResponsedata):
+        if not isinstance(other, ErrorResponseerror):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/DiskRecoveryPointListApiResponsedata.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/DeleteConsistencyGroupApiResponsedata.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class DiskRecoveryPointListApiResponsedata(object):
+class DeleteConsistencyGroupApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,47 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'List<dataprotection.v4.config.DiskRecoveryPoint>': 'list[dataprotection.v4.config.DiskRecoveryPoint]',
         'dataprotection.v4.error.ErrorResponse': 'dataprotection.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfdataprotection.v4.config.DiskRecoveryPointListApiResponsedata'
+        return 'OneOfdataprotection.v4.config.DeleteConsistencyGroupApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +114,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in DiskRecoveryPointListApiResponsedata.discriminator_value_class_map.values():
-            return list(DiskRecoveryPointListApiResponsedata.discriminator_value_class_map.keys())[list(DiskRecoveryPointListApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in DeleteConsistencyGroupApiResponsedata.discriminator_value_class_map.values():
+            return list(DeleteConsistencyGroupApiResponsedata.discriminator_value_class_map.keys())[list(DeleteConsistencyGroupApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(DiskRecoveryPointListApiResponsedata, dict):
+        if issubclass(DeleteConsistencyGroupApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +174,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, DiskRecoveryPointListApiResponsedata):
+        if not isinstance(other, DeleteConsistencyGroupApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/ProtectedResourceApiResponsedata.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/RecoveryPointRepositoryProjectionobject_storage_reference.py`

 * *Files 13% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class ProtectedResourceApiResponsedata(object):
+class RecoveryPointRepositoryProjectionobject_storage_reference(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,49 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'dataprotection.v4.config.ProtectedResource': 'dataprotection.v4.config.ProtectedResource',
-        'dataprotection.v4.error.ErrorResponse': 'dataprotection.v4.error.ErrorResponse'
+        'dataprotection.v4.config.AzureBlobStorageContainer': 'dataprotection.v4.config.AzureBlobStorageContainer',
+        'dataprotection.v4.config.AmazonS3Bucket': 'dataprotection.v4.config.AmazonS3Bucket',
+        'dataprotection.v4.config.NutanixObjectsBucket': 'dataprotection.v4.config.NutanixObjectsBucket'
     }
 
-    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
+    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$objectStorageReferenceItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfdataprotection.v4.config.ProtectedResourceApiResponsedata'
+        return 'OneOfdataprotection.v4.config.RecoveryPointRepositoryProjectionobject_storage_reference'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +116,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in ProtectedResourceApiResponsedata.discriminator_value_class_map.values():
-            return list(ProtectedResourceApiResponsedata.discriminator_value_class_map.keys())[list(ProtectedResourceApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in RecoveryPointRepositoryProjectionobject_storage_reference.discriminator_value_class_map.values():
+            return list(RecoveryPointRepositoryProjectionobject_storage_reference.discriminator_value_class_map.keys())[list(RecoveryPointRepositoryProjectionobject_storage_reference.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ProtectedResourceApiResponsedata, dict):
+        if issubclass(RecoveryPointRepositoryProjectionobject_storage_reference, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +176,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ProtectedResourceApiResponsedata):
+        if not isinstance(other, RecoveryPointRepositoryProjectionobject_storage_reference):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/ProtectedResourcePromoteApiResponsedata.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/ProtectedResourcePromoteApiResponsedata.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
 class ProtectedResourcePromoteApiResponsedata(object):
 
     """
 
 
     """
@@ -54,33 +55,33 @@
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'OneOfdataprotection.v4.config.ProtectedResourcePromoteApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -127,28 +128,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/ProtectedResourceRestoreApiResponsedata.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/ComputeChangedRegionsResponseModeldata.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class ProtectedResourceRestoreApiResponsedata(object):
+class ComputeChangedRegionsResponseModeldata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'prism.v4.config.TaskReference': 'prism.v4.config.TaskReference',
+        'dataprotection.v4.config.ComputeChangedRegionsResponse': 'dataprotection.v4.config.ComputeChangedRegionsResponse',
         'dataprotection.v4.error.ErrorResponse': 'dataprotection.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfdataprotection.v4.config.ProtectedResourceRestoreApiResponsedata'
+        return 'OneOfdataprotection.v4.config.ComputeChangedRegionsResponseModeldata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in ProtectedResourceRestoreApiResponsedata.discriminator_value_class_map.values():
-            return list(ProtectedResourceRestoreApiResponsedata.discriminator_value_class_map.keys())[list(ProtectedResourceRestoreApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in ComputeChangedRegionsResponseModeldata.discriminator_value_class_map.values():
+            return list(ComputeChangedRegionsResponseModeldata.discriminator_value_class_map.keys())[list(ComputeChangedRegionsResponseModeldata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ProtectedResourceRestoreApiResponsedata, dict):
+        if issubclass(ComputeChangedRegionsResponseModeldata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ProtectedResourceRestoreApiResponsedata):
+        if not isinstance(other, ComputeChangedRegionsResponseModeldata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/RecoveryPointApiResponsedata.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/ProtectedResourceRestoreSpecoverrides.py`

 * *Files 11% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class RecoveryPointApiResponsedata(object):
+class ProtectedResourceRestoreSpecoverrides(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,49 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'dataprotection.v4.config.RecoveryPoint': 'dataprotection.v4.config.RecoveryPoint',
-        'dataprotection.v4.error.ErrorResponse': 'dataprotection.v4.error.ErrorResponse'
+        'dataprotection.v4.config.AhvVmOverrideSpec': 'dataprotection.v4.config.AhvVmOverrideSpec',
+        'dataprotection.v4.config.EsxiVmOverrideSpec': 'dataprotection.v4.config.EsxiVmOverrideSpec',
+        'dataprotection.v4.config.VolumeGroupOverrideSpec': 'dataprotection.v4.config.VolumeGroupOverrideSpec'
     }
 
-    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
+    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$overridesItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfdataprotection.v4.config.RecoveryPointApiResponsedata'
+        return 'OneOfdataprotection.v4.config.ProtectedResourceRestoreSpecoverrides'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +116,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in RecoveryPointApiResponsedata.discriminator_value_class_map.values():
-            return list(RecoveryPointApiResponsedata.discriminator_value_class_map.keys())[list(RecoveryPointApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in ProtectedResourceRestoreSpecoverrides.discriminator_value_class_map.values():
+            return list(ProtectedResourceRestoreSpecoverrides.discriminator_value_class_map.keys())[list(ProtectedResourceRestoreSpecoverrides.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(RecoveryPointApiResponsedata, dict):
+        if issubclass(ProtectedResourceRestoreSpecoverrides, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +176,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, RecoveryPointApiResponsedata):
+        if not isinstance(other, ProtectedResourceRestoreSpecoverrides):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/RecoveryPointListApiResponsedata.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/error/ErrorResponse.py`

 * *Files 13% similar despite different names*

```diff
@@ -3,161 +3,190 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
+import ntnx_dataprotection_py_client.models
+from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.error.ErrorResponseerror import ErrorResponseerror  # noqa: F401,E501
 
-class RecoveryPointListApiResponsedata(object):
+class ErrorResponse(object):
 
-    """
+    """This schema is auto-generated by the Open API Dev Platform as REST response for 4xx and 5xx error responses.
 
+    :param error: (:attr:`error`) 
+    :type error: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
+        'error': 'OneOfdataprotection.v4.error.ErrorResponseerror',
+        '_reserved': 'dict(str, object)',
+        '_object_type': 'str',
+        '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
+        'error': 'error',
+        '_reserved': '$reserved',
+        '_object_type': '$objectType',
+        '_unknown_fields': '$unknownFields',
     }
 
-    discriminator_value_class_map = {
-        'EMPTY_LIST': 'list[str]',
-        'EMPTY_MAP': 'dict(str, object)',
-        'List<dataprotection.v4.config.RecoveryPoint>': 'list[dataprotection.v4.config.RecoveryPoint]',
-        'dataprotection.v4.error.ErrorResponse': 'dataprotection.v4.error.ErrorResponse'
-    }
-
-    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
-    def __init__(self, *args, **kwargs):  # noqa: E501
+    def __init__(self, error=None, *args, **kwargs):  # noqa: E501
+        self.__error = None
         self.discriminator = None
+        if error is not None:
+            self.__error = error
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfdataprotection.v4.config.RecoveryPointListApiResponsedata'
+        return 'dataprotection.v4.error.ErrorResponse'
 
-    def _initialize_fq_object_type(self):
-        return ''
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
-    def get_real_child_model(self, discriminator):
-        """Returns the real base class specified by the discriminator"""
-        if discriminator is not None and discriminator in self.discriminator_value_class_map:
-            return self.discriminator_value_class_map.get(discriminator)
-        return None
-
-    @staticmethod
-    def get_discriminator_from_object(value):
-        """Returns the discriminator for the provided object.
+    @property
+    def error(self):
         """
-        if not value:
-            disc = 'list[str]'
-        elif hasattr(value, "_object_type"):
-            disc = value.get_object_type()
-        elif type(value) == list:
-            if hasattr(value[0], "_object_type"):
-                datatype = value[0].get_object_type()
-            else:
-                datatype = type(value[0]).__name__
-            disc = 'list[' + datatype + ']'
-        elif type(value) == dict:
-            if hasattr(next(iter(value.values())), "_object_type"):
-                datatype = next(iter(value.values())).get_object_type()
-            else:
-                datatype = type(next(iter(value.values()))).__name__
-            disc = 'dict(str, ' + datatype + ')'
-        else:
-            disc = type(value).__name__
-        if disc in RecoveryPointListApiResponsedata.discriminator_value_class_map.values():
-            return list(RecoveryPointListApiResponsedata.discriminator_value_class_map.keys())[list(RecoveryPointListApiResponsedata.discriminator_value_class_map.values()).index(disc)]
-        return None
+        
+
+        :type:
+                :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.error.AppMessage` | 
+                :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.error.SchemaValidationError`
+                    """  # noqa: E501
+        return self.__error
+
+    @error.setter
+    def error(self, error):
+
+        self.__error = error
+
+    @property
+    def _reserved(self):
+        """
+        
 
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
+        return self.__dollar_reserved
+
+    @property
+    def _object_type(self):
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__dollar_object_type
+
+    @property
+    def _unknown_fields(self):
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
+        return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
+            if attr_type.startswith('OneOf'):
+                type = getattr(ntnx_dataprotection_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(RecoveryPointListApiResponsedata, dict):
+        if issubclass(ErrorResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +198,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, RecoveryPointListApiResponsedata):
+        if not isinstance(other, ErrorResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/RecoveryPointReplicateApiResponsedata.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/RecoveryPointReplicateApiResponsedata.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
 class RecoveryPointReplicateApiResponsedata(object):
 
     """
 
 
     """
@@ -39,15 +40,14 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'storage.v4.config.Task': 'storage.v4.config.Task',
         'prism.v4.config.TaskReference': 'prism.v4.config.TaskReference',
         'dataprotection.v4.error.ErrorResponse': 'dataprotection.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
@@ -55,33 +55,33 @@
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'OneOfdataprotection.v4.config.RecoveryPointReplicateApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -128,28 +128,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/RecoveryPointRestoreApiResponsedata.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/RecoveryPointRestoreApiResponsedata.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
 class RecoveryPointRestoreApiResponsedata(object):
 
     """
 
 
     """
@@ -39,15 +40,14 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'storage.v4.config.Task': 'storage.v4.config.Task',
         'prism.v4.config.TaskReference': 'prism.v4.config.TaskReference',
         'dataprotection.v4.error.ErrorResponse': 'dataprotection.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
@@ -55,33 +55,33 @@
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'OneOfdataprotection.v4.config.RecoveryPointRestoreApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -128,28 +128,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/SyncedVolumeGroupByIdApiResponsedata.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/CreateRecoveryPointApiResponsedata.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class SyncedVolumeGroupByIdApiResponsedata(object):
+class CreateRecoveryPointApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'dataprotection.v4.config.VolumeGroupSyncContext': 'dataprotection.v4.config.VolumeGroupSyncContext',
+        'prism.v4.config.TaskReference': 'prism.v4.config.TaskReference',
         'dataprotection.v4.error.ErrorResponse': 'dataprotection.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfdataprotection.v4.config.SyncedVolumeGroupByIdApiResponsedata'
+        return 'OneOfdataprotection.v4.config.CreateRecoveryPointApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in SyncedVolumeGroupByIdApiResponsedata.discriminator_value_class_map.values():
-            return list(SyncedVolumeGroupByIdApiResponsedata.discriminator_value_class_map.keys())[list(SyncedVolumeGroupByIdApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in CreateRecoveryPointApiResponsedata.discriminator_value_class_map.values():
+            return list(CreateRecoveryPointApiResponsedata.discriminator_value_class_map.keys())[list(CreateRecoveryPointApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(SyncedVolumeGroupByIdApiResponsedata, dict):
+        if issubclass(CreateRecoveryPointApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, SyncedVolumeGroupByIdApiResponsedata):
+        if not isinstance(other, CreateRecoveryPointApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/SynchronousReplicaPromoteApiResponsedata.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/IpAddress.py`

 * *Files 12% similar despite different names*

```diff
@@ -3,161 +3,189 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class SynchronousReplicaPromoteApiResponsedata(object):
+class IpAddress(object):
 
-    """
+    """IP address.
 
+    :param ipv4: (:attr:`ipv4`) IP address value in IPv4 format.
+    :type ipv4: required
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
+        'ipv4': 'str',
+        '_reserved': 'dict(str, object)',
+        '_object_type': 'str',
+        '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
+        'ipv4': 'ipv4',
+        '_reserved': '$reserved',
+        '_object_type': '$objectType',
+        '_unknown_fields': '$unknownFields',
     }
 
-    discriminator_value_class_map = {
-        'EMPTY_LIST': 'list[str]',
-        'EMPTY_MAP': 'dict(str, object)',
-        'prism.v4.config.TaskReference': 'prism.v4.config.TaskReference',
-        'dataprotection.v4.error.ErrorResponse': 'dataprotection.v4.error.ErrorResponse'
-    }
-
-    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
-    def __init__(self, *args, **kwargs):  # noqa: E501
+    def __init__(self, ipv4=None, *args, **kwargs):  # noqa: E501
+        self.__ipv4 = None
         self.discriminator = None
+        self.__ipv4 = ipv4
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfdataprotection.v4.config.SynchronousReplicaPromoteApiResponsedata'
+        return 'dataprotection.v4.config.IpAddress'
 
-    def _initialize_fq_object_type(self):
-        return ''
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
-    def get_real_child_model(self, discriminator):
-        """Returns the real base class specified by the discriminator"""
-        if discriminator is not None and discriminator in self.discriminator_value_class_map:
-            return self.discriminator_value_class_map.get(discriminator)
-        return None
-
-    @staticmethod
-    def get_discriminator_from_object(value):
-        """Returns the discriminator for the provided object.
+    @property
+    def ipv4(self):
         """
-        if not value:
-            disc = 'list[str]'
-        elif hasattr(value, "_object_type"):
-            disc = value.get_object_type()
-        elif type(value) == list:
-            if hasattr(value[0], "_object_type"):
-                datatype = value[0].get_object_type()
-            else:
-                datatype = type(value[0]).__name__
-            disc = 'list[' + datatype + ']'
-        elif type(value) == dict:
-            if hasattr(next(iter(value.values())), "_object_type"):
-                datatype = next(iter(value.values())).get_object_type()
-            else:
-                datatype = type(next(iter(value.values()))).__name__
-            disc = 'dict(str, ' + datatype + ')'
-        else:
-            disc = type(value).__name__
-        if disc in SynchronousReplicaPromoteApiResponsedata.discriminator_value_class_map.values():
-            return list(SynchronousReplicaPromoteApiResponsedata.discriminator_value_class_map.keys())[list(SynchronousReplicaPromoteApiResponsedata.discriminator_value_class_map.values()).index(disc)]
-        return None
+        IP address value in IPv4 format.
 
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__ipv4
+
+    @ipv4.setter
+    def ipv4(self, ipv4):
+        if ipv4 is None:
+            raise ValueError("Invalid value for `ipv4`, must not be `None`")  # noqa: E501
+        if ipv4 is not None and not re.search('^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$', ipv4):  # noqa: E501
+            raise ValueError(r"Invalid value for `ipv4`, must be a follow pattern or equal to `/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/`")  # noqa: E501
+
+        self.__ipv4 = ipv4
+
+    @property
+    def _reserved(self):
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
+        return self.__dollar_reserved
+
+    @property
+    def _object_type(self):
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__dollar_object_type
+
+    @property
+    def _unknown_fields(self):
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
+        return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(SynchronousReplicaPromoteApiResponsedata, dict):
+        if issubclass(IpAddress, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +197,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, SynchronousReplicaPromoteApiResponsedata):
+        if not isinstance(other, IpAddress):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/UpdateRecoveryPointExpirationTimeApiResponsedata.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/UpdateConsistencyGroupApiResponsedata.py`

 * *Files 12% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class UpdateRecoveryPointExpirationTimeApiResponsedata(object):
+class UpdateConsistencyGroupApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'prism.v4.config.TaskReference': 'prism.v4.config.TaskReference',
+        'List<dataprotection.v4.error.AppMessage>': 'list[dataprotection.v4.error.AppMessage]',
         'dataprotection.v4.error.ErrorResponse': 'dataprotection.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfdataprotection.v4.config.UpdateRecoveryPointExpirationTimeApiResponsedata'
+        return 'OneOfdataprotection.v4.config.UpdateConsistencyGroupApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in UpdateRecoveryPointExpirationTimeApiResponsedata.discriminator_value_class_map.values():
-            return list(UpdateRecoveryPointExpirationTimeApiResponsedata.discriminator_value_class_map.keys())[list(UpdateRecoveryPointExpirationTimeApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in UpdateConsistencyGroupApiResponsedata.discriminator_value_class_map.values():
+            return list(UpdateConsistencyGroupApiResponsedata.discriminator_value_class_map.keys())[list(UpdateConsistencyGroupApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(UpdateRecoveryPointExpirationTimeApiResponsedata, dict):
+        if issubclass(UpdateConsistencyGroupApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, UpdateRecoveryPointExpirationTimeApiResponsedata):
+        if not isinstance(other, UpdateConsistencyGroupApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/VMRecoveryPointApiResponsedata.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/common/v1/config/KVPair.py`

 * *Files 13% similar despite different names*

```diff
@@ -3,161 +3,216 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-
-class VMRecoveryPointApiResponsedata(object):
-
-    """
-
+from pathlib import Path
+import ntnx_dataprotection_py_client.models
+from ntnx_dataprotection_py_client.models.OneOfcommon.v1.config.KVPairvalue import KVPairvalue  # noqa: F401,E501
+
+class KVPair(object):
+
+    """A map describing a set of keys and their corresponding values. 
+
+    :param name: (:attr:`name`) The key of this key-value pair
+    :type name: 
+    :param value: (:attr:`value`) The value associated with the key for this key-value pair
+    :type value: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
+        'name': 'str',
+        'value': 'OneOfcommon.v1.config.KVPairvalue',
+        '_reserved': 'dict(str, object)',
+        '_object_type': 'str',
+        '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
+        'name': 'name',
+        'value': 'value',
+        '_reserved': '$reserved',
+        '_object_type': '$objectType',
+        '_unknown_fields': '$unknownFields',
     }
 
-    discriminator_value_class_map = {
-        'EMPTY_LIST': 'list[str]',
-        'EMPTY_MAP': 'dict(str, object)',
-        'dataprotection.v4.config.VMRecoveryPoint': 'dataprotection.v4.config.VMRecoveryPoint',
-        'dataprotection.v4.error.ErrorResponse': 'dataprotection.v4.error.ErrorResponse'
-    }
-
-    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
-    def __init__(self, *args, **kwargs):  # noqa: E501
+    def __init__(self, name=None, value=None, *args, **kwargs):  # noqa: E501
+        self.__name = None
+        self.__value = None
         self.discriminator = None
+        if name is not None:
+            self.__name = name
+        if value is not None:
+            self.__value = value
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfdataprotection.v4.config.VMRecoveryPointApiResponsedata'
+        return 'common.v1.config.KVPair'
 
-    def _initialize_fq_object_type(self):
-        return ''
+    def _initialize_object_version(self):
+        return 'v1.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
-    def get_real_child_model(self, discriminator):
-        """Returns the real base class specified by the discriminator"""
-        if discriminator is not None and discriminator in self.discriminator_value_class_map:
-            return self.discriminator_value_class_map.get(discriminator)
-        return None
-
-    @staticmethod
-    def get_discriminator_from_object(value):
-        """Returns the discriminator for the provided object.
-        """
-        if not value:
-            disc = 'list[str]'
-        elif hasattr(value, "_object_type"):
-            disc = value.get_object_type()
-        elif type(value) == list:
-            if hasattr(value[0], "_object_type"):
-                datatype = value[0].get_object_type()
-            else:
-                datatype = type(value[0]).__name__
-            disc = 'list[' + datatype + ']'
-        elif type(value) == dict:
-            if hasattr(next(iter(value.values())), "_object_type"):
-                datatype = next(iter(value.values())).get_object_type()
-            else:
-                datatype = type(next(iter(value.values()))).__name__
-            disc = 'dict(str, ' + datatype + ')'
-        else:
-            disc = type(value).__name__
-        if disc in VMRecoveryPointApiResponsedata.discriminator_value_class_map.values():
-            return list(VMRecoveryPointApiResponsedata.discriminator_value_class_map.keys())[list(VMRecoveryPointApiResponsedata.discriminator_value_class_map.values()).index(disc)]
-        return None
+    @property
+    def name(self):
+        """
+        The key of this key-value pair
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__name
+
+    @name.setter
+    def name(self, name):
+
+        self.__name = name
+
+    @property
+    def value(self):
+        """
+        The value associated with the key for this key-value pair
 
+        :type:
+                :class:`~str` | 
+                :class:`~int` | 
+                :class:`~bool` | 
+                :class:`~list[str]` | 
+                :class:`~dict(str, str)`
+                    """  # noqa: E501
+        return self.__value
+
+    @value.setter
+    def value(self, value):
+
+        self.__value = value
+
+    @property
+    def _reserved(self):
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
+        return self.__dollar_reserved
+
+    @property
+    def _object_type(self):
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__dollar_object_type
+
+    @property
+    def _unknown_fields(self):
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
+        return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
+            if attr_type.startswith('OneOf'):
+                type = getattr(ntnx_dataprotection_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(VMRecoveryPointApiResponsedata, dict):
+        if issubclass(KVPair, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +224,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, VMRecoveryPointApiResponsedata):
+        if not isinstance(other, KVPair):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/VMRecoveryPointListApiResponsedata.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/GetRecoveryPointApiResponse.py`

 * *Files 14% similar despite different names*

```diff
@@ -3,161 +3,213 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-
-class VMRecoveryPointListApiResponsedata(object):
-
-    """
-
+from pathlib import Path
+import ntnx_dataprotection_py_client.models
+from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.GetRecoveryPointApiResponsedata import GetRecoveryPointApiResponsedata  # noqa: F401,E501
+from ntnx_dataprotection_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class GetRecoveryPointApiResponse(object):
+
+    """REST response for all response codes in API path /dataprotection/v4.0.b1/config/recovery-points/{extId} Get operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
+        'metadata': 'common.v1.response.ApiResponseMetadata',
+        'data': 'OneOfdataprotection.v4.config.GetRecoveryPointApiResponsedata',
+        '_reserved': 'dict(str, object)',
+        '_object_type': 'str',
+        '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
+        'metadata': 'metadata',
+        'data': 'data',
+        '_reserved': '$reserved',
+        '_object_type': '$objectType',
+        '_unknown_fields': '$unknownFields',
     }
 
-    discriminator_value_class_map = {
-        'EMPTY_LIST': 'list[str]',
-        'EMPTY_MAP': 'dict(str, object)',
-        'List<dataprotection.v4.config.VMRecoveryPoint>': 'list[dataprotection.v4.config.VMRecoveryPoint]',
-        'dataprotection.v4.error.ErrorResponse': 'dataprotection.v4.error.ErrorResponse'
-    }
-
-    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
-    def __init__(self, *args, **kwargs):  # noqa: E501
+    def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
+        self.__metadata = None
+        self.__data = None
         self.discriminator = None
+        if metadata is not None:
+            self.__metadata = metadata
+        if data is not None:
+            self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfdataprotection.v4.config.VMRecoveryPointListApiResponsedata'
+        return 'dataprotection.v4.config.GetRecoveryPointApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return ''
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
-    def get_real_child_model(self, discriminator):
-        """Returns the real base class specified by the discriminator"""
-        if discriminator is not None and discriminator in self.discriminator_value_class_map:
-            return self.discriminator_value_class_map.get(discriminator)
-        return None
-
-    @staticmethod
-    def get_discriminator_from_object(value):
-        """Returns the discriminator for the provided object.
-        """
-        if not value:
-            disc = 'list[str]'
-        elif hasattr(value, "_object_type"):
-            disc = value.get_object_type()
-        elif type(value) == list:
-            if hasattr(value[0], "_object_type"):
-                datatype = value[0].get_object_type()
-            else:
-                datatype = type(value[0]).__name__
-            disc = 'list[' + datatype + ']'
-        elif type(value) == dict:
-            if hasattr(next(iter(value.values())), "_object_type"):
-                datatype = next(iter(value.values())).get_object_type()
-            else:
-                datatype = type(next(iter(value.values()))).__name__
-            disc = 'dict(str, ' + datatype + ')'
-        else:
-            disc = type(value).__name__
-        if disc in VMRecoveryPointListApiResponsedata.discriminator_value_class_map.values():
-            return list(VMRecoveryPointListApiResponsedata.discriminator_value_class_map.keys())[list(VMRecoveryPointListApiResponsedata.discriminator_value_class_map.values()).index(disc)]
-        return None
+    @property
+    def metadata(self):
+        """
+        
+
+        :type:
+            :class:`~ntnx_dataprotection_py_client.models.common.v1.response.ApiResponseMetadata`
+        """  # noqa: E501
+        return self.__metadata
+
+    @metadata.setter
+    def metadata(self, metadata):
+
+        self.__metadata = metadata
+
+    @property
+    def data(self):
+        """
+        
+
+        :type:
+                :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.RecoveryPoint` | 
+                :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.error.ErrorResponse`
+                    """  # noqa: E501
+        return self.__data
 
+    @data.setter
+    def data(self, data):
+
+        self.__data = data
+
+    @property
+    def _reserved(self):
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
+        return self.__dollar_reserved
+
+    @property
+    def _object_type(self):
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__dollar_object_type
+
+    @property
+    def _unknown_fields(self):
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
+        return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
+            if attr_type.startswith('OneOf'):
+                type = getattr(ntnx_dataprotection_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(VMRecoveryPointListApiResponsedata, dict):
+        if issubclass(GetRecoveryPointApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, VMRecoveryPointListApiResponsedata):
+        if not isinstance(other, GetRecoveryPointApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/ValidateRestoreVmRecoveryPointApiResponsedata.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/DeleteRecoveryPointApiResponse.py`

 * *Files 14% similar despite different names*

```diff
@@ -3,161 +3,213 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-
-class ValidateRestoreVmRecoveryPointApiResponsedata(object):
-
-    """
-
+from pathlib import Path
+import ntnx_dataprotection_py_client.models
+from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.DeleteRecoveryPointApiResponsedata import DeleteRecoveryPointApiResponsedata  # noqa: F401,E501
+from ntnx_dataprotection_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class DeleteRecoveryPointApiResponse(object):
+
+    """REST response for all response codes in API path /dataprotection/v4.0.b1/config/recovery-points/{extId} Delete operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
+        'metadata': 'common.v1.response.ApiResponseMetadata',
+        'data': 'OneOfdataprotection.v4.config.DeleteRecoveryPointApiResponsedata',
+        '_reserved': 'dict(str, object)',
+        '_object_type': 'str',
+        '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
+        'metadata': 'metadata',
+        'data': 'data',
+        '_reserved': '$reserved',
+        '_object_type': '$objectType',
+        '_unknown_fields': '$unknownFields',
     }
 
-    discriminator_value_class_map = {
-        'EMPTY_LIST': 'list[str]',
-        'EMPTY_MAP': 'dict(str, object)',
-        'List<dataprotection.v4.config.ValidateRecoveryPointResult>': 'list[dataprotection.v4.config.ValidateRecoveryPointResult]',
-        'dataprotection.v4.error.ErrorResponse': 'dataprotection.v4.error.ErrorResponse'
-    }
-
-    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
-    def __init__(self, *args, **kwargs):  # noqa: E501
+    def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
+        self.__metadata = None
+        self.__data = None
         self.discriminator = None
+        if metadata is not None:
+            self.__metadata = metadata
+        if data is not None:
+            self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfdataprotection.v4.config.ValidateRestoreVmRecoveryPointApiResponsedata'
+        return 'dataprotection.v4.config.DeleteRecoveryPointApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return ''
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
-    def get_real_child_model(self, discriminator):
-        """Returns the real base class specified by the discriminator"""
-        if discriminator is not None and discriminator in self.discriminator_value_class_map:
-            return self.discriminator_value_class_map.get(discriminator)
-        return None
-
-    @staticmethod
-    def get_discriminator_from_object(value):
-        """Returns the discriminator for the provided object.
-        """
-        if not value:
-            disc = 'list[str]'
-        elif hasattr(value, "_object_type"):
-            disc = value.get_object_type()
-        elif type(value) == list:
-            if hasattr(value[0], "_object_type"):
-                datatype = value[0].get_object_type()
-            else:
-                datatype = type(value[0]).__name__
-            disc = 'list[' + datatype + ']'
-        elif type(value) == dict:
-            if hasattr(next(iter(value.values())), "_object_type"):
-                datatype = next(iter(value.values())).get_object_type()
-            else:
-                datatype = type(next(iter(value.values()))).__name__
-            disc = 'dict(str, ' + datatype + ')'
-        else:
-            disc = type(value).__name__
-        if disc in ValidateRestoreVmRecoveryPointApiResponsedata.discriminator_value_class_map.values():
-            return list(ValidateRestoreVmRecoveryPointApiResponsedata.discriminator_value_class_map.keys())[list(ValidateRestoreVmRecoveryPointApiResponsedata.discriminator_value_class_map.values()).index(disc)]
-        return None
+    @property
+    def metadata(self):
+        """
+        
+
+        :type:
+            :class:`~ntnx_dataprotection_py_client.models.common.v1.response.ApiResponseMetadata`
+        """  # noqa: E501
+        return self.__metadata
+
+    @metadata.setter
+    def metadata(self, metadata):
+
+        self.__metadata = metadata
+
+    @property
+    def data(self):
+        """
+        
+
+        :type:
+                :class:`~ntnx_dataprotection_py_client.models.prism.v4.config.TaskReference` | 
+                :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.error.ErrorResponse`
+                    """  # noqa: E501
+        return self.__data
 
+    @data.setter
+    def data(self, data):
+
+        self.__data = data
+
+    @property
+    def _reserved(self):
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
+        return self.__dollar_reserved
+
+    @property
+    def _object_type(self):
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__dollar_object_type
+
+    @property
+    def _unknown_fields(self):
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
+        return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
+            if attr_type.startswith('OneOf'):
+                type = getattr(ntnx_dataprotection_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ValidateRestoreVmRecoveryPointApiResponsedata, dict):
+        if issubclass(DeleteRecoveryPointApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ValidateRestoreVmRecoveryPointApiResponsedata):
+        if not isinstance(other, DeleteRecoveryPointApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/VmRecoveryPointRestoreApiResponsedata.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/DeleteRecoveryPointApiResponsedata.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class VmRecoveryPointRestoreApiResponsedata(object):
+class DeleteRecoveryPointApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,49 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'storage.v4.config.Task': 'storage.v4.config.Task',
         'prism.v4.config.TaskReference': 'prism.v4.config.TaskReference',
         'dataprotection.v4.error.ErrorResponse': 'dataprotection.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfdataprotection.v4.config.VmRecoveryPointRestoreApiResponsedata'
+        return 'OneOfdataprotection.v4.config.DeleteRecoveryPointApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -115,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in VmRecoveryPointRestoreApiResponsedata.discriminator_value_class_map.values():
-            return list(VmRecoveryPointRestoreApiResponsedata.discriminator_value_class_map.keys())[list(VmRecoveryPointRestoreApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in DeleteRecoveryPointApiResponsedata.discriminator_value_class_map.values():
+            return list(DeleteRecoveryPointApiResponsedata.discriminator_value_class_map.keys())[list(DeleteRecoveryPointApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(VmRecoveryPointRestoreApiResponsedata, dict):
+        if issubclass(DeleteRecoveryPointApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -170,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, VmRecoveryPointRestoreApiResponsedata):
+        if not isinstance(other, DeleteRecoveryPointApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/VolumeGroupRecoveryPointApiResponsedata.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/CreateConsistencyGroupApiResponsedata.py`

 * *Files 12% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class VolumeGroupRecoveryPointApiResponsedata(object):
+class CreateConsistencyGroupApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'dataprotection.v4.config.VolumeGroupRecoveryPoint': 'dataprotection.v4.config.VolumeGroupRecoveryPoint',
+        'dataprotection.v4.config.ConsistencyGroup': 'dataprotection.v4.config.ConsistencyGroup',
         'dataprotection.v4.error.ErrorResponse': 'dataprotection.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfdataprotection.v4.config.VolumeGroupRecoveryPointApiResponsedata'
+        return 'OneOfdataprotection.v4.config.CreateConsistencyGroupApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in VolumeGroupRecoveryPointApiResponsedata.discriminator_value_class_map.values():
-            return list(VolumeGroupRecoveryPointApiResponsedata.discriminator_value_class_map.keys())[list(VolumeGroupRecoveryPointApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in CreateConsistencyGroupApiResponsedata.discriminator_value_class_map.values():
+            return list(CreateConsistencyGroupApiResponsedata.discriminator_value_class_map.keys())[list(CreateConsistencyGroupApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(VolumeGroupRecoveryPointApiResponsedata, dict):
+        if issubclass(CreateConsistencyGroupApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, VolumeGroupRecoveryPointApiResponsedata):
+        if not isinstance(other, CreateConsistencyGroupApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/VolumeGroupRecoveryPointListApiResponsedata.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/common/v1/config/TenantAwareModel.py`

 * *Files 14% similar despite different names*

```diff
@@ -3,161 +3,188 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class VolumeGroupRecoveryPointListApiResponsedata(object):
+class TenantAwareModel(object):
 
-    """
+    """A model base class whose instances are bound to a specific tenant.  This model adds a tenantId to the base model class that it extends and is automatically set by the server. 
 
+    :param tenant_id: (:attr:`tenant_id`) A globally unique identifier that represents the tenant that owns this entity. The system automatically assigns it, and it and is immutable from an API consumer perspective (some use cases may cause this Id to change - For instance, a use case may require the transfer of ownership of the entity, but these cases are handled automatically on the server). 
+    :type tenant_id: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
+        'tenant_id': 'str',
+        '_reserved': 'dict(str, object)',
+        '_object_type': 'str',
+        '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
+        'tenant_id': 'tenantId',
+        '_reserved': '$reserved',
+        '_object_type': '$objectType',
+        '_unknown_fields': '$unknownFields',
     }
 
-    discriminator_value_class_map = {
-        'EMPTY_LIST': 'list[str]',
-        'EMPTY_MAP': 'dict(str, object)',
-        'List<dataprotection.v4.config.VolumeGroupRecoveryPoint>': 'list[dataprotection.v4.config.VolumeGroupRecoveryPoint]',
-        'dataprotection.v4.error.ErrorResponse': 'dataprotection.v4.error.ErrorResponse'
-    }
-
-    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
-    def __init__(self, *args, **kwargs):  # noqa: E501
+    def __init__(self, tenant_id=None, *args, **kwargs):  # noqa: E501
+        self.__tenant_id = None
         self.discriminator = None
+        if tenant_id is not None:
+            self.__tenant_id = tenant_id
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfdataprotection.v4.config.VolumeGroupRecoveryPointListApiResponsedata'
+        return 'common.v1.config.TenantAwareModel'
 
-    def _initialize_fq_object_type(self):
-        return ''
+    def _initialize_object_version(self):
+        return 'v1.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
-    def get_real_child_model(self, discriminator):
-        """Returns the real base class specified by the discriminator"""
-        if discriminator is not None and discriminator in self.discriminator_value_class_map:
-            return self.discriminator_value_class_map.get(discriminator)
-        return None
-
-    @staticmethod
-    def get_discriminator_from_object(value):
-        """Returns the discriminator for the provided object.
+    @property
+    def tenant_id(self):
         """
-        if not value:
-            disc = 'list[str]'
-        elif hasattr(value, "_object_type"):
-            disc = value.get_object_type()
-        elif type(value) == list:
-            if hasattr(value[0], "_object_type"):
-                datatype = value[0].get_object_type()
-            else:
-                datatype = type(value[0]).__name__
-            disc = 'list[' + datatype + ']'
-        elif type(value) == dict:
-            if hasattr(next(iter(value.values())), "_object_type"):
-                datatype = next(iter(value.values())).get_object_type()
-            else:
-                datatype = type(next(iter(value.values()))).__name__
-            disc = 'dict(str, ' + datatype + ')'
-        else:
-            disc = type(value).__name__
-        if disc in VolumeGroupRecoveryPointListApiResponsedata.discriminator_value_class_map.values():
-            return list(VolumeGroupRecoveryPointListApiResponsedata.discriminator_value_class_map.keys())[list(VolumeGroupRecoveryPointListApiResponsedata.discriminator_value_class_map.values()).index(disc)]
-        return None
+        A globally unique identifier that represents the tenant that owns this entity. The system automatically assigns it, and it and is immutable from an API consumer perspective (some use cases may cause this Id to change - For instance, a use case may require the transfer of ownership of the entity, but these cases are handled automatically on the server). 
 
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__tenant_id
+
+    @tenant_id.setter
+    def tenant_id(self, tenant_id):
+        if tenant_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', tenant_id):  # noqa: E501
+            raise ValueError(r"Invalid value for `tenant_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
+
+        self.__tenant_id = tenant_id
+
+    @property
+    def _reserved(self):
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
+        return self.__dollar_reserved
+
+    @property
+    def _object_type(self):
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__dollar_object_type
+
+    @property
+    def _unknown_fields(self):
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
+        return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(VolumeGroupRecoveryPointListApiResponsedata, dict):
+        if issubclass(TenantAwareModel, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +196,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, VolumeGroupRecoveryPointListApiResponsedata):
+        if not isinstance(other, TenantAwareModel):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/VolumeGroupRecoveryPointRestoreApiResponsedata.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/GetProtectedResourceApiResponsedata.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class VolumeGroupRecoveryPointRestoreApiResponsedata(object):
+class GetProtectedResourceApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,49 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'storage.v4.config.Task': 'storage.v4.config.Task',
-        'prism.v4.config.TaskReference': 'prism.v4.config.TaskReference',
+        'dataprotection.v4.config.ProtectedResource': 'dataprotection.v4.config.ProtectedResource',
         'dataprotection.v4.error.ErrorResponse': 'dataprotection.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfdataprotection.v4.config.VolumeGroupRecoveryPointRestoreApiResponsedata'
+        return 'OneOfdataprotection.v4.config.GetProtectedResourceApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -115,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in VolumeGroupRecoveryPointRestoreApiResponsedata.discriminator_value_class_map.values():
-            return list(VolumeGroupRecoveryPointRestoreApiResponsedata.discriminator_value_class_map.keys())[list(VolumeGroupRecoveryPointRestoreApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in GetProtectedResourceApiResponsedata.discriminator_value_class_map.values():
+            return list(GetProtectedResourceApiResponsedata.discriminator_value_class_map.keys())[list(GetProtectedResourceApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(VolumeGroupRecoveryPointRestoreApiResponsedata, dict):
+        if issubclass(GetProtectedResourceApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -170,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, VolumeGroupRecoveryPointRestoreApiResponsedata):
+        if not isinstance(other, GetProtectedResourceApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/WitnessApiResponsedata.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/EsxiVmOverrideSpec.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,161 +3,188 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class WitnessApiResponsedata(object):
+class EsxiVmOverrideSpec(object):
 
-    """
+    """Protected resource/recovery point restore that overrides the ESXi VM configuration. The specified properties will be overridden for the restored VM.
 
+    :param name: (:attr:`name`) The name of the restored VM
+    :type name: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
+        'name': 'str',
+        '_reserved': 'dict(str, object)',
+        '_object_type': 'str',
+        '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
+        'name': 'name',
+        '_reserved': '$reserved',
+        '_object_type': '$objectType',
+        '_unknown_fields': '$unknownFields',
     }
 
-    discriminator_value_class_map = {
-        'EMPTY_LIST': 'list[str]',
-        'EMPTY_MAP': 'dict(str, object)',
-        'dataprotection.v4.config.Witness': 'dataprotection.v4.config.Witness',
-        'dataprotection.v4.error.ErrorResponse': 'dataprotection.v4.error.ErrorResponse'
-    }
-
-    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
-    def __init__(self, *args, **kwargs):  # noqa: E501
+    def __init__(self, name=None, *args, **kwargs):  # noqa: E501
+        self.__name = None
         self.discriminator = None
+        if name is not None:
+            self.__name = name
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfdataprotection.v4.config.WitnessApiResponsedata'
+        return 'dataprotection.v4.config.EsxiVmOverrideSpec'
 
-    def _initialize_fq_object_type(self):
-        return ''
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
-    def get_real_child_model(self, discriminator):
-        """Returns the real base class specified by the discriminator"""
-        if discriminator is not None and discriminator in self.discriminator_value_class_map:
-            return self.discriminator_value_class_map.get(discriminator)
-        return None
-
-    @staticmethod
-    def get_discriminator_from_object(value):
-        """Returns the discriminator for the provided object.
+    @property
+    def name(self):
         """
-        if not value:
-            disc = 'list[str]'
-        elif hasattr(value, "_object_type"):
-            disc = value.get_object_type()
-        elif type(value) == list:
-            if hasattr(value[0], "_object_type"):
-                datatype = value[0].get_object_type()
-            else:
-                datatype = type(value[0]).__name__
-            disc = 'list[' + datatype + ']'
-        elif type(value) == dict:
-            if hasattr(next(iter(value.values())), "_object_type"):
-                datatype = next(iter(value.values())).get_object_type()
-            else:
-                datatype = type(next(iter(value.values()))).__name__
-            disc = 'dict(str, ' + datatype + ')'
-        else:
-            disc = type(value).__name__
-        if disc in WitnessApiResponsedata.discriminator_value_class_map.values():
-            return list(WitnessApiResponsedata.discriminator_value_class_map.keys())[list(WitnessApiResponsedata.discriminator_value_class_map.values()).index(disc)]
-        return None
+        The name of the restored VM
 
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__name
+
+    @name.setter
+    def name(self, name):
+        if name is not None and len(name) > 80:
+            raise ValueError("Invalid value for `name`, length must be less than or equal to `80`")  # noqa: E501
+
+        self.__name = name
+
+    @property
+    def _reserved(self):
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
+        return self.__dollar_reserved
+
+    @property
+    def _object_type(self):
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__dollar_object_type
+
+    @property
+    def _unknown_fields(self):
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
+        return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(WitnessApiResponsedata, dict):
+        if issubclass(EsxiVmOverrideSpec, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +196,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, WitnessApiResponsedata):
+        if not isinstance(other, EsxiVmOverrideSpec):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/error/ErrorResponseerror.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/AhvVmOverrideSpec.py`

 * *Files 13% similar despite different names*

```diff
@@ -3,161 +3,188 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class ErrorResponseerror(object):
+class AhvVmOverrideSpec(object):
 
-    """
+    """Protected resource/recovery point restore that overrides the AHV VM configuration. The specified properties will be overridden for the restored VM.
 
+    :param name: (:attr:`name`) The name of the restored VM
+    :type name: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
+        'name': 'str',
+        '_reserved': 'dict(str, object)',
+        '_object_type': 'str',
+        '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
+        'name': 'name',
+        '_reserved': '$reserved',
+        '_object_type': '$objectType',
+        '_unknown_fields': '$unknownFields',
     }
 
-    discriminator_value_class_map = {
-        'EMPTY_LIST': 'list[str]',
-        'EMPTY_MAP': 'dict(str, object)',
-        'List<dataprotection.v4.error.AppMessage>': 'list[dataprotection.v4.error.AppMessage]',
-        'dataprotection.v4.error.SchemaValidationError': 'dataprotection.v4.error.SchemaValidationError'
-    }
-
-    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$errorItemDiscriminator'
 
 
-    def __init__(self, *args, **kwargs):  # noqa: E501
+    def __init__(self, name=None, *args, **kwargs):  # noqa: E501
+        self.__name = None
         self.discriminator = None
+        if name is not None:
+            self.__name = name
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfdataprotection.v4.error.ErrorResponseerror'
+        return 'dataprotection.v4.config.AhvVmOverrideSpec'
 
-    def _initialize_fq_object_type(self):
-        return ''
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
-    def get_real_child_model(self, discriminator):
-        """Returns the real base class specified by the discriminator"""
-        if discriminator is not None and discriminator in self.discriminator_value_class_map:
-            return self.discriminator_value_class_map.get(discriminator)
-        return None
-
-    @staticmethod
-    def get_discriminator_from_object(value):
-        """Returns the discriminator for the provided object.
+    @property
+    def name(self):
         """
-        if not value:
-            disc = 'list[str]'
-        elif hasattr(value, "_object_type"):
-            disc = value.get_object_type()
-        elif type(value) == list:
-            if hasattr(value[0], "_object_type"):
-                datatype = value[0].get_object_type()
-            else:
-                datatype = type(value[0]).__name__
-            disc = 'list[' + datatype + ']'
-        elif type(value) == dict:
-            if hasattr(next(iter(value.values())), "_object_type"):
-                datatype = next(iter(value.values())).get_object_type()
-            else:
-                datatype = type(next(iter(value.values()))).__name__
-            disc = 'dict(str, ' + datatype + ')'
-        else:
-            disc = type(value).__name__
-        if disc in ErrorResponseerror.discriminator_value_class_map.values():
-            return list(ErrorResponseerror.discriminator_value_class_map.keys())[list(ErrorResponseerror.discriminator_value_class_map.values()).index(disc)]
-        return None
+        The name of the restored VM
 
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__name
+
+    @name.setter
+    def name(self, name):
+        if name is not None and len(name) > 80:
+            raise ValueError("Invalid value for `name`, length must be less than or equal to `80`")  # noqa: E501
+
+        self.__name = name
+
+    @property
+    def _reserved(self):
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
+        return self.__dollar_reserved
+
+    @property
+    def _object_type(self):
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__dollar_object_type
+
+    @property
+    def _unknown_fields(self):
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
+        return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ErrorResponseerror, dict):
+        if issubclass(AhvVmOverrideSpec, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +196,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ErrorResponseerror):
+        if not isinstance(other, AhvVmOverrideSpec):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/__init__.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -4,149 +4,124 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 from __future__ import absolute_import
 
 # import models into model package
 from ntnx_dataprotection_py_client.models.OneOfcommon.v1.config.KVPairvalue import KVPairvalue
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.ChangedRegionsListApiResponsedata import ChangedRegionsListApiResponsedata
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.ConsistencyGroupApiResponsedata import ConsistencyGroupApiResponsedata
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.ConsistencyGroupListApiResponsedata import ConsistencyGroupListApiResponsedata
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.ConsistencyGroupMigrateApiResponsedata import ConsistencyGroupMigrateApiResponsedata
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.CreateConsistencyGroupRecoveryPointApiResponsedata import CreateConsistencyGroupRecoveryPointApiResponsedata
+from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.ComputeChangedRegionsResponseModeldata import ComputeChangedRegionsResponseModeldata
+from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.ComputeChangedRegionsResponseresponse import ComputeChangedRegionsResponseresponse
+from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.CreateConsistencyGroupApiResponsedata import CreateConsistencyGroupApiResponsedata
 from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.CreateRecoveryPointApiResponsedata import CreateRecoveryPointApiResponsedata
 from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.DeleteConsistencyGroupApiResponsedata import DeleteConsistencyGroupApiResponsedata
 from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.DeleteRecoveryPointApiResponsedata import DeleteRecoveryPointApiResponsedata
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.DiskRecoveryPointApiResponsedata import DiskRecoveryPointApiResponsedata
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.DiskRecoveryPointListApiResponsedata import DiskRecoveryPointListApiResponsedata
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.ProtectedResourceApiResponsedata import ProtectedResourceApiResponsedata
+from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.GetProtectedResourceApiResponsedata import GetProtectedResourceApiResponsedata
+from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.GetRecoveryPointApiResponsedata import GetRecoveryPointApiResponsedata
+from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.ListRecoveryPointsApiResponsedata import ListRecoveryPointsApiResponsedata
+from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.MigrateConsistencyGroupApiResponsedata import MigrateConsistencyGroupApiResponsedata
 from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.ProtectedResourcePromoteApiResponsedata import ProtectedResourcePromoteApiResponsedata
 from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.ProtectedResourceRestoreApiResponsedata import ProtectedResourceRestoreApiResponsedata
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.RecoveryPointApiResponsedata import RecoveryPointApiResponsedata
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.RecoveryPointListApiResponsedata import RecoveryPointListApiResponsedata
+from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.ProtectedResourceRestoreSpecoverrides import ProtectedResourceRestoreSpecoverrides
 from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.RecoveryPointReplicateApiResponsedata import RecoveryPointReplicateApiResponsedata
+from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.RecoveryPointRepositoryProjectionobject_storage_reference import RecoveryPointRepositoryProjectionobject_storage_reference
+from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.RecoveryPointRepositoryobject_storage_reference import RecoveryPointRepositoryobject_storage_reference
 from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.RecoveryPointRestoreApiResponsedata import RecoveryPointRestoreApiResponsedata
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.SyncedVolumeGroupByIdApiResponsedata import SyncedVolumeGroupByIdApiResponsedata
 from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.SynchronousReplicaPromoteApiResponsedata import SynchronousReplicaPromoteApiResponsedata
+from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.UpdateConsistencyGroupApiResponsedata import UpdateConsistencyGroupApiResponsedata
 from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.UpdateRecoveryPointExpirationTimeApiResponsedata import UpdateRecoveryPointExpirationTimeApiResponsedata
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.VMRecoveryPointApiResponsedata import VMRecoveryPointApiResponsedata
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.VMRecoveryPointListApiResponsedata import VMRecoveryPointListApiResponsedata
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.ValidateRestoreVmRecoveryPointApiResponsedata import ValidateRestoreVmRecoveryPointApiResponsedata
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.VmRecoveryPointRestoreApiResponsedata import VmRecoveryPointRestoreApiResponsedata
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.VolumeGroupRecoveryPointApiResponsedata import VolumeGroupRecoveryPointApiResponsedata
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.VolumeGroupRecoveryPointListApiResponsedata import VolumeGroupRecoveryPointListApiResponsedata
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.VolumeGroupRecoveryPointRestoreApiResponsedata import VolumeGroupRecoveryPointRestoreApiResponsedata
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.WitnessApiResponsedata import WitnessApiResponsedata
 from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.error.ErrorResponseerror import ErrorResponseerror
 from ntnx_dataprotection_py_client.models.common.v1.config.Flag import Flag
 from ntnx_dataprotection_py_client.models.common.v1.config.IPv4Address import IPv4Address
 from ntnx_dataprotection_py_client.models.common.v1.config.KVPair import KVPair
 from ntnx_dataprotection_py_client.models.common.v1.config.Message import Message
 from ntnx_dataprotection_py_client.models.common.v1.config.MessageSeverity import MessageSeverity
 from ntnx_dataprotection_py_client.models.common.v1.config.TenantAwareModel import TenantAwareModel
 from ntnx_dataprotection_py_client.models.common.v1.response.ApiLink import ApiLink
 from ntnx_dataprotection_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata
 from ntnx_dataprotection_py_client.models.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel
 from ntnx_dataprotection_py_client.models.dataprotection.v4.common.BaseRecoveryPoint import BaseRecoveryPoint
 from ntnx_dataprotection_py_client.models.dataprotection.v4.common.RecoveryPointStatus import RecoveryPointStatus
 from ntnx_dataprotection_py_client.models.dataprotection.v4.common.RecoveryPointType import RecoveryPointType
-from ntnx_dataprotection_py_client.models.dataprotection.v4.common.VendorSpecificProperty import VendorSpecificProperty
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.AhvVmOverrideSpec import AhvVmOverrideSpec
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.AmazonS3Bucket import AmazonS3Bucket
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.AzureBlobStorageContainer import AzureBlobStorageContainer
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.Category import Category
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ChangedRegions import ChangedRegions
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ChangedRegionsListApiResponse import ChangedRegionsListApiResponse
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ClusterReference import ClusterReference
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ComputeChangedRegionsResponse import ComputeChangedRegionsResponse
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ComputeChangedRegionsResponseModel import ComputeChangedRegionsResponseModel
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ConsistencyGroup import ConsistencyGroup
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ConsistencyGroupApiResponse import ConsistencyGroupApiResponse
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ConsistencyGroupListApiResponse import ConsistencyGroupListApiResponse
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ConsistencyGroupMember import ConsistencyGroupMember
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ConsistencyGroupMemberType import ConsistencyGroupMemberType
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ConsistencyGroupMigrateApiResponse import ConsistencyGroupMigrateApiResponse
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ConsistencyGroupMigrationSpec import ConsistencyGroupMigrationSpec
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ConsistencyGroupProjection import ConsistencyGroupProjection
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ConsistencyGroupRecoveryPointSpec import ConsistencyGroupRecoveryPointSpec
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.CreateConsistencyGroupRecoveryPointApiResponse import CreateConsistencyGroupRecoveryPointApiResponse
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.CreateConsistencyGroupApiResponse import CreateConsistencyGroupApiResponse
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.CreateRecoveryPointApiResponse import CreateRecoveryPointApiResponse
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.DataProtectionInfo import DataProtectionInfo
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.DataProtectionSiteReference import DataProtectionSiteReference
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.DeleteConsistencyGroupApiResponse import DeleteConsistencyGroupApiResponse
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.DeleteRecoveryPointApiResponse import DeleteRecoveryPointApiResponse
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.DisasterRecoveryLocation import DisasterRecoveryLocation
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.Disk import Disk
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.DiskRecoveryPoint import DiskRecoveryPoint
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.DiskRecoveryPointApiResponse import DiskRecoveryPointApiResponse
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.DiskRecoveryPointListApiResponse import DiskRecoveryPointListApiResponse
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.EsxiVmOverrideSpec import EsxiVmOverrideSpec
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.HardwareArchitecture import HardwareArchitecture
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ExpirationTimeSpec import ExpirationTimeSpec
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.GetProtectedResourceApiResponse import GetProtectedResourceApiResponse
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.GetRecoveryPointApiResponse import GetRecoveryPointApiResponse
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.HostReference import HostReference
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.HostType import HostType
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.HypervisorType import HypervisorType
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.IpAddress import IpAddress
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ListRecoveryPointsApiResponse import ListRecoveryPointsApiResponse
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.LocationReference import LocationReference
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.PowerState import PowerState
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.MigrateConsistencyGroupApiResponse import MigrateConsistencyGroupApiResponse
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.NutanixObjectsBucket import NutanixObjectsBucket
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ObjectStorageType import ObjectStorageType
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ProtectedEntityType import ProtectedEntityType
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ProtectedResource import ProtectedResource
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ProtectedResourceApiResponse import ProtectedResourceApiResponse
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ProtectedResourceEntityType import ProtectedResourceEntityType
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ProtectedResourcePromoteApiResponse import ProtectedResourcePromoteApiResponse
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ProtectedResourceReplicationStatus import ProtectedResourceReplicationStatus
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ProtectedResourceRestoreApiResponse import ProtectedResourceRestoreApiResponse
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ProtectedResourceRestoreSpec import ProtectedResourceRestoreSpec
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.RecoveryInfo import RecoveryInfo
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.RecoveryPoint import RecoveryPoint
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.RecoveryPointApiResponse import RecoveryPointApiResponse
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.RecoveryPointListApiResponse import RecoveryPointListApiResponse
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.RecoveryPointProjection import RecoveryPointProjection
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.RecoveryPointReplicateApiResponse import RecoveryPointReplicateApiResponse
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.RecoveryPointReplicationSpec import RecoveryPointReplicationSpec
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.RecoveryPointRepository import RecoveryPointRepository
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.RecoveryPointRepositoryProjection import RecoveryPointRepositoryProjection
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.RecoveryPointRestorationSpec import RecoveryPointRestorationSpec
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.RecoveryPointRestoreApiResponse import RecoveryPointRestoreApiResponse
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.Regions import Regions
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.RedirectionResponse import RedirectionResponse
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.Region import Region
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.RegionResponse import RegionResponse
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.RegionType import RegionType
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ReplicationState import ReplicationState
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.RestorableTimeRange import RestorableTimeRange
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.SetExpirationTimeSpec import SetExpirationTimeSpec
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.SiteProtectionInfo import SiteProtectionInfo
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.SiteReference import SiteReference
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.Subnet import Subnet
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.SyncedVolumeGroupByIdApiResponse import SyncedVolumeGroupByIdApiResponse
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.SynchronousReplicaPromoteApiResponse import SynchronousReplicaPromoteApiResponse
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.UpdateConsistencyGroupApiResponse import UpdateConsistencyGroupApiResponse
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.UpdateRecoveryPointExpirationTimeApiResponse import UpdateRecoveryPointExpirationTimeApiResponse
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VMRecoveryPoint import VMRecoveryPoint
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VMRecoveryPointApiResponse import VMRecoveryPointApiResponse
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VMRecoveryPointListApiResponse import VMRecoveryPointListApiResponse
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ValidateRecoveryPointResult import ValidateRecoveryPointResult
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ValidateRestoreVmRecoveryPointApiResponse import ValidateRestoreVmRecoveryPointApiResponse
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ValidationSeverity import ValidationSeverity
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.Vm import Vm
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VmRecoveryPointRestorationSpec import VmRecoveryPointRestorationSpec
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VmRecoveryPointRestoreApiResponse import VmRecoveryPointRestoreApiResponse
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VmRecoveryPoint import VmRecoveryPoint
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VmRecoveryPointComputeChangedRegionsRequest import VmRecoveryPointComputeChangedRegionsRequest
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VmRecoveryPointRestoreOverride import VmRecoveryPointRestoreOverride
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VmSubRecoveryPoint import VmSubRecoveryPoint
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VmSubRecoveryPointProjection import VmSubRecoveryPointProjection
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VolumeGroup import VolumeGroup
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VolumeGroupOverrideSpec import VolumeGroupOverrideSpec
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VolumeGroupRecoveryPoint import VolumeGroupRecoveryPoint
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VolumeGroupRecoveryPointApiResponse import VolumeGroupRecoveryPointApiResponse
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VolumeGroupRecoveryPointListApiResponse import VolumeGroupRecoveryPointListApiResponse
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VolumeGroupRecoveryPointRestorationSpec import VolumeGroupRecoveryPointRestorationSpec
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VolumeGroupRecoveryPointRestoreApiResponse import VolumeGroupRecoveryPointRestoreApiResponse
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VolumeGroupRecoveryPointComputeChangedRegionsRequest import VolumeGroupRecoveryPointComputeChangedRegionsRequest
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VolumeGroupRecoveryPointRestoreOverride import VolumeGroupRecoveryPointRestoreOverride
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VolumeGroupSubRecoveryPoint import VolumeGroupSubRecoveryPoint
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VolumeGroupSubRecoveryPointProjection import VolumeGroupSubRecoveryPointProjection
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VolumeGroupSyncContext import VolumeGroupSyncContext
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VpcReference import VpcReference
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.Witness import Witness
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.WitnessApiResponse import WitnessApiResponse
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.WitnessAvailabilityStatus import WitnessAvailabilityStatus
 from ntnx_dataprotection_py_client.models.dataprotection.v4.error.AppMessage import AppMessage
 from ntnx_dataprotection_py_client.models.dataprotection.v4.error.ErrorResponse import ErrorResponse
 from ntnx_dataprotection_py_client.models.dataprotection.v4.error.SchemaValidationError import SchemaValidationError
 from ntnx_dataprotection_py_client.models.dataprotection.v4.error.SchemaValidationErrorMessage import SchemaValidationErrorMessage
 from ntnx_dataprotection_py_client.models.prism.v4.config.TaskReference import TaskReference
-from ntnx_dataprotection_py_client.models.storage.v4.config.Task import Task
 from ntnx_dataprotection_py_client.api_response import ApiResponse
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/common/v1/config/Flag.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/Subnet.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,140 +3,118 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
+from ntnx_dataprotection_py_client.models.common.v1.config.IPv4Address import IPv4Address  # noqa: F401,E501
 
-class Flag(object):
+class Subnet(object):
 
-    """Many entities in the Nutanix APIs carry flags.  This object captures all the flags associated with that entity through this object.  The field that hosts this type of object must have an attribute called x-bounded-map-keys that tells which flags are actually present for that entity. 
+    """CIDR of the network gateway.
 
-    :param name: (:attr:`name`) 
-    :type name: 
-    :param value: (:attr:`value`) 
-    :type value: 
+    :param ipv4: (:attr:`ipv4`) 
+    :type ipv4: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'name': 'str',
-        'value': 'bool',
+        'ipv4': 'common.v1.config.IPv4Address',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'name': 'name',
-        'value': 'value',
+        'ipv4': 'ipv4',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, name=None, value=False, *args, **kwargs):  # noqa: E501
-        self.__name = None
-        self.__value = None
+    def __init__(self, ipv4=None, *args, **kwargs):  # noqa: E501
+        self.__ipv4 = None
         self.discriminator = None
-        if name is not None:
-            self.__name = name
-        if value is not None:
-            self.__value = value
+        if ipv4 is not None:
+            self.__ipv4 = ipv4
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'common.v1.config.Flag'
+        return 'dataprotection.v4.config.Subnet'
 
-    def _initialize_fq_object_type(self):
-        return 'common.v1.r0.a3.config.Flag'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def name(self):
+    def ipv4(self):
         """
         
 
         :type:
-
-                :class:`~str`
-        """  # noqa: E501
-        return self.__name
-
-    @name.setter
-    def name(self, name):
-
-        self.__name = name
-
-    @property
-    def value(self):
-        """
-        
-
-        :type:
-
-                :class:`~bool`
+            :class:`~ntnx_dataprotection_py_client.models.common.v1.config.IPv4Address`
         """  # noqa: E501
-        return self.__value
+        return self.__ipv4
 
-    @value.setter
-    def value(self, value):
+    @ipv4.setter
+    def ipv4(self, ipv4):
 
-        self.__value = value
+        self.__ipv4 = ipv4
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -169,37 +147,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(Flag, dict):
+        if issubclass(Subnet, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -211,15 +194,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, Flag):
+        if not isinstance(other, Subnet):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/common/v1/config/IPv4Address.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/common/v1/config/IPv4Address.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
 class IPv4Address(object):
 
     """
 
     :param value: (:attr:`value`) 
     :type value: 
@@ -66,33 +67,33 @@
             self.__prefix_length = prefix_length
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'common.v1.config.IPv4Address'
 
-    def _initialize_fq_object_type(self):
-        return 'common.v1.r0.a3.config.IPv4Address'
+    def _initialize_object_version(self):
+        return 'v1.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -175,28 +176,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/common/v1/config/KVPair.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/AmazonS3Bucket.py`

 * *Files 9% similar despite different names*

```diff
@@ -3,145 +3,141 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_dataprotection_py_client.models
-from ntnx_dataprotection_py_client.models.OneOfcommon.v1.config.KVPairvalue import KVPairvalue  # noqa: F401,E501
+from pathlib import Path
 
-class KVPair(object):
+class AmazonS3Bucket(object):
 
-    """A map describing a set of keys and their corresponding values. 
+    """Reference to the Amazon S3 bucket.
 
-    :param name: (:attr:`name`) The key of this key-value pair
-    :type name: 
-    :param value: (:attr:`value`) The value associated with the key for this key-value pair
-    :type value: 
+    :param bucket_name: (:attr:`bucket_name`) Name of the Amazon S3 bucket.
+    :type bucket_name: 
+    :param region_name: (:attr:`region_name`) Name of the AWS region.
+    :type region_name: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'name': 'str',
-        'value': 'OneOfcommon.v1.config.KVPairvalue',
+        'bucket_name': 'str',
+        'region_name': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'name': 'name',
-        'value': 'value',
+        'bucket_name': 'bucketName',
+        'region_name': 'regionName',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, name=None, value=None, *args, **kwargs):  # noqa: E501
-        self.__name = None
-        self.__value = None
+    def __init__(self, bucket_name=None, region_name=None, *args, **kwargs):  # noqa: E501
+        self.__bucket_name = None
+        self.__region_name = None
         self.discriminator = None
-        if name is not None:
-            self.__name = name
-        if value is not None:
-            self.__value = value
+        if bucket_name is not None:
+            self.__bucket_name = bucket_name
+        if region_name is not None:
+            self.__region_name = region_name
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'common.v1.config.KVPair'
+        return 'dataprotection.v4.config.AmazonS3Bucket'
 
-    def _initialize_fq_object_type(self):
-        return 'common.v1.r0.a3.config.KVPair'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def name(self):
+    def bucket_name(self):
         """
-        The key of this key-value pair
+        Name of the Amazon S3 bucket.
 
         :type:
 
                 :class:`~str`
         """  # noqa: E501
-        return self.__name
+        return self.__bucket_name
 
-    @name.setter
-    def name(self, name):
+    @bucket_name.setter
+    def bucket_name(self, bucket_name):
 
-        self.__name = name
+        self.__bucket_name = bucket_name
 
     @property
-    def value(self):
+    def region_name(self):
         """
-        The value associated with the key for this key-value pair
+        Name of the AWS region.
 
         :type:
-                :class:`~str` | 
-                :class:`~int` | 
-                :class:`~bool` | 
-                :class:`~list[str]` | 
-                :class:`~dict(str, str)`
-                    """  # noqa: E501
-        return self.__value
 
-    @value.setter
-    def value(self, value):
+                :class:`~str`
+        """  # noqa: E501
+        return self.__region_name
+
+    @region_name.setter
+    def region_name(self, region_name):
 
-        self.__value = value
+        self.__region_name = region_name
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -174,39 +170,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
-            if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_dataprotection_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(KVPair, dict):
+        if issubclass(AmazonS3Bucket, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -218,15 +217,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, KVPair):
+        if not isinstance(other, AmazonS3Bucket):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/common/v1/config/Message.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/common/v1/config/Message.py`

 * *Files 3% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_dataprotection_py_client.models.common.v1.config.MessageSeverity import MessageSeverity  # noqa: F401,E501
 
 class Message(object):
 
     """
 
     :param code: (:attr:`code`) A code that uniquely identifies a message. 
@@ -81,33 +82,33 @@
             self.__severity = severity
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'common.v1.config.Message'
 
-    def _initialize_fq_object_type(self):
-        return 'common.v1.r0.a3.config.Message'
+    def _initialize_object_version(self):
+        return 'v1.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -215,28 +216,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/common/v1/config/MessageSeverity.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/common/v1/config/MessageSeverity.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,38 +3,42 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
 class MessageSeverity(object):
 
     """The message severity. 
 
 
     Allowed enum values:
 
         - _UNKNOWN
         - _REDACTED
-        - INFO
-        - WARNING
-        - ERROR
+        - INFO: Information about successful completion.
+
+        - WARNING: Warning indicating future error.
+
+        - ERROR: Error indicating failed completion.
+
     """
     _UNKNOWN = "$UNKNOWN"
     _REDACTED = "$REDACTED"
     INFO = "INFO"
     WARNING = "WARNING"
     ERROR = "ERROR"
 
@@ -43,33 +47,33 @@
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'common.v1.config.MessageSeverity'
 
-    def _initialize_fq_object_type(self):
-        return 'common.v1.r0.a3.config.MessageSeverity'
+    def _initialize_object_version(self):
+        return 'v1.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -84,27 +88,32 @@
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/common/v1/config/TenantAwareModel.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ListRecoveryPointsApiResponse.py`

 * *Files 12% similar despite different names*

```diff
@@ -3,119 +3,144 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-
-class TenantAwareModel(object):
-
-    """A model base class whose instances are bound to a specific tenant.  This model adds a tenantId to the base model class that it extends and is automatically set by the server. 
-
-    :param tenant_id: (:attr:`tenant_id`) A globally unique identifier that represents the tenant that owns this entity.  It is automatically assigned by the system and is immutable from an API consumer perspective (some use cases may cause this Id to change - for instance a use case may require the transfer of ownership of the entity, but these cases are handled automatically on the server). 
-    :type tenant_id: 
+from pathlib import Path
+import ntnx_dataprotection_py_client.models
+from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.ListRecoveryPointsApiResponsedata import ListRecoveryPointsApiResponsedata  # noqa: F401,E501
+from ntnx_dataprotection_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class ListRecoveryPointsApiResponse(object):
+
+    """REST response for all response codes in API path /dataprotection/v4.0.b1/config/recovery-points Get operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'tenant_id': 'str',
+        'metadata': 'common.v1.response.ApiResponseMetadata',
+        'data': 'OneOfdataprotection.v4.config.ListRecoveryPointsApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'tenant_id': 'tenantId',
+        'metadata': 'metadata',
+        'data': 'data',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, tenant_id=None, *args, **kwargs):  # noqa: E501
-        self.__tenant_id = None
+    def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
+        self.__metadata = None
+        self.__data = None
         self.discriminator = None
-        if tenant_id is not None:
-            self.__tenant_id = tenant_id
+        if metadata is not None:
+            self.__metadata = metadata
+        if data is not None:
+            self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'common.v1.config.TenantAwareModel'
+        return 'dataprotection.v4.config.ListRecoveryPointsApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'common.v1.r0.a3.config.TenantAwareModel'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def tenant_id(self):
+    def metadata(self):
         """
-        A globally unique identifier that represents the tenant that owns this entity.  It is automatically assigned by the system and is immutable from an API consumer perspective (some use cases may cause this Id to change - for instance a use case may require the transfer of ownership of the entity, but these cases are handled automatically on the server). 
+        
 
         :type:
-
-                :class:`~str`
+            :class:`~ntnx_dataprotection_py_client.models.common.v1.response.ApiResponseMetadata`
         """  # noqa: E501
-        return self.__tenant_id
+        return self.__metadata
+
+    @metadata.setter
+    def metadata(self, metadata):
+
+        self.__metadata = metadata
 
-    @tenant_id.setter
-    def tenant_id(self, tenant_id):
-        if tenant_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', tenant_id):  # noqa: E501
-            raise ValueError(r"Invalid value for `tenant_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
+    @property
+    def data(self):
+        """
+        
+
+        :type:
+                :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.RecoveryPoint` | 
+                :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.error.ErrorResponse` | 
+                :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.RecoveryPointProjection`
+                    """  # noqa: E501
+        return self.__data
+
+    @data.setter
+    def data(self, data):
 
-        self.__tenant_id = tenant_id
+        self.__data = data
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -148,37 +173,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
+            if attr_type.startswith('OneOf'):
+                type = getattr(ntnx_dataprotection_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(TenantAwareModel, dict):
+        if issubclass(ListRecoveryPointsApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -190,15 +222,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, TenantAwareModel):
+        if not isinstance(other, ListRecoveryPointsApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/common/v1/response/ApiLink.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/common/v1/response/ApiLink.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,29 +3,30 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
 class ApiLink(object):
 
-    """A HATEOAS style link for the response.  Each link contains a user friendly name identifying the link and an address for retrieving the particular resource. 
+    """A HATEOAS style link for the response.  Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource. 
 
     :param href: (:attr:`href`) The URL at which the entity described by the link can be accessed. 
     :type href: 
     :param rel: (:attr:`rel`) A name that identifies the relationship of the link to the object that is returned by the URL.  The unique value of \"self\" identifies the URL for the object. 
     :type rel: 
 
     """
@@ -66,33 +67,33 @@
             self.__rel = rel
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'common.v1.response.ApiLink'
 
-    def _initialize_fq_object_type(self):
-        return 'common.v1.r0.a3.response.ApiLink'
+    def _initialize_object_version(self):
+        return 'v1.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -169,28 +170,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/common/v1/response/ApiResponseMetadata.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/common/v1/response/ApiResponseMetadata.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,35 +3,36 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_dataprotection_py_client.models.common.v1.config.Flag import Flag  # noqa: F401,E501
 from ntnx_dataprotection_py_client.models.common.v1.config.KVPair import KVPair  # noqa: F401,E501
 from ntnx_dataprotection_py_client.models.common.v1.config.Message import Message  # noqa: F401,E501
 from ntnx_dataprotection_py_client.models.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
 
 class ApiResponseMetadata(object):
 
     """The metadata associated with an API response. This value is always present and minimally contains the self-link for the API request that produced this response. It also contains pagination data for the paginated requests. 
 
-    :param flags: (:attr:`flags`) An array of flags that may indicate the status of the response. For example a flag with name isPaginated and value false indicates that the response is not paginated. 
+    :param flags: (:attr:`flags`) An array of flags that may indicate the status of the response. For example, a flag with the name 'isPaginated' and value 'false', indicates that the response is not paginated. 
     :type flags: 
     :param links: (:attr:`links`) An array of HATEOAS style links for the response that may also include pagination links for list operations. 
     :type links: 
     :param total_available_results: (:attr:`total_available_results`) The total number of entities that are available on the server for this type. 
     :type total_available_results: 
     :param messages: (:attr:`messages`) Information, Warning or Error messages that might provide additional contextual information related to the operation. 
     :type messages: 
@@ -91,33 +92,33 @@
             self.__extra_info = extra_info
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'common.v1.response.ApiResponseMetadata'
 
-    def _initialize_fq_object_type(self):
-        return 'common.v1.r0.a3.response.ApiResponseMetadata'
+    def _initialize_object_version(self):
+        return 'v1.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -126,15 +127,15 @@
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def flags(self):
         """
-        An array of flags that may indicate the status of the response. For example a flag with name isPaginated and value false indicates that the response is not paginated. 
+        An array of flags that may indicate the status of the response. For example, a flag with the name 'isPaginated' and value 'false', indicates that the response is not paginated. 
 
         :type:
              list[ :class:`~ntnx_dataprotection_py_client.models.common.v1.config.Flag` ]
         """  # noqa: E501
         return self.__flags
 
     @flags.setter
@@ -238,28 +239,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/common/v1/response/ExternalizableAbstractModel.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/common/v1/response/ExternalizableAbstractModel.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,35 +3,36 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_dataprotection_py_client.models.common.v1.config.TenantAwareModel import TenantAwareModel  # noqa: F401,E501
 from ntnx_dataprotection_py_client.models.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
 
 class ExternalizableAbstractModel(TenantAwareModel):
 
-    """A model that represents an object instance that is accessible through an API endpoint.  Instances of this type get an extId field that contains the globally unique identifier for that instance.  Externally accessible instances are always tenant aware and therefore extend the TenantAwareModel 
+    """A model that represents an object instance that is accessible through an API endpoint.  Instances of this type get an extId field that contains the globally unique identifier for that instance.  Externally accessible instances are always tenant aware and, therefore, extend the TenantAwareModel 
 
     :param ext_id: (:attr:`ext_id`) A globally unique identifier of an instance that is suitable for external consumption. 
     :type ext_id: 
-    :param links: (:attr:`links`) A HATEOAS style link for the response.  Each link contains a user friendly name identifying the link and an address for retrieving the particular resource. 
+    :param links: (:attr:`links`) A HATEOAS style link for the response.  Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource. 
     :type links: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
@@ -69,16 +70,16 @@
             self.__ext_id = ext_id
         if links is not None:
             self.__links = links
 
     def _initialize_object_type(self):
         return 'common.v1.response.ExternalizableAbstractModel'
 
-    def _initialize_fq_object_type(self):
-        return 'common.v1.r0.a3.response.ExternalizableAbstractModel'
+    def _initialize_object_version(self):
+        return 'v1.r0.b1'
 
 
     @property
     def ext_id(self):
         """
         A globally unique identifier of an instance that is suitable for external consumption. 
 
@@ -94,15 +95,15 @@
             raise ValueError(r"Invalid value for `ext_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
 
         self.__ext_id = ext_id
 
     @property
     def links(self):
         """
-        A HATEOAS style link for the response.  Each link contains a user friendly name identifying the link and an address for retrieving the particular resource. 
+        A HATEOAS style link for the response.  Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource. 
 
         :type:
              list[ :class:`~ntnx_dataprotection_py_client.models.common.v1.response.ApiLink` ]
         """  # noqa: E501
         return self.__links
 
     @links.setter
@@ -114,28 +115,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/common/BaseRecoveryPoint.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/common/BaseRecoveryPoint.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,30 +3,30 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_dataprotection_py_client.models.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
 from ntnx_dataprotection_py_client.models.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel  # noqa: F401,E501
 from ntnx_dataprotection_py_client.models.dataprotection.v4.common.RecoveryPointStatus import RecoveryPointStatus  # noqa: F401,E501
 from ntnx_dataprotection_py_client.models.dataprotection.v4.common.RecoveryPointType import RecoveryPointType  # noqa: F401,E501
-from ntnx_dataprotection_py_client.models.dataprotection.v4.common.VendorSpecificProperty import VendorSpecificProperty  # noqa: F401,E501
 
 class BaseRecoveryPoint(ExternalizableAbstractModel):
 
     """A model that represents common properties of a Recovery point resources
 
     :param location_agnostic_id: (:attr:`location_agnostic_id`) Location agnostic identifier of the Recovery point.
     :type location_agnostic_id: 
@@ -36,16 +36,14 @@
     :type creation_time: 
     :param expiration_time: (:attr:`expiration_time`) The UTC date and time in ISO-8601 format when the current Recovery point expires and will be garbage collected.
     :type expiration_time: 
     :param status: (:attr:`status`) 
     :type status: 
     :param recovery_point_type: (:attr:`recovery_point_type`) 
     :type recovery_point_type: 
-    :param vendor_specific_properties: (:attr:`vendor_specific_properties`) List of additional metadata provided by the client at the time of Recovery point creation.
-    :type vendor_specific_properties: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
@@ -56,15 +54,14 @@
     swagger_types = {
         'location_agnostic_id': 'str',
         'name': 'str',
         'creation_time': 'datetime',
         'expiration_time': 'datetime',
         'status': 'dataprotection.v4.common.RecoveryPointStatus',
         'recovery_point_type': 'dataprotection.v4.common.RecoveryPointType',
-        'vendor_specific_properties': 'list[dataprotection.v4.common.VendorSpecificProperty]',
         'ext_id': 'str',
         'links': 'list[common.v1.response.ApiLink]',
         'tenant_id': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
@@ -72,55 +69,51 @@
     attribute_map = {
         'location_agnostic_id': 'locationAgnosticId',
         'name': 'name',
         'creation_time': 'creationTime',
         'expiration_time': 'expirationTime',
         'status': 'status',
         'recovery_point_type': 'recoveryPointType',
-        'vendor_specific_properties': 'vendorSpecificProperties',
         'ext_id': 'extId',
         'links': 'links',
         'tenant_id': 'tenantId',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, location_agnostic_id=None, name=None, creation_time=None, expiration_time=None, status=None, recovery_point_type=None, vendor_specific_properties=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
+    def __init__(self, location_agnostic_id=None, name=None, creation_time=None, expiration_time=None, status=None, recovery_point_type=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
         ExternalizableAbstractModel.__init__(self, ext_id, links, tenant_id, *args, **kwargs)
         self.__location_agnostic_id = None
         self.__name = None
         self.__creation_time = None
         self.__expiration_time = None
         self.__status = None
         self.__recovery_point_type = None
-        self.__vendor_specific_properties = None
         self.discriminator = None
         if location_agnostic_id is not None:
             self.__location_agnostic_id = location_agnostic_id
         if name is not None:
             self.__name = name
         if creation_time is not None:
             self.__creation_time = creation_time
         if expiration_time is not None:
             self.__expiration_time = expiration_time
         if status is not None:
             self.__status = status
         if recovery_point_type is not None:
             self.__recovery_point_type = recovery_point_type
-        if vendor_specific_properties is not None:
-            self.__vendor_specific_properties = vendor_specific_properties
 
     def _initialize_object_type(self):
         return 'dataprotection.v4.common.BaseRecoveryPoint'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a2.common.BaseRecoveryPoint'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     @property
     def location_agnostic_id(self):
         """
         Location agnostic identifier of the Recovery point.
 
@@ -213,51 +206,41 @@
         return self.__recovery_point_type
 
     @recovery_point_type.setter
     def recovery_point_type(self, recovery_point_type):
 
         self.__recovery_point_type = recovery_point_type
 
-    @property
-    def vendor_specific_properties(self):
-        """
-        List of additional metadata provided by the client at the time of Recovery point creation.
-
-        :type:
-             list[ :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.common.VendorSpecificProperty` ]
-        """  # noqa: E501
-        return self.__vendor_specific_properties
-
-    @vendor_specific_properties.setter
-    def vendor_specific_properties(self, vendor_specific_properties):
-
-        self.__vendor_specific_properties = vendor_specific_properties
-
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/common/RecoveryPointStatus.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/common/RecoveryPointStatus.py`

 * *Files 9% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
 class RecoveryPointStatus(object):
 
     """The status of the Recovery point, which indicates whether this Recovery point is fit to be consumed.
 
 
     Allowed enum values:
@@ -43,33 +44,33 @@
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'dataprotection.v4.common.RecoveryPointStatus'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a2.common.RecoveryPointStatus'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -84,27 +85,32 @@
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/common/RecoveryPointType.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/common/RecoveryPointType.py`

 * *Files 11% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
 class RecoveryPointType(object):
 
     """Type of the Recovery point.
 
 
     Allowed enum values:
@@ -41,33 +42,33 @@
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'dataprotection.v4.common.RecoveryPointType'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a2.common.RecoveryPointType'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -82,27 +83,32 @@
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/common/VendorSpecificProperty.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/CreateRecoveryPointApiResponse.py`

 * *Files 11% similar despite different names*

```diff
@@ -3,142 +3,143 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-
-class VendorSpecificProperty(object):
-
-    """Additional metadata provided by the client at the time of Recovery point creation.
-
-    :param vendor_id: (:attr:`vendor_id`) The unique identifier of the vendor. It can be a magic number, UUID or vendor name.
-    :type vendor_id: required
-    :param vendor_metadata: (:attr:`vendor_metadata`) This is an opaque data interpreted only by the respective vendor.
-    :type vendor_metadata: required
+from pathlib import Path
+import ntnx_dataprotection_py_client.models
+from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.CreateRecoveryPointApiResponsedata import CreateRecoveryPointApiResponsedata  # noqa: F401,E501
+from ntnx_dataprotection_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class CreateRecoveryPointApiResponse(object):
+
+    """REST response for all response codes in API path /dataprotection/v4.0.b1/config/recovery-points Post operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'vendor_id': 'str',
-        'vendor_metadata': 'str',
+        'metadata': 'common.v1.response.ApiResponseMetadata',
+        'data': 'OneOfdataprotection.v4.config.CreateRecoveryPointApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'vendor_id': 'vendorId',
-        'vendor_metadata': 'vendorMetadata',
+        'metadata': 'metadata',
+        'data': 'data',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, vendor_id=None, vendor_metadata=None, *args, **kwargs):  # noqa: E501
-        self.__vendor_id = None
-        self.__vendor_metadata = None
+    def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
+        self.__metadata = None
+        self.__data = None
         self.discriminator = None
-        self.__vendor_id = vendor_id
-        self.__vendor_metadata = vendor_metadata
+        if metadata is not None:
+            self.__metadata = metadata
+        if data is not None:
+            self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'dataprotection.v4.common.VendorSpecificProperty'
+        return 'dataprotection.v4.config.CreateRecoveryPointApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a2.common.VendorSpecificProperty'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def vendor_id(self):
+    def metadata(self):
         """
-        The unique identifier of the vendor. It can be a magic number, UUID or vendor name.
+        
 
         :type:
-
-                :class:`~str`
+            :class:`~ntnx_dataprotection_py_client.models.common.v1.response.ApiResponseMetadata`
         """  # noqa: E501
-        return self.__vendor_id
+        return self.__metadata
 
-    @vendor_id.setter
-    def vendor_id(self, vendor_id):
-        if vendor_id is None:
-            raise ValueError("Invalid value for `vendor_id`, must not be `None`")  # noqa: E501
+    @metadata.setter
+    def metadata(self, metadata):
 
-        self.__vendor_id = vendor_id
+        self.__metadata = metadata
 
     @property
-    def vendor_metadata(self):
+    def data(self):
         """
-        This is an opaque data interpreted only by the respective vendor.
+        
 
         :type:
+                :class:`~ntnx_dataprotection_py_client.models.prism.v4.config.TaskReference` | 
+                :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.error.ErrorResponse`
+                    """  # noqa: E501
+        return self.__data
 
-                :class:`~str`
-        """  # noqa: E501
-        return self.__vendor_metadata
-
-    @vendor_metadata.setter
-    def vendor_metadata(self, vendor_metadata):
-        if vendor_metadata is None:
-            raise ValueError("Invalid value for `vendor_metadata`, must not be `None`")  # noqa: E501
+    @data.setter
+    def data(self, data):
 
-        self.__vendor_metadata = vendor_metadata
+        self.__data = data
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -171,37 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
+            if attr_type.startswith('OneOf'):
+                type = getattr(ntnx_dataprotection_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(VendorSpecificProperty, dict):
+        if issubclass(CreateRecoveryPointApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -213,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, VendorSpecificProperty):
+        if not isinstance(other, CreateRecoveryPointApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/AhvVmOverrideSpec.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/VolumeGroupOverrideSpec.py`

 * *Files 12% similar despite different names*

```diff
@@ -3,31 +3,32 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class AhvVmOverrideSpec(object):
+class VolumeGroupOverrideSpec(object):
 
-    """Recovery point restore that overrides the AHV VM configuration. The specified properties will be overridden for the restored VM.
+    """Protected resource/recovery point restore that overrides the volume group configuration. The specified properties will be overridden for the restored volume group.
 
-    :param name: (:attr:`name`) The name of the restored VM
+    :param name: (:attr:`name`) The name of the restored volume group.
     :type name: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
@@ -57,35 +58,35 @@
         self.discriminator = None
         if name is not None:
             self.__name = name
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'dataprotection.v4.config.AhvVmOverrideSpec'
+        return 'dataprotection.v4.config.VolumeGroupOverrideSpec'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.AhvVmOverrideSpec'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -94,15 +95,15 @@
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def name(self):
         """
-        The name of the restored VM
+        The name of the restored volume group.
 
         :type:
 
                 :class:`~str`
         """  # noqa: E501
         return self.__name
 
@@ -148,37 +149,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(AhvVmOverrideSpec, dict):
+        if issubclass(VolumeGroupOverrideSpec, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -190,15 +196,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, AhvVmOverrideSpec):
+        if not isinstance(other, VolumeGroupOverrideSpec):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/Category.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/Category.py`

 * *Files 12% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
 class Category(object):
 
     """Specifies category in key and value object format.
 
     :param key: (:attr:`key`) Name of the category key.
     :type key: required
@@ -64,33 +65,33 @@
         self.__value = value
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'dataprotection.v4.config.Category'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.Category'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -171,28 +172,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ChangedRegions.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/RegionResponse.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,48 +3,49 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.Regions import Regions  # noqa: F401,E501
+from pathlib import Path
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.Region import Region  # noqa: F401,E501
 
-class ChangedRegions(object):
+class RegionResponse(object):
 
-    """Changed Regions tracking
+    """
 
-    :param regions: (:attr:`regions`) Changed Regions list comprising of offset and regions length pertaining to the Disk Recovery Point.
+    :param regions: (:attr:`regions`) 
     :type regions: 
-    :param next_offset: (:attr:`next_offset`) The offset from where the client must continue the request. This field will not be set when there are no more changed regions to be returned. Note that the nextOffset can be outside the endOffset specified by the client in the request. This helps clients reach the next changed offset faster.
+    :param next_offset: (:attr:`next_offset`) The offset from where the client must continue the request. This field is not set when there are no more changed regions to be returned. Note: the nextOffset can be outside the endOffset specified by the client in the request. This helps clients reach the next changed offset faster.
     :type next_offset: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'regions': 'list[dataprotection.v4.config.Regions]',
+        'regions': 'list[dataprotection.v4.config.Region]',
         'next_offset': 'int',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
@@ -65,35 +66,35 @@
             self.__regions = regions
         if next_offset is not None:
             self.__next_offset = next_offset
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'dataprotection.v4.config.ChangedRegions'
+        return 'dataprotection.v4.config.RegionResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.ChangedRegions'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -102,30 +103,30 @@
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def regions(self):
         """
-        Changed Regions list comprising of offset and regions length pertaining to the Disk Recovery Point.
+        
 
         :type:
-             list[ :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.Regions` ]
+             list[ :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.Region` ]
         """  # noqa: E501
         return self.__regions
 
     @regions.setter
     def regions(self, regions):
 
         self.__regions = regions
 
     @property
     def next_offset(self):
         """
-        The offset from where the client must continue the request. This field will not be set when there are no more changed regions to be returned. Note that the nextOffset can be outside the endOffset specified by the client in the request. This helps clients reach the next changed offset faster.
+        The offset from where the client must continue the request. This field is not set when there are no more changed regions to be returned. Note: the nextOffset can be outside the endOffset specified by the client in the request. This helps clients reach the next changed offset faster.
 
         :type:
 
                 :class:`~int`
         """  # noqa: E501
         return self.__next_offset
 
@@ -169,37 +170,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ChangedRegions, dict):
+        if issubclass(RegionResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -211,15 +217,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ChangedRegions):
+        if not isinstance(other, RegionResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ChangedRegionsListApiResponse.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/MigrateConsistencyGroupApiResponse.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_dataprotection_py_client.models
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.ChangedRegionsListApiResponsedata import ChangedRegionsListApiResponsedata  # noqa: F401,E501
+from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.MigrateConsistencyGroupApiResponsedata import MigrateConsistencyGroupApiResponsedata  # noqa: F401,E501
 from ntnx_dataprotection_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class ChangedRegionsListApiResponse(object):
+class MigrateConsistencyGroupApiResponse(object):
 
-    """REST response for all response codes in API path /dataprotection/v4.0.a4/config/recovery-points/{recoveryPointExtId}/vm-recovery-points/{vmRecoveryPointExtId}/disk-recovery-points/{diskRecoveryPointExtId}/changed-regions Get operation
+    """REST response for all response codes in API path /dataprotection/v4.0.b1/config/consistency-groups/{extId}/$actions/migrate Post operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfdataprotection.v4.config.ChangedRegionsListApiResponsedata',
+        'data': 'OneOfdataprotection.v4.config.MigrateConsistencyGroupApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'dataprotection.v4.config.ChangedRegionsListApiResponse'
+        return 'dataprotection.v4.config.MigrateConsistencyGroupApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.ChangedRegionsListApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -122,15 +123,15 @@
 
     @property
     def data(self):
         """
         
 
         :type:
-                :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.ChangedRegions` | 
+                :class:`~ntnx_dataprotection_py_client.models.prism.v4.config.TaskReference` | 
                 :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.error.ErrorResponse`
                     """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
@@ -171,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_dataprotection_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ChangedRegionsListApiResponse, dict):
+        if issubclass(MigrateConsistencyGroupApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ChangedRegionsListApiResponse):
+        if not isinstance(other, MigrateConsistencyGroupApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ClusterReference.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ClusterReference.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
 class ClusterReference(object):
 
     """The UUID corresponding to the cluster where an entity resides or is synced.
 
     :param ext_id: (:attr:`ext_id`) External identifier of the cluster.
     :type ext_id: required
@@ -65,33 +66,33 @@
             self.__name = name
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'dataprotection.v4.config.ClusterReference'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.ClusterReference'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -172,28 +173,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ConsistencyGroup.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ConsistencyGroupProjection.py`

 * *Files 14% similar despite different names*

```diff
@@ -3,39 +3,49 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_dataprotection_py_client.models.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
-from ntnx_dataprotection_py_client.models.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel  # noqa: F401,E501
+from pathlib import Path
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ConsistencyGroup import ConsistencyGroup  # noqa: F401,E501
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ConsistencyGroupMember import ConsistencyGroupMember  # noqa: F401,E501
 
-class ConsistencyGroup(ExternalizableAbstractModel):
+class ConsistencyGroupProjection(ConsistencyGroup):
 
-    """There are many scenarios where the state of an application must be captured as an aggregate of the internal state of a set of related entities at some point in time. The Consistency group is a collection of all the entities whose snapshot represents the application state at that point in time
+    """
 
     :param name: (:attr:`name`) Name of the Consistency group.
     :type name: required
     :param owner_ext_id: (:attr:`owner_ext_id`) The external identifier of the user who created this Consistency group. This is a read-only field that is inserted into the Consistency group entity at the time of Consistency group creation.
     :type owner_ext_id: 
     :param members: (:attr:`members`) 
-    :type members: 
+    :type members: required
+    :param cluster_ext_id: (:attr:`cluster_ext_id`) The external identifier of the cluster to which the entities from the Consistency group are associated.
+    :type cluster_ext_id: 
+    :param protection_policy_ext_id: (:attr:`protection_policy_ext_id`) The external identifier of the Protection policy that protects the Consistency group.
+    :type protection_policy_ext_id: 
+    :param ext_id: (:attr:`ext_id`) A globally unique identifier of an instance that is suitable for external consumption. 
+    :type ext_id: 
+    :param links: (:attr:`links`) A HATEOAS style link for the response.  Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource. 
+    :type links: 
+    :param tenant_id: (:attr:`tenant_id`) A globally unique identifier that represents the tenant that owns this entity. The system automatically assigns it, and it and is immutable from an API consumer perspective (some use cases may cause this Id to change - For instance, a use case may require the transfer of ownership of the entity, but these cases are handled automatically on the server). 
+    :type tenant_id: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
@@ -43,139 +53,87 @@
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'name': 'str',
         'owner_ext_id': 'str',
         'members': 'list[dataprotection.v4.config.ConsistencyGroupMember]',
+        'cluster_ext_id': 'str',
+        'protection_policy_ext_id': 'str',
         'ext_id': 'str',
         'links': 'list[common.v1.response.ApiLink]',
         'tenant_id': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'name': 'name',
         'owner_ext_id': 'ownerExtId',
         'members': 'members',
+        'cluster_ext_id': 'clusterExtId',
+        'protection_policy_ext_id': 'protectionPolicyExtId',
         'ext_id': 'extId',
         'links': 'links',
         'tenant_id': 'tenantId',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, name=None, owner_ext_id=None, members=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
-        ExternalizableAbstractModel.__init__(self, ext_id, links, tenant_id, *args, **kwargs)
-        self.__name = None
-        self.__owner_ext_id = None
-        self.__members = None
+    def __init__(self, name=None, owner_ext_id=None, members=None, cluster_ext_id=None, protection_policy_ext_id=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
+        ConsistencyGroup.__init__(self, name, owner_ext_id, members, cluster_ext_id, protection_policy_ext_id, ext_id, links, tenant_id, *args, **kwargs)
         self.discriminator = None
-        self.__name = name
-        if owner_ext_id is not None:
-            self.__owner_ext_id = owner_ext_id
-        if members is not None:
-            self.__members = members
 
     def _initialize_object_type(self):
-        return 'dataprotection.v4.config.ConsistencyGroup'
-
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.ConsistencyGroup'
-
-
-    @property
-    def name(self):
-        """
-        Name of the Consistency group.
-
-        :type:
-
-                :class:`~str`
-        """  # noqa: E501
-        return self.__name
-
-    @name.setter
-    def name(self, name):
-        if name is None:
-            raise ValueError("Invalid value for `name`, must not be `None`")  # noqa: E501
-        if name is not None and len(name) > 256:
-            raise ValueError("Invalid value for `name`, length must be less than or equal to `256`")  # noqa: E501
-
-        self.__name = name
-
-    @property
-    def owner_ext_id(self):
-        """
-        The external identifier of the user who created this Consistency group. This is a read-only field that is inserted into the Consistency group entity at the time of Consistency group creation.
+        return 'dataprotection.v4.config.ConsistencyGroupProjection'
 
-        :type:
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
-                :class:`~str`
-        """  # noqa: E501
-        return self.__owner_ext_id
-
-    @owner_ext_id.setter
-    def owner_ext_id(self, owner_ext_id):
-        if owner_ext_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', owner_ext_id):  # noqa: E501
-            raise ValueError(r"Invalid value for `owner_ext_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
-
-        self.__owner_ext_id = owner_ext_id
-
-    @property
-    def members(self):
-        """
-        
-
-        :type:
-             list[ :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.ConsistencyGroupMember` ]
-        """  # noqa: E501
-        return self.__members
-
-    @members.setter
-    def members(self, members):
-
-        self.__members = members
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ConsistencyGroup, dict):
+        if issubclass(ConsistencyGroupProjection, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -187,15 +145,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ConsistencyGroup):
+        if not isinstance(other, ConsistencyGroupProjection):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ConsistencyGroupApiResponse.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/CreateConsistencyGroupApiResponse.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_dataprotection_py_client.models
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.ConsistencyGroupApiResponsedata import ConsistencyGroupApiResponsedata  # noqa: F401,E501
+from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.CreateConsistencyGroupApiResponsedata import CreateConsistencyGroupApiResponsedata  # noqa: F401,E501
 from ntnx_dataprotection_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class ConsistencyGroupApiResponse(object):
+class CreateConsistencyGroupApiResponse(object):
 
-    """REST response for all response codes in API path /dataprotection/v4.0.a4/config/consistency-groups/{extId} Put operation
+    """REST response for all response codes in API path /dataprotection/v4.0.b1/config/consistency-groups Post operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfdataprotection.v4.config.ConsistencyGroupApiResponsedata',
+        'data': 'OneOfdataprotection.v4.config.CreateConsistencyGroupApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'dataprotection.v4.config.ConsistencyGroupApiResponse'
+        return 'dataprotection.v4.config.CreateConsistencyGroupApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.ConsistencyGroupApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -171,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_dataprotection_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ConsistencyGroupApiResponse, dict):
+        if issubclass(CreateConsistencyGroupApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ConsistencyGroupApiResponse):
+        if not isinstance(other, CreateConsistencyGroupApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ConsistencyGroupListApiResponse.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ProtectedResourceRestoreApiResponse.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_dataprotection_py_client.models
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.ConsistencyGroupListApiResponsedata import ConsistencyGroupListApiResponsedata  # noqa: F401,E501
+from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.ProtectedResourceRestoreApiResponsedata import ProtectedResourceRestoreApiResponsedata  # noqa: F401,E501
 from ntnx_dataprotection_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class ConsistencyGroupListApiResponse(object):
+class ProtectedResourceRestoreApiResponse(object):
 
-    """REST response for all response codes in API path /dataprotection/v4.0.a4/config/consistency-groups Get operation
+    """REST response for all response codes in API path /dataprotection/v4.0.b1/config/protected-resources/{extId}/$actions/restore Post operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfdataprotection.v4.config.ConsistencyGroupListApiResponsedata',
+        'data': 'OneOfdataprotection.v4.config.ProtectedResourceRestoreApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'dataprotection.v4.config.ConsistencyGroupListApiResponse'
+        return 'dataprotection.v4.config.ProtectedResourceRestoreApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.ConsistencyGroupListApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -122,17 +123,16 @@
 
     @property
     def data(self):
         """
         
 
         :type:
-                :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.ConsistencyGroup` | 
-                :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.error.ErrorResponse` | 
-                :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.ConsistencyGroupProjection`
+                :class:`~ntnx_dataprotection_py_client.models.prism.v4.config.TaskReference` | 
+                :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.error.ErrorResponse`
                     """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
         self.__data = data
@@ -172,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_dataprotection_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ConsistencyGroupListApiResponse, dict):
+        if issubclass(ProtectedResourceRestoreApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -216,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ConsistencyGroupListApiResponse):
+        if not isinstance(other, ProtectedResourceRestoreApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ConsistencyGroupMember.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ConsistencyGroupMember.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,151 +3,127 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ConsistencyGroupMemberType import ConsistencyGroupMemberType  # noqa: F401,E501
 
 class ConsistencyGroupMember(object):
 
     """External identifier of the members (VM or volume group) of the Consistency group object.
 
-    :param ext_id: (:attr:`ext_id`) External identifier of the members (VM or volume group) of the Consistency group object.
-    :type ext_id: 
-    :param entity_id: (:attr:`entity_id`) External identifier of the members (VM or volume group) of the Consistency group object.
-    :type entity_id: 
+    :param entity_ext_id: (:attr:`entity_ext_id`) External identifier of the members (VM or volume group) of the Consistency group object.
+    :type entity_ext_id: 
     :param entity_type: (:attr:`entity_type`) 
     :type entity_type: required
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'ext_id': 'str',
-        'entity_id': 'str',
+        'entity_ext_id': 'str',
         'entity_type': 'dataprotection.v4.config.ConsistencyGroupMemberType',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'ext_id': 'extId',
-        'entity_id': 'entityId',
+        'entity_ext_id': 'entityExtId',
         'entity_type': 'entityType',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, ext_id=None, entity_id=None, entity_type=None, *args, **kwargs):  # noqa: E501
-        self.__ext_id = None
-        self.__entity_id = None
+    def __init__(self, entity_ext_id=None, entity_type=None, *args, **kwargs):  # noqa: E501
+        self.__entity_ext_id = None
         self.__entity_type = None
         self.discriminator = None
-        if ext_id is not None:
-            self.__ext_id = ext_id
-        if entity_id is not None:
-            self.__entity_id = entity_id
+        if entity_ext_id is not None:
+            self.__entity_ext_id = entity_ext_id
         self.__entity_type = entity_type
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'dataprotection.v4.config.ConsistencyGroupMember'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.ConsistencyGroupMember'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def ext_id(self):
+    def entity_ext_id(self):
         """
         External identifier of the members (VM or volume group) of the Consistency group object.
 
         :type:
 
                 :class:`~str`
         """  # noqa: E501
-        return self.__ext_id
+        return self.__entity_ext_id
 
-    @ext_id.setter
-    def ext_id(self, ext_id):
-        if ext_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', ext_id):  # noqa: E501
-            raise ValueError(r"Invalid value for `ext_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
+    @entity_ext_id.setter
+    def entity_ext_id(self, entity_ext_id):
+        if entity_ext_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', entity_ext_id):  # noqa: E501
+            raise ValueError(r"Invalid value for `entity_ext_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
 
-        self.__ext_id = ext_id
-
-    @property
-    def entity_id(self):
-        """
-        External identifier of the members (VM or volume group) of the Consistency group object.
-
-        :type:
-
-                :class:`~str`
-        """  # noqa: E501
-        return self.__entity_id
-
-    @entity_id.setter
-    def entity_id(self, entity_id):
-        if entity_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', entity_id):  # noqa: E501
-            raise ValueError(r"Invalid value for `entity_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
-
-        self.__entity_id = entity_id
+        self.__entity_ext_id = entity_ext_id
 
     @property
     def entity_type(self):
         """
         
 
         :type:
@@ -197,28 +173,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ConsistencyGroupMemberType.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ConsistencyGroupMemberType.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
 class ConsistencyGroupMemberType(object):
 
     """Consistency group member type
 
 
     Allowed enum values:
@@ -41,33 +42,33 @@
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'dataprotection.v4.config.ConsistencyGroupMemberType'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.ConsistencyGroupMemberType'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -82,27 +83,32 @@
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ConsistencyGroupMigrateApiResponse.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/RecoveryPointRestoreApiResponse.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_dataprotection_py_client.models
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.ConsistencyGroupMigrateApiResponsedata import ConsistencyGroupMigrateApiResponsedata  # noqa: F401,E501
+from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.RecoveryPointRestoreApiResponsedata import RecoveryPointRestoreApiResponsedata  # noqa: F401,E501
 from ntnx_dataprotection_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class ConsistencyGroupMigrateApiResponse(object):
+class RecoveryPointRestoreApiResponse(object):
 
-    """REST response for all response codes in API path /dataprotection/v4.0.a4/config/consistency-groups/{extId}/$actions/migrate Post operation
+    """REST response for all response codes in API path /dataprotection/v4.0.b1/config/recovery-points/{extId}/$actions/restore Post operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfdataprotection.v4.config.ConsistencyGroupMigrateApiResponsedata',
+        'data': 'OneOfdataprotection.v4.config.RecoveryPointRestoreApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'dataprotection.v4.config.ConsistencyGroupMigrateApiResponse'
+        return 'dataprotection.v4.config.RecoveryPointRestoreApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.ConsistencyGroupMigrateApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -122,15 +123,14 @@
 
     @property
     def data(self):
         """
         
 
         :type:
-                :class:`~ntnx_dataprotection_py_client.models.storage.v4.config.Task` | 
                 :class:`~ntnx_dataprotection_py_client.models.prism.v4.config.TaskReference` | 
                 :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.error.ErrorResponse`
                     """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
@@ -172,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_dataprotection_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ConsistencyGroupMigrateApiResponse, dict):
+        if issubclass(RecoveryPointRestoreApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -216,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ConsistencyGroupMigrateApiResponse):
+        if not isinstance(other, RecoveryPointRestoreApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ConsistencyGroupMigrationSpec.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/SiteReference.py`

 * *Files 15% similar despite different names*

```diff
@@ -3,145 +3,145 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class ConsistencyGroupMigrationSpec(object):
+class SiteReference(object):
 
-    """Specification for the migrate action on the Consistency group.
+    """Specification corresponding to the cluster reference information along with the related AZ information.
 
-    :param target_availability_zone_id: (:attr:`target_availability_zone_id`) Reference to the target Availability Zone where the entities need to be migrated.
-    :type target_availability_zone_id: required
-    :param target_cluster_id: (:attr:`target_cluster_id`) Reference to the cluster in the target Availability Zone where the entities need to be migrated.
-    :type target_cluster_id: 
+    :param availability_zone_reference: (:attr:`availability_zone_reference`) The UUID corresponding to the Availability Zone where an entity resides or is synced.
+    :type availability_zone_reference: 
+    :param cluster_reference: (:attr:`cluster_reference`) The UUID corresponding to the cluster where an entity resides or is synced.
+    :type cluster_reference: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'target_availability_zone_id': 'str',
-        'target_cluster_id': 'str',
+        'availability_zone_reference': 'str',
+        'cluster_reference': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'target_availability_zone_id': 'targetAvailabilityZoneId',
-        'target_cluster_id': 'targetClusterId',
+        'availability_zone_reference': 'availabilityZoneReference',
+        'cluster_reference': 'clusterReference',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, target_availability_zone_id=None, target_cluster_id=None, *args, **kwargs):  # noqa: E501
-        self.__target_availability_zone_id = None
-        self.__target_cluster_id = None
+    def __init__(self, availability_zone_reference=None, cluster_reference=None, *args, **kwargs):  # noqa: E501
+        self.__availability_zone_reference = None
+        self.__cluster_reference = None
         self.discriminator = None
-        self.__target_availability_zone_id = target_availability_zone_id
-        if target_cluster_id is not None:
-            self.__target_cluster_id = target_cluster_id
+        if availability_zone_reference is not None:
+            self.__availability_zone_reference = availability_zone_reference
+        if cluster_reference is not None:
+            self.__cluster_reference = cluster_reference
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'dataprotection.v4.config.ConsistencyGroupMigrationSpec'
+        return 'dataprotection.v4.config.SiteReference'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.ConsistencyGroupMigrationSpec'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def target_availability_zone_id(self):
+    def availability_zone_reference(self):
         """
-        Reference to the target Availability Zone where the entities need to be migrated.
+        The UUID corresponding to the Availability Zone where an entity resides or is synced.
 
         :type:
 
                 :class:`~str`
         """  # noqa: E501
-        return self.__target_availability_zone_id
+        return self.__availability_zone_reference
 
-    @target_availability_zone_id.setter
-    def target_availability_zone_id(self, target_availability_zone_id):
-        if target_availability_zone_id is None:
-            raise ValueError("Invalid value for `target_availability_zone_id`, must not be `None`")  # noqa: E501
-        if target_availability_zone_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', target_availability_zone_id):  # noqa: E501
-            raise ValueError(r"Invalid value for `target_availability_zone_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
+    @availability_zone_reference.setter
+    def availability_zone_reference(self, availability_zone_reference):
+        if availability_zone_reference is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', availability_zone_reference):  # noqa: E501
+            raise ValueError(r"Invalid value for `availability_zone_reference`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
 
-        self.__target_availability_zone_id = target_availability_zone_id
+        self.__availability_zone_reference = availability_zone_reference
 
     @property
-    def target_cluster_id(self):
+    def cluster_reference(self):
         """
-        Reference to the cluster in the target Availability Zone where the entities need to be migrated.
+        The UUID corresponding to the cluster where an entity resides or is synced.
 
         :type:
 
                 :class:`~str`
         """  # noqa: E501
-        return self.__target_cluster_id
+        return self.__cluster_reference
 
-    @target_cluster_id.setter
-    def target_cluster_id(self, target_cluster_id):
-        if target_cluster_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', target_cluster_id):  # noqa: E501
-            raise ValueError(r"Invalid value for `target_cluster_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
+    @cluster_reference.setter
+    def cluster_reference(self, cluster_reference):
+        if cluster_reference is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', cluster_reference):  # noqa: E501
+            raise ValueError(r"Invalid value for `cluster_reference`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
 
-        self.__target_cluster_id = target_cluster_id
+        self.__cluster_reference = cluster_reference
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -174,37 +174,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ConsistencyGroupMigrationSpec, dict):
+        if issubclass(SiteReference, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -216,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ConsistencyGroupMigrationSpec):
+        if not isinstance(other, SiteReference):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ConsistencyGroupProjection.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/RecoveryPointRepositoryProjection.py`

 * *Files 25% similar despite different names*

```diff
@@ -3,123 +3,133 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ConsistencyGroup import ConsistencyGroup  # noqa: F401,E501
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ConsistencyGroupMember import ConsistencyGroupMember  # noqa: F401,E501
+from pathlib import Path
+import ntnx_dataprotection_py_client.models
+from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.RecoveryPointRepositoryProjectionobject_storage_reference import RecoveryPointRepositoryProjectionobject_storage_reference  # noqa: F401,E501
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ObjectStorageType import ObjectStorageType  # noqa: F401,E501
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.RecoveryPointRepository import RecoveryPointRepository  # noqa: F401,E501
 
-class ConsistencyGroupProjection(ConsistencyGroup):
+class RecoveryPointRepositoryProjection(RecoveryPointRepository):
 
     """
 
-    :param name: (:attr:`name`) Name of the Consistency group.
-    :type name: required
-    :param owner_ext_id: (:attr:`owner_ext_id`) The external identifier of the user who created this Consistency group. This is a read-only field that is inserted into the Consistency group entity at the time of Consistency group creation.
-    :type owner_ext_id: 
-    :param members: (:attr:`members`) 
-    :type members: 
+    :param name: (:attr:`name`) Name of the recovery point repository.
+    :type name: 
+    :param object_storage_type: (:attr:`object_storage_type`) 
+    :type object_storage_type: 
+    :param object_storage_reference: (:attr:`object_storage_reference`) 
+    :type object_storage_reference: 
     :param ext_id: (:attr:`ext_id`) A globally unique identifier of an instance that is suitable for external consumption. 
     :type ext_id: 
-    :param links: (:attr:`links`) A HATEOAS style link for the response.  Each link contains a user friendly name identifying the link and an address for retrieving the particular resource. 
+    :param links: (:attr:`links`) A HATEOAS style link for the response.  Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource. 
     :type links: 
-    :param tenant_id: (:attr:`tenant_id`) A globally unique identifier that represents the tenant that owns this entity.  It is automatically assigned by the system and is immutable from an API consumer perspective (some use cases may cause this Id to change - for instance a use case may require the transfer of ownership of the entity, but these cases are handled automatically on the server). 
+    :param tenant_id: (:attr:`tenant_id`) A globally unique identifier that represents the tenant that owns this entity. The system automatically assigns it, and it and is immutable from an API consumer perspective (some use cases may cause this Id to change - For instance, a use case may require the transfer of ownership of the entity, but these cases are handled automatically on the server). 
     :type tenant_id: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'name': 'str',
-        'owner_ext_id': 'str',
-        'members': 'list[dataprotection.v4.config.ConsistencyGroupMember]',
+        'object_storage_type': 'dataprotection.v4.config.ObjectStorageType',
+        'object_storage_reference': 'OneOfdataprotection.v4.config.RecoveryPointRepositoryobject_storage_reference',
         'ext_id': 'str',
         'links': 'list[common.v1.response.ApiLink]',
         'tenant_id': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'name': 'name',
-        'owner_ext_id': 'ownerExtId',
-        'members': 'members',
+        'object_storage_type': 'objectStorageType',
+        'object_storage_reference': 'objectStorageReference',
         'ext_id': 'extId',
         'links': 'links',
         'tenant_id': 'tenantId',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, name=None, owner_ext_id=None, members=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
-        ConsistencyGroup.__init__(self, name, owner_ext_id, members, ext_id, links, tenant_id, *args, **kwargs)
+    def __init__(self, name=None, object_storage_type=None, object_storage_reference=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
+        RecoveryPointRepository.__init__(self, name, object_storage_type, object_storage_reference, ext_id, links, tenant_id, *args, **kwargs)
         self.discriminator = None
 
     def _initialize_object_type(self):
-        return 'dataprotection.v4.config.ConsistencyGroupProjection'
+        return 'dataprotection.v4.config.RecoveryPointRepositoryProjection'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.ConsistencyGroupProjection'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
+            if attr_type.startswith('OneOf'):
+                type = getattr(ntnx_dataprotection_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ConsistencyGroupProjection, dict):
+        if issubclass(RecoveryPointRepositoryProjection, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -131,15 +141,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ConsistencyGroupProjection):
+        if not isinstance(other, RecoveryPointRepositoryProjection):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ConsistencyGroupRecoveryPointSpec.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ProtectedResourcePromoteApiResponse.py`

 * *Files 14% similar despite different names*

```diff
@@ -3,143 +3,143 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_dataprotection_py_client.models.dataprotection.v4.common.RecoveryPointType import RecoveryPointType  # noqa: F401,E501
-
-class ConsistencyGroupRecoveryPointSpec(object):
-
-    """Specification for Create Consistency group Recovery point
-
-    :param name: (:attr:`name`) Name of the Consistency group Recovery point.
-    :type name: required
-    :param recovery_point_type: (:attr:`recovery_point_type`) 
-    :type recovery_point_type: 
+from pathlib import Path
+import ntnx_dataprotection_py_client.models
+from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.ProtectedResourcePromoteApiResponsedata import ProtectedResourcePromoteApiResponsedata  # noqa: F401,E501
+from ntnx_dataprotection_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class ProtectedResourcePromoteApiResponse(object):
+
+    """REST response for all response codes in API path /dataprotection/v4.0.b1/config/protected-resources/{extId}/$actions/promote Post operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'name': 'str',
-        'recovery_point_type': 'dataprotection.v4.common.RecoveryPointType',
+        'metadata': 'common.v1.response.ApiResponseMetadata',
+        'data': 'OneOfdataprotection.v4.config.ProtectedResourcePromoteApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'name': 'name',
-        'recovery_point_type': 'recoveryPointType',
+        'metadata': 'metadata',
+        'data': 'data',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, name=None, recovery_point_type=None, *args, **kwargs):  # noqa: E501
-        self.__name = None
-        self.__recovery_point_type = None
+    def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
+        self.__metadata = None
+        self.__data = None
         self.discriminator = None
-        self.__name = name
-        if recovery_point_type is not None:
-            self.__recovery_point_type = recovery_point_type
+        if metadata is not None:
+            self.__metadata = metadata
+        if data is not None:
+            self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'dataprotection.v4.config.ConsistencyGroupRecoveryPointSpec'
+        return 'dataprotection.v4.config.ProtectedResourcePromoteApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.ConsistencyGroupRecoveryPointSpec'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def name(self):
+    def metadata(self):
         """
-        Name of the Consistency group Recovery point.
+        
 
         :type:
-
-                :class:`~str`
+            :class:`~ntnx_dataprotection_py_client.models.common.v1.response.ApiResponseMetadata`
         """  # noqa: E501
-        return self.__name
+        return self.__metadata
 
-    @name.setter
-    def name(self, name):
-        if name is None:
-            raise ValueError("Invalid value for `name`, must not be `None`")  # noqa: E501
-        if name is not None and len(name) > 256:
-            raise ValueError("Invalid value for `name`, length must be less than or equal to `256`")  # noqa: E501
+    @metadata.setter
+    def metadata(self, metadata):
 
-        self.__name = name
+        self.__metadata = metadata
 
     @property
-    def recovery_point_type(self):
+    def data(self):
         """
         
 
         :type:
-            :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.common.RecoveryPointType`
-        """  # noqa: E501
-        return self.__recovery_point_type
+                :class:`~ntnx_dataprotection_py_client.models.prism.v4.config.TaskReference` | 
+                :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.error.ErrorResponse`
+                    """  # noqa: E501
+        return self.__data
 
-    @recovery_point_type.setter
-    def recovery_point_type(self, recovery_point_type):
+    @data.setter
+    def data(self, data):
 
-        self.__recovery_point_type = recovery_point_type
+        self.__data = data
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -172,37 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
+            if attr_type.startswith('OneOf'):
+                type = getattr(ntnx_dataprotection_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ConsistencyGroupRecoveryPointSpec, dict):
+        if issubclass(ProtectedResourcePromoteApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -214,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ConsistencyGroupRecoveryPointSpec):
+        if not isinstance(other, ProtectedResourcePromoteApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/CreateConsistencyGroupRecoveryPointApiResponse.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/RecoveryPointReplicateApiResponse.py`

 * *Files 9% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_dataprotection_py_client.models
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.CreateConsistencyGroupRecoveryPointApiResponsedata import CreateConsistencyGroupRecoveryPointApiResponsedata  # noqa: F401,E501
+from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.RecoveryPointReplicateApiResponsedata import RecoveryPointReplicateApiResponsedata  # noqa: F401,E501
 from ntnx_dataprotection_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class CreateConsistencyGroupRecoveryPointApiResponse(object):
+class RecoveryPointReplicateApiResponse(object):
 
-    """REST response for all response codes in API path /dataprotection/v4.0.a4/config/consistency-groups/{extId}/$actions/create-recovery-point Post operation
+    """REST response for all response codes in API path /dataprotection/v4.0.b1/config/recovery-points/{extId}/$actions/replicate Post operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfdataprotection.v4.config.CreateConsistencyGroupRecoveryPointApiResponsedata',
+        'data': 'OneOfdataprotection.v4.config.RecoveryPointReplicateApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'dataprotection.v4.config.CreateConsistencyGroupRecoveryPointApiResponse'
+        return 'dataprotection.v4.config.RecoveryPointReplicateApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.CreateConsistencyGroupRecoveryPointApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -123,15 +124,14 @@
     @property
     def data(self):
         """
         
 
         :type:
                 :class:`~ntnx_dataprotection_py_client.models.prism.v4.config.TaskReference` | 
-                :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.RecoveryPoint` | 
                 :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.error.ErrorResponse`
                     """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
@@ -172,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_dataprotection_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(CreateConsistencyGroupRecoveryPointApiResponse, dict):
+        if issubclass(RecoveryPointReplicateApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -216,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, CreateConsistencyGroupRecoveryPointApiResponse):
+        if not isinstance(other, RecoveryPointReplicateApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/CreateRecoveryPointApiResponse.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/UpdateRecoveryPointExpirationTimeApiResponse.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_dataprotection_py_client.models
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.CreateRecoveryPointApiResponsedata import CreateRecoveryPointApiResponsedata  # noqa: F401,E501
+from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.UpdateRecoveryPointExpirationTimeApiResponsedata import UpdateRecoveryPointExpirationTimeApiResponsedata  # noqa: F401,E501
 from ntnx_dataprotection_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class CreateRecoveryPointApiResponse(object):
+class UpdateRecoveryPointExpirationTimeApiResponse(object):
 
-    """REST response for all response codes in API path /dataprotection/v4.0.a4/config/recovery-points Post operation
+    """REST response for all response codes in API path /dataprotection/v4.0.b1/config/recovery-points/{extId}/$actions/set-expiration-time Post operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfdataprotection.v4.config.CreateRecoveryPointApiResponsedata',
+        'data': 'OneOfdataprotection.v4.config.UpdateRecoveryPointExpirationTimeApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'dataprotection.v4.config.CreateRecoveryPointApiResponse'
+        return 'dataprotection.v4.config.UpdateRecoveryPointExpirationTimeApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.CreateRecoveryPointApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -123,15 +124,14 @@
     @property
     def data(self):
         """
         
 
         :type:
                 :class:`~ntnx_dataprotection_py_client.models.prism.v4.config.TaskReference` | 
-                :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.RecoveryPoint` | 
                 :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.error.ErrorResponse`
                     """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
@@ -172,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_dataprotection_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(CreateRecoveryPointApiResponse, dict):
+        if issubclass(UpdateRecoveryPointExpirationTimeApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -216,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, CreateRecoveryPointApiResponse):
+        if not isinstance(other, UpdateRecoveryPointExpirationTimeApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/DataProtectionInfo.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/SiteProtectionInfo.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,31 +3,32 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.DataProtectionSiteReference import DataProtectionSiteReference  # noqa: F401,E501
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.RecoveryInfo import RecoveryInfo  # noqa: F401,E501
 
-class DataProtectionInfo(object):
+class SiteProtectionInfo(object):
 
-    """The data protection details for the protected resource that are relevant to the specified cluster, like the time ranges available for recovery on the given cluster.
+    """The data protection details for the Protected resource that are relevant to the specified local or remote site, like the time ranges available for recovery on the given site.
 
     :param recovery_info: (:attr:`recovery_info`) 
     :type recovery_info: 
     :param location_reference: (:attr:`location_reference`) 
     :type location_reference: 
 
     """
@@ -66,35 +67,35 @@
             self.__recovery_info = recovery_info
         if location_reference is not None:
             self.__location_reference = location_reference
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'dataprotection.v4.config.DataProtectionInfo'
+        return 'dataprotection.v4.config.SiteProtectionInfo'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.DataProtectionInfo'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -169,37 +170,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(DataProtectionInfo, dict):
+        if issubclass(SiteProtectionInfo, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -211,15 +217,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, DataProtectionInfo):
+        if not isinstance(other, SiteProtectionInfo):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/DataProtectionSiteReference.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/RecoveryPointReplicationSpec.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,29 +3,30 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class DataProtectionSiteReference(object):
+class RecoveryPointReplicationSpec(object):
 
-    """
+    """External identifier of the cluster and the Prism Central where the recovery point should be replicated.
 
     :param pc_ext_id: (:attr:`pc_ext_id`) External identifier of the Prism Central.
     :type pc_ext_id: 
     :param cluster_ext_id: (:attr:`cluster_ext_id`) External identifier of the cluster.
     :type cluster_ext_id: 
 
     """
@@ -64,35 +65,35 @@
             self.__pc_ext_id = pc_ext_id
         if cluster_ext_id is not None:
             self.__cluster_ext_id = cluster_ext_id
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'dataprotection.v4.config.DataProtectionSiteReference'
+        return 'dataprotection.v4.config.RecoveryPointReplicationSpec'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.DataProtectionSiteReference'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -173,37 +174,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(DataProtectionSiteReference, dict):
+        if issubclass(RecoveryPointReplicationSpec, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, DataProtectionSiteReference):
+        if not isinstance(other, RecoveryPointReplicationSpec):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/DeleteConsistencyGroupApiResponse.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/DeleteConsistencyGroupApiResponse.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_dataprotection_py_client.models
 from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.DeleteConsistencyGroupApiResponsedata import DeleteConsistencyGroupApiResponsedata  # noqa: F401,E501
 from ntnx_dataprotection_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
 class DeleteConsistencyGroupApiResponse(object):
 
-    """REST response for all response codes in API path /dataprotection/v4.0.a4/config/consistency-groups/{extId} Delete operation
+    """REST response for all response codes in API path /dataprotection/v4.0.b1/config/consistency-groups/{extId} Delete operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -69,33 +70,33 @@
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'dataprotection.v4.config.DeleteConsistencyGroupApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.DeleteConsistencyGroupApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -170,30 +171,35 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_dataprotection_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/DeleteRecoveryPointApiResponse.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ComputeChangedRegionsResponseModel.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_dataprotection_py_client.models
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.DeleteRecoveryPointApiResponsedata import DeleteRecoveryPointApiResponsedata  # noqa: F401,E501
+from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.ComputeChangedRegionsResponseModeldata import ComputeChangedRegionsResponseModeldata  # noqa: F401,E501
 from ntnx_dataprotection_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class DeleteRecoveryPointApiResponse(object):
+class ComputeChangedRegionsResponseModel(object):
 
-    """REST response for all response codes in API path /dataprotection/v4.0.a4/config/recovery-points/{extId} Delete operation
+    """REST response for all response codes in API path /dataprotection/v4.0.b1/config/recovery-points/{recoveryPointExtId}/volume-group-recovery-points/{volumeGroupRecoveryPointExtId}/disk-recovery-points/{extId}/$actions/compute-changed-regions Post operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfdataprotection.v4.config.DeleteRecoveryPointApiResponsedata',
+        'data': 'OneOfdataprotection.v4.config.ComputeChangedRegionsResponseModeldata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'dataprotection.v4.config.DeleteRecoveryPointApiResponse'
+        return 'dataprotection.v4.config.ComputeChangedRegionsResponseModel'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.DeleteRecoveryPointApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -122,16 +123,15 @@
 
     @property
     def data(self):
         """
         
 
         :type:
-                :class:`~ntnx_dataprotection_py_client.models.storage.v4.config.Task` | 
-                :class:`~ntnx_dataprotection_py_client.models.prism.v4.config.TaskReference` | 
+                :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.ComputeChangedRegionsResponse` | 
                 :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.error.ErrorResponse`
                     """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
@@ -172,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_dataprotection_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(DeleteRecoveryPointApiResponse, dict):
+        if issubclass(ComputeChangedRegionsResponseModel, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -216,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, DeleteRecoveryPointApiResponse):
+        if not isinstance(other, ComputeChangedRegionsResponseModel):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/DisasterRecoveryLocation.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/DisasterRecoveryLocation.py`

 * *Files 3% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ClusterReference import ClusterReference  # noqa: F401,E501
 
 class DisasterRecoveryLocation(object):
 
     """
 
     :param pc_ext_id: (:attr:`pc_ext_id`) External identifier of the Prism Central.
@@ -66,33 +67,33 @@
             self.__cluster_references = cluster_references
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'dataprotection.v4.config.DisasterRecoveryLocation'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.DisasterRecoveryLocation'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -172,28 +173,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/Disk.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/DiskRecoveryPoint.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,142 +3,145 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class Disk(object):
+class DiskRecoveryPoint(object):
 
-    """The configuration of the Disk captured by the Recovery point.
+    """A model that represents the disk recovery point properties.
 
-    :param disk_ext_id: (:attr:`disk_ext_id`) Disk external identifier which is captured as part of this Recovery point.
+    :param disk_recovery_point_ext_id: (:attr:`disk_recovery_point_ext_id`) Disk recovery point Identifier.
+    :type disk_recovery_point_ext_id: 
+    :param disk_ext_id: (:attr:`disk_ext_id`) Disk external identifier which is captured as part of this recovery point.
     :type disk_ext_id: 
-    :param capacity_bytes: (:attr:`capacity_bytes`) Capacity of the virtual disk in bytes.
-    :type capacity_bytes: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
+        'disk_recovery_point_ext_id': 'str',
         'disk_ext_id': 'str',
-        'capacity_bytes': 'int',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
+        'disk_recovery_point_ext_id': 'diskRecoveryPointExtId',
         'disk_ext_id': 'diskExtId',
-        'capacity_bytes': 'capacityBytes',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, disk_ext_id=None, capacity_bytes=None, *args, **kwargs):  # noqa: E501
+    def __init__(self, disk_recovery_point_ext_id=None, disk_ext_id=None, *args, **kwargs):  # noqa: E501
+        self.__disk_recovery_point_ext_id = None
         self.__disk_ext_id = None
-        self.__capacity_bytes = None
         self.discriminator = None
+        if disk_recovery_point_ext_id is not None:
+            self.__disk_recovery_point_ext_id = disk_recovery_point_ext_id
         if disk_ext_id is not None:
             self.__disk_ext_id = disk_ext_id
-        if capacity_bytes is not None:
-            self.__capacity_bytes = capacity_bytes
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'dataprotection.v4.config.Disk'
+        return 'dataprotection.v4.config.DiskRecoveryPoint'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.Disk'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def disk_ext_id(self):
+    def disk_recovery_point_ext_id(self):
         """
-        Disk external identifier which is captured as part of this Recovery point.
+        Disk recovery point Identifier.
 
         :type:
 
                 :class:`~str`
         """  # noqa: E501
-        return self.__disk_ext_id
+        return self.__disk_recovery_point_ext_id
 
-    @disk_ext_id.setter
-    def disk_ext_id(self, disk_ext_id):
-        if disk_ext_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', disk_ext_id):  # noqa: E501
-            raise ValueError(r"Invalid value for `disk_ext_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
+    @disk_recovery_point_ext_id.setter
+    def disk_recovery_point_ext_id(self, disk_recovery_point_ext_id):
+        if disk_recovery_point_ext_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', disk_recovery_point_ext_id):  # noqa: E501
+            raise ValueError(r"Invalid value for `disk_recovery_point_ext_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
 
-        self.__disk_ext_id = disk_ext_id
+        self.__disk_recovery_point_ext_id = disk_recovery_point_ext_id
 
     @property
-    def capacity_bytes(self):
+    def disk_ext_id(self):
         """
-        Capacity of the virtual disk in bytes.
+        Disk external identifier which is captured as part of this recovery point.
 
         :type:
 
-                :class:`~int`
+                :class:`~str`
         """  # noqa: E501
-        return self.__capacity_bytes
+        return self.__disk_ext_id
 
-    @capacity_bytes.setter
-    def capacity_bytes(self, capacity_bytes):
+    @disk_ext_id.setter
+    def disk_ext_id(self, disk_ext_id):
+        if disk_ext_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', disk_ext_id):  # noqa: E501
+            raise ValueError(r"Invalid value for `disk_ext_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
 
-        self.__capacity_bytes = capacity_bytes
+        self.__disk_ext_id = disk_ext_id
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -171,37 +174,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(Disk, dict):
+        if issubclass(DiskRecoveryPoint, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -213,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, Disk):
+        if not isinstance(other, DiskRecoveryPoint):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/DiskRecoveryPoint.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/HostReference.py`

 * *Files 15% similar despite different names*

```diff
@@ -3,144 +3,159 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_dataprotection_py_client.models.dataprotection.v4.common.BaseRecoveryPoint import BaseRecoveryPoint  # noqa: F401,E501
-from ntnx_dataprotection_py_client.models.dataprotection.v4.common.RecoveryPointStatus import RecoveryPointStatus  # noqa: F401,E501
-from ntnx_dataprotection_py_client.models.dataprotection.v4.common.RecoveryPointType import RecoveryPointType  # noqa: F401,E501
-from ntnx_dataprotection_py_client.models.dataprotection.v4.common.VendorSpecificProperty import VendorSpecificProperty  # noqa: F401,E501
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.Disk import Disk  # noqa: F401,E501
-
-class DiskRecoveryPoint(BaseRecoveryPoint):
-
-    """A model that represents the disk Recovery point properties.
-
-    :param disk: (:attr:`disk`) 
-    :type disk: 
+from pathlib import Path
+from ntnx_dataprotection_py_client.models.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
+from ntnx_dataprotection_py_client.models.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel  # noqa: F401,E501
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.HostType import HostType  # noqa: F401,E501
+
+class HostReference(ExternalizableAbstractModel):
+
+    """Information about the Witness host site.
+
+    :param host_type: (:attr:`host_type`) 
+    :type host_type: 
+    :param name: (:attr:`name`) Name of the Witness host site.
+    :type name: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'disk': 'dataprotection.v4.config.Disk',
-        'location_agnostic_id': 'str',
+        'host_type': 'dataprotection.v4.config.HostType',
         'name': 'str',
-        'creation_time': 'datetime',
-        'expiration_time': 'datetime',
-        'status': 'dataprotection.v4.common.RecoveryPointStatus',
-        'recovery_point_type': 'dataprotection.v4.common.RecoveryPointType',
-        'vendor_specific_properties': 'list[dataprotection.v4.common.VendorSpecificProperty]',
         'ext_id': 'str',
         'links': 'list[common.v1.response.ApiLink]',
         'tenant_id': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'disk': 'disk',
-        'location_agnostic_id': 'locationAgnosticId',
+        'host_type': 'hostType',
         'name': 'name',
-        'creation_time': 'creationTime',
-        'expiration_time': 'expirationTime',
-        'status': 'status',
-        'recovery_point_type': 'recoveryPointType',
-        'vendor_specific_properties': 'vendorSpecificProperties',
         'ext_id': 'extId',
         'links': 'links',
         'tenant_id': 'tenantId',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, disk=None, location_agnostic_id=None, name=None, creation_time=None, expiration_time=None, status=None, recovery_point_type=None, vendor_specific_properties=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
-        BaseRecoveryPoint.__init__(self, location_agnostic_id, name, creation_time, expiration_time, status, recovery_point_type, vendor_specific_properties, ext_id, links, tenant_id, *args, **kwargs)
-        self.__disk = None
+    def __init__(self, host_type=None, name=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
+        ExternalizableAbstractModel.__init__(self, ext_id, links, tenant_id, *args, **kwargs)
+        self.__host_type = None
+        self.__name = None
         self.discriminator = None
-        if disk is not None:
-            self.__disk = disk
+        if host_type is not None:
+            self.__host_type = host_type
+        if name is not None:
+            self.__name = name
 
     def _initialize_object_type(self):
-        return 'dataprotection.v4.config.DiskRecoveryPoint'
+        return 'dataprotection.v4.config.HostReference'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.DiskRecoveryPoint'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     @property
-    def disk(self):
+    def host_type(self):
         """
         
 
         :type:
-            :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.Disk`
+            :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.HostType`
+        """  # noqa: E501
+        return self.__host_type
+
+    @host_type.setter
+    def host_type(self, host_type):
+
+        self.__host_type = host_type
+
+    @property
+    def name(self):
+        """
+        Name of the Witness host site.
+
+        :type:
+
+                :class:`~str`
         """  # noqa: E501
-        return self.__disk
+        return self.__name
 
-    @disk.setter
-    def disk(self, disk):
+    @name.setter
+    def name(self, name):
+        if name is not None and len(name) > 256:
+            raise ValueError("Invalid value for `name`, length must be less than or equal to `256`")  # noqa: E501
 
-        self.__disk = disk
+        self.__name = name
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(DiskRecoveryPoint, dict):
+        if issubclass(HostReference, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -152,15 +167,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, DiskRecoveryPoint):
+        if not isinstance(other, HostReference):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/DiskRecoveryPointApiResponse.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/GetProtectedResourceApiResponse.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_dataprotection_py_client.models
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.DiskRecoveryPointApiResponsedata import DiskRecoveryPointApiResponsedata  # noqa: F401,E501
+from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.GetProtectedResourceApiResponsedata import GetProtectedResourceApiResponsedata  # noqa: F401,E501
 from ntnx_dataprotection_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class DiskRecoveryPointApiResponse(object):
+class GetProtectedResourceApiResponse(object):
 
-    """REST response for all response codes in API path /dataprotection/v4.0.a4/config/recovery-points/{recoveryPointExtId}/volume-group-recovery-points/{volumeGroupRecoveryPointExtId}/disk-recovery-points/{diskRecoveryPointExtId} Get operation
+    """REST response for all response codes in API path /dataprotection/v4.0.b1/config/protected-resources/{extId} Get operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfdataprotection.v4.config.DiskRecoveryPointApiResponsedata',
+        'data': 'OneOfdataprotection.v4.config.GetProtectedResourceApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'dataprotection.v4.config.DiskRecoveryPointApiResponse'
+        return 'dataprotection.v4.config.GetProtectedResourceApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.DiskRecoveryPointApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -122,15 +123,15 @@
 
     @property
     def data(self):
         """
         
 
         :type:
-                :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.DiskRecoveryPoint` | 
+                :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.ProtectedResource` | 
                 :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.error.ErrorResponse`
                     """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
@@ -171,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_dataprotection_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(DiskRecoveryPointApiResponse, dict):
+        if issubclass(GetProtectedResourceApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, DiskRecoveryPointApiResponse):
+        if not isinstance(other, GetProtectedResourceApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/DiskRecoveryPointListApiResponse.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/SynchronousReplicaPromoteApiResponse.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_dataprotection_py_client.models
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.DiskRecoveryPointListApiResponsedata import DiskRecoveryPointListApiResponsedata  # noqa: F401,E501
+from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.SynchronousReplicaPromoteApiResponsedata import SynchronousReplicaPromoteApiResponsedata  # noqa: F401,E501
 from ntnx_dataprotection_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class DiskRecoveryPointListApiResponse(object):
+class SynchronousReplicaPromoteApiResponse(object):
 
-    """REST response for all response codes in API path /dataprotection/v4.0.a4/config/recovery-points/{recoveryPointExtId}/volume-group-recovery-points/{volumeGroupRecoveryPointExtId}/disk-recovery-points Get operation
+    """REST response for all response codes in API path /dataprotection/v4.0.b1/config/synced-volume-groups/{extId}/$actions/promote Post operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfdataprotection.v4.config.DiskRecoveryPointListApiResponsedata',
+        'data': 'OneOfdataprotection.v4.config.SynchronousReplicaPromoteApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'dataprotection.v4.config.DiskRecoveryPointListApiResponse'
+        return 'dataprotection.v4.config.SynchronousReplicaPromoteApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.DiskRecoveryPointListApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -122,15 +123,15 @@
 
     @property
     def data(self):
         """
         
 
         :type:
-                :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.DiskRecoveryPoint` | 
+                :class:`~ntnx_dataprotection_py_client.models.prism.v4.config.TaskReference` | 
                 :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.error.ErrorResponse`
                     """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
@@ -171,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_dataprotection_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(DiskRecoveryPointListApiResponse, dict):
+        if issubclass(SynchronousReplicaPromoteApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, DiskRecoveryPointListApiResponse):
+        if not isinstance(other, SynchronousReplicaPromoteApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/EsxiVmOverrideSpec.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/LocationReference.py`

 * *Files 13% similar despite different names*

```diff
@@ -3,119 +3,120 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class EsxiVmOverrideSpec(object):
+class LocationReference(object):
 
-    """Recovery point restore that overrides the ESXi VM configuration. The specified properties will be overridden for the restored VM.
+    """Location reference where the specified recovery point is present.
 
-    :param name: (:attr:`name`) The name of the restored VM
-    :type name: 
+    :param location_ext_id: (:attr:`location_ext_id`) External identifier of the cluster where the recovery point is present.
+    :type location_ext_id: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'name': 'str',
+        'location_ext_id': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'name': 'name',
+        'location_ext_id': 'locationExtId',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, name=None, *args, **kwargs):  # noqa: E501
-        self.__name = None
+    def __init__(self, location_ext_id=None, *args, **kwargs):  # noqa: E501
+        self.__location_ext_id = None
         self.discriminator = None
-        if name is not None:
-            self.__name = name
+        if location_ext_id is not None:
+            self.__location_ext_id = location_ext_id
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'dataprotection.v4.config.EsxiVmOverrideSpec'
+        return 'dataprotection.v4.config.LocationReference'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.EsxiVmOverrideSpec'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def name(self):
+    def location_ext_id(self):
         """
-        The name of the restored VM
+        External identifier of the cluster where the recovery point is present.
 
         :type:
 
                 :class:`~str`
         """  # noqa: E501
-        return self.__name
+        return self.__location_ext_id
 
-    @name.setter
-    def name(self, name):
-        if name is not None and len(name) > 256:
-            raise ValueError("Invalid value for `name`, length must be less than or equal to `256`")  # noqa: E501
+    @location_ext_id.setter
+    def location_ext_id(self, location_ext_id):
+        if location_ext_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', location_ext_id):  # noqa: E501
+            raise ValueError(r"Invalid value for `location_ext_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
 
-        self.__name = name
+        self.__location_ext_id = location_ext_id
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -148,37 +149,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(EsxiVmOverrideSpec, dict):
+        if issubclass(LocationReference, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -190,15 +196,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, EsxiVmOverrideSpec):
+        if not isinstance(other, LocationReference):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/HardwareArchitecture.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ObjectStorageType.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,71 +3,74 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class HardwareArchitecture(object):
+class ObjectStorageType(object):
 
-    """Architecture of the hardware where the Recovery point is generated.
+    """Type of the S3-compatible object storage.
 
 
     Allowed enum values:
 
         - _UNKNOWN
         - _REDACTED
-        - X86_64
-        - PPC
+        - AZURE_BLOB_STORAGE: Microsoft Azure Blob Storage.
+        - AMAZON_S3: Amazon S3.
+        - NUTANIX_OBJECTS: Nutanix Objects.
     """
     _UNKNOWN = "$UNKNOWN"
     _REDACTED = "$REDACTED"
-    X86_64 = "X86_64"
-    PPC = "PPC"
+    AZURE_BLOB_STORAGE = "AZURE_BLOB_STORAGE"
+    AMAZON_S3 = "AMAZON_S3"
+    NUTANIX_OBJECTS = "NUTANIX_OBJECTS"
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'dataprotection.v4.config.HardwareArchitecture'
+        return 'dataprotection.v4.config.ObjectStorageType'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.HardwareArchitecture'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -82,36 +85,41 @@
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(HardwareArchitecture, dict):
+        if issubclass(ObjectStorageType, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -123,15 +131,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, HardwareArchitecture):
+        if not isinstance(other, ObjectStorageType):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/HostReference.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/WitnessAvailabilityStatus.py`

 * *Files 23% similar despite different names*

```diff
@@ -3,151 +3,121 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_dataprotection_py_client.models.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
-from ntnx_dataprotection_py_client.models.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel  # noqa: F401,E501
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.HostType import HostType  # noqa: F401,E501
-
-class HostReference(ExternalizableAbstractModel):
-
-    """Information about the Witness host site.
-
-    :param host_type: (:attr:`host_type`) 
-    :type host_type: 
-    :param name: (:attr:`name`) Name of the Witness host site.
-    :type name: 
+from pathlib import Path
 
-    """
-    """
-    IGNORE:
-    Attributes:
-      swagger_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-    IGNORE
-    """  # noqa: E501
-    swagger_types = {
-        'host_type': 'dataprotection.v4.config.HostType',
-        'name': 'str',
-        'ext_id': 'str',
-        'links': 'list[common.v1.response.ApiLink]',
-        'tenant_id': 'str',
-        '_reserved': 'dict(str, object)',
-        '_object_type': 'str',
-        '_unknown_fields': 'dict(str, object)',
-    }
-
-    attribute_map = {
-        'host_type': 'hostType',
-        'name': 'name',
-        'ext_id': 'extId',
-        'links': 'links',
-        'tenant_id': 'tenantId',
-        '_reserved': '$reserved',
-        '_object_type': '$objectType',
-        '_unknown_fields': '$unknownFields',
-    }
-
-
-
-    def __init__(self, host_type=None, name=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
-        ExternalizableAbstractModel.__init__(self, ext_id, links, tenant_id, *args, **kwargs)
-        self.__host_type = None
-        self.__name = None
-        self.discriminator = None
-        if host_type is not None:
-            self.__host_type = host_type
-        if name is not None:
-            self.__name = name
+class WitnessAvailabilityStatus(object):
 
-    def _initialize_object_type(self):
-        return 'dataprotection.v4.config.HostReference'
+    """Availability status of the Witness.
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.HostReference'
 
+    Allowed enum values:
 
-    @property
-    def host_type(self):
-        """
-        
+        - _UNKNOWN
+        - _REDACTED
+        - AVAILABLE
+        - UNAVAILABLE
+    """
+    _UNKNOWN = "$UNKNOWN"
+    _REDACTED = "$REDACTED"
+    AVAILABLE = "AVAILABLE"
+    UNAVAILABLE = "UNAVAILABLE"
 
-        :type:
-            :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.HostType`
-        """  # noqa: E501
-        return self.__host_type
 
-    @host_type.setter
-    def host_type(self, host_type):
+    def __init__(self, *args, **kwargs):  # noqa: E501
+        self.discriminator = None
+        # populate hidden vars if not empty
+        self._populate_hidden_vars(kwargs)
 
-        self.__host_type = host_type
+    def _initialize_object_type(self):
+        return 'dataprotection.v4.config.WitnessAvailabilityStatus'
 
-    @property
-    def name(self):
-        """
-        Name of the Witness host site.
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
-        :type:
+    def _populate_hidden_vars(self, kwargs):
+        if "_reserved" in kwargs and kwargs["_reserved"] is not None:
+            self.__dollar_reserved = kwargs["_reserved"]
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+            self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
+        else :
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
+        if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
+            self.__dollar_unknown_fields = kwargs["_unknown_fields"]
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+            self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
+        else :
+            self.__dollar_unknown_fields = {}
+        if "_object_type" in kwargs and kwargs["_object_type"] is not None:
+            self.__dollar_object_type = kwargs["_object_type"]
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+            self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
+        else:
+            self.__dollar_object_type = self._initialize_object_type()
 
-                :class:`~str`
-        """  # noqa: E501
-        return self.__name
+    def get_object_type(self):
+        return self.__dollar_object_type
 
-    @name.setter
-    def name(self, name):
+    def get_reserved(self):
+        return self.__dollar_reserved
 
-        self.__name = name
+    def get_unknown_fields(self):
+        return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(HostReference, dict):
+        if issubclass(WitnessAvailabilityStatus, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -159,15 +129,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, HostReference):
+        if not isinstance(other, WitnessAvailabilityStatus):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/HostType.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/HostType.py`

 * *Files 9% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
 class HostType(object):
 
     """Type of the Witness host site.
 
 
     Allowed enum values:
@@ -39,33 +40,33 @@
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'dataprotection.v4.config.HostType'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.HostType'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -80,27 +81,32 @@
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/HypervisorType.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/RegionType.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,73 +3,72 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class HypervisorType(object):
+class RegionType(object):
 
-    """Hypervisor type where the Recovery point is generated.
+    """The type of the region.
 
 
     Allowed enum values:
 
         - _UNKNOWN
         - _REDACTED
-        - AHV
-        - HYPERV
-        - VMWARE
+        - ZEROED: A zero region.
+        - REGULAR: An initialized region.
     """
     _UNKNOWN = "$UNKNOWN"
     _REDACTED = "$REDACTED"
-    AHV = "AHV"
-    HYPERV = "HYPERV"
-    VMWARE = "VMWARE"
+    ZEROED = "ZEROED"
+    REGULAR = "REGULAR"
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'dataprotection.v4.config.HypervisorType'
+        return 'dataprotection.v4.config.RegionType'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.HypervisorType'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -84,36 +83,41 @@
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(HypervisorType, dict):
+        if issubclass(RegionType, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -125,15 +129,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, HypervisorType):
+        if not isinstance(other, RegionType):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/IpAddress.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/prism/v4/config/TaskReference.py`

 * *Files 16% similar despite different names*

```diff
@@ -3,120 +3,120 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class IpAddress(object):
+class TaskReference(object):
 
-    """IP address.
+    """A reference to a task tracking an asynchronous operation. The status of the task can be queried by making a GET request to the task URI provided in the metadata section of the API response.
 
-    :param ipv4: (:attr:`ipv4`) IP address value in IPv4 format.
-    :type ipv4: required
+    :param ext_id: (:attr:`ext_id`) A globally unique identifier of a task.
+    :type ext_id: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'ipv4': 'str',
+        'ext_id': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'ipv4': 'ipv4',
+        'ext_id': 'extId',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, ipv4=None, *args, **kwargs):  # noqa: E501
-        self.__ipv4 = None
+    def __init__(self, ext_id=None, *args, **kwargs):  # noqa: E501
+        self.__ext_id = None
         self.discriminator = None
-        self.__ipv4 = ipv4
+        if ext_id is not None:
+            self.__ext_id = ext_id
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'dataprotection.v4.config.IpAddress'
+        return 'prism.v4.config.TaskReference'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.IpAddress'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def ipv4(self):
+    def ext_id(self):
         """
-        IP address value in IPv4 format.
+        A globally unique identifier of a task.
 
         :type:
 
                 :class:`~str`
         """  # noqa: E501
-        return self.__ipv4
+        return self.__ext_id
 
-    @ipv4.setter
-    def ipv4(self, ipv4):
-        if ipv4 is None:
-            raise ValueError("Invalid value for `ipv4`, must not be `None`")  # noqa: E501
-        if ipv4 is not None and not re.search('^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$', ipv4):  # noqa: E501
-            raise ValueError(r"Invalid value for `ipv4`, must be a follow pattern or equal to `/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/`")  # noqa: E501
+    @ext_id.setter
+    def ext_id(self, ext_id):
+        if ext_id is not None and not re.search('^[a-zA-Z0-9\/+]*={0,2}:[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}', ext_id):  # noqa: E501
+            raise ValueError(r"Invalid value for `ext_id`, must be a follow pattern or equal to `/^[a-zA-Z0-9\/+]*={0,2}:[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}/`")  # noqa: E501
 
-        self.__ipv4 = ipv4
+        self.__ext_id = ext_id
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -149,37 +149,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(IpAddress, dict):
+        if issubclass(TaskReference, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -191,15 +196,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, IpAddress):
+        if not isinstance(other, TaskReference):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/LocationReference.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/RedirectionResponse.py`

 * *Files 13% similar despite different names*

```diff
@@ -3,119 +3,141 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.IpAddress import IpAddress  # noqa: F401,E501
 
-class LocationReference(object):
+class RedirectionResponse(object):
 
-    """Location reference where the specified Recovery point is present.
+    """
 
-    :param location_ext_id: (:attr:`location_ext_id`) External identifier of the cluster where the Recovery point is present.
-    :type location_ext_id: 
+    :param certificate: (:attr:`certificate`) A special token in string format. This token must be set as a session cookie in the redirect call.
+    :type certificate: 
+    :param redirect_ip: (:attr:`redirect_ip`) 
+    :type redirect_ip: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'location_ext_id': 'str',
+        'certificate': 'str',
+        'redirect_ip': 'dataprotection.v4.config.IpAddress',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'location_ext_id': 'locationExtId',
+        'certificate': 'certificate',
+        'redirect_ip': 'redirectIp',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, location_ext_id=None, *args, **kwargs):  # noqa: E501
-        self.__location_ext_id = None
+    def __init__(self, certificate=None, redirect_ip=None, *args, **kwargs):  # noqa: E501
+        self.__certificate = None
+        self.__redirect_ip = None
         self.discriminator = None
-        if location_ext_id is not None:
-            self.__location_ext_id = location_ext_id
+        if certificate is not None:
+            self.__certificate = certificate
+        if redirect_ip is not None:
+            self.__redirect_ip = redirect_ip
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'dataprotection.v4.config.LocationReference'
+        return 'dataprotection.v4.config.RedirectionResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.LocationReference'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def location_ext_id(self):
+    def certificate(self):
         """
-        External identifier of the cluster where the Recovery point is present.
+        A special token in string format. This token must be set as a session cookie in the redirect call.
 
         :type:
 
                 :class:`~str`
         """  # noqa: E501
-        return self.__location_ext_id
+        return self.__certificate
+
+    @certificate.setter
+    def certificate(self, certificate):
+
+        self.__certificate = certificate
+
+    @property
+    def redirect_ip(self):
+        """
+        
+
+        :type:
+            :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.IpAddress`
+        """  # noqa: E501
+        return self.__redirect_ip
 
-    @location_ext_id.setter
-    def location_ext_id(self, location_ext_id):
-        if location_ext_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', location_ext_id):  # noqa: E501
-            raise ValueError(r"Invalid value for `location_ext_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
+    @redirect_ip.setter
+    def redirect_ip(self, redirect_ip):
 
-        self.__location_ext_id = location_ext_id
+        self.__redirect_ip = redirect_ip
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -148,37 +170,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(LocationReference, dict):
+        if issubclass(RedirectionResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -190,15 +217,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, LocationReference):
+        if not isinstance(other, RedirectionResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/PowerState.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ProtectedEntityType.py`

 * *Files 12% similar despite different names*

```diff
@@ -3,71 +3,72 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class PowerState(object):
+class ProtectedEntityType(object):
 
-    """Power state of the VM when the Recovery point is generated.
+    """Protected resource entity type.
 
 
     Allowed enum values:
 
         - _UNKNOWN
         - _REDACTED
-        - OFF
-        - ON
+        - VM: A VM protected in NearSync or Synchronous schedules.
+        - VOLUME_GROUP: A volume group protected in NearSync or Synchronous schedules.
     """
     _UNKNOWN = "$UNKNOWN"
     _REDACTED = "$REDACTED"
-    OFF = "OFF"
-    ON = "ON"
+    VM = "VM"
+    VOLUME_GROUP = "VOLUME_GROUP"
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'dataprotection.v4.config.PowerState'
+        return 'dataprotection.v4.config.ProtectedEntityType'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.PowerState'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -82,36 +83,41 @@
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(PowerState, dict):
+        if issubclass(ProtectedEntityType, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -123,15 +129,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, PowerState):
+        if not isinstance(other, ProtectedEntityType):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ProtectedResource.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ProtectedResource.py`

 * *Files 20% similar despite different names*

```diff
@@ -3,111 +3,119 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_dataprotection_py_client.models.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
 from ntnx_dataprotection_py_client.models.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel  # noqa: F401,E501
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.DataProtectionInfo import DataProtectionInfo  # noqa: F401,E501
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.DataProtectionSiteReference import DataProtectionSiteReference  # noqa: F401,E501
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ProtectedResourceEntityType import ProtectedResourceEntityType  # noqa: F401,E501
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ProtectedEntityType import ProtectedEntityType  # noqa: F401,E501
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ReplicationState import ReplicationState  # noqa: F401,E501
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.SiteProtectionInfo import SiteProtectionInfo  # noqa: F401,E501
 
 class ProtectedResource(ExternalizableAbstractModel):
 
     """Once a VM or volume group is associated with some protection policy, the schedule(s) in the protection policy kick in to achieve the specified recovery point objective. A protected resource represents the data protection view of such a VM or volume group. It contains information such as the restorable time ranges on the local Prism Central and the state of replication to the targets specified in all the applied protection policies.
 
     :param entity_ext_id: (:attr:`entity_ext_id`) The external identifier of the VM or the volume group associated with the protected resource.
     :type entity_ext_id: 
     :param entity_type: (:attr:`entity_type`) 
     :type entity_type: 
     :param source_site_reference: (:attr:`source_site_reference`) 
     :type source_site_reference: 
-    :param data_protection_info: (:attr:`data_protection_info`) The data protection details for the protected resource that are relevant to any of the clusters in the local Prism Central, like the time ranges available for recovery.
-    :type data_protection_info: 
+    :param site_protection_info: (:attr:`site_protection_info`) The data protection details for the protected resource that are relevant to any of the sites in the local Prism Central, like the time ranges available for recovery.
+    :type site_protection_info: 
     :param replication_states: (:attr:`replication_states`) 
     :type replication_states: 
+    :param category_fq_names: (:attr:`category_fq_names`) Category key-value pairs associated with the protected resource at the time of protection. The category key and value are separated by '/'. For example, a category with key 'dept' and value 'hr' will be represented as 'dept/hr'.
+    :type category_fq_names: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'entity_ext_id': 'str',
-        'entity_type': 'dataprotection.v4.config.ProtectedResourceEntityType',
+        'entity_type': 'dataprotection.v4.config.ProtectedEntityType',
         'source_site_reference': 'dataprotection.v4.config.DataProtectionSiteReference',
-        'data_protection_info': 'list[dataprotection.v4.config.DataProtectionInfo]',
+        'site_protection_info': 'list[dataprotection.v4.config.SiteProtectionInfo]',
         'replication_states': 'list[dataprotection.v4.config.ReplicationState]',
+        'category_fq_names': 'list[str]',
         'ext_id': 'str',
         'links': 'list[common.v1.response.ApiLink]',
         'tenant_id': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'entity_ext_id': 'entityExtId',
         'entity_type': 'entityType',
         'source_site_reference': 'sourceSiteReference',
-        'data_protection_info': 'dataProtectionInfo',
+        'site_protection_info': 'siteProtectionInfo',
         'replication_states': 'replicationStates',
+        'category_fq_names': 'categoryFqNames',
         'ext_id': 'extId',
         'links': 'links',
         'tenant_id': 'tenantId',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, entity_ext_id=None, entity_type=None, source_site_reference=None, data_protection_info=None, replication_states=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
+    def __init__(self, entity_ext_id=None, entity_type=None, source_site_reference=None, site_protection_info=None, replication_states=None, category_fq_names=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
         ExternalizableAbstractModel.__init__(self, ext_id, links, tenant_id, *args, **kwargs)
         self.__entity_ext_id = None
         self.__entity_type = None
         self.__source_site_reference = None
-        self.__data_protection_info = None
+        self.__site_protection_info = None
         self.__replication_states = None
+        self.__category_fq_names = None
         self.discriminator = None
         if entity_ext_id is not None:
             self.__entity_ext_id = entity_ext_id
         if entity_type is not None:
             self.__entity_type = entity_type
         if source_site_reference is not None:
             self.__source_site_reference = source_site_reference
-        if data_protection_info is not None:
-            self.__data_protection_info = data_protection_info
+        if site_protection_info is not None:
+            self.__site_protection_info = site_protection_info
         if replication_states is not None:
             self.__replication_states = replication_states
+        if category_fq_names is not None:
+            self.__category_fq_names = category_fq_names
 
     def _initialize_object_type(self):
         return 'dataprotection.v4.config.ProtectedResource'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.ProtectedResource'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     @property
     def entity_ext_id(self):
         """
         The external identifier of the VM or the volume group associated with the protected resource.
 
@@ -126,15 +134,15 @@
 
     @property
     def entity_type(self):
         """
         
 
         :type:
-            :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.ProtectedResourceEntityType`
+            :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.ProtectedEntityType`
         """  # noqa: E501
         return self.__entity_type
 
     @entity_type.setter
     def entity_type(self, entity_type):
 
         self.__entity_type = entity_type
@@ -151,27 +159,27 @@
 
     @source_site_reference.setter
     def source_site_reference(self, source_site_reference):
 
         self.__source_site_reference = source_site_reference
 
     @property
-    def data_protection_info(self):
+    def site_protection_info(self):
         """
-        The data protection details for the protected resource that are relevant to any of the clusters in the local Prism Central, like the time ranges available for recovery.
+        The data protection details for the protected resource that are relevant to any of the sites in the local Prism Central, like the time ranges available for recovery.
 
         :type:
-             list[ :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.DataProtectionInfo` ]
+             list[ :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.SiteProtectionInfo` ]
         """  # noqa: E501
-        return self.__data_protection_info
+        return self.__site_protection_info
 
-    @data_protection_info.setter
-    def data_protection_info(self, data_protection_info):
+    @site_protection_info.setter
+    def site_protection_info(self, site_protection_info):
 
-        self.__data_protection_info = data_protection_info
+        self.__site_protection_info = site_protection_info
 
     @property
     def replication_states(self):
         """
         
 
         :type:
@@ -180,36 +188,56 @@
         return self.__replication_states
 
     @replication_states.setter
     def replication_states(self, replication_states):
 
         self.__replication_states = replication_states
 
+    @property
+    def category_fq_names(self):
+        """
+        Category key-value pairs associated with the protected resource at the time of protection. The category key and value are separated by '/'. For example, a category with key 'dept' and value 'hr' will be represented as 'dept/hr'.
+
+        :type:
+            list[ :class:`~str` ]
+        """  # noqa: E501
+        return self.__category_fq_names
+
+    @category_fq_names.setter
+    def category_fq_names(self, category_fq_names):
+
+        self.__category_fq_names = category_fq_names
+
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ProtectedResourceApiResponse.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/UpdateConsistencyGroupApiResponse.py`

 * *Files 14% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_dataprotection_py_client.models
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.ProtectedResourceApiResponsedata import ProtectedResourceApiResponsedata  # noqa: F401,E501
+from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.UpdateConsistencyGroupApiResponsedata import UpdateConsistencyGroupApiResponsedata  # noqa: F401,E501
 from ntnx_dataprotection_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class ProtectedResourceApiResponse(object):
+class UpdateConsistencyGroupApiResponse(object):
 
-    """REST response for all response codes in API path /dataprotection/v4.0.a4/config/protected-resources/{extId} Get operation
+    """REST response for all response codes in API path /dataprotection/v4.0.b1/config/consistency-groups/{extId} Put operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfdataprotection.v4.config.ProtectedResourceApiResponsedata',
+        'data': 'OneOfdataprotection.v4.config.UpdateConsistencyGroupApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'dataprotection.v4.config.ProtectedResourceApiResponse'
+        return 'dataprotection.v4.config.UpdateConsistencyGroupApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.ProtectedResourceApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -122,15 +123,15 @@
 
     @property
     def data(self):
         """
         
 
         :type:
-                :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.ProtectedResource` | 
+                :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.error.AppMessage` | 
                 :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.error.ErrorResponse`
                     """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
@@ -171,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_dataprotection_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ProtectedResourceApiResponse, dict):
+        if issubclass(UpdateConsistencyGroupApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ProtectedResourceApiResponse):
+        if not isinstance(other, UpdateConsistencyGroupApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ProtectedResourceEntityType.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ProtectedResourceReplicationStatus.py`

 * *Files 20% similar despite different names*

```diff
@@ -3,71 +3,74 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class ProtectedResourceEntityType(object):
+class ProtectedResourceReplicationStatus(object):
 
-    """Protected resource entity type.
+    """Status of replication to a specified target site.
 
 
     Allowed enum values:
 
         - _UNKNOWN
         - _REDACTED
-        - VM
-        - VOLUME_GROUP
+        - IN_SYNC: The specified recovery point objective is met on the target site and failover can be performed.
+        - SYNCING: The system is trying to meet the specified recovery point objective for the target site via ongoing replications and failover can't yet be performed.
+        - OUT_OF_SYNC: The replication schedule is disabled and there are no ongoing replications. Manual action might be needed by the user to meet the recovery point objective.
     """
     _UNKNOWN = "$UNKNOWN"
     _REDACTED = "$REDACTED"
-    VM = "VM"
-    VOLUME_GROUP = "VOLUME_GROUP"
+    IN_SYNC = "IN_SYNC"
+    SYNCING = "SYNCING"
+    OUT_OF_SYNC = "OUT_OF_SYNC"
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'dataprotection.v4.config.ProtectedResourceEntityType'
+        return 'dataprotection.v4.config.ProtectedResourceReplicationStatus'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.ProtectedResourceEntityType'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -82,36 +85,41 @@
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ProtectedResourceEntityType, dict):
+        if issubclass(ProtectedResourceReplicationStatus, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -123,15 +131,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ProtectedResourceEntityType):
+        if not isinstance(other, ProtectedResourceReplicationStatus):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ProtectedResourcePromoteApiResponse.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/VpcReference.py`

 * *Files 20% similar despite different names*

```diff
@@ -3,142 +3,144 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_dataprotection_py_client.models
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.ProtectedResourcePromoteApiResponsedata import ProtectedResourcePromoteApiResponsedata  # noqa: F401,E501
-from ntnx_dataprotection_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
-
-class ProtectedResourcePromoteApiResponse(object):
-
-    """REST response for all response codes in API path /dataprotection/v4.0.a4/config/protected-resources/{extId}/$actions/promote Post operation
-
-    :param metadata: (:attr:`metadata`) 
-    :type metadata: 
-    :param data: (:attr:`data`) 
-    :type data: 
+from pathlib import Path
+
+class VpcReference(object):
+
+    """VPC reference.
+
+    :param ext_id: (:attr:`ext_id`) External identifier of the VPC.
+    :type ext_id: required
+    :param name: (:attr:`name`) Name of the VPC, this is a read-only field.
+    :type name: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfdataprotection.v4.config.ProtectedResourcePromoteApiResponsedata',
+        'ext_id': 'str',
+        'name': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'metadata': 'metadata',
-        'data': 'data',
+        'ext_id': 'extId',
+        'name': 'name',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        self.__metadata = None
-        self.__data = None
+    def __init__(self, ext_id=None, name=None, *args, **kwargs):  # noqa: E501
+        self.__ext_id = None
+        self.__name = None
         self.discriminator = None
-        if metadata is not None:
-            self.__metadata = metadata
-        if data is not None:
-            self.__data = data
+        self.__ext_id = ext_id
+        if name is not None:
+            self.__name = name
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'dataprotection.v4.config.ProtectedResourcePromoteApiResponse'
+        return 'dataprotection.v4.config.VpcReference'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.ProtectedResourcePromoteApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def metadata(self):
+    def ext_id(self):
         """
-        
+        External identifier of the VPC.
 
         :type:
-            :class:`~ntnx_dataprotection_py_client.models.common.v1.response.ApiResponseMetadata`
+
+                :class:`~str`
         """  # noqa: E501
-        return self.__metadata
+        return self.__ext_id
 
-    @metadata.setter
-    def metadata(self, metadata):
+    @ext_id.setter
+    def ext_id(self, ext_id):
+        if ext_id is None:
+            raise ValueError("Invalid value for `ext_id`, must not be `None`")  # noqa: E501
+        if ext_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', ext_id):  # noqa: E501
+            raise ValueError(r"Invalid value for `ext_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
 
-        self.__metadata = metadata
+        self.__ext_id = ext_id
 
     @property
-    def data(self):
+    def name(self):
         """
-        
+        Name of the VPC, this is a read-only field.
 
         :type:
-                :class:`~ntnx_dataprotection_py_client.models.prism.v4.config.TaskReference` | 
-                :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.error.ErrorResponse`
-                    """  # noqa: E501
-        return self.__data
 
-    @data.setter
-    def data(self, data):
+                :class:`~str`
+        """  # noqa: E501
+        return self.__name
+
+    @name.setter
+    def name(self, name):
 
-        self.__data = data
+        self.__name = name
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -171,39 +173,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
-            if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_dataprotection_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ProtectedResourcePromoteApiResponse, dict):
+        if issubclass(VpcReference, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +220,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ProtectedResourcePromoteApiResponse):
+        if not isinstance(other, VpcReference):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ProtectedResourceReplicationStatus.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/VolumeGroupSyncContext.py`

 * *Files 22% similar despite different names*

```diff
@@ -3,121 +3,208 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.SiteReference import SiteReference  # noqa: F401,E501
 
-class ProtectedResourceReplicationStatus(object):
+class VolumeGroupSyncContext(object):
 
-    """Status of replication to a specified target site:  ACTIVE - Replications are in-progress and the specified recovery point objective is met on the target site.  SYNCING - The system is trying to meet the specified recovery point objective for the target site.  DEGRADED - The replication schedule has been degraded to a higher recovery point objective.  DISABLED - The replication schedule is disabled and there are no ongoing replications.  DECOUPLED - The connection between recovery and source site is broken, the protected resource at the recovery  site is out of sync and has been promoted to a live entity.
+    """Specification corresponding to the volume group synced state. The primary site reference corresponds to the cluster reference information along with the related AZ information where the entity resides. The secondary site reference corresponds to the cluster site reference information along with the related AZ information where the volume group is synced to.
 
+    :param primary_site: (:attr:`primary_site`) 
+    :type primary_site: 
+    :param secondary_site: (:attr:`secondary_site`) 
+    :type secondary_site: 
 
-    Allowed enum values:
-
-        - _UNKNOWN
-        - _REDACTED
-        - ACTIVE
-        - SYNCING
-        - DEGRADED
-        - DISABLED
-        - DECOUPLED
     """
-    _UNKNOWN = "$UNKNOWN"
-    _REDACTED = "$REDACTED"
-    ACTIVE = "ACTIVE"
-    SYNCING = "SYNCING"
-    DEGRADED = "DEGRADED"
-    DISABLED = "DISABLED"
-    DECOUPLED = "DECOUPLED"
+    """
+    IGNORE:
+    Attributes:
+      swagger_types (dict): The key is attribute name
+                            and the value is attribute type.
+      attribute_map (dict): The key is attribute name
+                            and the value is json key in definition.
+    IGNORE
+    """  # noqa: E501
+    swagger_types = {
+        'primary_site': 'dataprotection.v4.config.SiteReference',
+        'secondary_site': 'dataprotection.v4.config.SiteReference',
+        '_reserved': 'dict(str, object)',
+        '_object_type': 'str',
+        '_unknown_fields': 'dict(str, object)',
+    }
+
+    attribute_map = {
+        'primary_site': 'primarySite',
+        'secondary_site': 'secondarySite',
+        '_reserved': '$reserved',
+        '_object_type': '$objectType',
+        '_unknown_fields': '$unknownFields',
+    }
 
 
-    def __init__(self, *args, **kwargs):  # noqa: E501
+
+    def __init__(self, primary_site=None, secondary_site=None, *args, **kwargs):  # noqa: E501
+        self.__primary_site = None
+        self.__secondary_site = None
         self.discriminator = None
+        if primary_site is not None:
+            self.__primary_site = primary_site
+        if secondary_site is not None:
+            self.__secondary_site = secondary_site
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'dataprotection.v4.config.ProtectedResourceReplicationStatus'
+        return 'dataprotection.v4.config.VolumeGroupSyncContext'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.ProtectedResourceReplicationStatus'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
+    @property
+    def primary_site(self):
+        """
+        
+
+        :type:
+            :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.SiteReference`
+        """  # noqa: E501
+        return self.__primary_site
+
+    @primary_site.setter
+    def primary_site(self, primary_site):
+
+        self.__primary_site = primary_site
+
+    @property
+    def secondary_site(self):
+        """
+        
+
+        :type:
+            :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.SiteReference`
+        """  # noqa: E501
+        return self.__secondary_site
+
+    @secondary_site.setter
+    def secondary_site(self, secondary_site):
+
+        self.__secondary_site = secondary_site
+
+    @property
+    def _reserved(self):
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
+        return self.__dollar_reserved
+
+    @property
+    def _object_type(self):
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__dollar_object_type
+
+    @property
+    def _unknown_fields(self):
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
+        return self.__dollar_unknown_fields
+
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ProtectedResourceReplicationStatus, dict):
+        if issubclass(VolumeGroupSyncContext, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -129,15 +216,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ProtectedResourceReplicationStatus):
+        if not isinstance(other, VolumeGroupSyncContext):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ProtectedResourceRestoreApiResponse.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/Region.py`

 * *Files 17% similar despite different names*

```diff
@@ -3,142 +3,167 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_dataprotection_py_client.models
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.ProtectedResourceRestoreApiResponsedata import ProtectedResourceRestoreApiResponsedata  # noqa: F401,E501
-from ntnx_dataprotection_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
-
-class ProtectedResourceRestoreApiResponse(object):
-
-    """REST response for all response codes in API path /dataprotection/v4.0.a4/config/protected-resources/{extId}/$actions/restore Post operation
-
-    :param metadata: (:attr:`metadata`) 
-    :type metadata: 
-    :param data: (:attr:`data`) 
-    :type data: 
+from pathlib import Path
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.RegionType import RegionType  # noqa: F401,E501
+
+class Region(object):
+
+    """Changed region comprising of offset, length, and type of the region.
+
+    :param offset: (:attr:`offset`) The start offset of the region in bytes.
+    :type offset: required
+    :param length: (:attr:`length`) The length of the region in bytes.
+    :type length: required
+    :param region_type: (:attr:`region_type`) 
+    :type region_type: required
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfdataprotection.v4.config.ProtectedResourceRestoreApiResponsedata',
+        'offset': 'int',
+        'length': 'int',
+        'region_type': 'dataprotection.v4.config.RegionType',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'metadata': 'metadata',
-        'data': 'data',
+        'offset': 'offset',
+        'length': 'length',
+        'region_type': 'regionType',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        self.__metadata = None
-        self.__data = None
+    def __init__(self, offset=None, length=None, region_type=None, *args, **kwargs):  # noqa: E501
+        self.__offset = None
+        self.__length = None
+        self.__region_type = None
         self.discriminator = None
-        if metadata is not None:
-            self.__metadata = metadata
-        if data is not None:
-            self.__data = data
+        self.__offset = offset
+        self.__length = length
+        self.__region_type = region_type
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'dataprotection.v4.config.ProtectedResourceRestoreApiResponse'
+        return 'dataprotection.v4.config.Region'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.ProtectedResourceRestoreApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def metadata(self):
+    def offset(self):
         """
-        
+        The start offset of the region in bytes.
 
         :type:
-            :class:`~ntnx_dataprotection_py_client.models.common.v1.response.ApiResponseMetadata`
+
+                :class:`~int`
         """  # noqa: E501
-        return self.__metadata
+        return self.__offset
 
-    @metadata.setter
-    def metadata(self, metadata):
+    @offset.setter
+    def offset(self, offset):
+        if offset is None:
+            raise ValueError("Invalid value for `offset`, must not be `None`")  # noqa: E501
 
-        self.__metadata = metadata
+        self.__offset = offset
 
     @property
-    def data(self):
+    def length(self):
+        """
+        The length of the region in bytes.
+
+        :type:
+
+                :class:`~int`
+        """  # noqa: E501
+        return self.__length
+
+    @length.setter
+    def length(self, length):
+        if length is None:
+            raise ValueError("Invalid value for `length`, must not be `None`")  # noqa: E501
+
+        self.__length = length
+
+    @property
+    def region_type(self):
         """
         
 
         :type:
-                :class:`~ntnx_dataprotection_py_client.models.prism.v4.config.TaskReference` | 
-                :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.error.ErrorResponse`
-                    """  # noqa: E501
-        return self.__data
+            :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.RegionType`
+        """  # noqa: E501
+        return self.__region_type
 
-    @data.setter
-    def data(self, data):
+    @region_type.setter
+    def region_type(self, region_type):
+        if region_type is None:
+            raise ValueError("Invalid value for `region_type`, must not be `None`")  # noqa: E501
 
-        self.__data = data
+        self.__region_type = region_type
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -171,39 +196,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
-            if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_dataprotection_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ProtectedResourceRestoreApiResponse, dict):
+        if issubclass(Region, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +243,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ProtectedResourceRestoreApiResponse):
+        if not isinstance(other, Region):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ProtectedResourceRestoreSpec.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ConsistencyGroupMigrationSpec.py`

 * *Files 20% similar despite different names*

```diff
@@ -3,143 +3,145 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class ProtectedResourceRestoreSpec(object):
+class ConsistencyGroupMigrationSpec(object):
 
-    """Restore action specifications for a minutely scheduled protected resource.
+    """Specification for the migrate action on the Consistency group.
 
-    :param cluster_ext_id: (:attr:`cluster_ext_id`) The external identifier of the cluster on which the entity has valid restorable time ranges. The restored entity will be created on the same cluster.
-    :type cluster_ext_id: required
-    :param restore_time: (:attr:`restore_time`) UTC date and time in ISO 8601 format representing the time from when the state of the entity should be restored. This needs to be a valid time within the restorable time range(s) for the protected resource.
-    :type restore_time: 
+    :param target_pc_ext_id: (:attr:`target_pc_ext_id`) Reference to the target Availability Zone where the entities need to be migrated.
+    :type target_pc_ext_id: 
+    :param target_cluster_ext_id: (:attr:`target_cluster_ext_id`) Reference to the cluster in the target Availability Zone where the entities need to be migrated.
+    :type target_cluster_ext_id: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'cluster_ext_id': 'str',
-        'restore_time': 'datetime',
+        'target_pc_ext_id': 'str',
+        'target_cluster_ext_id': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'cluster_ext_id': 'clusterExtId',
-        'restore_time': 'restoreTime',
+        'target_pc_ext_id': 'targetPcExtId',
+        'target_cluster_ext_id': 'targetClusterExtId',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, cluster_ext_id=None, restore_time=None, *args, **kwargs):  # noqa: E501
-        self.__cluster_ext_id = None
-        self.__restore_time = None
+    def __init__(self, target_pc_ext_id=None, target_cluster_ext_id=None, *args, **kwargs):  # noqa: E501
+        self.__target_pc_ext_id = None
+        self.__target_cluster_ext_id = None
         self.discriminator = None
-        self.__cluster_ext_id = cluster_ext_id
-        if restore_time is not None:
-            self.__restore_time = restore_time
+        if target_pc_ext_id is not None:
+            self.__target_pc_ext_id = target_pc_ext_id
+        if target_cluster_ext_id is not None:
+            self.__target_cluster_ext_id = target_cluster_ext_id
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'dataprotection.v4.config.ProtectedResourceRestoreSpec'
+        return 'dataprotection.v4.config.ConsistencyGroupMigrationSpec'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.ProtectedResourceRestoreSpec'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def cluster_ext_id(self):
+    def target_pc_ext_id(self):
         """
-        The external identifier of the cluster on which the entity has valid restorable time ranges. The restored entity will be created on the same cluster.
+        Reference to the target Availability Zone where the entities need to be migrated.
 
         :type:
 
                 :class:`~str`
         """  # noqa: E501
-        return self.__cluster_ext_id
+        return self.__target_pc_ext_id
 
-    @cluster_ext_id.setter
-    def cluster_ext_id(self, cluster_ext_id):
-        if cluster_ext_id is None:
-            raise ValueError("Invalid value for `cluster_ext_id`, must not be `None`")  # noqa: E501
-        if cluster_ext_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', cluster_ext_id):  # noqa: E501
-            raise ValueError(r"Invalid value for `cluster_ext_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
+    @target_pc_ext_id.setter
+    def target_pc_ext_id(self, target_pc_ext_id):
+        if target_pc_ext_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', target_pc_ext_id):  # noqa: E501
+            raise ValueError(r"Invalid value for `target_pc_ext_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
 
-        self.__cluster_ext_id = cluster_ext_id
+        self.__target_pc_ext_id = target_pc_ext_id
 
     @property
-    def restore_time(self):
+    def target_cluster_ext_id(self):
         """
-        UTC date and time in ISO 8601 format representing the time from when the state of the entity should be restored. This needs to be a valid time within the restorable time range(s) for the protected resource.
+        Reference to the cluster in the target Availability Zone where the entities need to be migrated.
 
         :type:
 
-                :class:`~datetime`
+                :class:`~str`
         """  # noqa: E501
-        return self.__restore_time
+        return self.__target_cluster_ext_id
 
-    @restore_time.setter
-    def restore_time(self, restore_time):
+    @target_cluster_ext_id.setter
+    def target_cluster_ext_id(self, target_cluster_ext_id):
+        if target_cluster_ext_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', target_cluster_ext_id):  # noqa: E501
+            raise ValueError(r"Invalid value for `target_cluster_ext_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
 
-        self.__restore_time = restore_time
+        self.__target_cluster_ext_id = target_cluster_ext_id
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -172,37 +174,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ProtectedResourceRestoreSpec, dict):
+        if issubclass(ConsistencyGroupMigrationSpec, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -214,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ProtectedResourceRestoreSpec):
+        if not isinstance(other, ConsistencyGroupMigrationSpec):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/RecoveryInfo.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/RecoveryInfo.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.RestorableTimeRange import RestorableTimeRange  # noqa: F401,E501
 
 class RecoveryInfo(object):
 
     """The restorable time range details that can be used to recover the protected resource.
 
     :param restorable_time_ranges: (:attr:`restorable_time_ranges`) List of restorable time ranges.
@@ -60,33 +61,33 @@
             self.__restorable_time_ranges = restorable_time_ranges
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'dataprotection.v4.config.RecoveryInfo'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.RecoveryInfo'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -146,28 +147,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/RecoveryPoint.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/VmRecoveryPointComputeChangedRegionsRequest.py`

 * *Files 16% similar despite different names*

```diff
@@ -3,259 +3,284 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_dataprotection_py_client.models.dataprotection.v4.common.BaseRecoveryPoint import BaseRecoveryPoint  # noqa: F401,E501
-from ntnx_dataprotection_py_client.models.dataprotection.v4.common.RecoveryPointStatus import RecoveryPointStatus  # noqa: F401,E501
-from ntnx_dataprotection_py_client.models.dataprotection.v4.common.RecoveryPointType import RecoveryPointType  # noqa: F401,E501
-from ntnx_dataprotection_py_client.models.dataprotection.v4.common.VendorSpecificProperty import VendorSpecificProperty  # noqa: F401,E501
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.LocationReference import LocationReference  # noqa: F401,E501
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VmSubRecoveryPoint import VmSubRecoveryPoint  # noqa: F401,E501
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VolumeGroupSubRecoveryPoint import VolumeGroupSubRecoveryPoint  # noqa: F401,E501
-
-class RecoveryPoint(BaseRecoveryPoint):
-
-    """Details about the Recovery point along with all the captured VM and volume group Recovery point(s).
-
-    :param owner_ext_id: (:attr:`owner_ext_id`) A read only field inserted into Recovery point at the time of Recovery point creation, indicating the external identifier of the user who created this Recovery point.
-    :type owner_ext_id: 
-    :param location_references: (:attr:`location_references`) List of location references where the VM or volume group Recovery points are a part of the specified Recovery point.
-    :type location_references: 
-    :param vm_reference_list: (:attr:`vm_reference_list`) List of VM external identifiers that are intended to be captured as part of the Recovery point.
-    :type vm_reference_list: 
-    :param volume_group_reference_list: (:attr:`volume_group_reference_list`) List of volume group external identifiers that are intended to be captured as part of the Recovery point.
-    :type volume_group_reference_list: 
-    :param vm_recovery_points: (:attr:`vm_recovery_points`) List of VM Recovery points that are a part of the specified top-level Recovery point.
-    :type vm_recovery_points: 
-    :param volume_group_recovery_points: (:attr:`volume_group_recovery_points`) List of volume group Recovery points that are a part of the specified top-level Recovery point.
-    :type volume_group_recovery_points: 
+from pathlib import Path
+
+class VmRecoveryPointComputeChangedRegionsRequest(object):
+
+    """Compute changed region parameters. In these parameters, you can specify a start offset, an end offset, and a reference disk recovery point. All parameters are optional. However, if a reference disk recovery point needs to be set, all three parameters - recovery point Id, VM recovery point Id, and disk recovery point Id must be specified.
+
+    :param reference_recovery_point_ext_id: (:attr:`reference_recovery_point_ext_id`) The external identifier that can be used to retrieve the recovery point using its URL.
+    :type reference_recovery_point_ext_id: 
+    :param reference_vm_recovery_point_ext_id: (:attr:`reference_vm_recovery_point_ext_id`) The external identifier that can be used to retrieve the VM recovery point using its URL (Note: This attribute will be removed in future releases, use VM recovery point external identifier instead).
+    :type reference_vm_recovery_point_ext_id: 
+    :param reference_disk_recovery_point_ext_id: (:attr:`reference_disk_recovery_point_ext_id`) Disk recovery point external identifier.
+    :type reference_disk_recovery_point_ext_id: 
+    :param offset: (:attr:`offset`) The start offset value to compute the changed region. If the value is not provided, the difference is executed from the offset of 0. Note: the start offset might automatically align to a system-defined block boundary.
+    :type offset: 
+    :param length: (:attr:`length`) The length to compute the changed region. If the value is not provided, the difference is performed from the start offset to the end of the disk. Note: the end offset might automatically align to a system-defined block boundary.
+    :type length: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'owner_ext_id': 'str',
-        'location_references': 'list[dataprotection.v4.config.LocationReference]',
-        'vm_reference_list': 'list[str]',
-        'volume_group_reference_list': 'list[str]',
-        'vm_recovery_points': 'list[dataprotection.v4.config.VmSubRecoveryPoint]',
-        'volume_group_recovery_points': 'list[dataprotection.v4.config.VolumeGroupSubRecoveryPoint]',
-        'location_agnostic_id': 'str',
-        'name': 'str',
-        'creation_time': 'datetime',
-        'expiration_time': 'datetime',
-        'status': 'dataprotection.v4.common.RecoveryPointStatus',
-        'recovery_point_type': 'dataprotection.v4.common.RecoveryPointType',
-        'vendor_specific_properties': 'list[dataprotection.v4.common.VendorSpecificProperty]',
-        'ext_id': 'str',
-        'links': 'list[common.v1.response.ApiLink]',
-        'tenant_id': 'str',
+        'reference_recovery_point_ext_id': 'str',
+        'reference_vm_recovery_point_ext_id': 'str',
+        'reference_disk_recovery_point_ext_id': 'str',
+        'offset': 'int',
+        'length': 'int',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'owner_ext_id': 'ownerExtId',
-        'location_references': 'locationReferences',
-        'vm_reference_list': 'vmReferenceList',
-        'volume_group_reference_list': 'volumeGroupReferenceList',
-        'vm_recovery_points': 'vmRecoveryPoints',
-        'volume_group_recovery_points': 'volumeGroupRecoveryPoints',
-        'location_agnostic_id': 'locationAgnosticId',
-        'name': 'name',
-        'creation_time': 'creationTime',
-        'expiration_time': 'expirationTime',
-        'status': 'status',
-        'recovery_point_type': 'recoveryPointType',
-        'vendor_specific_properties': 'vendorSpecificProperties',
-        'ext_id': 'extId',
-        'links': 'links',
-        'tenant_id': 'tenantId',
+        'reference_recovery_point_ext_id': 'referenceRecoveryPointExtId',
+        'reference_vm_recovery_point_ext_id': 'referenceVmRecoveryPointExtId',
+        'reference_disk_recovery_point_ext_id': 'referenceDiskRecoveryPointExtId',
+        'offset': 'offset',
+        'length': 'length',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, owner_ext_id=None, location_references=None, vm_reference_list=None, volume_group_reference_list=None, vm_recovery_points=None, volume_group_recovery_points=None, location_agnostic_id=None, name=None, creation_time=None, expiration_time=None, status=None, recovery_point_type=None, vendor_specific_properties=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
-        BaseRecoveryPoint.__init__(self, location_agnostic_id, name, creation_time, expiration_time, status, recovery_point_type, vendor_specific_properties, ext_id, links, tenant_id, *args, **kwargs)
-        self.__owner_ext_id = None
-        self.__location_references = None
-        self.__vm_reference_list = None
-        self.__volume_group_reference_list = None
-        self.__vm_recovery_points = None
-        self.__volume_group_recovery_points = None
+    def __init__(self, reference_recovery_point_ext_id=None, reference_vm_recovery_point_ext_id=None, reference_disk_recovery_point_ext_id=None, offset=None, length=None, *args, **kwargs):  # noqa: E501
+        self.__reference_recovery_point_ext_id = None
+        self.__reference_vm_recovery_point_ext_id = None
+        self.__reference_disk_recovery_point_ext_id = None
+        self.__offset = None
+        self.__length = None
         self.discriminator = None
-        if owner_ext_id is not None:
-            self.__owner_ext_id = owner_ext_id
-        if location_references is not None:
-            self.__location_references = location_references
-        if vm_reference_list is not None:
-            self.__vm_reference_list = vm_reference_list
-        if volume_group_reference_list is not None:
-            self.__volume_group_reference_list = volume_group_reference_list
-        if vm_recovery_points is not None:
-            self.__vm_recovery_points = vm_recovery_points
-        if volume_group_recovery_points is not None:
-            self.__volume_group_recovery_points = volume_group_recovery_points
+        if reference_recovery_point_ext_id is not None:
+            self.__reference_recovery_point_ext_id = reference_recovery_point_ext_id
+        if reference_vm_recovery_point_ext_id is not None:
+            self.__reference_vm_recovery_point_ext_id = reference_vm_recovery_point_ext_id
+        if reference_disk_recovery_point_ext_id is not None:
+            self.__reference_disk_recovery_point_ext_id = reference_disk_recovery_point_ext_id
+        if offset is not None:
+            self.__offset = offset
+        if length is not None:
+            self.__length = length
+        # populate hidden vars if not empty
+        self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'dataprotection.v4.config.RecoveryPoint'
+        return 'dataprotection.v4.config.VmRecoveryPointComputeChangedRegionsRequest'
+
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.RecoveryPoint'
+    def _populate_hidden_vars(self, kwargs):
+        if "_reserved" in kwargs and kwargs["_reserved"] is not None:
+            self.__dollar_reserved = kwargs["_reserved"]
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+            self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
+        else :
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
+        if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
+            self.__dollar_unknown_fields = kwargs["_unknown_fields"]
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+            self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
+        else :
+            self.__dollar_unknown_fields = {}
+        if "_object_type" in kwargs and kwargs["_object_type"] is not None:
+            self.__dollar_object_type = kwargs["_object_type"]
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+            self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
+        else:
+            self.__dollar_object_type = self._initialize_object_type()
 
+    def get_object_type(self):
+        return self.__dollar_object_type
+
+    def get_reserved(self):
+        return self.__dollar_reserved
+
+    def get_unknown_fields(self):
+        return self.__dollar_unknown_fields
 
     @property
-    def owner_ext_id(self):
+    def reference_recovery_point_ext_id(self):
         """
-        A read only field inserted into Recovery point at the time of Recovery point creation, indicating the external identifier of the user who created this Recovery point.
+        The external identifier that can be used to retrieve the recovery point using its URL.
 
         :type:
 
                 :class:`~str`
         """  # noqa: E501
-        return self.__owner_ext_id
+        return self.__reference_recovery_point_ext_id
 
-    @owner_ext_id.setter
-    def owner_ext_id(self, owner_ext_id):
-        if owner_ext_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', owner_ext_id):  # noqa: E501
-            raise ValueError(r"Invalid value for `owner_ext_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
+    @reference_recovery_point_ext_id.setter
+    def reference_recovery_point_ext_id(self, reference_recovery_point_ext_id):
+        if reference_recovery_point_ext_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', reference_recovery_point_ext_id):  # noqa: E501
+            raise ValueError(r"Invalid value for `reference_recovery_point_ext_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
 
-        self.__owner_ext_id = owner_ext_id
+        self.__reference_recovery_point_ext_id = reference_recovery_point_ext_id
 
     @property
-    def location_references(self):
+    def reference_vm_recovery_point_ext_id(self):
         """
-        List of location references where the VM or volume group Recovery points are a part of the specified Recovery point.
+        The external identifier that can be used to retrieve the VM recovery point using its URL (Note: This attribute will be removed in future releases, use VM recovery point external identifier instead).
 
         :type:
-             list[ :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.LocationReference` ]
+
+                :class:`~str`
         """  # noqa: E501
-        return self.__location_references
+        return self.__reference_vm_recovery_point_ext_id
 
-    @location_references.setter
-    def location_references(self, location_references):
+    @reference_vm_recovery_point_ext_id.setter
+    def reference_vm_recovery_point_ext_id(self, reference_vm_recovery_point_ext_id):
+        if reference_vm_recovery_point_ext_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', reference_vm_recovery_point_ext_id):  # noqa: E501
+            raise ValueError(r"Invalid value for `reference_vm_recovery_point_ext_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
 
-        self.__location_references = location_references
+        self.__reference_vm_recovery_point_ext_id = reference_vm_recovery_point_ext_id
 
     @property
-    def vm_reference_list(self):
+    def reference_disk_recovery_point_ext_id(self):
         """
-        List of VM external identifiers that are intended to be captured as part of the Recovery point.
+        Disk recovery point external identifier.
 
         :type:
-            list[ :class:`~str` ]
+
+                :class:`~str`
         """  # noqa: E501
-        return self.__vm_reference_list
+        return self.__reference_disk_recovery_point_ext_id
 
-    @vm_reference_list.setter
-    def vm_reference_list(self, vm_reference_list):
+    @reference_disk_recovery_point_ext_id.setter
+    def reference_disk_recovery_point_ext_id(self, reference_disk_recovery_point_ext_id):
+        if reference_disk_recovery_point_ext_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', reference_disk_recovery_point_ext_id):  # noqa: E501
+            raise ValueError(r"Invalid value for `reference_disk_recovery_point_ext_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
 
-        self.__vm_reference_list = vm_reference_list
+        self.__reference_disk_recovery_point_ext_id = reference_disk_recovery_point_ext_id
 
     @property
-    def volume_group_reference_list(self):
+    def offset(self):
         """
-        List of volume group external identifiers that are intended to be captured as part of the Recovery point.
+        The start offset value to compute the changed region. If the value is not provided, the difference is executed from the offset of 0. Note: the start offset might automatically align to a system-defined block boundary.
 
         :type:
-            list[ :class:`~str` ]
+
+                :class:`~int`
         """  # noqa: E501
-        return self.__volume_group_reference_list
+        return self.__offset
 
-    @volume_group_reference_list.setter
-    def volume_group_reference_list(self, volume_group_reference_list):
+    @offset.setter
+    def offset(self, offset):
 
-        self.__volume_group_reference_list = volume_group_reference_list
+        self.__offset = offset
 
     @property
-    def vm_recovery_points(self):
+    def length(self):
         """
-        List of VM Recovery points that are a part of the specified top-level Recovery point.
+        The length to compute the changed region. If the value is not provided, the difference is performed from the start offset to the end of the disk. Note: the end offset might automatically align to a system-defined block boundary.
 
         :type:
-             list[ :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.VmSubRecoveryPoint` ]
+
+                :class:`~int`
         """  # noqa: E501
-        return self.__vm_recovery_points
+        return self.__length
 
-    @vm_recovery_points.setter
-    def vm_recovery_points(self, vm_recovery_points):
+    @length.setter
+    def length(self, length):
 
-        self.__vm_recovery_points = vm_recovery_points
+        self.__length = length
 
     @property
-    def volume_group_recovery_points(self):
+    def _reserved(self):
         """
-        List of volume group Recovery points that are a part of the specified top-level Recovery point.
+        
 
         :type:
-             list[ :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.VolumeGroupSubRecoveryPoint` ]
+            dict(str, :class:`~object`)
         """  # noqa: E501
-        return self.__volume_group_recovery_points
+        return self.__dollar_reserved
 
-    @volume_group_recovery_points.setter
-    def volume_group_recovery_points(self, volume_group_recovery_points):
+    @property
+    def _object_type(self):
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__dollar_object_type
 
-        self.__volume_group_recovery_points = volume_group_recovery_points
+    @property
+    def _unknown_fields(self):
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
+        return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(RecoveryPoint, dict):
+        if issubclass(VmRecoveryPointComputeChangedRegionsRequest, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -267,15 +292,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, RecoveryPoint):
+        if not isinstance(other, VmRecoveryPointComputeChangedRegionsRequest):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/RecoveryPointApiResponse.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/RestorableTimeRange.py`

 * *Files 17% similar despite different names*

```diff
@@ -3,142 +3,141 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_dataprotection_py_client.models
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.RecoveryPointApiResponsedata import RecoveryPointApiResponsedata  # noqa: F401,E501
-from ntnx_dataprotection_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
-
-class RecoveryPointApiResponse(object):
-
-    """REST response for all response codes in API path /dataprotection/v4.0.a4/config/recovery-points/{extId} Get operation
-
-    :param metadata: (:attr:`metadata`) 
-    :type metadata: 
-    :param data: (:attr:`data`) 
-    :type data: 
+from pathlib import Path
+
+class RestorableTimeRange(object):
+
+    """The start and end time details, both inclusively represent the range of time during which the entity is restorable.
+
+    :param start_time: (:attr:`start_time`) UTC date and time in ISO 8601 format representing the time when the restorable time range for the entity starts.
+    :type start_time: 
+    :param end_time: (:attr:`end_time`) UTC date and time in ISO 8601 format representing the time when the restorable time range for the entity ends.
+    :type end_time: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfdataprotection.v4.config.RecoveryPointApiResponsedata',
+        'start_time': 'datetime',
+        'end_time': 'datetime',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'metadata': 'metadata',
-        'data': 'data',
+        'start_time': 'startTime',
+        'end_time': 'endTime',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        self.__metadata = None
-        self.__data = None
+    def __init__(self, start_time=None, end_time=None, *args, **kwargs):  # noqa: E501
+        self.__start_time = None
+        self.__end_time = None
         self.discriminator = None
-        if metadata is not None:
-            self.__metadata = metadata
-        if data is not None:
-            self.__data = data
+        if start_time is not None:
+            self.__start_time = start_time
+        if end_time is not None:
+            self.__end_time = end_time
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'dataprotection.v4.config.RecoveryPointApiResponse'
+        return 'dataprotection.v4.config.RestorableTimeRange'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.RecoveryPointApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def metadata(self):
+    def start_time(self):
         """
-        
+        UTC date and time in ISO 8601 format representing the time when the restorable time range for the entity starts.
 
         :type:
-            :class:`~ntnx_dataprotection_py_client.models.common.v1.response.ApiResponseMetadata`
+
+                :class:`~datetime`
         """  # noqa: E501
-        return self.__metadata
+        return self.__start_time
 
-    @metadata.setter
-    def metadata(self, metadata):
+    @start_time.setter
+    def start_time(self, start_time):
 
-        self.__metadata = metadata
+        self.__start_time = start_time
 
     @property
-    def data(self):
+    def end_time(self):
         """
-        
+        UTC date and time in ISO 8601 format representing the time when the restorable time range for the entity ends.
 
         :type:
-                :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.RecoveryPoint` | 
-                :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.error.ErrorResponse`
-                    """  # noqa: E501
-        return self.__data
 
-    @data.setter
-    def data(self, data):
+                :class:`~datetime`
+        """  # noqa: E501
+        return self.__end_time
+
+    @end_time.setter
+    def end_time(self, end_time):
 
-        self.__data = data
+        self.__end_time = end_time
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -171,39 +170,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
-            if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_dataprotection_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(RecoveryPointApiResponse, dict):
+        if issubclass(RestorableTimeRange, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +217,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, RecoveryPointApiResponse):
+        if not isinstance(other, RestorableTimeRange):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/RecoveryPointListApiResponse.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ComputeChangedRegionsResponse.py`

 * *Files 18% similar despite different names*

```diff
@@ -3,142 +3,120 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_dataprotection_py_client.models
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.RecoveryPointListApiResponsedata import RecoveryPointListApiResponsedata  # noqa: F401,E501
-from ntnx_dataprotection_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.ComputeChangedRegionsResponseresponse import ComputeChangedRegionsResponseresponse  # noqa: F401,E501
 
-class RecoveryPointListApiResponse(object):
+class ComputeChangedRegionsResponse(object):
 
-    """REST response for all response codes in API path /dataprotection/v4.0.a4/config/recovery-points Get operation
+    """Response parameters for the compute changed regions. It is a chunk-encoded stream for the redirect request. It can contain a redirect IP, a certificate, or the actual changed regions. If the response contains a redirect IP, the client must re-send the request to the specified IP. The certificate needs to be set as NTNX_IGW_SESSION cookie in the header.
 
-    :param metadata: (:attr:`metadata`) 
-    :type metadata: 
-    :param data: (:attr:`data`) 
-    :type data: 
+    :param response: (:attr:`response`) 
+    :type response: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfdataprotection.v4.config.RecoveryPointListApiResponsedata',
+        'response': 'OneOfdataprotection.v4.config.ComputeChangedRegionsResponseresponse',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'metadata': 'metadata',
-        'data': 'data',
+        'response': 'response',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        self.__metadata = None
-        self.__data = None
+    def __init__(self, response=None, *args, **kwargs):  # noqa: E501
+        self.__response = None
         self.discriminator = None
-        if metadata is not None:
-            self.__metadata = metadata
-        if data is not None:
-            self.__data = data
+        if response is not None:
+            self.__response = response
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'dataprotection.v4.config.RecoveryPointListApiResponse'
+        return 'dataprotection.v4.config.ComputeChangedRegionsResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.RecoveryPointListApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def metadata(self):
+    def response(self):
         """
         
 
         :type:
-            :class:`~ntnx_dataprotection_py_client.models.common.v1.response.ApiResponseMetadata`
-        """  # noqa: E501
-        return self.__metadata
-
-    @metadata.setter
-    def metadata(self, metadata):
-
-        self.__metadata = metadata
-
-    @property
-    def data(self):
-        """
-        
-
-        :type:
-                :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.RecoveryPoint` | 
-                :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.error.ErrorResponse`
+                :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.RegionResponse` | 
+                :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.RedirectionResponse`
                     """  # noqa: E501
-        return self.__data
+        return self.__response
 
-    @data.setter
-    def data(self, data):
+    @response.setter
+    def response(self, response):
 
-        self.__data = data
+        self.__response = response
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -171,39 +149,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_dataprotection_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(RecoveryPointListApiResponse, dict):
+        if issubclass(ComputeChangedRegionsResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +198,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, RecoveryPointListApiResponse):
+        if not isinstance(other, ComputeChangedRegionsResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/RecoveryPointReplicateApiResponse.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/error/SchemaValidationErrorMessage.py`

 * *Files 18% similar despite different names*

```diff
@@ -3,143 +3,164 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_dataprotection_py_client.models
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.RecoveryPointReplicateApiResponsedata import RecoveryPointReplicateApiResponsedata  # noqa: F401,E501
-from ntnx_dataprotection_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
-
-class RecoveryPointReplicateApiResponse(object):
-
-    """REST response for all response codes in API path /dataprotection/v4.0.a4/config/recovery-points/{extId}/$actions/replicate Post operation
-
-    :param metadata: (:attr:`metadata`) 
-    :type metadata: 
-    :param data: (:attr:`data`) 
-    :type data: 
+from pathlib import Path
+
+class SchemaValidationErrorMessage(object):
+
+    """This schema is generated from SchemaValidationErrorMessage.java
+
+    :param location: (:attr:`location`) The part of the request that failed validation. Validation can fail for path, query parameters, and request body.
+    :type location: 
+    :param message: (:attr:`message`) The detailed message for the validation error.
+    :type message: 
+    :param attribute_path: (:attr:`attribute_path`) The path of the attribute that failed validation in the schema.
+    :type attribute_path: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfdataprotection.v4.config.RecoveryPointReplicateApiResponsedata',
+        'location': 'str',
+        'message': 'str',
+        'attribute_path': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'metadata': 'metadata',
-        'data': 'data',
+        'location': 'location',
+        'message': 'message',
+        'attribute_path': 'attributePath',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        self.__metadata = None
-        self.__data = None
+    def __init__(self, location=None, message=None, attribute_path=None, *args, **kwargs):  # noqa: E501
+        self.__location = None
+        self.__message = None
+        self.__attribute_path = None
         self.discriminator = None
-        if metadata is not None:
-            self.__metadata = metadata
-        if data is not None:
-            self.__data = data
+        if location is not None:
+            self.__location = location
+        if message is not None:
+            self.__message = message
+        if attribute_path is not None:
+            self.__attribute_path = attribute_path
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'dataprotection.v4.config.RecoveryPointReplicateApiResponse'
+        return 'dataprotection.v4.error.SchemaValidationErrorMessage'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.RecoveryPointReplicateApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def metadata(self):
+    def location(self):
         """
-        
+        The part of the request that failed validation. Validation can fail for path, query parameters, and request body.
 
         :type:
-            :class:`~ntnx_dataprotection_py_client.models.common.v1.response.ApiResponseMetadata`
+
+                :class:`~str`
         """  # noqa: E501
-        return self.__metadata
+        return self.__location
 
-    @metadata.setter
-    def metadata(self, metadata):
+    @location.setter
+    def location(self, location):
 
-        self.__metadata = metadata
+        self.__location = location
 
     @property
-    def data(self):
+    def message(self):
         """
-        
+        The detailed message for the validation error.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__message
+
+    @message.setter
+    def message(self, message):
+
+        self.__message = message
+
+    @property
+    def attribute_path(self):
+        """
+        The path of the attribute that failed validation in the schema.
 
         :type:
-                :class:`~ntnx_dataprotection_py_client.models.storage.v4.config.Task` | 
-                :class:`~ntnx_dataprotection_py_client.models.prism.v4.config.TaskReference` | 
-                :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.error.ErrorResponse`
-                    """  # noqa: E501
-        return self.__data
 
-    @data.setter
-    def data(self, data):
+                :class:`~str`
+        """  # noqa: E501
+        return self.__attribute_path
+
+    @attribute_path.setter
+    def attribute_path(self, attribute_path):
 
-        self.__data = data
+        self.__attribute_path = attribute_path
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -172,39 +193,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
-            if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_dataprotection_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(RecoveryPointReplicateApiResponse, dict):
+        if issubclass(SchemaValidationErrorMessage, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -216,15 +240,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, RecoveryPointReplicateApiResponse):
+        if not isinstance(other, SchemaValidationErrorMessage):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/RecoveryPointRestorationSpec.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/RecoveryPointRestorationSpec.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,37 +3,38 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VmRecoveryPointRestoreOverride import VmRecoveryPointRestoreOverride  # noqa: F401,E501
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VolumeGroupRecoveryPointRestoreOverride import VolumeGroupRecoveryPointRestoreOverride  # noqa: F401,E501
 
 class RecoveryPointRestorationSpec(object):
 
-    """Specification for the restore action on the top-level Recovery point. For a Recovery point that contains multiple VM or volume group Recovery points, users can selectively trigger restore for any specific set of VM or volume group Recovery point(s). In case no particular selection is made, all VM and volume group Recovery points that are a part of the top-level Recovery point will be restored.
+    """Specification for the restore action on the top-level recovery point. For a recovery point that contains multiple VM or volume group recovery points, users can selectively trigger restore for any specific set of VM or volume group recovery point(s). In case no particular selection is made, all VM and volume group recovery points that are a part of the top-level recovery point will be restored.
 
-    :param cluster_ext_id: (:attr:`cluster_ext_id`) Recovery points are restored at the associated location reference by default. However, there is no particular location reference associated with Recovery points located on the cloud. In such a case, the client must specify the external identifier of the cluster on which the entity should be restored.
+    :param cluster_ext_id: (:attr:`cluster_ext_id`) Recovery points are restored at the associated location reference by default. However, there is no particular location reference associated with recovery points located on the cloud. In such a case, the client must specify the external identifier of the cluster on which the entity should be restored.
     :type cluster_ext_id: 
-    :param vm_recovery_point_restore_overrides: (:attr:`vm_recovery_point_restore_overrides`) List of specifications to restore a specific VM Recovery point(s) that are a part of the top-level recovery point. A specific VM Recovery point can be selected for restore by specifying its external identifier along with override specification (if any).
+    :param vm_recovery_point_restore_overrides: (:attr:`vm_recovery_point_restore_overrides`) List of specifications to restore a specific VM recovery point(s) that are a part of the top-level recovery point. A specific VM recovery point can be selected for restore by specifying its external identifier along with override specification (if any).
     :type vm_recovery_point_restore_overrides: 
-    :param volume_group_recovery_point_restore_overrides: (:attr:`volume_group_recovery_point_restore_overrides`) List of specifications to restore a specific volume group Recovery point(s) that are a part of the top-level Recovery point. A specific volume group Recovery point can be selected for restore by specifying its external identifier along with override specification (if any).
+    :param volume_group_recovery_point_restore_overrides: (:attr:`volume_group_recovery_point_restore_overrides`) List of specifications to restore a specific volume group recovery point(s) that are a part of the top-level recovery point. A specific volume group recovery point can be selected for restore by specifying its external identifier along with override specification (if any).
     :type volume_group_recovery_point_restore_overrides: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
@@ -75,33 +76,33 @@
             self.__volume_group_recovery_point_restore_overrides = volume_group_recovery_point_restore_overrides
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'dataprotection.v4.config.RecoveryPointRestorationSpec'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.RecoveryPointRestorationSpec'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -110,15 +111,15 @@
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def cluster_ext_id(self):
         """
-        Recovery points are restored at the associated location reference by default. However, there is no particular location reference associated with Recovery points located on the cloud. In such a case, the client must specify the external identifier of the cluster on which the entity should be restored.
+        Recovery points are restored at the associated location reference by default. However, there is no particular location reference associated with recovery points located on the cloud. In such a case, the client must specify the external identifier of the cluster on which the entity should be restored.
 
         :type:
 
                 :class:`~str`
         """  # noqa: E501
         return self.__cluster_ext_id
 
@@ -128,30 +129,30 @@
             raise ValueError(r"Invalid value for `cluster_ext_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
 
         self.__cluster_ext_id = cluster_ext_id
 
     @property
     def vm_recovery_point_restore_overrides(self):
         """
-        List of specifications to restore a specific VM Recovery point(s) that are a part of the top-level recovery point. A specific VM Recovery point can be selected for restore by specifying its external identifier along with override specification (if any).
+        List of specifications to restore a specific VM recovery point(s) that are a part of the top-level recovery point. A specific VM recovery point can be selected for restore by specifying its external identifier along with override specification (if any).
 
         :type:
              list[ :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.VmRecoveryPointRestoreOverride` ]
         """  # noqa: E501
         return self.__vm_recovery_point_restore_overrides
 
     @vm_recovery_point_restore_overrides.setter
     def vm_recovery_point_restore_overrides(self, vm_recovery_point_restore_overrides):
 
         self.__vm_recovery_point_restore_overrides = vm_recovery_point_restore_overrides
 
     @property
     def volume_group_recovery_point_restore_overrides(self):
         """
-        List of specifications to restore a specific volume group Recovery point(s) that are a part of the top-level Recovery point. A specific volume group Recovery point can be selected for restore by specifying its external identifier along with override specification (if any).
+        List of specifications to restore a specific volume group recovery point(s) that are a part of the top-level recovery point. A specific volume group recovery point can be selected for restore by specifying its external identifier along with override specification (if any).
 
         :type:
              list[ :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.VolumeGroupRecoveryPointRestoreOverride` ]
         """  # noqa: E501
         return self.__volume_group_recovery_point_restore_overrides
 
     @volume_group_recovery_point_restore_overrides.setter
@@ -194,28 +195,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/RecoveryPointRestoreApiResponse.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/VmRecoveryPoint.py`

 * *Files 21% similar despite different names*

```diff
@@ -3,208 +3,207 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_dataprotection_py_client.models
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.RecoveryPointRestoreApiResponsedata import RecoveryPointRestoreApiResponsedata  # noqa: F401,E501
-from ntnx_dataprotection_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
-
-class RecoveryPointRestoreApiResponse(object):
-
-    """REST response for all response codes in API path /dataprotection/v4.0.a4/config/recovery-points/{extId}/$actions/restore Post operation
-
-    :param metadata: (:attr:`metadata`) 
-    :type metadata: 
-    :param data: (:attr:`data`) 
-    :type data: 
+from pathlib import Path
+from ntnx_dataprotection_py_client.models.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
+from ntnx_dataprotection_py_client.models.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel  # noqa: F401,E501
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.DiskRecoveryPoint import DiskRecoveryPoint  # noqa: F401,E501
+
+class VmRecoveryPoint(ExternalizableAbstractModel):
+
+    """A model that represents VM recovery point properties.
+
+    :param location_agnostic_id: (:attr:`location_agnostic_id`) Location agnostic identifier of the recovery point. This identifier is used to identify the same instances of a recovery point across different sites.
+    :type location_agnostic_id: 
+    :param vm_ext_id: (:attr:`vm_ext_id`) VM external identifier which is captured as part of this recovery point.
+    :type vm_ext_id: required
+    :param vm_categories: (:attr:`vm_categories`) Category key-value pairs associated with the VM at the time of recovery point creation. The category key and value are separated by '/'. For example, a category with key 'dept' and value 'hr' will be represented as 'dept/hr'.
+    :type vm_categories: 
+    :param disk_recovery_points: (:attr:`disk_recovery_points`) 
+    :type disk_recovery_points: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfdataprotection.v4.config.RecoveryPointRestoreApiResponsedata',
+        'location_agnostic_id': 'str',
+        'vm_ext_id': 'str',
+        'vm_categories': 'list[str]',
+        'disk_recovery_points': 'list[dataprotection.v4.config.DiskRecoveryPoint]',
+        'ext_id': 'str',
+        'links': 'list[common.v1.response.ApiLink]',
+        'tenant_id': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'metadata': 'metadata',
-        'data': 'data',
+        'location_agnostic_id': 'locationAgnosticId',
+        'vm_ext_id': 'vmExtId',
+        'vm_categories': 'vmCategories',
+        'disk_recovery_points': 'diskRecoveryPoints',
+        'ext_id': 'extId',
+        'links': 'links',
+        'tenant_id': 'tenantId',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        self.__metadata = None
-        self.__data = None
+    def __init__(self, location_agnostic_id=None, vm_ext_id=None, vm_categories=None, disk_recovery_points=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
+        ExternalizableAbstractModel.__init__(self, ext_id, links, tenant_id, *args, **kwargs)
+        self.__location_agnostic_id = None
+        self.__vm_ext_id = None
+        self.__vm_categories = None
+        self.__disk_recovery_points = None
         self.discriminator = None
-        if metadata is not None:
-            self.__metadata = metadata
-        if data is not None:
-            self.__data = data
-        # populate hidden vars if not empty
-        self._populate_hidden_vars(kwargs)
+        if location_agnostic_id is not None:
+            self.__location_agnostic_id = location_agnostic_id
+        self.__vm_ext_id = vm_ext_id
+        if vm_categories is not None:
+            self.__vm_categories = vm_categories
+        if disk_recovery_points is not None:
+            self.__disk_recovery_points = disk_recovery_points
 
     def _initialize_object_type(self):
-        return 'dataprotection.v4.config.RecoveryPointRestoreApiResponse'
+        return 'dataprotection.v4.config.VmRecoveryPoint'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.RecoveryPointRestoreApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
-    def _populate_hidden_vars(self, kwargs):
-        if "_reserved" in kwargs and kwargs["_reserved"] is not None:
-            self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
-            self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
-        else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
-        if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
-            self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
-            self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
-        else :
-            self.__dollar_unknown_fields = {}
-        if "_object_type" in kwargs and kwargs["_object_type"] is not None:
-            self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
-            self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
-        else:
-            self.__dollar_object_type = self._initialize_object_type()
-
-    def get_object_type(self):
-        return self.__dollar_object_type
-
-    def get_reserved(self):
-        return self.__dollar_reserved
-
-    def get_unknown_fields(self):
-        return self.__dollar_unknown_fields
 
     @property
-    def metadata(self):
+    def location_agnostic_id(self):
         """
-        
+        Location agnostic identifier of the recovery point. This identifier is used to identify the same instances of a recovery point across different sites.
 
         :type:
-            :class:`~ntnx_dataprotection_py_client.models.common.v1.response.ApiResponseMetadata`
+
+                :class:`~str`
         """  # noqa: E501
-        return self.__metadata
+        return self.__location_agnostic_id
 
-    @metadata.setter
-    def metadata(self, metadata):
+    @location_agnostic_id.setter
+    def location_agnostic_id(self, location_agnostic_id):
+        if location_agnostic_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', location_agnostic_id):  # noqa: E501
+            raise ValueError(r"Invalid value for `location_agnostic_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
 
-        self.__metadata = metadata
+        self.__location_agnostic_id = location_agnostic_id
 
     @property
-    def data(self):
+    def vm_ext_id(self):
         """
-        
+        VM external identifier which is captured as part of this recovery point.
 
         :type:
-                :class:`~ntnx_dataprotection_py_client.models.storage.v4.config.Task` | 
-                :class:`~ntnx_dataprotection_py_client.models.prism.v4.config.TaskReference` | 
-                :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.error.ErrorResponse`
-                    """  # noqa: E501
-        return self.__data
 
-    @data.setter
-    def data(self, data):
+                :class:`~str`
+        """  # noqa: E501
+        return self.__vm_ext_id
 
-        self.__data = data
+    @vm_ext_id.setter
+    def vm_ext_id(self, vm_ext_id):
+        if vm_ext_id is None:
+            raise ValueError("Invalid value for `vm_ext_id`, must not be `None`")  # noqa: E501
+        if vm_ext_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', vm_ext_id):  # noqa: E501
+            raise ValueError(r"Invalid value for `vm_ext_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
+
+        self.__vm_ext_id = vm_ext_id
 
     @property
-    def _reserved(self):
+    def vm_categories(self):
         """
-        
+        Category key-value pairs associated with the VM at the time of recovery point creation. The category key and value are separated by '/'. For example, a category with key 'dept' and value 'hr' will be represented as 'dept/hr'.
 
         :type:
-            dict(str, :class:`~object`)
+            list[ :class:`~str` ]
         """  # noqa: E501
-        return self.__dollar_reserved
+        return self.__vm_categories
 
-    @property
-    def _object_type(self):
-        """
-        
+    @vm_categories.setter
+    def vm_categories(self, vm_categories):
 
-        :type:
-
-                :class:`~str`
-        """  # noqa: E501
-        return self.__dollar_object_type
+        self.__vm_categories = vm_categories
 
     @property
-    def _unknown_fields(self):
+    def disk_recovery_points(self):
         """
         
 
         :type:
-            dict(str, :class:`~object`)
+             list[ :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.DiskRecoveryPoint` ]
         """  # noqa: E501
-        return self.__dollar_unknown_fields
+        return self.__disk_recovery_points
+
+    @disk_recovery_points.setter
+    def disk_recovery_points(self, disk_recovery_points):
+
+        self.__disk_recovery_points = disk_recovery_points
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
-            if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_dataprotection_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(RecoveryPointRestoreApiResponse, dict):
+        if issubclass(VmRecoveryPoint, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -216,15 +215,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, RecoveryPointRestoreApiResponse):
+        if not isinstance(other, VmRecoveryPoint):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/Regions.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ExpirationTimeSpec.py`

 * *Files 18% similar despite different names*

```diff
@@ -3,140 +3,119 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class Regions(object):
+class ExpirationTimeSpec(object):
 
-    """Changed Regions list comprising of offset and regions length pertaining to the Disk Recovery Point.
+    """Specification to set the expiration time of the recovery point.
 
-    :param offset: (:attr:`offset`) The byte offset indicating the start of the regions.
-    :type offset: 
-    :param length: (:attr:`length`) The length of the regions in bytes.
-    :type length: 
+    :param expiration_time: (:attr:`expiration_time`) The UTC date and time in ISO-8601 format when the current recovery point expires . If not specified, the recovery point will never expire.
+    :type expiration_time: required
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'offset': 'int',
-        'length': 'int',
+        'expiration_time': 'datetime',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'offset': 'offset',
-        'length': 'length',
+        'expiration_time': 'expirationTime',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, offset=None, length=None, *args, **kwargs):  # noqa: E501
-        self.__offset = None
-        self.__length = None
+    def __init__(self, expiration_time=None, *args, **kwargs):  # noqa: E501
+        self.__expiration_time = None
         self.discriminator = None
-        if offset is not None:
-            self.__offset = offset
-        if length is not None:
-            self.__length = length
+        self.__expiration_time = expiration_time
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'dataprotection.v4.config.Regions'
+        return 'dataprotection.v4.config.ExpirationTimeSpec'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.Regions'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def offset(self):
+    def expiration_time(self):
         """
-        The byte offset indicating the start of the regions.
+        The UTC date and time in ISO-8601 format when the current recovery point expires . If not specified, the recovery point will never expire.
 
         :type:
 
-                :class:`~int`
+                :class:`~datetime`
         """  # noqa: E501
-        return self.__offset
+        return self.__expiration_time
 
-    @offset.setter
-    def offset(self, offset):
+    @expiration_time.setter
+    def expiration_time(self, expiration_time):
+        if expiration_time is None:
+            raise ValueError("Invalid value for `expiration_time`, must not be `None`")  # noqa: E501
 
-        self.__offset = offset
-
-    @property
-    def length(self):
-        """
-        The length of the regions in bytes.
-
-        :type:
-
-                :class:`~int`
-        """  # noqa: E501
-        return self.__length
-
-    @length.setter
-    def length(self, length):
-
-        self.__length = length
+        self.__expiration_time = expiration_time
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -169,37 +148,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(Regions, dict):
+        if issubclass(ExpirationTimeSpec, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -211,15 +195,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, Regions):
+        if not isinstance(other, ExpirationTimeSpec):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ReplicationState.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ReplicationState.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,36 +3,37 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.DataProtectionSiteReference import DataProtectionSiteReference  # noqa: F401,E501
 from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ProtectedResourceReplicationStatus import ProtectedResourceReplicationStatus  # noqa: F401,E501
 
 class ReplicationState(object):
 
     """Replication related information about the protected resource.
 
-    :param protection_policy_reference: (:attr:`protection_policy_reference`) The external identifier of the protection policy associated with the protected resource.
-    :type protection_policy_reference: 
-    :param recovery_point_objective: (:attr:`recovery_point_objective`) The recovery point objective of the schedule in seconds.
-    :type recovery_point_objective: 
+    :param protection_policy_ext_id: (:attr:`protection_policy_ext_id`) The external identifier of the Protection policy associated with the protected resource.
+    :type protection_policy_ext_id: 
+    :param recovery_point_objective_seconds: (:attr:`recovery_point_objective_seconds`) The recovery point objective of the schedule in seconds.
+    :type recovery_point_objective_seconds: 
     :param replication_status: (:attr:`replication_status`) 
     :type replication_status: 
     :param target_site_reference: (:attr:`target_site_reference`) 
     :type target_site_reference: 
 
     """
     """
@@ -41,120 +42,124 @@
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'protection_policy_reference': 'str',
-        'recovery_point_objective': 'int',
+        'protection_policy_ext_id': 'str',
+        'recovery_point_objective_seconds': 'int',
         'replication_status': 'dataprotection.v4.config.ProtectedResourceReplicationStatus',
         'target_site_reference': 'dataprotection.v4.config.DataProtectionSiteReference',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'protection_policy_reference': 'protectionPolicyReference',
-        'recovery_point_objective': 'recoveryPointObjective',
+        'protection_policy_ext_id': 'protectionPolicyExtId',
+        'recovery_point_objective_seconds': 'recoveryPointObjectiveSeconds',
         'replication_status': 'replicationStatus',
         'target_site_reference': 'targetSiteReference',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, protection_policy_reference=None, recovery_point_objective=None, replication_status=None, target_site_reference=None, *args, **kwargs):  # noqa: E501
-        self.__protection_policy_reference = None
-        self.__recovery_point_objective = None
+    def __init__(self, protection_policy_ext_id=None, recovery_point_objective_seconds=None, replication_status=None, target_site_reference=None, *args, **kwargs):  # noqa: E501
+        self.__protection_policy_ext_id = None
+        self.__recovery_point_objective_seconds = None
         self.__replication_status = None
         self.__target_site_reference = None
         self.discriminator = None
-        if protection_policy_reference is not None:
-            self.__protection_policy_reference = protection_policy_reference
-        if recovery_point_objective is not None:
-            self.__recovery_point_objective = recovery_point_objective
+        if protection_policy_ext_id is not None:
+            self.__protection_policy_ext_id = protection_policy_ext_id
+        if recovery_point_objective_seconds is not None:
+            self.__recovery_point_objective_seconds = recovery_point_objective_seconds
         if replication_status is not None:
             self.__replication_status = replication_status
         if target_site_reference is not None:
             self.__target_site_reference = target_site_reference
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'dataprotection.v4.config.ReplicationState'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.ReplicationState'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def protection_policy_reference(self):
+    def protection_policy_ext_id(self):
         """
-        The external identifier of the protection policy associated with the protected resource.
+        The external identifier of the Protection policy associated with the protected resource.
 
         :type:
 
                 :class:`~str`
         """  # noqa: E501
-        return self.__protection_policy_reference
+        return self.__protection_policy_ext_id
 
-    @protection_policy_reference.setter
-    def protection_policy_reference(self, protection_policy_reference):
-        if protection_policy_reference is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', protection_policy_reference):  # noqa: E501
-            raise ValueError(r"Invalid value for `protection_policy_reference`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
+    @protection_policy_ext_id.setter
+    def protection_policy_ext_id(self, protection_policy_ext_id):
+        if protection_policy_ext_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', protection_policy_ext_id):  # noqa: E501
+            raise ValueError(r"Invalid value for `protection_policy_ext_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
 
-        self.__protection_policy_reference = protection_policy_reference
+        self.__protection_policy_ext_id = protection_policy_ext_id
 
     @property
-    def recovery_point_objective(self):
+    def recovery_point_objective_seconds(self):
         """
         The recovery point objective of the schedule in seconds.
 
         :type:
 
                 :class:`~int`
         """  # noqa: E501
-        return self.__recovery_point_objective
+        return self.__recovery_point_objective_seconds
 
-    @recovery_point_objective.setter
-    def recovery_point_objective(self, recovery_point_objective):
+    @recovery_point_objective_seconds.setter
+    def recovery_point_objective_seconds(self, recovery_point_objective_seconds):
+        if recovery_point_objective_seconds is not None and recovery_point_objective_seconds > 2419200:  # noqa: E501
+            raise ValueError("Invalid value for `recovery_point_objective_seconds`, must be a value less than or equal to `2419200`")  # noqa: E501
+        if recovery_point_objective_seconds is not None and recovery_point_objective_seconds < 0:  # noqa: E501
+            raise ValueError("Invalid value for `recovery_point_objective_seconds`, must be a value greater than or equal to `0`")  # noqa: E501
 
-        self.__recovery_point_objective = recovery_point_objective
+        self.__recovery_point_objective_seconds = recovery_point_objective_seconds
 
     @property
     def replication_status(self):
         """
         
 
         :type:
@@ -217,28 +222,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/RestorableTimeRange.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/error/SchemaValidationError.py`

 * *Files 22% similar despite different names*

```diff
@@ -3,140 +3,210 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
+from ntnx_dataprotection_py_client.models.dataprotection.v4.error.SchemaValidationErrorMessage import SchemaValidationErrorMessage  # noqa: F401,E501
 
-class RestorableTimeRange(object):
+class SchemaValidationError(object):
 
-    """The start and end time details, both inclusively represent the range of time during which the entity is restorable.
+    """This schema is generated from SchemaValidationError.java
 
-    :param start_time: (:attr:`start_time`) UTC date and time in ISO 8601 format representing the time when the restorable time range for the entity starts.
-    :type start_time: 
-    :param end_time: (:attr:`end_time`) UTC date and time in ISO 8601 format representing the time when the restorable time range for the entity ends.
-    :type end_time: 
+    :param timestamp: (:attr:`timestamp`) Timestamp of the response.
+    :type timestamp: 
+    :param status_code: (:attr:`status_code`) The HTTP status code of the response.
+    :type status_code: 
+    :param error: (:attr:`error`) The generic error message for the response.
+    :type error: 
+    :param path: (:attr:`path`) API path on which the request was made.
+    :type path: 
+    :param validation_error_messages: (:attr:`validation_error_messages`) List of validation error messages
+    :type validation_error_messages: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'start_time': 'datetime',
-        'end_time': 'datetime',
+        'timestamp': 'str',
+        'status_code': 'int',
+        'error': 'str',
+        'path': 'str',
+        'validation_error_messages': 'list[dataprotection.v4.error.SchemaValidationErrorMessage]',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'start_time': 'startTime',
-        'end_time': 'endTime',
+        'timestamp': 'timestamp',
+        'status_code': 'statusCode',
+        'error': 'error',
+        'path': 'path',
+        'validation_error_messages': 'validationErrorMessages',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, start_time=None, end_time=None, *args, **kwargs):  # noqa: E501
-        self.__start_time = None
-        self.__end_time = None
+    def __init__(self, timestamp=None, status_code=None, error=None, path=None, validation_error_messages=None, *args, **kwargs):  # noqa: E501
+        self.__timestamp = None
+        self.__status_code = None
+        self.__error = None
+        self.__path = None
+        self.__validation_error_messages = None
         self.discriminator = None
-        if start_time is not None:
-            self.__start_time = start_time
-        if end_time is not None:
-            self.__end_time = end_time
+        if timestamp is not None:
+            self.__timestamp = timestamp
+        if status_code is not None:
+            self.__status_code = status_code
+        if error is not None:
+            self.__error = error
+        if path is not None:
+            self.__path = path
+        if validation_error_messages is not None:
+            self.__validation_error_messages = validation_error_messages
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'dataprotection.v4.config.RestorableTimeRange'
+        return 'dataprotection.v4.error.SchemaValidationError'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.RestorableTimeRange'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def start_time(self):
+    def timestamp(self):
         """
-        UTC date and time in ISO 8601 format representing the time when the restorable time range for the entity starts.
+        Timestamp of the response.
 
         :type:
 
-                :class:`~datetime`
+                :class:`~str`
+        """  # noqa: E501
+        return self.__timestamp
+
+    @timestamp.setter
+    def timestamp(self, timestamp):
+
+        self.__timestamp = timestamp
+
+    @property
+    def status_code(self):
+        """
+        The HTTP status code of the response.
+
+        :type:
+
+                :class:`~int`
         """  # noqa: E501
-        return self.__start_time
+        return self.__status_code
 
-    @start_time.setter
-    def start_time(self, start_time):
+    @status_code.setter
+    def status_code(self, status_code):
 
-        self.__start_time = start_time
+        self.__status_code = status_code
 
     @property
-    def end_time(self):
+    def error(self):
         """
-        UTC date and time in ISO 8601 format representing the time when the restorable time range for the entity ends.
+        The generic error message for the response.
 
         :type:
 
-                :class:`~datetime`
+                :class:`~str`
         """  # noqa: E501
-        return self.__end_time
+        return self.__error
 
-    @end_time.setter
-    def end_time(self, end_time):
+    @error.setter
+    def error(self, error):
 
-        self.__end_time = end_time
+        self.__error = error
+
+    @property
+    def path(self):
+        """
+        API path on which the request was made.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__path
+
+    @path.setter
+    def path(self, path):
+
+        self.__path = path
+
+    @property
+    def validation_error_messages(self):
+        """
+        List of validation error messages
+
+        :type:
+             list[ :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.error.SchemaValidationErrorMessage` ]
+        """  # noqa: E501
+        return self.__validation_error_messages
+
+    @validation_error_messages.setter
+    def validation_error_messages(self, validation_error_messages):
+
+        self.__validation_error_messages = validation_error_messages
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -169,37 +239,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(RestorableTimeRange, dict):
+        if issubclass(SchemaValidationError, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -211,15 +286,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, RestorableTimeRange):
+        if not isinstance(other, SchemaValidationError):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/SetExpirationTimeSpec.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/NutanixObjectsBucket.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,118 +3,118 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class SetExpirationTimeSpec(object):
+class NutanixObjectsBucket(object):
 
-    """Specification to set the expiration time of the Recovery point.
+    """Reference to the Nutanix Objects bucket.
 
-    :param expiration_time: (:attr:`expiration_time`) The UTC date and time in ISO-8601 format when the current Recovery point expires and will be garbage collected. If not specified, the Recovery point will never expire.
-    :type expiration_time: required
+    :param end_point: (:attr:`end_point`) URI of the Nutanix Objects bucket.
+    :type end_point: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'expiration_time': 'datetime',
+        'end_point': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'expiration_time': 'expirationTime',
+        'end_point': 'endPoint',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, expiration_time=None, *args, **kwargs):  # noqa: E501
-        self.__expiration_time = None
+    def __init__(self, end_point=None, *args, **kwargs):  # noqa: E501
+        self.__end_point = None
         self.discriminator = None
-        self.__expiration_time = expiration_time
+        if end_point is not None:
+            self.__end_point = end_point
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'dataprotection.v4.config.SetExpirationTimeSpec'
+        return 'dataprotection.v4.config.NutanixObjectsBucket'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.SetExpirationTimeSpec'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def expiration_time(self):
+    def end_point(self):
         """
-        The UTC date and time in ISO-8601 format when the current Recovery point expires and will be garbage collected. If not specified, the Recovery point will never expire.
+        URI of the Nutanix Objects bucket.
 
         :type:
 
-                :class:`~datetime`
+                :class:`~str`
         """  # noqa: E501
-        return self.__expiration_time
+        return self.__end_point
 
-    @expiration_time.setter
-    def expiration_time(self, expiration_time):
-        if expiration_time is None:
-            raise ValueError("Invalid value for `expiration_time`, must not be `None`")  # noqa: E501
+    @end_point.setter
+    def end_point(self, end_point):
 
-        self.__expiration_time = expiration_time
+        self.__end_point = end_point
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -147,37 +147,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(SetExpirationTimeSpec, dict):
+        if issubclass(NutanixObjectsBucket, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -189,15 +194,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, SetExpirationTimeSpec):
+        if not isinstance(other, NutanixObjectsBucket):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/SiteReference.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/VolumeGroupRecoveryPoint.py`

 * *Files 24% similar despite different names*

```diff
@@ -3,207 +3,184 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-
-class SiteReference(object):
-
-    """Specification corresponding to the cluster reference information along with the related AZ information.
-
-    :param availability_zone_reference: (:attr:`availability_zone_reference`) The UUID corresponding to the Availability Zone where an entity resides or is synced.
-    :type availability_zone_reference: 
-    :param cluster_reference: (:attr:`cluster_reference`) The UUID corresponding to the cluster where an entity resides or is synced.
-    :type cluster_reference: 
+from pathlib import Path
+from ntnx_dataprotection_py_client.models.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
+from ntnx_dataprotection_py_client.models.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel  # noqa: F401,E501
+
+class VolumeGroupRecoveryPoint(ExternalizableAbstractModel):
+
+    """A model that represents volume group recovery point properties.
+
+    :param location_agnostic_id: (:attr:`location_agnostic_id`) Location agnostic identifier of the recovery point. This identifier is used to identify the same instances of a recovery point across different sites.
+    :type location_agnostic_id: 
+    :param volume_group_ext_id: (:attr:`volume_group_ext_id`) Volume Group external identifier which is captured as part of this recovery point.
+    :type volume_group_ext_id: required
+    :param volume_group_categories: (:attr:`volume_group_categories`) Category key-value pairs associated with the volume group at the time of recovery point creation. The category key and value are separated by '/'. For example, a category with key 'dept' and value 'hr' will be represented as 'dept/hr'.
+    :type volume_group_categories: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'availability_zone_reference': 'str',
-        'cluster_reference': 'str',
+        'location_agnostic_id': 'str',
+        'volume_group_ext_id': 'str',
+        'volume_group_categories': 'list[str]',
+        'ext_id': 'str',
+        'links': 'list[common.v1.response.ApiLink]',
+        'tenant_id': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'availability_zone_reference': 'availabilityZoneReference',
-        'cluster_reference': 'clusterReference',
+        'location_agnostic_id': 'locationAgnosticId',
+        'volume_group_ext_id': 'volumeGroupExtId',
+        'volume_group_categories': 'volumeGroupCategories',
+        'ext_id': 'extId',
+        'links': 'links',
+        'tenant_id': 'tenantId',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, availability_zone_reference=None, cluster_reference=None, *args, **kwargs):  # noqa: E501
-        self.__availability_zone_reference = None
-        self.__cluster_reference = None
+    def __init__(self, location_agnostic_id=None, volume_group_ext_id=None, volume_group_categories=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
+        ExternalizableAbstractModel.__init__(self, ext_id, links, tenant_id, *args, **kwargs)
+        self.__location_agnostic_id = None
+        self.__volume_group_ext_id = None
+        self.__volume_group_categories = None
         self.discriminator = None
-        if availability_zone_reference is not None:
-            self.__availability_zone_reference = availability_zone_reference
-        if cluster_reference is not None:
-            self.__cluster_reference = cluster_reference
-        # populate hidden vars if not empty
-        self._populate_hidden_vars(kwargs)
+        if location_agnostic_id is not None:
+            self.__location_agnostic_id = location_agnostic_id
+        self.__volume_group_ext_id = volume_group_ext_id
+        if volume_group_categories is not None:
+            self.__volume_group_categories = volume_group_categories
 
     def _initialize_object_type(self):
-        return 'dataprotection.v4.config.SiteReference'
-
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.SiteReference'
-
-    def _populate_hidden_vars(self, kwargs):
-        if "_reserved" in kwargs and kwargs["_reserved"] is not None:
-            self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
-            self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
-        else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
-        if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
-            self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
-            self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
-        else :
-            self.__dollar_unknown_fields = {}
-        if "_object_type" in kwargs and kwargs["_object_type"] is not None:
-            self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
-            self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
-        else:
-            self.__dollar_object_type = self._initialize_object_type()
-
-    def get_object_type(self):
-        return self.__dollar_object_type
+        return 'dataprotection.v4.config.VolumeGroupRecoveryPoint'
 
-    def get_reserved(self):
-        return self.__dollar_reserved
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
-    def get_unknown_fields(self):
-        return self.__dollar_unknown_fields
 
     @property
-    def availability_zone_reference(self):
+    def location_agnostic_id(self):
         """
-        The UUID corresponding to the Availability Zone where an entity resides or is synced.
+        Location agnostic identifier of the recovery point. This identifier is used to identify the same instances of a recovery point across different sites.
 
         :type:
 
                 :class:`~str`
         """  # noqa: E501
-        return self.__availability_zone_reference
+        return self.__location_agnostic_id
 
-    @availability_zone_reference.setter
-    def availability_zone_reference(self, availability_zone_reference):
-        if availability_zone_reference is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', availability_zone_reference):  # noqa: E501
-            raise ValueError(r"Invalid value for `availability_zone_reference`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
+    @location_agnostic_id.setter
+    def location_agnostic_id(self, location_agnostic_id):
+        if location_agnostic_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', location_agnostic_id):  # noqa: E501
+            raise ValueError(r"Invalid value for `location_agnostic_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
 
-        self.__availability_zone_reference = availability_zone_reference
+        self.__location_agnostic_id = location_agnostic_id
 
     @property
-    def cluster_reference(self):
+    def volume_group_ext_id(self):
         """
-        The UUID corresponding to the cluster where an entity resides or is synced.
+        Volume Group external identifier which is captured as part of this recovery point.
 
         :type:
 
                 :class:`~str`
         """  # noqa: E501
-        return self.__cluster_reference
+        return self.__volume_group_ext_id
 
-    @cluster_reference.setter
-    def cluster_reference(self, cluster_reference):
-        if cluster_reference is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', cluster_reference):  # noqa: E501
-            raise ValueError(r"Invalid value for `cluster_reference`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
+    @volume_group_ext_id.setter
+    def volume_group_ext_id(self, volume_group_ext_id):
+        if volume_group_ext_id is None:
+            raise ValueError("Invalid value for `volume_group_ext_id`, must not be `None`")  # noqa: E501
+        if volume_group_ext_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', volume_group_ext_id):  # noqa: E501
+            raise ValueError(r"Invalid value for `volume_group_ext_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
 
-        self.__cluster_reference = cluster_reference
+        self.__volume_group_ext_id = volume_group_ext_id
 
     @property
-    def _reserved(self):
+    def volume_group_categories(self):
         """
-        
+        Category key-value pairs associated with the volume group at the time of recovery point creation. The category key and value are separated by '/'. For example, a category with key 'dept' and value 'hr' will be represented as 'dept/hr'.
 
         :type:
-            dict(str, :class:`~object`)
+            list[ :class:`~str` ]
         """  # noqa: E501
-        return self.__dollar_reserved
+        return self.__volume_group_categories
 
-    @property
-    def _object_type(self):
-        """
-        
+    @volume_group_categories.setter
+    def volume_group_categories(self, volume_group_categories):
 
-        :type:
-
-                :class:`~str`
-        """  # noqa: E501
-        return self.__dollar_object_type
-
-    @property
-    def _unknown_fields(self):
-        """
-        
-
-        :type:
-            dict(str, :class:`~object`)
-        """  # noqa: E501
-        return self.__dollar_unknown_fields
+        self.__volume_group_categories = volume_group_categories
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(SiteReference, dict):
+        if issubclass(VolumeGroupRecoveryPoint, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +192,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, SiteReference):
+        if not isinstance(other, VolumeGroupRecoveryPoint):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/Subnet.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/common/v1/config/Flag.py`

 * *Files 15% similar despite different names*

```diff
@@ -3,117 +3,141 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_dataprotection_py_client.models.common.v1.config.IPv4Address import IPv4Address  # noqa: F401,E501
+from pathlib import Path
 
-class Subnet(object):
+class Flag(object):
 
-    """CIDR of the network gateway.
+    """Many entities in the Nutanix APIs carry flags.  This object captures all the flags associated with that entity through this object.  The field that hosts this type of object must have an attribute called x-bounded-map-keys that tells which flags are actually present for that entity. 
 
-    :param ipv4: (:attr:`ipv4`) 
-    :type ipv4: 
+    :param name: (:attr:`name`) 
+    :type name: 
+    :param value: (:attr:`value`) 
+    :type value: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'ipv4': 'common.v1.config.IPv4Address',
+        'name': 'str',
+        'value': 'bool',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'ipv4': 'ipv4',
+        'name': 'name',
+        'value': 'value',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, ipv4=None, *args, **kwargs):  # noqa: E501
-        self.__ipv4 = None
+    def __init__(self, name=None, value=False, *args, **kwargs):  # noqa: E501
+        self.__name = None
+        self.__value = None
         self.discriminator = None
-        if ipv4 is not None:
-            self.__ipv4 = ipv4
+        if name is not None:
+            self.__name = name
+        if value is not None:
+            self.__value = value
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'dataprotection.v4.config.Subnet'
+        return 'common.v1.config.Flag'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.Subnet'
+    def _initialize_object_version(self):
+        return 'v1.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def ipv4(self):
+    def name(self):
         """
         
 
         :type:
-            :class:`~ntnx_dataprotection_py_client.models.common.v1.config.IPv4Address`
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__name
+
+    @name.setter
+    def name(self, name):
+
+        self.__name = name
+
+    @property
+    def value(self):
+        """
+        
+
+        :type:
+
+                :class:`~bool`
         """  # noqa: E501
-        return self.__ipv4
+        return self.__value
 
-    @ipv4.setter
-    def ipv4(self, ipv4):
+    @value.setter
+    def value(self, value):
 
-        self.__ipv4 = ipv4
+        self.__value = value
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -146,37 +170,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(Subnet, dict):
+        if issubclass(Flag, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -188,15 +217,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, Subnet):
+        if not isinstance(other, Flag):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/SyncedVolumeGroupByIdApiResponse.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/VmRecoveryPointRestoreOverride.py`

 * *Files 24% similar despite different names*

```diff
@@ -3,142 +3,120 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_dataprotection_py_client.models
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.SyncedVolumeGroupByIdApiResponsedata import SyncedVolumeGroupByIdApiResponsedata  # noqa: F401,E501
-from ntnx_dataprotection_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
-
-class SyncedVolumeGroupByIdApiResponse(object):
-
-    """REST response for all response codes in API path /dataprotection/v4.0.a4/config/synced-volume-groups/{extId} Get operation
-
-    :param metadata: (:attr:`metadata`) 
-    :type metadata: 
-    :param data: (:attr:`data`) 
-    :type data: 
+from pathlib import Path
+
+class VmRecoveryPointRestoreOverride(object):
+
+    """
+
+    :param vm_recovery_point_ext_id: (:attr:`vm_recovery_point_ext_id`) External identifier of a VM recovery point, that is a part of the top-level recovery point (Note: This attribute will be removed in future releases, use VM recovery point external identifier instead).
+    :type vm_recovery_point_ext_id: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfdataprotection.v4.config.SyncedVolumeGroupByIdApiResponsedata',
+        'vm_recovery_point_ext_id': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'metadata': 'metadata',
-        'data': 'data',
+        'vm_recovery_point_ext_id': 'vmRecoveryPointExtId',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        self.__metadata = None
-        self.__data = None
+    def __init__(self, vm_recovery_point_ext_id=None, *args, **kwargs):  # noqa: E501
+        self.__vm_recovery_point_ext_id = None
         self.discriminator = None
-        if metadata is not None:
-            self.__metadata = metadata
-        if data is not None:
-            self.__data = data
+        if vm_recovery_point_ext_id is not None:
+            self.__vm_recovery_point_ext_id = vm_recovery_point_ext_id
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'dataprotection.v4.config.SyncedVolumeGroupByIdApiResponse'
+        return 'dataprotection.v4.config.VmRecoveryPointRestoreOverride'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.SyncedVolumeGroupByIdApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def metadata(self):
+    def vm_recovery_point_ext_id(self):
         """
-        
+        External identifier of a VM recovery point, that is a part of the top-level recovery point (Note: This attribute will be removed in future releases, use VM recovery point external identifier instead).
 
         :type:
-            :class:`~ntnx_dataprotection_py_client.models.common.v1.response.ApiResponseMetadata`
-        """  # noqa: E501
-        return self.__metadata
-
-    @metadata.setter
-    def metadata(self, metadata):
 
-        self.__metadata = metadata
-
-    @property
-    def data(self):
-        """
-        
-
-        :type:
-                :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.VolumeGroupSyncContext` | 
-                :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.error.ErrorResponse`
-                    """  # noqa: E501
-        return self.__data
+                :class:`~str`
+        """  # noqa: E501
+        return self.__vm_recovery_point_ext_id
 
-    @data.setter
-    def data(self, data):
+    @vm_recovery_point_ext_id.setter
+    def vm_recovery_point_ext_id(self, vm_recovery_point_ext_id):
+        if vm_recovery_point_ext_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', vm_recovery_point_ext_id):  # noqa: E501
+            raise ValueError(r"Invalid value for `vm_recovery_point_ext_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
 
-        self.__data = data
+        self.__vm_recovery_point_ext_id = vm_recovery_point_ext_id
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -171,39 +149,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
-            if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_dataprotection_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(SyncedVolumeGroupByIdApiResponse, dict):
+        if issubclass(VmRecoveryPointRestoreOverride, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +196,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, SyncedVolumeGroupByIdApiResponse):
+        if not isinstance(other, VmRecoveryPointRestoreOverride):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/SynchronousReplicaPromoteApiResponse.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/DataProtectionSiteReference.py`

 * *Files 20% similar despite different names*

```diff
@@ -3,142 +3,145 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_dataprotection_py_client.models
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.SynchronousReplicaPromoteApiResponsedata import SynchronousReplicaPromoteApiResponsedata  # noqa: F401,E501
-from ntnx_dataprotection_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
-
-class SynchronousReplicaPromoteApiResponse(object):
-
-    """REST response for all response codes in API path /dataprotection/v4.0.a4/config/synced-volume-groups/{extId}/$actions/promote Post operation
-
-    :param metadata: (:attr:`metadata`) 
-    :type metadata: 
-    :param data: (:attr:`data`) 
-    :type data: 
+from pathlib import Path
+
+class DataProtectionSiteReference(object):
+
+    """
+
+    :param mgmt_cluster_ext_id: (:attr:`mgmt_cluster_ext_id`) External identifier of the Prism Central.
+    :type mgmt_cluster_ext_id: 
+    :param cluster_ext_id: (:attr:`cluster_ext_id`) External identifier of the cluster.
+    :type cluster_ext_id: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfdataprotection.v4.config.SynchronousReplicaPromoteApiResponsedata',
+        'mgmt_cluster_ext_id': 'str',
+        'cluster_ext_id': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'metadata': 'metadata',
-        'data': 'data',
+        'mgmt_cluster_ext_id': 'mgmtClusterExtId',
+        'cluster_ext_id': 'clusterExtId',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        self.__metadata = None
-        self.__data = None
+    def __init__(self, mgmt_cluster_ext_id=None, cluster_ext_id=None, *args, **kwargs):  # noqa: E501
+        self.__mgmt_cluster_ext_id = None
+        self.__cluster_ext_id = None
         self.discriminator = None
-        if metadata is not None:
-            self.__metadata = metadata
-        if data is not None:
-            self.__data = data
+        if mgmt_cluster_ext_id is not None:
+            self.__mgmt_cluster_ext_id = mgmt_cluster_ext_id
+        if cluster_ext_id is not None:
+            self.__cluster_ext_id = cluster_ext_id
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'dataprotection.v4.config.SynchronousReplicaPromoteApiResponse'
+        return 'dataprotection.v4.config.DataProtectionSiteReference'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.SynchronousReplicaPromoteApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def metadata(self):
+    def mgmt_cluster_ext_id(self):
         """
-        
+        External identifier of the Prism Central.
 
         :type:
-            :class:`~ntnx_dataprotection_py_client.models.common.v1.response.ApiResponseMetadata`
+
+                :class:`~str`
         """  # noqa: E501
-        return self.__metadata
+        return self.__mgmt_cluster_ext_id
 
-    @metadata.setter
-    def metadata(self, metadata):
+    @mgmt_cluster_ext_id.setter
+    def mgmt_cluster_ext_id(self, mgmt_cluster_ext_id):
+        if mgmt_cluster_ext_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', mgmt_cluster_ext_id):  # noqa: E501
+            raise ValueError(r"Invalid value for `mgmt_cluster_ext_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
 
-        self.__metadata = metadata
+        self.__mgmt_cluster_ext_id = mgmt_cluster_ext_id
 
     @property
-    def data(self):
+    def cluster_ext_id(self):
         """
-        
+        External identifier of the cluster.
 
         :type:
-                :class:`~ntnx_dataprotection_py_client.models.prism.v4.config.TaskReference` | 
-                :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.error.ErrorResponse`
-                    """  # noqa: E501
-        return self.__data
 
-    @data.setter
-    def data(self, data):
+                :class:`~str`
+        """  # noqa: E501
+        return self.__cluster_ext_id
+
+    @cluster_ext_id.setter
+    def cluster_ext_id(self, cluster_ext_id):
+        if cluster_ext_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', cluster_ext_id):  # noqa: E501
+            raise ValueError(r"Invalid value for `cluster_ext_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
 
-        self.__data = data
+        self.__cluster_ext_id = cluster_ext_id
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -171,39 +174,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
-            if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_dataprotection_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(SynchronousReplicaPromoteApiResponse, dict):
+        if issubclass(DataProtectionSiteReference, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, SynchronousReplicaPromoteApiResponse):
+        if not isinstance(other, DataProtectionSiteReference):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/VMRecoveryPoint.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/Witness.py`

 * *Files 25% similar despite different names*

```diff
@@ -3,169 +3,204 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_dataprotection_py_client.models.dataprotection.v4.common.BaseRecoveryPoint import BaseRecoveryPoint  # noqa: F401,E501
-from ntnx_dataprotection_py_client.models.dataprotection.v4.common.RecoveryPointStatus import RecoveryPointStatus  # noqa: F401,E501
-from ntnx_dataprotection_py_client.models.dataprotection.v4.common.RecoveryPointType import RecoveryPointType  # noqa: F401,E501
-from ntnx_dataprotection_py_client.models.dataprotection.v4.common.VendorSpecificProperty import VendorSpecificProperty  # noqa: F401,E501
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.Vm import Vm  # noqa: F401,E501
-
-class VMRecoveryPoint(BaseRecoveryPoint):
-
-    """A model that represents VM Recovery point properties.
-
-    :param consistency_group_ext_id: (:attr:`consistency_group_ext_id`) External identifier of the Consistency group which the entity was part of at the time of Recovery point creation.
-    :type consistency_group_ext_id: 
-    :param vm: (:attr:`vm`) 
-    :type vm: 
+from pathlib import Path
+from ntnx_dataprotection_py_client.models.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
+from ntnx_dataprotection_py_client.models.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel  # noqa: F401,E501
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.HostReference import HostReference  # noqa: F401,E501
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.WitnessAvailabilityStatus import WitnessAvailabilityStatus  # noqa: F401,E501
+
+class Witness(ExternalizableAbstractModel):
+
+    """A model that represents the details of a Witness site.
+
+    :param name: (:attr:`name`) Name of the Witness site.
+    :type name: 
+    :param host_references: (:attr:`host_references`) List of host references of the Witness.
+    :type host_references: 
+    :param ip_addresses: (:attr:`ip_addresses`) List of IP addresses for the Witness site.
+    :type ip_addresses: 
+    :param status: (:attr:`status`) 
+    :type status: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'consistency_group_ext_id': 'str',
-        'vm': 'dataprotection.v4.config.Vm',
-        'location_agnostic_id': 'str',
         'name': 'str',
-        'creation_time': 'datetime',
-        'expiration_time': 'datetime',
-        'status': 'dataprotection.v4.common.RecoveryPointStatus',
-        'recovery_point_type': 'dataprotection.v4.common.RecoveryPointType',
-        'vendor_specific_properties': 'list[dataprotection.v4.common.VendorSpecificProperty]',
+        'host_references': 'list[dataprotection.v4.config.HostReference]',
+        'ip_addresses': 'list[str]',
+        'status': 'dataprotection.v4.config.WitnessAvailabilityStatus',
         'ext_id': 'str',
         'links': 'list[common.v1.response.ApiLink]',
         'tenant_id': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'consistency_group_ext_id': 'consistencyGroupExtId',
-        'vm': 'vm',
-        'location_agnostic_id': 'locationAgnosticId',
         'name': 'name',
-        'creation_time': 'creationTime',
-        'expiration_time': 'expirationTime',
+        'host_references': 'hostReferences',
+        'ip_addresses': 'ipAddresses',
         'status': 'status',
-        'recovery_point_type': 'recoveryPointType',
-        'vendor_specific_properties': 'vendorSpecificProperties',
         'ext_id': 'extId',
         'links': 'links',
         'tenant_id': 'tenantId',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, consistency_group_ext_id=None, vm=None, location_agnostic_id=None, name=None, creation_time=None, expiration_time=None, status=None, recovery_point_type=None, vendor_specific_properties=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
-        BaseRecoveryPoint.__init__(self, location_agnostic_id, name, creation_time, expiration_time, status, recovery_point_type, vendor_specific_properties, ext_id, links, tenant_id, *args, **kwargs)
-        self.__consistency_group_ext_id = None
-        self.__vm = None
+    def __init__(self, name=None, host_references=None, ip_addresses=None, status=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
+        ExternalizableAbstractModel.__init__(self, ext_id, links, tenant_id, *args, **kwargs)
+        self.__name = None
+        self.__host_references = None
+        self.__ip_addresses = None
+        self.__status = None
         self.discriminator = None
-        if consistency_group_ext_id is not None:
-            self.__consistency_group_ext_id = consistency_group_ext_id
-        if vm is not None:
-            self.__vm = vm
+        if name is not None:
+            self.__name = name
+        if host_references is not None:
+            self.__host_references = host_references
+        if ip_addresses is not None:
+            self.__ip_addresses = ip_addresses
+        if status is not None:
+            self.__status = status
 
     def _initialize_object_type(self):
-        return 'dataprotection.v4.config.VMRecoveryPoint'
+        return 'dataprotection.v4.config.Witness'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.VMRecoveryPoint'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     @property
-    def consistency_group_ext_id(self):
+    def name(self):
         """
-        External identifier of the Consistency group which the entity was part of at the time of Recovery point creation.
+        Name of the Witness site.
 
         :type:
 
                 :class:`~str`
         """  # noqa: E501
-        return self.__consistency_group_ext_id
+        return self.__name
 
-    @consistency_group_ext_id.setter
-    def consistency_group_ext_id(self, consistency_group_ext_id):
-        if consistency_group_ext_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', consistency_group_ext_id):  # noqa: E501
-            raise ValueError(r"Invalid value for `consistency_group_ext_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
+    @name.setter
+    def name(self, name):
+        if name is not None and len(name) > 256:
+            raise ValueError("Invalid value for `name`, length must be less than or equal to `256`")  # noqa: E501
 
-        self.__consistency_group_ext_id = consistency_group_ext_id
+        self.__name = name
 
     @property
-    def vm(self):
+    def host_references(self):
+        """
+        List of host references of the Witness.
+
+        :type:
+             list[ :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.HostReference` ]
+        """  # noqa: E501
+        return self.__host_references
+
+    @host_references.setter
+    def host_references(self, host_references):
+
+        self.__host_references = host_references
+
+    @property
+    def ip_addresses(self):
+        """
+        List of IP addresses for the Witness site.
+
+        :type:
+            list[ :class:`~str` ]
+        """  # noqa: E501
+        return self.__ip_addresses
+
+    @ip_addresses.setter
+    def ip_addresses(self, ip_addresses):
+
+        self.__ip_addresses = ip_addresses
+
+    @property
+    def status(self):
         """
         
 
         :type:
-            :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.Vm`
+            :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.WitnessAvailabilityStatus`
         """  # noqa: E501
-        return self.__vm
+        return self.__status
 
-    @vm.setter
-    def vm(self, vm):
+    @status.setter
+    def status(self, status):
 
-        self.__vm = vm
+        self.__status = status
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(VMRecoveryPoint, dict):
+        if issubclass(Witness, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -177,15 +212,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, VMRecoveryPoint):
+        if not isinstance(other, Witness):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ValidateRecoveryPointResult.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/AzureBlobStorageContainer.py`

 * *Files 14% similar despite different names*

```diff
@@ -3,164 +3,141 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.ValidationSeverity import ValidationSeverity  # noqa: F401,E501
+from pathlib import Path
 
-class ValidateRecoveryPointResult(object):
+class AzureBlobStorageContainer(object):
 
-    """Recovery point validation failure details, if any.
+    """Reference to the Microsoft Azure Blob Storage container.
 
-    :param severity: (:attr:`severity`) 
-    :type severity: required
-    :param detail: (:attr:`detail`) Validation failure or warning details.
-    :type detail: 
-    :param resolution: (:attr:`resolution`) Possible resolution for the validation failure or warning.
-    :type resolution: 
+    :param storage_account_name: (:attr:`storage_account_name`) Name of the Microsoft Azure Blob Storage account.
+    :type storage_account_name: 
+    :param container_name: (:attr:`container_name`) Name of the Microsoft Azure Blob Storage container.
+    :type container_name: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'severity': 'dataprotection.v4.config.ValidationSeverity',
-        'detail': 'str',
-        'resolution': 'str',
+        'storage_account_name': 'str',
+        'container_name': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'severity': 'severity',
-        'detail': 'detail',
-        'resolution': 'resolution',
+        'storage_account_name': 'storageAccountName',
+        'container_name': 'containerName',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, severity=None, detail=None, resolution=None, *args, **kwargs):  # noqa: E501
-        self.__severity = None
-        self.__detail = None
-        self.__resolution = None
+    def __init__(self, storage_account_name=None, container_name=None, *args, **kwargs):  # noqa: E501
+        self.__storage_account_name = None
+        self.__container_name = None
         self.discriminator = None
-        self.__severity = severity
-        if detail is not None:
-            self.__detail = detail
-        if resolution is not None:
-            self.__resolution = resolution
+        if storage_account_name is not None:
+            self.__storage_account_name = storage_account_name
+        if container_name is not None:
+            self.__container_name = container_name
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'dataprotection.v4.config.ValidateRecoveryPointResult'
+        return 'dataprotection.v4.config.AzureBlobStorageContainer'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.ValidateRecoveryPointResult'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def severity(self):
+    def storage_account_name(self):
         """
-        
-
-        :type:
-            :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.ValidationSeverity`
-        """  # noqa: E501
-        return self.__severity
-
-    @severity.setter
-    def severity(self, severity):
-        if severity is None:
-            raise ValueError("Invalid value for `severity`, must not be `None`")  # noqa: E501
-
-        self.__severity = severity
-
-    @property
-    def detail(self):
-        """
-        Validation failure or warning details.
+        Name of the Microsoft Azure Blob Storage account.
 
         :type:
 
                 :class:`~str`
         """  # noqa: E501
-        return self.__detail
+        return self.__storage_account_name
 
-    @detail.setter
-    def detail(self, detail):
+    @storage_account_name.setter
+    def storage_account_name(self, storage_account_name):
 
-        self.__detail = detail
+        self.__storage_account_name = storage_account_name
 
     @property
-    def resolution(self):
+    def container_name(self):
         """
-        Possible resolution for the validation failure or warning.
+        Name of the Microsoft Azure Blob Storage container.
 
         :type:
 
                 :class:`~str`
         """  # noqa: E501
-        return self.__resolution
+        return self.__container_name
 
-    @resolution.setter
-    def resolution(self, resolution):
+    @container_name.setter
+    def container_name(self, container_name):
 
-        self.__resolution = resolution
+        self.__container_name = container_name
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -193,37 +170,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ValidateRecoveryPointResult, dict):
+        if issubclass(AzureBlobStorageContainer, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -235,15 +217,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ValidateRecoveryPointResult):
+        if not isinstance(other, AzureBlobStorageContainer):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ValidateRestoreVmRecoveryPointApiResponse.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/error/AppMessage.py`

 * *Files 27% similar despite different names*

```diff
@@ -3,142 +3,232 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_dataprotection_py_client.models
-from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.ValidateRestoreVmRecoveryPointApiResponsedata import ValidateRestoreVmRecoveryPointApiResponsedata  # noqa: F401,E501
-from ntnx_dataprotection_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
-
-class ValidateRestoreVmRecoveryPointApiResponse(object):
-
-    """REST response for all response codes in API path /dataprotection/v4.0.a4/config/recovery-points/{recoveryPointExtId}/vm-recovery-points/{vmRecoveryPointExtId}/$actions/validate-restore Post operation
-
-    :param metadata: (:attr:`metadata`) 
-    :type metadata: 
-    :param data: (:attr:`data`) 
-    :type data: 
+from pathlib import Path
+from ntnx_dataprotection_py_client.models.common.v1.config.MessageSeverity import MessageSeverity  # noqa: F401,E501
+
+class AppMessage(object):
+
+    """Message with associated severity describing status of the current operation.
+
+    :param message: (:attr:`message`) The message string.
+    :type message: 
+    :param severity: (:attr:`severity`) 
+    :type severity: 
+    :param code: (:attr:`code`) The code associated with this message.This string is typically prefixed by the namespace the endpoint belongs to. For example: VMM-40000
+    :type code: 
+    :param locale: (:attr:`locale`) Locale for this message. The default locale would be 'en-US'. (**Default** 'en_US')
+    :type locale: 
+    :param error_group: (:attr:`error_group`) The error group associated with this message of severity ERROR.
+    :type error_group: 
+    :param arguments_map: (:attr:`arguments_map`) The map of argument name to value.
+    :type arguments_map: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfdataprotection.v4.config.ValidateRestoreVmRecoveryPointApiResponsedata',
+        'message': 'str',
+        'severity': 'common.v1.config.MessageSeverity',
+        'code': 'str',
+        'locale': 'str',
+        'error_group': 'str',
+        'arguments_map': 'dict(str, str)',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'metadata': 'metadata',
-        'data': 'data',
+        'message': 'message',
+        'severity': 'severity',
+        'code': 'code',
+        'locale': 'locale',
+        'error_group': 'errorGroup',
+        'arguments_map': 'argumentsMap',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        self.__metadata = None
-        self.__data = None
+    def __init__(self, message=None, severity=None, code=None, locale='en_US', error_group=None, arguments_map=None, *args, **kwargs):  # noqa: E501
+        self.__message = None
+        self.__severity = None
+        self.__code = None
+        self.__locale = None
+        self.__error_group = None
+        self.__arguments_map = None
         self.discriminator = None
-        if metadata is not None:
-            self.__metadata = metadata
-        if data is not None:
-            self.__data = data
+        if message is not None:
+            self.__message = message
+        if severity is not None:
+            self.__severity = severity
+        if code is not None:
+            self.__code = code
+        if locale is not None:
+            self.__locale = locale
+        if error_group is not None:
+            self.__error_group = error_group
+        if arguments_map is not None:
+            self.__arguments_map = arguments_map
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'dataprotection.v4.config.ValidateRestoreVmRecoveryPointApiResponse'
+        return 'dataprotection.v4.error.AppMessage'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.ValidateRestoreVmRecoveryPointApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def metadata(self):
+    def message(self):
         """
-        
+        The message string.
 
         :type:
-            :class:`~ntnx_dataprotection_py_client.models.common.v1.response.ApiResponseMetadata`
+
+                :class:`~str`
         """  # noqa: E501
-        return self.__metadata
+        return self.__message
 
-    @metadata.setter
-    def metadata(self, metadata):
+    @message.setter
+    def message(self, message):
 
-        self.__metadata = metadata
+        self.__message = message
 
     @property
-    def data(self):
+    def severity(self):
         """
         
 
         :type:
-                :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.ValidateRecoveryPointResult` | 
-                :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.error.ErrorResponse`
-                    """  # noqa: E501
-        return self.__data
+            :class:`~ntnx_dataprotection_py_client.models.common.v1.config.MessageSeverity`
+        """  # noqa: E501
+        return self.__severity
+
+    @severity.setter
+    def severity(self, severity):
+
+        self.__severity = severity
+
+    @property
+    def code(self):
+        """
+        The code associated with this message.This string is typically prefixed by the namespace the endpoint belongs to. For example: VMM-40000
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__code
 
-    @data.setter
-    def data(self, data):
+    @code.setter
+    def code(self, code):
 
-        self.__data = data
+        self.__code = code
+
+    @property
+    def locale(self):
+        """
+        Locale for this message. The default locale would be 'en-US'.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__locale
+
+    @locale.setter
+    def locale(self, locale):
+
+        self.__locale = locale
+
+    @property
+    def error_group(self):
+        """
+        The error group associated with this message of severity ERROR.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__error_group
+
+    @error_group.setter
+    def error_group(self, error_group):
+
+        self.__error_group = error_group
+
+    @property
+    def arguments_map(self):
+        """
+        The map of argument name to value.
+
+        :type:
+            dict(str, :class:`~str`)
+        """  # noqa: E501
+        return self.__arguments_map
+
+    @arguments_map.setter
+    def arguments_map(self, arguments_map):
+
+        self.__arguments_map = arguments_map
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -171,39 +261,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
-            if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_dataprotection_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ValidateRestoreVmRecoveryPointApiResponse, dict):
+        if issubclass(AppMessage, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +308,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ValidateRestoreVmRecoveryPointApiResponse):
+        if not isinstance(other, AppMessage):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/VmRecoveryPointRestorationSpec.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/ProtectedResourceRestoreSpec.py`

 * *Files 21% similar despite different names*

```diff
@@ -3,165 +3,170 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.AhvVmOverrideSpec import AhvVmOverrideSpec  # noqa: F401,E501
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.EsxiVmOverrideSpec import EsxiVmOverrideSpec  # noqa: F401,E501
-
-class VmRecoveryPointRestorationSpec(object):
-
-    """Specification for the restore action on the VM Recovery point.
-
-    :param ahv_vm_override_spec: (:attr:`ahv_vm_override_spec`) 
-    :type ahv_vm_override_spec: 
-    :param esxi_vm_override_spec: (:attr:`esxi_vm_override_spec`) 
-    :type esxi_vm_override_spec: 
-    :param cluster_ext_id: (:attr:`cluster_ext_id`) Recovery points are restored at the associated location reference by default. However, there is no particular location reference associated with Recovery points located on the cloud. In such a case, the client must specify the external identifier of the cluster on which the entity should be restored.
-    :type cluster_ext_id: 
+from pathlib import Path
+import ntnx_dataprotection_py_client.models
+from ntnx_dataprotection_py_client.models.OneOfdataprotection.v4.config.ProtectedResourceRestoreSpecoverrides import ProtectedResourceRestoreSpecoverrides  # noqa: F401,E501
+
+class ProtectedResourceRestoreSpec(object):
+
+    """Restore action specifications for a minutely scheduled protected resource.
+
+    :param cluster_ext_id: (:attr:`cluster_ext_id`) The external identifier of the cluster on which the entity has valid restorable time ranges. The restored entity will be created on the same cluster.
+    :type cluster_ext_id: required
+    :param restore_time: (:attr:`restore_time`) UTC date and time in ISO 8601 format representing the time from when the state of the entity should be restored. This needs to be a valid time within the restorable time range(s) for the protected resource.
+    :type restore_time: 
+    :param overrides: (:attr:`overrides`) The restore action specifications on the protected resource. This is an optional field and the specified properties will be overridden for the restored VM/VG.
+    :type overrides: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'ahv_vm_override_spec': 'dataprotection.v4.config.AhvVmOverrideSpec',
-        'esxi_vm_override_spec': 'dataprotection.v4.config.EsxiVmOverrideSpec',
         'cluster_ext_id': 'str',
+        'restore_time': 'datetime',
+        'overrides': 'OneOfdataprotection.v4.config.ProtectedResourceRestoreSpecoverrides',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'ahv_vm_override_spec': 'ahvVmOverrideSpec',
-        'esxi_vm_override_spec': 'esxiVmOverrideSpec',
         'cluster_ext_id': 'clusterExtId',
+        'restore_time': 'restoreTime',
+        'overrides': 'overrides',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, ahv_vm_override_spec=None, esxi_vm_override_spec=None, cluster_ext_id=None, *args, **kwargs):  # noqa: E501
-        self.__ahv_vm_override_spec = None
-        self.__esxi_vm_override_spec = None
+    def __init__(self, cluster_ext_id=None, restore_time=None, overrides=None, *args, **kwargs):  # noqa: E501
         self.__cluster_ext_id = None
+        self.__restore_time = None
+        self.__overrides = None
         self.discriminator = None
-        if ahv_vm_override_spec is not None:
-            self.__ahv_vm_override_spec = ahv_vm_override_spec
-        if esxi_vm_override_spec is not None:
-            self.__esxi_vm_override_spec = esxi_vm_override_spec
-        if cluster_ext_id is not None:
-            self.__cluster_ext_id = cluster_ext_id
+        self.__cluster_ext_id = cluster_ext_id
+        if restore_time is not None:
+            self.__restore_time = restore_time
+        if overrides is not None:
+            self.__overrides = overrides
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'dataprotection.v4.config.VmRecoveryPointRestorationSpec'
+        return 'dataprotection.v4.config.ProtectedResourceRestoreSpec'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.VmRecoveryPointRestorationSpec'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def ahv_vm_override_spec(self):
+    def cluster_ext_id(self):
         """
-        
+        The external identifier of the cluster on which the entity has valid restorable time ranges. The restored entity will be created on the same cluster.
 
         :type:
-            :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.AhvVmOverrideSpec`
+
+                :class:`~str`
         """  # noqa: E501
-        return self.__ahv_vm_override_spec
+        return self.__cluster_ext_id
 
-    @ahv_vm_override_spec.setter
-    def ahv_vm_override_spec(self, ahv_vm_override_spec):
+    @cluster_ext_id.setter
+    def cluster_ext_id(self, cluster_ext_id):
+        if cluster_ext_id is None:
+            raise ValueError("Invalid value for `cluster_ext_id`, must not be `None`")  # noqa: E501
+        if cluster_ext_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', cluster_ext_id):  # noqa: E501
+            raise ValueError(r"Invalid value for `cluster_ext_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
 
-        self.__ahv_vm_override_spec = ahv_vm_override_spec
+        self.__cluster_ext_id = cluster_ext_id
 
     @property
-    def esxi_vm_override_spec(self):
+    def restore_time(self):
         """
-        
+        UTC date and time in ISO 8601 format representing the time from when the state of the entity should be restored. This needs to be a valid time within the restorable time range(s) for the protected resource.
 
         :type:
-            :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.EsxiVmOverrideSpec`
+
+                :class:`~datetime`
         """  # noqa: E501
-        return self.__esxi_vm_override_spec
+        return self.__restore_time
 
-    @esxi_vm_override_spec.setter
-    def esxi_vm_override_spec(self, esxi_vm_override_spec):
+    @restore_time.setter
+    def restore_time(self, restore_time):
 
-        self.__esxi_vm_override_spec = esxi_vm_override_spec
+        self.__restore_time = restore_time
 
     @property
-    def cluster_ext_id(self):
+    def overrides(self):
         """
-        Recovery points are restored at the associated location reference by default. However, there is no particular location reference associated with Recovery points located on the cloud. In such a case, the client must specify the external identifier of the cluster on which the entity should be restored.
+        The restore action specifications on the protected resource. This is an optional field and the specified properties will be overridden for the restored VM/VG.
 
         :type:
+                :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.AhvVmOverrideSpec` | 
+                :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.EsxiVmOverrideSpec` | 
+                :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.VolumeGroupOverrideSpec`
+                    """  # noqa: E501
+        return self.__overrides
 
-                :class:`~str`
-        """  # noqa: E501
-        return self.__cluster_ext_id
-
-    @cluster_ext_id.setter
-    def cluster_ext_id(self, cluster_ext_id):
-        if cluster_ext_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', cluster_ext_id):  # noqa: E501
-            raise ValueError(r"Invalid value for `cluster_ext_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
+    @overrides.setter
+    def overrides(self, overrides):
 
-        self.__cluster_ext_id = cluster_ext_id
+        self.__overrides = overrides
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -194,37 +199,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
+            if attr_type.startswith('OneOf'):
+                type = getattr(ntnx_dataprotection_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(VmRecoveryPointRestorationSpec, dict):
+        if issubclass(ProtectedResourceRestoreSpec, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -236,15 +248,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, VmRecoveryPointRestorationSpec):
+        if not isinstance(other, ProtectedResourceRestoreSpec):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/VmRecoveryPointRestoreOverride.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/VolumeGroupRecoveryPointRestoreOverride.py`

 * *Files 26% similar despite different names*

```diff
@@ -3,166 +3,143 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.AhvVmOverrideSpec import AhvVmOverrideSpec  # noqa: F401,E501
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.EsxiVmOverrideSpec import EsxiVmOverrideSpec  # noqa: F401,E501
+from pathlib import Path
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VolumeGroupOverrideSpec import VolumeGroupOverrideSpec  # noqa: F401,E501
 
-class VmRecoveryPointRestoreOverride(object):
+class VolumeGroupRecoveryPointRestoreOverride(object):
 
     """
 
-    :param vm_recovery_point_id: (:attr:`vm_recovery_point_id`) External identifier of a VM Recovery point, that is a part of the top-level Recovery point.
-    :type vm_recovery_point_id: required
-    :param ahv_vm_override_spec: (:attr:`ahv_vm_override_spec`) 
-    :type ahv_vm_override_spec: 
-    :param esxi_vm_override_spec: (:attr:`esxi_vm_override_spec`) 
-    :type esxi_vm_override_spec: 
+    :param volume_group_recovery_point_ext_id: (:attr:`volume_group_recovery_point_ext_id`) External identifier of a volume group recovery point, that is a part of the top-level recovery point.
+    :type volume_group_recovery_point_ext_id: 
+    :param volume_group_override_spec: (:attr:`volume_group_override_spec`) 
+    :type volume_group_override_spec: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'vm_recovery_point_id': 'str',
-        'ahv_vm_override_spec': 'dataprotection.v4.config.AhvVmOverrideSpec',
-        'esxi_vm_override_spec': 'dataprotection.v4.config.EsxiVmOverrideSpec',
+        'volume_group_recovery_point_ext_id': 'str',
+        'volume_group_override_spec': 'dataprotection.v4.config.VolumeGroupOverrideSpec',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'vm_recovery_point_id': 'vmRecoveryPointId',
-        'ahv_vm_override_spec': 'ahvVmOverrideSpec',
-        'esxi_vm_override_spec': 'esxiVmOverrideSpec',
+        'volume_group_recovery_point_ext_id': 'volumeGroupRecoveryPointExtId',
+        'volume_group_override_spec': 'volumeGroupOverrideSpec',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, vm_recovery_point_id=None, ahv_vm_override_spec=None, esxi_vm_override_spec=None, *args, **kwargs):  # noqa: E501
-        self.__vm_recovery_point_id = None
-        self.__ahv_vm_override_spec = None
-        self.__esxi_vm_override_spec = None
+    def __init__(self, volume_group_recovery_point_ext_id=None, volume_group_override_spec=None, *args, **kwargs):  # noqa: E501
+        self.__volume_group_recovery_point_ext_id = None
+        self.__volume_group_override_spec = None
         self.discriminator = None
-        self.__vm_recovery_point_id = vm_recovery_point_id
-        if ahv_vm_override_spec is not None:
-            self.__ahv_vm_override_spec = ahv_vm_override_spec
-        if esxi_vm_override_spec is not None:
-            self.__esxi_vm_override_spec = esxi_vm_override_spec
+        if volume_group_recovery_point_ext_id is not None:
+            self.__volume_group_recovery_point_ext_id = volume_group_recovery_point_ext_id
+        if volume_group_override_spec is not None:
+            self.__volume_group_override_spec = volume_group_override_spec
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'dataprotection.v4.config.VmRecoveryPointRestoreOverride'
+        return 'dataprotection.v4.config.VolumeGroupRecoveryPointRestoreOverride'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.VmRecoveryPointRestoreOverride'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def vm_recovery_point_id(self):
+    def volume_group_recovery_point_ext_id(self):
         """
-        External identifier of a VM Recovery point, that is a part of the top-level Recovery point.
+        External identifier of a volume group recovery point, that is a part of the top-level recovery point.
 
         :type:
 
                 :class:`~str`
         """  # noqa: E501
-        return self.__vm_recovery_point_id
+        return self.__volume_group_recovery_point_ext_id
 
-    @vm_recovery_point_id.setter
-    def vm_recovery_point_id(self, vm_recovery_point_id):
-        if vm_recovery_point_id is None:
-            raise ValueError("Invalid value for `vm_recovery_point_id`, must not be `None`")  # noqa: E501
-        if vm_recovery_point_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', vm_recovery_point_id):  # noqa: E501
-            raise ValueError(r"Invalid value for `vm_recovery_point_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
+    @volume_group_recovery_point_ext_id.setter
+    def volume_group_recovery_point_ext_id(self, volume_group_recovery_point_ext_id):
+        if volume_group_recovery_point_ext_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', volume_group_recovery_point_ext_id):  # noqa: E501
+            raise ValueError(r"Invalid value for `volume_group_recovery_point_ext_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
 
-        self.__vm_recovery_point_id = vm_recovery_point_id
+        self.__volume_group_recovery_point_ext_id = volume_group_recovery_point_ext_id
 
     @property
-    def ahv_vm_override_spec(self):
+    def volume_group_override_spec(self):
         """
         
 
         :type:
-            :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.AhvVmOverrideSpec`
+            :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.VolumeGroupOverrideSpec`
         """  # noqa: E501
-        return self.__ahv_vm_override_spec
+        return self.__volume_group_override_spec
 
-    @ahv_vm_override_spec.setter
-    def ahv_vm_override_spec(self, ahv_vm_override_spec):
+    @volume_group_override_spec.setter
+    def volume_group_override_spec(self, volume_group_override_spec):
 
-        self.__ahv_vm_override_spec = ahv_vm_override_spec
-
-    @property
-    def esxi_vm_override_spec(self):
-        """
-        
-
-        :type:
-            :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.EsxiVmOverrideSpec`
-        """  # noqa: E501
-        return self.__esxi_vm_override_spec
-
-    @esxi_vm_override_spec.setter
-    def esxi_vm_override_spec(self, esxi_vm_override_spec):
-
-        self.__esxi_vm_override_spec = esxi_vm_override_spec
+        self.__volume_group_override_spec = volume_group_override_spec
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -195,37 +172,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(VmRecoveryPointRestoreOverride, dict):
+        if issubclass(VolumeGroupRecoveryPointRestoreOverride, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -237,15 +219,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, VmRecoveryPointRestoreOverride):
+        if not isinstance(other, VolumeGroupRecoveryPointRestoreOverride):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/VolumeGroupRecoveryPointRestoreOverride.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/RecoveryPoint.py`

 * *Files 27% similar despite different names*

```diff
@@ -3,206 +3,218 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VolumeGroupOverrideSpec import VolumeGroupOverrideSpec  # noqa: F401,E501
-
-class VolumeGroupRecoveryPointRestoreOverride(object):
-
-    """
-
-    :param volume_group_recovery_point_id: (:attr:`volume_group_recovery_point_id`) External identifier of a volume group Recovery point, that is a part of the top-level Recovery point.
-    :type volume_group_recovery_point_id: required
-    :param volume_group_override_spec: (:attr:`volume_group_override_spec`) 
-    :type volume_group_override_spec: 
+from pathlib import Path
+from ntnx_dataprotection_py_client.models.dataprotection.v4.common.BaseRecoveryPoint import BaseRecoveryPoint  # noqa: F401,E501
+from ntnx_dataprotection_py_client.models.dataprotection.v4.common.RecoveryPointStatus import RecoveryPointStatus  # noqa: F401,E501
+from ntnx_dataprotection_py_client.models.dataprotection.v4.common.RecoveryPointType import RecoveryPointType  # noqa: F401,E501
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.LocationReference import LocationReference  # noqa: F401,E501
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VmRecoveryPoint import VmRecoveryPoint  # noqa: F401,E501
+from ntnx_dataprotection_py_client.models.dataprotection.v4.config.VolumeGroupRecoveryPoint import VolumeGroupRecoveryPoint  # noqa: F401,E501
+
+class RecoveryPoint(BaseRecoveryPoint):
+
+    """Details about the recovery point along with all the captured VM and volume group recovery point(s).
+
+    :param owner_ext_id: (:attr:`owner_ext_id`) A read only field inserted into recovery point at the time of recovery point creation, indicating the external identifier of the user who created this recovery point.
+    :type owner_ext_id: 
+    :param location_references: (:attr:`location_references`) List of location references where the VM or volume group recovery point are a part of the specified recovery point.
+    :type location_references: 
+    :param vm_recovery_points: (:attr:`vm_recovery_points`) List of VM recovery point that are a part of the specified top-level recovery point. Note that a recovery point can contain a maximum number of 30 entities. These entities can be a combination of VM(s) and volume group(s).
+    :type vm_recovery_points: 
+    :param volume_group_recovery_points: (:attr:`volume_group_recovery_points`) List of volume group recovery point that are a part of the specified top-level recovery point. Note that a recovery point can contain a maximum number of 30 entities. These entities can be a combination of VM(s) and volume group(s).
+    :type volume_group_recovery_points: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'volume_group_recovery_point_id': 'str',
-        'volume_group_override_spec': 'dataprotection.v4.config.VolumeGroupOverrideSpec',
+        'owner_ext_id': 'str',
+        'location_references': 'list[dataprotection.v4.config.LocationReference]',
+        'vm_recovery_points': 'list[dataprotection.v4.config.VmRecoveryPoint]',
+        'volume_group_recovery_points': 'list[dataprotection.v4.config.VolumeGroupRecoveryPoint]',
+        'location_agnostic_id': 'str',
+        'name': 'str',
+        'creation_time': 'datetime',
+        'expiration_time': 'datetime',
+        'status': 'dataprotection.v4.common.RecoveryPointStatus',
+        'recovery_point_type': 'dataprotection.v4.common.RecoveryPointType',
+        'ext_id': 'str',
+        'links': 'list[common.v1.response.ApiLink]',
+        'tenant_id': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'volume_group_recovery_point_id': 'volumeGroupRecoveryPointId',
-        'volume_group_override_spec': 'volumeGroupOverrideSpec',
+        'owner_ext_id': 'ownerExtId',
+        'location_references': 'locationReferences',
+        'vm_recovery_points': 'vmRecoveryPoints',
+        'volume_group_recovery_points': 'volumeGroupRecoveryPoints',
+        'location_agnostic_id': 'locationAgnosticId',
+        'name': 'name',
+        'creation_time': 'creationTime',
+        'expiration_time': 'expirationTime',
+        'status': 'status',
+        'recovery_point_type': 'recoveryPointType',
+        'ext_id': 'extId',
+        'links': 'links',
+        'tenant_id': 'tenantId',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, volume_group_recovery_point_id=None, volume_group_override_spec=None, *args, **kwargs):  # noqa: E501
-        self.__volume_group_recovery_point_id = None
-        self.__volume_group_override_spec = None
+    def __init__(self, owner_ext_id=None, location_references=None, vm_recovery_points=None, volume_group_recovery_points=None, location_agnostic_id=None, name=None, creation_time=None, expiration_time=None, status=None, recovery_point_type=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
+        BaseRecoveryPoint.__init__(self, location_agnostic_id, name, creation_time, expiration_time, status, recovery_point_type, ext_id, links, tenant_id, *args, **kwargs)
+        self.__owner_ext_id = None
+        self.__location_references = None
+        self.__vm_recovery_points = None
+        self.__volume_group_recovery_points = None
         self.discriminator = None
-        self.__volume_group_recovery_point_id = volume_group_recovery_point_id
-        if volume_group_override_spec is not None:
-            self.__volume_group_override_spec = volume_group_override_spec
-        # populate hidden vars if not empty
-        self._populate_hidden_vars(kwargs)
+        if owner_ext_id is not None:
+            self.__owner_ext_id = owner_ext_id
+        if location_references is not None:
+            self.__location_references = location_references
+        if vm_recovery_points is not None:
+            self.__vm_recovery_points = vm_recovery_points
+        if volume_group_recovery_points is not None:
+            self.__volume_group_recovery_points = volume_group_recovery_points
 
     def _initialize_object_type(self):
-        return 'dataprotection.v4.config.VolumeGroupRecoveryPointRestoreOverride'
-
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.VolumeGroupRecoveryPointRestoreOverride'
-
-    def _populate_hidden_vars(self, kwargs):
-        if "_reserved" in kwargs and kwargs["_reserved"] is not None:
-            self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
-            self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
-        else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
-        if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
-            self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
-            self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
-        else :
-            self.__dollar_unknown_fields = {}
-        if "_object_type" in kwargs and kwargs["_object_type"] is not None:
-            self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
-            self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
-        else:
-            self.__dollar_object_type = self._initialize_object_type()
+        return 'dataprotection.v4.config.RecoveryPoint'
 
-    def get_object_type(self):
-        return self.__dollar_object_type
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
-    def get_reserved(self):
-        return self.__dollar_reserved
-
-    def get_unknown_fields(self):
-        return self.__dollar_unknown_fields
 
     @property
-    def volume_group_recovery_point_id(self):
+    def owner_ext_id(self):
         """
-        External identifier of a volume group Recovery point, that is a part of the top-level Recovery point.
+        A read only field inserted into recovery point at the time of recovery point creation, indicating the external identifier of the user who created this recovery point.
 
         :type:
 
                 :class:`~str`
         """  # noqa: E501
-        return self.__volume_group_recovery_point_id
+        return self.__owner_ext_id
 
-    @volume_group_recovery_point_id.setter
-    def volume_group_recovery_point_id(self, volume_group_recovery_point_id):
-        if volume_group_recovery_point_id is None:
-            raise ValueError("Invalid value for `volume_group_recovery_point_id`, must not be `None`")  # noqa: E501
-        if volume_group_recovery_point_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', volume_group_recovery_point_id):  # noqa: E501
-            raise ValueError(r"Invalid value for `volume_group_recovery_point_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
+    @owner_ext_id.setter
+    def owner_ext_id(self, owner_ext_id):
+        if owner_ext_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', owner_ext_id):  # noqa: E501
+            raise ValueError(r"Invalid value for `owner_ext_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
 
-        self.__volume_group_recovery_point_id = volume_group_recovery_point_id
+        self.__owner_ext_id = owner_ext_id
 
     @property
-    def volume_group_override_spec(self):
+    def location_references(self):
         """
-        
+        List of location references where the VM or volume group recovery point are a part of the specified recovery point.
 
         :type:
-            :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.VolumeGroupOverrideSpec`
+             list[ :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.LocationReference` ]
         """  # noqa: E501
-        return self.__volume_group_override_spec
+        return self.__location_references
 
-    @volume_group_override_spec.setter
-    def volume_group_override_spec(self, volume_group_override_spec):
+    @location_references.setter
+    def location_references(self, location_references):
 
-        self.__volume_group_override_spec = volume_group_override_spec
+        self.__location_references = location_references
 
     @property
-    def _reserved(self):
+    def vm_recovery_points(self):
         """
-        
+        List of VM recovery point that are a part of the specified top-level recovery point. Note that a recovery point can contain a maximum number of 30 entities. These entities can be a combination of VM(s) and volume group(s).
 
         :type:
-            dict(str, :class:`~object`)
+             list[ :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.VmRecoveryPoint` ]
         """  # noqa: E501
-        return self.__dollar_reserved
+        return self.__vm_recovery_points
 
-    @property
-    def _object_type(self):
-        """
-        
-
-        :type:
+    @vm_recovery_points.setter
+    def vm_recovery_points(self, vm_recovery_points):
 
-                :class:`~str`
-        """  # noqa: E501
-        return self.__dollar_object_type
+        self.__vm_recovery_points = vm_recovery_points
 
     @property
-    def _unknown_fields(self):
+    def volume_group_recovery_points(self):
         """
-        
+        List of volume group recovery point that are a part of the specified top-level recovery point. Note that a recovery point can contain a maximum number of 30 entities. These entities can be a combination of VM(s) and volume group(s).
 
         :type:
-            dict(str, :class:`~object`)
+             list[ :class:`~ntnx_dataprotection_py_client.models.dataprotection.v4.config.VolumeGroupRecoveryPoint` ]
         """  # noqa: E501
-        return self.__dollar_unknown_fields
+        return self.__volume_group_recovery_points
+
+    @volume_group_recovery_points.setter
+    def volume_group_recovery_points(self, volume_group_recovery_points):
+
+        self.__volume_group_recovery_points = volume_group_recovery_points
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(VolumeGroupRecoveryPointRestoreOverride, dict):
+        if issubclass(RecoveryPoint, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -214,15 +226,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, VolumeGroupRecoveryPointRestoreOverride):
+        if not isinstance(other, RecoveryPoint):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/models/dataprotection/v4/config/VolumeGroupSubRecoveryPoint.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/models/dataprotection/v4/config/VolumeGroupRecoveryPointComputeChangedRegionsRequest.py`

 * *Files 22% similar despite different names*

```diff
@@ -3,216 +3,216 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class VolumeGroupSubRecoveryPoint(object):
+class VolumeGroupRecoveryPointComputeChangedRegionsRequest(object):
 
-    """A model that represents volume group Recovery point properties.
+    """Compute changed region parameters. In these parameters, you can specify a start offset, an end offset, and a reference disk recovery point. All parameters are optional. However, if a reference disk recovery point needs to be set, all three parameters - recovery point Id, volume group recovery point Id, and disk recovery point Id must be specified.
 
-    :param volume_group_recovery_point_id: (:attr:`volume_group_recovery_point_id`) The external identifier that can be used to retrieve the volume group Recovery point using its URL.
-    :type volume_group_recovery_point_id: 
-    :param consistency_group_ext_id: (:attr:`consistency_group_ext_id`) External identifier of the Consistency group which the entity was part of at the time of Recovery point creation.
-    :type consistency_group_ext_id: 
-    :param location_agnostic_id: (:attr:`location_agnostic_id`) Location agnostic identifier of the Recovery point. This identifier is used to identify the same instances of a Recovery point across different sites.
-    :type location_agnostic_id: 
-    :param volume_group_ext_id: (:attr:`volume_group_ext_id`) Volume group external identifier which is captured as part of this Recovery point.
-    :type volume_group_ext_id: 
-    :param volume_group_categories: (:attr:`volume_group_categories`) Category key-value pairs associated with the volume group at the time of Recovery point creation. The category key and value are separated by '/'. For example, a category with key 'dept' and value 'hr' will be represented as 'dept/hr'.
-    :type volume_group_categories: 
+    :param reference_recovery_point_ext_id: (:attr:`reference_recovery_point_ext_id`) The external identifier that can be used to retrieve the recovery point using its URL.
+    :type reference_recovery_point_ext_id: 
+    :param reference_volume_group_recovery_point_ext_id: (:attr:`reference_volume_group_recovery_point_ext_id`) The external identifier that can be used to retrieve the volume group recovery point using its URL (Note: This attribute will be removed in future releases, use volume group recovery point external identifier instead).
+    :type reference_volume_group_recovery_point_ext_id: 
+    :param reference_disk_recovery_point_ext_id: (:attr:`reference_disk_recovery_point_ext_id`) Disk recovery point external identifier.
+    :type reference_disk_recovery_point_ext_id: 
+    :param offset: (:attr:`offset`) The start offset value to compute the changed region. If the value is not provided, the difference is executed from the offset of 0. Note: the start offset might automatically align to a system-defined block boundary.
+    :type offset: 
+    :param length: (:attr:`length`) The length to compute the changed region. If the value is not provided, the difference is performed from the start offset to the end of the disk. Note: the end offset might automatically align to a system-defined block boundary.
+    :type length: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'volume_group_recovery_point_id': 'str',
-        'consistency_group_ext_id': 'str',
-        'location_agnostic_id': 'str',
-        'volume_group_ext_id': 'str',
-        'volume_group_categories': 'list[str]',
+        'reference_recovery_point_ext_id': 'str',
+        'reference_volume_group_recovery_point_ext_id': 'str',
+        'reference_disk_recovery_point_ext_id': 'str',
+        'offset': 'int',
+        'length': 'int',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'volume_group_recovery_point_id': 'volumeGroupRecoveryPointId',
-        'consistency_group_ext_id': 'consistencyGroupExtId',
-        'location_agnostic_id': 'locationAgnosticId',
-        'volume_group_ext_id': 'volumeGroupExtId',
-        'volume_group_categories': 'volumeGroupCategories',
+        'reference_recovery_point_ext_id': 'referenceRecoveryPointExtId',
+        'reference_volume_group_recovery_point_ext_id': 'referenceVolumeGroupRecoveryPointExtId',
+        'reference_disk_recovery_point_ext_id': 'referenceDiskRecoveryPointExtId',
+        'offset': 'offset',
+        'length': 'length',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, volume_group_recovery_point_id=None, consistency_group_ext_id=None, location_agnostic_id=None, volume_group_ext_id=None, volume_group_categories=None, *args, **kwargs):  # noqa: E501
-        self.__volume_group_recovery_point_id = None
-        self.__consistency_group_ext_id = None
-        self.__location_agnostic_id = None
-        self.__volume_group_ext_id = None
-        self.__volume_group_categories = None
+    def __init__(self, reference_recovery_point_ext_id=None, reference_volume_group_recovery_point_ext_id=None, reference_disk_recovery_point_ext_id=None, offset=None, length=None, *args, **kwargs):  # noqa: E501
+        self.__reference_recovery_point_ext_id = None
+        self.__reference_volume_group_recovery_point_ext_id = None
+        self.__reference_disk_recovery_point_ext_id = None
+        self.__offset = None
+        self.__length = None
         self.discriminator = None
-        if volume_group_recovery_point_id is not None:
-            self.__volume_group_recovery_point_id = volume_group_recovery_point_id
-        if consistency_group_ext_id is not None:
-            self.__consistency_group_ext_id = consistency_group_ext_id
-        if location_agnostic_id is not None:
-            self.__location_agnostic_id = location_agnostic_id
-        if volume_group_ext_id is not None:
-            self.__volume_group_ext_id = volume_group_ext_id
-        if volume_group_categories is not None:
-            self.__volume_group_categories = volume_group_categories
+        if reference_recovery_point_ext_id is not None:
+            self.__reference_recovery_point_ext_id = reference_recovery_point_ext_id
+        if reference_volume_group_recovery_point_ext_id is not None:
+            self.__reference_volume_group_recovery_point_ext_id = reference_volume_group_recovery_point_ext_id
+        if reference_disk_recovery_point_ext_id is not None:
+            self.__reference_disk_recovery_point_ext_id = reference_disk_recovery_point_ext_id
+        if offset is not None:
+            self.__offset = offset
+        if length is not None:
+            self.__length = length
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'dataprotection.v4.config.VolumeGroupSubRecoveryPoint'
+        return 'dataprotection.v4.config.VolumeGroupRecoveryPointComputeChangedRegionsRequest'
 
-    def _initialize_fq_object_type(self):
-        return 'dataprotection.v4.r0.a4.config.VolumeGroupSubRecoveryPoint'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def volume_group_recovery_point_id(self):
+    def reference_recovery_point_ext_id(self):
         """
-        The external identifier that can be used to retrieve the volume group Recovery point using its URL.
+        The external identifier that can be used to retrieve the recovery point using its URL.
 
         :type:
 
                 :class:`~str`
         """  # noqa: E501
-        return self.__volume_group_recovery_point_id
+        return self.__reference_recovery_point_ext_id
 
-    @volume_group_recovery_point_id.setter
-    def volume_group_recovery_point_id(self, volume_group_recovery_point_id):
-        if volume_group_recovery_point_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', volume_group_recovery_point_id):  # noqa: E501
-            raise ValueError(r"Invalid value for `volume_group_recovery_point_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
+    @reference_recovery_point_ext_id.setter
+    def reference_recovery_point_ext_id(self, reference_recovery_point_ext_id):
+        if reference_recovery_point_ext_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', reference_recovery_point_ext_id):  # noqa: E501
+            raise ValueError(r"Invalid value for `reference_recovery_point_ext_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
 
-        self.__volume_group_recovery_point_id = volume_group_recovery_point_id
+        self.__reference_recovery_point_ext_id = reference_recovery_point_ext_id
 
     @property
-    def consistency_group_ext_id(self):
+    def reference_volume_group_recovery_point_ext_id(self):
         """
-        External identifier of the Consistency group which the entity was part of at the time of Recovery point creation.
+        The external identifier that can be used to retrieve the volume group recovery point using its URL (Note: This attribute will be removed in future releases, use volume group recovery point external identifier instead).
 
         :type:
 
                 :class:`~str`
         """  # noqa: E501
-        return self.__consistency_group_ext_id
+        return self.__reference_volume_group_recovery_point_ext_id
 
-    @consistency_group_ext_id.setter
-    def consistency_group_ext_id(self, consistency_group_ext_id):
-        if consistency_group_ext_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', consistency_group_ext_id):  # noqa: E501
-            raise ValueError(r"Invalid value for `consistency_group_ext_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
+    @reference_volume_group_recovery_point_ext_id.setter
+    def reference_volume_group_recovery_point_ext_id(self, reference_volume_group_recovery_point_ext_id):
+        if reference_volume_group_recovery_point_ext_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', reference_volume_group_recovery_point_ext_id):  # noqa: E501
+            raise ValueError(r"Invalid value for `reference_volume_group_recovery_point_ext_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
 
-        self.__consistency_group_ext_id = consistency_group_ext_id
+        self.__reference_volume_group_recovery_point_ext_id = reference_volume_group_recovery_point_ext_id
 
     @property
-    def location_agnostic_id(self):
+    def reference_disk_recovery_point_ext_id(self):
         """
-        Location agnostic identifier of the Recovery point. This identifier is used to identify the same instances of a Recovery point across different sites.
+        Disk recovery point external identifier.
 
         :type:
 
                 :class:`~str`
         """  # noqa: E501
-        return self.__location_agnostic_id
+        return self.__reference_disk_recovery_point_ext_id
 
-    @location_agnostic_id.setter
-    def location_agnostic_id(self, location_agnostic_id):
-        if location_agnostic_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', location_agnostic_id):  # noqa: E501
-            raise ValueError(r"Invalid value for `location_agnostic_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
+    @reference_disk_recovery_point_ext_id.setter
+    def reference_disk_recovery_point_ext_id(self, reference_disk_recovery_point_ext_id):
+        if reference_disk_recovery_point_ext_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', reference_disk_recovery_point_ext_id):  # noqa: E501
+            raise ValueError(r"Invalid value for `reference_disk_recovery_point_ext_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
 
-        self.__location_agnostic_id = location_agnostic_id
+        self.__reference_disk_recovery_point_ext_id = reference_disk_recovery_point_ext_id
 
     @property
-    def volume_group_ext_id(self):
+    def offset(self):
         """
-        Volume group external identifier which is captured as part of this Recovery point.
+        The start offset value to compute the changed region. If the value is not provided, the difference is executed from the offset of 0. Note: the start offset might automatically align to a system-defined block boundary.
 
         :type:
 
-                :class:`~str`
+                :class:`~int`
         """  # noqa: E501
-        return self.__volume_group_ext_id
+        return self.__offset
 
-    @volume_group_ext_id.setter
-    def volume_group_ext_id(self, volume_group_ext_id):
-        if volume_group_ext_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', volume_group_ext_id):  # noqa: E501
-            raise ValueError(r"Invalid value for `volume_group_ext_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
+    @offset.setter
+    def offset(self, offset):
 
-        self.__volume_group_ext_id = volume_group_ext_id
+        self.__offset = offset
 
     @property
-    def volume_group_categories(self):
+    def length(self):
         """
-        Category key-value pairs associated with the volume group at the time of Recovery point creation. The category key and value are separated by '/'. For example, a category with key 'dept' and value 'hr' will be represented as 'dept/hr'.
+        The length to compute the changed region. If the value is not provided, the difference is performed from the start offset to the end of the disk. Note: the end offset might automatically align to a system-defined block boundary.
 
         :type:
-            list[ :class:`~str` ]
+
+                :class:`~int`
         """  # noqa: E501
-        return self.__volume_group_categories
+        return self.__length
 
-    @volume_group_categories.setter
-    def volume_group_categories(self, volume_group_categories):
+    @length.setter
+    def length(self, length):
 
-        self.__volume_group_categories = volume_group_categories
+        self.__length = length
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -245,37 +245,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(VolumeGroupSubRecoveryPoint, dict):
+        if issubclass(VolumeGroupRecoveryPointComputeChangedRegionsRequest, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -287,15 +292,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, VolumeGroupSubRecoveryPoint):
+        if not isinstance(other, VolumeGroupRecoveryPointComputeChangedRegionsRequest):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client/rest.py` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client/rest.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,15 +3,15 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 from __future__ import absolute_import
 
 import io
@@ -37,15 +37,15 @@
 
 class RESTResponse(io.IOBase):
 
     def __init__(self, resp):
         self.urllib3_response = resp
         self.status = resp.status
         self.reason = resp.reason
-        self.data = resp.data
+        self.data = None
 
     def getheaders(self):
         """Returns a dictionary of the response headers."""
         return self.urllib3_response.getheaders()
 
     def getheader(self, name, default=None):
         """Returns a given response header."""
@@ -180,14 +180,16 @@
             if isinstance(_request_timeout, (int, float) if six.PY3 else (int, long, float)):  # noqa: E501,F821
                 timeout = urllib3.Timeout(total=_request_timeout)
             elif (isinstance(_request_timeout, list) and len(_request_timeout) == 2):
                 timeout = urllib3.Timeout(connect=_request_timeout[0], read=_request_timeout[1])
 
         if 'Content-Type' not in headers:
             headers['Content-Type'] = 'application/json'
+        if 'Accept' in headers and headers['Accept'] == 'application/octet-stream':
+            _preload_content = False
 
         # Print log statements
         logger.info("%s %s", method, url + '?' + urlencode(query_params) if query_params else url)
         # Print debug logs, if enabled
         if self.__configuration.debug:
             logger.debug("Request Headers:")
             for key, value in six.iteritems(headers):
@@ -221,31 +223,37 @@
                         preload_content=_preload_content,
                         timeout=timeout,
                         headers=headers)
                 elif headers['Content-Type'] == 'multipart/form-data':
                     # must del headers['Content-Type'], or the correct
                     # Content-Type which generated by urllib3 will be
                     # overwritten.
+                    content_type_header = headers['Content-Type']
                     del headers['Content-Type']
                     r = self.pool_manager.request(
                         method, url,
                         fields=post_params,
                         encode_multipart=True,
                         preload_content=_preload_content,
                         timeout=timeout,
                         headers=headers)
+                    headers['Content-Type'] = content_type_header
                 # Pass a `string` parameter directly in the body to support
                 # other content types than Json when `body` argument is
                 # provided in serialized form
-                elif isinstance(body, str):
+                elif isinstance(body, str) or headers['Content-Type'] == 'application/octet-stream':
                     request_body = body
+                    preload = _preload_content
+                    if headers['Content-Type'] == 'application/octet-stream':
+                        preload = False
+
                     r = self.pool_manager.request(
                         method, url,
                         body=request_body,
-                        preload_content=_preload_content,
+                        preload_content=preload,
                         timeout=timeout,
                         headers=headers)
                 else:
                     # Cannot generate the request from given parameters
                     msg = """Cannot prepare a request message for provided
                              arguments. Please check that your arguments match
                              declared content type."""
@@ -260,30 +268,27 @@
         except urllib3.exceptions.SSLError as e:
             msg = "{0}\n{1}".format(type(e).__name__, str(e))
             raise ApiException(status=0, reason=msg)
         except Exception as e:
             logger.error(str(e))
             raise
 
-        if _preload_content:
+        if r.getheader(name='Content-Type') == 'application/octet-stream' or _preload_content :
             r = RESTResponse(r)
 
-            # In the python 3, the response.data is bytes.
-            # we need to decode it to string.
-            if six.PY3:
-                r.data = r.data.decode('utf8')
-
         # Print log statements
         logger.info("Response Status: %s %s", r.status, r.reason)
         # Print debug logs, if enabled
         if self.__configuration.debug:
             logger.debug("Response Headers:")
             for key, value in six.iteritems(r.getheaders()):
                 logger.debug("%s: %s", key, value)
-            logger.debug("Response Body: %s", r.data)
+
+            if _preload_content and r.getheader("Content-Type", "application/json") != "application/octet-stream":
+                logger.debug("Response Body: %s", r.urllib3_response.data)
 
         if not 200 <= r.status <= 299 and not 401 == r.status:
             raise ApiException(http_resp=r)
 
         return r
 
     def GET(self, url, headers=None, query_params=None, _preload_content=True,
@@ -354,15 +359,16 @@
 
 class ApiException(Exception):
 
     def __init__(self, status=None, reason=None, http_resp=None):
         if http_resp:
             self.status = http_resp.status
             self.reason = http_resp.reason
-            self.body = http_resp.data
+            self.body = (http_resp.urllib3_response.data.decode('utf8') if hasattr(http_resp, 'urllib3_response')
+                        else http_resp.data.decode('utf8'))
             self.headers = http_resp.getheaders()
         else:
             self.status = status
             self.reason = reason
             self.body = None
             self.headers = None
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client.egg-info/PKG-INFO` & `ntnx_dataprotection_py_client-4.0.1b1/README.md`

 * *Files 7% similar despite different names*

```diff
@@ -1,37 +1,22 @@
-Metadata-Version: 2.1
-Name: ntnx-dataprotection-py-client
-Version: 4.0.1a4
-Summary: Nutanix Dataprotection Versioned APIs
-Home-page: 
-Author-email: sdk@nutanix.com
-Keywords: Nutanix,v4,SDK,Nutanix Dataprotection Versioned APIs
-Description-Content-Type: text/markdown
-License-File: LICENSE.txt
-Requires-Dist: urllib3~=1.26
-Requires-Dist: six~=1.16
-Requires-Dist: certifi==2020.4.5.1
-Requires-Dist: python-dateutil~=2.8
-Requires-Dist: pysocks~=1.7
-
 # Python Client For Nutanix Dataprotection Versioned APIs
 
 The Python client for Nutanix Dataprotection Versioned APIs is designed for Python client application developers offering them simple and flexible access to APIs that business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.
 ## Features
 - Invoke Nutanix APIs with a simple interface.
 - Handle Authentication seamlessly.
 - Reduce boilerplate code implementation.
 - Use standard methods for installation.
 
 ## Version
-- API version: v4.0.a4
-- Package version: 4.0.1a4
+- API version: v4.0.b1
+- Package version: 4.0.1b1
 
 ## Requirements.
-Python 3.6, 3.7, and 3.8 are fully supported and tested.
+Python 3.6, 3.7, 3.8 and 3.9 are fully supported and tested.
 
 
 ## Installation & Usage
 
 ### Installing in a virtual environment
 [virtualenv](https://virtualenv.pypa.io/en/latest/) is a tool to create isolated Python environments. The basic problem it addresses is one of dependencies and versions, and indirectly permissions. virtualenv can help you install this client without needing system install permissions. It creates an environment that has its own installation directories without sharing libraries with other virtualenv environments or the system installation.
 
@@ -85,14 +70,15 @@
 | debug     | Runs the client in debug mode if specified                                       | No       | False        |
 | verify_ssl| Verify SSL certificate of cluster the client will connect to                     | No       | True         |
 | max_retry_attempts| Maximum number of retry attempts while connecting to the cluster         | No       | 5            |
 | backoff_factor| A backoff factor to apply between attempts after the second try.             | No       | 3            |
 | logger_file | File location to which debug logs are written to                               | No       | N/A          |
 | connect_timeout | Connection timeout in milliseconds for all operations                      | No       | 30000        |
 | read_timeout | Read timeout in milliseconds for all operations                               | No       | 30000        |
+| download_directory| Directory where downloaded files will be stored in                       | No       | Current Working Directory|
 
 
 ### Sample Configuration
 ```python
 config = Configuration()
 config.host = '10.19.50.27' # IPv4/IPv6 address or FQDN of the cluster
 config.port = 9440 # Port to which to connect to
@@ -142,79 +128,79 @@
 ```
 
 ## Usage
 
 ### Invoking an operation
 ```python
 # Initialize the API
-consistency_group_api_instance = ConsistencyGroupApi(api_client=client) # client configured in previous step
+consistency_groups_api_instance = ConsistencyGroupsApi(api_client=client) # client configured in previous step
 extId = 'extId_example' # UUID.
 
-# Get a Consistency group.
+# Get a Consistency group
 try:
-    api_response = consistency_group_api_instance.get_consistency_group(extId)
+    api_response = consistency_groups_api_instance.get_consistency_group_by_id(extId)
 except ApiException as e:
 ```
 
 ### Setting headers for individual operations
 Headers can be configured globally on the python client using the [method to set default headers](#additional-headers). However, sometimes headers need to be set on an individual operation basis. Nutanix APIs require that concurrent updates are protected using [ETag headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag).
 
 ```python
 # Initialize the API
-consistency_group_api_instance = ConsistencyGroupApi(api_client=client) # client configured in previous step
+consistency_groups_api_instance = ConsistencyGroupsApi(api_client=client) # client configured in previous step
 extId = 'extId_example' # UUID.
 
-# Get a Consistency group.
+# Get a Consistency group
 try:
-    api_response = consistency_group_api_instance.get_consistency_group(extId)
+    api_response = consistency_groups_api_instance.get_consistency_group_by_id(extId)
 except ApiException as e:
 
 # Extract E-Tag Header
 etag_value = ApiClient.get_etag(api_response)
 
-# Update a Consistency group.
+# Update a Consistency group
 try:
     # The body parameter in the following operation is received from the previous GET request's response which needs to be updated.
-    api_response = consistency_group_api_instance.update_consistency_group(body, extId, if_match=etag_value) # Use the extracted etag value
+    api_response = consistency_groups_api_instance.update_consistency_group_by_id(body, extId, if_match=etag_value) # Use the extracted etag value
 except ApiException as e:
 ```
 
 ### List Operations
 List Operations for Nutanix APIs support pagination, filtering, sorting and projections. The table below details the parameters that can be used to set the options for pagination etc.
 
 | Parameter | Description
 |-----------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
 | _page     | specifies the page number of the result set. Must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range will lead to no results being returned.|
 | _limit    | specifies the total number of records returned in the result set. Must be a positive integer between 0 and 100. Any number out of this range will lead to a validation error. If the limit is not provided a default value of 50 records will be returned in the result set|
 | _filter   | allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the [OData V4.01 URL](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part2-url-conventions.html#sec_SystemQueryOptionfilter) conventions. |
 | _orderby  | allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified the resources will be sorted in ascending order by default. For example, 'orderby=templateName desc' would get all templates sorted by templateName in desc order. |
-| _select   | allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the OData V4.01 URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e. *), then all properties on the matching resource will be returned. |
-| _expand   | allows clients to request related resources when a resource that satisfies a particular request is retrieved. Each expand item is evaluated relative to the entity containing the property being expanded. Other query options can be applied to an expanded property by appending a semicolon-separated list of query options, enclosed in parentheses, to the property name. Allowed system query options are $filter,$select, $orderby. |
+| _select   | allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the OData V4.01 URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e., *), then all properties on the matching resource will be returned. |
+| _expand   | allows clients to request related resources when a resource that satisfies a particular request is retrieved. Each expanded item is evaluated relative to the entity containing the property being expanded. Other query options can be applied to an expanded property by appending a semicolon-separated list of query options, enclosed in parentheses, to the property name. Permissible system query options are $filter,$select and $orderby. |
 
 ```python
 # Initialize the API
-consistency_group_api_instance = ConsistencyGroupApi(api_client=client) # client configured in previous step
+consistency_groups_api_instance = ConsistencyGroupsApi(api_client=client) # client configured in previous step
 extId = 'extId_example' # UUID.
 
-# List Consistency groups.
+# List Consistency groups
 try:
-    api_response = consistency_group_api_instance.get_consistency_groups(
+    api_response = consistency_groups_api_instance.list_consistency_groups(
 	                   _page=page, # if page parameter is present
 	                   _limit=limit, # if limit parameter is present
 	                   _filter=_filter, # if filter parameter is present
 	                   _orderby=_orderby, # if orderby parameter is present
 	                   _select=select, # if select parameter is present
 	                   _expand=expand) # if expand parameter is present
 except ApiException as e:
 
 ```
 The list of filterable and sortable fields with expansion keys can be found in the documentation [here](https://developers.nutanix.com/).
 
 ## API Reference
 
-This library has a full set of [API Reference Documentation](https://developers.nutanix.com/sdk-reference?namespace=dataprotection&version=v4.0.a4&language=python). This documentation is auto-generated, and the location may change.
+This library has a full set of [API Reference Documentation](https://developers.nutanix.com/sdk-reference?namespace=dataprotection&version=v4.0.b1&language=python). This documentation is auto-generated, and the location may change.
 
 ## License
 This library is licensed under Nutanix proprietary license. Full license text is available in [LICENSE](https://developers.nutanix.com/license).
 
 ## Contact us
-In case of issues please reach out to us at the [mailing list](mailto:sdk@nutanix.com)
+In case of issues please reach out to us at the [mailing list](mailto:sdk@nutanix.com)
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/ntnx_dataprotection_py_client.egg-info/SOURCES.txt` & `ntnx_dataprotection_py_client-4.0.1b1/ntnx_dataprotection_py_client.egg-info/SOURCES.txt`

 * *Files 20% similar despite different names*

```diff
@@ -8,50 +8,43 @@
 ntnx_dataprotection_py_client/rest.py
 ntnx_dataprotection_py_client.egg-info/PKG-INFO
 ntnx_dataprotection_py_client.egg-info/SOURCES.txt
 ntnx_dataprotection_py_client.egg-info/dependency_links.txt
 ntnx_dataprotection_py_client.egg-info/requires.txt
 ntnx_dataprotection_py_client.egg-info/top_level.txt
 ntnx_dataprotection_py_client/api/__init__.py
-ntnx_dataprotection_py_client/api/consistency_group_api.py
+ntnx_dataprotection_py_client/api/protected_resources_api.py
+ntnx_dataprotection_py_client/api/recovery_points_api.py
 ntnx_dataprotection_py_client/models/__init__.py
 ntnx_dataprotection_py_client/models/OneOfcommon/__init__.py
 ntnx_dataprotection_py_client/models/OneOfcommon/v1/__init__.py
 ntnx_dataprotection_py_client/models/OneOfcommon/v1/config/KVPairvalue.py
 ntnx_dataprotection_py_client/models/OneOfcommon/v1/config/__init__.py
 ntnx_dataprotection_py_client/models/OneOfdataprotection/__init__.py
 ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/__init__.py
-ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/ChangedRegionsListApiResponsedata.py
-ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/ConsistencyGroupApiResponsedata.py
-ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/ConsistencyGroupListApiResponsedata.py
-ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/ConsistencyGroupMigrateApiResponsedata.py
-ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/CreateConsistencyGroupRecoveryPointApiResponsedata.py
+ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/ComputeChangedRegionsResponseModeldata.py
+ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/ComputeChangedRegionsResponseresponse.py
+ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/CreateConsistencyGroupApiResponsedata.py
 ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/CreateRecoveryPointApiResponsedata.py
 ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/DeleteConsistencyGroupApiResponsedata.py
 ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/DeleteRecoveryPointApiResponsedata.py
-ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/DiskRecoveryPointApiResponsedata.py
-ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/DiskRecoveryPointListApiResponsedata.py
-ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/ProtectedResourceApiResponsedata.py
+ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/GetProtectedResourceApiResponsedata.py
+ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/GetRecoveryPointApiResponsedata.py
+ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/ListRecoveryPointsApiResponsedata.py
+ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/MigrateConsistencyGroupApiResponsedata.py
 ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/ProtectedResourcePromoteApiResponsedata.py
 ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/ProtectedResourceRestoreApiResponsedata.py
-ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/RecoveryPointApiResponsedata.py
-ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/RecoveryPointListApiResponsedata.py
+ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/ProtectedResourceRestoreSpecoverrides.py
 ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/RecoveryPointReplicateApiResponsedata.py
+ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/RecoveryPointRepositoryProjectionobject_storage_reference.py
+ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/RecoveryPointRepositoryobject_storage_reference.py
 ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/RecoveryPointRestoreApiResponsedata.py
-ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/SyncedVolumeGroupByIdApiResponsedata.py
 ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/SynchronousReplicaPromoteApiResponsedata.py
+ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/UpdateConsistencyGroupApiResponsedata.py
 ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/UpdateRecoveryPointExpirationTimeApiResponsedata.py
-ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/VMRecoveryPointApiResponsedata.py
-ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/VMRecoveryPointListApiResponsedata.py
-ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/ValidateRestoreVmRecoveryPointApiResponsedata.py
-ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/VmRecoveryPointRestoreApiResponsedata.py
-ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/VolumeGroupRecoveryPointApiResponsedata.py
-ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/VolumeGroupRecoveryPointListApiResponsedata.py
-ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/VolumeGroupRecoveryPointRestoreApiResponsedata.py
-ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/WitnessApiResponsedata.py
 ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/config/__init__.py
 ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/error/ErrorResponseerror.py
 ntnx_dataprotection_py_client/models/OneOfdataprotection/v4/error/__init__.py
 ntnx_dataprotection_py_client/models/common/__init__.py
 ntnx_dataprotection_py_client/models/common/v1/__init__.py
 ntnx_dataprotection_py_client/models/common/v1/config/Flag.py
 ntnx_dataprotection_py_client/models/common/v1/config/IPv4Address.py
@@ -65,107 +58,87 @@
 ntnx_dataprotection_py_client/models/common/v1/response/ExternalizableAbstractModel.py
 ntnx_dataprotection_py_client/models/common/v1/response/__init__.py
 ntnx_dataprotection_py_client/models/dataprotection/__init__.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/__init__.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/common/BaseRecoveryPoint.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/common/RecoveryPointStatus.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/common/RecoveryPointType.py
-ntnx_dataprotection_py_client/models/dataprotection/v4/common/VendorSpecificProperty.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/common/__init__.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/config/AhvVmOverrideSpec.py
+ntnx_dataprotection_py_client/models/dataprotection/v4/config/AmazonS3Bucket.py
+ntnx_dataprotection_py_client/models/dataprotection/v4/config/AzureBlobStorageContainer.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/config/Category.py
-ntnx_dataprotection_py_client/models/dataprotection/v4/config/ChangedRegions.py
-ntnx_dataprotection_py_client/models/dataprotection/v4/config/ChangedRegionsListApiResponse.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/config/ClusterReference.py
+ntnx_dataprotection_py_client/models/dataprotection/v4/config/ComputeChangedRegionsResponse.py
+ntnx_dataprotection_py_client/models/dataprotection/v4/config/ComputeChangedRegionsResponseModel.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/config/ConsistencyGroup.py
-ntnx_dataprotection_py_client/models/dataprotection/v4/config/ConsistencyGroupApiResponse.py
-ntnx_dataprotection_py_client/models/dataprotection/v4/config/ConsistencyGroupListApiResponse.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/config/ConsistencyGroupMember.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/config/ConsistencyGroupMemberType.py
-ntnx_dataprotection_py_client/models/dataprotection/v4/config/ConsistencyGroupMigrateApiResponse.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/config/ConsistencyGroupMigrationSpec.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/config/ConsistencyGroupProjection.py
-ntnx_dataprotection_py_client/models/dataprotection/v4/config/ConsistencyGroupRecoveryPointSpec.py
-ntnx_dataprotection_py_client/models/dataprotection/v4/config/CreateConsistencyGroupRecoveryPointApiResponse.py
+ntnx_dataprotection_py_client/models/dataprotection/v4/config/CreateConsistencyGroupApiResponse.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/config/CreateRecoveryPointApiResponse.py
-ntnx_dataprotection_py_client/models/dataprotection/v4/config/DataProtectionInfo.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/config/DataProtectionSiteReference.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/config/DeleteConsistencyGroupApiResponse.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/config/DeleteRecoveryPointApiResponse.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/config/DisasterRecoveryLocation.py
-ntnx_dataprotection_py_client/models/dataprotection/v4/config/Disk.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/config/DiskRecoveryPoint.py
-ntnx_dataprotection_py_client/models/dataprotection/v4/config/DiskRecoveryPointApiResponse.py
-ntnx_dataprotection_py_client/models/dataprotection/v4/config/DiskRecoveryPointListApiResponse.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/config/EsxiVmOverrideSpec.py
-ntnx_dataprotection_py_client/models/dataprotection/v4/config/HardwareArchitecture.py
+ntnx_dataprotection_py_client/models/dataprotection/v4/config/ExpirationTimeSpec.py
+ntnx_dataprotection_py_client/models/dataprotection/v4/config/GetProtectedResourceApiResponse.py
+ntnx_dataprotection_py_client/models/dataprotection/v4/config/GetRecoveryPointApiResponse.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/config/HostReference.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/config/HostType.py
-ntnx_dataprotection_py_client/models/dataprotection/v4/config/HypervisorType.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/config/IpAddress.py
+ntnx_dataprotection_py_client/models/dataprotection/v4/config/ListRecoveryPointsApiResponse.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/config/LocationReference.py
-ntnx_dataprotection_py_client/models/dataprotection/v4/config/PowerState.py
+ntnx_dataprotection_py_client/models/dataprotection/v4/config/MigrateConsistencyGroupApiResponse.py
+ntnx_dataprotection_py_client/models/dataprotection/v4/config/NutanixObjectsBucket.py
+ntnx_dataprotection_py_client/models/dataprotection/v4/config/ObjectStorageType.py
+ntnx_dataprotection_py_client/models/dataprotection/v4/config/ProtectedEntityType.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/config/ProtectedResource.py
-ntnx_dataprotection_py_client/models/dataprotection/v4/config/ProtectedResourceApiResponse.py
-ntnx_dataprotection_py_client/models/dataprotection/v4/config/ProtectedResourceEntityType.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/config/ProtectedResourcePromoteApiResponse.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/config/ProtectedResourceReplicationStatus.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/config/ProtectedResourceRestoreApiResponse.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/config/ProtectedResourceRestoreSpec.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/config/RecoveryInfo.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/config/RecoveryPoint.py
-ntnx_dataprotection_py_client/models/dataprotection/v4/config/RecoveryPointApiResponse.py
-ntnx_dataprotection_py_client/models/dataprotection/v4/config/RecoveryPointListApiResponse.py
+ntnx_dataprotection_py_client/models/dataprotection/v4/config/RecoveryPointProjection.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/config/RecoveryPointReplicateApiResponse.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/config/RecoveryPointReplicationSpec.py
+ntnx_dataprotection_py_client/models/dataprotection/v4/config/RecoveryPointRepository.py
+ntnx_dataprotection_py_client/models/dataprotection/v4/config/RecoveryPointRepositoryProjection.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/config/RecoveryPointRestorationSpec.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/config/RecoveryPointRestoreApiResponse.py
-ntnx_dataprotection_py_client/models/dataprotection/v4/config/Regions.py
+ntnx_dataprotection_py_client/models/dataprotection/v4/config/RedirectionResponse.py
+ntnx_dataprotection_py_client/models/dataprotection/v4/config/Region.py
+ntnx_dataprotection_py_client/models/dataprotection/v4/config/RegionResponse.py
+ntnx_dataprotection_py_client/models/dataprotection/v4/config/RegionType.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/config/ReplicationState.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/config/RestorableTimeRange.py
-ntnx_dataprotection_py_client/models/dataprotection/v4/config/SetExpirationTimeSpec.py
+ntnx_dataprotection_py_client/models/dataprotection/v4/config/SiteProtectionInfo.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/config/SiteReference.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/config/Subnet.py
-ntnx_dataprotection_py_client/models/dataprotection/v4/config/SyncedVolumeGroupByIdApiResponse.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/config/SynchronousReplicaPromoteApiResponse.py
+ntnx_dataprotection_py_client/models/dataprotection/v4/config/UpdateConsistencyGroupApiResponse.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/config/UpdateRecoveryPointExpirationTimeApiResponse.py
-ntnx_dataprotection_py_client/models/dataprotection/v4/config/VMRecoveryPoint.py
-ntnx_dataprotection_py_client/models/dataprotection/v4/config/VMRecoveryPointApiResponse.py
-ntnx_dataprotection_py_client/models/dataprotection/v4/config/VMRecoveryPointListApiResponse.py
-ntnx_dataprotection_py_client/models/dataprotection/v4/config/ValidateRecoveryPointResult.py
-ntnx_dataprotection_py_client/models/dataprotection/v4/config/ValidateRestoreVmRecoveryPointApiResponse.py
-ntnx_dataprotection_py_client/models/dataprotection/v4/config/ValidationSeverity.py
-ntnx_dataprotection_py_client/models/dataprotection/v4/config/Vm.py
-ntnx_dataprotection_py_client/models/dataprotection/v4/config/VmRecoveryPointRestorationSpec.py
-ntnx_dataprotection_py_client/models/dataprotection/v4/config/VmRecoveryPointRestoreApiResponse.py
+ntnx_dataprotection_py_client/models/dataprotection/v4/config/VmRecoveryPoint.py
+ntnx_dataprotection_py_client/models/dataprotection/v4/config/VmRecoveryPointComputeChangedRegionsRequest.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/config/VmRecoveryPointRestoreOverride.py
-ntnx_dataprotection_py_client/models/dataprotection/v4/config/VmSubRecoveryPoint.py
-ntnx_dataprotection_py_client/models/dataprotection/v4/config/VmSubRecoveryPointProjection.py
-ntnx_dataprotection_py_client/models/dataprotection/v4/config/VolumeGroup.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/config/VolumeGroupOverrideSpec.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/config/VolumeGroupRecoveryPoint.py
-ntnx_dataprotection_py_client/models/dataprotection/v4/config/VolumeGroupRecoveryPointApiResponse.py
-ntnx_dataprotection_py_client/models/dataprotection/v4/config/VolumeGroupRecoveryPointListApiResponse.py
-ntnx_dataprotection_py_client/models/dataprotection/v4/config/VolumeGroupRecoveryPointRestorationSpec.py
-ntnx_dataprotection_py_client/models/dataprotection/v4/config/VolumeGroupRecoveryPointRestoreApiResponse.py
+ntnx_dataprotection_py_client/models/dataprotection/v4/config/VolumeGroupRecoveryPointComputeChangedRegionsRequest.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/config/VolumeGroupRecoveryPointRestoreOverride.py
-ntnx_dataprotection_py_client/models/dataprotection/v4/config/VolumeGroupSubRecoveryPoint.py
-ntnx_dataprotection_py_client/models/dataprotection/v4/config/VolumeGroupSubRecoveryPointProjection.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/config/VolumeGroupSyncContext.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/config/VpcReference.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/config/Witness.py
-ntnx_dataprotection_py_client/models/dataprotection/v4/config/WitnessApiResponse.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/config/WitnessAvailabilityStatus.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/config/__init__.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/error/AppMessage.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/error/ErrorResponse.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/error/SchemaValidationError.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/error/SchemaValidationErrorMessage.py
 ntnx_dataprotection_py_client/models/dataprotection/v4/error/__init__.py
 ntnx_dataprotection_py_client/models/prism/__init__.py
 ntnx_dataprotection_py_client/models/prism/v4/__init__.py
 ntnx_dataprotection_py_client/models/prism/v4/config/TaskReference.py
-ntnx_dataprotection_py_client/models/prism/v4/config/__init__.py
-ntnx_dataprotection_py_client/models/storage/__init__.py
-ntnx_dataprotection_py_client/models/storage/v4/__init__.py
-ntnx_dataprotection_py_client/models/storage/v4/config/Task.py
-ntnx_dataprotection_py_client/models/storage/v4/config/__init__.py
+ntnx_dataprotection_py_client/models/prism/v4/config/__init__.py
```

### Comparing `ntnx-dataprotection-py-client-4.0.1a4/setup.py` & `ntnx_dataprotection_py_client-4.0.1b1/setup.py`

 * *Files 3% similar despite different names*

```diff
@@ -3,33 +3,33 @@
 
 """
 IGNORE:
     Nutanix Dataprotection Versioned APIs
 
     Business Continuity with full spectrum of Disaster Recovery and Backup solution. Spanning across Single PC, Cross AZ, MultiSite. Configuration of Recovery points, Protection policies, Recovery Plans. Execution and monitoring of back up and recovery orchestrations on OnPrem as well as Cloud.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-4
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import io
 import os
 from setuptools import setup, find_packages  # noqa: H301
 
 NAME = "ntnx-dataprotection-py-client"
-VERSION = "4.0.1a4"
+VERSION = "4.0.1b1"
 # To install the library, run the following
 #
 # python setup.py install
 #
 # prerequisite: setuptools
 # http://pypi.python.org/pypi/setuptools
 
-REQUIRES = ["urllib3 ~= 1.26", "six ~= 1.16", "certifi == 2020.4.5.1", "python-dateutil ~= 2.8", "pysocks ~= 1.7"]
+REQUIRES = ["urllib3 ~= 1.26", "six ~= 1.16", "certifi >=2020.4.5.1,<=2023.11.17", "python-dateutil ~= 2.8", "pysocks ~= 1.7"]
 
 package_root_path = os.path.abspath(os.path.dirname(__file__))
 readme_file_path = os.path.join(package_root_path, "README.md")
 with io.open(readme_file_path, encoding="utf-8") as readme_file:
     readme = readme_file.read()
 
 setup(
```

