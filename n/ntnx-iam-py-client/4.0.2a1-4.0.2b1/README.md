# Comparing `tmp/ntnx-iam-py-client-4.0.2a1.tar.gz` & `tmp/ntnx_iam_py_client-4.0.2b1.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "/home/circleci/project/verify/pip-release-verify/prod-package-iam/dist/.tmp-1e8e6oha/ntnx-iam-py-client-4.0.2a1.tar", last modified: Tue Feb  7 21:34:11 2023, max compression
+gzip compressed data, was "/home/circleci/project/verify/pip-release-verify/prod-package-iam/dist/.tmp-adyvlwtn/ntnx_iam_py_client-4.0.2b1.tar", last modified: Fri May 17 07:11:29 2024, max compression
```

## Comparing `ntnx-iam-py-client-4.0.2a1.tar` & `ntnx_iam_py_client-4.0.2b1.tar`

### file list

```diff
@@ -1,189 +1,312 @@
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-02-07 21:34:11.709088 ntnx-iam-py-client-4.0.2a1/
--rw-r--r--   0 circleci  (3434) circleci  (3434)    18137 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/LICENSE.txt
--rw-r--r--   0 circleci  (3434) circleci  (3434)    11539 2023-02-07 21:34:11.709088 ntnx-iam-py-client-4.0.2a1/PKG-INFO
--rw-r--r--   0 circleci  (3434) circleci  (3434)    11277 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/README.md
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-02-07 21:34:11.669087 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-02-07 21:34:11.669087 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-02-07 21:34:11.669087 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfcommon/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfcommon/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-02-07 21:34:11.669087 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfcommon/v1/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfcommon/v1/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-02-07 21:34:11.669087 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfcommon/v1/config/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6209 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfcommon/v1/config/KVPairvalue.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfcommon/v1/config/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-02-07 21:34:11.669087 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-02-07 21:34:11.669087 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-02-07 21:34:11.677087 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authn/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6365 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authn/ActivateUserApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6419 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authn/ChangeUserPasswordApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6491 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authn/ConnectionDirectoryServiceApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6529 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authn/CreateCertAuthProviderApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6529 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authn/CreateDirectoryServiceApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6573 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authn/CreateSamlIdentityProviderApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6397 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authn/CreateUserApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6452 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authn/CreateUserGroupApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6502 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authn/GetCertAuthProviderApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6502 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authn/GetDirectoryServiceApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6546 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authn/GetSamlIdentityProviderApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6435 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authn/GetSamlSpMetadataApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6370 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authn/GetUserApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6425 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authn/GetUserGroupApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6523 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authn/ListCertAuthProviderApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6523 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authn/ListDirectoryServiceApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6567 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authn/ListSamlIdentityProviderApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6391 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authn/ListUserApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6446 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authn/ListUserGroupApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6410 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authn/ResetUserPasswordApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6553 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authn/SearchDirectoryServiceApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6529 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authn/UpdateCertAuthProviderApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6529 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authn/UpdateDirectoryServiceApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6573 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authn/UpdateSamlIdentityProviderApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6397 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authn/UpdateUserApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authn/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-02-07 21:34:11.681087 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authz/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6483 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authz/CreateAccessPolicyApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6411 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authz/CreateRoleApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6419 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authz/DeleteAccessPolicyApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6347 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authz/DeleteRoleApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6479 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authz/ListAccessPolicyApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6446 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authz/ListOperationApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6391 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authz/ListRoleApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6483 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authz/UpdateAccessPolicyApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6411 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authz/UpdateRoleApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6467 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authz/ViewAccessPolicyApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6434 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authz/ViewOperationApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6379 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authz/ViewRoleApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authz/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-02-07 21:34:11.681087 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/error/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6375 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/error/ErrorResponseerror.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/error/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    12846 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-02-07 21:34:11.681087 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/common/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/common/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-02-07 21:34:11.681087 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/common/v1/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/common/v1/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-02-07 21:34:11.685087 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/common/v1/config/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6560 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/common/v1/config/Flag.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6912 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/common/v1/config/KVPair.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7340 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/common/v1/config/Message.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4794 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/common/v1/config/MessageSeverity.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6964 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/common/v1/config/TenantAwareModel.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/common/v1/config/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-02-07 21:34:11.685087 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/common/v1/response/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6658 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/common/v1/response/ApiLink.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8642 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/common/v1/response/ApiResponseMetadata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     5560 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/common/v1/response/ExternalizableAbstractModel.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/common/v1/response/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-02-07 21:34:11.685087 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-02-07 21:34:11.685087 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-02-07 21:34:11.697087 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7273 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/ActivateUserApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    11345 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/CertAuthProvider.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8967 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/CertRevocationInfo.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7328 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/ChangeUserPasswordApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7422 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/ConnectionDirectoryServiceApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7389 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/CreateCertAuthProviderApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7388 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/CreateDirectoryServiceApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7437 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/CreateSamlIdentityProviderApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7243 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/CreateUserApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7304 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/CreateUserGroupApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    11655 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/DirectoryService.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7067 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/DirectoryServiceConnectionRequest.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7900 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/DirectoryServiceInfo.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4893 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/DirectoryServiceInfoGroup.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4864 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/DirectoryServiceInfoOu.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6728 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/DirectoryServiceSearchAttribute.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7450 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/DirectoryServiceSearchEntity.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8317 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/DirectoryServiceSearchQuery.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7191 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/DirectoryServiceSearchResult.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4787 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/DirectoryType.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6959 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/DsServiceAccount.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7366 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/GetCertAuthProviderApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7365 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/GetDirectoryServiceApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7414 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/GetSamlIdentityProviderApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7335 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/GetSamlSpMetadataApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7220 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/GetUserApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7281 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/GetUserGroupApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4819 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/GroupSearchType.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4709 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/GroupType.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    11776 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/IdpProperties.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7374 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/ListCertAuthProviderApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7373 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/ListDirectoryServiceApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7422 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/ListSamlIdentityProviderApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7228 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/ListUserApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7289 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/ListUserGroupApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     5175 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/NameIdPolicyFormat.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7407 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/OpenLdapConfig.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7600 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/PasswordChangeRequest.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6299 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/PasswordResetRequest.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7325 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/ResetUserPasswordApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    14901 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/SamlIdentityProvider.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7415 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/SearchDirectoryServiceApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7396 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/UpdateCertAuthProviderApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7395 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/UpdateDirectoryServiceApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7444 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/UpdateSamlIdentityProviderApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7250 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/UpdateUserApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    14653 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/User.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8358 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/UserConfiguration.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8214 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/UserGroup.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     9625 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/UserGroupConfiguration.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6285 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/UserStateUpdate.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4753 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/UserStatusType.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4770 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/UserType.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-02-07 21:34:11.705088 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authz/
--rw-r--r--   0 circleci  (3434) circleci  (3434)    11348 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authz/AccessPolicy.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     5086 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authz/AccessPolicyType.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7339 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authz/CreateAccessPolicyApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7250 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authz/CreateRoleApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7322 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authz/DeleteAccessPolicyApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7233 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authz/DeleteRoleApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     5586 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authz/Filter.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7325 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authz/ListAccessPolicyApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7288 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authz/ListOperationApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7228 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authz/ListRoleApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7959 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authz/Operation.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    10282 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authz/Role.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     5058 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authz/StatusType.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7346 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authz/UpdateAccessPolicyApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7257 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authz/UpdateRoleApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7327 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authz/ViewAccessPolicyApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7290 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authz/ViewOperationApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7230 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authz/ViewRoleApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authz/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-02-07 21:34:11.705088 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/common/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4731 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/common/SortOrderType.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/common/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-02-07 21:34:11.705088 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/error/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8290 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/error/AppMessage.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6639 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/error/ErrorResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8160 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/error/SchemaValidationError.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7073 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/error/SchemaValidationErrorMessage.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/error/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    13489 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-02-07 21:34:11.709088 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/api/
--rw-r--r--   0 circleci  (3434) circleci  (3434)      627 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/api/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    28084 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/api/access_policy_api.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    30508 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/api/cert_auth_provider_api.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    34357 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/api/directory_service_api.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    13967 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/api/operation_api.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    27095 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/api/role_api.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    28014 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/api/saml_identity_provider_api.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    37718 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/api/user_api.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    18317 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/api/user_group_api.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    33312 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/api_client.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     2545 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/api_response.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    16157 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/configuration.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    15716 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/rest.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-02-07 21:34:11.669087 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client.egg-info/
--rw-r--r--   0 circleci  (3434) circleci  (3434)    11539 2023-02-07 21:34:11.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client.egg-info/PKG-INFO
--rw-r--r--   0 circleci  (3434) circleci  (3434)     9953 2023-02-07 21:34:11.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client.egg-info/SOURCES.txt
--rw-r--r--   0 circleci  (3434) circleci  (3434)        1 2023-02-07 21:34:11.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client.egg-info/dependency_links.txt
--rw-r--r--   0 circleci  (3434) circleci  (3434)       78 2023-02-07 21:34:11.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client.egg-info/requires.txt
--rw-r--r--   0 circleci  (3434) circleci  (3434)       19 2023-02-07 21:34:11.000000 ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client.egg-info/top_level.txt
--rw-r--r--   0 circleci  (3434) circleci  (3434)       38 2023-02-07 21:34:11.709088 ntnx-iam-py-client-4.0.2a1/setup.cfg
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1248 2023-02-07 21:34:01.000000 ntnx-iam-py-client-4.0.2a1/setup.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:29.517442 ntnx_iam_py_client-4.0.2b1/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    18137 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/LICENSE.txt
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    12032 2024-05-17 07:11:29.516442 ntnx_iam_py_client-4.0.2b1/PKG-INFO
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    11604 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/README.md
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:29.459441 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    25811 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:29.463441 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/api/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      945 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/api/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5543 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/api/api_keys_api.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    29405 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/api/authorization_policies_api.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    35806 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/api/certificate_authentication_providers_api.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    13054 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/api/clients_api.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    39821 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/api/directory_services_api.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    13020 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/api/entities_api.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    13113 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/api/operations_api.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    27752 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/api/roles_api.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    32950 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/api/saml_identity_providers_api.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    76993 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/api/service_accounts_api.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    22549 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/api/user_groups_api.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    62051 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/api/users_api.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    57314 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/api_client.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2389 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/api_response.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    16895 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/configuration.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:29.463441 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:29.464441 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfcommon/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfcommon/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:29.464441 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfcommon/v1/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfcommon/v1/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:29.464441 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfcommon/v1/config/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6935 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfcommon/v1/config/KVPairvalue.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfcommon/v1/config/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:29.464441 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:29.465441 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:29.476441 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7034 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/ActivateUserApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7074 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/ChangeUserPasswordApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7154 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/ConnectionDirectoryServiceApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7000 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/CreateApiKeyApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7090 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/CreateCertAuthProviderApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7090 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/CreateDirectoryServiceApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7126 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/CreateSamlIdentityProviderApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7072 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/CreateServiceAccountApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7099 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/CreateServiceAccountKeyApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7054 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/CreateSystemConfigApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6982 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/CreateUserApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7027 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/CreateUserGroupApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7027 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/CreateUserKeyApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6946 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/DeleteApiKeyApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7016 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/DeleteCertAuthProviderApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7016 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/DeleteDirectoryServiceApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7044 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/DeleteSamlIdentityProviderApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7002 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/DeleteServiceAccountApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7023 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/DeleteServiceAccountKeyApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6988 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/DeleteSystemConfigApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6932 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/DeleteUserApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6967 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/DeleteUserGroupApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6953 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/DeleteUserKeyApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6979 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/GetApiKeyApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7069 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/GetCertAuthProviderApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7069 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/GetDirectoryServiceApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7105 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/GetSamlIdentityProviderApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7006 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/GetSamlSpMetadataApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7051 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/GetServiceAccountApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7078 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/GetServiceAccountKeyApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6961 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/GetUserApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7006 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/GetUserGroupApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7005 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/ListApiKeysApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7095 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/ListCertAuthProvidersApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7095 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/ListDirectoryServicesApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7131 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/ListSamlIdentityProvidersApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7104 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/ListServiceAccountKeysApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7077 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/ListServiceAccountsApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7074 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/ListUserBucketKeysApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7032 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/ListUserGroupsApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6987 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/ListUsersApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7065 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/ResetUserPasswordApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7028 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/RevokeApiKeyApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7114 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/SearchDirectoryServiceApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7090 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/UpdateCertAuthProviderApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7090 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/UpdateDirectoryServiceApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7126 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/UpdateSamlIdentityProviderApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7054 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/UpdateSystemConfigApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6982 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/UpdateUserApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7046 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/ValidateApiKeyApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:29.480441 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authz/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7117 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authz/CreateAuthorizationPolicyApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6982 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authz/CreateRoleApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7037 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authz/DeleteAuthorizationPolicyApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6932 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authz/DeleteRoleApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7096 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authz/GetAuthorizationPolicyApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6979 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authz/GetClientApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6979 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authz/GetEntityApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7006 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authz/GetOperationApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6961 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authz/GetRoleApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7241 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authz/ListAuthorizationPoliciesApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7005 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authz/ListClientsApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7012 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authz/ListEntitiesApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7032 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authz/ListOperationsApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7069 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authz/ListRolesApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7101 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authz/UpdateAuthorizationPolicyApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7010 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authz/UpdateClientApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6996 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authz/UpdateRoleApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authz/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:29.480441 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/error/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6974 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/error/ErrorResponseerror.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/error/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    24850 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:29.480441 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/common/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/common/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:29.480441 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/common/v1/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/common/v1/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:29.481441 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/common/v1/config/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7061 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/common/v1/config/Flag.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7476 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/common/v1/config/KVPair.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8216 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/common/v1/config/Message.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5124 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/common/v1/config/MessageSeverity.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7710 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/common/v1/config/TenantAwareModel.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/common/v1/config/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:29.482441 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/common/v1/response/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7362 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/common/v1/response/ApiLink.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    10562 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/common/v1/response/ApiResponseMetadata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6075 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/common/v1/response/ExternalizableAbstractModel.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/common/v1/response/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:29.482441 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:29.483441 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:29.505442 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7713 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/ActivateUserApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     4911 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/AlgoType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    11497 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/ApiKey.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7641 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/ApiKeyCustomOptions.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     3965 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/ApiKeyRevokeResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5093 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/ApiKeyStatusType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6876 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/ApiKeyValidateRequest.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6317 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/ApiKeyValidateResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5034 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/AuthMethodType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8089 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/BucketsAccessKey.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    13041 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/CertAuthProvider.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    10275 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/CertRevocationInfo.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7749 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/ChangeUserPasswordApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5243 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/ClaimsType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7847 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/ConnectionDirectoryServiceApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7694 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/CreateApiKeyApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7760 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/CreateCertAuthProviderApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7759 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/CreateDirectoryServiceApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7796 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/CreateSamlIdentityProviderApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7741 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/CreateServiceAccountApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7785 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/CreateServiceAccountKeyApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7722 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/CreateSystemConfigApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7650 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/CreateUserApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7696 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/CreateUserGroupApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7711 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/CreateUserKeyApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7635 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/DeleteApiKeyApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7685 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/DeleteCertAuthProviderApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7684 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/DeleteDirectoryServiceApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7717 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/DeleteSamlIdentityProviderApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7668 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/DeleteServiceAccountApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7715 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/DeleteServiceAccountKeyApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7651 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/DeleteSystemConfigApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7587 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/DeleteUserApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7628 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/DeleteUserGroupApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7640 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/DeleteUserKeyApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    14111 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/DirectoryService.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7858 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/DirectoryServiceConnectionRequest.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     4042 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/DirectoryServiceConnectionResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8638 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/DirectoryServiceInfo.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5087 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/DirectoryServiceInfoGroup.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5064 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/DirectoryServiceInfoOu.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7196 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/DirectoryServiceSearchAttribute.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8104 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/DirectoryServiceSearchEntity.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     9311 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/DirectoryServiceSearchQuery.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7770 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/DirectoryServiceSearchResult.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5089 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/DirectoryType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     4954 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/DiscoverySubjectType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7804 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/DsServiceAccount.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    11192 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/Federation.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7193 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/FederationClaims.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7686 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/GetApiKeyApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7746 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/GetCertAuthProviderApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7745 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/GetDirectoryServiceApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7782 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/GetSamlIdentityProviderApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7669 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/GetSamlSpMetadataApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7727 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/GetServiceAccountApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7777 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/GetServiceAccountKeyApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7636 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/GetUserApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7682 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/GetUserGroupApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5278 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/GrantType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5143 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/Group.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5114 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/GroupSearchType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5034 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/GroupType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    12967 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/IdpMetadata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     4886 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/KeyType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7686 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/ListApiKeysApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7752 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/ListCertAuthProvidersApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7751 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/ListDirectoryServicesApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7788 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/ListSamlIdentityProvidersApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7777 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/ListServiceAccountKeysApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7733 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/ListServiceAccountsApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7745 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/ListUserBucketKeysApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7688 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/ListUserGroupsApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7642 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/ListUsersApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5412 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/NameIdPolicyFormat.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    10070 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/OidcKey.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5091 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/OidcSubjectType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    15080 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/OidcUserinfo.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8044 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/OpenLdapConfig.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8326 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/PasswordChangeRequest.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     3979 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/PasswordChangeResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6726 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/PasswordResetRequest.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     3967 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/PasswordResetResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7748 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/ResetUserPasswordApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5003 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/ResponseType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7738 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/RevokeApiKeyApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    18023 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/SamlIdentityProvider.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     4981 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/ScopeType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     4993 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/ScopesType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7795 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/SearchDirectoryServiceApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6777 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/SecretKeyRequest.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    11159 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/SecretKeyResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    11485 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/ServiceAccount.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    10444 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/ServiceAccountKey.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     4940 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/SigningAlgoType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5025 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/SubjectType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7456 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/SystemConfig.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5062 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/Tenant.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    15343 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/TokenRequest.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7767 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/UpdateCertAuthProviderApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7766 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/UpdateDirectoryServiceApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7803 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/UpdateSamlIdentityProviderApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7729 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/UpdateSystemConfigApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7657 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/UpdateUserApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     4890 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/UseType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    21245 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/User.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     9199 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/UserConfiguration.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     9865 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/UserGroup.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    10709 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/UserGroupConfiguration.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6707 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/UserStateUpdate.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     3980 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/UserStateUpdateResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5080 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/UserStatusType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5007 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/UserType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7717 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/ValidateApiKeyApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:29.514442 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     4993 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/ApiVersion.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8462 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/AssociatedEndpoint.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7165 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/AttributeEntity.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    14201 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/AuthorizationPolicy.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6420 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/AuthorizationPolicyProjection.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5562 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/AuthorizationPolicyType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7681 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/AuthorizationRequest.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6847 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/AuthorizationResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8460 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/AuthorizationResponseObject.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7857 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/AuthorizeEntity.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    10122 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/Client.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7787 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/CreateAuthorizationPolicyApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7650 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/CreateRoleApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7709 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/DeleteAuthorizationPolicyApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7587 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/DeleteRoleApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    12720 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/Entity.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5938 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/EntityFilter.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5074 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/EntityOperators.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7773 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/GetAuthorizationPolicyApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7654 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/GetClientApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7655 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/GetEntityApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7681 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/GetOperationApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7636 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/GetRoleApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5164 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/HttpMethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5946 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/IdentityFilter.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7364 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/IdentityObject.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     4979 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/IdentityType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7884 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/ListAuthorizationPoliciesApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7660 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/ListClientsApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7668 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/ListEntitiesApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7687 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/ListOperationsApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7725 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/ListRolesApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    12675 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/Operation.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5520 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/OperationType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8126 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/RequestObject.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5014 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/ResponseType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    14166 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/Role.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7672 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/RoleProjection.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     4985 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/Tenant.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7786 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/UpdateAuthorizationPolicyApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7680 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/UpdateClientApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7664 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/UpdateRoleApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:29.514442 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/common/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6629 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/common/ActionBaseResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     4948 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/common/SortOrderType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/common/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:29.515442 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/error/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     9845 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/error/AppMessage.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6947 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/error/ErrorResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     9350 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/error/SchemaValidationError.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8083 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/error/SchemaValidationErrorMessage.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/error/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:29.516442 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/tenant/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5784 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/tenant/Tenant.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/tenant/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    16547 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/rest.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:29.516442 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client.egg-info/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    12032 2024-05-17 07:11:29.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client.egg-info/PKG-INFO
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    18323 2024-05-17 07:11:29.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client.egg-info/SOURCES.txt
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        1 2024-05-17 07:11:29.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client.egg-info/dependency_links.txt
+-rw-r--r--   0 circleci  (3434) circleci  (3434)       91 2024-05-17 07:11:29.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client.egg-info/requires.txt
+-rw-r--r--   0 circleci  (3434) circleci  (3434)       19 2024-05-17 07:11:29.000000 ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client.egg-info/top_level.txt
+-rw-r--r--   0 circleci  (3434) circleci  (3434)       38 2024-05-17 07:11:29.517442 ntnx_iam_py_client-4.0.2b1/setup.cfg
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1267 2024-05-17 07:11:24.000000 ntnx_iam_py_client-4.0.2b1/setup.py
```

### Comparing `ntnx-iam-py-client-4.0.2a1/LICENSE.txt` & `ntnx_iam_py_client-4.0.2b1/LICENSE.txt`

 * *Files identical despite different names*

### Comparing `ntnx-iam-py-client-4.0.2a1/PKG-INFO` & `ntnx_iam_py_client-4.0.2b1/README.md`

 * *Files 6% similar despite different names*

```diff
@@ -1,32 +1,22 @@
-Metadata-Version: 2.1
-Name: ntnx-iam-py-client
-Version: 4.0.2a1
-Summary: Nutanix Iam Versioned APIs
-Home-page: 
-Author-email: sdk@nutanix.com
-Keywords: Nutanix,v4,SDK,Nutanix Iam Versioned APIs
-Description-Content-Type: text/markdown
-License-File: LICENSE.txt
-
 # Python Client For Nutanix Iam Versioned APIs
 
-The Python client for Nutanix Iam Versioned APIs is designed for Python client application developers offering them simple and flexible access to APIs that identity and Access Management in Nutanix cluster.
+The Python client for Nutanix Iam Versioned APIs is designed for Python client application developers offering them simple and flexible access to APIs that manage Identity and Access Management of Nutanix clusters.
 ## Features
 - Invoke Nutanix APIs with a simple interface.
 - Handle Authentication seamlessly.
 - Reduce boilerplate code implementation.
 - Use standard methods for installation.
 
 ## Version
-- API version: v4.0.a1
-- Package version: 4.0.2a1
+- API version: v4.0.b1
+- Package version: 4.0.2b1
 
 ## Requirements.
-Python 3.6, 3.7, and 3.8 are fully supported and tested.
+Python 3.6, 3.7, 3.8 and 3.9 are fully supported and tested.
 
 
 ## Installation & Usage
 
 ### Installing in a virtual environment
 [virtualenv](https://virtualenv.pypa.io/en/latest/) is a tool to create isolated Python environments. The basic problem it addresses is one of dependencies and versions, and indirectly permissions. virtualenv can help you install this client without needing system install permissions. It creates an environment that has its own installation directories without sharing libraries with other virtualenv environments or the system installation.
 
@@ -80,14 +70,15 @@
 | debug     | Runs the client in debug mode if specified                                       | No       | False        |
 | verify_ssl| Verify SSL certificate of cluster the client will connect to                     | No       | True         |
 | max_retry_attempts| Maximum number of retry attempts while connecting to the cluster         | No       | 5            |
 | backoff_factor| A backoff factor to apply between attempts after the second try.             | No       | 3            |
 | logger_file | File location to which debug logs are written to                               | No       | N/A          |
 | connect_timeout | Connection timeout in milliseconds for all operations                      | No       | 30000        |
 | read_timeout | Read timeout in milliseconds for all operations                               | No       | 30000        |
+| download_directory| Directory where downloaded files will be stored in                       | No       | Current Working Directory|
 
 
 ### Sample Configuration
 ```python
 config = Configuration()
 config.host = '10.19.50.27' # IPv4/IPv6 address or FQDN of the cluster
 config.port = 9440 # Port to which to connect to
@@ -137,79 +128,79 @@
 ```
 
 ## Usage
 
 ### Invoking an operation
 ```python
 # Initialize the API
-cert_auth_provider_api_instance = CertAuthProviderApi(api_client=client) # client configured in previous step
+certificate_authentication_providers_api_instance = CertificateAuthenticationProvidersApi(api_client=client) # client configured in previous step
 extId = 'extId_example' # UUID.
 
-# Get certificate based authentication provider
+# Get Certificate based Authentication provider
 try:
-    api_response = cert_auth_provider_api_instance.handle_get_cert_auth_provider(extId)
+    api_response = certificate_authentication_providers_api_instance.get_cert_auth_provider_by_id(extId)
 except ApiException as e:
 ```
 
 ### Setting headers for individual operations
 Headers can be configured globally on the python client using the [method to set default headers](#additional-headers). However, sometimes headers need to be set on an individual operation basis. Nutanix APIs require that concurrent updates are protected using [ETag headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag).
 
 ```python
 # Initialize the API
-cert_auth_provider_api_instance = CertAuthProviderApi(api_client=client) # client configured in previous step
+certificate_authentication_providers_api_instance = CertificateAuthenticationProvidersApi(api_client=client) # client configured in previous step
 extId = 'extId_example' # UUID.
 
-# Get certificate based authentication provider
+# Get Certificate based Authentication provider
 try:
-    api_response = cert_auth_provider_api_instance.handle_get_cert_auth_provider(extId)
+    api_response = certificate_authentication_providers_api_instance.get_cert_auth_provider_by_id(extId)
 except ApiException as e:
 
 # Extract E-Tag Header
 etag_value = ApiClient.get_etag(api_response)
 
-# Update certificate based authentication provider
+# Update Certificate based Authentication provider
 try:
     # The body parameter in the following operation is received from the previous GET request's response which needs to be updated.
-    api_response = cert_auth_provider_api_instance.handle_update_cert_auth_provider(body, extId, if_match=etag_value) # Use the extracted etag value
+    api_response = certificate_authentication_providers_api_instance.update_cert_auth_provider_by_id(body, extId, if_match=etag_value) # Use the extracted etag value
 except ApiException as e:
 ```
 
 ### List Operations
 List Operations for Nutanix APIs support pagination, filtering, sorting and projections. The table below details the parameters that can be used to set the options for pagination etc.
 
 | Parameter | Description
 |-----------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
 | _page     | specifies the page number of the result set. Must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range will lead to no results being returned.|
 | _limit    | specifies the total number of records returned in the result set. Must be a positive integer between 0 and 100. Any number out of this range will lead to a validation error. If the limit is not provided a default value of 50 records will be returned in the result set|
 | _filter   | allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the [OData V4.01 URL](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part2-url-conventions.html#sec_SystemQueryOptionfilter) conventions. |
 | _orderby  | allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified the resources will be sorted in ascending order by default. For example, 'orderby=templateName desc' would get all templates sorted by templateName in desc order. |
-| _select   | allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the OData V4.01 URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e. *), then all properties on the matching resource will be returned. |
-| _expand   | allows clients to request related resources when a resource that satisfies a particular request is retrieved. Each expand item is evaluated relative to the entity containing the property being expanded. Other query options can be applied to an expanded property by appending a semicolon-separated list of query options, enclosed in parentheses, to the property name. Allowed system query options are $filter,$select, $orderby. |
+| _select   | allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the OData V4.01 URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e., *), then all properties on the matching resource will be returned. |
+| _expand   | allows clients to request related resources when a resource that satisfies a particular request is retrieved. Each expanded item is evaluated relative to the entity containing the property being expanded. Other query options can be applied to an expanded property by appending a semicolon-separated list of query options, enclosed in parentheses, to the property name. Permissible system query options are $filter,$select and $orderby. |
 
 ```python
 # Initialize the API
-cert_auth_provider_api_instance = CertAuthProviderApi(api_client=client) # client configured in previous step
+certificate_authentication_providers_api_instance = CertificateAuthenticationProvidersApi(api_client=client) # client configured in previous step
 extId = 'extId_example' # UUID.
 
-# List certificate based authentication provider(s)
+# List Certificate based Authentication provider(s)
 try:
-    api_response = cert_auth_provider_api_instance.handle_list_cert_auth_providers(
+    api_response = certificate_authentication_providers_api_instance.list_cert_auth_providers(
 	                   _page=page, # if page parameter is present
 	                   _limit=limit, # if limit parameter is present
 	                   _filter=_filter, # if filter parameter is present
 	                   _orderby=_orderby, # if orderby parameter is present
 	                   _select=select, # if select parameter is present
 	                   _expand=expand) # if expand parameter is present
 except ApiException as e:
 
 ```
 The list of filterable and sortable fields with expansion keys can be found in the documentation [here](https://developers.nutanix.com/).
 
 ## API Reference
 
-This library has a full set of [API Reference Documentation](https://developers.nutanix.com/sdk-reference?namespace=iam&version=v4.0.a1&language=python). This documentation is auto-generated, and the location may change.
+This library has a full set of [API Reference Documentation](https://developers.nutanix.com/sdk-reference?namespace=iam&version=v4.0.b1&language=python). This documentation is auto-generated, and the location may change.
 
 ## License
 This library is licensed under Nutanix proprietary license. Full license text is available in [LICENSE](https://developers.nutanix.com/license).
 
 ## Contact us
-In case of issues please reach out to us at the [mailing list](mailto:sdk@nutanix.com)
+In case of issues please reach out to us at the [mailing list](mailto:sdk@nutanix.com)
```

### Comparing `ntnx-iam-py-client-4.0.2a1/README.md` & `ntnx_iam_py_client-4.0.2b1/PKG-INFO`

 * *Files 6% similar despite different names*

```diff
@@ -1,22 +1,37 @@
+Metadata-Version: 2.1
+Name: ntnx-iam-py-client
+Version: 4.0.2b1
+Summary: Nutanix Iam Versioned APIs
+Home-page: 
+Author-email: sdk@nutanix.com
+Keywords: Nutanix,v4,SDK,Nutanix Iam Versioned APIs
+Description-Content-Type: text/markdown
+License-File: LICENSE.txt
+Requires-Dist: urllib3~=1.26
+Requires-Dist: six~=1.16
+Requires-Dist: certifi<=2023.11.17,>=2020.4.5.1
+Requires-Dist: python-dateutil~=2.8
+Requires-Dist: pysocks~=1.7
+
 # Python Client For Nutanix Iam Versioned APIs
 
-The Python client for Nutanix Iam Versioned APIs is designed for Python client application developers offering them simple and flexible access to APIs that identity and Access Management in Nutanix cluster.
+The Python client for Nutanix Iam Versioned APIs is designed for Python client application developers offering them simple and flexible access to APIs that manage Identity and Access Management of Nutanix clusters.
 ## Features
 - Invoke Nutanix APIs with a simple interface.
 - Handle Authentication seamlessly.
 - Reduce boilerplate code implementation.
 - Use standard methods for installation.
 
 ## Version
-- API version: v4.0.a1
-- Package version: 4.0.2a1
+- API version: v4.0.b1
+- Package version: 4.0.2b1
 
 ## Requirements.
-Python 3.6, 3.7, and 3.8 are fully supported and tested.
+Python 3.6, 3.7, 3.8 and 3.9 are fully supported and tested.
 
 
 ## Installation & Usage
 
 ### Installing in a virtual environment
 [virtualenv](https://virtualenv.pypa.io/en/latest/) is a tool to create isolated Python environments. The basic problem it addresses is one of dependencies and versions, and indirectly permissions. virtualenv can help you install this client without needing system install permissions. It creates an environment that has its own installation directories without sharing libraries with other virtualenv environments or the system installation.
 
@@ -70,14 +85,15 @@
 | debug     | Runs the client in debug mode if specified                                       | No       | False        |
 | verify_ssl| Verify SSL certificate of cluster the client will connect to                     | No       | True         |
 | max_retry_attempts| Maximum number of retry attempts while connecting to the cluster         | No       | 5            |
 | backoff_factor| A backoff factor to apply between attempts after the second try.             | No       | 3            |
 | logger_file | File location to which debug logs are written to                               | No       | N/A          |
 | connect_timeout | Connection timeout in milliseconds for all operations                      | No       | 30000        |
 | read_timeout | Read timeout in milliseconds for all operations                               | No       | 30000        |
+| download_directory| Directory where downloaded files will be stored in                       | No       | Current Working Directory|
 
 
 ### Sample Configuration
 ```python
 config = Configuration()
 config.host = '10.19.50.27' # IPv4/IPv6 address or FQDN of the cluster
 config.port = 9440 # Port to which to connect to
@@ -127,79 +143,79 @@
 ```
 
 ## Usage
 
 ### Invoking an operation
 ```python
 # Initialize the API
-cert_auth_provider_api_instance = CertAuthProviderApi(api_client=client) # client configured in previous step
+certificate_authentication_providers_api_instance = CertificateAuthenticationProvidersApi(api_client=client) # client configured in previous step
 extId = 'extId_example' # UUID.
 
-# Get certificate based authentication provider
+# Get Certificate based Authentication provider
 try:
-    api_response = cert_auth_provider_api_instance.handle_get_cert_auth_provider(extId)
+    api_response = certificate_authentication_providers_api_instance.get_cert_auth_provider_by_id(extId)
 except ApiException as e:
 ```
 
 ### Setting headers for individual operations
 Headers can be configured globally on the python client using the [method to set default headers](#additional-headers). However, sometimes headers need to be set on an individual operation basis. Nutanix APIs require that concurrent updates are protected using [ETag headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag).
 
 ```python
 # Initialize the API
-cert_auth_provider_api_instance = CertAuthProviderApi(api_client=client) # client configured in previous step
+certificate_authentication_providers_api_instance = CertificateAuthenticationProvidersApi(api_client=client) # client configured in previous step
 extId = 'extId_example' # UUID.
 
-# Get certificate based authentication provider
+# Get Certificate based Authentication provider
 try:
-    api_response = cert_auth_provider_api_instance.handle_get_cert_auth_provider(extId)
+    api_response = certificate_authentication_providers_api_instance.get_cert_auth_provider_by_id(extId)
 except ApiException as e:
 
 # Extract E-Tag Header
 etag_value = ApiClient.get_etag(api_response)
 
-# Update certificate based authentication provider
+# Update Certificate based Authentication provider
 try:
     # The body parameter in the following operation is received from the previous GET request's response which needs to be updated.
-    api_response = cert_auth_provider_api_instance.handle_update_cert_auth_provider(body, extId, if_match=etag_value) # Use the extracted etag value
+    api_response = certificate_authentication_providers_api_instance.update_cert_auth_provider_by_id(body, extId, if_match=etag_value) # Use the extracted etag value
 except ApiException as e:
 ```
 
 ### List Operations
 List Operations for Nutanix APIs support pagination, filtering, sorting and projections. The table below details the parameters that can be used to set the options for pagination etc.
 
 | Parameter | Description
 |-----------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
 | _page     | specifies the page number of the result set. Must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range will lead to no results being returned.|
 | _limit    | specifies the total number of records returned in the result set. Must be a positive integer between 0 and 100. Any number out of this range will lead to a validation error. If the limit is not provided a default value of 50 records will be returned in the result set|
 | _filter   | allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the [OData V4.01 URL](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part2-url-conventions.html#sec_SystemQueryOptionfilter) conventions. |
 | _orderby  | allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified the resources will be sorted in ascending order by default. For example, 'orderby=templateName desc' would get all templates sorted by templateName in desc order. |
-| _select   | allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the OData V4.01 URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e. *), then all properties on the matching resource will be returned. |
-| _expand   | allows clients to request related resources when a resource that satisfies a particular request is retrieved. Each expand item is evaluated relative to the entity containing the property being expanded. Other query options can be applied to an expanded property by appending a semicolon-separated list of query options, enclosed in parentheses, to the property name. Allowed system query options are $filter,$select, $orderby. |
+| _select   | allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the OData V4.01 URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e., *), then all properties on the matching resource will be returned. |
+| _expand   | allows clients to request related resources when a resource that satisfies a particular request is retrieved. Each expanded item is evaluated relative to the entity containing the property being expanded. Other query options can be applied to an expanded property by appending a semicolon-separated list of query options, enclosed in parentheses, to the property name. Permissible system query options are $filter,$select and $orderby. |
 
 ```python
 # Initialize the API
-cert_auth_provider_api_instance = CertAuthProviderApi(api_client=client) # client configured in previous step
+certificate_authentication_providers_api_instance = CertificateAuthenticationProvidersApi(api_client=client) # client configured in previous step
 extId = 'extId_example' # UUID.
 
-# List certificate based authentication provider(s)
+# List Certificate based Authentication provider(s)
 try:
-    api_response = cert_auth_provider_api_instance.handle_list_cert_auth_providers(
+    api_response = certificate_authentication_providers_api_instance.list_cert_auth_providers(
 	                   _page=page, # if page parameter is present
 	                   _limit=limit, # if limit parameter is present
 	                   _filter=_filter, # if filter parameter is present
 	                   _orderby=_orderby, # if orderby parameter is present
 	                   _select=select, # if select parameter is present
 	                   _expand=expand) # if expand parameter is present
 except ApiException as e:
 
 ```
 The list of filterable and sortable fields with expansion keys can be found in the documentation [here](https://developers.nutanix.com/).
 
 ## API Reference
 
-This library has a full set of [API Reference Documentation](https://developers.nutanix.com/sdk-reference?namespace=iam&version=v4.0.a1&language=python). This documentation is auto-generated, and the location may change.
+This library has a full set of [API Reference Documentation](https://developers.nutanix.com/sdk-reference?namespace=iam&version=v4.0.b1&language=python). This documentation is auto-generated, and the location may change.
 
 ## License
 This library is licensed under Nutanix proprietary license. Full license text is available in [LICENSE](https://developers.nutanix.com/license).
 
 ## Contact us
-In case of issues please reach out to us at the [mailing list](mailto:sdk@nutanix.com)
+In case of issues please reach out to us at the [mailing list](mailto:sdk@nutanix.com)
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfcommon/v1/config/KVPairvalue.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authz/UpdateClientApiResponsedata.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,93 +1,87 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class UpdateClientApiResponsedata(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """
 
 
-class KVPairvalue(object):
-    """KVPairvalue - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
     }
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
-        'String': 'str',
-        'Integer': 'int'
+        'EMPTY_MAP': 'dict(str, object)',
+        'common.v1.config.Message': 'common.v1.config.Message',
+        'iam.v4.error.ErrorResponse': 'iam.v4.error.ErrorResponse'
     }
 
-    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$valueItemDiscriminator'
+    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
-        """KVPairvalue - a model defined in Swagger
-            
-        """
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfcommon.v1.config.KVPairvalue'
+        return 'OneOfiam.v4.authz.UpdateClientApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -101,82 +95,95 @@
         """Returns the real base class specified by the discriminator"""
         if discriminator is not None and discriminator in self.discriminator_value_class_map:
             return self.discriminator_value_class_map.get(discriminator)
         return None
 
     @staticmethod
     def get_discriminator_from_object(value):
-        """Returns the model properties as a dict"""
+        """Returns the discriminator for the provided object.
+        """
         if not value:
             disc = 'list[str]'
         elif hasattr(value, "_object_type"):
             disc = value.get_object_type()
         elif type(value) == list:
             if hasattr(value[0], "_object_type"):
                 datatype = value[0].get_object_type()
             else:
                 datatype = type(value[0]).__name__
             disc = 'list[' + datatype + ']'
+        elif type(value) == dict:
+            if hasattr(next(iter(value.values())), "_object_type"):
+                datatype = next(iter(value.values())).get_object_type()
+            else:
+                datatype = type(next(iter(value.values()))).__name__
+            disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in KVPairvalue.discriminator_value_class_map.values():
-            return list(KVPairvalue.discriminator_value_class_map.keys())[list(KVPairvalue.discriminator_value_class_map.values()).index(disc)]
+        if disc in UpdateClientApiResponsedata.discriminator_value_class_map.values():
+            return list(UpdateClientApiResponsedata.discriminator_value_class_map.keys())[list(UpdateClientApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(KVPairvalue, dict):
+        if issubclass(UpdateClientApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, KVPairvalue):
+        if not isinstance(other, UpdateClientApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authn/ActivateUserApiResponsedata.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/ActivateUserApiResponsedata.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,92 +1,87 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class ActivateUserApiResponsedata(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """
 
 
-class ActivateUserApiResponsedata(object):
-    """ActivateUserApiResponsedata - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
     }
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
+        'EMPTY_MAP': 'dict(str, object)',
+        'iam.v4.authn.UserStateUpdateResponse': 'iam.v4.authn.UserStateUpdateResponse',
         'iam.v4.error.ErrorResponse': 'iam.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
-        """ActivateUserApiResponsedata - a model defined in Swagger
-            
-        """
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'OneOfiam.v4.authn.ActivateUserApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -100,53 +95,66 @@
         """Returns the real base class specified by the discriminator"""
         if discriminator is not None and discriminator in self.discriminator_value_class_map:
             return self.discriminator_value_class_map.get(discriminator)
         return None
 
     @staticmethod
     def get_discriminator_from_object(value):
-        """Returns the model properties as a dict"""
+        """Returns the discriminator for the provided object.
+        """
         if not value:
             disc = 'list[str]'
         elif hasattr(value, "_object_type"):
             disc = value.get_object_type()
         elif type(value) == list:
             if hasattr(value[0], "_object_type"):
                 datatype = value[0].get_object_type()
             else:
                 datatype = type(value[0]).__name__
             disc = 'list[' + datatype + ']'
+        elif type(value) == dict:
+            if hasattr(next(iter(value.values())), "_object_type"):
+                datatype = next(iter(value.values())).get_object_type()
+            else:
+                datatype = type(next(iter(value.values()))).__name__
+            disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
         if disc in ActivateUserApiResponsedata.discriminator_value_class_map.values():
             return list(ActivateUserApiResponsedata.discriminator_value_class_map.keys())[list(ActivateUserApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
@@ -154,15 +162,15 @@
         if issubclass(ActivateUserApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authn/ChangeUserPasswordApiResponsedata.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/ListUsersApiResponsedata.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,92 +1,87 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class ListUsersApiResponsedata(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """
 
 
-class ChangeUserPasswordApiResponsedata(object):
-    """ChangeUserPasswordApiResponsedata - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
     }
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
+        'EMPTY_MAP': 'dict(str, object)',
+        'List<iam.v4.authn.User>': 'list[iam.v4.authn.User]',
         'iam.v4.error.ErrorResponse': 'iam.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
-        """ChangeUserPasswordApiResponsedata - a model defined in Swagger
-            
-        """
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfiam.v4.authn.ChangeUserPasswordApiResponsedata'
+        return 'OneOfiam.v4.authn.ListUsersApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -100,82 +95,95 @@
         """Returns the real base class specified by the discriminator"""
         if discriminator is not None and discriminator in self.discriminator_value_class_map:
             return self.discriminator_value_class_map.get(discriminator)
         return None
 
     @staticmethod
     def get_discriminator_from_object(value):
-        """Returns the model properties as a dict"""
+        """Returns the discriminator for the provided object.
+        """
         if not value:
             disc = 'list[str]'
         elif hasattr(value, "_object_type"):
             disc = value.get_object_type()
         elif type(value) == list:
             if hasattr(value[0], "_object_type"):
                 datatype = value[0].get_object_type()
             else:
                 datatype = type(value[0]).__name__
             disc = 'list[' + datatype + ']'
+        elif type(value) == dict:
+            if hasattr(next(iter(value.values())), "_object_type"):
+                datatype = next(iter(value.values())).get_object_type()
+            else:
+                datatype = type(next(iter(value.values()))).__name__
+            disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in ChangeUserPasswordApiResponsedata.discriminator_value_class_map.values():
-            return list(ChangeUserPasswordApiResponsedata.discriminator_value_class_map.keys())[list(ChangeUserPasswordApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in ListUsersApiResponsedata.discriminator_value_class_map.values():
+            return list(ListUsersApiResponsedata.discriminator_value_class_map.keys())[list(ListUsersApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ChangeUserPasswordApiResponsedata, dict):
+        if issubclass(ListUsersApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ChangeUserPasswordApiResponsedata):
+        if not isinstance(other, ListUsersApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authn/ConnectionDirectoryServiceApiResponsedata.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/ListDirectoryServicesApiResponsedata.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,92 +1,87 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class ListDirectoryServicesApiResponsedata(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """
 
 
-class ConnectionDirectoryServiceApiResponsedata(object):
-    """ConnectionDirectoryServiceApiResponsedata - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
     }
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
+        'EMPTY_MAP': 'dict(str, object)',
+        'List<iam.v4.authn.DirectoryService>': 'list[iam.v4.authn.DirectoryService]',
         'iam.v4.error.ErrorResponse': 'iam.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
-        """ConnectionDirectoryServiceApiResponsedata - a model defined in Swagger
-            
-        """
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfiam.v4.authn.ConnectionDirectoryServiceApiResponsedata'
+        return 'OneOfiam.v4.authn.ListDirectoryServicesApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -100,82 +95,95 @@
         """Returns the real base class specified by the discriminator"""
         if discriminator is not None and discriminator in self.discriminator_value_class_map:
             return self.discriminator_value_class_map.get(discriminator)
         return None
 
     @staticmethod
     def get_discriminator_from_object(value):
-        """Returns the model properties as a dict"""
+        """Returns the discriminator for the provided object.
+        """
         if not value:
             disc = 'list[str]'
         elif hasattr(value, "_object_type"):
             disc = value.get_object_type()
         elif type(value) == list:
             if hasattr(value[0], "_object_type"):
                 datatype = value[0].get_object_type()
             else:
                 datatype = type(value[0]).__name__
             disc = 'list[' + datatype + ']'
+        elif type(value) == dict:
+            if hasattr(next(iter(value.values())), "_object_type"):
+                datatype = next(iter(value.values())).get_object_type()
+            else:
+                datatype = type(next(iter(value.values()))).__name__
+            disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in ConnectionDirectoryServiceApiResponsedata.discriminator_value_class_map.values():
-            return list(ConnectionDirectoryServiceApiResponsedata.discriminator_value_class_map.keys())[list(ConnectionDirectoryServiceApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in ListDirectoryServicesApiResponsedata.discriminator_value_class_map.values():
+            return list(ListDirectoryServicesApiResponsedata.discriminator_value_class_map.keys())[list(ListDirectoryServicesApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ConnectionDirectoryServiceApiResponsedata, dict):
+        if issubclass(ListDirectoryServicesApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ConnectionDirectoryServiceApiResponsedata):
+        if not isinstance(other, ListDirectoryServicesApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authn/CreateCertAuthProviderApiResponsedata.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/CreateCertAuthProviderApiResponsedata.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,93 +1,87 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class CreateCertAuthProviderApiResponsedata(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """
 
 
-class CreateCertAuthProviderApiResponsedata(object):
-    """CreateCertAuthProviderApiResponsedata - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
     }
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
+        'EMPTY_MAP': 'dict(str, object)',
         'iam.v4.authn.CertAuthProvider': 'iam.v4.authn.CertAuthProvider',
         'iam.v4.error.ErrorResponse': 'iam.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
-        """CreateCertAuthProviderApiResponsedata - a model defined in Swagger
-            
-        """
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'OneOfiam.v4.authn.CreateCertAuthProviderApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -101,53 +95,66 @@
         """Returns the real base class specified by the discriminator"""
         if discriminator is not None and discriminator in self.discriminator_value_class_map:
             return self.discriminator_value_class_map.get(discriminator)
         return None
 
     @staticmethod
     def get_discriminator_from_object(value):
-        """Returns the model properties as a dict"""
+        """Returns the discriminator for the provided object.
+        """
         if not value:
             disc = 'list[str]'
         elif hasattr(value, "_object_type"):
             disc = value.get_object_type()
         elif type(value) == list:
             if hasattr(value[0], "_object_type"):
                 datatype = value[0].get_object_type()
             else:
                 datatype = type(value[0]).__name__
             disc = 'list[' + datatype + ']'
+        elif type(value) == dict:
+            if hasattr(next(iter(value.values())), "_object_type"):
+                datatype = next(iter(value.values())).get_object_type()
+            else:
+                datatype = type(next(iter(value.values()))).__name__
+            disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
         if disc in CreateCertAuthProviderApiResponsedata.discriminator_value_class_map.values():
             return list(CreateCertAuthProviderApiResponsedata.discriminator_value_class_map.keys())[list(CreateCertAuthProviderApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
@@ -155,15 +162,15 @@
         if issubclass(CreateCertAuthProviderApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authn/CreateDirectoryServiceApiResponsedata.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/DeleteDirectoryServiceApiResponsedata.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,93 +1,86 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class DeleteDirectoryServiceApiResponsedata(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """
 
 
-class CreateDirectoryServiceApiResponsedata(object):
-    """CreateDirectoryServiceApiResponsedata - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
     }
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
-        'iam.v4.authn.DirectoryService': 'iam.v4.authn.DirectoryService',
+        'EMPTY_MAP': 'dict(str, object)',
         'iam.v4.error.ErrorResponse': 'iam.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
-        """CreateDirectoryServiceApiResponsedata - a model defined in Swagger
-            
-        """
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfiam.v4.authn.CreateDirectoryServiceApiResponsedata'
+        return 'OneOfiam.v4.authn.DeleteDirectoryServiceApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -101,82 +94,95 @@
         """Returns the real base class specified by the discriminator"""
         if discriminator is not None and discriminator in self.discriminator_value_class_map:
             return self.discriminator_value_class_map.get(discriminator)
         return None
 
     @staticmethod
     def get_discriminator_from_object(value):
-        """Returns the model properties as a dict"""
+        """Returns the discriminator for the provided object.
+        """
         if not value:
             disc = 'list[str]'
         elif hasattr(value, "_object_type"):
             disc = value.get_object_type()
         elif type(value) == list:
             if hasattr(value[0], "_object_type"):
                 datatype = value[0].get_object_type()
             else:
                 datatype = type(value[0]).__name__
             disc = 'list[' + datatype + ']'
+        elif type(value) == dict:
+            if hasattr(next(iter(value.values())), "_object_type"):
+                datatype = next(iter(value.values())).get_object_type()
+            else:
+                datatype = type(next(iter(value.values()))).__name__
+            disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in CreateDirectoryServiceApiResponsedata.discriminator_value_class_map.values():
-            return list(CreateDirectoryServiceApiResponsedata.discriminator_value_class_map.keys())[list(CreateDirectoryServiceApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in DeleteDirectoryServiceApiResponsedata.discriminator_value_class_map.values():
+            return list(DeleteDirectoryServiceApiResponsedata.discriminator_value_class_map.keys())[list(DeleteDirectoryServiceApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(CreateDirectoryServiceApiResponsedata, dict):
+        if issubclass(DeleteDirectoryServiceApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, CreateDirectoryServiceApiResponsedata):
+        if not isinstance(other, DeleteDirectoryServiceApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authn/CreateSamlIdentityProviderApiResponsedata.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/CreateSamlIdentityProviderApiResponsedata.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,93 +1,87 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class CreateSamlIdentityProviderApiResponsedata(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """
 
 
-class CreateSamlIdentityProviderApiResponsedata(object):
-    """CreateSamlIdentityProviderApiResponsedata - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
     }
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
+        'EMPTY_MAP': 'dict(str, object)',
         'iam.v4.authn.SamlIdentityProvider': 'iam.v4.authn.SamlIdentityProvider',
         'iam.v4.error.ErrorResponse': 'iam.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
-        """CreateSamlIdentityProviderApiResponsedata - a model defined in Swagger
-            
-        """
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'OneOfiam.v4.authn.CreateSamlIdentityProviderApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -101,53 +95,66 @@
         """Returns the real base class specified by the discriminator"""
         if discriminator is not None and discriminator in self.discriminator_value_class_map:
             return self.discriminator_value_class_map.get(discriminator)
         return None
 
     @staticmethod
     def get_discriminator_from_object(value):
-        """Returns the model properties as a dict"""
+        """Returns the discriminator for the provided object.
+        """
         if not value:
             disc = 'list[str]'
         elif hasattr(value, "_object_type"):
             disc = value.get_object_type()
         elif type(value) == list:
             if hasattr(value[0], "_object_type"):
                 datatype = value[0].get_object_type()
             else:
                 datatype = type(value[0]).__name__
             disc = 'list[' + datatype + ']'
+        elif type(value) == dict:
+            if hasattr(next(iter(value.values())), "_object_type"):
+                datatype = next(iter(value.values())).get_object_type()
+            else:
+                datatype = type(next(iter(value.values()))).__name__
+            disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
         if disc in CreateSamlIdentityProviderApiResponsedata.discriminator_value_class_map.values():
             return list(CreateSamlIdentityProviderApiResponsedata.discriminator_value_class_map.keys())[list(CreateSamlIdentityProviderApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
@@ -155,15 +162,15 @@
         if issubclass(CreateSamlIdentityProviderApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authn/CreateUserApiResponsedata.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/UpdateUserApiResponsedata.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,93 +1,87 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class UpdateUserApiResponsedata(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """
 
 
-class CreateUserApiResponsedata(object):
-    """CreateUserApiResponsedata - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
     }
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
+        'EMPTY_MAP': 'dict(str, object)',
         'iam.v4.authn.User': 'iam.v4.authn.User',
         'iam.v4.error.ErrorResponse': 'iam.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
-        """CreateUserApiResponsedata - a model defined in Swagger
-            
-        """
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfiam.v4.authn.CreateUserApiResponsedata'
+        return 'OneOfiam.v4.authn.UpdateUserApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -101,82 +95,95 @@
         """Returns the real base class specified by the discriminator"""
         if discriminator is not None and discriminator in self.discriminator_value_class_map:
             return self.discriminator_value_class_map.get(discriminator)
         return None
 
     @staticmethod
     def get_discriminator_from_object(value):
-        """Returns the model properties as a dict"""
+        """Returns the discriminator for the provided object.
+        """
         if not value:
             disc = 'list[str]'
         elif hasattr(value, "_object_type"):
             disc = value.get_object_type()
         elif type(value) == list:
             if hasattr(value[0], "_object_type"):
                 datatype = value[0].get_object_type()
             else:
                 datatype = type(value[0]).__name__
             disc = 'list[' + datatype + ']'
+        elif type(value) == dict:
+            if hasattr(next(iter(value.values())), "_object_type"):
+                datatype = next(iter(value.values())).get_object_type()
+            else:
+                datatype = type(next(iter(value.values()))).__name__
+            disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in CreateUserApiResponsedata.discriminator_value_class_map.values():
-            return list(CreateUserApiResponsedata.discriminator_value_class_map.keys())[list(CreateUserApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in UpdateUserApiResponsedata.discriminator_value_class_map.values():
+            return list(UpdateUserApiResponsedata.discriminator_value_class_map.keys())[list(UpdateUserApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(CreateUserApiResponsedata, dict):
+        if issubclass(UpdateUserApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, CreateUserApiResponsedata):
+        if not isinstance(other, UpdateUserApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authn/CreateUserGroupApiResponsedata.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/CreateUserApiResponsedata.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,93 +1,87 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class CreateUserApiResponsedata(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """
 
 
-class CreateUserGroupApiResponsedata(object):
-    """CreateUserGroupApiResponsedata - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
     }
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
-        'iam.v4.authn.UserGroup': 'iam.v4.authn.UserGroup',
+        'EMPTY_MAP': 'dict(str, object)',
+        'iam.v4.authn.User': 'iam.v4.authn.User',
         'iam.v4.error.ErrorResponse': 'iam.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
-        """CreateUserGroupApiResponsedata - a model defined in Swagger
-            
-        """
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfiam.v4.authn.CreateUserGroupApiResponsedata'
+        return 'OneOfiam.v4.authn.CreateUserApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -101,82 +95,95 @@
         """Returns the real base class specified by the discriminator"""
         if discriminator is not None and discriminator in self.discriminator_value_class_map:
             return self.discriminator_value_class_map.get(discriminator)
         return None
 
     @staticmethod
     def get_discriminator_from_object(value):
-        """Returns the model properties as a dict"""
+        """Returns the discriminator for the provided object.
+        """
         if not value:
             disc = 'list[str]'
         elif hasattr(value, "_object_type"):
             disc = value.get_object_type()
         elif type(value) == list:
             if hasattr(value[0], "_object_type"):
                 datatype = value[0].get_object_type()
             else:
                 datatype = type(value[0]).__name__
             disc = 'list[' + datatype + ']'
+        elif type(value) == dict:
+            if hasattr(next(iter(value.values())), "_object_type"):
+                datatype = next(iter(value.values())).get_object_type()
+            else:
+                datatype = type(next(iter(value.values()))).__name__
+            disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in CreateUserGroupApiResponsedata.discriminator_value_class_map.values():
-            return list(CreateUserGroupApiResponsedata.discriminator_value_class_map.keys())[list(CreateUserGroupApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in CreateUserApiResponsedata.discriminator_value_class_map.values():
+            return list(CreateUserApiResponsedata.discriminator_value_class_map.keys())[list(CreateUserApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(CreateUserGroupApiResponsedata, dict):
+        if issubclass(CreateUserApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, CreateUserGroupApiResponsedata):
+        if not isinstance(other, CreateUserApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authn/GetCertAuthProviderApiResponsedata.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/GetCertAuthProviderApiResponsedata.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,93 +1,87 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class GetCertAuthProviderApiResponsedata(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """
 
 
-class GetCertAuthProviderApiResponsedata(object):
-    """GetCertAuthProviderApiResponsedata - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
     }
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
+        'EMPTY_MAP': 'dict(str, object)',
         'iam.v4.authn.CertAuthProvider': 'iam.v4.authn.CertAuthProvider',
         'iam.v4.error.ErrorResponse': 'iam.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
-        """GetCertAuthProviderApiResponsedata - a model defined in Swagger
-            
-        """
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'OneOfiam.v4.authn.GetCertAuthProviderApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -101,53 +95,66 @@
         """Returns the real base class specified by the discriminator"""
         if discriminator is not None and discriminator in self.discriminator_value_class_map:
             return self.discriminator_value_class_map.get(discriminator)
         return None
 
     @staticmethod
     def get_discriminator_from_object(value):
-        """Returns the model properties as a dict"""
+        """Returns the discriminator for the provided object.
+        """
         if not value:
             disc = 'list[str]'
         elif hasattr(value, "_object_type"):
             disc = value.get_object_type()
         elif type(value) == list:
             if hasattr(value[0], "_object_type"):
                 datatype = value[0].get_object_type()
             else:
                 datatype = type(value[0]).__name__
             disc = 'list[' + datatype + ']'
+        elif type(value) == dict:
+            if hasattr(next(iter(value.values())), "_object_type"):
+                datatype = next(iter(value.values())).get_object_type()
+            else:
+                datatype = type(next(iter(value.values()))).__name__
+            disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
         if disc in GetCertAuthProviderApiResponsedata.discriminator_value_class_map.values():
             return list(GetCertAuthProviderApiResponsedata.discriminator_value_class_map.keys())[list(GetCertAuthProviderApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
@@ -155,15 +162,15 @@
         if issubclass(GetCertAuthProviderApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authn/GetDirectoryServiceApiResponsedata.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/DeleteSamlIdentityProviderApiResponsedata.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,93 +1,86 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class DeleteSamlIdentityProviderApiResponsedata(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """
 
 
-class GetDirectoryServiceApiResponsedata(object):
-    """GetDirectoryServiceApiResponsedata - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
     }
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
-        'iam.v4.authn.DirectoryService': 'iam.v4.authn.DirectoryService',
+        'EMPTY_MAP': 'dict(str, object)',
         'iam.v4.error.ErrorResponse': 'iam.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
-        """GetDirectoryServiceApiResponsedata - a model defined in Swagger
-            
-        """
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfiam.v4.authn.GetDirectoryServiceApiResponsedata'
+        return 'OneOfiam.v4.authn.DeleteSamlIdentityProviderApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -101,82 +94,95 @@
         """Returns the real base class specified by the discriminator"""
         if discriminator is not None and discriminator in self.discriminator_value_class_map:
             return self.discriminator_value_class_map.get(discriminator)
         return None
 
     @staticmethod
     def get_discriminator_from_object(value):
-        """Returns the model properties as a dict"""
+        """Returns the discriminator for the provided object.
+        """
         if not value:
             disc = 'list[str]'
         elif hasattr(value, "_object_type"):
             disc = value.get_object_type()
         elif type(value) == list:
             if hasattr(value[0], "_object_type"):
                 datatype = value[0].get_object_type()
             else:
                 datatype = type(value[0]).__name__
             disc = 'list[' + datatype + ']'
+        elif type(value) == dict:
+            if hasattr(next(iter(value.values())), "_object_type"):
+                datatype = next(iter(value.values())).get_object_type()
+            else:
+                datatype = type(next(iter(value.values()))).__name__
+            disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in GetDirectoryServiceApiResponsedata.discriminator_value_class_map.values():
-            return list(GetDirectoryServiceApiResponsedata.discriminator_value_class_map.keys())[list(GetDirectoryServiceApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in DeleteSamlIdentityProviderApiResponsedata.discriminator_value_class_map.values():
+            return list(DeleteSamlIdentityProviderApiResponsedata.discriminator_value_class_map.keys())[list(DeleteSamlIdentityProviderApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(GetDirectoryServiceApiResponsedata, dict):
+        if issubclass(DeleteSamlIdentityProviderApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, GetDirectoryServiceApiResponsedata):
+        if not isinstance(other, DeleteSamlIdentityProviderApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authn/GetSamlIdentityProviderApiResponsedata.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/DeleteUserApiResponsedata.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,93 +1,86 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class DeleteUserApiResponsedata(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """
 
 
-class GetSamlIdentityProviderApiResponsedata(object):
-    """GetSamlIdentityProviderApiResponsedata - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
     }
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
-        'iam.v4.authn.SamlIdentityProvider': 'iam.v4.authn.SamlIdentityProvider',
+        'EMPTY_MAP': 'dict(str, object)',
         'iam.v4.error.ErrorResponse': 'iam.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
-        """GetSamlIdentityProviderApiResponsedata - a model defined in Swagger
-            
-        """
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfiam.v4.authn.GetSamlIdentityProviderApiResponsedata'
+        return 'OneOfiam.v4.authn.DeleteUserApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -101,82 +94,95 @@
         """Returns the real base class specified by the discriminator"""
         if discriminator is not None and discriminator in self.discriminator_value_class_map:
             return self.discriminator_value_class_map.get(discriminator)
         return None
 
     @staticmethod
     def get_discriminator_from_object(value):
-        """Returns the model properties as a dict"""
+        """Returns the discriminator for the provided object.
+        """
         if not value:
             disc = 'list[str]'
         elif hasattr(value, "_object_type"):
             disc = value.get_object_type()
         elif type(value) == list:
             if hasattr(value[0], "_object_type"):
                 datatype = value[0].get_object_type()
             else:
                 datatype = type(value[0]).__name__
             disc = 'list[' + datatype + ']'
+        elif type(value) == dict:
+            if hasattr(next(iter(value.values())), "_object_type"):
+                datatype = next(iter(value.values())).get_object_type()
+            else:
+                datatype = type(next(iter(value.values()))).__name__
+            disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in GetSamlIdentityProviderApiResponsedata.discriminator_value_class_map.values():
-            return list(GetSamlIdentityProviderApiResponsedata.discriminator_value_class_map.keys())[list(GetSamlIdentityProviderApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in DeleteUserApiResponsedata.discriminator_value_class_map.values():
+            return list(DeleteUserApiResponsedata.discriminator_value_class_map.keys())[list(DeleteUserApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(GetSamlIdentityProviderApiResponsedata, dict):
+        if issubclass(DeleteUserApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, GetSamlIdentityProviderApiResponsedata):
+        if not isinstance(other, DeleteUserApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authn/GetSamlSpMetadataApiResponsedata.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/GetSamlSpMetadataApiResponsedata.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,93 +1,87 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class GetSamlSpMetadataApiResponsedata(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """
 
 
-class GetSamlSpMetadataApiResponsedata(object):
-    """GetSamlSpMetadataApiResponsedata - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
     }
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
+        'EMPTY_MAP': 'dict(str, object)',
         'String': 'str',
         'iam.v4.error.ErrorResponse': 'iam.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
-        """GetSamlSpMetadataApiResponsedata - a model defined in Swagger
-            
-        """
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'OneOfiam.v4.authn.GetSamlSpMetadataApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -101,53 +95,66 @@
         """Returns the real base class specified by the discriminator"""
         if discriminator is not None and discriminator in self.discriminator_value_class_map:
             return self.discriminator_value_class_map.get(discriminator)
         return None
 
     @staticmethod
     def get_discriminator_from_object(value):
-        """Returns the model properties as a dict"""
+        """Returns the discriminator for the provided object.
+        """
         if not value:
             disc = 'list[str]'
         elif hasattr(value, "_object_type"):
             disc = value.get_object_type()
         elif type(value) == list:
             if hasattr(value[0], "_object_type"):
                 datatype = value[0].get_object_type()
             else:
                 datatype = type(value[0]).__name__
             disc = 'list[' + datatype + ']'
+        elif type(value) == dict:
+            if hasattr(next(iter(value.values())), "_object_type"):
+                datatype = next(iter(value.values())).get_object_type()
+            else:
+                datatype = type(next(iter(value.values()))).__name__
+            disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
         if disc in GetSamlSpMetadataApiResponsedata.discriminator_value_class_map.values():
             return list(GetSamlSpMetadataApiResponsedata.discriminator_value_class_map.keys())[list(GetSamlSpMetadataApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
@@ -155,15 +162,15 @@
         if issubclass(GetSamlSpMetadataApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authn/GetUserApiResponsedata.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/GetApiKeyApiResponsedata.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,93 +1,87 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class GetApiKeyApiResponsedata(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """
 
 
-class GetUserApiResponsedata(object):
-    """GetUserApiResponsedata - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
     }
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
-        'iam.v4.authn.User': 'iam.v4.authn.User',
+        'EMPTY_MAP': 'dict(str, object)',
+        'iam.v4.authn.ApiKey': 'iam.v4.authn.ApiKey',
         'iam.v4.error.ErrorResponse': 'iam.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
-        """GetUserApiResponsedata - a model defined in Swagger
-            
-        """
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfiam.v4.authn.GetUserApiResponsedata'
+        return 'OneOfiam.v4.authn.GetApiKeyApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -101,82 +95,95 @@
         """Returns the real base class specified by the discriminator"""
         if discriminator is not None and discriminator in self.discriminator_value_class_map:
             return self.discriminator_value_class_map.get(discriminator)
         return None
 
     @staticmethod
     def get_discriminator_from_object(value):
-        """Returns the model properties as a dict"""
+        """Returns the discriminator for the provided object.
+        """
         if not value:
             disc = 'list[str]'
         elif hasattr(value, "_object_type"):
             disc = value.get_object_type()
         elif type(value) == list:
             if hasattr(value[0], "_object_type"):
                 datatype = value[0].get_object_type()
             else:
                 datatype = type(value[0]).__name__
             disc = 'list[' + datatype + ']'
+        elif type(value) == dict:
+            if hasattr(next(iter(value.values())), "_object_type"):
+                datatype = next(iter(value.values())).get_object_type()
+            else:
+                datatype = type(next(iter(value.values()))).__name__
+            disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in GetUserApiResponsedata.discriminator_value_class_map.values():
-            return list(GetUserApiResponsedata.discriminator_value_class_map.keys())[list(GetUserApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in GetApiKeyApiResponsedata.discriminator_value_class_map.values():
+            return list(GetApiKeyApiResponsedata.discriminator_value_class_map.keys())[list(GetApiKeyApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(GetUserApiResponsedata, dict):
+        if issubclass(GetApiKeyApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, GetUserApiResponsedata):
+        if not isinstance(other, GetApiKeyApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authn/GetUserGroupApiResponsedata.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/ListUserBucketKeysApiResponsedata.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,93 +1,87 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class ListUserBucketKeysApiResponsedata(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """
 
 
-class GetUserGroupApiResponsedata(object):
-    """GetUserGroupApiResponsedata - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
     }
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
-        'iam.v4.authn.UserGroup': 'iam.v4.authn.UserGroup',
+        'EMPTY_MAP': 'dict(str, object)',
+        'List<iam.v4.authn.BucketsAccessKey>': 'list[iam.v4.authn.BucketsAccessKey]',
         'iam.v4.error.ErrorResponse': 'iam.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
-        """GetUserGroupApiResponsedata - a model defined in Swagger
-            
-        """
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfiam.v4.authn.GetUserGroupApiResponsedata'
+        return 'OneOfiam.v4.authn.ListUserBucketKeysApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -101,82 +95,95 @@
         """Returns the real base class specified by the discriminator"""
         if discriminator is not None and discriminator in self.discriminator_value_class_map:
             return self.discriminator_value_class_map.get(discriminator)
         return None
 
     @staticmethod
     def get_discriminator_from_object(value):
-        """Returns the model properties as a dict"""
+        """Returns the discriminator for the provided object.
+        """
         if not value:
             disc = 'list[str]'
         elif hasattr(value, "_object_type"):
             disc = value.get_object_type()
         elif type(value) == list:
             if hasattr(value[0], "_object_type"):
                 datatype = value[0].get_object_type()
             else:
                 datatype = type(value[0]).__name__
             disc = 'list[' + datatype + ']'
+        elif type(value) == dict:
+            if hasattr(next(iter(value.values())), "_object_type"):
+                datatype = next(iter(value.values())).get_object_type()
+            else:
+                datatype = type(next(iter(value.values()))).__name__
+            disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in GetUserGroupApiResponsedata.discriminator_value_class_map.values():
-            return list(GetUserGroupApiResponsedata.discriminator_value_class_map.keys())[list(GetUserGroupApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in ListUserBucketKeysApiResponsedata.discriminator_value_class_map.values():
+            return list(ListUserBucketKeysApiResponsedata.discriminator_value_class_map.keys())[list(ListUserBucketKeysApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(GetUserGroupApiResponsedata, dict):
+        if issubclass(ListUserBucketKeysApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, GetUserGroupApiResponsedata):
+        if not isinstance(other, ListUserBucketKeysApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authn/ListCertAuthProviderApiResponsedata.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/ListApiKeysApiResponsedata.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,93 +1,87 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class ListApiKeysApiResponsedata(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """
 
 
-class ListCertAuthProviderApiResponsedata(object):
-    """ListCertAuthProviderApiResponsedata - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
     }
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
-        'List<iam.v4.authn.CertAuthProvider>': 'list[iam.v4.authn.CertAuthProvider]',
+        'EMPTY_MAP': 'dict(str, object)',
+        'List<iam.v4.authn.ApiKey>': 'list[iam.v4.authn.ApiKey]',
         'iam.v4.error.ErrorResponse': 'iam.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
-        """ListCertAuthProviderApiResponsedata - a model defined in Swagger
-            
-        """
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfiam.v4.authn.ListCertAuthProviderApiResponsedata'
+        return 'OneOfiam.v4.authn.ListApiKeysApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -101,82 +95,95 @@
         """Returns the real base class specified by the discriminator"""
         if discriminator is not None and discriminator in self.discriminator_value_class_map:
             return self.discriminator_value_class_map.get(discriminator)
         return None
 
     @staticmethod
     def get_discriminator_from_object(value):
-        """Returns the model properties as a dict"""
+        """Returns the discriminator for the provided object.
+        """
         if not value:
             disc = 'list[str]'
         elif hasattr(value, "_object_type"):
             disc = value.get_object_type()
         elif type(value) == list:
             if hasattr(value[0], "_object_type"):
                 datatype = value[0].get_object_type()
             else:
                 datatype = type(value[0]).__name__
             disc = 'list[' + datatype + ']'
+        elif type(value) == dict:
+            if hasattr(next(iter(value.values())), "_object_type"):
+                datatype = next(iter(value.values())).get_object_type()
+            else:
+                datatype = type(next(iter(value.values()))).__name__
+            disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in ListCertAuthProviderApiResponsedata.discriminator_value_class_map.values():
-            return list(ListCertAuthProviderApiResponsedata.discriminator_value_class_map.keys())[list(ListCertAuthProviderApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in ListApiKeysApiResponsedata.discriminator_value_class_map.values():
+            return list(ListApiKeysApiResponsedata.discriminator_value_class_map.keys())[list(ListApiKeysApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ListCertAuthProviderApiResponsedata, dict):
+        if issubclass(ListApiKeysApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ListCertAuthProviderApiResponsedata):
+        if not isinstance(other, ListApiKeysApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authn/ListDirectoryServiceApiResponsedata.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authz/GetEntityApiResponsedata.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,93 +1,87 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class GetEntityApiResponsedata(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """
 
 
-class ListDirectoryServiceApiResponsedata(object):
-    """ListDirectoryServiceApiResponsedata - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
     }
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
-        'List<iam.v4.authn.DirectoryService>': 'list[iam.v4.authn.DirectoryService]',
+        'EMPTY_MAP': 'dict(str, object)',
+        'iam.v4.authz.Entity': 'iam.v4.authz.Entity',
         'iam.v4.error.ErrorResponse': 'iam.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
-        """ListDirectoryServiceApiResponsedata - a model defined in Swagger
-            
-        """
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfiam.v4.authn.ListDirectoryServiceApiResponsedata'
+        return 'OneOfiam.v4.authz.GetEntityApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -101,82 +95,95 @@
         """Returns the real base class specified by the discriminator"""
         if discriminator is not None and discriminator in self.discriminator_value_class_map:
             return self.discriminator_value_class_map.get(discriminator)
         return None
 
     @staticmethod
     def get_discriminator_from_object(value):
-        """Returns the model properties as a dict"""
+        """Returns the discriminator for the provided object.
+        """
         if not value:
             disc = 'list[str]'
         elif hasattr(value, "_object_type"):
             disc = value.get_object_type()
         elif type(value) == list:
             if hasattr(value[0], "_object_type"):
                 datatype = value[0].get_object_type()
             else:
                 datatype = type(value[0]).__name__
             disc = 'list[' + datatype + ']'
+        elif type(value) == dict:
+            if hasattr(next(iter(value.values())), "_object_type"):
+                datatype = next(iter(value.values())).get_object_type()
+            else:
+                datatype = type(next(iter(value.values()))).__name__
+            disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in ListDirectoryServiceApiResponsedata.discriminator_value_class_map.values():
-            return list(ListDirectoryServiceApiResponsedata.discriminator_value_class_map.keys())[list(ListDirectoryServiceApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in GetEntityApiResponsedata.discriminator_value_class_map.values():
+            return list(GetEntityApiResponsedata.discriminator_value_class_map.keys())[list(GetEntityApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ListDirectoryServiceApiResponsedata, dict):
+        if issubclass(GetEntityApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ListDirectoryServiceApiResponsedata):
+        if not isinstance(other, GetEntityApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authn/ListSamlIdentityProviderApiResponsedata.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/ListSamlIdentityProvidersApiResponsedata.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,93 +1,87 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class ListSamlIdentityProvidersApiResponsedata(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """
 
 
-class ListSamlIdentityProviderApiResponsedata(object):
-    """ListSamlIdentityProviderApiResponsedata - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
     }
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
+        'EMPTY_MAP': 'dict(str, object)',
         'List<iam.v4.authn.SamlIdentityProvider>': 'list[iam.v4.authn.SamlIdentityProvider]',
         'iam.v4.error.ErrorResponse': 'iam.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
-        """ListSamlIdentityProviderApiResponsedata - a model defined in Swagger
-            
-        """
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfiam.v4.authn.ListSamlIdentityProviderApiResponsedata'
+        return 'OneOfiam.v4.authn.ListSamlIdentityProvidersApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -101,82 +95,95 @@
         """Returns the real base class specified by the discriminator"""
         if discriminator is not None and discriminator in self.discriminator_value_class_map:
             return self.discriminator_value_class_map.get(discriminator)
         return None
 
     @staticmethod
     def get_discriminator_from_object(value):
-        """Returns the model properties as a dict"""
+        """Returns the discriminator for the provided object.
+        """
         if not value:
             disc = 'list[str]'
         elif hasattr(value, "_object_type"):
             disc = value.get_object_type()
         elif type(value) == list:
             if hasattr(value[0], "_object_type"):
                 datatype = value[0].get_object_type()
             else:
                 datatype = type(value[0]).__name__
             disc = 'list[' + datatype + ']'
+        elif type(value) == dict:
+            if hasattr(next(iter(value.values())), "_object_type"):
+                datatype = next(iter(value.values())).get_object_type()
+            else:
+                datatype = type(next(iter(value.values()))).__name__
+            disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in ListSamlIdentityProviderApiResponsedata.discriminator_value_class_map.values():
-            return list(ListSamlIdentityProviderApiResponsedata.discriminator_value_class_map.keys())[list(ListSamlIdentityProviderApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in ListSamlIdentityProvidersApiResponsedata.discriminator_value_class_map.values():
+            return list(ListSamlIdentityProvidersApiResponsedata.discriminator_value_class_map.keys())[list(ListSamlIdentityProvidersApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ListSamlIdentityProviderApiResponsedata, dict):
+        if issubclass(ListSamlIdentityProvidersApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ListSamlIdentityProviderApiResponsedata):
+        if not isinstance(other, ListSamlIdentityProvidersApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authn/ListUserApiResponsedata.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authz/ListEntitiesApiResponsedata.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,93 +1,87 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class ListEntitiesApiResponsedata(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """
 
 
-class ListUserApiResponsedata(object):
-    """ListUserApiResponsedata - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
     }
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
-        'List<iam.v4.authn.User>': 'list[iam.v4.authn.User]',
+        'EMPTY_MAP': 'dict(str, object)',
+        'List<iam.v4.authz.Entity>': 'list[iam.v4.authz.Entity]',
         'iam.v4.error.ErrorResponse': 'iam.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
-        """ListUserApiResponsedata - a model defined in Swagger
-            
-        """
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfiam.v4.authn.ListUserApiResponsedata'
+        return 'OneOfiam.v4.authz.ListEntitiesApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -101,82 +95,95 @@
         """Returns the real base class specified by the discriminator"""
         if discriminator is not None and discriminator in self.discriminator_value_class_map:
             return self.discriminator_value_class_map.get(discriminator)
         return None
 
     @staticmethod
     def get_discriminator_from_object(value):
-        """Returns the model properties as a dict"""
+        """Returns the discriminator for the provided object.
+        """
         if not value:
             disc = 'list[str]'
         elif hasattr(value, "_object_type"):
             disc = value.get_object_type()
         elif type(value) == list:
             if hasattr(value[0], "_object_type"):
                 datatype = value[0].get_object_type()
             else:
                 datatype = type(value[0]).__name__
             disc = 'list[' + datatype + ']'
+        elif type(value) == dict:
+            if hasattr(next(iter(value.values())), "_object_type"):
+                datatype = next(iter(value.values())).get_object_type()
+            else:
+                datatype = type(next(iter(value.values()))).__name__
+            disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in ListUserApiResponsedata.discriminator_value_class_map.values():
-            return list(ListUserApiResponsedata.discriminator_value_class_map.keys())[list(ListUserApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in ListEntitiesApiResponsedata.discriminator_value_class_map.values():
+            return list(ListEntitiesApiResponsedata.discriminator_value_class_map.keys())[list(ListEntitiesApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ListUserApiResponsedata, dict):
+        if issubclass(ListEntitiesApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ListUserApiResponsedata):
+        if not isinstance(other, ListEntitiesApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authn/ListUserGroupApiResponsedata.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/ListUserGroupsApiResponsedata.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,93 +1,87 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class ListUserGroupsApiResponsedata(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """
 
 
-class ListUserGroupApiResponsedata(object):
-    """ListUserGroupApiResponsedata - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
     }
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
+        'EMPTY_MAP': 'dict(str, object)',
         'List<iam.v4.authn.UserGroup>': 'list[iam.v4.authn.UserGroup]',
         'iam.v4.error.ErrorResponse': 'iam.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
-        """ListUserGroupApiResponsedata - a model defined in Swagger
-            
-        """
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfiam.v4.authn.ListUserGroupApiResponsedata'
+        return 'OneOfiam.v4.authn.ListUserGroupsApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -101,82 +95,95 @@
         """Returns the real base class specified by the discriminator"""
         if discriminator is not None and discriminator in self.discriminator_value_class_map:
             return self.discriminator_value_class_map.get(discriminator)
         return None
 
     @staticmethod
     def get_discriminator_from_object(value):
-        """Returns the model properties as a dict"""
+        """Returns the discriminator for the provided object.
+        """
         if not value:
             disc = 'list[str]'
         elif hasattr(value, "_object_type"):
             disc = value.get_object_type()
         elif type(value) == list:
             if hasattr(value[0], "_object_type"):
                 datatype = value[0].get_object_type()
             else:
                 datatype = type(value[0]).__name__
             disc = 'list[' + datatype + ']'
+        elif type(value) == dict:
+            if hasattr(next(iter(value.values())), "_object_type"):
+                datatype = next(iter(value.values())).get_object_type()
+            else:
+                datatype = type(next(iter(value.values()))).__name__
+            disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in ListUserGroupApiResponsedata.discriminator_value_class_map.values():
-            return list(ListUserGroupApiResponsedata.discriminator_value_class_map.keys())[list(ListUserGroupApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in ListUserGroupsApiResponsedata.discriminator_value_class_map.values():
+            return list(ListUserGroupsApiResponsedata.discriminator_value_class_map.keys())[list(ListUserGroupsApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ListUserGroupApiResponsedata, dict):
+        if issubclass(ListUserGroupsApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ListUserGroupApiResponsedata):
+        if not isinstance(other, ListUserGroupsApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authn/ResetUserPasswordApiResponsedata.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/GetUserGroupApiResponsedata.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,92 +1,87 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class GetUserGroupApiResponsedata(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """
 
 
-class ResetUserPasswordApiResponsedata(object):
-    """ResetUserPasswordApiResponsedata - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
     }
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
+        'EMPTY_MAP': 'dict(str, object)',
+        'iam.v4.authn.UserGroup': 'iam.v4.authn.UserGroup',
         'iam.v4.error.ErrorResponse': 'iam.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
-        """ResetUserPasswordApiResponsedata - a model defined in Swagger
-            
-        """
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfiam.v4.authn.ResetUserPasswordApiResponsedata'
+        return 'OneOfiam.v4.authn.GetUserGroupApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -100,82 +95,95 @@
         """Returns the real base class specified by the discriminator"""
         if discriminator is not None and discriminator in self.discriminator_value_class_map:
             return self.discriminator_value_class_map.get(discriminator)
         return None
 
     @staticmethod
     def get_discriminator_from_object(value):
-        """Returns the model properties as a dict"""
+        """Returns the discriminator for the provided object.
+        """
         if not value:
             disc = 'list[str]'
         elif hasattr(value, "_object_type"):
             disc = value.get_object_type()
         elif type(value) == list:
             if hasattr(value[0], "_object_type"):
                 datatype = value[0].get_object_type()
             else:
                 datatype = type(value[0]).__name__
             disc = 'list[' + datatype + ']'
+        elif type(value) == dict:
+            if hasattr(next(iter(value.values())), "_object_type"):
+                datatype = next(iter(value.values())).get_object_type()
+            else:
+                datatype = type(next(iter(value.values()))).__name__
+            disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in ResetUserPasswordApiResponsedata.discriminator_value_class_map.values():
-            return list(ResetUserPasswordApiResponsedata.discriminator_value_class_map.keys())[list(ResetUserPasswordApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in GetUserGroupApiResponsedata.discriminator_value_class_map.values():
+            return list(GetUserGroupApiResponsedata.discriminator_value_class_map.keys())[list(GetUserGroupApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ResetUserPasswordApiResponsedata, dict):
+        if issubclass(GetUserGroupApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ResetUserPasswordApiResponsedata):
+        if not isinstance(other, GetUserGroupApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authn/SearchDirectoryServiceApiResponsedata.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/SearchDirectoryServiceApiResponsedata.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,93 +1,87 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class SearchDirectoryServiceApiResponsedata(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """
 
 
-class SearchDirectoryServiceApiResponsedata(object):
-    """SearchDirectoryServiceApiResponsedata - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
     }
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
+        'EMPTY_MAP': 'dict(str, object)',
         'iam.v4.authn.DirectoryServiceSearchResult': 'iam.v4.authn.DirectoryServiceSearchResult',
         'iam.v4.error.ErrorResponse': 'iam.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
-        """SearchDirectoryServiceApiResponsedata - a model defined in Swagger
-            
-        """
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'OneOfiam.v4.authn.SearchDirectoryServiceApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -101,53 +95,66 @@
         """Returns the real base class specified by the discriminator"""
         if discriminator is not None and discriminator in self.discriminator_value_class_map:
             return self.discriminator_value_class_map.get(discriminator)
         return None
 
     @staticmethod
     def get_discriminator_from_object(value):
-        """Returns the model properties as a dict"""
+        """Returns the discriminator for the provided object.
+        """
         if not value:
             disc = 'list[str]'
         elif hasattr(value, "_object_type"):
             disc = value.get_object_type()
         elif type(value) == list:
             if hasattr(value[0], "_object_type"):
                 datatype = value[0].get_object_type()
             else:
                 datatype = type(value[0]).__name__
             disc = 'list[' + datatype + ']'
+        elif type(value) == dict:
+            if hasattr(next(iter(value.values())), "_object_type"):
+                datatype = next(iter(value.values())).get_object_type()
+            else:
+                datatype = type(next(iter(value.values()))).__name__
+            disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
         if disc in SearchDirectoryServiceApiResponsedata.discriminator_value_class_map.values():
             return list(SearchDirectoryServiceApiResponsedata.discriminator_value_class_map.keys())[list(SearchDirectoryServiceApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
@@ -155,15 +162,15 @@
         if issubclass(SearchDirectoryServiceApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authn/UpdateCertAuthProviderApiResponsedata.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/CreateDirectoryServiceApiResponsedata.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,93 +1,87 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class CreateDirectoryServiceApiResponsedata(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """
 
 
-class UpdateCertAuthProviderApiResponsedata(object):
-    """UpdateCertAuthProviderApiResponsedata - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
     }
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
-        'iam.v4.authn.CertAuthProvider': 'iam.v4.authn.CertAuthProvider',
+        'EMPTY_MAP': 'dict(str, object)',
+        'iam.v4.authn.DirectoryService': 'iam.v4.authn.DirectoryService',
         'iam.v4.error.ErrorResponse': 'iam.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
-        """UpdateCertAuthProviderApiResponsedata - a model defined in Swagger
-            
-        """
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfiam.v4.authn.UpdateCertAuthProviderApiResponsedata'
+        return 'OneOfiam.v4.authn.CreateDirectoryServiceApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -101,82 +95,95 @@
         """Returns the real base class specified by the discriminator"""
         if discriminator is not None and discriminator in self.discriminator_value_class_map:
             return self.discriminator_value_class_map.get(discriminator)
         return None
 
     @staticmethod
     def get_discriminator_from_object(value):
-        """Returns the model properties as a dict"""
+        """Returns the discriminator for the provided object.
+        """
         if not value:
             disc = 'list[str]'
         elif hasattr(value, "_object_type"):
             disc = value.get_object_type()
         elif type(value) == list:
             if hasattr(value[0], "_object_type"):
                 datatype = value[0].get_object_type()
             else:
                 datatype = type(value[0]).__name__
             disc = 'list[' + datatype + ']'
+        elif type(value) == dict:
+            if hasattr(next(iter(value.values())), "_object_type"):
+                datatype = next(iter(value.values())).get_object_type()
+            else:
+                datatype = type(next(iter(value.values()))).__name__
+            disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in UpdateCertAuthProviderApiResponsedata.discriminator_value_class_map.values():
-            return list(UpdateCertAuthProviderApiResponsedata.discriminator_value_class_map.keys())[list(UpdateCertAuthProviderApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in CreateDirectoryServiceApiResponsedata.discriminator_value_class_map.values():
+            return list(CreateDirectoryServiceApiResponsedata.discriminator_value_class_map.keys())[list(CreateDirectoryServiceApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(UpdateCertAuthProviderApiResponsedata, dict):
+        if issubclass(CreateDirectoryServiceApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, UpdateCertAuthProviderApiResponsedata):
+        if not isinstance(other, CreateDirectoryServiceApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authn/UpdateDirectoryServiceApiResponsedata.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/CreateApiKeyApiResponsedata.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,93 +1,87 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class CreateApiKeyApiResponsedata(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """
 
 
-class UpdateDirectoryServiceApiResponsedata(object):
-    """UpdateDirectoryServiceApiResponsedata - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
     }
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
-        'iam.v4.authn.DirectoryService': 'iam.v4.authn.DirectoryService',
+        'EMPTY_MAP': 'dict(str, object)',
+        'iam.v4.authn.ApiKey': 'iam.v4.authn.ApiKey',
         'iam.v4.error.ErrorResponse': 'iam.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
-        """UpdateDirectoryServiceApiResponsedata - a model defined in Swagger
-            
-        """
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfiam.v4.authn.UpdateDirectoryServiceApiResponsedata'
+        return 'OneOfiam.v4.authn.CreateApiKeyApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -101,82 +95,95 @@
         """Returns the real base class specified by the discriminator"""
         if discriminator is not None and discriminator in self.discriminator_value_class_map:
             return self.discriminator_value_class_map.get(discriminator)
         return None
 
     @staticmethod
     def get_discriminator_from_object(value):
-        """Returns the model properties as a dict"""
+        """Returns the discriminator for the provided object.
+        """
         if not value:
             disc = 'list[str]'
         elif hasattr(value, "_object_type"):
             disc = value.get_object_type()
         elif type(value) == list:
             if hasattr(value[0], "_object_type"):
                 datatype = value[0].get_object_type()
             else:
                 datatype = type(value[0]).__name__
             disc = 'list[' + datatype + ']'
+        elif type(value) == dict:
+            if hasattr(next(iter(value.values())), "_object_type"):
+                datatype = next(iter(value.values())).get_object_type()
+            else:
+                datatype = type(next(iter(value.values()))).__name__
+            disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in UpdateDirectoryServiceApiResponsedata.discriminator_value_class_map.values():
-            return list(UpdateDirectoryServiceApiResponsedata.discriminator_value_class_map.keys())[list(UpdateDirectoryServiceApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in CreateApiKeyApiResponsedata.discriminator_value_class_map.values():
+            return list(CreateApiKeyApiResponsedata.discriminator_value_class_map.keys())[list(CreateApiKeyApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(UpdateDirectoryServiceApiResponsedata, dict):
+        if issubclass(CreateApiKeyApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, UpdateDirectoryServiceApiResponsedata):
+        if not isinstance(other, CreateApiKeyApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authn/UpdateSamlIdentityProviderApiResponsedata.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authz/ListClientsApiResponsedata.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,93 +1,87 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class ListClientsApiResponsedata(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """
 
 
-class UpdateSamlIdentityProviderApiResponsedata(object):
-    """UpdateSamlIdentityProviderApiResponsedata - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
     }
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
-        'iam.v4.authn.SamlIdentityProvider': 'iam.v4.authn.SamlIdentityProvider',
+        'EMPTY_MAP': 'dict(str, object)',
+        'List<iam.v4.authz.Client>': 'list[iam.v4.authz.Client]',
         'iam.v4.error.ErrorResponse': 'iam.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
-        """UpdateSamlIdentityProviderApiResponsedata - a model defined in Swagger
-            
-        """
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfiam.v4.authn.UpdateSamlIdentityProviderApiResponsedata'
+        return 'OneOfiam.v4.authz.ListClientsApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -101,82 +95,95 @@
         """Returns the real base class specified by the discriminator"""
         if discriminator is not None and discriminator in self.discriminator_value_class_map:
             return self.discriminator_value_class_map.get(discriminator)
         return None
 
     @staticmethod
     def get_discriminator_from_object(value):
-        """Returns the model properties as a dict"""
+        """Returns the discriminator for the provided object.
+        """
         if not value:
             disc = 'list[str]'
         elif hasattr(value, "_object_type"):
             disc = value.get_object_type()
         elif type(value) == list:
             if hasattr(value[0], "_object_type"):
                 datatype = value[0].get_object_type()
             else:
                 datatype = type(value[0]).__name__
             disc = 'list[' + datatype + ']'
+        elif type(value) == dict:
+            if hasattr(next(iter(value.values())), "_object_type"):
+                datatype = next(iter(value.values())).get_object_type()
+            else:
+                datatype = type(next(iter(value.values()))).__name__
+            disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in UpdateSamlIdentityProviderApiResponsedata.discriminator_value_class_map.values():
-            return list(UpdateSamlIdentityProviderApiResponsedata.discriminator_value_class_map.keys())[list(UpdateSamlIdentityProviderApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in ListClientsApiResponsedata.discriminator_value_class_map.values():
+            return list(ListClientsApiResponsedata.discriminator_value_class_map.keys())[list(ListClientsApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(UpdateSamlIdentityProviderApiResponsedata, dict):
+        if issubclass(ListClientsApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, UpdateSamlIdentityProviderApiResponsedata):
+        if not isinstance(other, ListClientsApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authn/UpdateUserApiResponsedata.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/CreateUserGroupApiResponsedata.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,93 +1,87 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class CreateUserGroupApiResponsedata(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """
 
 
-class UpdateUserApiResponsedata(object):
-    """UpdateUserApiResponsedata - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
     }
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
-        'iam.v4.authn.User': 'iam.v4.authn.User',
+        'EMPTY_MAP': 'dict(str, object)',
+        'iam.v4.authn.UserGroup': 'iam.v4.authn.UserGroup',
         'iam.v4.error.ErrorResponse': 'iam.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
-        """UpdateUserApiResponsedata - a model defined in Swagger
-            
-        """
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfiam.v4.authn.UpdateUserApiResponsedata'
+        return 'OneOfiam.v4.authn.CreateUserGroupApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -101,82 +95,95 @@
         """Returns the real base class specified by the discriminator"""
         if discriminator is not None and discriminator in self.discriminator_value_class_map:
             return self.discriminator_value_class_map.get(discriminator)
         return None
 
     @staticmethod
     def get_discriminator_from_object(value):
-        """Returns the model properties as a dict"""
+        """Returns the discriminator for the provided object.
+        """
         if not value:
             disc = 'list[str]'
         elif hasattr(value, "_object_type"):
             disc = value.get_object_type()
         elif type(value) == list:
             if hasattr(value[0], "_object_type"):
                 datatype = value[0].get_object_type()
             else:
                 datatype = type(value[0]).__name__
             disc = 'list[' + datatype + ']'
+        elif type(value) == dict:
+            if hasattr(next(iter(value.values())), "_object_type"):
+                datatype = next(iter(value.values())).get_object_type()
+            else:
+                datatype = type(next(iter(value.values()))).__name__
+            disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in UpdateUserApiResponsedata.discriminator_value_class_map.values():
-            return list(UpdateUserApiResponsedata.discriminator_value_class_map.keys())[list(UpdateUserApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in CreateUserGroupApiResponsedata.discriminator_value_class_map.values():
+            return list(CreateUserGroupApiResponsedata.discriminator_value_class_map.keys())[list(CreateUserGroupApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(UpdateUserApiResponsedata, dict):
+        if issubclass(CreateUserGroupApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, UpdateUserApiResponsedata):
+        if not isinstance(other, CreateUserGroupApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authz/CreateAccessPolicyApiResponsedata.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/CreateUserKeyApiResponsedata.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,93 +1,87 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class CreateUserKeyApiResponsedata(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """
 
 
-class CreateAccessPolicyApiResponsedata(object):
-    """CreateAccessPolicyApiResponsedata - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
     }
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
-        'common.v1.config.Message': 'common.v1.config.Message',
+        'EMPTY_MAP': 'dict(str, object)',
+        'iam.v4.authn.BucketsAccessKey': 'iam.v4.authn.BucketsAccessKey',
         'iam.v4.error.ErrorResponse': 'iam.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
-        """CreateAccessPolicyApiResponsedata - a model defined in Swagger
-            
-        """
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfiam.v4.authz.CreateAccessPolicyApiResponsedata'
+        return 'OneOfiam.v4.authn.CreateUserKeyApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -101,82 +95,95 @@
         """Returns the real base class specified by the discriminator"""
         if discriminator is not None and discriminator in self.discriminator_value_class_map:
             return self.discriminator_value_class_map.get(discriminator)
         return None
 
     @staticmethod
     def get_discriminator_from_object(value):
-        """Returns the model properties as a dict"""
+        """Returns the discriminator for the provided object.
+        """
         if not value:
             disc = 'list[str]'
         elif hasattr(value, "_object_type"):
             disc = value.get_object_type()
         elif type(value) == list:
             if hasattr(value[0], "_object_type"):
                 datatype = value[0].get_object_type()
             else:
                 datatype = type(value[0]).__name__
             disc = 'list[' + datatype + ']'
+        elif type(value) == dict:
+            if hasattr(next(iter(value.values())), "_object_type"):
+                datatype = next(iter(value.values())).get_object_type()
+            else:
+                datatype = type(next(iter(value.values()))).__name__
+            disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in CreateAccessPolicyApiResponsedata.discriminator_value_class_map.values():
-            return list(CreateAccessPolicyApiResponsedata.discriminator_value_class_map.keys())[list(CreateAccessPolicyApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in CreateUserKeyApiResponsedata.discriminator_value_class_map.values():
+            return list(CreateUserKeyApiResponsedata.discriminator_value_class_map.keys())[list(CreateUserKeyApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(CreateAccessPolicyApiResponsedata, dict):
+        if issubclass(CreateUserKeyApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, CreateAccessPolicyApiResponsedata):
+        if not isinstance(other, CreateUserKeyApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authz/CreateRoleApiResponsedata.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authz/DeleteRoleApiResponsedata.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,93 +1,86 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class DeleteRoleApiResponsedata(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """
 
 
-class CreateRoleApiResponsedata(object):
-    """CreateRoleApiResponsedata - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
     }
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
-        'common.v1.config.Message': 'common.v1.config.Message',
+        'EMPTY_MAP': 'dict(str, object)',
         'iam.v4.error.ErrorResponse': 'iam.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
-        """CreateRoleApiResponsedata - a model defined in Swagger
-            
-        """
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfiam.v4.authz.CreateRoleApiResponsedata'
+        return 'OneOfiam.v4.authz.DeleteRoleApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -101,82 +94,95 @@
         """Returns the real base class specified by the discriminator"""
         if discriminator is not None and discriminator in self.discriminator_value_class_map:
             return self.discriminator_value_class_map.get(discriminator)
         return None
 
     @staticmethod
     def get_discriminator_from_object(value):
-        """Returns the model properties as a dict"""
+        """Returns the discriminator for the provided object.
+        """
         if not value:
             disc = 'list[str]'
         elif hasattr(value, "_object_type"):
             disc = value.get_object_type()
         elif type(value) == list:
             if hasattr(value[0], "_object_type"):
                 datatype = value[0].get_object_type()
             else:
                 datatype = type(value[0]).__name__
             disc = 'list[' + datatype + ']'
+        elif type(value) == dict:
+            if hasattr(next(iter(value.values())), "_object_type"):
+                datatype = next(iter(value.values())).get_object_type()
+            else:
+                datatype = type(next(iter(value.values()))).__name__
+            disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in CreateRoleApiResponsedata.discriminator_value_class_map.values():
-            return list(CreateRoleApiResponsedata.discriminator_value_class_map.keys())[list(CreateRoleApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in DeleteRoleApiResponsedata.discriminator_value_class_map.values():
+            return list(DeleteRoleApiResponsedata.discriminator_value_class_map.keys())[list(DeleteRoleApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(CreateRoleApiResponsedata, dict):
+        if issubclass(DeleteRoleApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, CreateRoleApiResponsedata):
+        if not isinstance(other, DeleteRoleApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authz/DeleteAccessPolicyApiResponsedata.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authz/ListRolesApiResponsedata.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,92 +1,88 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class ListRolesApiResponsedata(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """
 
 
-class DeleteAccessPolicyApiResponsedata(object):
-    """DeleteAccessPolicyApiResponsedata - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
     }
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
-        'iam.v4.error.ErrorResponse': 'iam.v4.error.ErrorResponse'
+        'EMPTY_MAP': 'dict(str, object)',
+        'List<iam.v4.authz.Role>': 'list[iam.v4.authz.Role]',
+        'iam.v4.error.ErrorResponse': 'iam.v4.error.ErrorResponse',
+        'List<iam.v4.authz.RoleProjection>': 'list[iam.v4.authz.RoleProjection]'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
-        """DeleteAccessPolicyApiResponsedata - a model defined in Swagger
-            
-        """
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfiam.v4.authz.DeleteAccessPolicyApiResponsedata'
+        return 'OneOfiam.v4.authz.ListRolesApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -100,82 +96,95 @@
         """Returns the real base class specified by the discriminator"""
         if discriminator is not None and discriminator in self.discriminator_value_class_map:
             return self.discriminator_value_class_map.get(discriminator)
         return None
 
     @staticmethod
     def get_discriminator_from_object(value):
-        """Returns the model properties as a dict"""
+        """Returns the discriminator for the provided object.
+        """
         if not value:
             disc = 'list[str]'
         elif hasattr(value, "_object_type"):
             disc = value.get_object_type()
         elif type(value) == list:
             if hasattr(value[0], "_object_type"):
                 datatype = value[0].get_object_type()
             else:
                 datatype = type(value[0]).__name__
             disc = 'list[' + datatype + ']'
+        elif type(value) == dict:
+            if hasattr(next(iter(value.values())), "_object_type"):
+                datatype = next(iter(value.values())).get_object_type()
+            else:
+                datatype = type(next(iter(value.values()))).__name__
+            disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in DeleteAccessPolicyApiResponsedata.discriminator_value_class_map.values():
-            return list(DeleteAccessPolicyApiResponsedata.discriminator_value_class_map.keys())[list(DeleteAccessPolicyApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in ListRolesApiResponsedata.discriminator_value_class_map.values():
+            return list(ListRolesApiResponsedata.discriminator_value_class_map.keys())[list(ListRolesApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(DeleteAccessPolicyApiResponsedata, dict):
+        if issubclass(ListRolesApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, DeleteAccessPolicyApiResponsedata):
+        if not isinstance(other, ListRolesApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authz/DeleteRoleApiResponsedata.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/CreateServiceAccountKeyApiResponsedata.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,92 +1,87 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class CreateServiceAccountKeyApiResponsedata(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """
 
 
-class DeleteRoleApiResponsedata(object):
-    """DeleteRoleApiResponsedata - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
     }
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
+        'EMPTY_MAP': 'dict(str, object)',
+        'iam.v4.authn.ServiceAccountKey': 'iam.v4.authn.ServiceAccountKey',
         'iam.v4.error.ErrorResponse': 'iam.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
-        """DeleteRoleApiResponsedata - a model defined in Swagger
-            
-        """
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfiam.v4.authz.DeleteRoleApiResponsedata'
+        return 'OneOfiam.v4.authn.CreateServiceAccountKeyApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -100,82 +95,95 @@
         """Returns the real base class specified by the discriminator"""
         if discriminator is not None and discriminator in self.discriminator_value_class_map:
             return self.discriminator_value_class_map.get(discriminator)
         return None
 
     @staticmethod
     def get_discriminator_from_object(value):
-        """Returns the model properties as a dict"""
+        """Returns the discriminator for the provided object.
+        """
         if not value:
             disc = 'list[str]'
         elif hasattr(value, "_object_type"):
             disc = value.get_object_type()
         elif type(value) == list:
             if hasattr(value[0], "_object_type"):
                 datatype = value[0].get_object_type()
             else:
                 datatype = type(value[0]).__name__
             disc = 'list[' + datatype + ']'
+        elif type(value) == dict:
+            if hasattr(next(iter(value.values())), "_object_type"):
+                datatype = next(iter(value.values())).get_object_type()
+            else:
+                datatype = type(next(iter(value.values()))).__name__
+            disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in DeleteRoleApiResponsedata.discriminator_value_class_map.values():
-            return list(DeleteRoleApiResponsedata.discriminator_value_class_map.keys())[list(DeleteRoleApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in CreateServiceAccountKeyApiResponsedata.discriminator_value_class_map.values():
+            return list(CreateServiceAccountKeyApiResponsedata.discriminator_value_class_map.keys())[list(CreateServiceAccountKeyApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(DeleteRoleApiResponsedata, dict):
+        if issubclass(CreateServiceAccountKeyApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, DeleteRoleApiResponsedata):
+        if not isinstance(other, CreateServiceAccountKeyApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authz/ListAccessPolicyApiResponsedata.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authz/ListAuthorizationPoliciesApiResponsedata.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,93 +1,88 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class ListAuthorizationPoliciesApiResponsedata(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """
 
 
-class ListAccessPolicyApiResponsedata(object):
-    """ListAccessPolicyApiResponsedata - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
     }
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
-        'List<iam.v4.authz.AccessPolicy>': 'list[iam.v4.authz.AccessPolicy]',
-        'iam.v4.error.ErrorResponse': 'iam.v4.error.ErrorResponse'
+        'EMPTY_MAP': 'dict(str, object)',
+        'List<iam.v4.authz.AuthorizationPolicy>': 'list[iam.v4.authz.AuthorizationPolicy]',
+        'iam.v4.error.ErrorResponse': 'iam.v4.error.ErrorResponse',
+        'List<iam.v4.authz.AuthorizationPolicyProjection>': 'list[iam.v4.authz.AuthorizationPolicyProjection]'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
-        """ListAccessPolicyApiResponsedata - a model defined in Swagger
-            
-        """
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfiam.v4.authz.ListAccessPolicyApiResponsedata'
+        return 'OneOfiam.v4.authz.ListAuthorizationPoliciesApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -101,82 +96,95 @@
         """Returns the real base class specified by the discriminator"""
         if discriminator is not None and discriminator in self.discriminator_value_class_map:
             return self.discriminator_value_class_map.get(discriminator)
         return None
 
     @staticmethod
     def get_discriminator_from_object(value):
-        """Returns the model properties as a dict"""
+        """Returns the discriminator for the provided object.
+        """
         if not value:
             disc = 'list[str]'
         elif hasattr(value, "_object_type"):
             disc = value.get_object_type()
         elif type(value) == list:
             if hasattr(value[0], "_object_type"):
                 datatype = value[0].get_object_type()
             else:
                 datatype = type(value[0]).__name__
             disc = 'list[' + datatype + ']'
+        elif type(value) == dict:
+            if hasattr(next(iter(value.values())), "_object_type"):
+                datatype = next(iter(value.values())).get_object_type()
+            else:
+                datatype = type(next(iter(value.values()))).__name__
+            disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in ListAccessPolicyApiResponsedata.discriminator_value_class_map.values():
-            return list(ListAccessPolicyApiResponsedata.discriminator_value_class_map.keys())[list(ListAccessPolicyApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in ListAuthorizationPoliciesApiResponsedata.discriminator_value_class_map.values():
+            return list(ListAuthorizationPoliciesApiResponsedata.discriminator_value_class_map.keys())[list(ListAuthorizationPoliciesApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ListAccessPolicyApiResponsedata, dict):
+        if issubclass(ListAuthorizationPoliciesApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ListAccessPolicyApiResponsedata):
+        if not isinstance(other, ListAuthorizationPoliciesApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authz/ListOperationApiResponsedata.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authz/ListOperationsApiResponsedata.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,93 +1,87 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class ListOperationsApiResponsedata(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """
 
 
-class ListOperationApiResponsedata(object):
-    """ListOperationApiResponsedata - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
     }
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
+        'EMPTY_MAP': 'dict(str, object)',
         'List<iam.v4.authz.Operation>': 'list[iam.v4.authz.Operation]',
         'iam.v4.error.ErrorResponse': 'iam.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
-        """ListOperationApiResponsedata - a model defined in Swagger
-            
-        """
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfiam.v4.authz.ListOperationApiResponsedata'
+        return 'OneOfiam.v4.authz.ListOperationsApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -101,82 +95,95 @@
         """Returns the real base class specified by the discriminator"""
         if discriminator is not None and discriminator in self.discriminator_value_class_map:
             return self.discriminator_value_class_map.get(discriminator)
         return None
 
     @staticmethod
     def get_discriminator_from_object(value):
-        """Returns the model properties as a dict"""
+        """Returns the discriminator for the provided object.
+        """
         if not value:
             disc = 'list[str]'
         elif hasattr(value, "_object_type"):
             disc = value.get_object_type()
         elif type(value) == list:
             if hasattr(value[0], "_object_type"):
                 datatype = value[0].get_object_type()
             else:
                 datatype = type(value[0]).__name__
             disc = 'list[' + datatype + ']'
+        elif type(value) == dict:
+            if hasattr(next(iter(value.values())), "_object_type"):
+                datatype = next(iter(value.values())).get_object_type()
+            else:
+                datatype = type(next(iter(value.values()))).__name__
+            disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in ListOperationApiResponsedata.discriminator_value_class_map.values():
-            return list(ListOperationApiResponsedata.discriminator_value_class_map.keys())[list(ListOperationApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in ListOperationsApiResponsedata.discriminator_value_class_map.values():
+            return list(ListOperationsApiResponsedata.discriminator_value_class_map.keys())[list(ListOperationsApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ListOperationApiResponsedata, dict):
+        if issubclass(ListOperationsApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ListOperationApiResponsedata):
+        if not isinstance(other, ListOperationsApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authz/ListRoleApiResponsedata.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/GetServiceAccountKeyApiResponsedata.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,93 +1,87 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class GetServiceAccountKeyApiResponsedata(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """
 
 
-class ListRoleApiResponsedata(object):
-    """ListRoleApiResponsedata - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
     }
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
-        'List<iam.v4.authz.Role>': 'list[iam.v4.authz.Role]',
+        'EMPTY_MAP': 'dict(str, object)',
+        'iam.v4.authn.ServiceAccountKey': 'iam.v4.authn.ServiceAccountKey',
         'iam.v4.error.ErrorResponse': 'iam.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
-        """ListRoleApiResponsedata - a model defined in Swagger
-            
-        """
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfiam.v4.authz.ListRoleApiResponsedata'
+        return 'OneOfiam.v4.authn.GetServiceAccountKeyApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -101,82 +95,95 @@
         """Returns the real base class specified by the discriminator"""
         if discriminator is not None and discriminator in self.discriminator_value_class_map:
             return self.discriminator_value_class_map.get(discriminator)
         return None
 
     @staticmethod
     def get_discriminator_from_object(value):
-        """Returns the model properties as a dict"""
+        """Returns the discriminator for the provided object.
+        """
         if not value:
             disc = 'list[str]'
         elif hasattr(value, "_object_type"):
             disc = value.get_object_type()
         elif type(value) == list:
             if hasattr(value[0], "_object_type"):
                 datatype = value[0].get_object_type()
             else:
                 datatype = type(value[0]).__name__
             disc = 'list[' + datatype + ']'
+        elif type(value) == dict:
+            if hasattr(next(iter(value.values())), "_object_type"):
+                datatype = next(iter(value.values())).get_object_type()
+            else:
+                datatype = type(next(iter(value.values()))).__name__
+            disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in ListRoleApiResponsedata.discriminator_value_class_map.values():
-            return list(ListRoleApiResponsedata.discriminator_value_class_map.keys())[list(ListRoleApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in GetServiceAccountKeyApiResponsedata.discriminator_value_class_map.values():
+            return list(GetServiceAccountKeyApiResponsedata.discriminator_value_class_map.keys())[list(GetServiceAccountKeyApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ListRoleApiResponsedata, dict):
+        if issubclass(GetServiceAccountKeyApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ListRoleApiResponsedata):
+        if not isinstance(other, GetServiceAccountKeyApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authz/UpdateAccessPolicyApiResponsedata.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authz/GetAuthorizationPolicyApiResponsedata.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,93 +1,87 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class GetAuthorizationPolicyApiResponsedata(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """
 
 
-class UpdateAccessPolicyApiResponsedata(object):
-    """UpdateAccessPolicyApiResponsedata - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
     }
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
-        'common.v1.config.Message': 'common.v1.config.Message',
+        'EMPTY_MAP': 'dict(str, object)',
+        'iam.v4.authz.AuthorizationPolicy': 'iam.v4.authz.AuthorizationPolicy',
         'iam.v4.error.ErrorResponse': 'iam.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
-        """UpdateAccessPolicyApiResponsedata - a model defined in Swagger
-            
-        """
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfiam.v4.authz.UpdateAccessPolicyApiResponsedata'
+        return 'OneOfiam.v4.authz.GetAuthorizationPolicyApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -101,82 +95,95 @@
         """Returns the real base class specified by the discriminator"""
         if discriminator is not None and discriminator in self.discriminator_value_class_map:
             return self.discriminator_value_class_map.get(discriminator)
         return None
 
     @staticmethod
     def get_discriminator_from_object(value):
-        """Returns the model properties as a dict"""
+        """Returns the discriminator for the provided object.
+        """
         if not value:
             disc = 'list[str]'
         elif hasattr(value, "_object_type"):
             disc = value.get_object_type()
         elif type(value) == list:
             if hasattr(value[0], "_object_type"):
                 datatype = value[0].get_object_type()
             else:
                 datatype = type(value[0]).__name__
             disc = 'list[' + datatype + ']'
+        elif type(value) == dict:
+            if hasattr(next(iter(value.values())), "_object_type"):
+                datatype = next(iter(value.values())).get_object_type()
+            else:
+                datatype = type(next(iter(value.values()))).__name__
+            disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in UpdateAccessPolicyApiResponsedata.discriminator_value_class_map.values():
-            return list(UpdateAccessPolicyApiResponsedata.discriminator_value_class_map.keys())[list(UpdateAccessPolicyApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in GetAuthorizationPolicyApiResponsedata.discriminator_value_class_map.values():
+            return list(GetAuthorizationPolicyApiResponsedata.discriminator_value_class_map.keys())[list(GetAuthorizationPolicyApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(UpdateAccessPolicyApiResponsedata, dict):
+        if issubclass(GetAuthorizationPolicyApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, UpdateAccessPolicyApiResponsedata):
+        if not isinstance(other, GetAuthorizationPolicyApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authz/UpdateRoleApiResponsedata.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authz/CreateRoleApiResponsedata.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,93 +1,87 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class CreateRoleApiResponsedata(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """
 
 
-class UpdateRoleApiResponsedata(object):
-    """UpdateRoleApiResponsedata - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
     }
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
-        'common.v1.config.Message': 'common.v1.config.Message',
+        'EMPTY_MAP': 'dict(str, object)',
+        'iam.v4.authz.Role': 'iam.v4.authz.Role',
         'iam.v4.error.ErrorResponse': 'iam.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
-        """UpdateRoleApiResponsedata - a model defined in Swagger
-            
-        """
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfiam.v4.authz.UpdateRoleApiResponsedata'
+        return 'OneOfiam.v4.authz.CreateRoleApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -101,82 +95,95 @@
         """Returns the real base class specified by the discriminator"""
         if discriminator is not None and discriminator in self.discriminator_value_class_map:
             return self.discriminator_value_class_map.get(discriminator)
         return None
 
     @staticmethod
     def get_discriminator_from_object(value):
-        """Returns the model properties as a dict"""
+        """Returns the discriminator for the provided object.
+        """
         if not value:
             disc = 'list[str]'
         elif hasattr(value, "_object_type"):
             disc = value.get_object_type()
         elif type(value) == list:
             if hasattr(value[0], "_object_type"):
                 datatype = value[0].get_object_type()
             else:
                 datatype = type(value[0]).__name__
             disc = 'list[' + datatype + ']'
+        elif type(value) == dict:
+            if hasattr(next(iter(value.values())), "_object_type"):
+                datatype = next(iter(value.values())).get_object_type()
+            else:
+                datatype = type(next(iter(value.values()))).__name__
+            disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in UpdateRoleApiResponsedata.discriminator_value_class_map.values():
-            return list(UpdateRoleApiResponsedata.discriminator_value_class_map.keys())[list(UpdateRoleApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in CreateRoleApiResponsedata.discriminator_value_class_map.values():
+            return list(CreateRoleApiResponsedata.discriminator_value_class_map.keys())[list(CreateRoleApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(UpdateRoleApiResponsedata, dict):
+        if issubclass(CreateRoleApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, UpdateRoleApiResponsedata):
+        if not isinstance(other, CreateRoleApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authz/ViewAccessPolicyApiResponsedata.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authn/CreateSystemConfigApiResponsedata.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,93 +1,87 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class CreateSystemConfigApiResponsedata(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """
 
 
-class ViewAccessPolicyApiResponsedata(object):
-    """ViewAccessPolicyApiResponsedata - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
     }
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
-        'iam.v4.authz.AccessPolicy': 'iam.v4.authz.AccessPolicy',
+        'EMPTY_MAP': 'dict(str, object)',
+        'iam.v4.authn.SystemConfig': 'iam.v4.authn.SystemConfig',
         'iam.v4.error.ErrorResponse': 'iam.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
-        """ViewAccessPolicyApiResponsedata - a model defined in Swagger
-            
-        """
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfiam.v4.authz.ViewAccessPolicyApiResponsedata'
+        return 'OneOfiam.v4.authn.CreateSystemConfigApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -101,82 +95,95 @@
         """Returns the real base class specified by the discriminator"""
         if discriminator is not None and discriminator in self.discriminator_value_class_map:
             return self.discriminator_value_class_map.get(discriminator)
         return None
 
     @staticmethod
     def get_discriminator_from_object(value):
-        """Returns the model properties as a dict"""
+        """Returns the discriminator for the provided object.
+        """
         if not value:
             disc = 'list[str]'
         elif hasattr(value, "_object_type"):
             disc = value.get_object_type()
         elif type(value) == list:
             if hasattr(value[0], "_object_type"):
                 datatype = value[0].get_object_type()
             else:
                 datatype = type(value[0]).__name__
             disc = 'list[' + datatype + ']'
+        elif type(value) == dict:
+            if hasattr(next(iter(value.values())), "_object_type"):
+                datatype = next(iter(value.values())).get_object_type()
+            else:
+                datatype = type(next(iter(value.values()))).__name__
+            disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in ViewAccessPolicyApiResponsedata.discriminator_value_class_map.values():
-            return list(ViewAccessPolicyApiResponsedata.discriminator_value_class_map.keys())[list(ViewAccessPolicyApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in CreateSystemConfigApiResponsedata.discriminator_value_class_map.values():
+            return list(CreateSystemConfigApiResponsedata.discriminator_value_class_map.keys())[list(CreateSystemConfigApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ViewAccessPolicyApiResponsedata, dict):
+        if issubclass(CreateSystemConfigApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ViewAccessPolicyApiResponsedata):
+        if not isinstance(other, CreateSystemConfigApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authz/ViewOperationApiResponsedata.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authz/CreateAuthorizationPolicyApiResponsedata.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,93 +1,87 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class CreateAuthorizationPolicyApiResponsedata(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """
 
 
-class ViewOperationApiResponsedata(object):
-    """ViewOperationApiResponsedata - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
     }
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
-        'iam.v4.authz.Operation': 'iam.v4.authz.Operation',
+        'EMPTY_MAP': 'dict(str, object)',
+        'iam.v4.authz.AuthorizationPolicy': 'iam.v4.authz.AuthorizationPolicy',
         'iam.v4.error.ErrorResponse': 'iam.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
-        """ViewOperationApiResponsedata - a model defined in Swagger
-            
-        """
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfiam.v4.authz.ViewOperationApiResponsedata'
+        return 'OneOfiam.v4.authz.CreateAuthorizationPolicyApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -101,82 +95,95 @@
         """Returns the real base class specified by the discriminator"""
         if discriminator is not None and discriminator in self.discriminator_value_class_map:
             return self.discriminator_value_class_map.get(discriminator)
         return None
 
     @staticmethod
     def get_discriminator_from_object(value):
-        """Returns the model properties as a dict"""
+        """Returns the discriminator for the provided object.
+        """
         if not value:
             disc = 'list[str]'
         elif hasattr(value, "_object_type"):
             disc = value.get_object_type()
         elif type(value) == list:
             if hasattr(value[0], "_object_type"):
                 datatype = value[0].get_object_type()
             else:
                 datatype = type(value[0]).__name__
             disc = 'list[' + datatype + ']'
+        elif type(value) == dict:
+            if hasattr(next(iter(value.values())), "_object_type"):
+                datatype = next(iter(value.values())).get_object_type()
+            else:
+                datatype = type(next(iter(value.values()))).__name__
+            disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in ViewOperationApiResponsedata.discriminator_value_class_map.values():
-            return list(ViewOperationApiResponsedata.discriminator_value_class_map.keys())[list(ViewOperationApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in CreateAuthorizationPolicyApiResponsedata.discriminator_value_class_map.values():
+            return list(CreateAuthorizationPolicyApiResponsedata.discriminator_value_class_map.keys())[list(CreateAuthorizationPolicyApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ViewOperationApiResponsedata, dict):
+        if issubclass(CreateAuthorizationPolicyApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ViewOperationApiResponsedata):
+        if not isinstance(other, CreateAuthorizationPolicyApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/authz/ViewRoleApiResponsedata.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authz/UpdateRoleApiResponsedata.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,93 +1,87 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class UpdateRoleApiResponsedata(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """
 
 
-class ViewRoleApiResponsedata(object):
-    """ViewRoleApiResponsedata - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
     }
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
-        'iam.v4.authz.Role': 'iam.v4.authz.Role',
+        'EMPTY_MAP': 'dict(str, object)',
+        'common.v1.config.Message': 'common.v1.config.Message',
         'iam.v4.error.ErrorResponse': 'iam.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
-        """ViewRoleApiResponsedata - a model defined in Swagger
-            
-        """
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfiam.v4.authz.ViewRoleApiResponsedata'
+        return 'OneOfiam.v4.authz.UpdateRoleApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -101,82 +95,95 @@
         """Returns the real base class specified by the discriminator"""
         if discriminator is not None and discriminator in self.discriminator_value_class_map:
             return self.discriminator_value_class_map.get(discriminator)
         return None
 
     @staticmethod
     def get_discriminator_from_object(value):
-        """Returns the model properties as a dict"""
+        """Returns the discriminator for the provided object.
+        """
         if not value:
             disc = 'list[str]'
         elif hasattr(value, "_object_type"):
             disc = value.get_object_type()
         elif type(value) == list:
             if hasattr(value[0], "_object_type"):
                 datatype = value[0].get_object_type()
             else:
                 datatype = type(value[0]).__name__
             disc = 'list[' + datatype + ']'
+        elif type(value) == dict:
+            if hasattr(next(iter(value.values())), "_object_type"):
+                datatype = next(iter(value.values())).get_object_type()
+            else:
+                datatype = type(next(iter(value.values()))).__name__
+            disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in ViewRoleApiResponsedata.discriminator_value_class_map.values():
-            return list(ViewRoleApiResponsedata.discriminator_value_class_map.keys())[list(ViewRoleApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in UpdateRoleApiResponsedata.discriminator_value_class_map.values():
+            return list(UpdateRoleApiResponsedata.discriminator_value_class_map.keys())[list(UpdateRoleApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ViewRoleApiResponsedata, dict):
+        if issubclass(UpdateRoleApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ViewRoleApiResponsedata):
+        if not isinstance(other, UpdateRoleApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/OneOfiam/v4/error/ErrorResponseerror.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/OneOfiam/v4/authz/UpdateAuthorizationPolicyApiResponsedata.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,93 +1,87 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class UpdateAuthorizationPolicyApiResponsedata(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """
 
 
-class ErrorResponseerror(object):
-    """ErrorResponseerror - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
     }
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
-        'List<iam.v4.error.AppMessage>': 'list[iam.v4.error.AppMessage]',
-        'iam.v4.error.SchemaValidationError': 'iam.v4.error.SchemaValidationError'
+        'EMPTY_MAP': 'dict(str, object)',
+        'common.v1.config.Message': 'common.v1.config.Message',
+        'iam.v4.error.ErrorResponse': 'iam.v4.error.ErrorResponse'
     }
 
-    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$errorItemDiscriminator'
+    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
-        """ErrorResponseerror - a model defined in Swagger
-            
-        """
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfiam.v4.error.ErrorResponseerror'
+        return 'OneOfiam.v4.authz.UpdateAuthorizationPolicyApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -101,82 +95,95 @@
         """Returns the real base class specified by the discriminator"""
         if discriminator is not None and discriminator in self.discriminator_value_class_map:
             return self.discriminator_value_class_map.get(discriminator)
         return None
 
     @staticmethod
     def get_discriminator_from_object(value):
-        """Returns the model properties as a dict"""
+        """Returns the discriminator for the provided object.
+        """
         if not value:
             disc = 'list[str]'
         elif hasattr(value, "_object_type"):
             disc = value.get_object_type()
         elif type(value) == list:
             if hasattr(value[0], "_object_type"):
                 datatype = value[0].get_object_type()
             else:
                 datatype = type(value[0]).__name__
             disc = 'list[' + datatype + ']'
+        elif type(value) == dict:
+            if hasattr(next(iter(value.values())), "_object_type"):
+                datatype = next(iter(value.values())).get_object_type()
+            else:
+                datatype = type(next(iter(value.values()))).__name__
+            disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in ErrorResponseerror.discriminator_value_class_map.values():
-            return list(ErrorResponseerror.discriminator_value_class_map.keys())[list(ErrorResponseerror.discriminator_value_class_map.values()).index(disc)]
+        if disc in UpdateAuthorizationPolicyApiResponsedata.discriminator_value_class_map.values():
+            return list(UpdateAuthorizationPolicyApiResponsedata.discriminator_value_class_map.keys())[list(UpdateAuthorizationPolicyApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ErrorResponseerror, dict):
+        if issubclass(UpdateAuthorizationPolicyApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ErrorResponseerror):
+        if not isinstance(other, UpdateAuthorizationPolicyApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/common/v1/config/Flag.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/EntityFilter.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,210 +1,185 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class EntityFilter(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """
 
 
-class Flag(object):
-    """Flag - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
-        'name': 'str',
-        'value': 'bool',
         '_reserved': 'dict(str, object)',
-        '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
+        '_object_type': 'str',
     }
 
     attribute_map = {
-        'name': 'name',
-        'value': 'value',
         '_reserved': '$reserved',
-        '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
+        '_object_type': '$objectType',
     }
 
 
 
-    def __init__(self, name=None, value=False, *args, **kwargs):  # noqa: E501
-        """Flag - a model defined in Swagger
-            \nMany entities in the Nutanix APIs carry flags.  This object captures all the flags associated with that entity through this object.  The field that hosts this type of object must have an attribute called x-bounded-map-keys that tells which flags are actually present for that entity. 
-        """
-        self.__name = None
-        self.__value = None
+    def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
-        if name is not None:
-            self.__name = name
-        if value is not None:
-            self.__value = value
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'common.v1.config.Flag'
+        return 'iam.v4.authz.EntityFilter'
 
-    def _initialize_fq_object_type(self):
-        return 'common.v1.r0.a3.config.Flag'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def name(self):
-        """`{ str }`
-            
-        """ # noqa: E501
-        return self.__name
-
-    @name.setter
-    def name(self, name):
+    def _reserved(self):
+        """
+        
 
-        self.__name = name
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
+        return self.__dollar_reserved
 
     @property
-    def value(self):
-        """`{ bool }`
-            
-        """ # noqa: E501
-        return self.__value
-
-    @value.setter
-    def value(self, value):
-
-        self.__value = value
+    def _unknown_fields(self):
+        """
+        
 
-    @property
-    def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
-        return self.__dollar_reserved
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
+        return self.__dollar_unknown_fields
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
-        return self.__dollar_object_type
+        """
+        
 
-    @property
-    def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
-        return self.__dollar_unknown_fields
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__dollar_object_type
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(Flag, dict):
+        if issubclass(EntityFilter, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, Flag):
+        if not isinstance(other, EntityFilter):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/common/v1/config/KVPair.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/SecretKeyRequest.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,216 +1,209 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_iam_py_client.Ntnx
-from ntnx_iam_py_client.Ntnx.OneOfcommon.v1.config.KVPairvalue import KVPairvalue  # noqa: F401,E501
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class SecretKeyRequest(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """Get Secret Key and User details for given Access Key Id.
 
+    :param access_key_id: (:attr:`access_key_id`) External Identifier for Bucket Access Key.
+    :type access_key_id: required
 
-class KVPair(object):
-    """KVPair - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
-        'name': 'str',
-        'value': 'OneOfcommon.v1.config.KVPairvalue',
+        'access_key_id': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'name': 'name',
-        'value': 'value',
+        'access_key_id': 'accessKeyId',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, name=None, value=None, *args, **kwargs):  # noqa: E501
-        """KVPair - a model defined in Swagger
-            \nA map describing a set of keys and their corresponding values. 
-        """
-        self.__name = None
-        self.__value = None
+    def __init__(self, access_key_id=None, *args, **kwargs):  # noqa: E501
+        self.__access_key_id = None
         self.discriminator = None
-        if name is not None:
-            self.__name = name
-        if value is not None:
-            self.__value = value
+        self.__access_key_id = access_key_id
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'common.v1.config.KVPair'
+        return 'iam.v4.authn.SecretKeyRequest'
 
-    def _initialize_fq_object_type(self):
-        return 'common.v1.r0.a3.config.KVPair'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def name(self):
-        """`{ str }`
-            \nThe key of this key-value pair
-        """ # noqa: E501
-        return self.__name
+    def access_key_id(self):
+        """
+        External Identifier for Bucket Access Key.
 
-    @name.setter
-    def name(self, name):
+        :type:
 
-        self.__name = name
+                :class:`~str`
+        """  # noqa: E501
+        return self.__access_key_id
 
-    @property
-    def value(self):
-        """`{ str | int }`
-            \nThe value associated with the key for this key-value pair
-        """ # noqa: E501
-        return self.__value
+    @access_key_id.setter
+    def access_key_id(self, access_key_id):
+        if access_key_id is None:
+            raise ValueError("Invalid value for `access_key_id`, must not be `None`")  # noqa: E501
 
-    @value.setter
-    def value(self, value):
-
-        self.__value = value
+        self.__access_key_id = access_key_id
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
-            if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_iam_py_client.Ntnx, attr_type.split('.')[-1])
-                if hasattr(type, 'get_discriminator_from_object'):
-                    result[type.ONE_OF_ITEM_DISCRIMINATOR_NAME] = type.get_discriminator_from_object(value)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(KVPair, dict):
+        if issubclass(SecretKeyRequest, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, KVPair):
+        if not isinstance(other, SecretKeyRequest):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/common/v1/config/Message.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/common/v1/config/Flag.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,245 +1,231 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_iam_py_client.Ntnx.common.v1.config.MessageSeverity import MessageSeverity  # noqa: F401,E501
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class Flag(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """Many entities in the Nutanix APIs carry flags.  This object captures all the flags associated with that entity through this object.  The field that hosts this type of object must have an attribute called x-bounded-map-keys that tells which flags are actually present for that entity. 
 
+    :param name: (:attr:`name`) 
+    :type name: 
+    :param value: (:attr:`value`) 
+    :type value: 
 
-class Message(object):
-    """Message - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
-        'code': 'str',
-        'message': 'str',
-        'locale': 'str',
-        'severity': 'common.v1.config.MessageSeverity',
+        'name': 'str',
+        'value': 'bool',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'code': 'code',
-        'message': 'message',
-        'locale': 'locale',
-        'severity': 'severity',
+        'name': 'name',
+        'value': 'value',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, code=None, message=None, locale='en_US', severity=None, *args, **kwargs):  # noqa: E501
-        """Message - a model defined in Swagger
-            
-        """
-        self.__code = None
-        self.__message = None
-        self.__locale = None
-        self.__severity = None
+    def __init__(self, name=None, value=False, *args, **kwargs):  # noqa: E501
+        self.__name = None
+        self.__value = None
         self.discriminator = None
-        if code is not None:
-            self.__code = code
-        if message is not None:
-            self.__message = message
-        if locale is not None:
-            self.__locale = locale
-        if severity is not None:
-            self.__severity = severity
+        if name is not None:
+            self.__name = name
+        if value is not None:
+            self.__value = value
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'common.v1.config.Message'
+        return 'common.v1.config.Flag'
 
-    def _initialize_fq_object_type(self):
-        return 'common.v1.r0.a3.config.Message'
+    def _initialize_object_version(self):
+        return 'v1.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def code(self):
-        """`{ str }`
-            \nA code that uniquely identifies a message. 
-        """ # noqa: E501
-        return self.__code
-
-    @code.setter
-    def code(self, code):
+    def name(self):
+        """
+        
 
-        self.__code = code
+        :type:
 
-    @property
-    def message(self):
-        """`{ str }`
-            
-        """ # noqa: E501
-        return self.__message
+                :class:`~str`
+        """  # noqa: E501
+        return self.__name
 
-    @message.setter
-    def message(self, message):
+    @name.setter
+    def name(self, name):
 
-        self.__message = message
+        self.__name = name
 
     @property
-    def locale(self):
-        """`{ str }`
-            \nThe locale for the message description. 
-        """ # noqa: E501
-        return self.__locale
-
-    @locale.setter
-    def locale(self, locale):
+    def value(self):
+        """
+        
 
-        self.__locale = locale
+        :type:
 
-    @property
-    def severity(self):
-        """`{ common.v1.config.MessageSeverity }`
-            
-        """ # noqa: E501
-        return self.__severity
+                :class:`~bool`
+        """  # noqa: E501
+        return self.__value
 
-    @severity.setter
-    def severity(self, severity):
+    @value.setter
+    def value(self, value):
 
-        self.__severity = severity
+        self.__value = value
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(Message, dict):
+        if issubclass(Flag, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, Message):
+        if not isinstance(other, Flag):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/common/v1/config/MessageSeverity.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/common/v1/config/MessageSeverity.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,124 +1,119 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
-
-Do not edit the class manually.
-IGNORE
-"""
-
+from pathlib import Path
 
 class MessageSeverity(object):
 
-    """
-    allowed enum values :
+    """The message severity. 
 
-    _UNKNOWN 
 
-    _REDACTED 
+    Allowed enum values:
 
-    INFO 
+        - _UNKNOWN
+        - _REDACTED
+        - INFO: Information about successful completion.
 
-    WARNING 
+        - WARNING: Warning indicating future error.
 
-    ERROR 
+        - ERROR: Error indicating failed completion.
 
     """
     _UNKNOWN = "$UNKNOWN"
     _REDACTED = "$REDACTED"
     INFO = "INFO"
     WARNING = "WARNING"
     ERROR = "ERROR"
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
-        """MessageSeverity - a model defined in Swagger
-            \nThe message severity. 
-        """
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'common.v1.config.MessageSeverity'
 
-    def _initialize_fq_object_type(self):
-        return 'common.v1.r0.a3.config.MessageSeverity'
+    def _initialize_object_version(self):
+        return 'v1.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
@@ -126,15 +121,15 @@
         if issubclass(MessageSeverity, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/common/v1/config/TenantAwareModel.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/common/v1/config/TenantAwareModel.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,48 +1,46 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class TenantAwareModel(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """A model base class whose instances are bound to a specific tenant.  This model adds a tenantId to the base model class that it extends and is automatically set by the server. 
 
+    :param tenant_id: (:attr:`tenant_id`) A globally unique identifier that represents the tenant that owns this entity. The system automatically assigns it, and it and is immutable from an API consumer perspective (some use cases may cause this Id to change - For instance, a use case may require the transfer of ownership of the entity, but these cases are handled automatically on the server). 
+    :type tenant_id: 
 
-class TenantAwareModel(object):
-    """TenantAwareModel - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'tenant_id': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
@@ -52,46 +50,43 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, tenant_id=None, *args, **kwargs):  # noqa: E501
-        """TenantAwareModel - a model defined in Swagger
-            \nA model base class whose instances are bound to a specific tenant.  This model adds a tenantId to the base model class that it extends and is automatically set by the server. 
-        """
         self.__tenant_id = None
         self.discriminator = None
         if tenant_id is not None:
             self.__tenant_id = tenant_id
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'common.v1.config.TenantAwareModel'
 
-    def _initialize_fq_object_type(self):
-        return 'common.v1.r0.a3.config.TenantAwareModel'
+    def _initialize_object_version(self):
+        return 'v1.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -99,68 +94,88 @@
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def tenant_id(self):
-        """`{ str }`
-            \nA globally unique identifier that represents the tenant that owns this entity.  It is automatically assigned by the system and is immutable from an API consumer perspective (some use cases may cause this Id to change - for instance a use case may require the transfer of ownership of the entity, but these cases are handled automatically on the server). 
-        """ # noqa: E501
+        """
+        A globally unique identifier that represents the tenant that owns this entity. The system automatically assigns it, and it and is immutable from an API consumer perspective (some use cases may cause this Id to change - For instance, a use case may require the transfer of ownership of the entity, but these cases are handled automatically on the server). 
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__tenant_id
 
     @tenant_id.setter
     def tenant_id(self, tenant_id):
         if tenant_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', tenant_id):  # noqa: E501
             raise ValueError(r"Invalid value for `tenant_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
 
         self.__tenant_id = tenant_id
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
@@ -168,15 +183,15 @@
         if issubclass(TenantAwareModel, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/common/v1/response/ApiLink.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/ApiKeyValidateRequest.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,210 +1,212 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class ApiKeyValidateRequest(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """Body of the validate request, consists of an audience.
 
+    :param audience: (:attr:`audience`) 
+    :type audience: 
 
-class ApiLink(object):
-    """ApiLink - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
-        'href': 'str',
-        'rel': 'str',
+        'audience': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'href': 'href',
-        'rel': 'rel',
+        'audience': 'audience',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, href=None, rel=None, *args, **kwargs):  # noqa: E501
-        """ApiLink - a model defined in Swagger
-            \nA HATEOAS style link for the response.  Each link contains a user friendly name identifying the link and an address for retrieving the particular resource. 
-        """
-        self.__href = None
-        self.__rel = None
+    def __init__(self, audience=None, *args, **kwargs):  # noqa: E501
+        self.__audience = None
         self.discriminator = None
-        if href is not None:
-            self.__href = href
-        if rel is not None:
-            self.__rel = rel
+        if audience is not None:
+            self.__audience = audience
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'common.v1.response.ApiLink'
+        return 'iam.v4.authn.ApiKeyValidateRequest'
 
-    def _initialize_fq_object_type(self):
-        return 'common.v1.r0.a3.response.ApiLink'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def href(self):
-        """`{ str }`
-            \nThe URL at which the entity described by this link can be accessed. 
-        """ # noqa: E501
-        return self.__href
-
-    @href.setter
-    def href(self, href):
-
-        self.__href = href
+    def audience(self):
+        """
+        
 
-    @property
-    def rel(self):
-        """`{ str }`
-            \nA name that identifies the relationship of this link to the object that is returned by the URL.  The special value of \"self\" identifies the URL for the object. 
-        """ # noqa: E501
-        return self.__rel
+        :type:
 
-    @rel.setter
-    def rel(self, rel):
+                :class:`~str`
+        """  # noqa: E501
+        return self.__audience
+
+    @audience.setter
+    def audience(self, audience):
+        if audience is not None and len(audience) > 2000:
+            raise ValueError("Invalid value for `audience`, length must be less than or equal to `2000`")  # noqa: E501
+        if audience is not None and len(audience) < 3:
+            raise ValueError("Invalid value for `audience`, length must be greater than or equal to `3`")  # noqa: E501
 
-        self.__rel = rel
+        self.__audience = audience
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ApiLink, dict):
+        if issubclass(ApiKeyValidateRequest, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ApiLink):
+        if not isinstance(other, ApiKeyValidateRequest):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/common/v1/response/ApiResponseMetadata.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/CreateDirectoryServiceApiResponse.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,265 +1,235 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_iam_py_client.Ntnx.common.v1.config.Flag import Flag  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.common.v1.config.KVPair import KVPair  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.common.v1.config.Message import Message  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
+from pathlib import Path
+import ntnx_iam_py_client.models
+from ntnx_iam_py_client.models.OneOfiam.v4.authn.CreateDirectoryServiceApiResponsedata import CreateDirectoryServiceApiResponsedata  # noqa: F401,E501
+from ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class CreateDirectoryServiceApiResponse(object):
+
+    """REST response for all response codes in API path /iam/v4.0.b1/authn/directory-services Post operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
-
-Do not edit the class manually.
-IGNORE
-"""
-
-
-class ApiResponseMetadata(object):
-    """ApiResponseMetadata - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
-        'flags': 'list[common.v1.config.Flag]',
-        'links': 'list[common.v1.response.ApiLink]',
-        'total_available_results': 'int',
-        'messages': 'list[common.v1.config.Message]',
-        'extra_info': 'list[common.v1.config.KVPair]',
+        'metadata': 'common.v1.response.ApiResponseMetadata',
+        'data': 'OneOfiam.v4.authn.CreateDirectoryServiceApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'flags': 'flags',
-        'links': 'links',
-        'total_available_results': 'totalAvailableResults',
-        'messages': 'messages',
-        'extra_info': 'extraInfo',
+        'metadata': 'metadata',
+        'data': 'data',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, flags=None, links=None, total_available_results=None, messages=None, extra_info=None, *args, **kwargs):  # noqa: E501
-        """ApiResponseMetadata - a model defined in Swagger
-            \nThe metadata associated with an API response. Always present and minimally contains the self-link for the API request that produced this response.  Also contains pagination data for paginated requests. 
-        """
-        self.__flags = None
-        self.__links = None
-        self.__total_available_results = None
-        self.__messages = None
-        self.__extra_info = None
+    def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
+        self.__metadata = None
+        self.__data = None
         self.discriminator = None
-        if flags is not None:
-            self.__flags = flags
-        if links is not None:
-            self.__links = links
-        if total_available_results is not None:
-            self.__total_available_results = total_available_results
-        if messages is not None:
-            self.__messages = messages
-        if extra_info is not None:
-            self.__extra_info = extra_info
+        if metadata is not None:
+            self.__metadata = metadata
+        if data is not None:
+            self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'common.v1.response.ApiResponseMetadata'
+        return 'iam.v4.authn.CreateDirectoryServiceApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'common.v1.r0.a3.response.ApiResponseMetadata'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def flags(self):
-        """`{ list[common.v1.config.Flag] }`
-            
-        """ # noqa: E501
-        return self.__flags
-
-    @flags.setter
-    def flags(self, flags):
-
-        self.__flags = flags
+    def metadata(self):
+        """
+        
 
-    @property
-    def links(self):
-        """`{ list[common.v1.response.ApiLink] }`
-            
-        """ # noqa: E501
-        return self.__links
+        :type:
+            :class:`~ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata`
+        """  # noqa: E501
+        return self.__metadata
 
-    @links.setter
-    def links(self, links):
+    @metadata.setter
+    def metadata(self, metadata):
 
-        self.__links = links
+        self.__metadata = metadata
 
     @property
-    def total_available_results(self):
-        """`{ int }`
-            
-        """ # noqa: E501
-        return self.__total_available_results
-
-    @total_available_results.setter
-    def total_available_results(self, total_available_results):
-
-        self.__total_available_results = total_available_results
-
-    @property
-    def messages(self):
-        """`{ list[common.v1.config.Message] }`
-            
-        """ # noqa: E501
-        return self.__messages
-
-    @messages.setter
-    def messages(self, messages):
-
-        self.__messages = messages
+    def data(self):
+        """
+        
 
-    @property
-    def extra_info(self):
-        """`{ list[common.v1.config.KVPair] }`
-            \nAn array of entity-specific metadata 
-        """ # noqa: E501
-        return self.__extra_info
+        :type:
+                :class:`~ntnx_iam_py_client.models.iam.v4.authn.DirectoryService` | 
+                :class:`~ntnx_iam_py_client.models.iam.v4.error.ErrorResponse`
+                    """  # noqa: E501
+        return self.__data
 
-    @extra_info.setter
-    def extra_info(self, extra_info):
+    @data.setter
+    def data(self, data):
 
-        self.__extra_info = extra_info
+        self.__data = data
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
+            if attr_type.startswith('OneOf'):
+                type = getattr(ntnx_iam_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ApiResponseMetadata, dict):
+        if issubclass(CreateDirectoryServiceApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ApiResponseMetadata):
+        if not isinstance(other, CreateDirectoryServiceApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/common/v1/response/ExternalizableAbstractModel.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/common/v1/response/ExternalizableAbstractModel.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,50 +1,50 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_iam_py_client.Ntnx.common.v1.config.TenantAwareModel import TenantAwareModel  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
+from pathlib import Path
+from ntnx_iam_py_client.models.common.v1.config.TenantAwareModel import TenantAwareModel  # noqa: F401,E501
+from ntnx_iam_py_client.models.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class ExternalizableAbstractModel(TenantAwareModel):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """A model that represents an object instance that is accessible through an API endpoint.  Instances of this type get an extId field that contains the globally unique identifier for that instance.  Externally accessible instances are always tenant aware and, therefore, extend the TenantAwareModel 
 
+    :param ext_id: (:attr:`ext_id`) A globally unique identifier of an instance that is suitable for external consumption. 
+    :type ext_id: 
+    :param links: (:attr:`links`) A HATEOAS style link for the response.  Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource. 
+    :type links: 
 
-class ExternalizableAbstractModel(TenantAwareModel):
-    """ExternalizableAbstractModel - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'ext_id': 'str',
         'links': 'list[common.v1.response.ApiLink]',
         'tenant_id': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
@@ -58,80 +58,90 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
-        """ExternalizableAbstractModel - a model defined in Swagger
-            \nA model that represents an object instance that is accessible through an API endpoint.  Instances of this type get an extId field that contains the globally unique identifier for that instance.  Externally accessible instances are always tenant aware and therefore extend the TenantAwareModel 
-        """
         TenantAwareModel.__init__(self, tenant_id, *args, **kwargs)
         self.__ext_id = None
         self.__links = None
         self.discriminator = None
         if ext_id is not None:
             self.__ext_id = ext_id
         if links is not None:
             self.__links = links
 
     def _initialize_object_type(self):
         return 'common.v1.response.ExternalizableAbstractModel'
 
-    def _initialize_fq_object_type(self):
-        return 'common.v1.r0.a3.response.ExternalizableAbstractModel'
+    def _initialize_object_version(self):
+        return 'v1.r0.b1'
 
 
     @property
     def ext_id(self):
-        """`{ str }`
-            \nA globally unique identifier of an instance that is suitable for external consumption. 
-        """ # noqa: E501
+        """
+        A globally unique identifier of an instance that is suitable for external consumption. 
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__ext_id
 
     @ext_id.setter
     def ext_id(self, ext_id):
         if ext_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', ext_id):  # noqa: E501
             raise ValueError(r"Invalid value for `ext_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
 
         self.__ext_id = ext_id
 
     @property
     def links(self):
-        """`{ list[common.v1.response.ApiLink] }`
-            \nA HATEOAS style link for the response.  Each link contains a user friendly name identifying the link and an address for retrieving the particular resource. 
-        """ # noqa: E501
+        """
+        A HATEOAS style link for the response.  Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource. 
+
+        :type:
+             list[ :class:`~ntnx_iam_py_client.models.common.v1.response.ApiLink` ]
+        """  # noqa: E501
         return self.__links
 
     @links.setter
     def links(self, links):
 
         self.__links = links
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
@@ -139,15 +149,15 @@
         if issubclass(ExternalizableAbstractModel, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/ActivateUserApiResponse.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/GetEntityApiResponse.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,54 +1,54 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_iam_py_client.Ntnx
-from ntnx_iam_py_client.Ntnx.OneOfiam.v4.authn.ActivateUserApiResponsedata import ActivateUserApiResponsedata  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+from pathlib import Path
+import ntnx_iam_py_client.models
+from ntnx_iam_py_client.models.OneOfiam.v4.authz.GetEntityApiResponsedata import GetEntityApiResponsedata  # noqa: F401,E501
+from ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class GetEntityApiResponse(object):
+
+    """REST response for all response codes in API path /iam/v4.0.b1/authz/entities/{extId} Get operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
-
-Do not edit the class manually.
-IGNORE
-"""
-
-
-class ActivateUserApiResponse(object):
-    """ActivateUserApiResponse - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfiam.v4.authn.ActivateUserApiResponsedata',
+        'data': 'OneOfiam.v4.authz.GetEntityApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -57,49 +57,46 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        """ActivateUserApiResponse - a model defined in Swagger
-            \nREST response for all response codes in api path /iam/v4.0.a1/authn/users/{extId}/$actions/change-state Post operation
-        """
         self.__metadata = None
         self.__data = None
         self.discriminator = None
         if metadata is not None:
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'iam.v4.authn.ActivateUserApiResponse'
+        return 'iam.v4.authz.GetEntityApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authn.ActivateUserApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -107,111 +104,132 @@
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def metadata(self):
-        """`{ common.v1.response.ApiResponseMetadata }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            :class:`~ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata`
+        """  # noqa: E501
         return self.__metadata
 
     @metadata.setter
     def metadata(self, metadata):
 
         self.__metadata = metadata
 
     @property
     def data(self):
-        """`{ iam.v4.error.ErrorResponse }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+                :class:`~ntnx_iam_py_client.models.iam.v4.authz.Entity` | 
+                :class:`~ntnx_iam_py_client.models.iam.v4.error.ErrorResponse`
+                    """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
         self.__data = data
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_iam_py_client.Ntnx, attr_type.split('.')[-1])
-                if hasattr(type, 'get_discriminator_from_object'):
-                    result[type.ONE_OF_ITEM_DISCRIMINATOR_NAME] = type.get_discriminator_from_object(value)
+                type = getattr(ntnx_iam_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ActivateUserApiResponse, dict):
+        if issubclass(GetEntityApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ActivateUserApiResponse):
+        if not isinstance(other, GetEntityApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/CertAuthProvider.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/CertAuthProvider.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,56 +1,72 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_iam_py_client.Ntnx.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.iam.v4.authn.CertRevocationInfo import CertRevocationInfo  # noqa: F401,E501
+from pathlib import Path
+from ntnx_iam_py_client.models.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
+from ntnx_iam_py_client.models.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel  # noqa: F401,E501
+from ntnx_iam_py_client.models.iam.v4.authn.CertRevocationInfo import CertRevocationInfo  # noqa: F401,E501
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class CertAuthProvider(ExternalizableAbstractModel):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """A Certificate based Authentication provider.
 
+    :param name: (:attr:`name`) Unique name of the Certificate based Authentication provider.
+    :type name: 
+    :param client_ca_chain: (:attr:`client_ca_chain`) CA chain file.
+    :type client_ca_chain: 
+    :param is_cert_auth_enabled: (:attr:`is_cert_auth_enabled`) Flag to enable/disable CAC for the current Certificate based Authentication provider.
+    :type is_cert_auth_enabled: 
+    :param is_cac_enabled: (:attr:`is_cac_enabled`) Flag to enable/disable Certificate Authentication for the current certificate based authentication provider.
+    :type is_cac_enabled: 
+    :param dir_svc_ext_id: (:attr:`dir_svc_ext_id`) UUID of an existing Directory Service.
+    :type dir_svc_ext_id: 
+    :param ca_cert_file_name: (:attr:`ca_cert_file_name`) Name of the uploaded CA chain file.
+    :type ca_cert_file_name: 
+    :param cert_revocation_info: (:attr:`cert_revocation_info`) 
+    :type cert_revocation_info: 
+    :param created_time: (:attr:`created_time`) Creation time of the Certificate Authentication Provider.
+    :type created_time: 
+    :param last_updated_time: (:attr:`last_updated_time`) Last updated time of the Certificate Authentication Provider.
+    :type last_updated_time: 
+    :param created_by: (:attr:`created_by`) User or Service who created the Certificate Authentication Provider.
+    :type created_by: 
 
-class CertAuthProvider(ExternalizableAbstractModel):
-    """CertAuthProvider - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'name': 'str',
         'client_ca_chain': 'str',
-        'cert_auth_enabled': 'bool',
-        'cac_enabled': 'bool',
+        'is_cert_auth_enabled': 'bool',
+        'is_cac_enabled': 'bool',
         'dir_svc_ext_id': 'str',
         'ca_cert_file_name': 'str',
         'cert_revocation_info': 'iam.v4.authn.CertRevocationInfo',
         'created_time': 'datetime',
         'last_updated_time': 'datetime',
         'created_by': 'str',
         'ext_id': 'str',
@@ -60,16 +76,16 @@
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'name': 'name',
         'client_ca_chain': 'clientCaChain',
-        'cert_auth_enabled': 'certAuthEnabled',
-        'cac_enabled': 'cacEnabled',
+        'is_cert_auth_enabled': 'isCertAuthEnabled',
+        'is_cac_enabled': 'isCacEnabled',
         'dir_svc_ext_id': 'dirSvcExtID',
         'ca_cert_file_name': 'caCertFileName',
         'cert_revocation_info': 'certRevocationInfo',
         'created_time': 'createdTime',
         'last_updated_time': 'lastUpdatedTime',
         'created_by': 'createdBy',
         'ext_id': 'extId',
@@ -78,216 +94,255 @@
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, name=None, client_ca_chain=None, cert_auth_enabled=None, cac_enabled=None, dir_svc_ext_id=None, ca_cert_file_name=None, cert_revocation_info=None, created_time=None, last_updated_time=None, created_by=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
-        """CertAuthProvider - a model defined in Swagger
-            \nA certificate based authentication provider
-        """
+    def __init__(self, name=None, client_ca_chain=None, is_cert_auth_enabled=None, is_cac_enabled=None, dir_svc_ext_id=None, ca_cert_file_name=None, cert_revocation_info=None, created_time=None, last_updated_time=None, created_by=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
         ExternalizableAbstractModel.__init__(self, ext_id, links, tenant_id, *args, **kwargs)
         self.__name = None
         self.__client_ca_chain = None
-        self.__cert_auth_enabled = None
-        self.__cac_enabled = None
+        self.__is_cert_auth_enabled = None
+        self.__is_cac_enabled = None
         self.__dir_svc_ext_id = None
         self.__ca_cert_file_name = None
         self.__cert_revocation_info = None
         self.__created_time = None
         self.__last_updated_time = None
         self.__created_by = None
         self.discriminator = None
-        self.__name = name
-        self.__client_ca_chain = client_ca_chain
-        self.__cert_auth_enabled = cert_auth_enabled
-        self.__cac_enabled = cac_enabled
+        if name is not None:
+            self.__name = name
+        if client_ca_chain is not None:
+            self.__client_ca_chain = client_ca_chain
+        if is_cert_auth_enabled is not None:
+            self.__is_cert_auth_enabled = is_cert_auth_enabled
+        if is_cac_enabled is not None:
+            self.__is_cac_enabled = is_cac_enabled
         if dir_svc_ext_id is not None:
             self.__dir_svc_ext_id = dir_svc_ext_id
-        self.__ca_cert_file_name = ca_cert_file_name
+        if ca_cert_file_name is not None:
+            self.__ca_cert_file_name = ca_cert_file_name
         if cert_revocation_info is not None:
             self.__cert_revocation_info = cert_revocation_info
         if created_time is not None:
             self.__created_time = created_time
         if last_updated_time is not None:
             self.__last_updated_time = last_updated_time
         if created_by is not None:
             self.__created_by = created_by
 
     def _initialize_object_type(self):
         return 'iam.v4.authn.CertAuthProvider'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authn.CertAuthProvider'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     @property
     def name(self):
-        """`{ str }`
-            \nUnique name of the certificate based authentication provider.
-        """ # noqa: E501
+        """
+        Unique name of the Certificate based Authentication provider.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__name
 
     @name.setter
     def name(self, name):
-        if name is None:
-            raise ValueError("Invalid value for `name`, must not be `None`")  # noqa: E501
         if name is not None and len(name) > 255:
             raise ValueError("Invalid value for `name`, length must be less than or equal to `255`")  # noqa: E501
         if name is not None and len(name) < 1:
             raise ValueError("Invalid value for `name`, length must be greater than or equal to `1`")  # noqa: E501
+        if name is not None and not re.search('^[^<>;\'()&+%\/\\\\\"`]*$', name):  # noqa: E501
+            raise ValueError(r"Invalid value for `name`, must be a follow pattern or equal to `/^[^<>;'()&+%\/\\\\\"`]*$/`")  # noqa: E501
 
         self.__name = name
 
     @property
     def client_ca_chain(self):
-        """`{ str }`
-            \nCA chain file
-        """ # noqa: E501
+        """
+        CA chain file.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__client_ca_chain
 
     @client_ca_chain.setter
     def client_ca_chain(self, client_ca_chain):
-        if client_ca_chain is None:
-            raise ValueError("Invalid value for `client_ca_chain`, must not be `None`")  # noqa: E501
         if client_ca_chain is not None and len(client_ca_chain) < 64:
             raise ValueError("Invalid value for `client_ca_chain`, length must be greater than or equal to `64`")  # noqa: E501
 
         self.__client_ca_chain = client_ca_chain
 
     @property
-    def cert_auth_enabled(self):
-        """`{ bool }`
-            \nFlag to enable/disable CAC for the current certificate based authentication provider.
-        """ # noqa: E501
-        return self.__cert_auth_enabled
-
-    @cert_auth_enabled.setter
-    def cert_auth_enabled(self, cert_auth_enabled):
-        if cert_auth_enabled is None:
-            raise ValueError("Invalid value for `cert_auth_enabled`, must not be `None`")  # noqa: E501
+    def is_cert_auth_enabled(self):
+        """
+        Flag to enable/disable CAC for the current Certificate based Authentication provider.
 
-        self.__cert_auth_enabled = cert_auth_enabled
+        :type:
+
+                :class:`~bool`
+        """  # noqa: E501
+        return self.__is_cert_auth_enabled
+
+    @is_cert_auth_enabled.setter
+    def is_cert_auth_enabled(self, is_cert_auth_enabled):
+
+        self.__is_cert_auth_enabled = is_cert_auth_enabled
 
     @property
-    def cac_enabled(self):
-        """`{ bool }`
-            \nFlag to enable/disable Cert Auth for the current certificate based authentication provider.
-        """ # noqa: E501
-        return self.__cac_enabled
-
-    @cac_enabled.setter
-    def cac_enabled(self, cac_enabled):
-        if cac_enabled is None:
-            raise ValueError("Invalid value for `cac_enabled`, must not be `None`")  # noqa: E501
+    def is_cac_enabled(self):
+        """
+        Flag to enable/disable Certificate Authentication for the current certificate based authentication provider.
+
+        :type:
 
-        self.__cac_enabled = cac_enabled
+                :class:`~bool`
+        """  # noqa: E501
+        return self.__is_cac_enabled
+
+    @is_cac_enabled.setter
+    def is_cac_enabled(self, is_cac_enabled):
+
+        self.__is_cac_enabled = is_cac_enabled
 
     @property
     def dir_svc_ext_id(self):
-        """`{ str }`
-            \nUUID of an existing directory service
-        """ # noqa: E501
+        """
+        UUID of an existing Directory Service.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dir_svc_ext_id
 
     @dir_svc_ext_id.setter
     def dir_svc_ext_id(self, dir_svc_ext_id):
         if dir_svc_ext_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', dir_svc_ext_id):  # noqa: E501
             raise ValueError(r"Invalid value for `dir_svc_ext_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
 
         self.__dir_svc_ext_id = dir_svc_ext_id
 
     @property
     def ca_cert_file_name(self):
-        """`{ str }`
-            \nName of the uploaded CA chain file
-        """ # noqa: E501
+        """
+        Name of the uploaded CA chain file.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__ca_cert_file_name
 
     @ca_cert_file_name.setter
     def ca_cert_file_name(self, ca_cert_file_name):
-        if ca_cert_file_name is None:
-            raise ValueError("Invalid value for `ca_cert_file_name`, must not be `None`")  # noqa: E501
         if ca_cert_file_name is not None and len(ca_cert_file_name) > 255:
             raise ValueError("Invalid value for `ca_cert_file_name`, length must be less than or equal to `255`")  # noqa: E501
         if ca_cert_file_name is not None and len(ca_cert_file_name) < 1:
             raise ValueError("Invalid value for `ca_cert_file_name`, length must be greater than or equal to `1`")  # noqa: E501
 
         self.__ca_cert_file_name = ca_cert_file_name
 
     @property
     def cert_revocation_info(self):
-        """`{ iam.v4.authn.CertRevocationInfo }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            :class:`~ntnx_iam_py_client.models.iam.v4.authn.CertRevocationInfo`
+        """  # noqa: E501
         return self.__cert_revocation_info
 
     @cert_revocation_info.setter
     def cert_revocation_info(self, cert_revocation_info):
 
         self.__cert_revocation_info = cert_revocation_info
 
     @property
     def created_time(self):
-        """`{ datetime }`
-            \nCreation time of the certificate based authentication provider
-        """ # noqa: E501
+        """
+        Creation time of the Certificate Authentication Provider.
+
+        :type:
+
+                :class:`~datetime`
+        """  # noqa: E501
         return self.__created_time
 
     @created_time.setter
     def created_time(self, created_time):
 
         self.__created_time = created_time
 
     @property
     def last_updated_time(self):
-        """`{ datetime }`
-            \nLast updated time of the certificate based authentication provider
-        """ # noqa: E501
+        """
+        Last updated time of the Certificate Authentication Provider.
+
+        :type:
+
+                :class:`~datetime`
+        """  # noqa: E501
         return self.__last_updated_time
 
     @last_updated_time.setter
     def last_updated_time(self, last_updated_time):
 
         self.__last_updated_time = last_updated_time
 
     @property
     def created_by(self):
-        """`{ str }`
-            \nUser or service who created the CertAuthProvider
-        """ # noqa: E501
+        """
+        User or Service who created the Certificate Authentication Provider.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__created_by
 
     @created_by.setter
     def created_by(self, created_by):
 
         self.__created_by = created_by
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
@@ -295,15 +350,15 @@
         if issubclass(CertAuthProvider, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/CertRevocationInfo.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/DeleteApiKeyApiResponse.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,263 +1,234 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
+import ntnx_iam_py_client.models
+from ntnx_iam_py_client.models.OneOfiam.v4.authn.DeleteApiKeyApiResponsedata import DeleteApiKeyApiResponsedata  # noqa: F401,E501
+from ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class DeleteApiKeyApiResponse(object):
+
+    """REST response for all response codes in API path /iam/v4.0.b1/authn/service-accounts/{svcAccExtId}/api-keys/{extId} Delete operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
-
-Do not edit the class manually.
-IGNORE
-"""
-
-
-class CertRevocationInfo(object):
-    """CertRevocationInfo - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
-        'ocsp_enabled': 'bool',
-        'ocsp_responder': 'str',
-        'crl_enabled': 'bool',
-        'crl_dps': 'list[str]',
-        'global_crl_refresh_interval': 'int',
+        'metadata': 'common.v1.response.ApiResponseMetadata',
+        'data': 'OneOfiam.v4.authn.DeleteApiKeyApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'ocsp_enabled': 'ocspEnabled',
-        'ocsp_responder': 'ocspResponder',
-        'crl_enabled': 'crlEnabled',
-        'crl_dps': 'crlDps',
-        'global_crl_refresh_interval': 'globalCrlRefreshInterval',
+        'metadata': 'metadata',
+        'data': 'data',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, ocsp_enabled=None, ocsp_responder=None, crl_enabled=None, crl_dps=None, global_crl_refresh_interval=None, *args, **kwargs):  # noqa: E501
-        """CertRevocationInfo - a model defined in Swagger
-            \nConfiguration details used for determining if the client certificate is revoked.
-        """
-        self.__ocsp_enabled = None
-        self.__ocsp_responder = None
-        self.__crl_enabled = None
-        self.__crl_dps = None
-        self.__global_crl_refresh_interval = None
+    def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
+        self.__metadata = None
+        self.__data = None
         self.discriminator = None
-        if ocsp_enabled is not None:
-            self.__ocsp_enabled = ocsp_enabled
-        if ocsp_responder is not None:
-            self.__ocsp_responder = ocsp_responder
-        if crl_enabled is not None:
-            self.__crl_enabled = crl_enabled
-        if crl_dps is not None:
-            self.__crl_dps = crl_dps
-        if global_crl_refresh_interval is not None:
-            self.__global_crl_refresh_interval = global_crl_refresh_interval
+        if metadata is not None:
+            self.__metadata = metadata
+        if data is not None:
+            self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'iam.v4.authn.CertRevocationInfo'
+        return 'iam.v4.authn.DeleteApiKeyApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authn.CertRevocationInfo'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def ocsp_enabled(self):
-        """`{ bool }`
-            \nFlag to enable/disable OCSP revocation check
-        """ # noqa: E501
-        return self.__ocsp_enabled
-
-    @ocsp_enabled.setter
-    def ocsp_enabled(self, ocsp_enabled):
-
-        self.__ocsp_enabled = ocsp_enabled
-
-    @property
-    def ocsp_responder(self):
-        """`{ str }`
-            \nURL of the OCSP responder used to override the URL from AIA extension
-        """ # noqa: E501
-        return self.__ocsp_responder
-
-    @ocsp_responder.setter
-    def ocsp_responder(self, ocsp_responder):
-        if ocsp_responder is not None and not re.search('^((http[s]?):\/)?\/?([^:\/\\s]*)((\/\\w+)*(:[0-9]+)*?\/)([\\w\\-\\.]+[^#?\\s]+)(.*)?(#[\\w\\-]+)?$', ocsp_responder):  # noqa: E501
-            raise ValueError(r"Invalid value for `ocsp_responder`, must be a follow pattern or equal to `/^((http[s]?):\/)?\/?([^:\/\\s]*)((\/\\w+)*(:[0-9]+)*?\/)([\\w\\-\\.]+[^#?\\s]+)(.*)?(#[\\w\\-]+)?$/`")  # noqa: E501
-
-        self.__ocsp_responder = ocsp_responder
+    def metadata(self):
+        """
+        
 
-    @property
-    def crl_enabled(self):
-        """`{ bool }`
-            \nFlag to enable/disable CRL revocation check
-        """ # noqa: E501
-        return self.__crl_enabled
+        :type:
+            :class:`~ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata`
+        """  # noqa: E501
+        return self.__metadata
 
-    @crl_enabled.setter
-    def crl_enabled(self, crl_enabled):
+    @metadata.setter
+    def metadata(self, metadata):
 
-        self.__crl_enabled = crl_enabled
+        self.__metadata = metadata
 
     @property
-    def crl_dps(self):
-        """`{ list[str] }`
-            \nList of the CRL distribution points which will be used to fetch the CRLs
-        """ # noqa: E501
-        return self.__crl_dps
-
-    @crl_dps.setter
-    def crl_dps(self, crl_dps):
-
-        self.__crl_dps = crl_dps
+    def data(self):
+        """
+        
 
-    @property
-    def global_crl_refresh_interval(self):
-        """`{ int }`
-            \nInterval in seconds at which the CRL should be fetched from the CRLDP, default = 86400 seconds(1 day)
-        """ # noqa: E501
-        return self.__global_crl_refresh_interval
+        :type:
+                :class:`~ntnx_iam_py_client.models.iam.v4.error.ErrorResponse`
+                    """  # noqa: E501
+        return self.__data
 
-    @global_crl_refresh_interval.setter
-    def global_crl_refresh_interval(self, global_crl_refresh_interval):
+    @data.setter
+    def data(self, data):
 
-        self.__global_crl_refresh_interval = global_crl_refresh_interval
+        self.__data = data
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
+            if attr_type.startswith('OneOf'):
+                type = getattr(ntnx_iam_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(CertRevocationInfo, dict):
+        if issubclass(DeleteApiKeyApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, CertRevocationInfo):
+        if not isinstance(other, DeleteApiKeyApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/ChangeUserPasswordApiResponse.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/DeleteCertAuthProviderApiResponse.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,54 +1,54 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_iam_py_client.Ntnx
-from ntnx_iam_py_client.Ntnx.OneOfiam.v4.authn.ChangeUserPasswordApiResponsedata import ChangeUserPasswordApiResponsedata  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+from pathlib import Path
+import ntnx_iam_py_client.models
+from ntnx_iam_py_client.models.OneOfiam.v4.authn.DeleteCertAuthProviderApiResponsedata import DeleteCertAuthProviderApiResponsedata  # noqa: F401,E501
+from ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class DeleteCertAuthProviderApiResponse(object):
+
+    """REST response for all response codes in API path /iam/v4.0.b1/authn/cert-auth-providers/{extId} Delete operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
-
-Do not edit the class manually.
-IGNORE
-"""
-
-
-class ChangeUserPasswordApiResponse(object):
-    """ChangeUserPasswordApiResponse - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfiam.v4.authn.ChangeUserPasswordApiResponsedata',
+        'data': 'OneOfiam.v4.authn.DeleteCertAuthProviderApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -57,49 +57,46 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        """ChangeUserPasswordApiResponse - a model defined in Swagger
-            \nREST response for all response codes in api path /iam/v4.0.a1/authn/users/$actions/change-password Post operation
-        """
         self.__metadata = None
         self.__data = None
         self.discriminator = None
         if metadata is not None:
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'iam.v4.authn.ChangeUserPasswordApiResponse'
+        return 'iam.v4.authn.DeleteCertAuthProviderApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authn.ChangeUserPasswordApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -107,111 +104,131 @@
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def metadata(self):
-        """`{ common.v1.response.ApiResponseMetadata }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            :class:`~ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata`
+        """  # noqa: E501
         return self.__metadata
 
     @metadata.setter
     def metadata(self, metadata):
 
         self.__metadata = metadata
 
     @property
     def data(self):
-        """`{ iam.v4.error.ErrorResponse }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+                :class:`~ntnx_iam_py_client.models.iam.v4.error.ErrorResponse`
+                    """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
         self.__data = data
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_iam_py_client.Ntnx, attr_type.split('.')[-1])
-                if hasattr(type, 'get_discriminator_from_object'):
-                    result[type.ONE_OF_ITEM_DISCRIMINATOR_NAME] = type.get_discriminator_from_object(value)
+                type = getattr(ntnx_iam_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ChangeUserPasswordApiResponse, dict):
+        if issubclass(DeleteCertAuthProviderApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ChangeUserPasswordApiResponse):
+        if not isinstance(other, DeleteCertAuthProviderApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/ConnectionDirectoryServiceApiResponse.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/ListDirectoryServicesApiResponse.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,54 +1,54 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_iam_py_client.Ntnx
-from ntnx_iam_py_client.Ntnx.OneOfiam.v4.authn.ConnectionDirectoryServiceApiResponsedata import ConnectionDirectoryServiceApiResponsedata  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+from pathlib import Path
+import ntnx_iam_py_client.models
+from ntnx_iam_py_client.models.OneOfiam.v4.authn.ListDirectoryServicesApiResponsedata import ListDirectoryServicesApiResponsedata  # noqa: F401,E501
+from ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class ListDirectoryServicesApiResponse(object):
+
+    """REST response for all response codes in API path /iam/v4.0.b1/authn/directory-services Get operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
-
-Do not edit the class manually.
-IGNORE
-"""
-
-
-class ConnectionDirectoryServiceApiResponse(object):
-    """ConnectionDirectoryServiceApiResponse - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfiam.v4.authn.ConnectionDirectoryServiceApiResponsedata',
+        'data': 'OneOfiam.v4.authn.ListDirectoryServicesApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -57,49 +57,46 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        """ConnectionDirectoryServiceApiResponse - a model defined in Swagger
-            \nREST response for all response codes in api path /iam/v4.0.a1/authn/directory-services/{extId}/connection-status Post operation
-        """
         self.__metadata = None
         self.__data = None
         self.discriminator = None
         if metadata is not None:
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'iam.v4.authn.ConnectionDirectoryServiceApiResponse'
+        return 'iam.v4.authn.ListDirectoryServicesApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authn.ConnectionDirectoryServiceApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -107,111 +104,132 @@
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def metadata(self):
-        """`{ common.v1.response.ApiResponseMetadata }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            :class:`~ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata`
+        """  # noqa: E501
         return self.__metadata
 
     @metadata.setter
     def metadata(self, metadata):
 
         self.__metadata = metadata
 
     @property
     def data(self):
-        """`{ iam.v4.error.ErrorResponse }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+                :class:`~ntnx_iam_py_client.models.iam.v4.authn.DirectoryService` | 
+                :class:`~ntnx_iam_py_client.models.iam.v4.error.ErrorResponse`
+                    """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
         self.__data = data
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_iam_py_client.Ntnx, attr_type.split('.')[-1])
-                if hasattr(type, 'get_discriminator_from_object'):
-                    result[type.ONE_OF_ITEM_DISCRIMINATOR_NAME] = type.get_discriminator_from_object(value)
+                type = getattr(ntnx_iam_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ConnectionDirectoryServiceApiResponse, dict):
+        if issubclass(ListDirectoryServicesApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ConnectionDirectoryServiceApiResponse):
+        if not isinstance(other, ListDirectoryServicesApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/CreateCertAuthProviderApiResponse.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/UpdateCertAuthProviderApiResponse.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,54 +1,54 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_iam_py_client.Ntnx
-from ntnx_iam_py_client.Ntnx.OneOfiam.v4.authn.CreateCertAuthProviderApiResponsedata import CreateCertAuthProviderApiResponsedata  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+from pathlib import Path
+import ntnx_iam_py_client.models
+from ntnx_iam_py_client.models.OneOfiam.v4.authn.UpdateCertAuthProviderApiResponsedata import UpdateCertAuthProviderApiResponsedata  # noqa: F401,E501
+from ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class UpdateCertAuthProviderApiResponse(object):
+
+    """REST response for all response codes in API path /iam/v4.0.b1/authn/cert-auth-providers/{extId} Put operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
-
-Do not edit the class manually.
-IGNORE
-"""
-
-
-class CreateCertAuthProviderApiResponse(object):
-    """CreateCertAuthProviderApiResponse - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfiam.v4.authn.CreateCertAuthProviderApiResponsedata',
+        'data': 'OneOfiam.v4.authn.UpdateCertAuthProviderApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -57,49 +57,46 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        """CreateCertAuthProviderApiResponse - a model defined in Swagger
-            \nREST response for all response codes in api path /iam/v4.0.a1/authn/cert-auth-providers Post operation
-        """
         self.__metadata = None
         self.__data = None
         self.discriminator = None
         if metadata is not None:
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'iam.v4.authn.CreateCertAuthProviderApiResponse'
+        return 'iam.v4.authn.UpdateCertAuthProviderApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authn.CreateCertAuthProviderApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -107,111 +104,132 @@
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def metadata(self):
-        """`{ common.v1.response.ApiResponseMetadata }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            :class:`~ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata`
+        """  # noqa: E501
         return self.__metadata
 
     @metadata.setter
     def metadata(self, metadata):
 
         self.__metadata = metadata
 
     @property
     def data(self):
-        """`{ iam.v4.authn.CertAuthProvider | iam.v4.error.ErrorResponse }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+                :class:`~ntnx_iam_py_client.models.iam.v4.authn.CertAuthProvider` | 
+                :class:`~ntnx_iam_py_client.models.iam.v4.error.ErrorResponse`
+                    """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
         self.__data = data
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_iam_py_client.Ntnx, attr_type.split('.')[-1])
-                if hasattr(type, 'get_discriminator_from_object'):
-                    result[type.ONE_OF_ITEM_DISCRIMINATOR_NAME] = type.get_discriminator_from_object(value)
+                type = getattr(ntnx_iam_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(CreateCertAuthProviderApiResponse, dict):
+        if issubclass(UpdateCertAuthProviderApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, CreateCertAuthProviderApiResponse):
+        if not isinstance(other, UpdateCertAuthProviderApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/CreateDirectoryServiceApiResponse.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/UpdateDirectoryServiceApiResponse.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,54 +1,54 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_iam_py_client.Ntnx
-from ntnx_iam_py_client.Ntnx.OneOfiam.v4.authn.CreateDirectoryServiceApiResponsedata import CreateDirectoryServiceApiResponsedata  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+from pathlib import Path
+import ntnx_iam_py_client.models
+from ntnx_iam_py_client.models.OneOfiam.v4.authn.UpdateDirectoryServiceApiResponsedata import UpdateDirectoryServiceApiResponsedata  # noqa: F401,E501
+from ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class UpdateDirectoryServiceApiResponse(object):
+
+    """REST response for all response codes in API path /iam/v4.0.b1/authn/directory-services/{extId} Put operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
-
-Do not edit the class manually.
-IGNORE
-"""
-
-
-class CreateDirectoryServiceApiResponse(object):
-    """CreateDirectoryServiceApiResponse - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfiam.v4.authn.CreateDirectoryServiceApiResponsedata',
+        'data': 'OneOfiam.v4.authn.UpdateDirectoryServiceApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -57,49 +57,46 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        """CreateDirectoryServiceApiResponse - a model defined in Swagger
-            \nREST response for all response codes in api path /iam/v4.0.a1/authn/directory-services Post operation
-        """
         self.__metadata = None
         self.__data = None
         self.discriminator = None
         if metadata is not None:
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'iam.v4.authn.CreateDirectoryServiceApiResponse'
+        return 'iam.v4.authn.UpdateDirectoryServiceApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authn.CreateDirectoryServiceApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -107,111 +104,132 @@
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def metadata(self):
-        """`{ common.v1.response.ApiResponseMetadata }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            :class:`~ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata`
+        """  # noqa: E501
         return self.__metadata
 
     @metadata.setter
     def metadata(self, metadata):
 
         self.__metadata = metadata
 
     @property
     def data(self):
-        """`{ iam.v4.authn.DirectoryService | iam.v4.error.ErrorResponse }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+                :class:`~ntnx_iam_py_client.models.iam.v4.authn.DirectoryService` | 
+                :class:`~ntnx_iam_py_client.models.iam.v4.error.ErrorResponse`
+                    """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
         self.__data = data
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_iam_py_client.Ntnx, attr_type.split('.')[-1])
-                if hasattr(type, 'get_discriminator_from_object'):
-                    result[type.ONE_OF_ITEM_DISCRIMINATOR_NAME] = type.get_discriminator_from_object(value)
+                type = getattr(ntnx_iam_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(CreateDirectoryServiceApiResponse, dict):
+        if issubclass(UpdateDirectoryServiceApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, CreateDirectoryServiceApiResponse):
+        if not isinstance(other, UpdateDirectoryServiceApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/CreateSamlIdentityProviderApiResponse.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/ListRolesApiResponse.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,54 +1,54 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_iam_py_client.Ntnx
-from ntnx_iam_py_client.Ntnx.OneOfiam.v4.authn.CreateSamlIdentityProviderApiResponsedata import CreateSamlIdentityProviderApiResponsedata  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+from pathlib import Path
+import ntnx_iam_py_client.models
+from ntnx_iam_py_client.models.OneOfiam.v4.authz.ListRolesApiResponsedata import ListRolesApiResponsedata  # noqa: F401,E501
+from ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class ListRolesApiResponse(object):
+
+    """REST response for all response codes in API path /iam/v4.0.b1/authz/roles Get operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
-
-Do not edit the class manually.
-IGNORE
-"""
-
-
-class CreateSamlIdentityProviderApiResponse(object):
-    """CreateSamlIdentityProviderApiResponse - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfiam.v4.authn.CreateSamlIdentityProviderApiResponsedata',
+        'data': 'OneOfiam.v4.authz.ListRolesApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -57,49 +57,46 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        """CreateSamlIdentityProviderApiResponse - a model defined in Swagger
-            \nREST response for all response codes in api path /iam/v4.0.a1/authn/saml-identity-providers Post operation
-        """
         self.__metadata = None
         self.__data = None
         self.discriminator = None
         if metadata is not None:
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'iam.v4.authn.CreateSamlIdentityProviderApiResponse'
+        return 'iam.v4.authz.ListRolesApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authn.CreateSamlIdentityProviderApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -107,111 +104,133 @@
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def metadata(self):
-        """`{ common.v1.response.ApiResponseMetadata }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            :class:`~ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata`
+        """  # noqa: E501
         return self.__metadata
 
     @metadata.setter
     def metadata(self, metadata):
 
         self.__metadata = metadata
 
     @property
     def data(self):
-        """`{ iam.v4.authn.SamlIdentityProvider | iam.v4.error.ErrorResponse }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+                :class:`~ntnx_iam_py_client.models.iam.v4.authz.Role` | 
+                :class:`~ntnx_iam_py_client.models.iam.v4.error.ErrorResponse` | 
+                :class:`~ntnx_iam_py_client.models.iam.v4.authz.RoleProjection`
+                    """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
         self.__data = data
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_iam_py_client.Ntnx, attr_type.split('.')[-1])
-                if hasattr(type, 'get_discriminator_from_object'):
-                    result[type.ONE_OF_ITEM_DISCRIMINATOR_NAME] = type.get_discriminator_from_object(value)
+                type = getattr(ntnx_iam_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(CreateSamlIdentityProviderApiResponse, dict):
+        if issubclass(ListRolesApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, CreateSamlIdentityProviderApiResponse):
+        if not isinstance(other, ListRolesApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/CreateUserApiResponse.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/CreateAuthorizationPolicyApiResponse.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,54 +1,54 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_iam_py_client.Ntnx
-from ntnx_iam_py_client.Ntnx.OneOfiam.v4.authn.CreateUserApiResponsedata import CreateUserApiResponsedata  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+from pathlib import Path
+import ntnx_iam_py_client.models
+from ntnx_iam_py_client.models.OneOfiam.v4.authz.CreateAuthorizationPolicyApiResponsedata import CreateAuthorizationPolicyApiResponsedata  # noqa: F401,E501
+from ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class CreateAuthorizationPolicyApiResponse(object):
+
+    """REST response for all response codes in API path /iam/v4.0.b1/authz/authorization-policies Post operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
-
-Do not edit the class manually.
-IGNORE
-"""
-
-
-class CreateUserApiResponse(object):
-    """CreateUserApiResponse - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfiam.v4.authn.CreateUserApiResponsedata',
+        'data': 'OneOfiam.v4.authz.CreateAuthorizationPolicyApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -57,49 +57,46 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        """CreateUserApiResponse - a model defined in Swagger
-            \nREST response for all response codes in api path /iam/v4.0.a1/authn/users Post operation
-        """
         self.__metadata = None
         self.__data = None
         self.discriminator = None
         if metadata is not None:
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'iam.v4.authn.CreateUserApiResponse'
+        return 'iam.v4.authz.CreateAuthorizationPolicyApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authn.CreateUserApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -107,111 +104,132 @@
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def metadata(self):
-        """`{ common.v1.response.ApiResponseMetadata }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            :class:`~ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata`
+        """  # noqa: E501
         return self.__metadata
 
     @metadata.setter
     def metadata(self, metadata):
 
         self.__metadata = metadata
 
     @property
     def data(self):
-        """`{ iam.v4.authn.User | iam.v4.error.ErrorResponse }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+                :class:`~ntnx_iam_py_client.models.iam.v4.authz.AuthorizationPolicy` | 
+                :class:`~ntnx_iam_py_client.models.iam.v4.error.ErrorResponse`
+                    """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
         self.__data = data
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_iam_py_client.Ntnx, attr_type.split('.')[-1])
-                if hasattr(type, 'get_discriminator_from_object'):
-                    result[type.ONE_OF_ITEM_DISCRIMINATOR_NAME] = type.get_discriminator_from_object(value)
+                type = getattr(ntnx_iam_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(CreateUserApiResponse, dict):
+        if issubclass(CreateAuthorizationPolicyApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, CreateUserApiResponse):
+        if not isinstance(other, CreateAuthorizationPolicyApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/CreateUserGroupApiResponse.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/UpdateAuthorizationPolicyApiResponse.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,54 +1,54 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_iam_py_client.Ntnx
-from ntnx_iam_py_client.Ntnx.OneOfiam.v4.authn.CreateUserGroupApiResponsedata import CreateUserGroupApiResponsedata  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+from pathlib import Path
+import ntnx_iam_py_client.models
+from ntnx_iam_py_client.models.OneOfiam.v4.authz.UpdateAuthorizationPolicyApiResponsedata import UpdateAuthorizationPolicyApiResponsedata  # noqa: F401,E501
+from ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class UpdateAuthorizationPolicyApiResponse(object):
+
+    """REST response for all response codes in API path /iam/v4.0.b1/authz/authorization-policies/{extId} Put operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
-
-Do not edit the class manually.
-IGNORE
-"""
-
-
-class CreateUserGroupApiResponse(object):
-    """CreateUserGroupApiResponse - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfiam.v4.authn.CreateUserGroupApiResponsedata',
+        'data': 'OneOfiam.v4.authz.UpdateAuthorizationPolicyApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -57,49 +57,46 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        """CreateUserGroupApiResponse - a model defined in Swagger
-            \nREST response for all response codes in api path /iam/v4.0.a1/authn/user-groups Post operation
-        """
         self.__metadata = None
         self.__data = None
         self.discriminator = None
         if metadata is not None:
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'iam.v4.authn.CreateUserGroupApiResponse'
+        return 'iam.v4.authz.UpdateAuthorizationPolicyApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authn.CreateUserGroupApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -107,111 +104,132 @@
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def metadata(self):
-        """`{ common.v1.response.ApiResponseMetadata }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            :class:`~ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata`
+        """  # noqa: E501
         return self.__metadata
 
     @metadata.setter
     def metadata(self, metadata):
 
         self.__metadata = metadata
 
     @property
     def data(self):
-        """`{ iam.v4.authn.UserGroup | iam.v4.error.ErrorResponse }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+                :class:`~ntnx_iam_py_client.models.common.v1.config.Message` | 
+                :class:`~ntnx_iam_py_client.models.iam.v4.error.ErrorResponse`
+                    """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
         self.__data = data
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_iam_py_client.Ntnx, attr_type.split('.')[-1])
-                if hasattr(type, 'get_discriminator_from_object'):
-                    result[type.ONE_OF_ITEM_DISCRIMINATOR_NAME] = type.get_discriminator_from_object(value)
+                type = getattr(ntnx_iam_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(CreateUserGroupApiResponse, dict):
+        if issubclass(UpdateAuthorizationPolicyApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, CreateUserGroupApiResponse):
+        if not isinstance(other, UpdateAuthorizationPolicyApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/DirectoryService.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/DirectoryService.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,57 +1,78 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_iam_py_client.Ntnx.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.iam.v4.authn.DirectoryType import DirectoryType  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.iam.v4.authn.DsServiceAccount import DsServiceAccount  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.iam.v4.authn.GroupSearchType import GroupSearchType  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.iam.v4.authn.OpenLdapConfig import OpenLdapConfig  # noqa: F401,E501
+from pathlib import Path
+from ntnx_iam_py_client.models.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
+from ntnx_iam_py_client.models.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel  # noqa: F401,E501
+from ntnx_iam_py_client.models.iam.v4.authn.DirectoryType import DirectoryType  # noqa: F401,E501
+from ntnx_iam_py_client.models.iam.v4.authn.DsServiceAccount import DsServiceAccount  # noqa: F401,E501
+from ntnx_iam_py_client.models.iam.v4.authn.GroupSearchType import GroupSearchType  # noqa: F401,E501
+from ntnx_iam_py_client.models.iam.v4.authn.OpenLdapConfig import OpenLdapConfig  # noqa: F401,E501
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class DirectoryService(ExternalizableAbstractModel):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """Information of a Directory Service.
 
+    :param name: (:attr:`name`) Name for the Directory Service.
+    :type name: 
+    :param url: (:attr:`url`) URL for the Directory Service.
+    :type url: 
+    :param secondary_urls: (:attr:`secondary_urls`) Secondary URL for the Directory Service.
+    :type secondary_urls: 
+    :param domain_name: (:attr:`domain_name`) Domain name for the Directory Service.
+    :type domain_name: 
+    :param directory_type: (:attr:`directory_type`) 
+    :type directory_type: 
+    :param service_account: (:attr:`service_account`) 
+    :type service_account: 
+    :param open_ldap_configuration: (:attr:`open_ldap_configuration`) 
+    :type open_ldap_configuration: 
+    :param group_search_type: (:attr:`group_search_type`) 
+    :type group_search_type: 
+    :param white_listed_groups: (:attr:`white_listed_groups`) List of allowed User Groups for the Directory Service.
+    :type white_listed_groups: 
+    :param created_time: (:attr:`created_time`) Creation time of the Directory Service.
+    :type created_time: 
+    :param last_updated_time: (:attr:`last_updated_time`) Last updated time of the Directory Service.
+    :type last_updated_time: 
+    :param created_by: (:attr:`created_by`) User or Service who created the Directory Service.
+    :type created_by: 
 
-class DirectoryService(ExternalizableAbstractModel):
-    """DirectoryService - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'name': 'str',
         'url': 'str',
+        'secondary_urls': 'list[str]',
         'domain_name': 'str',
         'directory_type': 'iam.v4.authn.DirectoryType',
         'service_account': 'iam.v4.authn.DsServiceAccount',
         'open_ldap_configuration': 'iam.v4.authn.OpenLdapConfig',
         'group_search_type': 'iam.v4.authn.GroupSearchType',
         'white_listed_groups': 'list[str]',
         'created_time': 'datetime',
@@ -64,14 +85,15 @@
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'name': 'name',
         'url': 'url',
+        'secondary_urls': 'secondaryUrls',
         'domain_name': 'domainName',
         'directory_type': 'directoryType',
         'service_account': 'serviceAccount',
         'open_ldap_configuration': 'openLdapConfiguration',
         'group_search_type': 'groupSearchType',
         'white_listed_groups': 'whiteListedGroups',
         'created_time': 'createdTime',
@@ -83,36 +105,41 @@
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, name=None, url=None, domain_name=None, directory_type=None, service_account=None, open_ldap_configuration=None, group_search_type=None, white_listed_groups=None, created_time=None, last_updated_time=None, created_by=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
-        """DirectoryService - a model defined in Swagger
-            \nInformation of a directory service
-        """
+    def __init__(self, name=None, url=None, secondary_urls=None, domain_name=None, directory_type=None, service_account=None, open_ldap_configuration=None, group_search_type=None, white_listed_groups=None, created_time=None, last_updated_time=None, created_by=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
         ExternalizableAbstractModel.__init__(self, ext_id, links, tenant_id, *args, **kwargs)
         self.__name = None
         self.__url = None
+        self.__secondary_urls = None
         self.__domain_name = None
         self.__directory_type = None
         self.__service_account = None
         self.__open_ldap_configuration = None
         self.__group_search_type = None
         self.__white_listed_groups = None
         self.__created_time = None
         self.__last_updated_time = None
         self.__created_by = None
         self.discriminator = None
-        self.__name = name
-        self.__url = url
-        self.__domain_name = domain_name
-        self.__directory_type = directory_type
-        self.__service_account = service_account
+        if name is not None:
+            self.__name = name
+        if url is not None:
+            self.__url = url
+        if secondary_urls is not None:
+            self.__secondary_urls = secondary_urls
+        if domain_name is not None:
+            self.__domain_name = domain_name
+        if directory_type is not None:
+            self.__directory_type = directory_type
+        if service_account is not None:
+            self.__service_account = service_account
         if open_ldap_configuration is not None:
             self.__open_ldap_configuration = open_ldap_configuration
         if group_search_type is not None:
             self.__group_search_type = group_search_type
         if white_listed_groups is not None:
             self.__white_listed_groups = white_listed_groups
         if created_time is not None:
@@ -121,193 +148,247 @@
             self.__last_updated_time = last_updated_time
         if created_by is not None:
             self.__created_by = created_by
 
     def _initialize_object_type(self):
         return 'iam.v4.authn.DirectoryService'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authn.DirectoryService'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     @property
     def name(self):
-        """`{ str }`
-            \nName for the directory service
-        """ # noqa: E501
+        """
+        Name for the Directory Service.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__name
 
     @name.setter
     def name(self, name):
-        if name is None:
-            raise ValueError("Invalid value for `name`, must not be `None`")  # noqa: E501
         if name is not None and len(name) > 255:
             raise ValueError("Invalid value for `name`, length must be less than or equal to `255`")  # noqa: E501
         if name is not None and len(name) < 1:
             raise ValueError("Invalid value for `name`, length must be greater than or equal to `1`")  # noqa: E501
+        if name is not None and not re.search('^[^<>;\'()&+%\/\\\\\"`]*$', name):  # noqa: E501
+            raise ValueError(r"Invalid value for `name`, must be a follow pattern or equal to `/^[^<>;'()&+%\/\\\\\"`]*$/`")  # noqa: E501
 
         self.__name = name
 
     @property
     def url(self):
-        """`{ str }`
-            \nURL for the directory service
-        """ # noqa: E501
+        """
+        URL for the Directory Service.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__url
 
     @url.setter
     def url(self, url):
-        if url is None:
-            raise ValueError("Invalid value for `url`, must not be `None`")  # noqa: E501
         if url is not None and len(url) > 2000:
             raise ValueError("Invalid value for `url`, length must be less than or equal to `2000`")  # noqa: E501
         if url is not None and len(url) < 3:
             raise ValueError("Invalid value for `url`, length must be greater than or equal to `3`")  # noqa: E501
 
         self.__url = url
 
     @property
+    def secondary_urls(self):
+        """
+        Secondary URL for the Directory Service.
+
+        :type:
+            list[ :class:`~str` ]
+        """  # noqa: E501
+        return self.__secondary_urls
+
+    @secondary_urls.setter
+    def secondary_urls(self, secondary_urls):
+
+        self.__secondary_urls = secondary_urls
+
+    @property
     def domain_name(self):
-        """`{ str }`
-            \nDomain name for the directory service
-        """ # noqa: E501
+        """
+        Domain name for the Directory Service.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__domain_name
 
     @domain_name.setter
     def domain_name(self, domain_name):
-        if domain_name is None:
-            raise ValueError("Invalid value for `domain_name`, must not be `None`")  # noqa: E501
         if domain_name is not None and len(domain_name) > 255:
             raise ValueError("Invalid value for `domain_name`, length must be less than or equal to `255`")  # noqa: E501
         if domain_name is not None and len(domain_name) < 3:
             raise ValueError("Invalid value for `domain_name`, length must be greater than or equal to `3`")  # noqa: E501
+        if domain_name is not None and not re.search('^[^<>;\'()&+%\/\\\\\"`]*$', domain_name):  # noqa: E501
+            raise ValueError(r"Invalid value for `domain_name`, must be a follow pattern or equal to `/^[^<>;'()&+%\/\\\\\"`]*$/`")  # noqa: E501
 
         self.__domain_name = domain_name
 
     @property
     def directory_type(self):
-        """`{ iam.v4.authn.DirectoryType }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            :class:`~ntnx_iam_py_client.models.iam.v4.authn.DirectoryType`
+        """  # noqa: E501
         return self.__directory_type
 
     @directory_type.setter
     def directory_type(self, directory_type):
-        if directory_type is None:
-            raise ValueError("Invalid value for `directory_type`, must not be `None`")  # noqa: E501
 
         self.__directory_type = directory_type
 
     @property
     def service_account(self):
-        """`{ iam.v4.authn.DsServiceAccount }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            :class:`~ntnx_iam_py_client.models.iam.v4.authn.DsServiceAccount`
+        """  # noqa: E501
         return self.__service_account
 
     @service_account.setter
     def service_account(self, service_account):
-        if service_account is None:
-            raise ValueError("Invalid value for `service_account`, must not be `None`")  # noqa: E501
 
         self.__service_account = service_account
 
     @property
     def open_ldap_configuration(self):
-        """`{ iam.v4.authn.OpenLdapConfig }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            :class:`~ntnx_iam_py_client.models.iam.v4.authn.OpenLdapConfig`
+        """  # noqa: E501
         return self.__open_ldap_configuration
 
     @open_ldap_configuration.setter
     def open_ldap_configuration(self, open_ldap_configuration):
 
         self.__open_ldap_configuration = open_ldap_configuration
 
     @property
     def group_search_type(self):
-        """`{ iam.v4.authn.GroupSearchType }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            :class:`~ntnx_iam_py_client.models.iam.v4.authn.GroupSearchType`
+        """  # noqa: E501
         return self.__group_search_type
 
     @group_search_type.setter
     def group_search_type(self, group_search_type):
 
         self.__group_search_type = group_search_type
 
     @property
     def white_listed_groups(self):
-        """`{ list[str] }`
-            \nList of allowed user groups for the directory service
-        """ # noqa: E501
+        """
+        List of allowed User Groups for the Directory Service.
+
+        :type:
+            list[ :class:`~str` ]
+        """  # noqa: E501
         return self.__white_listed_groups
 
     @white_listed_groups.setter
     def white_listed_groups(self, white_listed_groups):
 
         self.__white_listed_groups = white_listed_groups
 
     @property
     def created_time(self):
-        """`{ datetime }`
-            \nCreation time of the directory service
-        """ # noqa: E501
+        """
+        Creation time of the Directory Service.
+
+        :type:
+
+                :class:`~datetime`
+        """  # noqa: E501
         return self.__created_time
 
     @created_time.setter
     def created_time(self, created_time):
 
         self.__created_time = created_time
 
     @property
     def last_updated_time(self):
-        """`{ datetime }`
-            \nLast updated time of the directory service
-        """ # noqa: E501
+        """
+        Last updated time of the Directory Service.
+
+        :type:
+
+                :class:`~datetime`
+        """  # noqa: E501
         return self.__last_updated_time
 
     @last_updated_time.setter
     def last_updated_time(self, last_updated_time):
 
         self.__last_updated_time = last_updated_time
 
     @property
     def created_by(self):
-        """`{ str }`
-            \nUser or service who created the directory service
-        """ # noqa: E501
+        """
+        User or Service who created the Directory Service.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__created_by
 
     @created_by.setter
     def created_by(self, created_by):
 
         self.__created_by = created_by
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
@@ -315,15 +396,15 @@
         if issubclass(DirectoryService, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/DirectoryServiceConnectionRequest.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/DirectoryServiceConnectionRequest.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,48 +1,48 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class DirectoryServiceConnectionRequest(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """Information for Directory Service connection request.
 
+    :param username: (:attr:`username`) Username to connect to the Directory Service.
+    :type username: required
+    :param password: (:attr:`password`) Password to connect to the Directory Service.
+    :type password: required
 
-class DirectoryServiceConnectionRequest(object):
-    """DirectoryServiceConnectionRequest - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'username': 'str',
         'password': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
@@ -54,47 +54,44 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, username=None, password=None, *args, **kwargs):  # noqa: E501
-        """DirectoryServiceConnectionRequest - a model defined in Swagger
-            \nInformation for directory service connection request
-        """
         self.__username = None
         self.__password = None
         self.discriminator = None
         self.__username = username
         self.__password = password
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'iam.v4.authn.DirectoryServiceConnectionRequest'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authn.DirectoryServiceConnectionRequest'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -102,84 +99,110 @@
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def username(self):
-        """`{ str }`
-            \nUsername to connect to the directory service
-        """ # noqa: E501
+        """
+        Username to connect to the Directory Service.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__username
 
     @username.setter
     def username(self, username):
         if username is None:
             raise ValueError("Invalid value for `username`, must not be `None`")  # noqa: E501
         if username is not None and len(username) > 255:
             raise ValueError("Invalid value for `username`, length must be less than or equal to `255`")  # noqa: E501
+        if username is not None and not re.search('^[^<>;\'()&+%\/\\\\\"`]*$', username):  # noqa: E501
+            raise ValueError(r"Invalid value for `username`, must be a follow pattern or equal to `/^[^<>;'()&+%\/\\\\\"`]*$/`")  # noqa: E501
 
         self.__username = username
 
     @property
     def password(self):
-        """`{ str }`
-            \nPassword to connect to the directory service
-        """ # noqa: E501
+        """
+        Password to connect to the Directory Service.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__password
 
     @password.setter
     def password(self, password):
         if password is None:
             raise ValueError("Invalid value for `password`, must not be `None`")  # noqa: E501
 
         self.__password = password
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
@@ -187,15 +210,15 @@
         if issubclass(DirectoryServiceConnectionRequest, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/DirectoryServiceInfo.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/DirectoryServiceInfo.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,50 +1,52 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_iam_py_client.Ntnx.iam.v4.authn.DirectoryServiceInfoGroup import DirectoryServiceInfoGroup  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.iam.v4.authn.DirectoryServiceInfoOu import DirectoryServiceInfoOu  # noqa: F401,E501
+from pathlib import Path
+from ntnx_iam_py_client.models.iam.v4.authn.DirectoryServiceInfoGroup import DirectoryServiceInfoGroup  # noqa: F401,E501
+from ntnx_iam_py_client.models.iam.v4.authn.DirectoryServiceInfoOu import DirectoryServiceInfoOu  # noqa: F401,E501
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class DirectoryServiceInfo(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """AD/LDAP information of the User.
 
+    :param user_id: (:attr:`user_id`) External Identifier of the User.
+    :type user_id: required
+    :param groups: (:attr:`groups`) List of AD/LDAP groups having the User.
+    :type groups: required
+    :param ous: (:attr:`ous`) List of AD/LDAP OUs having the given User.
+    :type ous: required
 
-class DirectoryServiceInfo(object):
-    """DirectoryServiceInfo - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'user_id': 'str',
         'groups': 'list[iam.v4.authn.DirectoryServiceInfoGroup]',
         'ous': 'list[iam.v4.authn.DirectoryServiceInfoOu]',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
@@ -58,49 +60,46 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, user_id=None, groups=None, ous=None, *args, **kwargs):  # noqa: E501
-        """DirectoryServiceInfo - a model defined in Swagger
-            \nAD/LDAP information of the user
-        """
         self.__user_id = None
         self.__groups = None
         self.__ous = None
         self.discriminator = None
         self.__user_id = user_id
         self.__groups = groups
         self.__ous = ous
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'iam.v4.authn.DirectoryServiceInfo'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authn.DirectoryServiceInfo'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -108,98 +107,124 @@
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def user_id(self):
-        """`{ str }`
-            \nExternal Identifier of the user
-        """ # noqa: E501
+        """
+        External Identifier of the User.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__user_id
 
     @user_id.setter
     def user_id(self, user_id):
         if user_id is None:
             raise ValueError("Invalid value for `user_id`, must not be `None`")  # noqa: E501
         if user_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', user_id):  # noqa: E501
             raise ValueError(r"Invalid value for `user_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
 
         self.__user_id = user_id
 
     @property
     def groups(self):
-        """`{ list[iam.v4.authn.DirectoryServiceInfoGroup] }`
-            \nList of AD/LDAP groups having the user
-        """ # noqa: E501
+        """
+        List of AD/LDAP groups having the User.
+
+        :type:
+             list[ :class:`~ntnx_iam_py_client.models.iam.v4.authn.DirectoryServiceInfoGroup` ]
+        """  # noqa: E501
         return self.__groups
 
     @groups.setter
     def groups(self, groups):
         if groups is None:
             raise ValueError("Invalid value for `groups`, must not be `None`")  # noqa: E501
 
         self.__groups = groups
 
     @property
     def ous(self):
-        """`{ list[iam.v4.authn.DirectoryServiceInfoOu] }`
-            \nList of AD/LDAP OUs having the given user
-        """ # noqa: E501
+        """
+        List of AD/LDAP OUs having the given User.
+
+        :type:
+             list[ :class:`~ntnx_iam_py_client.models.iam.v4.authn.DirectoryServiceInfoOu` ]
+        """  # noqa: E501
         return self.__ous
 
     @ous.setter
     def ous(self, ous):
         if ous is None:
             raise ValueError("Invalid value for `ous`, must not be `None`")  # noqa: E501
 
         self.__ous = ous
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
@@ -207,15 +232,15 @@
         if issubclass(DirectoryServiceInfo, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/DirectoryServiceInfoGroup.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/Tenant.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,50 +1,48 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_iam_py_client.Ntnx.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel  # noqa: F401,E501
+from pathlib import Path
+from ntnx_iam_py_client.models.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
+from ntnx_iam_py_client.models.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel  # noqa: F401,E501
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class Tenant(ExternalizableAbstractModel):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """Information regarding the tenant that the User belongs to.
 
+    :param name: (:attr:`name`) Name of the tenant that the User belongs to.
+    :type name: 
 
-class DirectoryServiceInfoGroup(ExternalizableAbstractModel):
-    """DirectoryServiceInfoGroup - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'name': 'str',
         'ext_id': 'str',
         'links': 'list[common.v1.response.ApiLink]',
         'tenant_id': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
@@ -60,97 +58,103 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, name=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
-        """DirectoryServiceInfoGroup - a model defined in Swagger
-            \nInformation of AD group having the user
-        """
         ExternalizableAbstractModel.__init__(self, ext_id, links, tenant_id, *args, **kwargs)
         self.__name = None
         self.discriminator = None
-        self.__name = name
+        if name is not None:
+            self.__name = name
 
     def _initialize_object_type(self):
-        return 'iam.v4.authn.DirectoryServiceInfoGroup'
+        return 'iam.v4.authn.Tenant'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authn.DirectoryServiceInfoGroup'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     @property
     def name(self):
-        """`{ str }`
-            \nName of the group
-        """ # noqa: E501
+        """
+        Name of the tenant that the User belongs to.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__name
 
     @name.setter
     def name(self, name):
-        if name is None:
-            raise ValueError("Invalid value for `name`, must not be `None`")  # noqa: E501
         if name is not None and len(name) > 255:
             raise ValueError("Invalid value for `name`, length must be less than or equal to `255`")  # noqa: E501
-        if name is not None and len(name) < 1:
-            raise ValueError("Invalid value for `name`, length must be greater than or equal to `1`")  # noqa: E501
+        if name is not None and not re.search('^[^<>;\'()&+%\/\\\\\"`]*$', name):  # noqa: E501
+            raise ValueError(r"Invalid value for `name`, must be a follow pattern or equal to `/^[^<>;'()&+%\/\\\\\"`]*$/`")  # noqa: E501
 
         self.__name = name
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(DirectoryServiceInfoGroup, dict):
+        if issubclass(Tenant, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, DirectoryServiceInfoGroup):
+        if not isinstance(other, Tenant):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/DirectoryServiceInfoOu.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/Group.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,50 +1,48 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_iam_py_client.Ntnx.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel  # noqa: F401,E501
+from pathlib import Path
+from ntnx_iam_py_client.models.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
+from ntnx_iam_py_client.models.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel  # noqa: F401,E501
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class Group(ExternalizableAbstractModel):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """Information of a group of Users.
 
+    :param name: (:attr:`name`) The name of group.
+    :type name: 
 
-class DirectoryServiceInfoOu(ExternalizableAbstractModel):
-    """DirectoryServiceInfoOu - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'name': 'str',
         'ext_id': 'str',
         'links': 'list[common.v1.response.ApiLink]',
         'tenant_id': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
@@ -60,97 +58,105 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, name=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
-        """DirectoryServiceInfoOu - a model defined in Swagger
-            \nInformation of OUs having the user
-        """
         ExternalizableAbstractModel.__init__(self, ext_id, links, tenant_id, *args, **kwargs)
         self.__name = None
         self.discriminator = None
-        self.__name = name
+        if name is not None:
+            self.__name = name
 
     def _initialize_object_type(self):
-        return 'iam.v4.authn.DirectoryServiceInfoOu'
+        return 'iam.v4.authn.Group'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authn.DirectoryServiceInfoOu'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     @property
     def name(self):
-        """`{ str }`
-            \nName of the OU
-        """ # noqa: E501
+        """
+        The name of group.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__name
 
     @name.setter
     def name(self, name):
-        if name is None:
-            raise ValueError("Invalid value for `name`, must not be `None`")  # noqa: E501
         if name is not None and len(name) > 255:
             raise ValueError("Invalid value for `name`, length must be less than or equal to `255`")  # noqa: E501
         if name is not None and len(name) < 1:
             raise ValueError("Invalid value for `name`, length must be greater than or equal to `1`")  # noqa: E501
+        if name is not None and not re.search('^[^<>;\'()&+%\/\\\\\"`]*$', name):  # noqa: E501
+            raise ValueError(r"Invalid value for `name`, must be a follow pattern or equal to `/^[^<>;'()&+%\/\\\\\"`]*$/`")  # noqa: E501
 
         self.__name = name
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(DirectoryServiceInfoOu, dict):
+        if issubclass(Group, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, DirectoryServiceInfoOu):
+        if not isinstance(other, Group):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/DirectoryServiceSearchAttribute.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/FederationClaims.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,212 +1,235 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class FederationClaims(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """Mapping of claims from IAM to the OIDC provider.
 
+    :param name: (:attr:`name`) 
+    :type name: 
+    :param email: (:attr:`email`) 
+    :type email: 
 
-class DirectoryServiceSearchAttribute(object):
-    """DirectoryServiceSearchAttribute - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
-        'values': 'list[str]',
         'name': 'str',
+        'email': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'values': 'values',
         'name': 'name',
+        'email': 'email',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, values=None, name=None, *args, **kwargs):  # noqa: E501
-        """DirectoryServiceSearchAttribute - a model defined in Swagger
-            \nInformation of searched attributes
-        """
-        self.__values = None
+    def __init__(self, name=None, email=None, *args, **kwargs):  # noqa: E501
         self.__name = None
+        self.__email = None
         self.discriminator = None
-        if values is not None:
-            self.__values = values
         if name is not None:
             self.__name = name
+        if email is not None:
+            self.__email = email
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'iam.v4.authn.DirectoryServiceSearchAttribute'
+        return 'iam.v4.authn.FederationClaims'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authn.DirectoryServiceSearchAttribute'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def values(self):
-        """`{ list[str] }`
-            \nValue of the attribute
-        """ # noqa: E501
-        return self.__values
-
-    @values.setter
-    def values(self, values):
+    def name(self):
+        """
+        
 
-        self.__values = values
+        :type:
 
-    @property
-    def name(self):
-        """`{ str }`
-            \nName of the attribute
-        """ # noqa: E501
+                :class:`~str`
+        """  # noqa: E501
         return self.__name
 
     @name.setter
     def name(self, name):
-        if name is not None and len(name) > 1000:
-            raise ValueError("Invalid value for `name`, length must be less than or equal to `1000`")  # noqa: E501
+        if name is not None and len(name) > 16:
+            raise ValueError("Invalid value for `name`, length must be less than or equal to `16`")  # noqa: E501
 
         self.__name = name
 
     @property
+    def email(self):
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__email
+
+    @email.setter
+    def email(self, email):
+        if email is not None and len(email) > 16:
+            raise ValueError("Invalid value for `email`, length must be less than or equal to `16`")  # noqa: E501
+
+        self.__email = email
+
+    @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(DirectoryServiceSearchAttribute, dict):
+        if issubclass(FederationClaims, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, DirectoryServiceSearchAttribute):
+        if not isinstance(other, FederationClaims):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/DirectoryServiceSearchEntity.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/common/v1/response/ApiLink.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,230 +1,231 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_iam_py_client.Ntnx.iam.v4.authn.DirectoryServiceSearchAttribute import DirectoryServiceSearchAttribute  # noqa: F401,E501
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class ApiLink(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """A HATEOAS style link for the response.  Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource. 
 
+    :param href: (:attr:`href`) The URL at which the entity described by the link can be accessed. 
+    :type href: 
+    :param rel: (:attr:`rel`) A name that identifies the relationship of the link to the object that is returned by the URL.  The unique value of \"self\" identifies the URL for the object. 
+    :type rel: 
 
-class DirectoryServiceSearchEntity(object):
-    """DirectoryServiceSearchEntity - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
-        'entity_type': 'str',
-        'name': 'str',
-        'attributes': 'list[iam.v4.authn.DirectoryServiceSearchAttribute]',
+        'href': 'str',
+        'rel': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'entity_type': 'entityType',
-        'name': 'name',
-        'attributes': 'attributes',
+        'href': 'href',
+        'rel': 'rel',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, entity_type=None, name=None, attributes=None, *args, **kwargs):  # noqa: E501
-        """DirectoryServiceSearchEntity - a model defined in Swagger
-            \nInformation of single search entity
-        """
-        self.__entity_type = None
-        self.__name = None
-        self.__attributes = None
+    def __init__(self, href=None, rel=None, *args, **kwargs):  # noqa: E501
+        self.__href = None
+        self.__rel = None
         self.discriminator = None
-        if entity_type is not None:
-            self.__entity_type = entity_type
-        if name is not None:
-            self.__name = name
-        if attributes is not None:
-            self.__attributes = attributes
+        if href is not None:
+            self.__href = href
+        if rel is not None:
+            self.__rel = rel
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'iam.v4.authn.DirectoryServiceSearchEntity'
+        return 'common.v1.response.ApiLink'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authn.DirectoryServiceSearchEntity'
+    def _initialize_object_version(self):
+        return 'v1.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def entity_type(self):
-        """`{ str }`
-            \nType of entity either user or group
-        """ # noqa: E501
-        return self.__entity_type
+    def href(self):
+        """
+        The URL at which the entity described by the link can be accessed. 
 
-    @entity_type.setter
-    def entity_type(self, entity_type):
+        :type:
 
-        self.__entity_type = entity_type
+                :class:`~str`
+        """  # noqa: E501
+        return self.__href
 
-    @property
-    def name(self):
-        """`{ str }`
-            \nName of the entity in canonical format
-        """ # noqa: E501
-        return self.__name
-
-    @name.setter
-    def name(self, name):
-        if name is not None and len(name) > 64:
-            raise ValueError("Invalid value for `name`, length must be less than or equal to `64`")  # noqa: E501
+    @href.setter
+    def href(self, href):
 
-        self.__name = name
+        self.__href = href
 
     @property
-    def attributes(self):
-        """`{ list[iam.v4.authn.DirectoryServiceSearchAttribute] }`
-            
-        """ # noqa: E501
-        return self.__attributes
+    def rel(self):
+        """
+        A name that identifies the relationship of the link to the object that is returned by the URL.  The unique value of \"self\" identifies the URL for the object. 
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__rel
 
-    @attributes.setter
-    def attributes(self, attributes):
+    @rel.setter
+    def rel(self, rel):
 
-        self.__attributes = attributes
+        self.__rel = rel
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(DirectoryServiceSearchEntity, dict):
+        if issubclass(ApiLink, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, DirectoryServiceSearchEntity):
+        if not isinstance(other, ApiLink):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/DirectoryServiceSearchQuery.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/DirectoryServiceSearchQuery.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,48 +1,52 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class DirectoryServiceSearchQuery(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """Information for directory search query.
 
+    :param query: (:attr:`query`) Query string for Directory Service search.
+    :type query: required
+    :param searched_attributes: (:attr:`searched_attributes`) Attributes for search Operation. By default search will be performed with common name.
+    :type searched_attributes: 
+    :param returned_attributes: (:attr:`returned_attributes`) Attributes the search Operation returns.
+    :type returned_attributes: 
+    :param is_wildcard_search: (:attr:`is_wildcard_search`) Flag indicating whether the search should be a wildcard search or not. (**Default** True)
+    :type is_wildcard_search: 
 
-class DirectoryServiceSearchQuery(object):
-    """DirectoryServiceSearchQuery - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'query': 'str',
         'searched_attributes': 'list[str]',
         'returned_attributes': 'list[str]',
         'is_wildcard_search': 'bool',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
@@ -58,17 +62,14 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, query=None, searched_attributes=None, returned_attributes=None, is_wildcard_search=True, *args, **kwargs):  # noqa: E501
-        """DirectoryServiceSearchQuery - a model defined in Swagger
-            \nInformation for directory search query
-        """
         self.__query = None
         self.__searched_attributes = None
         self.__returned_attributes = None
         self.__is_wildcard_search = None
         self.discriminator = None
         self.__query = query
         if searched_attributes is not None:
@@ -79,33 +80,33 @@
             self.__is_wildcard_search = is_wildcard_search
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'iam.v4.authn.DirectoryServiceSearchQuery'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authn.DirectoryServiceSearchQuery'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -113,106 +114,136 @@
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def query(self):
-        """`{ str }`
-            \nQuery string for directory service search
-        """ # noqa: E501
+        """
+        Query string for Directory Service search.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__query
 
     @query.setter
     def query(self, query):
         if query is None:
             raise ValueError("Invalid value for `query`, must not be `None`")  # noqa: E501
         if query is not None and len(query) > 2000:
             raise ValueError("Invalid value for `query`, length must be less than or equal to `2000`")  # noqa: E501
 
         self.__query = query
 
     @property
     def searched_attributes(self):
-        """`{ list[str] }`
-            \nAttributes for search operation. By default search will be performed with common name
-        """ # noqa: E501
+        """
+        Attributes for search Operation. By default search will be performed with common name.
+
+        :type:
+            list[ :class:`~str` ]
+        """  # noqa: E501
         return self.__searched_attributes
 
     @searched_attributes.setter
     def searched_attributes(self, searched_attributes):
 
         self.__searched_attributes = searched_attributes
 
     @property
     def returned_attributes(self):
-        """`{ list[str] }`
-            \nAttributes the search operation returns
-        """ # noqa: E501
+        """
+        Attributes the search Operation returns.
+
+        :type:
+            list[ :class:`~str` ]
+        """  # noqa: E501
         return self.__returned_attributes
 
     @returned_attributes.setter
     def returned_attributes(self, returned_attributes):
 
         self.__returned_attributes = returned_attributes
 
     @property
     def is_wildcard_search(self):
-        """`{ bool }`
-            \nFlag indicating whether the search should be a wildcard search or not
-        """ # noqa: E501
+        """
+        Flag indicating whether the search should be a wildcard search or not.
+
+        :type:
+
+                :class:`~bool`
+        """  # noqa: E501
         return self.__is_wildcard_search
 
     @is_wildcard_search.setter
     def is_wildcard_search(self, is_wildcard_search):
 
         self.__is_wildcard_search = is_wildcard_search
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
@@ -220,15 +251,15 @@
         if issubclass(DirectoryServiceSearchQuery, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/DirectoryServiceSearchResult.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/DirectoryServiceSearchResult.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,49 +1,49 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_iam_py_client.Ntnx.iam.v4.authn.DirectoryServiceSearchEntity import DirectoryServiceSearchEntity  # noqa: F401,E501
+from pathlib import Path
+from ntnx_iam_py_client.models.iam.v4.authn.DirectoryServiceSearchEntity import DirectoryServiceSearchEntity  # noqa: F401,E501
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class DirectoryServiceSearchResult(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """Information of Directory Service search result.
 
+    :param search_results: (:attr:`search_results`) Result of Directory Service search.
+    :type search_results: 
+    :param domain_name: (:attr:`domain_name`) Domain name for the Directory Service.
+    :type domain_name: 
 
-class DirectoryServiceSearchResult(object):
-    """DirectoryServiceSearchResult - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'search_results': 'list[iam.v4.authn.DirectoryServiceSearchEntity]',
         'domain_name': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
@@ -55,49 +55,46 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, search_results=None, domain_name=None, *args, **kwargs):  # noqa: E501
-        """DirectoryServiceSearchResult - a model defined in Swagger
-            \nInformation of directory service search result
-        """
         self.__search_results = None
         self.__domain_name = None
         self.discriminator = None
         if search_results is not None:
             self.__search_results = search_results
         if domain_name is not None:
             self.__domain_name = domain_name
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'iam.v4.authn.DirectoryServiceSearchResult'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authn.DirectoryServiceSearchResult'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -105,80 +102,103 @@
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def search_results(self):
-        """`{ list[iam.v4.authn.DirectoryServiceSearchEntity] }`
-            \nResult of directory service search
-        """ # noqa: E501
+        """
+        Result of Directory Service search.
+
+        :type:
+             list[ :class:`~ntnx_iam_py_client.models.iam.v4.authn.DirectoryServiceSearchEntity` ]
+        """  # noqa: E501
         return self.__search_results
 
     @search_results.setter
     def search_results(self, search_results):
 
         self.__search_results = search_results
 
     @property
     def domain_name(self):
-        """`{ str }`
-            \nDomain name for the directory service
-        """ # noqa: E501
+        """
+        Domain name for the Directory Service.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__domain_name
 
     @domain_name.setter
     def domain_name(self, domain_name):
         if domain_name is not None and len(domain_name) > 255:
             raise ValueError("Invalid value for `domain_name`, length must be less than or equal to `255`")  # noqa: E501
 
         self.__domain_name = domain_name
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
@@ -186,15 +206,15 @@
         if issubclass(DirectoryServiceSearchResult, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/DirectoryType.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/ScopeType.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,150 +1,145 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class ScopeType(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """Type of scope.
 
 
-class DirectoryType(object):
-
-    """
-    allowed enum values :
-
-    _UNKNOWN 
-
-    _REDACTED 
-
-    ACTIVE_DIRECTORY 
-
-    OPEN_LDAP 
+    Allowed enum values:
 
+        - _UNKNOWN
+        - _REDACTED
+        - OPEN_ID
+        - PROFILE
+        - EMAIL
     """
     _UNKNOWN = "$UNKNOWN"
     _REDACTED = "$REDACTED"
-    ACTIVE_DIRECTORY = "ACTIVE_DIRECTORY"
-    OPEN_LDAP = "OPEN_LDAP"
+    OPEN_ID = "OPEN_ID"
+    PROFILE = "PROFILE"
+    EMAIL = "EMAIL"
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
-        """DirectoryType - a model defined in Swagger
-            \nType of directory service
-        """
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'iam.v4.authn.DirectoryType'
+        return 'iam.v4.authn.ScopeType'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authn.DirectoryType'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(DirectoryType, dict):
+        if issubclass(ScopeType, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, DirectoryType):
+        if not isinstance(other, ScopeType):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/DsServiceAccount.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/DsServiceAccount.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,48 +1,48 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class DsServiceAccount(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """Information of Service account to connect to the Directory Service.
 
+    :param username: (:attr:`username`) Username to connect to the Directory Service.
+    :type username: required
+    :param password: (:attr:`password`) Password to connect to the Directory Service.
+    :type password: required
 
-class DsServiceAccount(object):
-    """DsServiceAccount - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'username': 'str',
         'password': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
@@ -54,47 +54,44 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, username=None, password=None, *args, **kwargs):  # noqa: E501
-        """DsServiceAccount - a model defined in Swagger
-            \nService account information to connect to the directory service
-        """
         self.__username = None
         self.__password = None
         self.discriminator = None
         self.__username = username
         self.__password = password
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'iam.v4.authn.DsServiceAccount'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authn.DsServiceAccount'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -102,84 +99,110 @@
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def username(self):
-        """`{ str }`
-            \nUsername to connect to the directory service
-        """ # noqa: E501
+        """
+        Username to connect to the Directory Service.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__username
 
     @username.setter
     def username(self, username):
         if username is None:
             raise ValueError("Invalid value for `username`, must not be `None`")  # noqa: E501
         if username is not None and len(username) > 255:
             raise ValueError("Invalid value for `username`, length must be less than or equal to `255`")  # noqa: E501
+        if username is not None and not re.search('^[^<>;\'()&+%\/\\\\\"`]*$', username):  # noqa: E501
+            raise ValueError(r"Invalid value for `username`, must be a follow pattern or equal to `/^[^<>;'()&+%\/\\\\\"`]*$/`")  # noqa: E501
 
         self.__username = username
 
     @property
     def password(self):
-        """`{ str }`
-            \nPassword to connect to the directory service
-        """ # noqa: E501
+        """
+        Password to connect to the Directory Service.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__password
 
     @password.setter
     def password(self, password):
         if password is None:
             raise ValueError("Invalid value for `password`, must not be `None`")  # noqa: E501
 
         self.__password = password
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
@@ -187,15 +210,15 @@
         if issubclass(DsServiceAccount, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/GetCertAuthProviderApiResponse.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/DeleteAuthorizationPolicyApiResponse.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,54 +1,54 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_iam_py_client.Ntnx
-from ntnx_iam_py_client.Ntnx.OneOfiam.v4.authn.GetCertAuthProviderApiResponsedata import GetCertAuthProviderApiResponsedata  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+from pathlib import Path
+import ntnx_iam_py_client.models
+from ntnx_iam_py_client.models.OneOfiam.v4.authz.DeleteAuthorizationPolicyApiResponsedata import DeleteAuthorizationPolicyApiResponsedata  # noqa: F401,E501
+from ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class DeleteAuthorizationPolicyApiResponse(object):
+
+    """REST response for all response codes in API path /iam/v4.0.b1/authz/authorization-policies/{extId} Delete operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
-
-Do not edit the class manually.
-IGNORE
-"""
-
-
-class GetCertAuthProviderApiResponse(object):
-    """GetCertAuthProviderApiResponse - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfiam.v4.authn.GetCertAuthProviderApiResponsedata',
+        'data': 'OneOfiam.v4.authz.DeleteAuthorizationPolicyApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -57,49 +57,46 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        """GetCertAuthProviderApiResponse - a model defined in Swagger
-            \nREST response for all response codes in api path /iam/v4.0.a1/authn/cert-auth-providers/{extId} Get operation
-        """
         self.__metadata = None
         self.__data = None
         self.discriminator = None
         if metadata is not None:
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'iam.v4.authn.GetCertAuthProviderApiResponse'
+        return 'iam.v4.authz.DeleteAuthorizationPolicyApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authn.GetCertAuthProviderApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -107,111 +104,131 @@
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def metadata(self):
-        """`{ common.v1.response.ApiResponseMetadata }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            :class:`~ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata`
+        """  # noqa: E501
         return self.__metadata
 
     @metadata.setter
     def metadata(self, metadata):
 
         self.__metadata = metadata
 
     @property
     def data(self):
-        """`{ iam.v4.authn.CertAuthProvider | iam.v4.error.ErrorResponse }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+                :class:`~ntnx_iam_py_client.models.iam.v4.error.ErrorResponse`
+                    """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
         self.__data = data
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_iam_py_client.Ntnx, attr_type.split('.')[-1])
-                if hasattr(type, 'get_discriminator_from_object'):
-                    result[type.ONE_OF_ITEM_DISCRIMINATOR_NAME] = type.get_discriminator_from_object(value)
+                type = getattr(ntnx_iam_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(GetCertAuthProviderApiResponse, dict):
+        if issubclass(DeleteAuthorizationPolicyApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, GetCertAuthProviderApiResponse):
+        if not isinstance(other, DeleteAuthorizationPolicyApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/GetDirectoryServiceApiResponse.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/GetDirectoryServiceApiResponse.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,51 +1,51 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_iam_py_client.Ntnx
-from ntnx_iam_py_client.Ntnx.OneOfiam.v4.authn.GetDirectoryServiceApiResponsedata import GetDirectoryServiceApiResponsedata  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+from pathlib import Path
+import ntnx_iam_py_client.models
+from ntnx_iam_py_client.models.OneOfiam.v4.authn.GetDirectoryServiceApiResponsedata import GetDirectoryServiceApiResponsedata  # noqa: F401,E501
+from ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class GetDirectoryServiceApiResponse(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """REST response for all response codes in API path /iam/v4.0.b1/authn/directory-services/{extId} Get operation
 
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
-class GetDirectoryServiceApiResponse(object):
-    """GetDirectoryServiceApiResponse - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
         'data': 'OneOfiam.v4.authn.GetDirectoryServiceApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
@@ -57,49 +57,46 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        """GetDirectoryServiceApiResponse - a model defined in Swagger
-            \nREST response for all response codes in api path /iam/v4.0.a1/authn/directory-services/{extId} Get operation
-        """
         self.__metadata = None
         self.__data = None
         self.discriminator = None
         if metadata is not None:
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'iam.v4.authn.GetDirectoryServiceApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authn.GetDirectoryServiceApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -107,82 +104,103 @@
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def metadata(self):
-        """`{ common.v1.response.ApiResponseMetadata }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            :class:`~ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata`
+        """  # noqa: E501
         return self.__metadata
 
     @metadata.setter
     def metadata(self, metadata):
 
         self.__metadata = metadata
 
     @property
     def data(self):
-        """`{ iam.v4.authn.DirectoryService | iam.v4.error.ErrorResponse }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+                :class:`~ntnx_iam_py_client.models.iam.v4.authn.DirectoryService` | 
+                :class:`~ntnx_iam_py_client.models.iam.v4.error.ErrorResponse`
+                    """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
         self.__data = data
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_iam_py_client.Ntnx, attr_type.split('.')[-1])
-                if hasattr(type, 'get_discriminator_from_object'):
-                    result[type.ONE_OF_ITEM_DISCRIMINATOR_NAME] = type.get_discriminator_from_object(value)
+                type = getattr(ntnx_iam_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
@@ -190,15 +208,15 @@
         if issubclass(GetDirectoryServiceApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/GetSamlIdentityProviderApiResponse.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/GetSamlIdentityProviderApiResponse.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,51 +1,51 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_iam_py_client.Ntnx
-from ntnx_iam_py_client.Ntnx.OneOfiam.v4.authn.GetSamlIdentityProviderApiResponsedata import GetSamlIdentityProviderApiResponsedata  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+from pathlib import Path
+import ntnx_iam_py_client.models
+from ntnx_iam_py_client.models.OneOfiam.v4.authn.GetSamlIdentityProviderApiResponsedata import GetSamlIdentityProviderApiResponsedata  # noqa: F401,E501
+from ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class GetSamlIdentityProviderApiResponse(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """REST response for all response codes in API path /iam/v4.0.b1/authn/saml-identity-providers/{extId} Get operation
 
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
-class GetSamlIdentityProviderApiResponse(object):
-    """GetSamlIdentityProviderApiResponse - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
         'data': 'OneOfiam.v4.authn.GetSamlIdentityProviderApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
@@ -57,49 +57,46 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        """GetSamlIdentityProviderApiResponse - a model defined in Swagger
-            \nREST response for all response codes in api path /iam/v4.0.a1/authn/saml-identity-providers/{extId} Get operation
-        """
         self.__metadata = None
         self.__data = None
         self.discriminator = None
         if metadata is not None:
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'iam.v4.authn.GetSamlIdentityProviderApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authn.GetSamlIdentityProviderApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -107,82 +104,103 @@
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def metadata(self):
-        """`{ common.v1.response.ApiResponseMetadata }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            :class:`~ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata`
+        """  # noqa: E501
         return self.__metadata
 
     @metadata.setter
     def metadata(self, metadata):
 
         self.__metadata = metadata
 
     @property
     def data(self):
-        """`{ iam.v4.authn.SamlIdentityProvider | iam.v4.error.ErrorResponse }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+                :class:`~ntnx_iam_py_client.models.iam.v4.authn.SamlIdentityProvider` | 
+                :class:`~ntnx_iam_py_client.models.iam.v4.error.ErrorResponse`
+                    """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
         self.__data = data
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_iam_py_client.Ntnx, attr_type.split('.')[-1])
-                if hasattr(type, 'get_discriminator_from_object'):
-                    result[type.ONE_OF_ITEM_DISCRIMINATOR_NAME] = type.get_discriminator_from_object(value)
+                type = getattr(ntnx_iam_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
@@ -190,15 +208,15 @@
         if issubclass(GetSamlIdentityProviderApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/GetSamlSpMetadataApiResponse.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/GetSamlSpMetadataApiResponse.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,51 +1,51 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_iam_py_client.Ntnx
-from ntnx_iam_py_client.Ntnx.OneOfiam.v4.authn.GetSamlSpMetadataApiResponsedata import GetSamlSpMetadataApiResponsedata  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+from pathlib import Path
+import ntnx_iam_py_client.models
+from ntnx_iam_py_client.models.OneOfiam.v4.authn.GetSamlSpMetadataApiResponsedata import GetSamlSpMetadataApiResponsedata  # noqa: F401,E501
+from ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class GetSamlSpMetadataApiResponse(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """REST response for all response codes in API path /iam/v4.0.b1/authn/saml-sp-metadata Get operation
 
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
-class GetSamlSpMetadataApiResponse(object):
-    """GetSamlSpMetadataApiResponse - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
         'data': 'OneOfiam.v4.authn.GetSamlSpMetadataApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
@@ -57,49 +57,46 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        """GetSamlSpMetadataApiResponse - a model defined in Swagger
-            \nREST response for all response codes in api path /iam/v4.0.a1/authn/saml-identity-providers/saml20/sp-metadata Get operation
-        """
         self.__metadata = None
         self.__data = None
         self.discriminator = None
         if metadata is not None:
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'iam.v4.authn.GetSamlSpMetadataApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authn.GetSamlSpMetadataApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -107,82 +104,103 @@
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def metadata(self):
-        """`{ common.v1.response.ApiResponseMetadata }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            :class:`~ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata`
+        """  # noqa: E501
         return self.__metadata
 
     @metadata.setter
     def metadata(self, metadata):
 
         self.__metadata = metadata
 
     @property
     def data(self):
-        """`{ str | iam.v4.error.ErrorResponse }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+                :class:`~str` | 
+                :class:`~ntnx_iam_py_client.models.iam.v4.error.ErrorResponse`
+                    """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
         self.__data = data
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_iam_py_client.Ntnx, attr_type.split('.')[-1])
-                if hasattr(type, 'get_discriminator_from_object'):
-                    result[type.ONE_OF_ITEM_DISCRIMINATOR_NAME] = type.get_discriminator_from_object(value)
+                type = getattr(ntnx_iam_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
@@ -190,15 +208,15 @@
         if issubclass(GetSamlSpMetadataApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/GetUserApiResponse.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/UpdateSamlIdentityProviderApiResponse.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,54 +1,54 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_iam_py_client.Ntnx
-from ntnx_iam_py_client.Ntnx.OneOfiam.v4.authn.GetUserApiResponsedata import GetUserApiResponsedata  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+from pathlib import Path
+import ntnx_iam_py_client.models
+from ntnx_iam_py_client.models.OneOfiam.v4.authn.UpdateSamlIdentityProviderApiResponsedata import UpdateSamlIdentityProviderApiResponsedata  # noqa: F401,E501
+from ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class UpdateSamlIdentityProviderApiResponse(object):
+
+    """REST response for all response codes in API path /iam/v4.0.b1/authn/saml-identity-providers/{extId} Put operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
-
-Do not edit the class manually.
-IGNORE
-"""
-
-
-class GetUserApiResponse(object):
-    """GetUserApiResponse - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfiam.v4.authn.GetUserApiResponsedata',
+        'data': 'OneOfiam.v4.authn.UpdateSamlIdentityProviderApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -57,49 +57,46 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        """GetUserApiResponse - a model defined in Swagger
-            \nREST response for all response codes in api path /iam/v4.0.a1/authn/users/{extId} Get operation
-        """
         self.__metadata = None
         self.__data = None
         self.discriminator = None
         if metadata is not None:
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'iam.v4.authn.GetUserApiResponse'
+        return 'iam.v4.authn.UpdateSamlIdentityProviderApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authn.GetUserApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -107,111 +104,132 @@
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def metadata(self):
-        """`{ common.v1.response.ApiResponseMetadata }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            :class:`~ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata`
+        """  # noqa: E501
         return self.__metadata
 
     @metadata.setter
     def metadata(self, metadata):
 
         self.__metadata = metadata
 
     @property
     def data(self):
-        """`{ iam.v4.authn.User | iam.v4.error.ErrorResponse }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+                :class:`~ntnx_iam_py_client.models.iam.v4.authn.SamlIdentityProvider` | 
+                :class:`~ntnx_iam_py_client.models.iam.v4.error.ErrorResponse`
+                    """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
         self.__data = data
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_iam_py_client.Ntnx, attr_type.split('.')[-1])
-                if hasattr(type, 'get_discriminator_from_object'):
-                    result[type.ONE_OF_ITEM_DISCRIMINATOR_NAME] = type.get_discriminator_from_object(value)
+                type = getattr(ntnx_iam_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(GetUserApiResponse, dict):
+        if issubclass(UpdateSamlIdentityProviderApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, GetUserApiResponse):
+        if not isinstance(other, UpdateSamlIdentityProviderApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/GetUserGroupApiResponse.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/GetOperationApiResponse.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,54 +1,54 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_iam_py_client.Ntnx
-from ntnx_iam_py_client.Ntnx.OneOfiam.v4.authn.GetUserGroupApiResponsedata import GetUserGroupApiResponsedata  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+from pathlib import Path
+import ntnx_iam_py_client.models
+from ntnx_iam_py_client.models.OneOfiam.v4.authz.GetOperationApiResponsedata import GetOperationApiResponsedata  # noqa: F401,E501
+from ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class GetOperationApiResponse(object):
+
+    """REST response for all response codes in API path /iam/v4.0.b1/authz/operations/{extId} Get operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
-
-Do not edit the class manually.
-IGNORE
-"""
-
-
-class GetUserGroupApiResponse(object):
-    """GetUserGroupApiResponse - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfiam.v4.authn.GetUserGroupApiResponsedata',
+        'data': 'OneOfiam.v4.authz.GetOperationApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -57,49 +57,46 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        """GetUserGroupApiResponse - a model defined in Swagger
-            \nREST response for all response codes in api path /iam/v4.0.a1/authn/user-groups/{extId} Get operation
-        """
         self.__metadata = None
         self.__data = None
         self.discriminator = None
         if metadata is not None:
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'iam.v4.authn.GetUserGroupApiResponse'
+        return 'iam.v4.authz.GetOperationApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authn.GetUserGroupApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -107,111 +104,132 @@
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def metadata(self):
-        """`{ common.v1.response.ApiResponseMetadata }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            :class:`~ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata`
+        """  # noqa: E501
         return self.__metadata
 
     @metadata.setter
     def metadata(self, metadata):
 
         self.__metadata = metadata
 
     @property
     def data(self):
-        """`{ iam.v4.authn.UserGroup | iam.v4.error.ErrorResponse }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+                :class:`~ntnx_iam_py_client.models.iam.v4.authz.Operation` | 
+                :class:`~ntnx_iam_py_client.models.iam.v4.error.ErrorResponse`
+                    """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
         self.__data = data
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_iam_py_client.Ntnx, attr_type.split('.')[-1])
-                if hasattr(type, 'get_discriminator_from_object'):
-                    result[type.ONE_OF_ITEM_DISCRIMINATOR_NAME] = type.get_discriminator_from_object(value)
+                type = getattr(ntnx_iam_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(GetUserGroupApiResponse, dict):
+        if issubclass(GetOperationApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, GetUserGroupApiResponse):
+        if not isinstance(other, GetOperationApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/GroupSearchType.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/DirectoryType.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,150 +1,143 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class DirectoryType(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """Type of Directory Service.
 
 
-class GroupSearchType(object):
-
-    """
-    allowed enum values :
-
-    _UNKNOWN 
-
-    _REDACTED 
-
-    NON_RECURSIVE 
-
-    RECURSIVE 
+    Allowed enum values:
 
+        - _UNKNOWN
+        - _REDACTED
+        - ACTIVE_DIRECTORY: Directory Service type is Active Directory.
+        - OPEN_LDAP: Directory Service type is Open LDAP.
     """
     _UNKNOWN = "$UNKNOWN"
     _REDACTED = "$REDACTED"
-    NON_RECURSIVE = "NON_RECURSIVE"
-    RECURSIVE = "RECURSIVE"
+    ACTIVE_DIRECTORY = "ACTIVE_DIRECTORY"
+    OPEN_LDAP = "OPEN_LDAP"
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
-        """GroupSearchType - a model defined in Swagger
-            \nGroup membership search type for the directory service
-        """
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'iam.v4.authn.GroupSearchType'
+        return 'iam.v4.authn.DirectoryType'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authn.GroupSearchType'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(GroupSearchType, dict):
+        if issubclass(DirectoryType, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, GroupSearchType):
+        if not isinstance(other, DirectoryType):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/GroupType.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/GroupType.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,121 +1,114 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
-
-Do not edit the class manually.
-IGNORE
-"""
-
+from pathlib import Path
 
 class GroupType(object):
 
-    """
-    allowed enum values :
-
-    _UNKNOWN 
-
-    _REDACTED 
+    """Type of the User Group.
 
-    SAML 
 
-    LDAP 
+    Allowed enum values:
 
+        - _UNKNOWN
+        - _REDACTED
+        - SAML: User Group belonging to a SAML IDP.
+        - LDAP: User Group belonging to a Directory Service (Open LDAP/AD).
     """
     _UNKNOWN = "$UNKNOWN"
     _REDACTED = "$REDACTED"
     SAML = "SAML"
     LDAP = "LDAP"
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
-        """GroupType - a model defined in Swagger
-            \nType of the user group
-        """
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'iam.v4.authn.GroupType'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authn.GroupType'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
@@ -123,15 +116,15 @@
         if issubclass(GroupType, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/IdpProperties.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/IdpMetadata.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,49 +1,57 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_iam_py_client.Ntnx.iam.v4.authn.NameIdPolicyFormat import NameIdPolicyFormat  # noqa: F401,E501
+from pathlib import Path
+from ntnx_iam_py_client.models.iam.v4.authn.NameIdPolicyFormat import NameIdPolicyFormat  # noqa: F401,E501
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class IdpMetadata(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """Information of the IDP.
 
+    :param entity_id: (:attr:`entity_id`) Entity Identifier of Identity provider.
+    :type entity_id: required
+    :param login_url: (:attr:`login_url`) Login URL of the Identity provider.
+    :type login_url: required
+    :param logout_url: (:attr:`logout_url`) Logout URL of the Identity provider.
+    :type logout_url: 
+    :param error_url: (:attr:`error_url`) Error URL of the Identity provider.
+    :type error_url: 
+    :param certificate: (:attr:`certificate`) Certificate for verification.
+    :type certificate: required
+    :param name_id_policy_format: (:attr:`name_id_policy_format`) 
+    :type name_id_policy_format: 
 
-class IdpProperties(object):
-    """IdpProperties - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'entity_id': 'str',
         'login_url': 'str',
         'logout_url': 'str',
         'error_url': 'str',
         'certificate': 'str',
         'name_id_policy_format': 'iam.v4.authn.NameIdPolicyFormat',
@@ -63,17 +71,14 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, entity_id=None, login_url=None, logout_url=None, error_url=None, certificate=None, name_id_policy_format=None, *args, **kwargs):  # noqa: E501
-        """IdpProperties - a model defined in Swagger
-            \nInformation of the IDP
-        """
         self.__entity_id = None
         self.__login_url = None
         self.__logout_url = None
         self.__error_url = None
         self.__certificate = None
         self.__name_id_policy_format = None
         self.discriminator = None
@@ -86,35 +91,35 @@
         self.__certificate = certificate
         if name_id_policy_format is not None:
             self.__name_id_policy_format = name_id_policy_format
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'iam.v4.authn.IdpProperties'
+        return 'iam.v4.authn.IdpMetadata'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authn.IdpProperties'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -122,17 +127,21 @@
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def entity_id(self):
-        """`{ str }`
-            \nEntity Id of Identity provider
-        """ # noqa: E501
+        """
+        Entity Identifier of Identity provider.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__entity_id
 
     @entity_id.setter
     def entity_id(self, entity_id):
         if entity_id is None:
             raise ValueError("Invalid value for `entity_id`, must not be `None`")  # noqa: E501
         if entity_id is not None and len(entity_id) > 2000:
@@ -140,167 +149,202 @@
         if entity_id is not None and len(entity_id) < 3:
             raise ValueError("Invalid value for `entity_id`, length must be greater than or equal to `3`")  # noqa: E501
 
         self.__entity_id = entity_id
 
     @property
     def login_url(self):
-        """`{ str }`
-            \nLogin URL of the Identity provider
-        """ # noqa: E501
+        """
+        Login URL of the Identity provider.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__login_url
 
     @login_url.setter
     def login_url(self, login_url):
         if login_url is None:
             raise ValueError("Invalid value for `login_url`, must not be `None`")  # noqa: E501
         if login_url is not None and len(login_url) > 2000:
             raise ValueError("Invalid value for `login_url`, length must be less than or equal to `2000`")  # noqa: E501
         if login_url is not None and len(login_url) < 3:
             raise ValueError("Invalid value for `login_url`, length must be greater than or equal to `3`")  # noqa: E501
-        if login_url is not None and not re.search('^((http[s]?):\/)?\/?([^:\/\\s]*)((\/\\w+)*(:[0-9]+)*?\/)([\\w\\-\\.]+[^#?\\s]+)(.*)?(#[\\w\\-]+)?$', login_url):  # noqa: E501
-            raise ValueError(r"Invalid value for `login_url`, must be a follow pattern or equal to `/^((http[s]?):\/)?\/?([^:\/\\s]*)((\/\\w+)*(:[0-9]+)*?\/)([\\w\\-\\.]+[^#?\\s]+)(.*)?(#[\\w\\-]+)?$/`")  # noqa: E501
+        if login_url is not None and not re.search('^((http[s]?|nfs):\/)?\/?([^:\/\\s]*)((\/\\w+)*(:[0-9]+)*?\/)([\\w\\-\\.]+[^#?\\s]+)(.*)?(#[\\w\\-]+)?$', login_url):  # noqa: E501
+            raise ValueError(r"Invalid value for `login_url`, must be a follow pattern or equal to `/^((http[s]?|nfs):\/)?\/?([^:\/\\s]*)((\/\\w+)*(:[0-9]+)*?\/)([\\w\\-\\.]+[^#?\\s]+)(.*)?(#[\\w\\-]+)?$/`")  # noqa: E501
 
         self.__login_url = login_url
 
     @property
     def logout_url(self):
-        """`{ str }`
-            \nLogout URL of the Identity provider
-        """ # noqa: E501
+        """
+        Logout URL of the Identity provider.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__logout_url
 
     @logout_url.setter
     def logout_url(self, logout_url):
         if logout_url is not None and len(logout_url) > 2000:
             raise ValueError("Invalid value for `logout_url`, length must be less than or equal to `2000`")  # noqa: E501
         if logout_url is not None and len(logout_url) < 3:
             raise ValueError("Invalid value for `logout_url`, length must be greater than or equal to `3`")  # noqa: E501
-        if logout_url is not None and not re.search('^((http[s]?):\/)?\/?([^:\/\\s]*)((\/\\w+)*(:[0-9]+)*?\/)([\\w\\-\\.]+[^#?\\s]+)(.*)?(#[\\w\\-]+)?$', logout_url):  # noqa: E501
-            raise ValueError(r"Invalid value for `logout_url`, must be a follow pattern or equal to `/^((http[s]?):\/)?\/?([^:\/\\s]*)((\/\\w+)*(:[0-9]+)*?\/)([\\w\\-\\.]+[^#?\\s]+)(.*)?(#[\\w\\-]+)?$/`")  # noqa: E501
+        if logout_url is not None and not re.search('^((http[s]?|nfs):\/)?\/?([^:\/\\s]*)((\/\\w+)*(:[0-9]+)*?\/)([\\w\\-\\.]+[^#?\\s]+)(.*)?(#[\\w\\-]+)?$', logout_url):  # noqa: E501
+            raise ValueError(r"Invalid value for `logout_url`, must be a follow pattern or equal to `/^((http[s]?|nfs):\/)?\/?([^:\/\\s]*)((\/\\w+)*(:[0-9]+)*?\/)([\\w\\-\\.]+[^#?\\s]+)(.*)?(#[\\w\\-]+)?$/`")  # noqa: E501
 
         self.__logout_url = logout_url
 
     @property
     def error_url(self):
-        """`{ str }`
-            \nError URL of the Identity provider
-        """ # noqa: E501
+        """
+        Error URL of the Identity provider.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__error_url
 
     @error_url.setter
     def error_url(self, error_url):
         if error_url is not None and len(error_url) > 2000:
             raise ValueError("Invalid value for `error_url`, length must be less than or equal to `2000`")  # noqa: E501
         if error_url is not None and len(error_url) < 3:
             raise ValueError("Invalid value for `error_url`, length must be greater than or equal to `3`")  # noqa: E501
-        if error_url is not None and not re.search('^((http[s]?):\/)?\/?([^:\/\\s]*)((\/\\w+)*(:[0-9]+)*?\/)([\\w\\-\\.]+[^#?\\s]+)(.*)?(#[\\w\\-]+)?$', error_url):  # noqa: E501
-            raise ValueError(r"Invalid value for `error_url`, must be a follow pattern or equal to `/^((http[s]?):\/)?\/?([^:\/\\s]*)((\/\\w+)*(:[0-9]+)*?\/)([\\w\\-\\.]+[^#?\\s]+)(.*)?(#[\\w\\-]+)?$/`")  # noqa: E501
+        if error_url is not None and not re.search('^((http[s]?|nfs):\/)?\/?([^:\/\\s]*)((\/\\w+)*(:[0-9]+)*?\/)([\\w\\-\\.]+[^#?\\s]+)(.*)?(#[\\w\\-]+)?$', error_url):  # noqa: E501
+            raise ValueError(r"Invalid value for `error_url`, must be a follow pattern or equal to `/^((http[s]?|nfs):\/)?\/?([^:\/\\s]*)((\/\\w+)*(:[0-9]+)*?\/)([\\w\\-\\.]+[^#?\\s]+)(.*)?(#[\\w\\-]+)?$/`")  # noqa: E501
 
         self.__error_url = error_url
 
     @property
     def certificate(self):
-        """`{ str }`
-            \nCertificate for verification
-        """ # noqa: E501
+        """
+        Certificate for verification.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__certificate
 
     @certificate.setter
     def certificate(self, certificate):
         if certificate is None:
             raise ValueError("Invalid value for `certificate`, must not be `None`")  # noqa: E501
         if certificate is not None and len(certificate) < 64:
             raise ValueError("Invalid value for `certificate`, length must be greater than or equal to `64`")  # noqa: E501
 
         self.__certificate = certificate
 
     @property
     def name_id_policy_format(self):
-        """`{ iam.v4.authn.NameIdPolicyFormat }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            :class:`~ntnx_iam_py_client.models.iam.v4.authn.NameIdPolicyFormat`
+        """  # noqa: E501
         return self.__name_id_policy_format
 
     @name_id_policy_format.setter
     def name_id_policy_format(self, name_id_policy_format):
 
         self.__name_id_policy_format = name_id_policy_format
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(IdpProperties, dict):
+        if issubclass(IdpMetadata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, IdpProperties):
+        if not isinstance(other, IdpMetadata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/ListCertAuthProviderApiResponse.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/GetCertAuthProviderApiResponse.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,54 +1,54 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_iam_py_client.Ntnx
-from ntnx_iam_py_client.Ntnx.OneOfiam.v4.authn.ListCertAuthProviderApiResponsedata import ListCertAuthProviderApiResponsedata  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+from pathlib import Path
+import ntnx_iam_py_client.models
+from ntnx_iam_py_client.models.OneOfiam.v4.authn.GetCertAuthProviderApiResponsedata import GetCertAuthProviderApiResponsedata  # noqa: F401,E501
+from ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class GetCertAuthProviderApiResponse(object):
+
+    """REST response for all response codes in API path /iam/v4.0.b1/authn/cert-auth-providers/{extId} Get operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
-
-Do not edit the class manually.
-IGNORE
-"""
-
-
-class ListCertAuthProviderApiResponse(object):
-    """ListCertAuthProviderApiResponse - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfiam.v4.authn.ListCertAuthProviderApiResponsedata',
+        'data': 'OneOfiam.v4.authn.GetCertAuthProviderApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -57,49 +57,46 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        """ListCertAuthProviderApiResponse - a model defined in Swagger
-            \nREST response for all response codes in api path /iam/v4.0.a1/authn/cert-auth-providers Get operation
-        """
         self.__metadata = None
         self.__data = None
         self.discriminator = None
         if metadata is not None:
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'iam.v4.authn.ListCertAuthProviderApiResponse'
+        return 'iam.v4.authn.GetCertAuthProviderApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authn.ListCertAuthProviderApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -107,111 +104,132 @@
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def metadata(self):
-        """`{ common.v1.response.ApiResponseMetadata }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            :class:`~ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata`
+        """  # noqa: E501
         return self.__metadata
 
     @metadata.setter
     def metadata(self, metadata):
 
         self.__metadata = metadata
 
     @property
     def data(self):
-        """`{ list[iam.v4.authn.CertAuthProvider] | iam.v4.error.ErrorResponse }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+                :class:`~ntnx_iam_py_client.models.iam.v4.authn.CertAuthProvider` | 
+                :class:`~ntnx_iam_py_client.models.iam.v4.error.ErrorResponse`
+                    """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
         self.__data = data
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_iam_py_client.Ntnx, attr_type.split('.')[-1])
-                if hasattr(type, 'get_discriminator_from_object'):
-                    result[type.ONE_OF_ITEM_DISCRIMINATOR_NAME] = type.get_discriminator_from_object(value)
+                type = getattr(ntnx_iam_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ListCertAuthProviderApiResponse, dict):
+        if issubclass(GetCertAuthProviderApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ListCertAuthProviderApiResponse):
+        if not isinstance(other, GetCertAuthProviderApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/ListDirectoryServiceApiResponse.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/ListAuthorizationPoliciesApiResponse.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,54 +1,54 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_iam_py_client.Ntnx
-from ntnx_iam_py_client.Ntnx.OneOfiam.v4.authn.ListDirectoryServiceApiResponsedata import ListDirectoryServiceApiResponsedata  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+from pathlib import Path
+import ntnx_iam_py_client.models
+from ntnx_iam_py_client.models.OneOfiam.v4.authz.ListAuthorizationPoliciesApiResponsedata import ListAuthorizationPoliciesApiResponsedata  # noqa: F401,E501
+from ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class ListAuthorizationPoliciesApiResponse(object):
+
+    """REST response for all response codes in API path /iam/v4.0.b1/authz/authorization-policies Get operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
-
-Do not edit the class manually.
-IGNORE
-"""
-
-
-class ListDirectoryServiceApiResponse(object):
-    """ListDirectoryServiceApiResponse - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfiam.v4.authn.ListDirectoryServiceApiResponsedata',
+        'data': 'OneOfiam.v4.authz.ListAuthorizationPoliciesApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -57,49 +57,46 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        """ListDirectoryServiceApiResponse - a model defined in Swagger
-            \nREST response for all response codes in api path /iam/v4.0.a1/authn/directory-services Get operation
-        """
         self.__metadata = None
         self.__data = None
         self.discriminator = None
         if metadata is not None:
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'iam.v4.authn.ListDirectoryServiceApiResponse'
+        return 'iam.v4.authz.ListAuthorizationPoliciesApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authn.ListDirectoryServiceApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -107,111 +104,133 @@
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def metadata(self):
-        """`{ common.v1.response.ApiResponseMetadata }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            :class:`~ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata`
+        """  # noqa: E501
         return self.__metadata
 
     @metadata.setter
     def metadata(self, metadata):
 
         self.__metadata = metadata
 
     @property
     def data(self):
-        """`{ list[iam.v4.authn.DirectoryService] | iam.v4.error.ErrorResponse }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+                :class:`~ntnx_iam_py_client.models.iam.v4.authz.AuthorizationPolicy` | 
+                :class:`~ntnx_iam_py_client.models.iam.v4.error.ErrorResponse` | 
+                :class:`~ntnx_iam_py_client.models.iam.v4.authz.AuthorizationPolicyProjection`
+                    """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
         self.__data = data
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_iam_py_client.Ntnx, attr_type.split('.')[-1])
-                if hasattr(type, 'get_discriminator_from_object'):
-                    result[type.ONE_OF_ITEM_DISCRIMINATOR_NAME] = type.get_discriminator_from_object(value)
+                type = getattr(ntnx_iam_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ListDirectoryServiceApiResponse, dict):
+        if issubclass(ListAuthorizationPoliciesApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ListDirectoryServiceApiResponse):
+        if not isinstance(other, ListAuthorizationPoliciesApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/ListSamlIdentityProviderApiResponse.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/DeleteSamlIdentityProviderApiResponse.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,54 +1,54 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_iam_py_client.Ntnx
-from ntnx_iam_py_client.Ntnx.OneOfiam.v4.authn.ListSamlIdentityProviderApiResponsedata import ListSamlIdentityProviderApiResponsedata  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+from pathlib import Path
+import ntnx_iam_py_client.models
+from ntnx_iam_py_client.models.OneOfiam.v4.authn.DeleteSamlIdentityProviderApiResponsedata import DeleteSamlIdentityProviderApiResponsedata  # noqa: F401,E501
+from ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class DeleteSamlIdentityProviderApiResponse(object):
+
+    """REST response for all response codes in API path /iam/v4.0.b1/authn/saml-identity-providers/{extId} Delete operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
-
-Do not edit the class manually.
-IGNORE
-"""
-
-
-class ListSamlIdentityProviderApiResponse(object):
-    """ListSamlIdentityProviderApiResponse - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfiam.v4.authn.ListSamlIdentityProviderApiResponsedata',
+        'data': 'OneOfiam.v4.authn.DeleteSamlIdentityProviderApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -57,49 +57,46 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        """ListSamlIdentityProviderApiResponse - a model defined in Swagger
-            \nREST response for all response codes in api path /iam/v4.0.a1/authn/saml-identity-providers Get operation
-        """
         self.__metadata = None
         self.__data = None
         self.discriminator = None
         if metadata is not None:
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'iam.v4.authn.ListSamlIdentityProviderApiResponse'
+        return 'iam.v4.authn.DeleteSamlIdentityProviderApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authn.ListSamlIdentityProviderApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -107,111 +104,131 @@
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def metadata(self):
-        """`{ common.v1.response.ApiResponseMetadata }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            :class:`~ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata`
+        """  # noqa: E501
         return self.__metadata
 
     @metadata.setter
     def metadata(self, metadata):
 
         self.__metadata = metadata
 
     @property
     def data(self):
-        """`{ list[iam.v4.authn.SamlIdentityProvider] | iam.v4.error.ErrorResponse }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+                :class:`~ntnx_iam_py_client.models.iam.v4.error.ErrorResponse`
+                    """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
         self.__data = data
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_iam_py_client.Ntnx, attr_type.split('.')[-1])
-                if hasattr(type, 'get_discriminator_from_object'):
-                    result[type.ONE_OF_ITEM_DISCRIMINATOR_NAME] = type.get_discriminator_from_object(value)
+                type = getattr(ntnx_iam_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ListSamlIdentityProviderApiResponse, dict):
+        if issubclass(DeleteSamlIdentityProviderApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ListSamlIdentityProviderApiResponse):
+        if not isinstance(other, DeleteSamlIdentityProviderApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/ListUserApiResponse.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/UpdateUserApiResponse.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,54 +1,54 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_iam_py_client.Ntnx
-from ntnx_iam_py_client.Ntnx.OneOfiam.v4.authn.ListUserApiResponsedata import ListUserApiResponsedata  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+from pathlib import Path
+import ntnx_iam_py_client.models
+from ntnx_iam_py_client.models.OneOfiam.v4.authn.UpdateUserApiResponsedata import UpdateUserApiResponsedata  # noqa: F401,E501
+from ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class UpdateUserApiResponse(object):
+
+    """REST response for all response codes in API path /iam/v4.0.b1/authn/users/{extId} Put operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
-
-Do not edit the class manually.
-IGNORE
-"""
-
-
-class ListUserApiResponse(object):
-    """ListUserApiResponse - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfiam.v4.authn.ListUserApiResponsedata',
+        'data': 'OneOfiam.v4.authn.UpdateUserApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -57,49 +57,46 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        """ListUserApiResponse - a model defined in Swagger
-            \nREST response for all response codes in api path /iam/v4.0.a1/authn/users Get operation
-        """
         self.__metadata = None
         self.__data = None
         self.discriminator = None
         if metadata is not None:
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'iam.v4.authn.ListUserApiResponse'
+        return 'iam.v4.authn.UpdateUserApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authn.ListUserApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -107,111 +104,132 @@
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def metadata(self):
-        """`{ common.v1.response.ApiResponseMetadata }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            :class:`~ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata`
+        """  # noqa: E501
         return self.__metadata
 
     @metadata.setter
     def metadata(self, metadata):
 
         self.__metadata = metadata
 
     @property
     def data(self):
-        """`{ list[iam.v4.authn.User] | iam.v4.error.ErrorResponse }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+                :class:`~ntnx_iam_py_client.models.iam.v4.authn.User` | 
+                :class:`~ntnx_iam_py_client.models.iam.v4.error.ErrorResponse`
+                    """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
         self.__data = data
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_iam_py_client.Ntnx, attr_type.split('.')[-1])
-                if hasattr(type, 'get_discriminator_from_object'):
-                    result[type.ONE_OF_ITEM_DISCRIMINATOR_NAME] = type.get_discriminator_from_object(value)
+                type = getattr(ntnx_iam_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ListUserApiResponse, dict):
+        if issubclass(UpdateUserApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ListUserApiResponse):
+        if not isinstance(other, UpdateUserApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/ListUserGroupApiResponse.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/ListOperationsApiResponse.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,54 +1,54 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_iam_py_client.Ntnx
-from ntnx_iam_py_client.Ntnx.OneOfiam.v4.authn.ListUserGroupApiResponsedata import ListUserGroupApiResponsedata  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+from pathlib import Path
+import ntnx_iam_py_client.models
+from ntnx_iam_py_client.models.OneOfiam.v4.authz.ListOperationsApiResponsedata import ListOperationsApiResponsedata  # noqa: F401,E501
+from ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class ListOperationsApiResponse(object):
+
+    """REST response for all response codes in API path /iam/v4.0.b1/authz/operations Get operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
-
-Do not edit the class manually.
-IGNORE
-"""
-
-
-class ListUserGroupApiResponse(object):
-    """ListUserGroupApiResponse - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfiam.v4.authn.ListUserGroupApiResponsedata',
+        'data': 'OneOfiam.v4.authz.ListOperationsApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -57,49 +57,46 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        """ListUserGroupApiResponse - a model defined in Swagger
-            \nREST response for all response codes in api path /iam/v4.0.a1/authn/user-groups Get operation
-        """
         self.__metadata = None
         self.__data = None
         self.discriminator = None
         if metadata is not None:
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'iam.v4.authn.ListUserGroupApiResponse'
+        return 'iam.v4.authz.ListOperationsApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authn.ListUserGroupApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -107,111 +104,132 @@
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def metadata(self):
-        """`{ common.v1.response.ApiResponseMetadata }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            :class:`~ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata`
+        """  # noqa: E501
         return self.__metadata
 
     @metadata.setter
     def metadata(self, metadata):
 
         self.__metadata = metadata
 
     @property
     def data(self):
-        """`{ list[iam.v4.authn.UserGroup] | iam.v4.error.ErrorResponse }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+                :class:`~ntnx_iam_py_client.models.iam.v4.authz.Operation` | 
+                :class:`~ntnx_iam_py_client.models.iam.v4.error.ErrorResponse`
+                    """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
         self.__data = data
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_iam_py_client.Ntnx, attr_type.split('.')[-1])
-                if hasattr(type, 'get_discriminator_from_object'):
-                    result[type.ONE_OF_ITEM_DISCRIMINATOR_NAME] = type.get_discriminator_from_object(value)
+                type = getattr(ntnx_iam_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ListUserGroupApiResponse, dict):
+        if issubclass(ListOperationsApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ListUserGroupApiResponse):
+        if not isinstance(other, ListOperationsApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/NameIdPolicyFormat.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/NameIdPolicyFormat.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,64 +1,47 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
-
-Do not edit the class manually.
-IGNORE
-"""
-
+from pathlib import Path
 
 class NameIdPolicyFormat(object):
 
-    """
-    allowed enum values :
-
-    _UNKNOWN 
-
-    _REDACTED 
+    """Name ID Policy format.
 
-    EMAILADDRESS 
 
-    UNSPECIFIED 
-
-    X509SUBJECTNAME 
-
-    WINDOWSDOMAINQUALIFIEDNAME 
-
-    ENCRYPTED 
-
-    ENTITY 
-
-    KERBEROS 
-
-    PERSISTENT 
-
-    TRANSIENT 
+    Allowed enum values:
 
+        - _UNKNOWN
+        - _REDACTED
+        - EMAILADDRESS
+        - UNSPECIFIED
+        - X509SUBJECTNAME
+        - WINDOWSDOMAINQUALIFIEDNAME
+        - ENCRYPTED
+        - ENTITY
+        - KERBEROS
+        - PERSISTENT
+        - TRANSIENT
     """
     _UNKNOWN = "$UNKNOWN"
     _REDACTED = "$REDACTED"
     EMAILADDRESS = "emailAddress"
     UNSPECIFIED = "unspecified"
     X509SUBJECTNAME = "X509SubjectName"
     WINDOWSDOMAINQUALIFIEDNAME = "WindowsDomainQualifiedName"
@@ -66,77 +49,80 @@
     ENTITY = "entity"
     KERBEROS = "kerberos"
     PERSISTENT = "persistent"
     TRANSIENT = "transient"
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
-        """NameIdPolicyFormat - a model defined in Swagger
-            \nName Id Policy format
-        """
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'iam.v4.authn.NameIdPolicyFormat'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authn.NameIdPolicyFormat'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
@@ -144,15 +130,15 @@
         if issubclass(NameIdPolicyFormat, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/OpenLdapConfig.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/OpenLdapConfig.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,50 +1,50 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_iam_py_client.Ntnx.iam.v4.authn.UserConfiguration import UserConfiguration  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.iam.v4.authn.UserGroupConfiguration import UserGroupConfiguration  # noqa: F401,E501
+from pathlib import Path
+from ntnx_iam_py_client.models.iam.v4.authn.UserConfiguration import UserConfiguration  # noqa: F401,E501
+from ntnx_iam_py_client.models.iam.v4.authn.UserGroupConfiguration import UserGroupConfiguration  # noqa: F401,E501
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class OpenLdapConfig(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """Configuration for OpenLDAP Directory Service.
 
+    :param user_configuration: (:attr:`user_configuration`) 
+    :type user_configuration: required
+    :param user_group_configuration: (:attr:`user_group_configuration`) 
+    :type user_group_configuration: required
 
-class OpenLdapConfig(object):
-    """OpenLdapConfig - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'user_configuration': 'iam.v4.authn.UserConfiguration',
         'user_group_configuration': 'iam.v4.authn.UserGroupConfiguration',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
@@ -56,47 +56,44 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, user_configuration=None, user_group_configuration=None, *args, **kwargs):  # noqa: E501
-        """OpenLdapConfig - a model defined in Swagger
-            \nConfiguration for OpenLDAP directory service
-        """
         self.__user_configuration = None
         self.__user_group_configuration = None
         self.discriminator = None
         self.__user_configuration = user_configuration
         self.__user_group_configuration = user_group_configuration
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'iam.v4.authn.OpenLdapConfig'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authn.OpenLdapConfig'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -104,82 +101,104 @@
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def user_configuration(self):
-        """`{ iam.v4.authn.UserConfiguration }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            :class:`~ntnx_iam_py_client.models.iam.v4.authn.UserConfiguration`
+        """  # noqa: E501
         return self.__user_configuration
 
     @user_configuration.setter
     def user_configuration(self, user_configuration):
         if user_configuration is None:
             raise ValueError("Invalid value for `user_configuration`, must not be `None`")  # noqa: E501
 
         self.__user_configuration = user_configuration
 
     @property
     def user_group_configuration(self):
-        """`{ iam.v4.authn.UserGroupConfiguration }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            :class:`~ntnx_iam_py_client.models.iam.v4.authn.UserGroupConfiguration`
+        """  # noqa: E501
         return self.__user_group_configuration
 
     @user_group_configuration.setter
     def user_group_configuration(self, user_group_configuration):
         if user_group_configuration is None:
             raise ValueError("Invalid value for `user_group_configuration`, must not be `None`")  # noqa: E501
 
         self.__user_group_configuration = user_group_configuration
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
@@ -187,15 +206,15 @@
         if issubclass(OpenLdapConfig, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/PasswordChangeRequest.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/PasswordChangeRequest.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,48 +1,50 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class PasswordChangeRequest(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """Information for password change of User.
 
+    :param username: (:attr:`username`) Identifier for the User in the form an email address.
+    :type username: required
+    :param old_password: (:attr:`old_password`) Current password of the User.
+    :type old_password: required
+    :param new_password: (:attr:`new_password`) New password for the User.
+    :type new_password: required
 
-class PasswordChangeRequest(object):
-    """PasswordChangeRequest - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'username': 'str',
         'old_password': 'str',
         'new_password': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
@@ -56,49 +58,46 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, username=None, old_password=None, new_password=None, *args, **kwargs):  # noqa: E501
-        """PasswordChangeRequest - a model defined in Swagger
-            \nInformation for password change of user
-        """
         self.__username = None
         self.__old_password = None
         self.__new_password = None
         self.discriminator = None
         self.__username = username
         self.__old_password = old_password
         self.__new_password = new_password
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'iam.v4.authn.PasswordChangeRequest'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authn.PasswordChangeRequest'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -106,98 +105,126 @@
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def username(self):
-        """`{ str }`
-            \nIdentifier for the user in the form an email address
-        """ # noqa: E501
+        """
+        Identifier for the User in the form an email address.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__username
 
     @username.setter
     def username(self, username):
         if username is None:
             raise ValueError("Invalid value for `username`, must not be `None`")  # noqa: E501
         if username is not None and len(username) > 255:
             raise ValueError("Invalid value for `username`, length must be less than or equal to `255`")  # noqa: E501
 
         self.__username = username
 
     @property
     def old_password(self):
-        """`{ str }`
-            \nCurrent password of the user
-        """ # noqa: E501
+        """
+        Current password of the User.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__old_password
 
     @old_password.setter
     def old_password(self, old_password):
         if old_password is None:
             raise ValueError("Invalid value for `old_password`, must not be `None`")  # noqa: E501
 
         self.__old_password = old_password
 
     @property
     def new_password(self):
-        """`{ str }`
-            \nNew password for the user
-        """ # noqa: E501
+        """
+        New password for the User.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__new_password
 
     @new_password.setter
     def new_password(self, new_password):
         if new_password is None:
             raise ValueError("Invalid value for `new_password`, must not be `None`")  # noqa: E501
 
         self.__new_password = new_password
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
@@ -205,15 +232,15 @@
         if issubclass(PasswordChangeRequest, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/PasswordResetRequest.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/PasswordResetRequest.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,48 +1,46 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class PasswordResetRequest(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """Information for password reset of User.
 
+    :param new_password: (:attr:`new_password`) New password for the User.
+    :type new_password: required
 
-class PasswordResetRequest(object):
-    """PasswordResetRequest - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'new_password': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
@@ -52,45 +50,42 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, new_password=None, *args, **kwargs):  # noqa: E501
-        """PasswordResetRequest - a model defined in Swagger
-            \nInformation for password reset of user
-        """
         self.__new_password = None
         self.discriminator = None
         self.__new_password = new_password
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'iam.v4.authn.PasswordResetRequest'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authn.PasswordResetRequest'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -98,68 +93,88 @@
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def new_password(self):
-        """`{ str }`
-            \nNew password for the user
-        """ # noqa: E501
+        """
+        New password for the User.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__new_password
 
     @new_password.setter
     def new_password(self, new_password):
         if new_password is None:
             raise ValueError("Invalid value for `new_password`, must not be `None`")  # noqa: E501
 
         self.__new_password = new_password
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
@@ -167,15 +182,15 @@
         if issubclass(PasswordResetRequest, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/ResetUserPasswordApiResponse.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/ChangeUserPasswordApiResponse.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,54 +1,54 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_iam_py_client.Ntnx
-from ntnx_iam_py_client.Ntnx.OneOfiam.v4.authn.ResetUserPasswordApiResponsedata import ResetUserPasswordApiResponsedata  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+from pathlib import Path
+import ntnx_iam_py_client.models
+from ntnx_iam_py_client.models.OneOfiam.v4.authn.ChangeUserPasswordApiResponsedata import ChangeUserPasswordApiResponsedata  # noqa: F401,E501
+from ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class ChangeUserPasswordApiResponse(object):
+
+    """REST response for all response codes in API path /iam/v4.0.b1/authn/users/$actions/change-password Post operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
-
-Do not edit the class manually.
-IGNORE
-"""
-
-
-class ResetUserPasswordApiResponse(object):
-    """ResetUserPasswordApiResponse - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfiam.v4.authn.ResetUserPasswordApiResponsedata',
+        'data': 'OneOfiam.v4.authn.ChangeUserPasswordApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -57,49 +57,46 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        """ResetUserPasswordApiResponse - a model defined in Swagger
-            \nREST response for all response codes in api path /iam/v4.0.a1/authn/users/{extId}/$actions/reset-password Post operation
-        """
         self.__metadata = None
         self.__data = None
         self.discriminator = None
         if metadata is not None:
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'iam.v4.authn.ResetUserPasswordApiResponse'
+        return 'iam.v4.authn.ChangeUserPasswordApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authn.ResetUserPasswordApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -107,111 +104,132 @@
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def metadata(self):
-        """`{ common.v1.response.ApiResponseMetadata }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            :class:`~ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata`
+        """  # noqa: E501
         return self.__metadata
 
     @metadata.setter
     def metadata(self, metadata):
 
         self.__metadata = metadata
 
     @property
     def data(self):
-        """`{ iam.v4.error.ErrorResponse }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+                :class:`~ntnx_iam_py_client.models.iam.v4.authn.PasswordChangeResponse` | 
+                :class:`~ntnx_iam_py_client.models.iam.v4.error.ErrorResponse`
+                    """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
         self.__data = data
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_iam_py_client.Ntnx, attr_type.split('.')[-1])
-                if hasattr(type, 'get_discriminator_from_object'):
-                    result[type.ONE_OF_ITEM_DISCRIMINATOR_NAME] = type.get_discriminator_from_object(value)
+                type = getattr(ntnx_iam_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ResetUserPasswordApiResponse, dict):
+        if issubclass(ChangeUserPasswordApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ResetUserPasswordApiResponse):
+        if not isinstance(other, ChangeUserPasswordApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/SamlIdentityProvider.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/SamlIdentityProvider.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,379 +1,461 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_iam_py_client.Ntnx.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.iam.v4.authn.IdpProperties import IdpProperties  # noqa: F401,E501
+from pathlib import Path
+from ntnx_iam_py_client.models.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
+from ntnx_iam_py_client.models.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel  # noqa: F401,E501
+from ntnx_iam_py_client.models.iam.v4.authn.IdpMetadata import IdpMetadata  # noqa: F401,E501
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class SamlIdentityProvider(ExternalizableAbstractModel):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """Information of SAML IDP.
 
+    :param idp_metadata_url: (:attr:`idp_metadata_url`) Metadata url that provides IDP details.
+    :type idp_metadata_url: 
+    :param idp_metadata_xml: (:attr:`idp_metadata_xml`) Base64 encoded metadata in XML format with IDP details.
+    :type idp_metadata_xml: 
+    :param idp_metadata: (:attr:`idp_metadata`) 
+    :type idp_metadata: 
+    :param name: (:attr:`name`) Unique name of the IDP.
+    :type name: 
+    :param username_attribute: (:attr:`username_attribute`) SAML assertion Username attribute element. (**Default** 'name')
+    :type username_attribute: 
+    :param email_attribute: (:attr:`email_attribute`) SAML assertion email attribute element. (**Default** 'email')
+    :type email_attribute: 
+    :param groups_attribute: (:attr:`groups_attribute`) SAML assertion groups attribute element.
+    :type groups_attribute: 
+    :param groups_delim: (:attr:`groups_delim`) Delimiter is used to split the value of attribute into multiple groups.
+    :type groups_delim: 
+    :param custom_attributes: (:attr:`custom_attributes`) SAML assertions for list of custom attribute elements.
+    :type custom_attributes: 
+    :param entity_issuer: (:attr:`entity_issuer`) It will be used as Issuer in SAML authnRequest.
+    :type entity_issuer: 
+    :param is_signed_authn_req_enabled: (:attr:`is_signed_authn_req_enabled`) Flag indicating signing of SAML authnRequests.
+    :type is_signed_authn_req_enabled: 
+    :param created_time: (:attr:`created_time`) Creation time of the SAML Identity Provider.
+    :type created_time: 
+    :param last_updated_time: (:attr:`last_updated_time`) Last updated time of the SAML Identity Provider.
+    :type last_updated_time: 
+    :param created_by: (:attr:`created_by`) User or Service who created the SAML Identity Provider.
+    :type created_by: 
 
-class SamlIdentityProvider(ExternalizableAbstractModel):
-    """SamlIdentityProvider - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'idp_metadata_url': 'str',
-        'idp_metadata': 'str',
-        'idp_properties': 'iam.v4.authn.IdpProperties',
+        'idp_metadata_xml': 'str',
+        'idp_metadata': 'iam.v4.authn.IdpMetadata',
         'name': 'str',
-        'username_attr': 'str',
-        'email_attr': 'str',
-        'groups_attr': 'str',
+        'username_attribute': 'str',
+        'email_attribute': 'str',
+        'groups_attribute': 'str',
         'groups_delim': 'str',
-        'custom_attr': 'list[str]',
+        'custom_attributes': 'list[str]',
         'entity_issuer': 'str',
-        'enable_signed_authn_req': 'bool',
+        'is_signed_authn_req_enabled': 'bool',
         'created_time': 'datetime',
         'last_updated_time': 'datetime',
         'created_by': 'str',
         'ext_id': 'str',
         'links': 'list[common.v1.response.ApiLink]',
         'tenant_id': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'idp_metadata_url': 'idpMetadataUrl',
+        'idp_metadata_xml': 'idpMetadataXml',
         'idp_metadata': 'idpMetadata',
-        'idp_properties': 'idpProperties',
         'name': 'name',
-        'username_attr': 'usernameAttr',
-        'email_attr': 'emailAttr',
-        'groups_attr': 'groupsAttr',
+        'username_attribute': 'usernameAttribute',
+        'email_attribute': 'emailAttribute',
+        'groups_attribute': 'groupsAttribute',
         'groups_delim': 'groupsDelim',
-        'custom_attr': 'customAttr',
+        'custom_attributes': 'customAttributes',
         'entity_issuer': 'entityIssuer',
-        'enable_signed_authn_req': 'enableSignedAuthnReq',
+        'is_signed_authn_req_enabled': 'isSignedAuthnReqEnabled',
         'created_time': 'createdTime',
         'last_updated_time': 'lastUpdatedTime',
         'created_by': 'createdBy',
         'ext_id': 'extId',
         'links': 'links',
         'tenant_id': 'tenantId',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, idp_metadata_url=None, idp_metadata=None, idp_properties=None, name=None, username_attr='name', email_attr='email', groups_attr=None, groups_delim=None, custom_attr=None, entity_issuer=None, enable_signed_authn_req=None, created_time=None, last_updated_time=None, created_by=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
-        """SamlIdentityProvider - a model defined in Swagger
-            \nInformation of SAML IDP
-        """
+    def __init__(self, idp_metadata_url=None, idp_metadata_xml=None, idp_metadata=None, name=None, username_attribute='name', email_attribute='email', groups_attribute=None, groups_delim=None, custom_attributes=None, entity_issuer=None, is_signed_authn_req_enabled=None, created_time=None, last_updated_time=None, created_by=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
         ExternalizableAbstractModel.__init__(self, ext_id, links, tenant_id, *args, **kwargs)
         self.__idp_metadata_url = None
+        self.__idp_metadata_xml = None
         self.__idp_metadata = None
-        self.__idp_properties = None
         self.__name = None
-        self.__username_attr = None
-        self.__email_attr = None
-        self.__groups_attr = None
+        self.__username_attribute = None
+        self.__email_attribute = None
+        self.__groups_attribute = None
         self.__groups_delim = None
-        self.__custom_attr = None
+        self.__custom_attributes = None
         self.__entity_issuer = None
-        self.__enable_signed_authn_req = None
+        self.__is_signed_authn_req_enabled = None
         self.__created_time = None
         self.__last_updated_time = None
         self.__created_by = None
         self.discriminator = None
         if idp_metadata_url is not None:
             self.__idp_metadata_url = idp_metadata_url
+        if idp_metadata_xml is not None:
+            self.__idp_metadata_xml = idp_metadata_xml
         if idp_metadata is not None:
             self.__idp_metadata = idp_metadata
-        if idp_properties is not None:
-            self.__idp_properties = idp_properties
-        self.__name = name
-        self.__username_attr = username_attr
-        self.__email_attr = email_attr
-        if groups_attr is not None:
-            self.__groups_attr = groups_attr
+        if name is not None:
+            self.__name = name
+        if username_attribute is not None:
+            self.__username_attribute = username_attribute
+        if email_attribute is not None:
+            self.__email_attribute = email_attribute
+        if groups_attribute is not None:
+            self.__groups_attribute = groups_attribute
         if groups_delim is not None:
             self.__groups_delim = groups_delim
-        if custom_attr is not None:
-            self.__custom_attr = custom_attr
+        if custom_attributes is not None:
+            self.__custom_attributes = custom_attributes
         if entity_issuer is not None:
             self.__entity_issuer = entity_issuer
-        if enable_signed_authn_req is not None:
-            self.__enable_signed_authn_req = enable_signed_authn_req
+        if is_signed_authn_req_enabled is not None:
+            self.__is_signed_authn_req_enabled = is_signed_authn_req_enabled
         if created_time is not None:
             self.__created_time = created_time
         if last_updated_time is not None:
             self.__last_updated_time = last_updated_time
         if created_by is not None:
             self.__created_by = created_by
 
     def _initialize_object_type(self):
         return 'iam.v4.authn.SamlIdentityProvider'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authn.SamlIdentityProvider'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     @property
     def idp_metadata_url(self):
-        """`{ str }`
-            \nMetadata URL that provides IDP details
-        """ # noqa: E501
+        """
+        Metadata url that provides IDP details.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__idp_metadata_url
 
     @idp_metadata_url.setter
     def idp_metadata_url(self, idp_metadata_url):
         if idp_metadata_url is not None and len(idp_metadata_url) > 2000:
             raise ValueError("Invalid value for `idp_metadata_url`, length must be less than or equal to `2000`")  # noqa: E501
         if idp_metadata_url is not None and len(idp_metadata_url) < 3:
             raise ValueError("Invalid value for `idp_metadata_url`, length must be greater than or equal to `3`")  # noqa: E501
-        if idp_metadata_url is not None and not re.search('^((http[s]?):\/)?\/?([^:\/\\s]*)((\/\\w+)*(:[0-9]+)*?\/)([\\w\\-\\.]+[^#?\\s]+)(.*)?(#[\\w\\-]+)?$', idp_metadata_url):  # noqa: E501
-            raise ValueError(r"Invalid value for `idp_metadata_url`, must be a follow pattern or equal to `/^((http[s]?):\/)?\/?([^:\/\\s]*)((\/\\w+)*(:[0-9]+)*?\/)([\\w\\-\\.]+[^#?\\s]+)(.*)?(#[\\w\\-]+)?$/`")  # noqa: E501
+        if idp_metadata_url is not None and not re.search('^((http[s]?|nfs):\/)?\/?([^:\/\\s]*)((\/\\w+)*(:[0-9]+)*?\/)([\\w\\-\\.]+[^#?\\s]+)(.*)?(#[\\w\\-]+)?$', idp_metadata_url):  # noqa: E501
+            raise ValueError(r"Invalid value for `idp_metadata_url`, must be a follow pattern or equal to `/^((http[s]?|nfs):\/)?\/?([^:\/\\s]*)((\/\\w+)*(:[0-9]+)*?\/)([\\w\\-\\.]+[^#?\\s]+)(.*)?(#[\\w\\-]+)?$/`")  # noqa: E501
 
         self.__idp_metadata_url = idp_metadata_url
 
     @property
+    def idp_metadata_xml(self):
+        """
+        Base64 encoded metadata in XML format with IDP details.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__idp_metadata_xml
+
+    @idp_metadata_xml.setter
+    def idp_metadata_xml(self, idp_metadata_xml):
+        if idp_metadata_xml is not None and len(idp_metadata_xml) < 3:
+            raise ValueError("Invalid value for `idp_metadata_xml`, length must be greater than or equal to `3`")  # noqa: E501
+
+        self.__idp_metadata_xml = idp_metadata_xml
+
+    @property
     def idp_metadata(self):
-        """`{ str }`
-            \nBase64 encoded metadata in xml format with IDP details
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            :class:`~ntnx_iam_py_client.models.iam.v4.authn.IdpMetadata`
+        """  # noqa: E501
         return self.__idp_metadata
 
     @idp_metadata.setter
     def idp_metadata(self, idp_metadata):
-        if idp_metadata is not None and len(idp_metadata) < 3:
-            raise ValueError("Invalid value for `idp_metadata`, length must be greater than or equal to `3`")  # noqa: E501
 
         self.__idp_metadata = idp_metadata
 
     @property
-    def idp_properties(self):
-        """`{ iam.v4.authn.IdpProperties }`
-            
-        """ # noqa: E501
-        return self.__idp_properties
-
-    @idp_properties.setter
-    def idp_properties(self, idp_properties):
+    def name(self):
+        """
+        Unique name of the IDP.
 
-        self.__idp_properties = idp_properties
+        :type:
 
-    @property
-    def name(self):
-        """`{ str }`
-            \nUnique name of the IDP
-        """ # noqa: E501
+                :class:`~str`
+        """  # noqa: E501
         return self.__name
 
     @name.setter
     def name(self, name):
-        if name is None:
-            raise ValueError("Invalid value for `name`, must not be `None`")  # noqa: E501
         if name is not None and len(name) > 255:
             raise ValueError("Invalid value for `name`, length must be less than or equal to `255`")  # noqa: E501
         if name is not None and len(name) < 1:
             raise ValueError("Invalid value for `name`, length must be greater than or equal to `1`")  # noqa: E501
+        if name is not None and not re.search('^[^<>;\'()&+%\/\\\\\"`]*$', name):  # noqa: E501
+            raise ValueError(r"Invalid value for `name`, must be a follow pattern or equal to `/^[^<>;'()&+%\/\\\\\"`]*$/`")  # noqa: E501
 
         self.__name = name
 
     @property
-    def username_attr(self):
-        """`{ str }`
-            \nSAML assertion username attribute element
-        """ # noqa: E501
-        return self.__username_attr
-
-    @username_attr.setter
-    def username_attr(self, username_attr):
-        if username_attr is None:
-            raise ValueError("Invalid value for `username_attr`, must not be `None`")  # noqa: E501
-        if username_attr is not None and len(username_attr) > 256:
-            raise ValueError("Invalid value for `username_attr`, length must be less than or equal to `256`")  # noqa: E501
-        if username_attr is not None and len(username_attr) < 1:
-            raise ValueError("Invalid value for `username_attr`, length must be greater than or equal to `1`")  # noqa: E501
-
-        self.__username_attr = username_attr
-
-    @property
-    def email_attr(self):
-        """`{ str }`
-            \nSAML assertion email attribute element
-        """ # noqa: E501
-        return self.__email_attr
-
-    @email_attr.setter
-    def email_attr(self, email_attr):
-        if email_attr is None:
-            raise ValueError("Invalid value for `email_attr`, must not be `None`")  # noqa: E501
-        if email_attr is not None and len(email_attr) > 256:
-            raise ValueError("Invalid value for `email_attr`, length must be less than or equal to `256`")  # noqa: E501
-        if email_attr is not None and len(email_attr) < 3:
-            raise ValueError("Invalid value for `email_attr`, length must be greater than or equal to `3`")  # noqa: E501
-
-        self.__email_attr = email_attr
-
-    @property
-    def groups_attr(self):
-        """`{ str }`
-            \nSAML assertion groups attribute element
-        """ # noqa: E501
-        return self.__groups_attr
-
-    @groups_attr.setter
-    def groups_attr(self, groups_attr):
-        if groups_attr is not None and len(groups_attr) > 256:
-            raise ValueError("Invalid value for `groups_attr`, length must be less than or equal to `256`")  # noqa: E501
-        if groups_attr is not None and len(groups_attr) < 3:
-            raise ValueError("Invalid value for `groups_attr`, length must be greater than or equal to `3`")  # noqa: E501
+    def username_attribute(self):
+        """
+        SAML assertion Username attribute element.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__username_attribute
+
+    @username_attribute.setter
+    def username_attribute(self, username_attribute):
+        if username_attribute is not None and len(username_attribute) > 256:
+            raise ValueError("Invalid value for `username_attribute`, length must be less than or equal to `256`")  # noqa: E501
+        if username_attribute is not None and len(username_attribute) < 1:
+            raise ValueError("Invalid value for `username_attribute`, length must be greater than or equal to `1`")  # noqa: E501
+        if username_attribute is not None and not re.search('^[^<>;\'()&+%\/\\\\\"`]*$', username_attribute):  # noqa: E501
+            raise ValueError(r"Invalid value for `username_attribute`, must be a follow pattern or equal to `/^[^<>;'()&+%\/\\\\\"`]*$/`")  # noqa: E501
+
+        self.__username_attribute = username_attribute
+
+    @property
+    def email_attribute(self):
+        """
+        SAML assertion email attribute element.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__email_attribute
 
-        self.__groups_attr = groups_attr
+    @email_attribute.setter
+    def email_attribute(self, email_attribute):
+        if email_attribute is not None and len(email_attribute) > 256:
+            raise ValueError("Invalid value for `email_attribute`, length must be less than or equal to `256`")  # noqa: E501
+        if email_attribute is not None and len(email_attribute) < 3:
+            raise ValueError("Invalid value for `email_attribute`, length must be greater than or equal to `3`")  # noqa: E501
+
+        self.__email_attribute = email_attribute
+
+    @property
+    def groups_attribute(self):
+        """
+        SAML assertion groups attribute element.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__groups_attribute
+
+    @groups_attribute.setter
+    def groups_attribute(self, groups_attribute):
+        if groups_attribute is not None and len(groups_attribute) > 256:
+            raise ValueError("Invalid value for `groups_attribute`, length must be less than or equal to `256`")  # noqa: E501
+        if groups_attribute is not None and len(groups_attribute) < 3:
+            raise ValueError("Invalid value for `groups_attribute`, length must be greater than or equal to `3`")  # noqa: E501
+
+        self.__groups_attribute = groups_attribute
 
     @property
     def groups_delim(self):
-        """`{ str }`
-            \nDelimiter is used to split the value of attribute into multiple groups
-        """ # noqa: E501
+        """
+        Delimiter is used to split the value of attribute into multiple groups.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__groups_delim
 
     @groups_delim.setter
     def groups_delim(self, groups_delim):
         if groups_delim is not None and len(groups_delim) > 3:
             raise ValueError("Invalid value for `groups_delim`, length must be less than or equal to `3`")  # noqa: E501
         if groups_delim is not None and len(groups_delim) < 1:
             raise ValueError("Invalid value for `groups_delim`, length must be greater than or equal to `1`")  # noqa: E501
 
         self.__groups_delim = groups_delim
 
     @property
-    def custom_attr(self):
-        """`{ list[str] }`
-            \nSAML assertions for list of custom attribute elements
-        """ # noqa: E501
-        return self.__custom_attr
+    def custom_attributes(self):
+        """
+        SAML assertions for list of custom attribute elements.
+
+        :type:
+            list[ :class:`~str` ]
+        """  # noqa: E501
+        return self.__custom_attributes
 
-    @custom_attr.setter
-    def custom_attr(self, custom_attr):
+    @custom_attributes.setter
+    def custom_attributes(self, custom_attributes):
 
-        self.__custom_attr = custom_attr
+        self.__custom_attributes = custom_attributes
 
     @property
     def entity_issuer(self):
-        """`{ str }`
-            \nIt will be used as issuer in SAML authentication request
-        """ # noqa: E501
+        """
+        It will be used as Issuer in SAML authnRequest.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__entity_issuer
 
     @entity_issuer.setter
     def entity_issuer(self, entity_issuer):
         if entity_issuer is not None and len(entity_issuer) > 2000:
             raise ValueError("Invalid value for `entity_issuer`, length must be less than or equal to `2000`")  # noqa: E501
         if entity_issuer is not None and len(entity_issuer) < 3:
             raise ValueError("Invalid value for `entity_issuer`, length must be greater than or equal to `3`")  # noqa: E501
 
         self.__entity_issuer = entity_issuer
 
     @property
-    def enable_signed_authn_req(self):
-        """`{ bool }`
-            \nFlag indicating signing of SAML authentication requests
-        """ # noqa: E501
-        return self.__enable_signed_authn_req
+    def is_signed_authn_req_enabled(self):
+        """
+        Flag indicating signing of SAML authnRequests.
+
+        :type:
+
+                :class:`~bool`
+        """  # noqa: E501
+        return self.__is_signed_authn_req_enabled
 
-    @enable_signed_authn_req.setter
-    def enable_signed_authn_req(self, enable_signed_authn_req):
+    @is_signed_authn_req_enabled.setter
+    def is_signed_authn_req_enabled(self, is_signed_authn_req_enabled):
 
-        self.__enable_signed_authn_req = enable_signed_authn_req
+        self.__is_signed_authn_req_enabled = is_signed_authn_req_enabled
 
     @property
     def created_time(self):
-        """`{ datetime }`
-            \nCreation time of the SAML Identity Provider
-        """ # noqa: E501
+        """
+        Creation time of the SAML Identity Provider.
+
+        :type:
+
+                :class:`~datetime`
+        """  # noqa: E501
         return self.__created_time
 
     @created_time.setter
     def created_time(self, created_time):
 
         self.__created_time = created_time
 
     @property
     def last_updated_time(self):
-        """`{ datetime }`
-            \nLast updated time of the SAML Identity Provider
-        """ # noqa: E501
+        """
+        Last updated time of the SAML Identity Provider.
+
+        :type:
+
+                :class:`~datetime`
+        """  # noqa: E501
         return self.__last_updated_time
 
     @last_updated_time.setter
     def last_updated_time(self, last_updated_time):
 
         self.__last_updated_time = last_updated_time
 
     @property
     def created_by(self):
-        """`{ str }`
-            \nUser or service who created the SAML Identity Provider
-        """ # noqa: E501
+        """
+        User or Service who created the SAML Identity Provider.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__created_by
 
     @created_by.setter
     def created_by(self, created_by):
 
         self.__created_by = created_by
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
@@ -381,15 +463,15 @@
         if issubclass(SamlIdentityProvider, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/SearchDirectoryServiceApiResponse.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/SearchDirectoryServiceApiResponse.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,51 +1,51 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_iam_py_client.Ntnx
-from ntnx_iam_py_client.Ntnx.OneOfiam.v4.authn.SearchDirectoryServiceApiResponsedata import SearchDirectoryServiceApiResponsedata  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+from pathlib import Path
+import ntnx_iam_py_client.models
+from ntnx_iam_py_client.models.OneOfiam.v4.authn.SearchDirectoryServiceApiResponsedata import SearchDirectoryServiceApiResponsedata  # noqa: F401,E501
+from ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class SearchDirectoryServiceApiResponse(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """REST response for all response codes in API path /iam/v4.0.b1/authn/directory-services/{extId}/$actions/search Post operation
 
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
-class SearchDirectoryServiceApiResponse(object):
-    """SearchDirectoryServiceApiResponse - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
         'data': 'OneOfiam.v4.authn.SearchDirectoryServiceApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
@@ -57,49 +57,46 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        """SearchDirectoryServiceApiResponse - a model defined in Swagger
-            \nREST response for all response codes in api path /iam/v4.0.a1/authn/directory-services/{extId}/search Post operation
-        """
         self.__metadata = None
         self.__data = None
         self.discriminator = None
         if metadata is not None:
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'iam.v4.authn.SearchDirectoryServiceApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authn.SearchDirectoryServiceApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -107,82 +104,103 @@
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def metadata(self):
-        """`{ common.v1.response.ApiResponseMetadata }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            :class:`~ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata`
+        """  # noqa: E501
         return self.__metadata
 
     @metadata.setter
     def metadata(self, metadata):
 
         self.__metadata = metadata
 
     @property
     def data(self):
-        """`{ iam.v4.authn.DirectoryServiceSearchResult | iam.v4.error.ErrorResponse }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+                :class:`~ntnx_iam_py_client.models.iam.v4.authn.DirectoryServiceSearchResult` | 
+                :class:`~ntnx_iam_py_client.models.iam.v4.error.ErrorResponse`
+                    """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
         self.__data = data
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_iam_py_client.Ntnx, attr_type.split('.')[-1])
-                if hasattr(type, 'get_discriminator_from_object'):
-                    result[type.ONE_OF_ITEM_DISCRIMINATOR_NAME] = type.get_discriminator_from_object(value)
+                type = getattr(ntnx_iam_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
@@ -190,15 +208,15 @@
         if issubclass(SearchDirectoryServiceApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/UpdateCertAuthProviderApiResponse.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/DeleteDirectoryServiceApiResponse.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,54 +1,54 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_iam_py_client.Ntnx
-from ntnx_iam_py_client.Ntnx.OneOfiam.v4.authn.UpdateCertAuthProviderApiResponsedata import UpdateCertAuthProviderApiResponsedata  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+from pathlib import Path
+import ntnx_iam_py_client.models
+from ntnx_iam_py_client.models.OneOfiam.v4.authn.DeleteDirectoryServiceApiResponsedata import DeleteDirectoryServiceApiResponsedata  # noqa: F401,E501
+from ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class DeleteDirectoryServiceApiResponse(object):
+
+    """REST response for all response codes in API path /iam/v4.0.b1/authn/directory-services/{extId} Delete operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
-
-Do not edit the class manually.
-IGNORE
-"""
-
-
-class UpdateCertAuthProviderApiResponse(object):
-    """UpdateCertAuthProviderApiResponse - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfiam.v4.authn.UpdateCertAuthProviderApiResponsedata',
+        'data': 'OneOfiam.v4.authn.DeleteDirectoryServiceApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -57,49 +57,46 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        """UpdateCertAuthProviderApiResponse - a model defined in Swagger
-            \nREST response for all response codes in api path /iam/v4.0.a1/authn/cert-auth-providers/{extId} Put operation
-        """
         self.__metadata = None
         self.__data = None
         self.discriminator = None
         if metadata is not None:
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'iam.v4.authn.UpdateCertAuthProviderApiResponse'
+        return 'iam.v4.authn.DeleteDirectoryServiceApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authn.UpdateCertAuthProviderApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -107,111 +104,131 @@
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def metadata(self):
-        """`{ common.v1.response.ApiResponseMetadata }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            :class:`~ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata`
+        """  # noqa: E501
         return self.__metadata
 
     @metadata.setter
     def metadata(self, metadata):
 
         self.__metadata = metadata
 
     @property
     def data(self):
-        """`{ iam.v4.authn.CertAuthProvider | iam.v4.error.ErrorResponse }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+                :class:`~ntnx_iam_py_client.models.iam.v4.error.ErrorResponse`
+                    """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
         self.__data = data
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_iam_py_client.Ntnx, attr_type.split('.')[-1])
-                if hasattr(type, 'get_discriminator_from_object'):
-                    result[type.ONE_OF_ITEM_DISCRIMINATOR_NAME] = type.get_discriminator_from_object(value)
+                type = getattr(ntnx_iam_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(UpdateCertAuthProviderApiResponse, dict):
+        if issubclass(DeleteDirectoryServiceApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, UpdateCertAuthProviderApiResponse):
+        if not isinstance(other, DeleteDirectoryServiceApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/UpdateDirectoryServiceApiResponse.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/UpdateSystemConfigApiResponse.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,54 +1,54 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_iam_py_client.Ntnx
-from ntnx_iam_py_client.Ntnx.OneOfiam.v4.authn.UpdateDirectoryServiceApiResponsedata import UpdateDirectoryServiceApiResponsedata  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+from pathlib import Path
+import ntnx_iam_py_client.models
+from ntnx_iam_py_client.models.OneOfiam.v4.authn.UpdateSystemConfigApiResponsedata import UpdateSystemConfigApiResponsedata  # noqa: F401,E501
+from ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class UpdateSystemConfigApiResponse(object):
+
+    """REST response for all response codes in API path /iam/v4.0.b1/authn/system-config/{extId} Put operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
-
-Do not edit the class manually.
-IGNORE
-"""
-
-
-class UpdateDirectoryServiceApiResponse(object):
-    """UpdateDirectoryServiceApiResponse - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfiam.v4.authn.UpdateDirectoryServiceApiResponsedata',
+        'data': 'OneOfiam.v4.authn.UpdateSystemConfigApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -57,49 +57,46 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        """UpdateDirectoryServiceApiResponse - a model defined in Swagger
-            \nREST response for all response codes in api path /iam/v4.0.a1/authn/directory-services/{extId} Put operation
-        """
         self.__metadata = None
         self.__data = None
         self.discriminator = None
         if metadata is not None:
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'iam.v4.authn.UpdateDirectoryServiceApiResponse'
+        return 'iam.v4.authn.UpdateSystemConfigApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authn.UpdateDirectoryServiceApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -107,111 +104,132 @@
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def metadata(self):
-        """`{ common.v1.response.ApiResponseMetadata }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            :class:`~ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata`
+        """  # noqa: E501
         return self.__metadata
 
     @metadata.setter
     def metadata(self, metadata):
 
         self.__metadata = metadata
 
     @property
     def data(self):
-        """`{ iam.v4.authn.DirectoryService | iam.v4.error.ErrorResponse }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+                :class:`~ntnx_iam_py_client.models.iam.v4.authn.SystemConfig` | 
+                :class:`~ntnx_iam_py_client.models.iam.v4.error.ErrorResponse`
+                    """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
         self.__data = data
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_iam_py_client.Ntnx, attr_type.split('.')[-1])
-                if hasattr(type, 'get_discriminator_from_object'):
-                    result[type.ONE_OF_ITEM_DISCRIMINATOR_NAME] = type.get_discriminator_from_object(value)
+                type = getattr(ntnx_iam_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(UpdateDirectoryServiceApiResponse, dict):
+        if issubclass(UpdateSystemConfigApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, UpdateDirectoryServiceApiResponse):
+        if not isinstance(other, UpdateSystemConfigApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/UpdateSamlIdentityProviderApiResponse.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/DeleteUserApiResponse.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,54 +1,54 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_iam_py_client.Ntnx
-from ntnx_iam_py_client.Ntnx.OneOfiam.v4.authn.UpdateSamlIdentityProviderApiResponsedata import UpdateSamlIdentityProviderApiResponsedata  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+from pathlib import Path
+import ntnx_iam_py_client.models
+from ntnx_iam_py_client.models.OneOfiam.v4.authn.DeleteUserApiResponsedata import DeleteUserApiResponsedata  # noqa: F401,E501
+from ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class DeleteUserApiResponse(object):
+
+    """REST response for all response codes in API path /iam/v4.0.b1/authn/users/{extId} Delete operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
-
-Do not edit the class manually.
-IGNORE
-"""
-
-
-class UpdateSamlIdentityProviderApiResponse(object):
-    """UpdateSamlIdentityProviderApiResponse - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfiam.v4.authn.UpdateSamlIdentityProviderApiResponsedata',
+        'data': 'OneOfiam.v4.authn.DeleteUserApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -57,49 +57,46 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        """UpdateSamlIdentityProviderApiResponse - a model defined in Swagger
-            \nREST response for all response codes in api path /iam/v4.0.a1/authn/saml-identity-providers/{extId} Put operation
-        """
         self.__metadata = None
         self.__data = None
         self.discriminator = None
         if metadata is not None:
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'iam.v4.authn.UpdateSamlIdentityProviderApiResponse'
+        return 'iam.v4.authn.DeleteUserApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authn.UpdateSamlIdentityProviderApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -107,111 +104,131 @@
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def metadata(self):
-        """`{ common.v1.response.ApiResponseMetadata }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            :class:`~ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata`
+        """  # noqa: E501
         return self.__metadata
 
     @metadata.setter
     def metadata(self, metadata):
 
         self.__metadata = metadata
 
     @property
     def data(self):
-        """`{ iam.v4.authn.SamlIdentityProvider | iam.v4.error.ErrorResponse }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+                :class:`~ntnx_iam_py_client.models.iam.v4.error.ErrorResponse`
+                    """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
         self.__data = data
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_iam_py_client.Ntnx, attr_type.split('.')[-1])
-                if hasattr(type, 'get_discriminator_from_object'):
-                    result[type.ONE_OF_ITEM_DISCRIMINATOR_NAME] = type.get_discriminator_from_object(value)
+                type = getattr(ntnx_iam_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(UpdateSamlIdentityProviderApiResponse, dict):
+        if issubclass(DeleteUserApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, UpdateSamlIdentityProviderApiResponse):
+        if not isinstance(other, DeleteUserApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/UpdateUserApiResponse.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/DeleteUserKeyApiResponse.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,54 +1,54 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_iam_py_client.Ntnx
-from ntnx_iam_py_client.Ntnx.OneOfiam.v4.authn.UpdateUserApiResponsedata import UpdateUserApiResponsedata  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+from pathlib import Path
+import ntnx_iam_py_client.models
+from ntnx_iam_py_client.models.OneOfiam.v4.authn.DeleteUserKeyApiResponsedata import DeleteUserKeyApiResponsedata  # noqa: F401,E501
+from ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class DeleteUserKeyApiResponse(object):
+
+    """REST response for all response codes in API path /iam/v4.0.b1/authn/users/{userExtId}/buckets-access-keys/{extId} Delete operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
-
-Do not edit the class manually.
-IGNORE
-"""
-
-
-class UpdateUserApiResponse(object):
-    """UpdateUserApiResponse - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfiam.v4.authn.UpdateUserApiResponsedata',
+        'data': 'OneOfiam.v4.authn.DeleteUserKeyApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -57,49 +57,46 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        """UpdateUserApiResponse - a model defined in Swagger
-            \nREST response for all response codes in api path /iam/v4.0.a1/authn/users/{extId} Put operation
-        """
         self.__metadata = None
         self.__data = None
         self.discriminator = None
         if metadata is not None:
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'iam.v4.authn.UpdateUserApiResponse'
+        return 'iam.v4.authn.DeleteUserKeyApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authn.UpdateUserApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -107,111 +104,131 @@
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def metadata(self):
-        """`{ common.v1.response.ApiResponseMetadata }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            :class:`~ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata`
+        """  # noqa: E501
         return self.__metadata
 
     @metadata.setter
     def metadata(self, metadata):
 
         self.__metadata = metadata
 
     @property
     def data(self):
-        """`{ iam.v4.authn.User | iam.v4.error.ErrorResponse }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+                :class:`~ntnx_iam_py_client.models.iam.v4.error.ErrorResponse`
+                    """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
         self.__data = data
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_iam_py_client.Ntnx, attr_type.split('.')[-1])
-                if hasattr(type, 'get_discriminator_from_object'):
-                    result[type.ONE_OF_ITEM_DISCRIMINATOR_NAME] = type.get_discriminator_from_object(value)
+                type = getattr(ntnx_iam_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(UpdateUserApiResponse, dict):
+        if issubclass(DeleteUserKeyApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, UpdateUserApiResponse):
+        if not isinstance(other, DeleteUserKeyApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/User.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/AuthorizationPolicy.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,461 +1,404 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_iam_py_client.Ntnx.common.v1.config.KVPair import KVPair  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.iam.v4.authn.UserStatusType import UserStatusType  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.iam.v4.authn.UserType import UserType  # noqa: F401,E501
+from pathlib import Path
+from ntnx_iam_py_client.models.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
+from ntnx_iam_py_client.models.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel  # noqa: F401,E501
+from ntnx_iam_py_client.models.iam.v4.authz.AuthorizationPolicyType import AuthorizationPolicyType  # noqa: F401,E501
+from ntnx_iam_py_client.models.iam.v4.authz.EntityFilter import EntityFilter  # noqa: F401,E501
+from ntnx_iam_py_client.models.iam.v4.authz.IdentityFilter import IdentityFilter  # noqa: F401,E501
+
+class AuthorizationPolicy(ExternalizableAbstractModel):
+
+    """An Authorization Policy to define who can perform what Operation on which entity.
+
+    :param display_name: (:attr:`display_name`) The display name for the Authorization Policy.
+    :type display_name: 
+    :param description: (:attr:`description`) Description of the Authorization Policy.
+    :type description: 
+    :param client_name: (:attr:`client_name`) Client that created the entity.
+    :type client_name: 
+    :param identities: (:attr:`identities`) The identities for which the Authorization Policy is created.
+    :type identities: 
+    :param entities: (:attr:`entities`) The entities being qualified by the Authorization Policy.
+    :type entities: 
+    :param role: (:attr:`role`) The Role associated with the Authorization Policy.
+    :type role: 
+    :param created_time: (:attr:`created_time`) The creation time of the Authorization Policy.
+    :type created_time: 
+    :param last_updated_time: (:attr:`last_updated_time`) The time when the Authorization Policy was last updated.
+    :type last_updated_time: 
+    :param created_by: (:attr:`created_by`) User or Service Name that created the Authorization Policy.
+    :type created_by: 
+    :param is_system_defined: (:attr:`is_system_defined`) Flag identifying if the Authorization Policy is system defined or not. (**Default** True)
+    :type is_system_defined: 
+    :param authorization_policy_type: (:attr:`authorization_policy_type`) 
+    :type authorization_policy_type: 
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
-
-Do not edit the class manually.
-IGNORE
-"""
-
-
-class User(ExternalizableAbstractModel):
-    """User - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
-        'username': 'str',
-        'user_type': 'iam.v4.authn.UserType',
-        'idp_id': 'str',
         'display_name': 'str',
-        'first_name': 'str',
-        'middle_initial': 'str',
-        'last_name': 'str',
-        'email_id': 'str',
-        'locale': 'str',
-        'region': 'str',
-        'password': 'str',
-        'force_reset_password': 'bool',
-        'additional_attributes': 'list[common.v1.config.KVPair]',
-        'status': 'iam.v4.authn.UserStatusType',
-        'last_login_time': 'datetime',
+        'description': 'str',
+        'client_name': 'str',
+        'identities': 'list[iam.v4.authz.IdentityFilter]',
+        'entities': 'list[iam.v4.authz.EntityFilter]',
+        'role': 'str',
         'created_time': 'datetime',
         'last_updated_time': 'datetime',
         'created_by': 'str',
+        'is_system_defined': 'bool',
+        'authorization_policy_type': 'iam.v4.authz.AuthorizationPolicyType',
         'ext_id': 'str',
         'links': 'list[common.v1.response.ApiLink]',
         'tenant_id': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'username': 'username',
-        'user_type': 'userType',
-        'idp_id': 'idpId',
         'display_name': 'displayName',
-        'first_name': 'firstName',
-        'middle_initial': 'middleInitial',
-        'last_name': 'lastName',
-        'email_id': 'emailId',
-        'locale': 'locale',
-        'region': 'region',
-        'password': 'password',
-        'force_reset_password': 'forceResetPassword',
-        'additional_attributes': 'additionalAttributes',
-        'status': 'status',
-        'last_login_time': 'lastLoginTime',
+        'description': 'description',
+        'client_name': 'clientName',
+        'identities': 'identities',
+        'entities': 'entities',
+        'role': 'role',
         'created_time': 'createdTime',
         'last_updated_time': 'lastUpdatedTime',
         'created_by': 'createdBy',
+        'is_system_defined': 'isSystemDefined',
+        'authorization_policy_type': 'authorizationPolicyType',
         'ext_id': 'extId',
         'links': 'links',
         'tenant_id': 'tenantId',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, username=None, user_type=None, idp_id=None, display_name=None, first_name=None, middle_initial=None, last_name=None, email_id=None, locale=None, region=None, password=None, force_reset_password=None, additional_attributes=None, status=None, last_login_time=None, created_time=None, last_updated_time=None, created_by=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
-        """User - a model defined in Swagger
-            \nInformation of the user
-        """
+    def __init__(self, display_name=None, description=None, client_name=None, identities=None, entities=None, role=None, created_time=None, last_updated_time=None, created_by=None, is_system_defined=True, authorization_policy_type=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
         ExternalizableAbstractModel.__init__(self, ext_id, links, tenant_id, *args, **kwargs)
-        self.__username = None
-        self.__user_type = None
-        self.__idp_id = None
         self.__display_name = None
-        self.__first_name = None
-        self.__middle_initial = None
-        self.__last_name = None
-        self.__email_id = None
-        self.__locale = None
-        self.__region = None
-        self.__password = None
-        self.__force_reset_password = None
-        self.__additional_attributes = None
-        self.__status = None
-        self.__last_login_time = None
+        self.__description = None
+        self.__client_name = None
+        self.__identities = None
+        self.__entities = None
+        self.__role = None
         self.__created_time = None
         self.__last_updated_time = None
         self.__created_by = None
+        self.__is_system_defined = None
+        self.__authorization_policy_type = None
         self.discriminator = None
-        self.__username = username
-        self.__user_type = user_type
-        if idp_id is not None:
-            self.__idp_id = idp_id
         if display_name is not None:
             self.__display_name = display_name
-        if first_name is not None:
-            self.__first_name = first_name
-        if middle_initial is not None:
-            self.__middle_initial = middle_initial
-        if last_name is not None:
-            self.__last_name = last_name
-        if email_id is not None:
-            self.__email_id = email_id
-        if locale is not None:
-            self.__locale = locale
-        if region is not None:
-            self.__region = region
-        if password is not None:
-            self.__password = password
-        if force_reset_password is not None:
-            self.__force_reset_password = force_reset_password
-        if additional_attributes is not None:
-            self.__additional_attributes = additional_attributes
-        if status is not None:
-            self.__status = status
-        if last_login_time is not None:
-            self.__last_login_time = last_login_time
+        if description is not None:
+            self.__description = description
+        if client_name is not None:
+            self.__client_name = client_name
+        if identities is not None:
+            self.__identities = identities
+        if entities is not None:
+            self.__entities = entities
+        if role is not None:
+            self.__role = role
         if created_time is not None:
             self.__created_time = created_time
         if last_updated_time is not None:
             self.__last_updated_time = last_updated_time
         if created_by is not None:
             self.__created_by = created_by
+        if is_system_defined is not None:
+            self.__is_system_defined = is_system_defined
+        if authorization_policy_type is not None:
+            self.__authorization_policy_type = authorization_policy_type
 
     def _initialize_object_type(self):
-        return 'iam.v4.authn.User'
-
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authn.User'
-
-
-    @property
-    def username(self):
-        """`{ str }`
-            \nIdentifier for the user in the form an email address
-        """ # noqa: E501
-        return self.__username
-
-    @username.setter
-    def username(self, username):
-        if username is None:
-            raise ValueError("Invalid value for `username`, must not be `None`")  # noqa: E501
-        if username is not None and len(username) > 255:
-            raise ValueError("Invalid value for `username`, length must be less than or equal to `255`")  # noqa: E501
-        if username is not None and len(username) < 1:
-            raise ValueError("Invalid value for `username`, length must be greater than or equal to `1`")  # noqa: E501
-
-        self.__username = username
-
-    @property
-    def user_type(self):
-        """`{ iam.v4.authn.UserType }`
-            
-        """ # noqa: E501
-        return self.__user_type
+        return 'iam.v4.authz.AuthorizationPolicy'
 
-    @user_type.setter
-    def user_type(self, user_type):
-        if user_type is None:
-            raise ValueError("Invalid value for `user_type`, must not be `None`")  # noqa: E501
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
-        self.__user_type = user_type
 
     @property
-    def idp_id(self):
-        """`{ str }`
-            \nIdentifier of the IDP for the user
-        """ # noqa: E501
-        return self.__idp_id
-
-    @idp_id.setter
-    def idp_id(self, idp_id):
-        if idp_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', idp_id):  # noqa: E501
-            raise ValueError(r"Invalid value for `idp_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
+    def display_name(self):
+        """
+        The display name for the Authorization Policy.
 
-        self.__idp_id = idp_id
+        :type:
 
-    @property
-    def display_name(self):
-        """`{ str }`
-            \nDisplay name for the user
-        """ # noqa: E501
+                :class:`~str`
+        """  # noqa: E501
         return self.__display_name
 
     @display_name.setter
     def display_name(self, display_name):
         if display_name is not None and len(display_name) > 255:
             raise ValueError("Invalid value for `display_name`, length must be less than or equal to `255`")  # noqa: E501
+        if display_name is not None and len(display_name) < 1:
+            raise ValueError("Invalid value for `display_name`, length must be greater than or equal to `1`")  # noqa: E501
+        if display_name is not None and not re.search('^[^<>;\'()&+%\/\\\\\"`]*$', display_name):  # noqa: E501
+            raise ValueError(r"Invalid value for `display_name`, must be a follow pattern or equal to `/^[^<>;'()&+%\/\\\\\"`]*$/`")  # noqa: E501
 
         self.__display_name = display_name
 
     @property
-    def first_name(self):
-        """`{ str }`
-            \nFirst name for the user
-        """ # noqa: E501
-        return self.__first_name
-
-    @first_name.setter
-    def first_name(self, first_name):
-        if first_name is not None and len(first_name) > 255:
-            raise ValueError("Invalid value for `first_name`, length must be less than or equal to `255`")  # noqa: E501
+    def description(self):
+        """
+        Description of the Authorization Policy.
 
-        self.__first_name = first_name
+        :type:
 
-    @property
-    def middle_initial(self):
-        """`{ str }`
-            \nMiddle name for the user
-        """ # noqa: E501
-        return self.__middle_initial
+                :class:`~str`
+        """  # noqa: E501
+        return self.__description
 
-    @middle_initial.setter
-    def middle_initial(self, middle_initial):
-        if middle_initial is not None and len(middle_initial) > 255:
-            raise ValueError("Invalid value for `middle_initial`, length must be less than or equal to `255`")  # noqa: E501
+    @description.setter
+    def description(self, description):
+        if description is not None and len(description) > 1000:
+            raise ValueError("Invalid value for `description`, length must be less than or equal to `1000`")  # noqa: E501
+        if description is not None and not re.search('^[^<>;()&+%\/\\\\\"`]*$', description):  # noqa: E501
+            raise ValueError(r"Invalid value for `description`, must be a follow pattern or equal to `/^[^<>;()&+%\/\\\\\"`]*$/`")  # noqa: E501
 
-        self.__middle_initial = middle_initial
+        self.__description = description
 
     @property
-    def last_name(self):
-        """`{ str }`
-            \nLast name for the user
-        """ # noqa: E501
-        return self.__last_name
-
-    @last_name.setter
-    def last_name(self, last_name):
-        if last_name is not None and len(last_name) > 255:
-            raise ValueError("Invalid value for `last_name`, length must be less than or equal to `255`")  # noqa: E501
+    def client_name(self):
+        """
+        Client that created the entity.
 
-        self.__last_name = last_name
+        :type:
 
-    @property
-    def email_id(self):
-        """`{ str }`
-            \nEmail Id for the user
-        """ # noqa: E501
-        return self.__email_id
+                :class:`~str`
+        """  # noqa: E501
+        return self.__client_name
 
-    @email_id.setter
-    def email_id(self, email_id):
-        if email_id is not None and len(email_id) > 255:
-            raise ValueError("Invalid value for `email_id`, length must be less than or equal to `255`")  # noqa: E501
+    @client_name.setter
+    def client_name(self, client_name):
+        if client_name is not None and len(client_name) > 255:
+            raise ValueError("Invalid value for `client_name`, length must be less than or equal to `255`")  # noqa: E501
+        if client_name is not None and not re.search('^[^<>;\'()&+%\/\\\\\"`]*$', client_name):  # noqa: E501
+            raise ValueError(r"Invalid value for `client_name`, must be a follow pattern or equal to `/^[^<>;'()&+%\/\\\\\"`]*$/`")  # noqa: E501
 
-        self.__email_id = email_id
+        self.__client_name = client_name
 
     @property
-    def locale(self):
-        """`{ str }`
-            \nDefault locale for the user
-        """ # noqa: E501
-        return self.__locale
-
-    @locale.setter
-    def locale(self, locale):
-
-        self.__locale = locale
+    def identities(self):
+        """
+        The identities for which the Authorization Policy is created.
 
-    @property
-    def region(self):
-        """`{ str }`
-            \nDefault region for the user
-        """ # noqa: E501
-        return self.__region
+        :type:
+             list[ :class:`~ntnx_iam_py_client.models.iam.v4.authz.IdentityFilter` ]
+        """  # noqa: E501
+        return self.__identities
 
-    @region.setter
-    def region(self, region):
+    @identities.setter
+    def identities(self, identities):
 
-        self.__region = region
+        self.__identities = identities
 
     @property
-    def password(self):
-        """`{ str }`
-            \nPassword for the user
-        """ # noqa: E501
-        return self.__password
-
-    @password.setter
-    def password(self, password):
-
-        self.__password = password
+    def entities(self):
+        """
+        The entities being qualified by the Authorization Policy.
 
-    @property
-    def force_reset_password(self):
-        """`{ bool }`
-            \nFlag to force the user to reset password
-        """ # noqa: E501
-        return self.__force_reset_password
+        :type:
+             list[ :class:`~ntnx_iam_py_client.models.iam.v4.authz.EntityFilter` ]
+        """  # noqa: E501
+        return self.__entities
 
-    @force_reset_password.setter
-    def force_reset_password(self, force_reset_password):
+    @entities.setter
+    def entities(self, entities):
 
-        self.__force_reset_password = force_reset_password
+        self.__entities = entities
 
     @property
-    def additional_attributes(self):
-        """`{ list[common.v1.config.KVPair] }`
-            \nAny additional attribute for the user
-        """ # noqa: E501
-        return self.__additional_attributes
-
-    @additional_attributes.setter
-    def additional_attributes(self, additional_attributes):
+    def role(self):
+        """
+        The Role associated with the Authorization Policy.
 
-        self.__additional_attributes = additional_attributes
+        :type:
 
-    @property
-    def status(self):
-        """`{ iam.v4.authn.UserStatusType }`
-            
-        """ # noqa: E501
-        return self.__status
+                :class:`~str`
+        """  # noqa: E501
+        return self.__role
+
+    @role.setter
+    def role(self, role):
+        if role is not None and len(role) > 255:
+            raise ValueError("Invalid value for `role`, length must be less than or equal to `255`")  # noqa: E501
+        if role is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', role):  # noqa: E501
+            raise ValueError(r"Invalid value for `role`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
 
-    @status.setter
-    def status(self, status):
-
-        self.__status = status
+        self.__role = role
 
     @property
-    def last_login_time(self):
-        """`{ datetime }`
-            \nLast successful logged in time for the user
-        """ # noqa: E501
-        return self.__last_login_time
-
-    @last_login_time.setter
-    def last_login_time(self, last_login_time):
+    def created_time(self):
+        """
+        The creation time of the Authorization Policy.
 
-        self.__last_login_time = last_login_time
+        :type:
 
-    @property
-    def created_time(self):
-        """`{ datetime }`
-            \nCreation time of the user
-        """ # noqa: E501
+                :class:`~datetime`
+        """  # noqa: E501
         return self.__created_time
 
     @created_time.setter
     def created_time(self, created_time):
 
         self.__created_time = created_time
 
     @property
     def last_updated_time(self):
-        """`{ datetime }`
-            \nLast updated time of the user
-        """ # noqa: E501
+        """
+        The time when the Authorization Policy was last updated.
+
+        :type:
+
+                :class:`~datetime`
+        """  # noqa: E501
         return self.__last_updated_time
 
     @last_updated_time.setter
     def last_updated_time(self, last_updated_time):
 
         self.__last_updated_time = last_updated_time
 
     @property
     def created_by(self):
-        """`{ str }`
-            \nUser or service who created the user
-        """ # noqa: E501
+        """
+        User or Service Name that created the Authorization Policy.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__created_by
 
     @created_by.setter
     def created_by(self, created_by):
 
         self.__created_by = created_by
 
-    def _to_dict(self, sanitize):
+    @property
+    def is_system_defined(self):
+        """
+        Flag identifying if the Authorization Policy is system defined or not.
+
+        :type:
+
+                :class:`~bool`
+        """  # noqa: E501
+        return self.__is_system_defined
+
+    @is_system_defined.setter
+    def is_system_defined(self, is_system_defined):
+
+        self.__is_system_defined = is_system_defined
+
+    @property
+    def authorization_policy_type(self):
         """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        
+
+        :type:
+            :class:`~ntnx_iam_py_client.models.iam.v4.authz.AuthorizationPolicyType`
+        """  # noqa: E501
+        return self.__authorization_policy_type
+
+    @authorization_policy_type.setter
+    def authorization_policy_type(self, authorization_policy_type):
+
+        self.__authorization_policy_type = authorization_policy_type
+
+    def _to_dict(self, sanitize):
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(User, dict):
+        if issubclass(AuthorizationPolicy, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, User):
+        if not isinstance(other, AuthorizationPolicy):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/UserConfiguration.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/UserConfiguration.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,48 +1,50 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class UserConfiguration(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """User configuration for OpenLDAP Directory Service.
 
+    :param user_object_class: (:attr:`user_object_class`) Object class in the OpenLDAP system that corresponds to Users.
+    :type user_object_class: required
+    :param user_search_base: (:attr:`user_search_base`) Base DN for User search.
+    :type user_search_base: required
+    :param username_attribute: (:attr:`username_attribute`) Unique Identifier for each User which can be used in Authentication.
+    :type username_attribute: required
 
-class UserConfiguration(object):
-    """UserConfiguration - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'user_object_class': 'str',
         'user_search_base': 'str',
         'username_attribute': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
@@ -56,49 +58,46 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, user_object_class=None, user_search_base=None, username_attribute=None, *args, **kwargs):  # noqa: E501
-        """UserConfiguration - a model defined in Swagger
-            \nUser configuration for OpenLDAP directory service
-        """
         self.__user_object_class = None
         self.__user_search_base = None
         self.__username_attribute = None
         self.discriminator = None
         self.__user_object_class = user_object_class
         self.__user_search_base = user_search_base
         self.__username_attribute = username_attribute
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'iam.v4.authn.UserConfiguration'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authn.UserConfiguration'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -106,102 +105,130 @@
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def user_object_class(self):
-        """`{ str }`
-            \nObject class in the OpenLDAP system that corresponds to users
-        """ # noqa: E501
+        """
+        Object class in the OpenLDAP system that corresponds to Users.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__user_object_class
 
     @user_object_class.setter
     def user_object_class(self, user_object_class):
         if user_object_class is None:
             raise ValueError("Invalid value for `user_object_class`, must not be `None`")  # noqa: E501
         if user_object_class is not None and len(user_object_class) > 64:
             raise ValueError("Invalid value for `user_object_class`, length must be less than or equal to `64`")  # noqa: E501
 
         self.__user_object_class = user_object_class
 
     @property
     def user_search_base(self):
-        """`{ str }`
-            \nBase DN for user search
-        """ # noqa: E501
+        """
+        Base DN for User search.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__user_search_base
 
     @user_search_base.setter
     def user_search_base(self, user_search_base):
         if user_search_base is None:
             raise ValueError("Invalid value for `user_search_base`, must not be `None`")  # noqa: E501
         if user_search_base is not None and len(user_search_base) > 200:
             raise ValueError("Invalid value for `user_search_base`, length must be less than or equal to `200`")  # noqa: E501
 
         self.__user_search_base = user_search_base
 
     @property
     def username_attribute(self):
-        """`{ str }`
-            \nUnique identifier for each user which can be used in authentication
-        """ # noqa: E501
+        """
+        Unique Identifier for each User which can be used in Authentication.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__username_attribute
 
     @username_attribute.setter
     def username_attribute(self, username_attribute):
         if username_attribute is None:
             raise ValueError("Invalid value for `username_attribute`, must not be `None`")  # noqa: E501
         if username_attribute is not None and len(username_attribute) > 64:
             raise ValueError("Invalid value for `username_attribute`, length must be less than or equal to `64`")  # noqa: E501
 
         self.__username_attribute = username_attribute
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
@@ -209,15 +236,15 @@
         if issubclass(UserConfiguration, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/UserGroup.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/UserGroup.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,51 +1,61 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_iam_py_client.Ntnx.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.iam.v4.authn.GroupType import GroupType  # noqa: F401,E501
+from pathlib import Path
+from ntnx_iam_py_client.models.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
+from ntnx_iam_py_client.models.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel  # noqa: F401,E501
+from ntnx_iam_py_client.models.iam.v4.authn.GroupType import GroupType  # noqa: F401,E501
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class UserGroup(ExternalizableAbstractModel):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """Information of the User Group.
 
+    :param group_type: (:attr:`group_type`) 
+    :type group_type: 
+    :param idp_id: (:attr:`idp_id`) Identifier of the IDP for the User Group.
+    :type idp_id: 
+    :param name: (:attr:`name`) Common Name of the User Group.
+    :type name: 
+    :param distinguished_name: (:attr:`distinguished_name`) Identifier for the User Group in the form of a distinguished name.
+    :type distinguished_name: 
+    :param created_time: (:attr:`created_time`) Creation time of the User Group.
+    :type created_time: 
+    :param last_updated_time: (:attr:`last_updated_time`) Last updated time of the User Group.
+    :type last_updated_time: 
+    :param created_by: (:attr:`created_by`) User or Service who created the User Group.
+    :type created_by: 
 
-class UserGroup(ExternalizableAbstractModel):
-    """UserGroup - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'group_type': 'iam.v4.authn.GroupType',
         'idp_id': 'str',
         'name': 'str',
         'distinguished_name': 'str',
         'created_time': 'datetime',
         'last_updated_time': 'datetime',
@@ -73,17 +83,14 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, group_type=None, idp_id=None, name=None, distinguished_name=None, created_time=None, last_updated_time=None, created_by=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
-        """UserGroup - a model defined in Swagger
-            \nInformation of the user group
-        """
         ExternalizableAbstractModel.__init__(self, ext_id, links, tenant_id, *args, **kwargs)
         self.__group_type = None
         self.__idp_id = None
         self.__name = None
         self.__distinguished_name = None
         self.__created_time = None
         self.__last_updated_time = None
@@ -103,129 +110,166 @@
             self.__last_updated_time = last_updated_time
         if created_by is not None:
             self.__created_by = created_by
 
     def _initialize_object_type(self):
         return 'iam.v4.authn.UserGroup'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authn.UserGroup'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     @property
     def group_type(self):
-        """`{ iam.v4.authn.GroupType }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            :class:`~ntnx_iam_py_client.models.iam.v4.authn.GroupType`
+        """  # noqa: E501
         return self.__group_type
 
     @group_type.setter
     def group_type(self, group_type):
 
         self.__group_type = group_type
 
     @property
     def idp_id(self):
-        """`{ str }`
-            \nIdentifier of the IDP for the user group
-        """ # noqa: E501
+        """
+        Identifier of the IDP for the User Group.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__idp_id
 
     @idp_id.setter
     def idp_id(self, idp_id):
         if idp_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', idp_id):  # noqa: E501
             raise ValueError(r"Invalid value for `idp_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
 
         self.__idp_id = idp_id
 
     @property
     def name(self):
-        """`{ str }`
-            \nCommon name of the user group
-        """ # noqa: E501
+        """
+        Common Name of the User Group.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__name
 
     @name.setter
     def name(self, name):
         if name is not None and len(name) > 255:
             raise ValueError("Invalid value for `name`, length must be less than or equal to `255`")  # noqa: E501
+        if name is not None and not re.search('^[^<>;\'()&+%\/\\\\\"`]*$', name):  # noqa: E501
+            raise ValueError(r"Invalid value for `name`, must be a follow pattern or equal to `/^[^<>;'()&+%\/\\\\\"`]*$/`")  # noqa: E501
 
         self.__name = name
 
     @property
     def distinguished_name(self):
-        """`{ str }`
-            \nIdentifier for the user group in the form of a distinguished name
-        """ # noqa: E501
+        """
+        Identifier for the User Group in the form of a distinguished name.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__distinguished_name
 
     @distinguished_name.setter
     def distinguished_name(self, distinguished_name):
         if distinguished_name is not None and len(distinguished_name) > 255:
             raise ValueError("Invalid value for `distinguished_name`, length must be less than or equal to `255`")  # noqa: E501
+        if distinguished_name is not None and not re.search('^[^<>;\'()&+%\/\\\\\"`]*$', distinguished_name):  # noqa: E501
+            raise ValueError(r"Invalid value for `distinguished_name`, must be a follow pattern or equal to `/^[^<>;'()&+%\/\\\\\"`]*$/`")  # noqa: E501
 
         self.__distinguished_name = distinguished_name
 
     @property
     def created_time(self):
-        """`{ datetime }`
-            \nCreation time of the user group
-        """ # noqa: E501
+        """
+        Creation time of the User Group.
+
+        :type:
+
+                :class:`~datetime`
+        """  # noqa: E501
         return self.__created_time
 
     @created_time.setter
     def created_time(self, created_time):
 
         self.__created_time = created_time
 
     @property
     def last_updated_time(self):
-        """`{ datetime }`
-            \nLast updated time of the user group
-        """ # noqa: E501
+        """
+        Last updated time of the User Group.
+
+        :type:
+
+                :class:`~datetime`
+        """  # noqa: E501
         return self.__last_updated_time
 
     @last_updated_time.setter
     def last_updated_time(self, last_updated_time):
 
         self.__last_updated_time = last_updated_time
 
     @property
     def created_by(self):
-        """`{ str }`
-            \nUser or service who created the user group
-        """ # noqa: E501
+        """
+        User or Service who created the User Group.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__created_by
 
     @created_by.setter
     def created_by(self, created_by):
 
         self.__created_by = created_by
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
@@ -233,15 +277,15 @@
         if issubclass(UserGroup, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/UserGroupConfiguration.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/UserGroupConfiguration.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,48 +1,52 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class UserGroupConfiguration(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """User Group configuration for OpenLDAP Directory Service.
 
+    :param group_object_class: (:attr:`group_object_class`) Object class in the OpenLDAP system that corresponds to groups.
+    :type group_object_class: required
+    :param group_search_base: (:attr:`group_search_base`) Base DN for group search.
+    :type group_search_base: required
+    :param group_member_attribute: (:attr:`group_member_attribute`) Attribute in a group that associates Users to the group.
+    :type group_member_attribute: required
+    :param group_member_attribute_value: (:attr:`group_member_attribute_value`) User attribute value that will be used in group entity to associate User to the group.
+    :type group_member_attribute_value: required
 
-class UserGroupConfiguration(object):
-    """UserGroupConfiguration - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'group_object_class': 'str',
         'group_search_base': 'str',
         'group_member_attribute': 'str',
         'group_member_attribute_value': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
@@ -58,17 +62,14 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, group_object_class=None, group_search_base=None, group_member_attribute=None, group_member_attribute_value=None, *args, **kwargs):  # noqa: E501
-        """UserGroupConfiguration - a model defined in Swagger
-            \nUser group configuration for OpenLDAP directory service
-        """
         self.__group_object_class = None
         self.__group_search_base = None
         self.__group_member_attribute = None
         self.__group_member_attribute_value = None
         self.discriminator = None
         self.__group_object_class = group_object_class
         self.__group_search_base = group_search_base
@@ -76,33 +77,33 @@
         self.__group_member_attribute_value = group_member_attribute_value
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'iam.v4.authn.UserGroupConfiguration'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authn.UserGroupConfiguration'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -110,118 +111,150 @@
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def group_object_class(self):
-        """`{ str }`
-            \nObject class in the OpenLDAP system that corresponds to groups
-        """ # noqa: E501
+        """
+        Object class in the OpenLDAP system that corresponds to groups.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__group_object_class
 
     @group_object_class.setter
     def group_object_class(self, group_object_class):
         if group_object_class is None:
             raise ValueError("Invalid value for `group_object_class`, must not be `None`")  # noqa: E501
         if group_object_class is not None and len(group_object_class) > 64:
             raise ValueError("Invalid value for `group_object_class`, length must be less than or equal to `64`")  # noqa: E501
 
         self.__group_object_class = group_object_class
 
     @property
     def group_search_base(self):
-        """`{ str }`
-            \nBase DN for group search
-        """ # noqa: E501
+        """
+        Base DN for group search.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__group_search_base
 
     @group_search_base.setter
     def group_search_base(self, group_search_base):
         if group_search_base is None:
             raise ValueError("Invalid value for `group_search_base`, must not be `None`")  # noqa: E501
         if group_search_base is not None and len(group_search_base) > 200:
             raise ValueError("Invalid value for `group_search_base`, length must be less than or equal to `200`")  # noqa: E501
 
         self.__group_search_base = group_search_base
 
     @property
     def group_member_attribute(self):
-        """`{ str }`
-            \nAttribute in a group that associates users to the group
-        """ # noqa: E501
+        """
+        Attribute in a group that associates Users to the group.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__group_member_attribute
 
     @group_member_attribute.setter
     def group_member_attribute(self, group_member_attribute):
         if group_member_attribute is None:
             raise ValueError("Invalid value for `group_member_attribute`, must not be `None`")  # noqa: E501
         if group_member_attribute is not None and len(group_member_attribute) > 64:
             raise ValueError("Invalid value for `group_member_attribute`, length must be less than or equal to `64`")  # noqa: E501
 
         self.__group_member_attribute = group_member_attribute
 
     @property
     def group_member_attribute_value(self):
-        """`{ str }`
-            \nUser attribute value that will be used in group entity to associate user to the group
-        """ # noqa: E501
+        """
+        User attribute value that will be used in group entity to associate User to the group.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__group_member_attribute_value
 
     @group_member_attribute_value.setter
     def group_member_attribute_value(self, group_member_attribute_value):
         if group_member_attribute_value is None:
             raise ValueError("Invalid value for `group_member_attribute_value`, must not be `None`")  # noqa: E501
         if group_member_attribute_value is not None and len(group_member_attribute_value) > 64:
             raise ValueError("Invalid value for `group_member_attribute_value`, length must be less than or equal to `64`")  # noqa: E501
 
         self.__group_member_attribute_value = group_member_attribute_value
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
@@ -229,15 +262,15 @@
         if issubclass(UserGroupConfiguration, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/UserStateUpdate.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/UserStateUpdate.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,49 +1,47 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_iam_py_client.Ntnx.iam.v4.authn.UserStatusType import UserStatusType  # noqa: F401,E501
+from pathlib import Path
+from ntnx_iam_py_client.models.iam.v4.authn.UserStatusType import UserStatusType  # noqa: F401,E501
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class UserStateUpdate(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """Information to change state of User.
 
+    :param status: (:attr:`status`) 
+    :type status: required
 
-class UserStateUpdate(object):
-    """UserStateUpdate - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'status': 'iam.v4.authn.UserStatusType',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
@@ -53,45 +51,42 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, status=None, *args, **kwargs):  # noqa: E501
-        """UserStateUpdate - a model defined in Swagger
-            \nInformation to change state of user
-        """
         self.__status = None
         self.discriminator = None
         self.__status = status
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'iam.v4.authn.UserStateUpdate'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authn.UserStateUpdate'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -99,68 +94,87 @@
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def status(self):
-        """`{ iam.v4.authn.UserStatusType }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            :class:`~ntnx_iam_py_client.models.iam.v4.authn.UserStatusType`
+        """  # noqa: E501
         return self.__status
 
     @status.setter
     def status(self, status):
         if status is None:
             raise ValueError("Invalid value for `status`, must not be `None`")  # noqa: E501
 
         self.__status = status
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
@@ -168,15 +182,15 @@
         if issubclass(UserStateUpdate, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/UserStatusType.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/OperationType.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,150 +1,145 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class OperationType(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """The Operation type. Currently we support INTERNAL, EXTERNAL and SYSTEM_DEFINED_ONLY.
 
 
-class UserStatusType(object):
-
-    """
-    allowed enum values :
-
-    _UNKNOWN 
-
-    _REDACTED 
-
-    ACTIVE 
-
-    INACTIVE 
+    Allowed enum values:
 
+        - _UNKNOWN
+        - _REDACTED
+        - INTERNAL: This type of Operation will not be available to be consumed for Custom Role creation and will not be returned in GET/LIST API response.
+        - SYSTEM_DEFINED_ONLY: This type of Operation will not be available to be consumed for Custom Role creation but it will be returned in GET/LIST API response.
+        - EXTERNAL: This type of Operation will be available to be consumed for Custom Role creation and it will be returned in GET/LIST API response.
     """
     _UNKNOWN = "$UNKNOWN"
     _REDACTED = "$REDACTED"
-    ACTIVE = "ACTIVE"
-    INACTIVE = "INACTIVE"
+    INTERNAL = "INTERNAL"
+    SYSTEM_DEFINED_ONLY = "SYSTEM_DEFINED_ONLY"
+    EXTERNAL = "EXTERNAL"
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
-        """UserStatusType - a model defined in Swagger
-            \nStatus of the user
-        """
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'iam.v4.authn.UserStatusType'
+        return 'iam.v4.authz.OperationType'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authn.UserStatusType'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(UserStatusType, dict):
+        if issubclass(OperationType, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, UserStatusType):
+        if not isinstance(other, OperationType):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authn/UserType.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/KeyType.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,156 +1,141 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class KeyType(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """Type of OIDC key.
 
 
-class UserType(object):
-
-    """
-    allowed enum values :
-
-    _UNKNOWN 
-
-    _REDACTED 
-
-    LOCAL 
-
-    SAML 
-
-    LDAP 
-
-    EXTERNAL 
+    Allowed enum values:
 
+        - _UNKNOWN
+        - _REDACTED
+        - RSA
     """
     _UNKNOWN = "$UNKNOWN"
     _REDACTED = "$REDACTED"
-    LOCAL = "LOCAL"
-    SAML = "SAML"
-    LDAP = "LDAP"
-    EXTERNAL = "EXTERNAL"
+    RSA = "RSA"
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
-        """UserType - a model defined in Swagger
-            \nType of the user
-        """
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'iam.v4.authn.UserType'
+        return 'iam.v4.authn.KeyType'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authn.UserType'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(UserType, dict):
+        if issubclass(KeyType, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, UserType):
+        if not isinstance(other, KeyType):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authz/AccessPolicy.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/Operation.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,337 +1,355 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_iam_py_client.Ntnx.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.iam.v4.authz.AccessPolicyType import AccessPolicyType  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.iam.v4.authz.Filter import Filter  # noqa: F401,E501
+from pathlib import Path
+from ntnx_iam_py_client.models.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
+from ntnx_iam_py_client.models.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel  # noqa: F401,E501
+from ntnx_iam_py_client.models.iam.v4.authz.AssociatedEndpoint import AssociatedEndpoint  # noqa: F401,E501
+from ntnx_iam_py_client.models.iam.v4.authz.OperationType import OperationType  # noqa: F401,E501
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class Operation(ExternalizableAbstractModel):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """
 
+    :param display_name: (:attr:`display_name`) Name of the Operation.
+    :type display_name: 
+    :param description: (:attr:`description`) Description of the Operation.
+    :type description: 
+    :param entity_type: (:attr:`entity_type`) Type of entity associated with this Operation.
+    :type entity_type: 
+    :param client_name: (:attr:`client_name`) Client that created the entity.
+    :type client_name: 
+    :param created_time: (:attr:`created_time`) The creation time of the Operation.
+    :type created_time: 
+    :param last_updated_time: (:attr:`last_updated_time`) The time when the Operation was last updated.
+    :type last_updated_time: 
+    :param operation_type: (:attr:`operation_type`) 
+    :type operation_type: 
+    :param related_operation_list: (:attr:`related_operation_list`) List of related Operations. These are the Operations which might need to be given access to, along with the current Operation, for certain workflows to succeed.
+    :type related_operation_list: 
+    :param associated_endpoint_list: (:attr:`associated_endpoint_list`) List of associated endpoint objects for the Operation.
+    :type associated_endpoint_list: 
 
-class AccessPolicy(ExternalizableAbstractModel):
-    """AccessPolicy - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'display_name': 'str',
         'description': 'str',
+        'entity_type': 'str',
         'client_name': 'str',
-        'identities': 'list[iam.v4.authz.Filter]',
-        'objects': 'list[iam.v4.authz.Filter]',
-        'role': 'str',
         'created_time': 'datetime',
         'last_updated_time': 'datetime',
-        'created_by': 'str',
-        'is_system_defined': 'bool',
-        'access_policy_type': 'iam.v4.authz.AccessPolicyType',
+        'operation_type': 'iam.v4.authz.OperationType',
+        'related_operation_list': 'list[str]',
+        'associated_endpoint_list': 'list[iam.v4.authz.AssociatedEndpoint]',
         'ext_id': 'str',
         'links': 'list[common.v1.response.ApiLink]',
         'tenant_id': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'display_name': 'displayName',
         'description': 'description',
+        'entity_type': 'entityType',
         'client_name': 'clientName',
-        'identities': 'identities',
-        'objects': 'objects',
-        'role': 'role',
         'created_time': 'createdTime',
         'last_updated_time': 'lastUpdatedTime',
-        'created_by': 'createdBy',
-        'is_system_defined': 'isSystemDefined',
-        'access_policy_type': 'accessPolicyType',
+        'operation_type': 'operationType',
+        'related_operation_list': 'relatedOperationList',
+        'associated_endpoint_list': 'associatedEndpointList',
         'ext_id': 'extId',
         'links': 'links',
         'tenant_id': 'tenantId',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, display_name=None, description=None, client_name=None, identities=None, objects=None, role=None, created_time=None, last_updated_time=None, created_by=None, is_system_defined=True, access_policy_type=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
-        """AccessPolicy - a model defined in Swagger
-            \nAn access policy to define who can perform what operation on which object
-        """
+    def __init__(self, display_name=None, description=None, entity_type=None, client_name=None, created_time=None, last_updated_time=None, operation_type=None, related_operation_list=None, associated_endpoint_list=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
         ExternalizableAbstractModel.__init__(self, ext_id, links, tenant_id, *args, **kwargs)
         self.__display_name = None
         self.__description = None
+        self.__entity_type = None
         self.__client_name = None
-        self.__identities = None
-        self.__objects = None
-        self.__role = None
         self.__created_time = None
         self.__last_updated_time = None
-        self.__created_by = None
-        self.__is_system_defined = None
-        self.__access_policy_type = None
+        self.__operation_type = None
+        self.__related_operation_list = None
+        self.__associated_endpoint_list = None
         self.discriminator = None
         if display_name is not None:
             self.__display_name = display_name
         if description is not None:
             self.__description = description
+        if entity_type is not None:
+            self.__entity_type = entity_type
         if client_name is not None:
             self.__client_name = client_name
-        if identities is not None:
-            self.__identities = identities
-        if objects is not None:
-            self.__objects = objects
-        if role is not None:
-            self.__role = role
         if created_time is not None:
             self.__created_time = created_time
         if last_updated_time is not None:
             self.__last_updated_time = last_updated_time
-        if created_by is not None:
-            self.__created_by = created_by
-        if is_system_defined is not None:
-            self.__is_system_defined = is_system_defined
-        if access_policy_type is not None:
-            self.__access_policy_type = access_policy_type
+        if operation_type is not None:
+            self.__operation_type = operation_type
+        if related_operation_list is not None:
+            self.__related_operation_list = related_operation_list
+        if associated_endpoint_list is not None:
+            self.__associated_endpoint_list = associated_endpoint_list
 
     def _initialize_object_type(self):
-        return 'iam.v4.authz.AccessPolicy'
+        return 'iam.v4.authz.Operation'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authz.AccessPolicy'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     @property
     def display_name(self):
-        """`{ str }`
-            \nThe display name for the access policy
-        """ # noqa: E501
+        """
+        Name of the Operation.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__display_name
 
     @display_name.setter
     def display_name(self, display_name):
         if display_name is not None and len(display_name) > 255:
             raise ValueError("Invalid value for `display_name`, length must be less than or equal to `255`")  # noqa: E501
         if display_name is not None and len(display_name) < 1:
             raise ValueError("Invalid value for `display_name`, length must be greater than or equal to `1`")  # noqa: E501
-        if display_name is not None and not re.search('^[^\\\"]*$', display_name):  # noqa: E501
-            raise ValueError(r"Invalid value for `display_name`, must be a follow pattern or equal to `/^[^\\\"]*$/`")  # noqa: E501
+        if display_name is not None and not re.search('^[^<>;\'()&+%\/\\\\\"`]*$', display_name):  # noqa: E501
+            raise ValueError(r"Invalid value for `display_name`, must be a follow pattern or equal to `/^[^<>;'()&+%\/\\\\\"`]*$/`")  # noqa: E501
 
         self.__display_name = display_name
 
     @property
     def description(self):
-        """`{ str }`
-            \nDescription of the access policy
-        """ # noqa: E501
+        """
+        Description of the Operation.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__description
 
     @description.setter
     def description(self, description):
         if description is not None and len(description) > 1000:
             raise ValueError("Invalid value for `description`, length must be less than or equal to `1000`")  # noqa: E501
+        if description is not None and not re.search('^[^<>;()&+%\/\\\\\"`]*$', description):  # noqa: E501
+            raise ValueError(r"Invalid value for `description`, must be a follow pattern or equal to `/^[^<>;()&+%\/\\\\\"`]*$/`")  # noqa: E501
 
         self.__description = description
 
     @property
-    def client_name(self):
-        """`{ str }`
-            \nClient that created the access policy
-        """ # noqa: E501
-        return self.__client_name
-
-    @client_name.setter
-    def client_name(self, client_name):
-        if client_name is not None and len(client_name) > 255:
-            raise ValueError("Invalid value for `client_name`, length must be less than or equal to `255`")  # noqa: E501
+    def entity_type(self):
+        """
+        Type of entity associated with this Operation.
 
-        self.__client_name = client_name
+        :type:
 
-    @property
-    def identities(self):
-        """`{ list[iam.v4.authz.Filter] }`
-            \nThe identities for which the access policy is created
-        """ # noqa: E501
-        return self.__identities
+                :class:`~str`
+        """  # noqa: E501
+        return self.__entity_type
 
-    @identities.setter
-    def identities(self, identities):
+    @entity_type.setter
+    def entity_type(self, entity_type):
+        if entity_type is not None and not re.search('^[^<>;\'()&+%\/\\\\\"`]*$', entity_type):  # noqa: E501
+            raise ValueError(r"Invalid value for `entity_type`, must be a follow pattern or equal to `/^[^<>;'()&+%\/\\\\\"`]*$/`")  # noqa: E501
 
-        self.__identities = identities
+        self.__entity_type = entity_type
 
     @property
-    def objects(self):
-        """`{ list[iam.v4.authz.Filter] }`
-            \nThe objects being qualified by the access policy
-        """ # noqa: E501
-        return self.__objects
+    def client_name(self):
+        """
+        Client that created the entity.
 
-    @objects.setter
-    def objects(self, objects):
+        :type:
 
-        self.__objects = objects
+                :class:`~str`
+        """  # noqa: E501
+        return self.__client_name
 
-    @property
-    def role(self):
-        """`{ str }`
-            \nThe role associated with the access policy
-        """ # noqa: E501
-        return self.__role
-
-    @role.setter
-    def role(self, role):
-        if role is not None and len(role) > 255:
-            raise ValueError("Invalid value for `role`, length must be less than or equal to `255`")  # noqa: E501
-        if role is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', role):  # noqa: E501
-            raise ValueError(r"Invalid value for `role`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
+    @client_name.setter
+    def client_name(self, client_name):
+        if client_name is not None and len(client_name) > 255:
+            raise ValueError("Invalid value for `client_name`, length must be less than or equal to `255`")  # noqa: E501
+        if client_name is not None and not re.search('^[^<>;\'()&+%\/\\\\\"`]*$', client_name):  # noqa: E501
+            raise ValueError(r"Invalid value for `client_name`, must be a follow pattern or equal to `/^[^<>;'()&+%\/\\\\\"`]*$/`")  # noqa: E501
 
-        self.__role = role
+        self.__client_name = client_name
 
     @property
     def created_time(self):
-        """`{ datetime }`
-            \nThe creation time of the access policy
-        """ # noqa: E501
+        """
+        The creation time of the Operation.
+
+        :type:
+
+                :class:`~datetime`
+        """  # noqa: E501
         return self.__created_time
 
     @created_time.setter
     def created_time(self, created_time):
 
         self.__created_time = created_time
 
     @property
     def last_updated_time(self):
-        """`{ datetime }`
-            \nThe time when the access policy was last updated
-        """ # noqa: E501
+        """
+        The time when the Operation was last updated.
+
+        :type:
+
+                :class:`~datetime`
+        """  # noqa: E501
         return self.__last_updated_time
 
     @last_updated_time.setter
     def last_updated_time(self, last_updated_time):
 
         self.__last_updated_time = last_updated_time
 
     @property
-    def created_by(self):
-        """`{ str }`
-            \nUser or service name that created the access policy
-        """ # noqa: E501
-        return self.__created_by
+    def operation_type(self):
+        """
+        
 
-    @created_by.setter
-    def created_by(self, created_by):
+        :type:
+            :class:`~ntnx_iam_py_client.models.iam.v4.authz.OperationType`
+        """  # noqa: E501
+        return self.__operation_type
 
-        self.__created_by = created_by
+    @operation_type.setter
+    def operation_type(self, operation_type):
+
+        self.__operation_type = operation_type
 
     @property
-    def is_system_defined(self):
-        """`{ bool }`
-            \nFlag identifying if the access policy is system defined or not
-        """ # noqa: E501
-        return self.__is_system_defined
+    def related_operation_list(self):
+        """
+        List of related Operations. These are the Operations which might need to be given access to, along with the current Operation, for certain workflows to succeed.
+
+        :type:
+            list[ :class:`~str` ]
+        """  # noqa: E501
+        return self.__related_operation_list
 
-    @is_system_defined.setter
-    def is_system_defined(self, is_system_defined):
+    @related_operation_list.setter
+    def related_operation_list(self, related_operation_list):
 
-        self.__is_system_defined = is_system_defined
+        self.__related_operation_list = related_operation_list
 
     @property
-    def access_policy_type(self):
-        """`{ iam.v4.authz.AccessPolicyType }`
-            
-        """ # noqa: E501
-        return self.__access_policy_type
+    def associated_endpoint_list(self):
+        """
+        List of associated endpoint objects for the Operation.
+
+        :type:
+             list[ :class:`~ntnx_iam_py_client.models.iam.v4.authz.AssociatedEndpoint` ]
+        """  # noqa: E501
+        return self.__associated_endpoint_list
 
-    @access_policy_type.setter
-    def access_policy_type(self, access_policy_type):
+    @associated_endpoint_list.setter
+    def associated_endpoint_list(self, associated_endpoint_list):
 
-        self.__access_policy_type = access_policy_type
+        self.__associated_endpoint_list = associated_endpoint_list
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(AccessPolicy, dict):
+        if issubclass(Operation, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, AccessPolicy):
+        if not isinstance(other, Operation):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authz/AccessPolicyType.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/EntityOperators.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,159 +1,149 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
-
-Do not edit the class manually.
-IGNORE
-"""
-
-
-class AccessPolicyType(object):
-
-    """
-    allowed enum values :
-
-    _UNKNOWN 
-
-    _REDACTED 
-
-    USER_DEFINED 
+class EntityOperators(object):
 
-    SERVICE_DEFINED 
+    """Type of Authorization Policy.
 
-    PREDEFINED_READ_ONLY 
 
-    PREDEFINED_UPDATE_IDENTITY_ONLY 
-
-    SERVICE_DEFINED_READ_ONLY 
+    Allowed enum values:
 
+        - _UNKNOWN
+        - _REDACTED
+        - ALLOF
+        - ANYOF
+        - EQ
+        - NONEOF
+        - NOTEQ
     """
     _UNKNOWN = "$UNKNOWN"
     _REDACTED = "$REDACTED"
-    USER_DEFINED = "USER_DEFINED"
-    SERVICE_DEFINED = "SERVICE_DEFINED"
-    PREDEFINED_READ_ONLY = "PREDEFINED_READ_ONLY"
-    PREDEFINED_UPDATE_IDENTITY_ONLY = "PREDEFINED_UPDATE_IDENTITY_ONLY"
-    SERVICE_DEFINED_READ_ONLY = "SERVICE_DEFINED_READ_ONLY"
+    ALLOF = "ALLOF"
+    ANYOF = "ANYOF"
+    EQ = "EQ"
+    NONEOF = "NONEOF"
+    NOTEQ = "NOTEQ"
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
-        """AccessPolicyType - a model defined in Swagger
-            \nType of access policy
-        """
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'iam.v4.authz.AccessPolicyType'
+        return 'iam.v4.authz.EntityOperators'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authz.AccessPolicyType'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(AccessPolicyType, dict):
+        if issubclass(EntityOperators, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, AccessPolicyType):
+        if not isinstance(other, EntityOperators):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authz/CreateAccessPolicyApiResponse.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/GetAuthorizationPolicyApiResponse.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,54 +1,54 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_iam_py_client.Ntnx
-from ntnx_iam_py_client.Ntnx.OneOfiam.v4.authz.CreateAccessPolicyApiResponsedata import CreateAccessPolicyApiResponsedata  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+from pathlib import Path
+import ntnx_iam_py_client.models
+from ntnx_iam_py_client.models.OneOfiam.v4.authz.GetAuthorizationPolicyApiResponsedata import GetAuthorizationPolicyApiResponsedata  # noqa: F401,E501
+from ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class GetAuthorizationPolicyApiResponse(object):
+
+    """REST response for all response codes in API path /iam/v4.0.b1/authz/authorization-policies/{extId} Get operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
-
-Do not edit the class manually.
-IGNORE
-"""
-
-
-class CreateAccessPolicyApiResponse(object):
-    """CreateAccessPolicyApiResponse - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfiam.v4.authz.CreateAccessPolicyApiResponsedata',
+        'data': 'OneOfiam.v4.authz.GetAuthorizationPolicyApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -57,49 +57,46 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        """CreateAccessPolicyApiResponse - a model defined in Swagger
-            \nREST response for all response codes in api path /iam/v4.0.a1/authz/accessPolicies Post operation
-        """
         self.__metadata = None
         self.__data = None
         self.discriminator = None
         if metadata is not None:
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'iam.v4.authz.CreateAccessPolicyApiResponse'
+        return 'iam.v4.authz.GetAuthorizationPolicyApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authz.CreateAccessPolicyApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -107,111 +104,132 @@
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def metadata(self):
-        """`{ common.v1.response.ApiResponseMetadata }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            :class:`~ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata`
+        """  # noqa: E501
         return self.__metadata
 
     @metadata.setter
     def metadata(self, metadata):
 
         self.__metadata = metadata
 
     @property
     def data(self):
-        """`{ common.v1.config.Message | iam.v4.error.ErrorResponse }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+                :class:`~ntnx_iam_py_client.models.iam.v4.authz.AuthorizationPolicy` | 
+                :class:`~ntnx_iam_py_client.models.iam.v4.error.ErrorResponse`
+                    """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
         self.__data = data
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_iam_py_client.Ntnx, attr_type.split('.')[-1])
-                if hasattr(type, 'get_discriminator_from_object'):
-                    result[type.ONE_OF_ITEM_DISCRIMINATOR_NAME] = type.get_discriminator_from_object(value)
+                type = getattr(ntnx_iam_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(CreateAccessPolicyApiResponse, dict):
+        if issubclass(GetAuthorizationPolicyApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, CreateAccessPolicyApiResponse):
+        if not isinstance(other, GetAuthorizationPolicyApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authz/CreateRoleApiResponse.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/UpdateClientApiResponse.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,54 +1,54 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_iam_py_client.Ntnx
-from ntnx_iam_py_client.Ntnx.OneOfiam.v4.authz.CreateRoleApiResponsedata import CreateRoleApiResponsedata  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+from pathlib import Path
+import ntnx_iam_py_client.models
+from ntnx_iam_py_client.models.OneOfiam.v4.authz.UpdateClientApiResponsedata import UpdateClientApiResponsedata  # noqa: F401,E501
+from ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class UpdateClientApiResponse(object):
+
+    """REST response for all response codes in API path /iam/v4.0.b1/authz/clients/{extId} Put operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
-
-Do not edit the class manually.
-IGNORE
-"""
-
-
-class CreateRoleApiResponse(object):
-    """CreateRoleApiResponse - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfiam.v4.authz.CreateRoleApiResponsedata',
+        'data': 'OneOfiam.v4.authz.UpdateClientApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -57,49 +57,46 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        """CreateRoleApiResponse - a model defined in Swagger
-            \nREST response for all response codes in api path /iam/v4.0.a1/authz/roles Post operation
-        """
         self.__metadata = None
         self.__data = None
         self.discriminator = None
         if metadata is not None:
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'iam.v4.authz.CreateRoleApiResponse'
+        return 'iam.v4.authz.UpdateClientApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authz.CreateRoleApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -107,111 +104,132 @@
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def metadata(self):
-        """`{ common.v1.response.ApiResponseMetadata }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            :class:`~ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata`
+        """  # noqa: E501
         return self.__metadata
 
     @metadata.setter
     def metadata(self, metadata):
 
         self.__metadata = metadata
 
     @property
     def data(self):
-        """`{ common.v1.config.Message | iam.v4.error.ErrorResponse }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+                :class:`~ntnx_iam_py_client.models.common.v1.config.Message` | 
+                :class:`~ntnx_iam_py_client.models.iam.v4.error.ErrorResponse`
+                    """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
         self.__data = data
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_iam_py_client.Ntnx, attr_type.split('.')[-1])
-                if hasattr(type, 'get_discriminator_from_object'):
-                    result[type.ONE_OF_ITEM_DISCRIMINATOR_NAME] = type.get_discriminator_from_object(value)
+                type = getattr(ntnx_iam_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(CreateRoleApiResponse, dict):
+        if issubclass(UpdateClientApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, CreateRoleApiResponse):
+        if not isinstance(other, UpdateClientApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authz/DeleteAccessPolicyApiResponse.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/DeleteServiceAccountKeyApiResponse.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,54 +1,54 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_iam_py_client.Ntnx
-from ntnx_iam_py_client.Ntnx.OneOfiam.v4.authz.DeleteAccessPolicyApiResponsedata import DeleteAccessPolicyApiResponsedata  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+from pathlib import Path
+import ntnx_iam_py_client.models
+from ntnx_iam_py_client.models.OneOfiam.v4.authn.DeleteServiceAccountKeyApiResponsedata import DeleteServiceAccountKeyApiResponsedata  # noqa: F401,E501
+from ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class DeleteServiceAccountKeyApiResponse(object):
+
+    """REST response for all response codes in API path /iam/v4.0.b1/authn/service-accounts/{svcAccExtId}/access-keys/{extId} Delete operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
-
-Do not edit the class manually.
-IGNORE
-"""
-
-
-class DeleteAccessPolicyApiResponse(object):
-    """DeleteAccessPolicyApiResponse - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfiam.v4.authz.DeleteAccessPolicyApiResponsedata',
+        'data': 'OneOfiam.v4.authn.DeleteServiceAccountKeyApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -57,49 +57,46 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        """DeleteAccessPolicyApiResponse - a model defined in Swagger
-            \nREST response for all response codes in api path /iam/v4.0.a1/authz/accessPolicies/{extId} Delete operation
-        """
         self.__metadata = None
         self.__data = None
         self.discriminator = None
         if metadata is not None:
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'iam.v4.authz.DeleteAccessPolicyApiResponse'
+        return 'iam.v4.authn.DeleteServiceAccountKeyApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authz.DeleteAccessPolicyApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -107,111 +104,131 @@
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def metadata(self):
-        """`{ common.v1.response.ApiResponseMetadata }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            :class:`~ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata`
+        """  # noqa: E501
         return self.__metadata
 
     @metadata.setter
     def metadata(self, metadata):
 
         self.__metadata = metadata
 
     @property
     def data(self):
-        """`{ iam.v4.error.ErrorResponse }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+                :class:`~ntnx_iam_py_client.models.iam.v4.error.ErrorResponse`
+                    """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
         self.__data = data
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_iam_py_client.Ntnx, attr_type.split('.')[-1])
-                if hasattr(type, 'get_discriminator_from_object'):
-                    result[type.ONE_OF_ITEM_DISCRIMINATOR_NAME] = type.get_discriminator_from_object(value)
+                type = getattr(ntnx_iam_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(DeleteAccessPolicyApiResponse, dict):
+        if issubclass(DeleteServiceAccountKeyApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, DeleteAccessPolicyApiResponse):
+        if not isinstance(other, DeleteServiceAccountKeyApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authz/DeleteRoleApiResponse.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/DeleteSystemConfigApiResponse.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,54 +1,54 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_iam_py_client.Ntnx
-from ntnx_iam_py_client.Ntnx.OneOfiam.v4.authz.DeleteRoleApiResponsedata import DeleteRoleApiResponsedata  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+from pathlib import Path
+import ntnx_iam_py_client.models
+from ntnx_iam_py_client.models.OneOfiam.v4.authn.DeleteSystemConfigApiResponsedata import DeleteSystemConfigApiResponsedata  # noqa: F401,E501
+from ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class DeleteSystemConfigApiResponse(object):
+
+    """REST response for all response codes in API path /iam/v4.0.b1/authn/system-config/{extId} Delete operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
-
-Do not edit the class manually.
-IGNORE
-"""
-
-
-class DeleteRoleApiResponse(object):
-    """DeleteRoleApiResponse - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfiam.v4.authz.DeleteRoleApiResponsedata',
+        'data': 'OneOfiam.v4.authn.DeleteSystemConfigApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -57,49 +57,46 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        """DeleteRoleApiResponse - a model defined in Swagger
-            \nREST response for all response codes in api path /iam/v4.0.a1/authz/roles/{extId} Delete operation
-        """
         self.__metadata = None
         self.__data = None
         self.discriminator = None
         if metadata is not None:
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'iam.v4.authz.DeleteRoleApiResponse'
+        return 'iam.v4.authn.DeleteSystemConfigApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authz.DeleteRoleApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -107,111 +104,131 @@
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def metadata(self):
-        """`{ common.v1.response.ApiResponseMetadata }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            :class:`~ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata`
+        """  # noqa: E501
         return self.__metadata
 
     @metadata.setter
     def metadata(self, metadata):
 
         self.__metadata = metadata
 
     @property
     def data(self):
-        """`{ iam.v4.error.ErrorResponse }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+                :class:`~ntnx_iam_py_client.models.iam.v4.error.ErrorResponse`
+                    """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
         self.__data = data
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_iam_py_client.Ntnx, attr_type.split('.')[-1])
-                if hasattr(type, 'get_discriminator_from_object'):
-                    result[type.ONE_OF_ITEM_DISCRIMINATOR_NAME] = type.get_discriminator_from_object(value)
+                type = getattr(ntnx_iam_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(DeleteRoleApiResponse, dict):
+        if issubclass(DeleteSystemConfigApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, DeleteRoleApiResponse):
+        if not isinstance(other, DeleteSystemConfigApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authz/Filter.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/ResponseType.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,176 +1,143 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class ResponseType(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """Type of response expected.
 
 
-class Filter(object):
-    """Filter - a model defined in Swagger"""
-    """
-    IGNORE:
-    Attributes:
-      swagger_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-    IGNORE
-    """ # noqa: E501
-    swagger_types = {
-        '_reserved': 'dict(str, object)',
-        '_unknown_fields': 'dict(str, object)',
-        '_object_type': 'str',
-    }
-
-    attribute_map = {
-        '_reserved': '$reserved',
-        '_unknown_fields': '$unknownFields',
-        '_object_type': '$objectType',
-    }
+    Allowed enum values:
 
+        - _UNKNOWN
+        - _REDACTED
+        - BOOLEANRESPONSE
+        - FILTERRESPONSE
+    """
+    _UNKNOWN = "$UNKNOWN"
+    _REDACTED = "$REDACTED"
+    BOOLEANRESPONSE = "BooleanResponse"
+    FILTERRESPONSE = "FilterResponse"
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
-        """Filter - a model defined in Swagger
-            
-        """
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'iam.v4.authz.Filter'
+        return 'iam.v4.authz.ResponseType'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authz.Filter'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
-    @property
-    def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
-        return self.__dollar_reserved
-
-    @property
-    def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
-        return self.__dollar_unknown_fields
-
-    @property
-    def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
-        return self.__dollar_object_type
-
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(Filter, dict):
+        if issubclass(ResponseType, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, Filter):
+        if not isinstance(other, ResponseType):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authz/ListAccessPolicyApiResponse.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authz/GetRoleApiResponse.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,54 +1,54 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_iam_py_client.Ntnx
-from ntnx_iam_py_client.Ntnx.OneOfiam.v4.authz.ListAccessPolicyApiResponsedata import ListAccessPolicyApiResponsedata  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+from pathlib import Path
+import ntnx_iam_py_client.models
+from ntnx_iam_py_client.models.OneOfiam.v4.authz.GetRoleApiResponsedata import GetRoleApiResponsedata  # noqa: F401,E501
+from ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class GetRoleApiResponse(object):
+
+    """REST response for all response codes in API path /iam/v4.0.b1/authz/roles/{extId} Get operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
-
-Do not edit the class manually.
-IGNORE
-"""
-
-
-class ListAccessPolicyApiResponse(object):
-    """ListAccessPolicyApiResponse - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfiam.v4.authz.ListAccessPolicyApiResponsedata',
+        'data': 'OneOfiam.v4.authz.GetRoleApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -57,49 +57,46 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        """ListAccessPolicyApiResponse - a model defined in Swagger
-            \nREST response for all response codes in api path /iam/v4.0.a1/authz/accessPolicies Get operation
-        """
         self.__metadata = None
         self.__data = None
         self.discriminator = None
         if metadata is not None:
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'iam.v4.authz.ListAccessPolicyApiResponse'
+        return 'iam.v4.authz.GetRoleApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authz.ListAccessPolicyApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -107,111 +104,132 @@
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def metadata(self):
-        """`{ common.v1.response.ApiResponseMetadata }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            :class:`~ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata`
+        """  # noqa: E501
         return self.__metadata
 
     @metadata.setter
     def metadata(self, metadata):
 
         self.__metadata = metadata
 
     @property
     def data(self):
-        """`{ list[iam.v4.authz.AccessPolicy] | iam.v4.error.ErrorResponse }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+                :class:`~ntnx_iam_py_client.models.iam.v4.authz.Role` | 
+                :class:`~ntnx_iam_py_client.models.iam.v4.error.ErrorResponse`
+                    """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
         self.__data = data
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_iam_py_client.Ntnx, attr_type.split('.')[-1])
-                if hasattr(type, 'get_discriminator_from_object'):
-                    result[type.ONE_OF_ITEM_DISCRIMINATOR_NAME] = type.get_discriminator_from_object(value)
+                type = getattr(ntnx_iam_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ListAccessPolicyApiResponse, dict):
+        if issubclass(GetRoleApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ListAccessPolicyApiResponse):
+        if not isinstance(other, GetRoleApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authz/ListOperationApiResponse.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/CreateSystemConfigApiResponse.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,54 +1,54 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_iam_py_client.Ntnx
-from ntnx_iam_py_client.Ntnx.OneOfiam.v4.authz.ListOperationApiResponsedata import ListOperationApiResponsedata  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+from pathlib import Path
+import ntnx_iam_py_client.models
+from ntnx_iam_py_client.models.OneOfiam.v4.authn.CreateSystemConfigApiResponsedata import CreateSystemConfigApiResponsedata  # noqa: F401,E501
+from ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class CreateSystemConfigApiResponse(object):
+
+    """REST response for all response codes in API path /iam/v4.0.b1/authn/system-config Post operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
-
-Do not edit the class manually.
-IGNORE
-"""
-
-
-class ListOperationApiResponse(object):
-    """ListOperationApiResponse - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfiam.v4.authz.ListOperationApiResponsedata',
+        'data': 'OneOfiam.v4.authn.CreateSystemConfigApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -57,49 +57,46 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        """ListOperationApiResponse - a model defined in Swagger
-            \nREST response for all response codes in api path /iam/v4.0.a1/authz/operations Get operation
-        """
         self.__metadata = None
         self.__data = None
         self.discriminator = None
         if metadata is not None:
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'iam.v4.authz.ListOperationApiResponse'
+        return 'iam.v4.authn.CreateSystemConfigApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authz.ListOperationApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -107,111 +104,132 @@
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def metadata(self):
-        """`{ common.v1.response.ApiResponseMetadata }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            :class:`~ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata`
+        """  # noqa: E501
         return self.__metadata
 
     @metadata.setter
     def metadata(self, metadata):
 
         self.__metadata = metadata
 
     @property
     def data(self):
-        """`{ list[iam.v4.authz.Operation] | iam.v4.error.ErrorResponse }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+                :class:`~ntnx_iam_py_client.models.iam.v4.authn.SystemConfig` | 
+                :class:`~ntnx_iam_py_client.models.iam.v4.error.ErrorResponse`
+                    """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
         self.__data = data
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_iam_py_client.Ntnx, attr_type.split('.')[-1])
-                if hasattr(type, 'get_discriminator_from_object'):
-                    result[type.ONE_OF_ITEM_DISCRIMINATOR_NAME] = type.get_discriminator_from_object(value)
+                type = getattr(ntnx_iam_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ListOperationApiResponse, dict):
+        if issubclass(CreateSystemConfigApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ListOperationApiResponse):
+        if not isinstance(other, CreateSystemConfigApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authz/ListRoleApiResponse.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/CreateSamlIdentityProviderApiResponse.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,54 +1,54 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_iam_py_client.Ntnx
-from ntnx_iam_py_client.Ntnx.OneOfiam.v4.authz.ListRoleApiResponsedata import ListRoleApiResponsedata  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+from pathlib import Path
+import ntnx_iam_py_client.models
+from ntnx_iam_py_client.models.OneOfiam.v4.authn.CreateSamlIdentityProviderApiResponsedata import CreateSamlIdentityProviderApiResponsedata  # noqa: F401,E501
+from ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class CreateSamlIdentityProviderApiResponse(object):
+
+    """REST response for all response codes in API path /iam/v4.0.b1/authn/saml-identity-providers Post operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
-
-Do not edit the class manually.
-IGNORE
-"""
-
-
-class ListRoleApiResponse(object):
-    """ListRoleApiResponse - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfiam.v4.authz.ListRoleApiResponsedata',
+        'data': 'OneOfiam.v4.authn.CreateSamlIdentityProviderApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -57,49 +57,46 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        """ListRoleApiResponse - a model defined in Swagger
-            \nREST response for all response codes in api path /iam/v4.0.a1/authz/roles Get operation
-        """
         self.__metadata = None
         self.__data = None
         self.discriminator = None
         if metadata is not None:
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'iam.v4.authz.ListRoleApiResponse'
+        return 'iam.v4.authn.CreateSamlIdentityProviderApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authz.ListRoleApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -107,111 +104,132 @@
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def metadata(self):
-        """`{ common.v1.response.ApiResponseMetadata }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            :class:`~ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata`
+        """  # noqa: E501
         return self.__metadata
 
     @metadata.setter
     def metadata(self, metadata):
 
         self.__metadata = metadata
 
     @property
     def data(self):
-        """`{ list[iam.v4.authz.Role] | iam.v4.error.ErrorResponse }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+                :class:`~ntnx_iam_py_client.models.iam.v4.authn.SamlIdentityProvider` | 
+                :class:`~ntnx_iam_py_client.models.iam.v4.error.ErrorResponse`
+                    """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
         self.__data = data
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_iam_py_client.Ntnx, attr_type.split('.')[-1])
-                if hasattr(type, 'get_discriminator_from_object'):
-                    result[type.ONE_OF_ITEM_DISCRIMINATOR_NAME] = type.get_discriminator_from_object(value)
+                type = getattr(ntnx_iam_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ListRoleApiResponse, dict):
+        if issubclass(CreateSamlIdentityProviderApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ListRoleApiResponse):
+        if not isinstance(other, CreateSamlIdentityProviderApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authz/Operation.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/SystemConfig.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,246 +1,235 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_iam_py_client.Ntnx.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel  # noqa: F401,E501
+from pathlib import Path
+from ntnx_iam_py_client.models.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
+from ntnx_iam_py_client.models.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel  # noqa: F401,E501
+
+class SystemConfig(ExternalizableAbstractModel):
+
+    """System configuration resource.
+
+    :param name: (:attr:`name`) Name of the system configuration.
+    :type name: 
+    :param value: (:attr:`value`) Value of the system configuration.
+    :type value: 
+    :param created_time: (:attr:`created_time`) Creation time of the system configuration.
+    :type created_time: 
+    :param last_updated_time: (:attr:`last_updated_time`) Last update time of the system configuration.
+    :type last_updated_time: 
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
-
-Do not edit the class manually.
-IGNORE
-"""
-
-
-class Operation(ExternalizableAbstractModel):
-    """Operation - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
-        'display_name': 'str',
-        'description': 'str',
-        'object_type': 'str',
-        'client_name': 'str',
+        'name': 'str',
+        'value': 'str',
         'created_time': 'datetime',
         'last_updated_time': 'datetime',
         'ext_id': 'str',
         'links': 'list[common.v1.response.ApiLink]',
         'tenant_id': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'display_name': 'displayName',
-        'description': 'description',
-        'object_type': 'objectType',
-        'client_name': 'clientName',
+        'name': 'name',
+        'value': 'value',
         'created_time': 'createdTime',
         'last_updated_time': 'lastUpdatedTime',
         'ext_id': 'extId',
         'links': 'links',
         'tenant_id': 'tenantId',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, display_name=None, description=None, object_type=None, client_name=None, created_time=None, last_updated_time=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
-        """Operation - a model defined in Swagger
-            
-        """
+    def __init__(self, name=None, value=None, created_time=None, last_updated_time=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
         ExternalizableAbstractModel.__init__(self, ext_id, links, tenant_id, *args, **kwargs)
-        self.__display_name = None
-        self.__description = None
-        self.__object_type = None
-        self.__client_name = None
+        self.__name = None
+        self.__value = None
         self.__created_time = None
         self.__last_updated_time = None
         self.discriminator = None
-        if display_name is not None:
-            self.__display_name = display_name
-        if description is not None:
-            self.__description = description
-        if object_type is not None:
-            self.__object_type = object_type
-        if client_name is not None:
-            self.__client_name = client_name
+        if name is not None:
+            self.__name = name
+        if value is not None:
+            self.__value = value
         if created_time is not None:
             self.__created_time = created_time
         if last_updated_time is not None:
             self.__last_updated_time = last_updated_time
 
     def _initialize_object_type(self):
-        return 'iam.v4.authz.Operation'
+        return 'iam.v4.authn.SystemConfig'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authz.Operation'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     @property
-    def display_name(self):
-        """`{ str }`
-            \nName of the operation
-        """ # noqa: E501
-        return self.__display_name
-
-    @display_name.setter
-    def display_name(self, display_name):
-        if display_name is not None and len(display_name) > 255:
-            raise ValueError("Invalid value for `display_name`, length must be less than or equal to `255`")  # noqa: E501
-        if display_name is not None and len(display_name) < 1:
-            raise ValueError("Invalid value for `display_name`, length must be greater than or equal to `1`")  # noqa: E501
-        if display_name is not None and not re.search('^[^\\\"]*$', display_name):  # noqa: E501
-            raise ValueError(r"Invalid value for `display_name`, must be a follow pattern or equal to `/^[^\\\"]*$/`")  # noqa: E501
+    def name(self):
+        """
+        Name of the system configuration.
 
-        self.__display_name = display_name
+        :type:
 
-    @property
-    def description(self):
-        """`{ str }`
-            \nDescription of the operation
-        """ # noqa: E501
-        return self.__description
-
-    @description.setter
-    def description(self, description):
-        if description is not None and len(description) > 1000:
-            raise ValueError("Invalid value for `description`, length must be less than or equal to `1000`")  # noqa: E501
+                :class:`~str`
+        """  # noqa: E501
+        return self.__name
 
-        self.__description = description
+    @name.setter
+    def name(self, name):
+        if name is not None and len(name) > 255:
+            raise ValueError("Invalid value for `name`, length must be less than or equal to `255`")  # noqa: E501
+        if name is not None and len(name) < 1:
+            raise ValueError("Invalid value for `name`, length must be greater than or equal to `1`")  # noqa: E501
+        if name is not None and not re.search('^[^<>;\'()&+%\/\\\\\"`]*$', name):  # noqa: E501
+            raise ValueError(r"Invalid value for `name`, must be a follow pattern or equal to `/^[^<>;'()&+%\/\\\\\"`]*$/`")  # noqa: E501
 
-    @property
-    def object_type(self):
-        """`{ str }`
-            \nType of object associated with this operation
-        """ # noqa: E501
-        return self.__object_type
+        self.__name = name
 
-    @object_type.setter
-    def object_type(self, object_type):
+    @property
+    def value(self):
+        """
+        Value of the system configuration.
 
-        self.__object_type = object_type
+        :type:
 
-    @property
-    def client_name(self):
-        """`{ str }`
-            \nClient that created the operation
-        """ # noqa: E501
-        return self.__client_name
-
-    @client_name.setter
-    def client_name(self, client_name):
-        if client_name is not None and len(client_name) > 255:
-            raise ValueError("Invalid value for `client_name`, length must be less than or equal to `255`")  # noqa: E501
+                :class:`~str`
+        """  # noqa: E501
+        return self.__value
+
+    @value.setter
+    def value(self, value):
+        if value is not None and len(value) > 255:
+            raise ValueError("Invalid value for `value`, length must be less than or equal to `255`")  # noqa: E501
+        if value is not None and len(value) < 1:
+            raise ValueError("Invalid value for `value`, length must be greater than or equal to `1`")  # noqa: E501
 
-        self.__client_name = client_name
+        self.__value = value
 
     @property
     def created_time(self):
-        """`{ datetime }`
-            \nThe creation time of the operation
-        """ # noqa: E501
+        """
+        Creation time of the system configuration.
+
+        :type:
+
+                :class:`~datetime`
+        """  # noqa: E501
         return self.__created_time
 
     @created_time.setter
     def created_time(self, created_time):
 
         self.__created_time = created_time
 
     @property
     def last_updated_time(self):
-        """`{ datetime }`
-            \nThe time when the operation was last updated
-        """ # noqa: E501
+        """
+        Last update time of the system configuration.
+
+        :type:
+
+                :class:`~datetime`
+        """  # noqa: E501
         return self.__last_updated_time
 
     @last_updated_time.setter
     def last_updated_time(self, last_updated_time):
 
         self.__last_updated_time = last_updated_time
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(Operation, dict):
+        if issubclass(SystemConfig, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, Operation):
+        if not isinstance(other, SystemConfig):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authz/Role.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/ServiceAccountKey.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,314 +1,327 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_iam_py_client.Ntnx.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel  # noqa: F401,E501
+from pathlib import Path
+from ntnx_iam_py_client.models.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
+from ntnx_iam_py_client.models.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel  # noqa: F401,E501
+
+class ServiceAccountKey(ExternalizableAbstractModel):
+
+    """Credentials in the form of a private key and certificate for the Service Account, for authentication over mTLS.
+
+    :param name: (:attr:`name`) Identifier of the Service Account Key in the form of a name.
+    :type name: 
+    :param description: (:attr:`description`) Brief description of the Service Account Key.
+    :type description: 
+    :param serial_number: (:attr:`serial_number`) Serial number of the certificate.
+    :type serial_number: 
+    :param certificate: (:attr:`certificate`) X509 certificate signed by IAM in PEM format (includes leaf as well as ICAs), returned only during creation.
+    :type certificate: 
+    :param private_key: (:attr:`private_key`) RSA private key encoded in PEM format, returned only during creation.
+    :type private_key: 
+    :param created_time: (:attr:`created_time`) User or Service who created the Nutanix Access Key.
+    :type created_time: 
+    :param created_by: (:attr:`created_by`) Creation time for the Nutanix Access Key.
+    :type created_by: 
+    :param expiry_time: (:attr:`expiry_time`) Expiry time of the Certificate.
+    :type expiry_time: 
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
-
-Do not edit the class manually.
-IGNORE
-"""
-
-
-class Role(ExternalizableAbstractModel):
-    """Role - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
-        'display_name': 'str',
+        'name': 'str',
         'description': 'str',
-        'client_name': 'str',
-        'operations': 'list[str]',
-        'accessible_clients': 'list[str]',
-        'accessible_object_types': 'list[str]',
+        'serial_number': 'str',
+        'certificate': 'str',
+        'private_key': 'str',
         'created_time': 'datetime',
-        'last_updated_time': 'datetime',
         'created_by': 'str',
-        'is_system_defined': 'bool',
+        'expiry_time': 'datetime',
         'ext_id': 'str',
         'links': 'list[common.v1.response.ApiLink]',
         'tenant_id': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'display_name': 'displayName',
+        'name': 'name',
         'description': 'description',
-        'client_name': 'clientName',
-        'operations': 'operations',
-        'accessible_clients': 'accessibleClients',
-        'accessible_object_types': 'accessibleObjectTypes',
+        'serial_number': 'serialNumber',
+        'certificate': 'certificate',
+        'private_key': 'privateKey',
         'created_time': 'createdTime',
-        'last_updated_time': 'lastUpdatedTime',
         'created_by': 'createdBy',
-        'is_system_defined': 'isSystemDefined',
+        'expiry_time': 'expiryTime',
         'ext_id': 'extId',
         'links': 'links',
         'tenant_id': 'tenantId',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, display_name=None, description=None, client_name=None, operations=None, accessible_clients=None, accessible_object_types=None, created_time=None, last_updated_time=None, created_by=None, is_system_defined=True, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
-        """Role - a model defined in Swagger
-            \nA role to group the operations and/or sub roles
-        """
+    def __init__(self, name=None, description=None, serial_number=None, certificate=None, private_key=None, created_time=None, created_by=None, expiry_time=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
         ExternalizableAbstractModel.__init__(self, ext_id, links, tenant_id, *args, **kwargs)
-        self.__display_name = None
+        self.__name = None
         self.__description = None
-        self.__client_name = None
-        self.__operations = None
-        self.__accessible_clients = None
-        self.__accessible_object_types = None
+        self.__serial_number = None
+        self.__certificate = None
+        self.__private_key = None
         self.__created_time = None
-        self.__last_updated_time = None
         self.__created_by = None
-        self.__is_system_defined = None
+        self.__expiry_time = None
         self.discriminator = None
-        if display_name is not None:
-            self.__display_name = display_name
+        if name is not None:
+            self.__name = name
         if description is not None:
             self.__description = description
-        if client_name is not None:
-            self.__client_name = client_name
-        if operations is not None:
-            self.__operations = operations
-        if accessible_clients is not None:
-            self.__accessible_clients = accessible_clients
-        if accessible_object_types is not None:
-            self.__accessible_object_types = accessible_object_types
+        if serial_number is not None:
+            self.__serial_number = serial_number
+        if certificate is not None:
+            self.__certificate = certificate
+        if private_key is not None:
+            self.__private_key = private_key
         if created_time is not None:
             self.__created_time = created_time
-        if last_updated_time is not None:
-            self.__last_updated_time = last_updated_time
         if created_by is not None:
             self.__created_by = created_by
-        if is_system_defined is not None:
-            self.__is_system_defined = is_system_defined
+        if expiry_time is not None:
+            self.__expiry_time = expiry_time
 
     def _initialize_object_type(self):
-        return 'iam.v4.authz.Role'
+        return 'iam.v4.authn.ServiceAccountKey'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authz.Role'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     @property
-    def display_name(self):
-        """`{ str }`
-            \nThe display name for the role
-        """ # noqa: E501
-        return self.__display_name
-
-    @display_name.setter
-    def display_name(self, display_name):
-        if display_name is not None and len(display_name) > 255:
-            raise ValueError("Invalid value for `display_name`, length must be less than or equal to `255`")  # noqa: E501
-        if display_name is not None and len(display_name) < 1:
-            raise ValueError("Invalid value for `display_name`, length must be greater than or equal to `1`")  # noqa: E501
-        if display_name is not None and not re.search('^[^\\\"]*$', display_name):  # noqa: E501
-            raise ValueError(r"Invalid value for `display_name`, must be a follow pattern or equal to `/^[^\\\"]*$/`")  # noqa: E501
+    def name(self):
+        """
+        Identifier of the Service Account Key in the form of a name.
 
-        self.__display_name = display_name
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__name
+
+    @name.setter
+    def name(self, name):
+        if name is not None and len(name) > 255:
+            raise ValueError("Invalid value for `name`, length must be less than or equal to `255`")  # noqa: E501
+        if name is not None and len(name) < 1:
+            raise ValueError("Invalid value for `name`, length must be greater than or equal to `1`")  # noqa: E501
+        if name is not None and not re.search('^[^<>;\'()&+%\/\\\\\"`]*$', name):  # noqa: E501
+            raise ValueError(r"Invalid value for `name`, must be a follow pattern or equal to `/^[^<>;'()&+%\/\\\\\"`]*$/`")  # noqa: E501
+
+        self.__name = name
 
     @property
     def description(self):
-        """`{ str }`
-            \nDescription of the role
-        """ # noqa: E501
+        """
+        Brief description of the Service Account Key.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__description
 
     @description.setter
     def description(self, description):
         if description is not None and len(description) > 1000:
             raise ValueError("Invalid value for `description`, length must be less than or equal to `1000`")  # noqa: E501
+        if description is not None and not re.search('^[^<>;()&+%\/\\\\\"`]*$', description):  # noqa: E501
+            raise ValueError(r"Invalid value for `description`, must be a follow pattern or equal to `/^[^<>;()&+%\/\\\\\"`]*$/`")  # noqa: E501
 
         self.__description = description
 
     @property
-    def client_name(self):
-        """`{ str }`
-            \nClient that created the role
-        """ # noqa: E501
-        return self.__client_name
-
-    @client_name.setter
-    def client_name(self, client_name):
-        if client_name is not None and len(client_name) > 255:
-            raise ValueError("Invalid value for `client_name`, length must be less than or equal to `255`")  # noqa: E501
+    def serial_number(self):
+        """
+        Serial number of the certificate.
 
-        self.__client_name = client_name
+        :type:
 
-    @property
-    def operations(self):
-        """`{ list[str] }`
-            \nList of operations for the role
-        """ # noqa: E501
-        return self.__operations
+                :class:`~str`
+        """  # noqa: E501
+        return self.__serial_number
 
-    @operations.setter
-    def operations(self, operations):
+    @serial_number.setter
+    def serial_number(self, serial_number):
 
-        self.__operations = operations
+        self.__serial_number = serial_number
 
     @property
-    def accessible_clients(self):
-        """`{ list[str] }`
-            \nList of accessible clients for the role
-        """ # noqa: E501
-        return self.__accessible_clients
+    def certificate(self):
+        """
+        X509 certificate signed by IAM in PEM format (includes leaf as well as ICAs), returned only during creation.
+
+        :type:
 
-    @accessible_clients.setter
-    def accessible_clients(self, accessible_clients):
+                :class:`~str`
+        """  # noqa: E501
+        return self.__certificate
 
-        self.__accessible_clients = accessible_clients
+    @certificate.setter
+    def certificate(self, certificate):
+
+        self.__certificate = certificate
 
     @property
-    def accessible_object_types(self):
-        """`{ list[str] }`
-            \nList of Accessible ObjectTypes for the role
-        """ # noqa: E501
-        return self.__accessible_object_types
+    def private_key(self):
+        """
+        RSA private key encoded in PEM format, returned only during creation.
+
+        :type:
 
-    @accessible_object_types.setter
-    def accessible_object_types(self, accessible_object_types):
+                :class:`~str`
+        """  # noqa: E501
+        return self.__private_key
 
-        self.__accessible_object_types = accessible_object_types
+    @private_key.setter
+    def private_key(self, private_key):
+
+        self.__private_key = private_key
 
     @property
     def created_time(self):
-        """`{ datetime }`
-            \nThe creation time of the role
-        """ # noqa: E501
+        """
+        User or Service who created the Nutanix Access Key.
+
+        :type:
+
+                :class:`~datetime`
+        """  # noqa: E501
         return self.__created_time
 
     @created_time.setter
     def created_time(self, created_time):
 
         self.__created_time = created_time
 
     @property
-    def last_updated_time(self):
-        """`{ datetime }`
-            \nThe time when the role was last updated
-        """ # noqa: E501
-        return self.__last_updated_time
-
-    @last_updated_time.setter
-    def last_updated_time(self, last_updated_time):
+    def created_by(self):
+        """
+        Creation time for the Nutanix Access Key.
 
-        self.__last_updated_time = last_updated_time
+        :type:
 
-    @property
-    def created_by(self):
-        """`{ str }`
-            \nUser or service name that created the role
-        """ # noqa: E501
+                :class:`~str`
+        """  # noqa: E501
         return self.__created_by
 
     @created_by.setter
     def created_by(self, created_by):
 
         self.__created_by = created_by
 
     @property
-    def is_system_defined(self):
-        """`{ bool }`
-            \nFlag identifying if the role is system defined or not
-        """ # noqa: E501
-        return self.__is_system_defined
+    def expiry_time(self):
+        """
+        Expiry time of the Certificate.
+
+        :type:
 
-    @is_system_defined.setter
-    def is_system_defined(self, is_system_defined):
+                :class:`~datetime`
+        """  # noqa: E501
+        return self.__expiry_time
 
-        self.__is_system_defined = is_system_defined
+    @expiry_time.setter
+    def expiry_time(self, expiry_time):
+
+        self.__expiry_time = expiry_time
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(Role, dict):
+        if issubclass(ServiceAccountKey, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, Role):
+        if not isinstance(other, ServiceAccountKey):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authz/StatusType.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/ScopesType.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,171 +1,145 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
-
-Do not edit the class manually.
-IGNORE
-"""
-
-
-class StatusType(object):
-
-    """
-    allowed enum values :
-
-    _UNKNOWN 
+class ScopesType(object):
 
-    _REDACTED 
+    """Supported OIDC scopes.
 
-    NOERROR 
 
-    APPERROR 
-
-    CANCELED 
-
-    RETRY 
-
-    TIMEOUT 
-
-    AUTHORIZED 
-
-    BADREQUEST 
-
-    NOTAUTHORIZED 
-
-    PARTIALSUCCESS 
+    Allowed enum values:
 
+        - _UNKNOWN
+        - _REDACTED
+        - OPEN_ID
+        - PROFILE
+        - EMAIL
     """
     _UNKNOWN = "$UNKNOWN"
     _REDACTED = "$REDACTED"
-    NOERROR = "NoError"
-    APPERROR = "AppError"
-    CANCELED = "Canceled"
-    RETRY = "Retry"
-    TIMEOUT = "Timeout"
-    AUTHORIZED = "Authorized"
-    BADREQUEST = "BadRequest"
-    NOTAUTHORIZED = "NotAuthorized"
-    PARTIALSUCCESS = "PartialSuccess"
+    OPEN_ID = "OPEN_ID"
+    PROFILE = "PROFILE"
+    EMAIL = "EMAIL"
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
-        """StatusType - a model defined in Swagger
-            \nStatus type for response
-        """
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'iam.v4.authz.StatusType'
+        return 'iam.v4.authn.ScopesType'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authz.StatusType'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(StatusType, dict):
+        if issubclass(ScopesType, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, StatusType):
+        if not isinstance(other, ScopesType):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authz/UpdateAccessPolicyApiResponse.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/GetServiceAccountApiResponse.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,54 +1,54 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_iam_py_client.Ntnx
-from ntnx_iam_py_client.Ntnx.OneOfiam.v4.authz.UpdateAccessPolicyApiResponsedata import UpdateAccessPolicyApiResponsedata  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+from pathlib import Path
+import ntnx_iam_py_client.models
+from ntnx_iam_py_client.models.OneOfiam.v4.authn.GetServiceAccountApiResponsedata import GetServiceAccountApiResponsedata  # noqa: F401,E501
+from ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class GetServiceAccountApiResponse(object):
+
+    """REST response for all response codes in API path /iam/v4.0.b1/authn/service-accounts/{extId} Get operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
-
-Do not edit the class manually.
-IGNORE
-"""
-
-
-class UpdateAccessPolicyApiResponse(object):
-    """UpdateAccessPolicyApiResponse - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfiam.v4.authz.UpdateAccessPolicyApiResponsedata',
+        'data': 'OneOfiam.v4.authn.GetServiceAccountApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -57,49 +57,46 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        """UpdateAccessPolicyApiResponse - a model defined in Swagger
-            \nREST response for all response codes in api path /iam/v4.0.a1/authz/accessPolicies/{extId} Put operation
-        """
         self.__metadata = None
         self.__data = None
         self.discriminator = None
         if metadata is not None:
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'iam.v4.authz.UpdateAccessPolicyApiResponse'
+        return 'iam.v4.authn.GetServiceAccountApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authz.UpdateAccessPolicyApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -107,111 +104,132 @@
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def metadata(self):
-        """`{ common.v1.response.ApiResponseMetadata }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            :class:`~ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata`
+        """  # noqa: E501
         return self.__metadata
 
     @metadata.setter
     def metadata(self, metadata):
 
         self.__metadata = metadata
 
     @property
     def data(self):
-        """`{ common.v1.config.Message | iam.v4.error.ErrorResponse }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+                :class:`~ntnx_iam_py_client.models.iam.v4.authn.ServiceAccount` | 
+                :class:`~ntnx_iam_py_client.models.iam.v4.error.ErrorResponse`
+                    """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
         self.__data = data
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_iam_py_client.Ntnx, attr_type.split('.')[-1])
-                if hasattr(type, 'get_discriminator_from_object'):
-                    result[type.ONE_OF_ITEM_DISCRIMINATOR_NAME] = type.get_discriminator_from_object(value)
+                type = getattr(ntnx_iam_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(UpdateAccessPolicyApiResponse, dict):
+        if issubclass(GetServiceAccountApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, UpdateAccessPolicyApiResponse):
+        if not isinstance(other, GetServiceAccountApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authz/UpdateRoleApiResponse.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/DeleteServiceAccountApiResponse.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,54 +1,54 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_iam_py_client.Ntnx
-from ntnx_iam_py_client.Ntnx.OneOfiam.v4.authz.UpdateRoleApiResponsedata import UpdateRoleApiResponsedata  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+from pathlib import Path
+import ntnx_iam_py_client.models
+from ntnx_iam_py_client.models.OneOfiam.v4.authn.DeleteServiceAccountApiResponsedata import DeleteServiceAccountApiResponsedata  # noqa: F401,E501
+from ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class DeleteServiceAccountApiResponse(object):
+
+    """REST response for all response codes in API path /iam/v4.0.b1/authn/service-accounts/{extId} Delete operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
-
-Do not edit the class manually.
-IGNORE
-"""
-
-
-class UpdateRoleApiResponse(object):
-    """UpdateRoleApiResponse - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfiam.v4.authz.UpdateRoleApiResponsedata',
+        'data': 'OneOfiam.v4.authn.DeleteServiceAccountApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -57,49 +57,46 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        """UpdateRoleApiResponse - a model defined in Swagger
-            \nREST response for all response codes in api path /iam/v4.0.a1/authz/roles/{extId} Put operation
-        """
         self.__metadata = None
         self.__data = None
         self.discriminator = None
         if metadata is not None:
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'iam.v4.authz.UpdateRoleApiResponse'
+        return 'iam.v4.authn.DeleteServiceAccountApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authz.UpdateRoleApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -107,111 +104,131 @@
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def metadata(self):
-        """`{ common.v1.response.ApiResponseMetadata }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            :class:`~ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata`
+        """  # noqa: E501
         return self.__metadata
 
     @metadata.setter
     def metadata(self, metadata):
 
         self.__metadata = metadata
 
     @property
     def data(self):
-        """`{ common.v1.config.Message | iam.v4.error.ErrorResponse }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+                :class:`~ntnx_iam_py_client.models.iam.v4.error.ErrorResponse`
+                    """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
         self.__data = data
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_iam_py_client.Ntnx, attr_type.split('.')[-1])
-                if hasattr(type, 'get_discriminator_from_object'):
-                    result[type.ONE_OF_ITEM_DISCRIMINATOR_NAME] = type.get_discriminator_from_object(value)
+                type = getattr(ntnx_iam_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(UpdateRoleApiResponse, dict):
+        if issubclass(DeleteServiceAccountApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, UpdateRoleApiResponse):
+        if not isinstance(other, DeleteServiceAccountApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authz/ViewAccessPolicyApiResponse.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/CreateCertAuthProviderApiResponse.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,54 +1,54 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_iam_py_client.Ntnx
-from ntnx_iam_py_client.Ntnx.OneOfiam.v4.authz.ViewAccessPolicyApiResponsedata import ViewAccessPolicyApiResponsedata  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+from pathlib import Path
+import ntnx_iam_py_client.models
+from ntnx_iam_py_client.models.OneOfiam.v4.authn.CreateCertAuthProviderApiResponsedata import CreateCertAuthProviderApiResponsedata  # noqa: F401,E501
+from ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class CreateCertAuthProviderApiResponse(object):
+
+    """REST response for all response codes in API path /iam/v4.0.b1/authn/cert-auth-providers Post operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
-
-Do not edit the class manually.
-IGNORE
-"""
-
-
-class ViewAccessPolicyApiResponse(object):
-    """ViewAccessPolicyApiResponse - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfiam.v4.authz.ViewAccessPolicyApiResponsedata',
+        'data': 'OneOfiam.v4.authn.CreateCertAuthProviderApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -57,49 +57,46 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        """ViewAccessPolicyApiResponse - a model defined in Swagger
-            \nREST response for all response codes in api path /iam/v4.0.a1/authz/accessPolicies/{extId} Get operation
-        """
         self.__metadata = None
         self.__data = None
         self.discriminator = None
         if metadata is not None:
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'iam.v4.authz.ViewAccessPolicyApiResponse'
+        return 'iam.v4.authn.CreateCertAuthProviderApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authz.ViewAccessPolicyApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -107,111 +104,132 @@
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def metadata(self):
-        """`{ common.v1.response.ApiResponseMetadata }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            :class:`~ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata`
+        """  # noqa: E501
         return self.__metadata
 
     @metadata.setter
     def metadata(self, metadata):
 
         self.__metadata = metadata
 
     @property
     def data(self):
-        """`{ iam.v4.authz.AccessPolicy | iam.v4.error.ErrorResponse }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+                :class:`~ntnx_iam_py_client.models.iam.v4.authn.CertAuthProvider` | 
+                :class:`~ntnx_iam_py_client.models.iam.v4.error.ErrorResponse`
+                    """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
         self.__data = data
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_iam_py_client.Ntnx, attr_type.split('.')[-1])
-                if hasattr(type, 'get_discriminator_from_object'):
-                    result[type.ONE_OF_ITEM_DISCRIMINATOR_NAME] = type.get_discriminator_from_object(value)
+                type = getattr(ntnx_iam_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ViewAccessPolicyApiResponse, dict):
+        if issubclass(CreateCertAuthProviderApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ViewAccessPolicyApiResponse):
+        if not isinstance(other, CreateCertAuthProviderApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authz/ViewOperationApiResponse.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/ValidateApiKeyApiResponse.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,54 +1,54 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_iam_py_client.Ntnx
-from ntnx_iam_py_client.Ntnx.OneOfiam.v4.authz.ViewOperationApiResponsedata import ViewOperationApiResponsedata  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+from pathlib import Path
+import ntnx_iam_py_client.models
+from ntnx_iam_py_client.models.OneOfiam.v4.authn.ValidateApiKeyApiResponsedata import ValidateApiKeyApiResponsedata  # noqa: F401,E501
+from ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class ValidateApiKeyApiResponse(object):
+
+    """REST response for all response codes in API path /iam/v4.0.b1/authn/api-keys/$actions/validate Post operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
-
-Do not edit the class manually.
-IGNORE
-"""
-
-
-class ViewOperationApiResponse(object):
-    """ViewOperationApiResponse - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfiam.v4.authz.ViewOperationApiResponsedata',
+        'data': 'OneOfiam.v4.authn.ValidateApiKeyApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -57,49 +57,46 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        """ViewOperationApiResponse - a model defined in Swagger
-            \nREST response for all response codes in api path /iam/v4.0.a1/authz/operations/{extId} Get operation
-        """
         self.__metadata = None
         self.__data = None
         self.discriminator = None
         if metadata is not None:
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'iam.v4.authz.ViewOperationApiResponse'
+        return 'iam.v4.authn.ValidateApiKeyApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authz.ViewOperationApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -107,111 +104,132 @@
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def metadata(self):
-        """`{ common.v1.response.ApiResponseMetadata }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            :class:`~ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata`
+        """  # noqa: E501
         return self.__metadata
 
     @metadata.setter
     def metadata(self, metadata):
 
         self.__metadata = metadata
 
     @property
     def data(self):
-        """`{ iam.v4.authz.Operation | iam.v4.error.ErrorResponse }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+                :class:`~ntnx_iam_py_client.models.iam.v4.authn.ApiKeyValidateResponse` | 
+                :class:`~ntnx_iam_py_client.models.iam.v4.error.ErrorResponse`
+                    """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
         self.__data = data
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_iam_py_client.Ntnx, attr_type.split('.')[-1])
-                if hasattr(type, 'get_discriminator_from_object'):
-                    result[type.ONE_OF_ITEM_DISCRIMINATOR_NAME] = type.get_discriminator_from_object(value)
+                type = getattr(ntnx_iam_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ViewOperationApiResponse, dict):
+        if issubclass(ValidateApiKeyApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ViewOperationApiResponse):
+        if not isinstance(other, ValidateApiKeyApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/authz/ViewRoleApiResponse.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/ListServiceAccountsApiResponse.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,54 +1,54 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_iam_py_client.Ntnx
-from ntnx_iam_py_client.Ntnx.OneOfiam.v4.authz.ViewRoleApiResponsedata import ViewRoleApiResponsedata  # noqa: F401,E501
-from ntnx_iam_py_client.Ntnx.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+from pathlib import Path
+import ntnx_iam_py_client.models
+from ntnx_iam_py_client.models.OneOfiam.v4.authn.ListServiceAccountsApiResponsedata import ListServiceAccountsApiResponsedata  # noqa: F401,E501
+from ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class ListServiceAccountsApiResponse(object):
+
+    """REST response for all response codes in API path /iam/v4.0.b1/authn/service-accounts Get operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
-
-Do not edit the class manually.
-IGNORE
-"""
-
-
-class ViewRoleApiResponse(object):
-    """ViewRoleApiResponse - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfiam.v4.authz.ViewRoleApiResponsedata',
+        'data': 'OneOfiam.v4.authn.ListServiceAccountsApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -57,49 +57,46 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        """ViewRoleApiResponse - a model defined in Swagger
-            \nREST response for all response codes in api path /iam/v4.0.a1/authz/roles/{extId} Get operation
-        """
         self.__metadata = None
         self.__data = None
         self.discriminator = None
         if metadata is not None:
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'iam.v4.authz.ViewRoleApiResponse'
+        return 'iam.v4.authn.ListServiceAccountsApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.authz.ViewRoleApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -107,111 +104,132 @@
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def metadata(self):
-        """`{ common.v1.response.ApiResponseMetadata }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            :class:`~ntnx_iam_py_client.models.common.v1.response.ApiResponseMetadata`
+        """  # noqa: E501
         return self.__metadata
 
     @metadata.setter
     def metadata(self, metadata):
 
         self.__metadata = metadata
 
     @property
     def data(self):
-        """`{ iam.v4.authz.Role | iam.v4.error.ErrorResponse }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+                :class:`~ntnx_iam_py_client.models.iam.v4.authn.ServiceAccount` | 
+                :class:`~ntnx_iam_py_client.models.iam.v4.error.ErrorResponse`
+                    """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
         self.__data = data
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_iam_py_client.Ntnx, attr_type.split('.')[-1])
-                if hasattr(type, 'get_discriminator_from_object'):
-                    result[type.ONE_OF_ITEM_DISCRIMINATOR_NAME] = type.get_discriminator_from_object(value)
+                type = getattr(ntnx_iam_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ViewRoleApiResponse, dict):
+        if issubclass(ListServiceAccountsApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ViewRoleApiResponse):
+        if not isinstance(other, ListServiceAccountsApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/common/SortOrderType.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/authn/UserStatusType.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,150 +1,143 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class UserStatusType(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """Status of the User.
 
 
-class SortOrderType(object):
-
-    """
-    allowed enum values :
-
-    _UNKNOWN 
-
-    _REDACTED 
-
-    ASC 
-
-    DESC 
+    Allowed enum values:
 
+        - _UNKNOWN
+        - _REDACTED
+        - ACTIVE: Denotes that the local User is active.
+        - INACTIVE: Denotes that the local User is inactive and needs to be reactivated.
     """
     _UNKNOWN = "$UNKNOWN"
     _REDACTED = "$REDACTED"
-    ASC = "ASC"
-    DESC = "DESC"
+    ACTIVE = "ACTIVE"
+    INACTIVE = "INACTIVE"
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
-        """SortOrderType - a model defined in Swagger
-            \nDecRef(sortOrderDesc)
-        """
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'iam.v4.common.SortOrderType'
+        return 'iam.v4.authn.UserStatusType'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.common.SortOrderType'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(SortOrderType, dict):
+        if issubclass(UserStatusType, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, SortOrderType):
+        if not isinstance(other, UserStatusType):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/error/AppMessage.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/common/v1/config/Message.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,279 +1,277 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_iam_py_client.Ntnx.common.v1.config.MessageSeverity import MessageSeverity  # noqa: F401,E501
+from pathlib import Path
+from ntnx_iam_py_client.models.common.v1.config.MessageSeverity import MessageSeverity  # noqa: F401,E501
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class Message(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """
 
+    :param code: (:attr:`code`) A code that uniquely identifies a message. 
+    :type code: 
+    :param message: (:attr:`message`) The description of the message. 
+    :type message: 
+    :param locale: (:attr:`locale`) The locale for the message description.  (**Default** 'en_US')
+    :type locale: 
+    :param severity: (:attr:`severity`) 
+    :type severity: 
 
-class AppMessage(object):
-    """AppMessage - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
-        'message': 'str',
-        'severity': 'common.v1.config.MessageSeverity',
         'code': 'str',
+        'message': 'str',
         'locale': 'str',
-        'error_group': 'str',
-        'arguments_map': 'dict(str, str)',
+        'severity': 'common.v1.config.MessageSeverity',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'message': 'message',
-        'severity': 'severity',
         'code': 'code',
+        'message': 'message',
         'locale': 'locale',
-        'error_group': 'errorGroup',
-        'arguments_map': 'argumentsMap',
+        'severity': 'severity',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, message=None, severity=None, code=None, locale='en_US', error_group=None, arguments_map=None, *args, **kwargs):  # noqa: E501
-        """AppMessage - a model defined in Swagger
-            \nThis schema is generated from AppMessage.java
-        """
-        self.__message = None
-        self.__severity = None
+    def __init__(self, code=None, message=None, locale='en_US', severity=None, *args, **kwargs):  # noqa: E501
         self.__code = None
+        self.__message = None
         self.__locale = None
-        self.__error_group = None
-        self.__arguments_map = None
+        self.__severity = None
         self.discriminator = None
-        if message is not None:
-            self.__message = message
-        if severity is not None:
-            self.__severity = severity
         if code is not None:
             self.__code = code
+        if message is not None:
+            self.__message = message
         if locale is not None:
             self.__locale = locale
-        if error_group is not None:
-            self.__error_group = error_group
-        if arguments_map is not None:
-            self.__arguments_map = arguments_map
+        if severity is not None:
+            self.__severity = severity
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'iam.v4.error.AppMessage'
+        return 'common.v1.config.Message'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.error.AppMessage'
+    def _initialize_object_version(self):
+        return 'v1.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def message(self):
-        """`{ str }`
-            
-        """ # noqa: E501
-        return self.__message
-
-    @message.setter
-    def message(self, message):
-
-        self.__message = message
-
-    @property
-    def severity(self):
-        """`{ common.v1.config.MessageSeverity }`
-            
-        """ # noqa: E501
-        return self.__severity
-
-    @severity.setter
-    def severity(self, severity):
+    def code(self):
+        """
+        A code that uniquely identifies a message. 
 
-        self.__severity = severity
+        :type:
 
-    @property
-    def code(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+                :class:`~str`
+        """  # noqa: E501
         return self.__code
 
     @code.setter
     def code(self, code):
 
         self.__code = code
 
     @property
+    def message(self):
+        """
+        The description of the message. 
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__message
+
+    @message.setter
+    def message(self, message):
+
+        self.__message = message
+
+    @property
     def locale(self):
-        """`{ str }`
-            \nThe locale for the message description.
-        """ # noqa: E501
+        """
+        The locale for the message description. 
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__locale
 
     @locale.setter
     def locale(self, locale):
 
         self.__locale = locale
 
     @property
-    def error_group(self):
-        """`{ str }`
-            
-        """ # noqa: E501
-        return self.__error_group
-
-    @error_group.setter
-    def error_group(self, error_group):
-
-        self.__error_group = error_group
+    def severity(self):
+        """
+        
 
-    @property
-    def arguments_map(self):
-        """`{ dict(str, str) }`
-            
-        """ # noqa: E501
-        return self.__arguments_map
+        :type:
+            :class:`~ntnx_iam_py_client.models.common.v1.config.MessageSeverity`
+        """  # noqa: E501
+        return self.__severity
 
-    @arguments_map.setter
-    def arguments_map(self, arguments_map):
+    @severity.setter
+    def severity(self, severity):
 
-        self.__arguments_map = arguments_map
+        self.__severity = severity
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(AppMessage, dict):
+        if issubclass(Message, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, AppMessage):
+        if not isinstance(other, Message):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/error/ErrorResponse.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/error/ErrorResponse.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,50 +1,48 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_iam_py_client.Ntnx
-from ntnx_iam_py_client.Ntnx.OneOfiam.v4.error.ErrorResponseerror import ErrorResponseerror  # noqa: F401,E501
+from pathlib import Path
+import ntnx_iam_py_client.models
+from ntnx_iam_py_client.models.OneOfiam.v4.error.ErrorResponseerror import ErrorResponseerror  # noqa: F401,E501
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class ErrorResponse(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """This schema is auto-generated by the Open API Dev Platform as REST response for 4xx and 5xx error responses.
 
+    :param error: (:attr:`error`) 
+    :type error: 
 
-class ErrorResponse(object):
-    """ErrorResponse - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'error': 'OneOfiam.v4.error.ErrorResponseerror',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
@@ -54,46 +52,43 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, error=None, *args, **kwargs):  # noqa: E501
-        """ErrorResponse - a model defined in Swagger
-            \nThis schema is auto-generated by the Open API Dev Platform as REST response for 4xx and 5xx error responses.
-        """
         self.__error = None
         self.discriminator = None
         if error is not None:
             self.__error = error
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'iam.v4.error.ErrorResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.error.ErrorResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -101,70 +96,88 @@
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def error(self):
-        """`{ list[iam.v4.error.AppMessage] | iam.v4.error.SchemaValidationError }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+                :class:`~ntnx_iam_py_client.models.iam.v4.error.AppMessage` | 
+                :class:`~ntnx_iam_py_client.models.iam.v4.error.SchemaValidationError`
+                    """  # noqa: E501
         return self.__error
 
     @error.setter
     def error(self, error):
 
         self.__error = error
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_iam_py_client.Ntnx, attr_type.split('.')[-1])
-                if hasattr(type, 'get_discriminator_from_object'):
-                    result[type.ONE_OF_ITEM_DISCRIMINATOR_NAME] = type.get_discriminator_from_object(value)
+                type = getattr(ntnx_iam_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
@@ -172,15 +185,15 @@
         if issubclass(ErrorResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/error/SchemaValidationError.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/error/SchemaValidationError.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,49 +1,55 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_iam_py_client.Ntnx.iam.v4.error.SchemaValidationErrorMessage import SchemaValidationErrorMessage  # noqa: F401,E501
+from pathlib import Path
+from ntnx_iam_py_client.models.iam.v4.error.SchemaValidationErrorMessage import SchemaValidationErrorMessage  # noqa: F401,E501
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class SchemaValidationError(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """This schema is generated from SchemaValidationError.java
 
+    :param timestamp: (:attr:`timestamp`) Timestamp of the response.
+    :type timestamp: 
+    :param status_code: (:attr:`status_code`) The HTTP status code of the response.
+    :type status_code: 
+    :param error: (:attr:`error`) The generic error message for the response.
+    :type error: 
+    :param path: (:attr:`path`) API path on which the request was made.
+    :type path: 
+    :param validation_error_messages: (:attr:`validation_error_messages`) List of validation error messages
+    :type validation_error_messages: 
 
-class SchemaValidationError(object):
-    """SchemaValidationError - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'timestamp': 'str',
         'status_code': 'int',
         'error': 'str',
         'path': 'str',
         'validation_error_messages': 'list[iam.v4.error.SchemaValidationErrorMessage]',
         '_reserved': 'dict(str, object)',
@@ -61,17 +67,14 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, timestamp=None, status_code=None, error=None, path=None, validation_error_messages=None, *args, **kwargs):  # noqa: E501
-        """SchemaValidationError - a model defined in Swagger
-            \nThis schema is generated from SchemaValidationError.java
-        """
         self.__timestamp = None
         self.__status_code = None
         self.__error = None
         self.__path = None
         self.__validation_error_messages = None
         self.discriminator = None
         if timestamp is not None:
@@ -86,33 +89,33 @@
             self.__validation_error_messages = validation_error_messages
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'iam.v4.error.SchemaValidationError'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.error.SchemaValidationError'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -120,114 +123,149 @@
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def timestamp(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        Timestamp of the response.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__timestamp
 
     @timestamp.setter
     def timestamp(self, timestamp):
 
         self.__timestamp = timestamp
 
     @property
     def status_code(self):
-        """`{ int }`
-            
-        """ # noqa: E501
+        """
+        The HTTP status code of the response.
+
+        :type:
+
+                :class:`~int`
+        """  # noqa: E501
         return self.__status_code
 
     @status_code.setter
     def status_code(self, status_code):
 
         self.__status_code = status_code
 
     @property
     def error(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        The generic error message for the response.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__error
 
     @error.setter
     def error(self, error):
 
         self.__error = error
 
     @property
     def path(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        API path on which the request was made.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__path
 
     @path.setter
     def path(self, path):
 
         self.__path = path
 
     @property
     def validation_error_messages(self):
-        """`{ list[iam.v4.error.SchemaValidationErrorMessage] }`
-            
-        """ # noqa: E501
+        """
+        List of validation error messages
+
+        :type:
+             list[ :class:`~ntnx_iam_py_client.models.iam.v4.error.SchemaValidationErrorMessage` ]
+        """  # noqa: E501
         return self.__validation_error_messages
 
     @validation_error_messages.setter
     def validation_error_messages(self, validation_error_messages):
 
         self.__validation_error_messages = validation_error_messages
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
@@ -235,15 +273,15 @@
         if issubclass(SchemaValidationError, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/Ntnx/iam/v4/error/SchemaValidationErrorMessage.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/models/iam/v4/error/SchemaValidationErrorMessage.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,48 +1,50 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-"""
-IGNORE:
-NOTE: This class is auto generated by the swagger code generator program.
+class SchemaValidationErrorMessage(object):
 
-Do not edit the class manually.
-IGNORE
-"""
+    """This schema is generated from SchemaValidationErrorMessage.java
 
+    :param location: (:attr:`location`) The part of the request that failed validation. Validation can fail for path, query parameters, and request body.
+    :type location: 
+    :param message: (:attr:`message`) The detailed message for the validation error.
+    :type message: 
+    :param attribute_path: (:attr:`attribute_path`) The path of the attribute that failed validation in the schema.
+    :type attribute_path: 
 
-class SchemaValidationErrorMessage(object):
-    """SchemaValidationErrorMessage - a model defined in Swagger"""
+    """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
     swagger_types = {
         'location': 'str',
         'message': 'str',
         'attribute_path': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
@@ -56,17 +58,14 @@
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
     def __init__(self, location=None, message=None, attribute_path=None, *args, **kwargs):  # noqa: E501
-        """SchemaValidationErrorMessage - a model defined in Swagger
-            \nThis schema is generated from SchemaValidationErrorMessage.java
-        """
         self.__location = None
         self.__message = None
         self.__attribute_path = None
         self.discriminator = None
         if location is not None:
             self.__location = location
         if message is not None:
@@ -75,33 +74,33 @@
             self.__attribute_path = attribute_path
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'iam.v4.error.SchemaValidationErrorMessage'
 
-    def _initialize_fq_object_type(self):
-        return 'iam.v4.r0.a1.error.SchemaValidationErrorMessage'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -109,90 +108,118 @@
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def location(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        The part of the request that failed validation. Validation can fail for path, query parameters, and request body.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__location
 
     @location.setter
     def location(self, location):
 
         self.__location = location
 
     @property
     def message(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        The detailed message for the validation error.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__message
 
     @message.setter
     def message(self, message):
 
         self.__message = message
 
     @property
     def attribute_path(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        The path of the attribute that failed validation in the schema.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__attribute_path
 
     @attribute_path.setter
     def attribute_path(self, attribute_path):
 
         self.__attribute_path = attribute_path
 
     @property
     def _reserved(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_reserved
 
     @property
     def _object_type(self):
-        """`{ str }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
         return self.__dollar_object_type
 
     @property
     def _unknown_fields(self):
-        """`{ dict(str, object) }`
-            
-        """ # noqa: E501
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
         return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
-        """
-        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
-        :param bool sanitize
+        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
+
+        :param sanitize: A flag to omit None properties if set to True
+        :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
@@ -200,15 +227,15 @@
         if issubclass(SchemaValidationErrorMessage, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
-        """Returns the model properties as a dict"""
+        """Returns the model properties as a dictionary"""
         return self._to_dict(False)
 
     def to_str(self):
         """Returns the string representation of the model"""
         return pprint.pformat(self._to_dict(True))
 
     def __repr__(self):
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/api/access_policy_api.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/api/roles_api.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,682 +1,628 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 from __future__ import absolute_import
 
 import re  # noqa: F401
 
 # python 2 and python 3 compatibility library
 import six
 
 from ntnx_iam_py_client.api_client import ApiClient
 
 
-class AccessPolicyApi(object):
+class RolesApi(object):
     """IGNORE:
-    NOTE: This class is auto generated by the swagger code generator program.
-
-    Do not edit the class manually.
-    Ref: https://github.com/swagger-api/swagger-codegen
+    NOTE: A placeholder for class level description
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
+
         self.api_client = api_client
+        self.__headers_to_skip = { 'authorization', 'cookie', 'host', 'user-agent' }
 
-    def create_access_policy_api(self, body, **kwargs):  # noqa: E501
-        """Create access policy
-        Create an access policy
+    def create_role(self, body, **kwargs):  # noqa: E501
+        """Create Role
 
-        >>> response = api.create_access_policy_api(body)
+        >>> response = api.create_role(body)
 
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
+        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.create_access_policy_api(body, async_req=True)
+        >>> thread = api.create_role(body, async_req=True)
         >>> result = thread.get()
 
-        :param iam.v4.authz.AccessPolicy body: Create an access policy (required)
-        :param bool async_req:
-        :return: iam.v4.authz.CreateAccessPolicyApiResponse
-
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """ # noqa: E501
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.create_access_policy_api_with_http_info(body, **kwargs)  # noqa: E501
-        else:
-            (data) = self.create_access_policy_api_with_http_info(body, **kwargs)  # noqa: E501
-            return data
-
-    def create_access_policy_api_with_http_info(self, body, **kwargs):  # noqa: E501
-        """Create access policy
-        Create an access policy
-
-        >>> response = api.create_access_policy_api(body)
+        :param body: Create a Role.
+        :type body:
 
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
+            :class:`~ntnx_iam_py_client.models.iam.v4.authz.Role`, required
+        :param kwargs: kwargs for the method.
+                       The following can be passed for an asynchronous HTTP call::
 
-        >>> thread = api.create_access_policy_api_with_http_info(body, async_req=True)
-        >>> result = thread.get()
+                           async_req=True
+        :return: An instance of class :class:`~ntnx_iam_py_client.models.iam.v4.authz.CreateRoleApiResponse`.
 
-        :param iam.v4.authz.AccessPolicy body: Create an access policy (required)
-        :param bool async_req:
-        :return: iam.v4.authz.CreateAccessPolicyApiResponse
-
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        all_params = ['body']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-        all_params.append('if_match')
-        all_params.append('if_none_match')
+                 If the method is called asynchronously, returns the request thread.
+        """ # noqa: E501
+        kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
-            if key not in all_params:
-                raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method create_access_policy_api" % key
-                )
             params[key] = val
         del params['kwargs']
+        del params['self']
+
         # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
-            raise ValueError("Missing the required parameter `body` when calling `create_access_policy_api`")  # noqa: E501
+        if ('body' not in params or params['body'] is None):
+            raise ValueError("Missing the required parameter `body` when calling `create_role`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'if_match' in params and params['if_match'] is not None:
-            header_params['If-Match'] = params['if_match']  # noqa: E501
-        if 'if_none_match' in params and params['if_none_match'] is not None:
-            header_params['If-None-Match'] = params['if_none_match']  # noqa: E501
-
-        form_params = []
-        local_var_files = {}
-
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
+        header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
+        header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
             ['application/json'])  # noqa: E501
+        if 'Content-Type' in params and params.get('Content-Type') is not None:
+            header_params['Content-Type'] = params.get('Content-Type')
+
+        # Process operation specific headers
+        extra_params = []
+        extra_params.append('async_req')
+        extra_params.append('_return_http_data_only')
+        extra_params.append('_preload_content')
+        extra_params.append('_request_timeout')
+        all_params = set(['body'])
+        all_params.update(extra_params)
+        for key, val in six.iteritems(params):
+            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
+                if key.lower() == 'if_match'.lower():
+                    key = 'If-Match'
+                elif key.lower() == 'if_none_match'.lower():
+                    key = 'If-None-Match'
+                header_params[key] = val
+
+        form_params = []
+        local_var_files = {}
 
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/api/iam/v4.0.a1/authz/accessPolicies', 'POST',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type='iam.v4.authz.CreateAccessPolicyApiResponse',  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def delete_access_policy_api(self, extId, **kwargs):  # noqa: E501
-        """Delete access policy
-        Delete an access policy
+        body_params = None
+        if 'body' in params and params['body'] is not None:
+            body_params = params['body']
 
-        >>> response = api.delete_access_policy_api(extId)
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authz/roles', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authz.CreateRoleApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authz/roles', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authz.CreateRoleApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
+    def delete_role_by_id(self, extId, **kwargs):  # noqa: E501
+        """Delete Role
 
-        >>> thread = api.delete_access_policy_api(extId, async_req=True)
-        >>> result = thread.get()
+        >>> response = api.delete_role_by_id(extId)
 
-        :param str extId: External identifier for the access policy (required)
-        :param bool async_req:
-        :return: iam.v4.authz.DeleteAccessPolicyApiResponse
+        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """ # noqa: E501
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.delete_access_policy_api_with_http_info(extId, **kwargs)  # noqa: E501
-        else:
-            (data) = self.delete_access_policy_api_with_http_info(extId, **kwargs)  # noqa: E501
-            return data
-
-    def delete_access_policy_api_with_http_info(self, extId, **kwargs):  # noqa: E501
-        """Delete access policy
-        Delete an access policy
+        >>> thread = api.delete_role_by_id(extId, async_req=True)
+        >>> result = thread.get()
 
-        >>> response = api.delete_access_policy_api(extId)
+        :param extId: ExtId for the Role.
+        :type extId:
 
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
+            :class:`str`, required
+        :param kwargs: kwargs for the method.
+                       The following can be passed for an asynchronous HTTP call::
 
-        >>> thread = api.delete_access_policy_api_with_http_info(extId, async_req=True)
-        >>> result = thread.get()
+                           async_req=True
+        :return: An instance of class :class:`~ntnx_iam_py_client.models.iam.v4.authz.DeleteRoleApiResponse`.
 
-        :param str extId: External identifier for the access policy (required)
-        :param bool async_req:
-        :return: iam.v4.authz.DeleteAccessPolicyApiResponse
-
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        all_params = ['extId']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-        all_params.append('if_match')
-        all_params.append('if_none_match')
+                 If the method is called asynchronously, returns the request thread.
+        """ # noqa: E501
+        kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
-            if key not in all_params:
-                raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method delete_access_policy_api" % key
-                )
             params[key] = val
         del params['kwargs']
+        del params['self']
+
         # verify the required parameter 'extId' is set
-        if ('extId' not in params or
-                params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `delete_access_policy_api`")  # noqa: E501
+        if ('extId' not in params or params['extId'] is None):
+            raise ValueError("Missing the required parameter `extId` when calling `delete_role_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'extId' in params:
+        if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'if_match' in params and params['if_match'] is not None:
-            header_params['If-Match'] = params['if_match']  # noqa: E501
-        if 'if_none_match' in params and params['if_none_match'] is not None:
-            header_params['If-None-Match'] = params['if_none_match']  # noqa: E501
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client._select_header_accept(
+            ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
+
+        # Process operation specific headers
+        extra_params = []
+        extra_params.append('async_req')
+        extra_params.append('_return_http_data_only')
+        extra_params.append('_preload_content')
+        extra_params.append('_request_timeout')
+        all_params = set(['extId'])
+        all_params.update(extra_params)
+        for key, val in six.iteritems(params):
+            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
+                if key.lower() == 'if_match'.lower():
+                    key = 'If-Match'
+                elif key.lower() == 'if_none_match'.lower():
+                    key = 'If-None-Match'
+                header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/api/iam/v4.0.a1/authz/accessPolicies/{extId}', 'DELETE',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type='iam.v4.authz.DeleteAccessPolicyApiResponse',  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def list_access_policy_api(self, **kwargs):  # noqa: E501
-        """List access policy(ies)
-        List all the access policy(ies)
+        body_params = None
 
-        >>> response = api.list_access_policy_api((optional) _page, (optional) _limit, (optional) _filter, (optional) _orderby, (optional) _select)
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authz/roles/{extId}', 'DELETE',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authz.DeleteRoleApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authz/roles/{extId}', 'DELETE',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authz.DeleteRoleApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
+    def get_role_by_id(self, extId, **kwargs):  # noqa: E501
+        """Get Role
 
-        >>> thread = api.list_access_policy_api(async_req=True)
-        >>> result = thread.get()
+        >>> response = api.get_role_by_id(extId)
+
+        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        :param int _page: A URL query parameter that specifies the page number of the result set.  Must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range will lead to no results being returned.
+        >>> thread = api.get_role_by_id(extId, async_req=True)
+        >>> result = thread.get()
 
-        :param int _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 0 and 100. Any number out of this range will lead to a validation error. If the limit is not provided a default value of 50 records will be returned in the result set.
+        :param extId: ExtId for the Role.
+        :type extId:
 
-        :param str _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the OData V4.01 URL conventions.
-        The filter can be applied on the following fields:
-        
-        - clientName
-        - createdBy
-        - createdTime
-        - displayName
-        - extId
-        - isSystemDefined
-        - lastUpdatedTime
-        - role
-        
-        :param str _orderby: A URL query parameter that allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified the resources will be sorted in ascending order by default. For example, 'orderby=templateName desc' would get all templates sorted by templateName in desc order.
-        The orderby can be applied to the following fields:
-        
-        - createdTime
-        - displayName
-        - extId
-        - lastUpdatedTime
-        - role
-        
-        :param str _select: A URL query parameter that allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the OData V4.01 URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e. *), then all properties on the matching resource will be returned.
-- accessPolicyType
-- clientName
-- createdBy
-- createdTime
-- description
-- displayName
-- extId
-- identities
-- isSystemDefined
-- lastUpdatedTime
-- links
-- objects
-- role
-- tenantId
+            :class:`str`, required
+        :param kwargs: kwargs for the method.
+                       The following can be passed for an asynchronous HTTP call::
 
-        :param bool async_req:
-        :return: iam.v4.authz.ListAccessPolicyApiResponse
+                           async_req=True
+        :return: An instance of class :class:`~ntnx_iam_py_client.models.iam.v4.authz.GetRoleApiResponse`.
 
-                 If the method is called asynchronously,
-                 returns the request thread.
+                 If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.list_access_policy_api_with_http_info(**kwargs)  # noqa: E501
-        else:
-            (data) = self.list_access_policy_api_with_http_info(**kwargs)  # noqa: E501
-            return data
-
-    def list_access_policy_api_with_http_info(self, **kwargs):  # noqa: E501
-        """List access policy(ies)
-        List all the access policy(ies)
-
-        >>> response = api.list_access_policy_api((optional) _page, (optional) _limit, (optional) _filter, (optional) _orderby, (optional) _select)
-
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-
-        >>> thread = api.list_access_policy_api_with_http_info(async_req=True)
-        >>> result = thread.get()
 
-        :param int _page: A URL query parameter that specifies the page number of the result set.  Must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range will lead to no results being returned.
-
-        :param int _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 0 and 100. Any number out of this range will lead to a validation error. If the limit is not provided a default value of 50 records will be returned in the result set.
-
-        :param str _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the OData V4.01 URL conventions.
-        The filter can be applied on the following fields:
-        
-        - clientName
-        - createdBy
-        - createdTime
-        - displayName
-        - extId
-        - isSystemDefined
-        - lastUpdatedTime
-        - role
-        
-        :param str _orderby: A URL query parameter that allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified the resources will be sorted in ascending order by default. For example, 'orderby=templateName desc' would get all templates sorted by templateName in desc order.
-        The orderby can be applied to the following fields:
-        
-        - createdTime
-        - displayName
-        - extId
-        - lastUpdatedTime
-        - role
-        
-        :param str _select: A URL query parameter that allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the OData V4.01 URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e. *), then all properties on the matching resource will be returned.
-- accessPolicyType
-- clientName
-- createdBy
-- createdTime
-- description
-- displayName
-- extId
-- identities
-- isSystemDefined
-- lastUpdatedTime
-- links
-- objects
-- role
-- tenantId
-
-        :param bool async_req:
-        :return: iam.v4.authz.ListAccessPolicyApiResponse
-
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        all_params = ['_page', '_limit', '_filter', '_orderby', '_select']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-        all_params.append('if_match')
-        all_params.append('if_none_match')
-
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
-            if key not in all_params:
-                raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_access_policy_api" % key
-                )
             params[key] = val
         del params['kwargs']
+        del params['self']
+
+        # verify the required parameter 'extId' is set
+        if ('extId' not in params or params['extId'] is None):
+            raise ValueError("Missing the required parameter `extId` when calling `get_role_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
+        if 'extId' in params and params['extId'] is not None:
+            path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
-        if '_page' in params:
-            query_params.append(('$page', params['_page']))  # noqa: E501
-        if '_limit' in params:
-            query_params.append(('$limit', params['_limit']))  # noqa: E501
-        if '_filter' in params:
-            query_params.append(('$filter', params['_filter']))  # noqa: E501
-        if '_orderby' in params:
-            query_params.append(('$orderby', params['_orderby']))  # noqa: E501
-        if '_select' in params:
-            query_params.append(('$select', params['_select']))  # noqa: E501
 
         header_params = {}
-        if 'if_match' in params and params['if_match'] is not None:
-            header_params['If-Match'] = params['if_match']  # noqa: E501
-        if 'if_none_match' in params and params['if_none_match'] is not None:
-            header_params['If-None-Match'] = params['if_none_match']  # noqa: E501
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client._select_header_accept(
+            ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
+
+        # Process operation specific headers
+        extra_params = []
+        extra_params.append('async_req')
+        extra_params.append('_return_http_data_only')
+        extra_params.append('_preload_content')
+        extra_params.append('_request_timeout')
+        all_params = set(['extId'])
+        all_params.update(extra_params)
+        for key, val in six.iteritems(params):
+            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
+                if key.lower() == 'if_match'.lower():
+                    key = 'If-Match'
+                elif key.lower() == 'if_none_match'.lower():
+                    key = 'If-None-Match'
+                header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/api/iam/v4.0.a1/authz/accessPolicies', 'GET',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type='iam.v4.authz.ListAccessPolicyApiResponse',  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def update_access_policy_api(self, body, extId, **kwargs):  # noqa: E501
-        """Update access policy
-        Update an access policy
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authz/roles/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authz.GetRoleApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authz/roles/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authz.GetRoleApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-        >>> response = api.update_access_policy_api(body, extId)
+    def list_roles(self, _page=None, _limit=None, _filter=None, _orderby=None, _select=None, **kwargs):  # noqa: E501
+        """List Role(s)
 
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
+        >>> response = api.list_roles((optional) _page, (optional) _limit, (optional) _filter, (optional) _orderby, (optional) _select)
 
-        >>> thread = api.update_access_policy_api(body, extId, async_req=True)
+        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
+
+        >>> thread = api.list_roles(async_req=True)
         >>> result = thread.get()
 
-        :param iam.v4.authz.AccessPolicy body: Update an access policy (required)
-        :param str extId: External identifier for the access policy (required)
-        :param bool async_req:
-        :return: iam.v4.authz.UpdateAccessPolicyApiResponse
+        :param _page: A URL query parameter that specifies the page number of the result set. It must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range might lead to no results. 
+        :type _page:
 
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """ # noqa: E501
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.update_access_policy_api_with_http_info(body, extId, **kwargs)  # noqa: E501
-        else:
-            (data) = self.update_access_policy_api_with_http_info(body, extId, **kwargs)  # noqa: E501
-            return data
-
-    def update_access_policy_api_with_http_info(self, body, extId, **kwargs):  # noqa: E501
-        """Update access policy
-        Update an access policy
+            :class:`int`
+        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided, a default value of 50 records will be returned in the result set. 
+        :type _limit:
 
-        >>> response = api.update_access_policy_api(body, extId)
+            :class:`int`
+        :param _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the [OData V4.01](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html) URL conventions. For example, filter '$filter=name eq 'karbon-ntnx-1.0' would filter the result on cluster name 'karbon-ntnx1.0', filter '$filter=startswith(name, 'C')' would filter on cluster name starting with 'C'. The filter can be applied to the following fields: - clientName - createdBy - createdTime - displayName - extId - isSystemDefined - lastUpdatedTime 
+        :type _filter:
 
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
+            :class:`str`
+        :param _orderby: A URL query parameter that allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified, the resources will be sorted in ascending order by default. For example, '$orderby=templateName desc' would get all templates sorted by templateName in descending order. The orderby can be applied to the following fields: - createdTime - displayName - extId - lastUpdatedTime 
+        :type _orderby:
 
-        >>> thread = api.update_access_policy_api_with_http_info(body, extId, async_req=True)
-        >>> result = thread.get()
+            :class:`str`
+        :param _select: A URL query parameter that allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the [OData V4.01](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html) URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e., *), then all properties on the matching resource will be returned. - accessibleClients - accessibleEntityTypes - assignedUserGroupsCount - assignedUsersCount - clientName - createdBy - createdTime - description - displayName - extId - isSystemDefined - lastUpdatedTime - links - operations - tenantId 
+        :type _select:
 
-        :param iam.v4.authz.AccessPolicy body: Update an access policy (required)
-        :param str extId: External identifier for the access policy (required)
-        :param bool async_req:
-        :return: iam.v4.authz.UpdateAccessPolicyApiResponse
-
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        all_params = ['body', 'extId']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-        all_params.append('if_match')
-        all_params.append('if_none_match')
+            :class:`str`
+        :param kwargs: kwargs for the method.
+                       The following can be passed for an asynchronous HTTP call::
 
-        params = locals()
+                           async_req=True
+        :return: An instance of class :class:`~ntnx_iam_py_client.models.iam.v4.authz.ListRolesApiResponse`.
+
+                 If the method is called asynchronously, returns the request thread.
+        """ # noqa: E501
+        kwargs['_return_http_data_only'] = True
+
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
-            if key not in all_params:
-                raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method update_access_policy_api" % key
-                )
             params[key] = val
         del params['kwargs']
-        # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
-            raise ValueError("Missing the required parameter `body` when calling `update_access_policy_api`")  # noqa: E501
-        # verify the required parameter 'extId' is set
-        if ('extId' not in params or
-                params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `update_access_policy_api`")  # noqa: E501
+        del params['self']
+
 
         collection_formats = {}
 
         path_params = {}
-        if 'extId' in params:
-            path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
+        if '_page' in params and params['_page'] is not None:
+            query_params.append(('$page', params['_page']))  # noqa: E501
+        if '_limit' in params and params['_limit'] is not None:
+            query_params.append(('$limit', params['_limit']))  # noqa: E501
+        if '_filter' in params and params['_filter'] is not None:
+            query_params.append(('$filter', params['_filter']))  # noqa: E501
+        if '_orderby' in params and params['_orderby'] is not None:
+            query_params.append(('$orderby', params['_orderby']))  # noqa: E501
+        if '_select' in params and params['_select'] is not None:
+            query_params.append(('$select', params['_select']))  # noqa: E501
 
         header_params = {}
-        if 'if_match' in params and params['if_match'] is not None:
-            header_params['If-Match'] = params['if_match']  # noqa: E501
-        if 'if_none_match' in params and params['if_none_match'] is not None:
-            header_params['If-None-Match'] = params['if_none_match']  # noqa: E501
-
-        form_params = []
-        local_var_files = {}
-
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
+        header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
-        # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        # Process operation specific headers
+        extra_params = []
+        extra_params.append('async_req')
+        extra_params.append('_return_http_data_only')
+        extra_params.append('_preload_content')
+        extra_params.append('_request_timeout')
+        all_params = set(['_page', '_limit', '_filter', '_orderby', '_select'])
+        all_params.update(extra_params)
+        for key, val in six.iteritems(params):
+            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
+                if key.lower() == 'if_match'.lower():
+                    key = 'If-Match'
+                elif key.lower() == 'if_none_match'.lower():
+                    key = 'If-None-Match'
+                header_params[key] = val
+
+        form_params = []
+        local_var_files = {}
 
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/api/iam/v4.0.a1/authz/accessPolicies/{extId}', 'PUT',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type='iam.v4.authz.UpdateAccessPolicyApiResponse',  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def view_access_policy_api(self, extId, **kwargs):  # noqa: E501
-        """Get access policy
-        View an access policy
+        body_params = None
 
-        >>> response = api.view_access_policy_api(extId)
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authz/roles', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authz.ListRolesApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authz/roles', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authz.ListRolesApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
+    def update_role_by_id(self, extId, body, **kwargs):  # noqa: E501
+        """Update Role
 
-        >>> thread = api.view_access_policy_api(extId, async_req=True)
-        >>> result = thread.get()
+        >>> response = api.update_role_by_id(extId, body)
 
-        :param str extId: External identifier for the access policy (required)
-        :param bool async_req:
-        :return: iam.v4.authz.ViewAccessPolicyApiResponse
+        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """ # noqa: E501
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.view_access_policy_api_with_http_info(extId, **kwargs)  # noqa: E501
-        else:
-            (data) = self.view_access_policy_api_with_http_info(extId, **kwargs)  # noqa: E501
-            return data
-
-    def view_access_policy_api_with_http_info(self, extId, **kwargs):  # noqa: E501
-        """Get access policy
-        View an access policy
+        >>> thread = api.update_role_by_id(extId, body, async_req=True)
+        >>> result = thread.get()
 
-        >>> response = api.view_access_policy_api(extId)
+        :param extId: ExtId for the Role.
+        :type extId:
 
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
+            :class:`str`, required
+        :param body: Update a Role.
+        :type body:
 
-        >>> thread = api.view_access_policy_api_with_http_info(extId, async_req=True)
-        >>> result = thread.get()
+            :class:`~ntnx_iam_py_client.models.iam.v4.authz.Role`, required
+        :param kwargs: kwargs for the method.
+                       The following can be passed for an asynchronous HTTP call::
 
-        :param str extId: External identifier for the access policy (required)
-        :param bool async_req:
-        :return: iam.v4.authz.ViewAccessPolicyApiResponse
-
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        all_params = ['extId']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-        all_params.append('if_match')
-        all_params.append('if_none_match')
+                           async_req=True
+        :return: An instance of class :class:`~ntnx_iam_py_client.models.iam.v4.authz.UpdateRoleApiResponse`.
 
-        params = locals()
+                 If the method is called asynchronously, returns the request thread.
+        """ # noqa: E501
+        kwargs['_return_http_data_only'] = True
+
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
-            if key not in all_params:
-                raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method view_access_policy_api" % key
-                )
             params[key] = val
         del params['kwargs']
+        del params['self']
+
         # verify the required parameter 'extId' is set
-        if ('extId' not in params or
-                params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `view_access_policy_api`")  # noqa: E501
+        if ('extId' not in params or params['extId'] is None):
+            raise ValueError("Missing the required parameter `extId` when calling `update_role_by_id`")  # noqa: E501
+        # verify the required parameter 'body' is set
+        if ('body' not in params or params['body'] is None):
+            raise ValueError("Missing the required parameter `body` when calling `update_role_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'extId' in params:
+        if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'if_match' in params and params['if_match'] is not None:
-            header_params['If-Match'] = params['if_match']  # noqa: E501
-        if 'if_none_match' in params and params['if_none_match'] is not None:
-            header_params['If-None-Match'] = params['if_none_match']  # noqa: E501
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client._select_header_accept(
+            ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
+
+        # HTTP header `Content-Type`
+        header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
+            ['application/json'])  # noqa: E501
+        if 'Content-Type' in params and params.get('Content-Type') is not None:
+            header_params['Content-Type'] = params.get('Content-Type')
+
+        # Process operation specific headers
+        extra_params = []
+        extra_params.append('async_req')
+        extra_params.append('_return_http_data_only')
+        extra_params.append('_preload_content')
+        extra_params.append('_request_timeout')
+        all_params = set(['extId', 'body'])
+        all_params.update(extra_params)
+        for key, val in six.iteritems(params):
+            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
+                if key.lower() == 'if_match'.lower():
+                    key = 'If-Match'
+                elif key.lower() == 'if_none_match'.lower():
+                    key = 'If-None-Match'
+                header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/api/iam/v4.0.a1/authz/accessPolicies/{extId}', 'GET',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type='iam.v4.authz.ViewAccessPolicyApiResponse',  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+        body_params = None
+        if 'body' in params and params['body'] is not None:
+            body_params = params['body']
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authz/roles/{extId}', 'PUT',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authz.UpdateRoleApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authz/roles/{extId}', 'PUT',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authz.UpdateRoleApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/api/cert_auth_provider_api.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/api/saml_identity_providers_api.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,655 +1,729 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 from __future__ import absolute_import
 
 import re  # noqa: F401
 
 # python 2 and python 3 compatibility library
 import six
 
 from ntnx_iam_py_client.api_client import ApiClient
 
 
-class CertAuthProviderApi(object):
+class SAMLIdentityProvidersApi(object):
     """IGNORE:
-    NOTE: This class is auto generated by the swagger code generator program.
-
-    Do not edit the class manually.
-    Ref: https://github.com/swagger-api/swagger-codegen
+    NOTE: A placeholder for class level description
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
+
         self.api_client = api_client
+        self.__headers_to_skip = { 'authorization', 'cookie', 'host', 'user-agent' }
 
-    def handle_create_cert_auth_provider(self, clientCaChain, certAuthEnabled, cacEnabled, caCertFileName, name, **kwargs):  # noqa: E501
-        """Create certificate based authentication provider
-        Create a certificate based authentication provider
+    def create_saml_identity_provider(self, body, **kwargs):  # noqa: E501
+        """Create SAML Identity Provider
 
-        >>> response = api.handle_create_cert_auth_provider(clientCaChain, certAuthEnabled, cacEnabled, caCertFileName, name, (optional) dirSvcExtID, (optional) certRevocationInfo, (optional) createdBy, (optional) tenantId, (optional) createdTime, (optional) links, (optional) lastUpdatedTime, (optional) extId)
+        >>> response = api.create_saml_identity_provider(body)
 
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
+        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.handle_create_cert_auth_provider(clientCaChain, certAuthEnabled, cacEnabled, caCertFileName, name, async_req=True)
+        >>> thread = api.create_saml_identity_provider(body, async_req=True)
         >>> result = thread.get()
 
-        :param str clientCaChain: (required)
-        :param bool certAuthEnabled: (required)
-        :param bool cacEnabled: (required)
-        :param str caCertFileName: (required)
-        :param str name: (required)
-        :param str dirSvcExtID:
-        :param iam.v4.authn.CertRevocationInfo certRevocationInfo:
-        :param str createdBy:
-        :param str tenantId:
-        :param datetime createdTime:
-        :param list[common.v1.response.ApiLink] links:
-        :param datetime lastUpdatedTime:
-        :param str extId:
-        :param bool async_req:
-        :return: iam.v4.authn.CreateCertAuthProviderApiResponse
-
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """ # noqa: E501
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.handle_create_cert_auth_provider_with_http_info(clientCaChain, certAuthEnabled, cacEnabled, caCertFileName, name, **kwargs)  # noqa: E501
-        else:
-            (data) = self.handle_create_cert_auth_provider_with_http_info(clientCaChain, certAuthEnabled, cacEnabled, caCertFileName, name, **kwargs)  # noqa: E501
-            return data
-
-    def handle_create_cert_auth_provider_with_http_info(self, clientCaChain, certAuthEnabled, cacEnabled, caCertFileName, name, **kwargs):  # noqa: E501
-        """Create certificate based authentication provider
-        Create a certificate based authentication provider
+        :param body: Create a SAML Identity Provider.
+        :type body:
 
-        >>> response = api.handle_create_cert_auth_provider(clientCaChain, certAuthEnabled, cacEnabled, caCertFileName, name, (optional) dirSvcExtID, (optional) certRevocationInfo, (optional) createdBy, (optional) tenantId, (optional) createdTime, (optional) links, (optional) lastUpdatedTime, (optional) extId)
+            :class:`~ntnx_iam_py_client.models.iam.v4.authn.SamlIdentityProvider`, required
+        :param kwargs: kwargs for the method.
+                       The following can be passed for an asynchronous HTTP call::
 
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
+                           async_req=True
+        :return: An instance of class :class:`~ntnx_iam_py_client.models.iam.v4.authn.CreateSamlIdentityProviderApiResponse`.
 
-        >>> thread = api.handle_create_cert_auth_provider_with_http_info(clientCaChain, certAuthEnabled, cacEnabled, caCertFileName, name, async_req=True)
-        >>> result = thread.get()
-
-        :param str clientCaChain: (required)
-        :param bool certAuthEnabled: (required)
-        :param bool cacEnabled: (required)
-        :param str caCertFileName: (required)
-        :param str name: (required)
-        :param str dirSvcExtID:
-        :param iam.v4.authn.CertRevocationInfo certRevocationInfo:
-        :param str createdBy:
-        :param str tenantId:
-        :param datetime createdTime:
-        :param list[common.v1.response.ApiLink] links:
-        :param datetime lastUpdatedTime:
-        :param str extId:
-        :param bool async_req:
-        :return: iam.v4.authn.CreateCertAuthProviderApiResponse
-
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        all_params = ['clientCaChain', 'certAuthEnabled', 'cacEnabled', 'caCertFileName', 'name', 'dirSvcExtID', 'certRevocationInfo', 'createdBy', 'tenantId', 'createdTime', 'links', 'lastUpdatedTime', 'extId']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-        all_params.append('if_match')
-        all_params.append('if_none_match')
+                 If the method is called asynchronously, returns the request thread.
+        """ # noqa: E501
+        kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
-            if key not in all_params:
-                raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method handle_create_cert_auth_provider" % key
-                )
             params[key] = val
         del params['kwargs']
-        # verify the required parameter 'clientCaChain' is set
-        if ('clientCaChain' not in params or
-                params['clientCaChain'] is None):
-            raise ValueError("Missing the required parameter `clientCaChain` when calling `handle_create_cert_auth_provider`")  # noqa: E501
-        # verify the required parameter 'certAuthEnabled' is set
-        if ('certAuthEnabled' not in params or
-                params['certAuthEnabled'] is None):
-            raise ValueError("Missing the required parameter `certAuthEnabled` when calling `handle_create_cert_auth_provider`")  # noqa: E501
-        # verify the required parameter 'cacEnabled' is set
-        if ('cacEnabled' not in params or
-                params['cacEnabled'] is None):
-            raise ValueError("Missing the required parameter `cacEnabled` when calling `handle_create_cert_auth_provider`")  # noqa: E501
-        # verify the required parameter 'caCertFileName' is set
-        if ('caCertFileName' not in params or
-                params['caCertFileName'] is None):
-            raise ValueError("Missing the required parameter `caCertFileName` when calling `handle_create_cert_auth_provider`")  # noqa: E501
-        # verify the required parameter 'name' is set
-        if ('name' not in params or
-                params['name'] is None):
-            raise ValueError("Missing the required parameter `name` when calling `handle_create_cert_auth_provider`")  # noqa: E501
+        del params['self']
+
+        # verify the required parameter 'body' is set
+        if ('body' not in params or params['body'] is None):
+            raise ValueError("Missing the required parameter `body` when calling `create_saml_identity_provider`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'if_match' in params and params['if_match'] is not None:
-            header_params['If-Match'] = params['if_match']  # noqa: E501
-        if 'if_none_match' in params and params['if_none_match'] is not None:
-            header_params['If-None-Match'] = params['if_none_match']  # noqa: E501
-
-        form_params = []
-        local_var_files = {}
-        if 'clientCaChain' in params:
-            form_params.append(('clientCaChain', params['clientCaChain']))  # noqa: E501
-        if 'dirSvcExtID' in params:
-            form_params.append(('dirSvcExtID', params['dirSvcExtID']))  # noqa: E501
-        if 'certAuthEnabled' in params:
-            form_params.append(('certAuthEnabled', params['certAuthEnabled']))  # noqa: E501
-        if 'cacEnabled' in params:
-            form_params.append(('cacEnabled', params['cacEnabled']))  # noqa: E501
-        if 'certRevocationInfo' in params:
-            form_params.append(('certRevocationInfo', params['certRevocationInfo']))  # noqa: E501
-        if 'caCertFileName' in params:
-            form_params.append(('caCertFileName', params['caCertFileName']))  # noqa: E501
-        if 'createdBy' in params:
-            form_params.append(('createdBy', params['createdBy']))  # noqa: E501
-        if 'tenantId' in params:
-            form_params.append(('tenantId', params['tenantId']))  # noqa: E501
-        if 'name' in params:
-            form_params.append(('name', params['name']))  # noqa: E501
-        if 'createdTime' in params:
-            form_params.append(('createdTime', params['createdTime']))  # noqa: E501
-        if 'links' in params:
-            form_params.append(('links', params['links']))  # noqa: E501
-            collection_formats['links'] = 'multi'  # noqa: E501
-        if 'lastUpdatedTime' in params:
-            form_params.append(('lastUpdatedTime', params['lastUpdatedTime']))  # noqa: E501
-        if 'extId' in params:
-            form_params.append(('extId', params['extId']))  # noqa: E501
-
-        body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
+        header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['multipart/form-data'])  # noqa: E501
+        header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
+            ['application/json'])  # noqa: E501
+        if 'Content-Type' in params and params.get('Content-Type') is not None:
+            header_params['Content-Type'] = params.get('Content-Type')
+
+        # Process operation specific headers
+        extra_params = []
+        extra_params.append('async_req')
+        extra_params.append('_return_http_data_only')
+        extra_params.append('_preload_content')
+        extra_params.append('_request_timeout')
+        all_params = set(['body'])
+        all_params.update(extra_params)
+        for key, val in six.iteritems(params):
+            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
+                if key.lower() == 'if_match'.lower():
+                    key = 'If-Match'
+                elif key.lower() == 'if_none_match'.lower():
+                    key = 'If-None-Match'
+                header_params[key] = val
+
+        form_params = []
+        local_var_files = {}
 
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/api/iam/v4.0.a1/authn/cert-auth-providers', 'POST',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type='iam.v4.authn.CreateCertAuthProviderApiResponse',  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def handle_get_cert_auth_provider(self, extId, **kwargs):  # noqa: E501
-        """Get certificate based authentication provider
-        Get a certificate based authentication provider by its UUID
+        body_params = None
+        if 'body' in params and params['body'] is not None:
+            body_params = params['body']
 
-        >>> response = api.handle_get_cert_auth_provider(extId)
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authn/saml-identity-providers', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authn.CreateSamlIdentityProviderApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authn/saml-identity-providers', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authn.CreateSamlIdentityProviderApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
+    def delete_saml_identity_provider_by_id(self, extId, **kwargs):  # noqa: E501
+        """Delete SAML Identity Provider
 
-        >>> thread = api.handle_get_cert_auth_provider(extId, async_req=True)
-        >>> result = thread.get()
+        >>> response = api.delete_saml_identity_provider_by_id(extId)
 
-        :param str extId: External identifier of the certificate based authentication provider (required)
-        :param bool async_req:
-        :return: iam.v4.authn.GetCertAuthProviderApiResponse
+        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """ # noqa: E501
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.handle_get_cert_auth_provider_with_http_info(extId, **kwargs)  # noqa: E501
-        else:
-            (data) = self.handle_get_cert_auth_provider_with_http_info(extId, **kwargs)  # noqa: E501
-            return data
-
-    def handle_get_cert_auth_provider_with_http_info(self, extId, **kwargs):  # noqa: E501
-        """Get certificate based authentication provider
-        Get a certificate based authentication provider by its UUID
+        >>> thread = api.delete_saml_identity_provider_by_id(extId, async_req=True)
+        >>> result = thread.get()
 
-        >>> response = api.handle_get_cert_auth_provider(extId)
+        :param extId: External identifier of the SAML Identity Provider.
+        :type extId:
 
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
+            :class:`str`, required
+        :param kwargs: kwargs for the method.
+                       The following can be passed for an asynchronous HTTP call::
 
-        >>> thread = api.handle_get_cert_auth_provider_with_http_info(extId, async_req=True)
-        >>> result = thread.get()
+                           async_req=True
+        :return: An instance of class :class:`~ntnx_iam_py_client.models.iam.v4.authn.DeleteSamlIdentityProviderApiResponse`.
 
-        :param str extId: External identifier of the certificate based authentication provider (required)
-        :param bool async_req:
-        :return: iam.v4.authn.GetCertAuthProviderApiResponse
-
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        all_params = ['extId']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-        all_params.append('if_match')
-        all_params.append('if_none_match')
+                 If the method is called asynchronously, returns the request thread.
+        """ # noqa: E501
+        kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
-            if key not in all_params:
-                raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method handle_get_cert_auth_provider" % key
-                )
             params[key] = val
         del params['kwargs']
+        del params['self']
+
         # verify the required parameter 'extId' is set
-        if ('extId' not in params or
-                params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `handle_get_cert_auth_provider`")  # noqa: E501
+        if ('extId' not in params or params['extId'] is None):
+            raise ValueError("Missing the required parameter `extId` when calling `delete_saml_identity_provider_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'extId' in params:
+        if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'if_match' in params and params['if_match'] is not None:
-            header_params['If-Match'] = params['if_match']  # noqa: E501
-        if 'if_none_match' in params and params['if_none_match'] is not None:
-            header_params['If-None-Match'] = params['if_none_match']  # noqa: E501
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client._select_header_accept(
+            ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
+
+        # Process operation specific headers
+        extra_params = []
+        extra_params.append('async_req')
+        extra_params.append('_return_http_data_only')
+        extra_params.append('_preload_content')
+        extra_params.append('_request_timeout')
+        all_params = set(['extId'])
+        all_params.update(extra_params)
+        for key, val in six.iteritems(params):
+            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
+                if key.lower() == 'if_match'.lower():
+                    key = 'If-Match'
+                elif key.lower() == 'if_none_match'.lower():
+                    key = 'If-None-Match'
+                header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
+        # Authentication setting
+        auth_settings = ['basicAuthScheme']  # noqa: E501
+
         body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authn/saml-identity-providers/{extId}', 'DELETE',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authn.DeleteSamlIdentityProviderApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authn/saml-identity-providers/{extId}', 'DELETE',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authn.DeleteSamlIdentityProviderApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
+
+    def get_saml_identity_provider_by_id(self, extId, **kwargs):  # noqa: E501
+        """Get SAML Identity Provider
+
+        >>> response = api.get_saml_identity_provider_by_id(extId)
+
+        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
+
+        >>> thread = api.get_saml_identity_provider_by_id(extId, async_req=True)
+        >>> result = thread.get()
+
+        :param extId: External identifier of the SAML Identity Provider.
+        :type extId:
+
+            :class:`str`, required
+        :param kwargs: kwargs for the method.
+                       The following can be passed for an asynchronous HTTP call::
+
+                           async_req=True
+        :return: An instance of class :class:`~ntnx_iam_py_client.models.iam.v4.authn.GetSamlIdentityProviderApiResponse`.
+
+                 If the method is called asynchronously, returns the request thread.
+        """ # noqa: E501
+        kwargs['_return_http_data_only'] = True
+
+        params = dict(locals())
+        for key, val in six.iteritems(params['kwargs']):
+            params[key] = val
+        del params['kwargs']
+        del params['self']
+
+        # verify the required parameter 'extId' is set
+        if ('extId' not in params or params['extId'] is None):
+            raise ValueError("Missing the required parameter `extId` when calling `get_saml_identity_provider_by_id`")  # noqa: E501
+
+        collection_formats = {}
+
+        path_params = {}
+        if 'extId' in params and params['extId'] is not None:
+            path_params['extId'] = params['extId']  # noqa: E501
+
+        query_params = []
+
+        header_params = {}
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
+        header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
+
+        # Process operation specific headers
+        extra_params = []
+        extra_params.append('async_req')
+        extra_params.append('_return_http_data_only')
+        extra_params.append('_preload_content')
+        extra_params.append('_request_timeout')
+        all_params = set(['extId'])
+        all_params.update(extra_params)
+        for key, val in six.iteritems(params):
+            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
+                if key.lower() == 'if_match'.lower():
+                    key = 'If-Match'
+                elif key.lower() == 'if_none_match'.lower():
+                    key = 'If-None-Match'
+                header_params[key] = val
+
+        form_params = []
+        local_var_files = {}
 
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/api/iam/v4.0.a1/authn/cert-auth-providers/{extId}', 'GET',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type='iam.v4.authn.GetCertAuthProviderApiResponse',  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def handle_list_cert_auth_providers(self, **kwargs):  # noqa: E501
-        """List certificate based authentication provider(s)
-        Get a list of all configured certificate based authentication providers
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authn/saml-identity-providers/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authn.GetSamlIdentityProviderApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authn/saml-identity-providers/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authn.GetSamlIdentityProviderApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
+
+    def get_saml_sp_metadata(self, **kwargs):  # noqa: E501
+        """Get SP-Metadata for SAML Identity Provider
 
-        >>> response = api.handle_list_cert_auth_providers((optional) _filter, (optional) _orderby, (optional) _select)
+        >>> response = api.get_saml_sp_metadata()
 
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
+        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.handle_list_cert_auth_providers(async_req=True)
+        >>> thread = api.get_saml_sp_metadata(async_req=True)
         >>> result = thread.get()
 
-        :param str _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the OData V4.01 URL conventions.
-        The filter can be applied on the following fields:
-        
-        - createdBy
-        - extId
-        - name
-        
-        :param str _orderby: A URL query parameter that allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified the resources will be sorted in ascending order by default. For example, 'orderby=templateName desc' would get all templates sorted by templateName in desc order.
-        The orderby can be applied to the following fields:
-        
-        - createdTime
-        - lastUpdatedTime
-        - name
-        
-        :param str _select: A URL query parameter that allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the OData V4.01 URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e. *), then all properties on the matching resource will be returned.
-- caCertFileName
-- cacEnabled
-- certAuthEnabled
-- certRevocationInfo
-- clientCaChain
-- createdBy
-- createdTime
-- dirSvcExtID
-- extId
-- lastUpdatedTime
-- links
-- name
-- tenantId
+        :param kwargs: kwargs for the method.
+                       The following can be passed for an asynchronous HTTP call::
 
-        :param bool async_req:
-        :return: iam.v4.authn.ListCertAuthProviderApiResponse
+                           async_req=True
+        :return: An instance of class :class:`~ntnx_iam_py_client.models.iam.v4.authn.GetSamlSpMetadataApiResponse`.
 
-                 If the method is called asynchronously,
-                 returns the request thread.
+                 If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.handle_list_cert_auth_providers_with_http_info(**kwargs)  # noqa: E501
-        else:
-            (data) = self.handle_list_cert_auth_providers_with_http_info(**kwargs)  # noqa: E501
-            return data
-
-    def handle_list_cert_auth_providers_with_http_info(self, **kwargs):  # noqa: E501
-        """List certificate based authentication provider(s)
-        Get a list of all configured certificate based authentication providers
 
-        >>> response = api.handle_list_cert_auth_providers((optional) _filter, (optional) _orderby, (optional) _select)
+        params = dict(locals())
+        for key, val in six.iteritems(params['kwargs']):
+            params[key] = val
+        del params['kwargs']
+        del params['self']
+
 
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
+        collection_formats = {}
 
-        >>> thread = api.handle_list_cert_auth_providers_with_http_info(async_req=True)
+        path_params = {}
+
+        query_params = []
+
+        header_params = {}
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client._select_header_accept(
+            ['text/xml', 'application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
+
+        # Process operation specific headers
+        extra_params = []
+        extra_params.append('async_req')
+        extra_params.append('_return_http_data_only')
+        extra_params.append('_preload_content')
+        extra_params.append('_request_timeout')
+        all_params = set([])
+        all_params.update(extra_params)
+        for key, val in six.iteritems(params):
+            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
+                if key.lower() == 'if_match'.lower():
+                    key = 'If-Match'
+                elif key.lower() == 'if_none_match'.lower():
+                    key = 'If-None-Match'
+                header_params[key] = val
+
+        form_params = []
+        local_var_files = {}
+
+        # Authentication setting
+        auth_settings = ['basicAuthScheme']  # noqa: E501
+
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authn/saml-sp-metadata', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authn.GetSamlSpMetadataApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authn/saml-sp-metadata', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authn.GetSamlSpMetadataApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
+
+    def list_saml_identity_providers(self, _page=None, _limit=None, _filter=None, _orderby=None, _select=None, **kwargs):  # noqa: E501
+        """List SAML Identity Providers
+
+        >>> response = api.list_saml_identity_providers((optional) _page, (optional) _limit, (optional) _filter, (optional) _orderby, (optional) _select)
+
+        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
+
+        >>> thread = api.list_saml_identity_providers(async_req=True)
         >>> result = thread.get()
 
-        :param str _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the OData V4.01 URL conventions.
-        The filter can be applied on the following fields:
-        
-        - createdBy
-        - extId
-        - name
-        
-        :param str _orderby: A URL query parameter that allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified the resources will be sorted in ascending order by default. For example, 'orderby=templateName desc' would get all templates sorted by templateName in desc order.
-        The orderby can be applied to the following fields:
-        
-        - createdTime
-        - lastUpdatedTime
-        - name
-        
-        :param str _select: A URL query parameter that allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the OData V4.01 URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e. *), then all properties on the matching resource will be returned.
-- caCertFileName
-- cacEnabled
-- certAuthEnabled
-- certRevocationInfo
-- clientCaChain
-- createdBy
-- createdTime
-- dirSvcExtID
-- extId
-- lastUpdatedTime
-- links
-- name
-- tenantId
-
-        :param bool async_req:
-        :return: iam.v4.authn.ListCertAuthProviderApiResponse
-
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        all_params = ['_filter', '_orderby', '_select']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-        all_params.append('if_match')
-        all_params.append('if_none_match')
+        :param _page: A URL query parameter that specifies the page number of the result set. It must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range might lead to no results. 
+        :type _page:
+
+            :class:`int`
+        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided, a default value of 50 records will be returned in the result set. 
+        :type _limit:
+
+            :class:`int`
+        :param _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the [OData V4.01](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html) URL conventions. For example, filter '$filter=name eq 'karbon-ntnx-1.0' would filter the result on cluster name 'karbon-ntnx1.0', filter '$filter=startswith(name, 'C')' would filter on cluster name starting with 'C'. The filter can be applied to the following fields: - createdBy - extId - name 
+        :type _filter:
+
+            :class:`str`
+        :param _orderby: A URL query parameter that allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified, the resources will be sorted in ascending order by default. For example, '$orderby=templateName desc' would get all templates sorted by templateName in descending order. The orderby can be applied to the following fields: - createdTime - lastUpdatedTime - name 
+        :type _orderby:
+
+            :class:`str`
+        :param _select: A URL query parameter that allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the [OData V4.01](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html) URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e., *), then all properties on the matching resource will be returned. - createdBy - createdTime - customAttributes - emailAttribute - entityIssuer - extId - groupsAttribute - groupsDelim - idpMetadata/certificate - idpMetadata/entityId - idpMetadata/errorUrl - idpMetadata/loginUrl - idpMetadata/logoutUrl - idpMetadata/nameIdPolicyFormat - isSignedAuthnReqEnabled - lastUpdatedTime - links - name - tenantId - usernameAttribute 
+        :type _select:
+
+            :class:`str`
+        :param kwargs: kwargs for the method.
+                       The following can be passed for an asynchronous HTTP call::
+
+                           async_req=True
+        :return: An instance of class :class:`~ntnx_iam_py_client.models.iam.v4.authn.ListSamlIdentityProvidersApiResponse`.
 
-        params = locals()
+                 If the method is called asynchronously, returns the request thread.
+        """ # noqa: E501
+        kwargs['_return_http_data_only'] = True
+
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
-            if key not in all_params:
-                raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method handle_list_cert_auth_providers" % key
-                )
             params[key] = val
         del params['kwargs']
+        del params['self']
+
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
-        if '_filter' in params:
+        if '_page' in params and params['_page'] is not None:
+            query_params.append(('$page', params['_page']))  # noqa: E501
+        if '_limit' in params and params['_limit'] is not None:
+            query_params.append(('$limit', params['_limit']))  # noqa: E501
+        if '_filter' in params and params['_filter'] is not None:
             query_params.append(('$filter', params['_filter']))  # noqa: E501
-        if '_orderby' in params:
+        if '_orderby' in params and params['_orderby'] is not None:
             query_params.append(('$orderby', params['_orderby']))  # noqa: E501
-        if '_select' in params:
+        if '_select' in params and params['_select'] is not None:
             query_params.append(('$select', params['_select']))  # noqa: E501
 
         header_params = {}
-        if 'if_match' in params and params['if_match'] is not None:
-            header_params['If-Match'] = params['if_match']  # noqa: E501
-        if 'if_none_match' in params and params['if_none_match'] is not None:
-            header_params['If-None-Match'] = params['if_none_match']  # noqa: E501
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client._select_header_accept(
+            ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
+
+        # Process operation specific headers
+        extra_params = []
+        extra_params.append('async_req')
+        extra_params.append('_return_http_data_only')
+        extra_params.append('_preload_content')
+        extra_params.append('_request_timeout')
+        all_params = set(['_page', '_limit', '_filter', '_orderby', '_select'])
+        all_params.update(extra_params)
+        for key, val in six.iteritems(params):
+            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
+                if key.lower() == 'if_match'.lower():
+                    key = 'If-Match'
+                elif key.lower() == 'if_none_match'.lower():
+                    key = 'If-None-Match'
+                header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/api/iam/v4.0.a1/authn/cert-auth-providers', 'GET',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type='iam.v4.authn.ListCertAuthProviderApiResponse',  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def handle_update_cert_auth_provider(self, extId, **kwargs):  # noqa: E501
-        """Update certificate based authentication provider
-        Update a certificate based authentication provider configuration
+        body_params = None
 
-        >>> response = api.handle_update_cert_auth_provider((optional) clientCaChain, (optional) dirSvcExtID, (optional) certAuthEnabled, (optional) cacEnabled, (optional) certRevocationInfo, (optional) caCertFileName, (optional) createdBy, (optional) tenantId, (optional) name, (optional) createdTime, (optional) links, (optional) lastUpdatedTime, (optional) extId2, extId)
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authn/saml-identity-providers', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authn.ListSamlIdentityProvidersApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authn/saml-identity-providers', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authn.ListSamlIdentityProvidersApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
+    def update_saml_identity_provider_by_id(self, extId, body, **kwargs):  # noqa: E501
+        """Update SAML Identity Provider
 
-        >>> thread = api.handle_update_cert_auth_provider(extId, async_req=True)
-        >>> result = thread.get()
+        >>> response = api.update_saml_identity_provider_by_id(extId, body)
 
-        :param str clientCaChain:
-        :param str dirSvcExtID:
-        :param bool certAuthEnabled:
-        :param bool cacEnabled:
-        :param iam.v4.authn.CertRevocationInfo certRevocationInfo:
-        :param str caCertFileName:
-        :param str createdBy:
-        :param str tenantId:
-        :param str name:
-        :param datetime createdTime:
-        :param list[common.v1.response.ApiLink] links:
-        :param datetime lastUpdatedTime:
-        :param str extId2:
-        :param str extId: External identifier of the certificate based authentication provider (required)
-        :param bool async_req:
-        :return: iam.v4.authn.UpdateCertAuthProviderApiResponse
+        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """ # noqa: E501
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.handle_update_cert_auth_provider_with_http_info(extId, **kwargs)  # noqa: E501
-        else:
-            (data) = self.handle_update_cert_auth_provider_with_http_info(extId, **kwargs)  # noqa: E501
-            return data
-
-    def handle_update_cert_auth_provider_with_http_info(self, extId, **kwargs):  # noqa: E501
-        """Update certificate based authentication provider
-        Update a certificate based authentication provider configuration
+        >>> thread = api.update_saml_identity_provider_by_id(extId, body, async_req=True)
+        >>> result = thread.get()
 
-        >>> response = api.handle_update_cert_auth_provider((optional) clientCaChain, (optional) dirSvcExtID, (optional) certAuthEnabled, (optional) cacEnabled, (optional) certRevocationInfo, (optional) caCertFileName, (optional) createdBy, (optional) tenantId, (optional) name, (optional) createdTime, (optional) links, (optional) lastUpdatedTime, (optional) extId2, extId)
+        :param extId: External identifier of the SAML Identity Provider.
+        :type extId:
 
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
+            :class:`str`, required
+        :param body: Update a SAML Identity Provider.
+        :type body:
 
-        >>> thread = api.handle_update_cert_auth_provider_with_http_info(extId, async_req=True)
-        >>> result = thread.get()
+            :class:`~ntnx_iam_py_client.models.iam.v4.authn.SamlIdentityProvider`, required
+        :param kwargs: kwargs for the method.
+                       The following can be passed for an asynchronous HTTP call::
 
-        :param str clientCaChain:
-        :param str dirSvcExtID:
-        :param bool certAuthEnabled:
-        :param bool cacEnabled:
-        :param iam.v4.authn.CertRevocationInfo certRevocationInfo:
-        :param str caCertFileName:
-        :param str createdBy:
-        :param str tenantId:
-        :param str name:
-        :param datetime createdTime:
-        :param list[common.v1.response.ApiLink] links:
-        :param datetime lastUpdatedTime:
-        :param str extId2:
-        :param str extId: External identifier of the certificate based authentication provider (required)
-        :param bool async_req:
-        :return: iam.v4.authn.UpdateCertAuthProviderApiResponse
-
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        all_params = ['clientCaChain', 'dirSvcExtID', 'certAuthEnabled', 'cacEnabled', 'certRevocationInfo', 'caCertFileName', 'createdBy', 'tenantId', 'name', 'createdTime', 'links', 'lastUpdatedTime', 'extId2', 'extId']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-        all_params.append('if_match')
-        all_params.append('if_none_match')
+                           async_req=True
+        :return: An instance of class :class:`~ntnx_iam_py_client.models.iam.v4.authn.UpdateSamlIdentityProviderApiResponse`.
 
-        params = locals()
+                 If the method is called asynchronously, returns the request thread.
+        """ # noqa: E501
+        kwargs['_return_http_data_only'] = True
+
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
-            if key not in all_params:
-                raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method handle_update_cert_auth_provider" % key
-                )
             params[key] = val
         del params['kwargs']
+        del params['self']
+
         # verify the required parameter 'extId' is set
-        if ('extId' not in params or
-                params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `handle_update_cert_auth_provider`")  # noqa: E501
+        if ('extId' not in params or params['extId'] is None):
+            raise ValueError("Missing the required parameter `extId` when calling `update_saml_identity_provider_by_id`")  # noqa: E501
+        # verify the required parameter 'body' is set
+        if ('body' not in params or params['body'] is None):
+            raise ValueError("Missing the required parameter `body` when calling `update_saml_identity_provider_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'extId' in params:
+        if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'if_match' in params and params['if_match'] is not None:
-            header_params['If-Match'] = params['if_match']  # noqa: E501
-        if 'if_none_match' in params and params['if_none_match'] is not None:
-            header_params['If-None-Match'] = params['if_none_match']  # noqa: E501
-
-        form_params = []
-        local_var_files = {}
-        if 'clientCaChain' in params:
-            form_params.append(('clientCaChain', params['clientCaChain']))  # noqa: E501
-        if 'dirSvcExtID' in params:
-            form_params.append(('dirSvcExtID', params['dirSvcExtID']))  # noqa: E501
-        if 'certAuthEnabled' in params:
-            form_params.append(('certAuthEnabled', params['certAuthEnabled']))  # noqa: E501
-        if 'cacEnabled' in params:
-            form_params.append(('cacEnabled', params['cacEnabled']))  # noqa: E501
-        if 'certRevocationInfo' in params:
-            form_params.append(('certRevocationInfo', params['certRevocationInfo']))  # noqa: E501
-        if 'caCertFileName' in params:
-            form_params.append(('caCertFileName', params['caCertFileName']))  # noqa: E501
-        if 'createdBy' in params:
-            form_params.append(('createdBy', params['createdBy']))  # noqa: E501
-        if 'tenantId' in params:
-            form_params.append(('tenantId', params['tenantId']))  # noqa: E501
-        if 'name' in params:
-            form_params.append(('name', params['name']))  # noqa: E501
-        if 'createdTime' in params:
-            form_params.append(('createdTime', params['createdTime']))  # noqa: E501
-        if 'links' in params:
-            form_params.append(('links', params['links']))  # noqa: E501
-            collection_formats['links'] = 'multi'  # noqa: E501
-        if 'lastUpdatedTime' in params:
-            form_params.append(('lastUpdatedTime', params['lastUpdatedTime']))  # noqa: E501
-        if 'extId2' in params:
-            form_params.append(('extId', params['extId2']))  # noqa: E501
-
-        body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
+        header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['multipart/form-data'])  # noqa: E501
+        header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
+            ['application/json'])  # noqa: E501
+        if 'Content-Type' in params and params.get('Content-Type') is not None:
+            header_params['Content-Type'] = params.get('Content-Type')
+
+        # Process operation specific headers
+        extra_params = []
+        extra_params.append('async_req')
+        extra_params.append('_return_http_data_only')
+        extra_params.append('_preload_content')
+        extra_params.append('_request_timeout')
+        all_params = set(['extId', 'body'])
+        all_params.update(extra_params)
+        for key, val in six.iteritems(params):
+            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
+                if key.lower() == 'if_match'.lower():
+                    key = 'If-Match'
+                elif key.lower() == 'if_none_match'.lower():
+                    key = 'If-None-Match'
+                header_params[key] = val
+
+        form_params = []
+        local_var_files = {}
 
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/api/iam/v4.0.a1/authn/cert-auth-providers/{extId}', 'PUT',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type='iam.v4.authn.UpdateCertAuthProviderApiResponse',  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+        body_params = None
+        if 'body' in params and params['body'] is not None:
+            body_params = params['body']
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authn/saml-identity-providers/{extId}', 'PUT',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authn.UpdateSamlIdentityProviderApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authn/saml-identity-providers/{extId}', 'PUT',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authn.UpdateSamlIdentityProviderApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/api/directory_service_api.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/api/directory_services_api.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,805 +1,878 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 from __future__ import absolute_import
 
 import re  # noqa: F401
 
 # python 2 and python 3 compatibility library
 import six
 
 from ntnx_iam_py_client.api_client import ApiClient
 
 
-class DirectoryServiceApi(object):
+class DirectoryServicesApi(object):
     """IGNORE:
-    NOTE: This class is auto generated by the swagger code generator program.
-
-    Do not edit the class manually.
-    Ref: https://github.com/swagger-api/swagger-codegen
+    NOTE: A placeholder for class level description
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
+
         self.api_client = api_client
+        self.__headers_to_skip = { 'authorization', 'cookie', 'host', 'user-agent' }
 
-    def connection_status_directory_service(self, body, extId, **kwargs):  # noqa: E501
-        """Check directory service connection
-        Check connection to the directory service
+    def connection_status_directory_service(self, extId, body, **kwargs):  # noqa: E501
+        """Check Directory Service connection
 
-        >>> response = api.connection_status_directory_service(body, extId)
+        >>> response = api.connection_status_directory_service(extId, body)
 
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
+        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.connection_status_directory_service(body, extId, async_req=True)
+        >>> thread = api.connection_status_directory_service(extId, body, async_req=True)
         >>> result = thread.get()
 
-        :param iam.v4.authn.DirectoryServiceConnectionRequest body: Check connection to the directory service (required)
-        :param str extId: External identifier of the directory service (required)
-        :param bool async_req:
-        :return: iam.v4.authn.ConnectionDirectoryServiceApiResponse
-
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """ # noqa: E501
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.connection_status_directory_service_with_http_info(body, extId, **kwargs)  # noqa: E501
-        else:
-            (data) = self.connection_status_directory_service_with_http_info(body, extId, **kwargs)  # noqa: E501
-            return data
-
-    def connection_status_directory_service_with_http_info(self, body, extId, **kwargs):  # noqa: E501
-        """Check directory service connection
-        Check connection to the directory service
+        :param extId: External identifier of the Directory Service.
+        :type extId:
 
-        >>> response = api.connection_status_directory_service(body, extId)
+            :class:`str`, required
+        :param body: Check connection to the Directory Service.
+        :type body:
 
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
+            :class:`~ntnx_iam_py_client.models.iam.v4.authn.DirectoryServiceConnectionRequest`, required
+        :param kwargs: kwargs for the method.
+                       The following can be passed for an asynchronous HTTP call::
 
-        >>> thread = api.connection_status_directory_service_with_http_info(body, extId, async_req=True)
-        >>> result = thread.get()
+                           async_req=True
+        :return: An instance of class :class:`~ntnx_iam_py_client.models.iam.v4.authn.ConnectionDirectoryServiceApiResponse`.
 
-        :param iam.v4.authn.DirectoryServiceConnectionRequest body: Check connection to the directory service (required)
-        :param str extId: External identifier of the directory service (required)
-        :param bool async_req:
-        :return: iam.v4.authn.ConnectionDirectoryServiceApiResponse
-
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        all_params = ['body', 'extId']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-        all_params.append('if_match')
-        all_params.append('if_none_match')
+                 If the method is called asynchronously, returns the request thread.
+        """ # noqa: E501
+        kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
-            if key not in all_params:
-                raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method connection_status_directory_service" % key
-                )
             params[key] = val
         del params['kwargs']
-        # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
-            raise ValueError("Missing the required parameter `body` when calling `connection_status_directory_service`")  # noqa: E501
+        del params['self']
+
         # verify the required parameter 'extId' is set
-        if ('extId' not in params or
-                params['extId'] is None):
+        if ('extId' not in params or params['extId'] is None):
             raise ValueError("Missing the required parameter `extId` when calling `connection_status_directory_service`")  # noqa: E501
+        # verify the required parameter 'body' is set
+        if ('body' not in params or params['body'] is None):
+            raise ValueError("Missing the required parameter `body` when calling `connection_status_directory_service`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'extId' in params:
+        if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'if_match' in params and params['if_match'] is not None:
-            header_params['If-Match'] = params['if_match']  # noqa: E501
-        if 'if_none_match' in params and params['if_none_match'] is not None:
-            header_params['If-None-Match'] = params['if_none_match']  # noqa: E501
-
-        form_params = []
-        local_var_files = {}
-
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
+        header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
+        header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
             ['application/json'])  # noqa: E501
+        if 'Content-Type' in params and params.get('Content-Type') is not None:
+            header_params['Content-Type'] = params.get('Content-Type')
+
+        # Process operation specific headers
+        extra_params = []
+        extra_params.append('async_req')
+        extra_params.append('_return_http_data_only')
+        extra_params.append('_preload_content')
+        extra_params.append('_request_timeout')
+        all_params = set(['extId', 'body'])
+        all_params.update(extra_params)
+        for key, val in six.iteritems(params):
+            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
+                if key.lower() == 'if_match'.lower():
+                    key = 'If-Match'
+                elif key.lower() == 'if_none_match'.lower():
+                    key = 'If-None-Match'
+                header_params[key] = val
+
+        form_params = []
+        local_var_files = {}
 
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/api/iam/v4.0.a1/authn/directory-services/{extId}/connection-status', 'POST',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type='iam.v4.authn.ConnectionDirectoryServiceApiResponse',  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+        body_params = None
+        if 'body' in params and params['body'] is not None:
+            body_params = params['body']
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authn/directory-services/{extId}/$actions/verify-connection-status', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authn.ConnectionDirectoryServiceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authn/directory-services/{extId}/$actions/verify-connection-status', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authn.ConnectionDirectoryServiceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
     def create_directory_service(self, body, **kwargs):  # noqa: E501
-        """Create directory service
-        Create a directory service
+        """Create Directory Service
 
         >>> response = api.create_directory_service(body)
 
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
+        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
         >>> thread = api.create_directory_service(body, async_req=True)
         >>> result = thread.get()
 
-        :param iam.v4.authn.DirectoryService body: Create a directory service (required)
-        :param bool async_req:
-        :return: iam.v4.authn.CreateDirectoryServiceApiResponse
-
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """ # noqa: E501
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.create_directory_service_with_http_info(body, **kwargs)  # noqa: E501
-        else:
-            (data) = self.create_directory_service_with_http_info(body, **kwargs)  # noqa: E501
-            return data
-
-    def create_directory_service_with_http_info(self, body, **kwargs):  # noqa: E501
-        """Create directory service
-        Create a directory service
-
-        >>> response = api.create_directory_service(body)
+        :param body: Create a Directory Service.
+        :type body:
 
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
+            :class:`~ntnx_iam_py_client.models.iam.v4.authn.DirectoryService`, required
+        :param kwargs: kwargs for the method.
+                       The following can be passed for an asynchronous HTTP call::
 
-        >>> thread = api.create_directory_service_with_http_info(body, async_req=True)
-        >>> result = thread.get()
+                           async_req=True
+        :return: An instance of class :class:`~ntnx_iam_py_client.models.iam.v4.authn.CreateDirectoryServiceApiResponse`.
 
-        :param iam.v4.authn.DirectoryService body: Create a directory service (required)
-        :param bool async_req:
-        :return: iam.v4.authn.CreateDirectoryServiceApiResponse
-
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        all_params = ['body']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-        all_params.append('if_match')
-        all_params.append('if_none_match')
+                 If the method is called asynchronously, returns the request thread.
+        """ # noqa: E501
+        kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
-            if key not in all_params:
-                raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method create_directory_service" % key
-                )
             params[key] = val
         del params['kwargs']
+        del params['self']
+
         # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
+        if ('body' not in params or params['body'] is None):
             raise ValueError("Missing the required parameter `body` when calling `create_directory_service`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'if_match' in params and params['if_match'] is not None:
-            header_params['If-Match'] = params['if_match']  # noqa: E501
-        if 'if_none_match' in params and params['if_none_match'] is not None:
-            header_params['If-None-Match'] = params['if_none_match']  # noqa: E501
-
-        form_params = []
-        local_var_files = {}
-
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
+        header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
+        header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
             ['application/json'])  # noqa: E501
+        if 'Content-Type' in params and params.get('Content-Type') is not None:
+            header_params['Content-Type'] = params.get('Content-Type')
+
+        # Process operation specific headers
+        extra_params = []
+        extra_params.append('async_req')
+        extra_params.append('_return_http_data_only')
+        extra_params.append('_preload_content')
+        extra_params.append('_request_timeout')
+        all_params = set(['body'])
+        all_params.update(extra_params)
+        for key, val in six.iteritems(params):
+            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
+                if key.lower() == 'if_match'.lower():
+                    key = 'If-Match'
+                elif key.lower() == 'if_none_match'.lower():
+                    key = 'If-None-Match'
+                header_params[key] = val
+
+        form_params = []
+        local_var_files = {}
 
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/api/iam/v4.0.a1/authn/directory-services', 'POST',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type='iam.v4.authn.CreateDirectoryServiceApiResponse',  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def get_directory_service_list(self, **kwargs):  # noqa: E501
-        """List directory service(s)
-        List all directory service(s)
+        body_params = None
+        if 'body' in params and params['body'] is not None:
+            body_params = params['body']
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authn/directory-services', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authn.CreateDirectoryServiceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authn/directory-services', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authn.CreateDirectoryServiceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
+
+    def delete_directory_service_by_id(self, extId, **kwargs):  # noqa: E501
+        """Delete Directory Service
+
+        >>> response = api.delete_directory_service_by_id(extId)
+
+        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
+
+        >>> thread = api.delete_directory_service_by_id(extId, async_req=True)
+        >>> result = thread.get()
+
+        :param extId: External identifier of the Directory Service.
+        :type extId:
+
+            :class:`str`, required
+        :param kwargs: kwargs for the method.
+                       The following can be passed for an asynchronous HTTP call::
 
-        >>> response = api.get_directory_service_list((optional) _page, (optional) _limit, (optional) _filter, (optional) _orderby, (optional) _select)
+                           async_req=True
+        :return: An instance of class :class:`~ntnx_iam_py_client.models.iam.v4.authn.DeleteDirectoryServiceApiResponse`.
 
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
+                 If the method is called asynchronously, returns the request thread.
+        """ # noqa: E501
+        kwargs['_return_http_data_only'] = True
 
-        >>> thread = api.get_directory_service_list(async_req=True)
-        >>> result = thread.get()
+        params = dict(locals())
+        for key, val in six.iteritems(params['kwargs']):
+            params[key] = val
+        del params['kwargs']
+        del params['self']
 
-        :param int _page: A URL query parameter that specifies the page number of the result set.  Must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range will lead to no results being returned.
+        # verify the required parameter 'extId' is set
+        if ('extId' not in params or params['extId'] is None):
+            raise ValueError("Missing the required parameter `extId` when calling `delete_directory_service_by_id`")  # noqa: E501
 
-        :param int _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 0 and 100. Any number out of this range will lead to a validation error. If the limit is not provided a default value of 50 records will be returned in the result set.
+        collection_formats = {}
 
-        :param str _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the OData V4.01 URL conventions.
-        The filter can be applied on the following fields:
-        
-        - createdBy
-        - domainName
-        - extId
-        - name
-        
-        :param str _orderby: A URL query parameter that allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified the resources will be sorted in ascending order by default. For example, 'orderby=templateName desc' would get all templates sorted by templateName in desc order.
-        The orderby can be applied to the following fields:
-        
-        - createdTime
-        - domainName
-        - lastUpdatedTime
-        - name
-        
-        :param str _select: A URL query parameter that allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the OData V4.01 URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e. *), then all properties on the matching resource will be returned.
-- createdBy
-- createdTime
-- directoryType
-- domainName
-- extId
-- groupSearchType
-- lastUpdatedTime
-- links
-- name
-- openLdapConfiguration
-- serviceAccount
-- tenantId
-- url
-- whiteListedGroups
+        path_params = {}
+        if 'extId' in params and params['extId'] is not None:
+            path_params['extId'] = params['extId']  # noqa: E501
 
-        :param bool async_req:
-        :return: iam.v4.authn.ListDirectoryServiceApiResponse
+        query_params = []
 
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """ # noqa: E501
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.get_directory_service_list_with_http_info(**kwargs)  # noqa: E501
-        else:
-            (data) = self.get_directory_service_list_with_http_info(**kwargs)  # noqa: E501
-            return data
-
-    def get_directory_service_list_with_http_info(self, **kwargs):  # noqa: E501
-        """List directory service(s)
-        List all directory service(s)
+        header_params = {}
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client._select_header_accept(
+            ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
-        >>> response = api.get_directory_service_list((optional) _page, (optional) _limit, (optional) _filter, (optional) _orderby, (optional) _select)
+        # Process operation specific headers
+        extra_params = []
+        extra_params.append('async_req')
+        extra_params.append('_return_http_data_only')
+        extra_params.append('_preload_content')
+        extra_params.append('_request_timeout')
+        all_params = set(['extId'])
+        all_params.update(extra_params)
+        for key, val in six.iteritems(params):
+            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
+                if key.lower() == 'if_match'.lower():
+                    key = 'If-Match'
+                elif key.lower() == 'if_none_match'.lower():
+                    key = 'If-None-Match'
+                header_params[key] = val
+
+        form_params = []
+        local_var_files = {}
 
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
+        # Authentication setting
+        auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        >>> thread = api.get_directory_service_list_with_http_info(async_req=True)
-        >>> result = thread.get()
+        body_params = None
 
-        :param int _page: A URL query parameter that specifies the page number of the result set.  Must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range will lead to no results being returned.
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authn/directory-services/{extId}', 'DELETE',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authn.DeleteDirectoryServiceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authn/directory-services/{extId}', 'DELETE',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authn.DeleteDirectoryServiceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
+
+    def get_directory_service_by_id(self, extId, **kwargs):  # noqa: E501
+        """Get Directory Service
+
+        >>> response = api.get_directory_service_by_id(extId)
+
+        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
+
+        >>> thread = api.get_directory_service_by_id(extId, async_req=True)
+        >>> result = thread.get()
+
+        :param extId: External identifier of the Directory Service.
+        :type extId:
+
+            :class:`str`, required
+        :param kwargs: kwargs for the method.
+                       The following can be passed for an asynchronous HTTP call::
 
-        :param int _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 0 and 100. Any number out of this range will lead to a validation error. If the limit is not provided a default value of 50 records will be returned in the result set.
+                           async_req=True
+        :return: An instance of class :class:`~ntnx_iam_py_client.models.iam.v4.authn.GetDirectoryServiceApiResponse`.
 
-        :param str _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the OData V4.01 URL conventions.
-        The filter can be applied on the following fields:
-        
-        - createdBy
-        - domainName
-        - extId
-        - name
-        
-        :param str _orderby: A URL query parameter that allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified the resources will be sorted in ascending order by default. For example, 'orderby=templateName desc' would get all templates sorted by templateName in desc order.
-        The orderby can be applied to the following fields:
-        
-        - createdTime
-        - domainName
-        - lastUpdatedTime
-        - name
-        
-        :param str _select: A URL query parameter that allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the OData V4.01 URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e. *), then all properties on the matching resource will be returned.
-- createdBy
-- createdTime
-- directoryType
-- domainName
-- extId
-- groupSearchType
-- lastUpdatedTime
-- links
-- name
-- openLdapConfiguration
-- serviceAccount
-- tenantId
-- url
-- whiteListedGroups
-
-        :param bool async_req:
-        :return: iam.v4.authn.ListDirectoryServiceApiResponse
-
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        all_params = ['_page', '_limit', '_filter', '_orderby', '_select']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-        all_params.append('if_match')
-        all_params.append('if_none_match')
+                 If the method is called asynchronously, returns the request thread.
+        """ # noqa: E501
+        kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
-            if key not in all_params:
-                raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_directory_service_list" % key
-                )
             params[key] = val
         del params['kwargs']
+        del params['self']
+
+        # verify the required parameter 'extId' is set
+        if ('extId' not in params or params['extId'] is None):
+            raise ValueError("Missing the required parameter `extId` when calling `get_directory_service_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
+        if 'extId' in params and params['extId'] is not None:
+            path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
-        if '_page' in params:
-            query_params.append(('$page', params['_page']))  # noqa: E501
-        if '_limit' in params:
-            query_params.append(('$limit', params['_limit']))  # noqa: E501
-        if '_filter' in params:
-            query_params.append(('$filter', params['_filter']))  # noqa: E501
-        if '_orderby' in params:
-            query_params.append(('$orderby', params['_orderby']))  # noqa: E501
-        if '_select' in params:
-            query_params.append(('$select', params['_select']))  # noqa: E501
 
         header_params = {}
-        if 'if_match' in params and params['if_match'] is not None:
-            header_params['If-Match'] = params['if_match']  # noqa: E501
-        if 'if_none_match' in params and params['if_none_match'] is not None:
-            header_params['If-None-Match'] = params['if_none_match']  # noqa: E501
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client._select_header_accept(
+            ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
+
+        # Process operation specific headers
+        extra_params = []
+        extra_params.append('async_req')
+        extra_params.append('_return_http_data_only')
+        extra_params.append('_preload_content')
+        extra_params.append('_request_timeout')
+        all_params = set(['extId'])
+        all_params.update(extra_params)
+        for key, val in six.iteritems(params):
+            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
+                if key.lower() == 'if_match'.lower():
+                    key = 'If-Match'
+                elif key.lower() == 'if_none_match'.lower():
+                    key = 'If-None-Match'
+                header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/api/iam/v4.0.a1/authn/directory-services', 'GET',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type='iam.v4.authn.ListDirectoryServiceApiResponse',  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def get_directory_serviceby_id(self, extId, **kwargs):  # noqa: E501
-        """Get directory service
-        View a directory service
-
-        >>> response = api.get_directory_serviceby_id(extId)
-
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
+        body_params = None
 
-        >>> thread = api.get_directory_serviceby_id(extId, async_req=True)
-        >>> result = thread.get()
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authn/directory-services/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authn.GetDirectoryServiceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authn/directory-services/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authn.GetDirectoryServiceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
+
+    def list_directory_services(self, _page=None, _limit=None, _filter=None, _orderby=None, _select=None, **kwargs):  # noqa: E501
+        """List Directory Service(s)
+
+        >>> response = api.list_directory_services((optional) _page, (optional) _limit, (optional) _filter, (optional) _orderby, (optional) _select)
+
+        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
+
+        >>> thread = api.list_directory_services(async_req=True)
+        >>> result = thread.get()
+
+        :param _page: A URL query parameter that specifies the page number of the result set. It must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range might lead to no results. 
+        :type _page:
+
+            :class:`int`
+        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided, a default value of 50 records will be returned in the result set. 
+        :type _limit:
+
+            :class:`int`
+        :param _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the [OData V4.01](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html) URL conventions. For example, filter '$filter=name eq 'karbon-ntnx-1.0' would filter the result on cluster name 'karbon-ntnx1.0', filter '$filter=startswith(name, 'C')' would filter on cluster name starting with 'C'. The filter can be applied to the following fields: - createdBy - domainName - extId - name 
+        :type _filter:
+
+            :class:`str`
+        :param _orderby: A URL query parameter that allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified, the resources will be sorted in ascending order by default. For example, '$orderby=templateName desc' would get all templates sorted by templateName in descending order. The orderby can be applied to the following fields: - createdTime - domainName - lastUpdatedTime - name 
+        :type _orderby:
+
+            :class:`str`
+        :param _select: A URL query parameter that allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the [OData V4.01](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html) URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e., *), then all properties on the matching resource will be returned. - createdBy - createdTime - directoryType - domainName - extId - groupSearchType - lastUpdatedTime - links - name - openLdapConfiguration/userConfiguration - openLdapConfiguration/userGroupConfiguration - secondaryUrls - serviceAccount/password - serviceAccount/username - tenantId - url - whiteListedGroups 
+        :type _select:
+
+            :class:`str`
+        :param kwargs: kwargs for the method.
+                       The following can be passed for an asynchronous HTTP call::
 
-        :param str extId: External identifier of the directory service (required)
-        :param bool async_req:
-        :return: iam.v4.authn.GetDirectoryServiceApiResponse
+                           async_req=True
+        :return: An instance of class :class:`~ntnx_iam_py_client.models.iam.v4.authn.ListDirectoryServicesApiResponse`.
 
-                 If the method is called asynchronously,
-                 returns the request thread.
+                 If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.get_directory_serviceby_id_with_http_info(extId, **kwargs)  # noqa: E501
-        else:
-            (data) = self.get_directory_serviceby_id_with_http_info(extId, **kwargs)  # noqa: E501
-            return data
-
-    def get_directory_serviceby_id_with_http_info(self, extId, **kwargs):  # noqa: E501
-        """Get directory service
-        View a directory service
 
-        >>> response = api.get_directory_serviceby_id(extId)
-
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-
-        >>> thread = api.get_directory_serviceby_id_with_http_info(extId, async_req=True)
-        >>> result = thread.get()
-
-        :param str extId: External identifier of the directory service (required)
-        :param bool async_req:
-        :return: iam.v4.authn.GetDirectoryServiceApiResponse
-
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        all_params = ['extId']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-        all_params.append('if_match')
-        all_params.append('if_none_match')
-
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
-            if key not in all_params:
-                raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_directory_serviceby_id" % key
-                )
             params[key] = val
         del params['kwargs']
-        # verify the required parameter 'extId' is set
-        if ('extId' not in params or
-                params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `get_directory_serviceby_id`")  # noqa: E501
+        del params['self']
+
 
         collection_formats = {}
 
         path_params = {}
-        if 'extId' in params:
-            path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
+        if '_page' in params and params['_page'] is not None:
+            query_params.append(('$page', params['_page']))  # noqa: E501
+        if '_limit' in params and params['_limit'] is not None:
+            query_params.append(('$limit', params['_limit']))  # noqa: E501
+        if '_filter' in params and params['_filter'] is not None:
+            query_params.append(('$filter', params['_filter']))  # noqa: E501
+        if '_orderby' in params and params['_orderby'] is not None:
+            query_params.append(('$orderby', params['_orderby']))  # noqa: E501
+        if '_select' in params and params['_select'] is not None:
+            query_params.append(('$select', params['_select']))  # noqa: E501
 
         header_params = {}
-        if 'if_match' in params and params['if_match'] is not None:
-            header_params['If-Match'] = params['if_match']  # noqa: E501
-        if 'if_none_match' in params and params['if_none_match'] is not None:
-            header_params['If-None-Match'] = params['if_none_match']  # noqa: E501
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client._select_header_accept(
+            ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
+
+        # Process operation specific headers
+        extra_params = []
+        extra_params.append('async_req')
+        extra_params.append('_return_http_data_only')
+        extra_params.append('_preload_content')
+        extra_params.append('_request_timeout')
+        all_params = set(['_page', '_limit', '_filter', '_orderby', '_select'])
+        all_params.update(extra_params)
+        for key, val in six.iteritems(params):
+            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
+                if key.lower() == 'if_match'.lower():
+                    key = 'If-Match'
+                elif key.lower() == 'if_none_match'.lower():
+                    key = 'If-None-Match'
+                header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/api/iam/v4.0.a1/authn/directory-services/{extId}', 'GET',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type='iam.v4.authn.GetDirectoryServiceApiResponse',  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def search_directory_service(self, body, extId, **kwargs):  # noqa: E501
-        """Search user/group in directory service
-        Search user or group in the directory service
-
-        >>> response = api.search_directory_service(body, extId)
+        body_params = None
 
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authn/directory-services', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authn.ListDirectoryServicesApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authn/directory-services', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authn.ListDirectoryServicesApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
+
+    def search_directory_service(self, extId, body, **kwargs):  # noqa: E501
+        """Search user/group in Directory Service
+
+        >>> response = api.search_directory_service(extId, body)
+
+        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
+
+        >>> thread = api.search_directory_service(extId, body, async_req=True)
+        >>> result = thread.get()
+
+        :param extId: External identifier of the Directory Service.
+        :type extId:
+
+            :class:`str`, required
+        :param body: Search User or group in the Directory Service.
+        :type body:
+
+            :class:`~ntnx_iam_py_client.models.iam.v4.authn.DirectoryServiceSearchQuery`, required
+        :param kwargs: kwargs for the method.
+                       The following can be passed for an asynchronous HTTP call::
 
-        >>> thread = api.search_directory_service(body, extId, async_req=True)
-        >>> result = thread.get()
+                           async_req=True
+        :return: An instance of class :class:`~ntnx_iam_py_client.models.iam.v4.authn.SearchDirectoryServiceApiResponse`.
 
-        :param iam.v4.authn.DirectoryServiceSearchQuery body: Search user or group in the directory service (required)
-        :param str extId: External identifier of the directory service (required)
-        :param bool async_req:
-        :return: iam.v4.authn.SearchDirectoryServiceApiResponse
-
-                 If the method is called asynchronously,
-                 returns the request thread.
+                 If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.search_directory_service_with_http_info(body, extId, **kwargs)  # noqa: E501
-        else:
-            (data) = self.search_directory_service_with_http_info(body, extId, **kwargs)  # noqa: E501
-            return data
-
-    def search_directory_service_with_http_info(self, body, extId, **kwargs):  # noqa: E501
-        """Search user/group in directory service
-        Search user or group in the directory service
-
-        >>> response = api.search_directory_service(body, extId)
 
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-
-        >>> thread = api.search_directory_service_with_http_info(body, extId, async_req=True)
-        >>> result = thread.get()
-
-        :param iam.v4.authn.DirectoryServiceSearchQuery body: Search user or group in the directory service (required)
-        :param str extId: External identifier of the directory service (required)
-        :param bool async_req:
-        :return: iam.v4.authn.SearchDirectoryServiceApiResponse
-
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        all_params = ['body', 'extId']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-        all_params.append('if_match')
-        all_params.append('if_none_match')
-
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
-            if key not in all_params:
-                raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method search_directory_service" % key
-                )
             params[key] = val
         del params['kwargs']
-        # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
-            raise ValueError("Missing the required parameter `body` when calling `search_directory_service`")  # noqa: E501
+        del params['self']
+
         # verify the required parameter 'extId' is set
-        if ('extId' not in params or
-                params['extId'] is None):
+        if ('extId' not in params or params['extId'] is None):
             raise ValueError("Missing the required parameter `extId` when calling `search_directory_service`")  # noqa: E501
+        # verify the required parameter 'body' is set
+        if ('body' not in params or params['body'] is None):
+            raise ValueError("Missing the required parameter `body` when calling `search_directory_service`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'extId' in params:
+        if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'if_match' in params and params['if_match'] is not None:
-            header_params['If-Match'] = params['if_match']  # noqa: E501
-        if 'if_none_match' in params and params['if_none_match'] is not None:
-            header_params['If-None-Match'] = params['if_none_match']  # noqa: E501
-
-        form_params = []
-        local_var_files = {}
-
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
+        header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
+        header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
             ['application/json'])  # noqa: E501
+        if 'Content-Type' in params and params.get('Content-Type') is not None:
+            header_params['Content-Type'] = params.get('Content-Type')
 
-        # Authentication setting
-        auth_settings = ['basicAuthScheme']  # noqa: E501
+        # Process operation specific headers
+        extra_params = []
+        extra_params.append('async_req')
+        extra_params.append('_return_http_data_only')
+        extra_params.append('_preload_content')
+        extra_params.append('_request_timeout')
+        all_params = set(['extId', 'body'])
+        all_params.update(extra_params)
+        for key, val in six.iteritems(params):
+            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
+                if key.lower() == 'if_match'.lower():
+                    key = 'If-Match'
+                elif key.lower() == 'if_none_match'.lower():
+                    key = 'If-None-Match'
+                header_params[key] = val
 
-        return self.api_client.call_api(
-            '/api/iam/v4.0.a1/authn/directory-services/{extId}/search', 'POST',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type='iam.v4.authn.SearchDirectoryServiceApiResponse',  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def update_directory_service(self, body, extId, **kwargs):  # noqa: E501
-        """Update directory service
-        Update a directory service
+        form_params = []
+        local_var_files = {}
 
-        >>> response = api.update_directory_service(body, extId)
+        # Authentication setting
+        auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
+        body_params = None
+        if 'body' in params and params['body'] is not None:
+            body_params = params['body']
 
-        >>> thread = api.update_directory_service(body, extId, async_req=True)
-        >>> result = thread.get()
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authn/directory-services/{extId}/$actions/search', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authn.SearchDirectoryServiceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authn/directory-services/{extId}/$actions/search', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authn.SearchDirectoryServiceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
+
+    def update_directory_service_by_id(self, extId, body, **kwargs):  # noqa: E501
+        """Update Directory Service
+
+        >>> response = api.update_directory_service_by_id(extId, body)
+
+        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
+
+        >>> thread = api.update_directory_service_by_id(extId, body, async_req=True)
+        >>> result = thread.get()
+
+        :param extId: External identifier of the Directory Service.
+        :type extId:
+
+            :class:`str`, required
+        :param body: Update a Directory Service.
+        :type body:
+
+            :class:`~ntnx_iam_py_client.models.iam.v4.authn.DirectoryService`, required
+        :param kwargs: kwargs for the method.
+                       The following can be passed for an asynchronous HTTP call::
 
-        :param iam.v4.authn.DirectoryService body: Update a directory service (required)
-        :param str extId: External identifier of the directory service (required)
-        :param bool async_req:
-        :return: iam.v4.authn.UpdateDirectoryServiceApiResponse
+                           async_req=True
+        :return: An instance of class :class:`~ntnx_iam_py_client.models.iam.v4.authn.UpdateDirectoryServiceApiResponse`.
 
-                 If the method is called asynchronously,
-                 returns the request thread.
+                 If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.update_directory_service_with_http_info(body, extId, **kwargs)  # noqa: E501
-        else:
-            (data) = self.update_directory_service_with_http_info(body, extId, **kwargs)  # noqa: E501
-            return data
-
-    def update_directory_service_with_http_info(self, body, extId, **kwargs):  # noqa: E501
-        """Update directory service
-        Update a directory service
-
-        >>> response = api.update_directory_service(body, extId)
 
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-
-        >>> thread = api.update_directory_service_with_http_info(body, extId, async_req=True)
-        >>> result = thread.get()
-
-        :param iam.v4.authn.DirectoryService body: Update a directory service (required)
-        :param str extId: External identifier of the directory service (required)
-        :param bool async_req:
-        :return: iam.v4.authn.UpdateDirectoryServiceApiResponse
-
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        all_params = ['body', 'extId']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-        all_params.append('if_match')
-        all_params.append('if_none_match')
-
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
-            if key not in all_params:
-                raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method update_directory_service" % key
-                )
             params[key] = val
         del params['kwargs']
-        # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
-            raise ValueError("Missing the required parameter `body` when calling `update_directory_service`")  # noqa: E501
+        del params['self']
+
         # verify the required parameter 'extId' is set
-        if ('extId' not in params or
-                params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `update_directory_service`")  # noqa: E501
+        if ('extId' not in params or params['extId'] is None):
+            raise ValueError("Missing the required parameter `extId` when calling `update_directory_service_by_id`")  # noqa: E501
+        # verify the required parameter 'body' is set
+        if ('body' not in params or params['body'] is None):
+            raise ValueError("Missing the required parameter `body` when calling `update_directory_service_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'extId' in params:
+        if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'if_match' in params and params['if_match'] is not None:
-            header_params['If-Match'] = params['if_match']  # noqa: E501
-        if 'if_none_match' in params and params['if_none_match'] is not None:
-            header_params['If-None-Match'] = params['if_none_match']  # noqa: E501
-
-        form_params = []
-        local_var_files = {}
-
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
+        header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
+        header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
             ['application/json'])  # noqa: E501
+        if 'Content-Type' in params and params.get('Content-Type') is not None:
+            header_params['Content-Type'] = params.get('Content-Type')
+
+        # Process operation specific headers
+        extra_params = []
+        extra_params.append('async_req')
+        extra_params.append('_return_http_data_only')
+        extra_params.append('_preload_content')
+        extra_params.append('_request_timeout')
+        all_params = set(['extId', 'body'])
+        all_params.update(extra_params)
+        for key, val in six.iteritems(params):
+            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
+                if key.lower() == 'if_match'.lower():
+                    key = 'If-Match'
+                elif key.lower() == 'if_none_match'.lower():
+                    key = 'If-None-Match'
+                header_params[key] = val
+
+        form_params = []
+        local_var_files = {}
 
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/api/iam/v4.0.a1/authn/directory-services/{extId}', 'PUT',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type='iam.v4.authn.UpdateDirectoryServiceApiResponse',  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+        body_params = None
+        if 'body' in params and params['body'] is not None:
+            body_params = params['body']
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authn/directory-services/{extId}', 'PUT',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authn.UpdateDirectoryServiceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authn/directory-services/{extId}', 'PUT',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authn.UpdateDirectoryServiceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/api/operation_api.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/api/operations_api.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,325 +1,277 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 from __future__ import absolute_import
 
 import re  # noqa: F401
 
 # python 2 and python 3 compatibility library
 import six
 
 from ntnx_iam_py_client.api_client import ApiClient
 
 
-class OperationApi(object):
+class OperationsApi(object):
     """IGNORE:
-    NOTE: This class is auto generated by the swagger code generator program.
-
-    Do not edit the class manually.
-    Ref: https://github.com/swagger-api/swagger-codegen
+    NOTE: A placeholder for class level description
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
+
         self.api_client = api_client
+        self.__headers_to_skip = { 'authorization', 'cookie', 'host', 'user-agent' }
 
-    def list_operation_api(self, **kwargs):  # noqa: E501
-        """List operation(s)
-        List all the operation(s)
+    def get_operation_by_id(self, extId, **kwargs):  # noqa: E501
+        """Get Operation
 
-        >>> response = api.list_operation_api((optional) _page, (optional) _limit, (optional) _filter, (optional) _orderby, (optional) _select)
+        >>> response = api.get_operation_by_id(extId)
 
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
+        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.list_operation_api(async_req=True)
+        >>> thread = api.get_operation_by_id(extId, async_req=True)
         >>> result = thread.get()
 
-        :param int _page: A URL query parameter that specifies the page number of the result set.  Must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range will lead to no results being returned.
+        :param extId: ExtId of the Operation.
+        :type extId:
 
-        :param int _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 0 and 100. Any number out of this range will lead to a validation error. If the limit is not provided a default value of 50 records will be returned in the result set.
+            :class:`str`, required
+        :param kwargs: kwargs for the method.
+                       The following can be passed for an asynchronous HTTP call::
 
-        :param str _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the OData V4.01 URL conventions.
-        The filter can be applied on the following fields:
-        
-        - clientName
-        - createdTime
-        - displayName
-        - extId
-        - lastUpdatedTime
-        - objectType
-        
-        :param str _orderby: A URL query parameter that allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified the resources will be sorted in ascending order by default. For example, 'orderby=templateName desc' would get all templates sorted by templateName in desc order.
-        The orderby can be applied to the following fields:
-        
-        - createdTime
-        - displayName
-        - extId
-        - lastUpdatedTime
-        - objectType
-        
-        :param str _select: A URL query parameter that allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the OData V4.01 URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e. *), then all properties on the matching resource will be returned.
-- clientName
-- createdTime
-- description
-- displayName
-- extId
-- lastUpdatedTime
-- links
-- objectType
-- tenantId
+                           async_req=True
+        :return: An instance of class :class:`~ntnx_iam_py_client.models.iam.v4.authz.GetOperationApiResponse`.
 
-        :param bool async_req:
-        :return: iam.v4.authz.ListOperationApiResponse
-
-                 If the method is called asynchronously,
-                 returns the request thread.
+                 If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.list_operation_api_with_http_info(**kwargs)  # noqa: E501
-        else:
-            (data) = self.list_operation_api_with_http_info(**kwargs)  # noqa: E501
-            return data
-
-    def list_operation_api_with_http_info(self, **kwargs):  # noqa: E501
-        """List operation(s)
-        List all the operation(s)
-
-        >>> response = api.list_operation_api((optional) _page, (optional) _limit, (optional) _filter, (optional) _orderby, (optional) _select)
-
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-
-        >>> thread = api.list_operation_api_with_http_info(async_req=True)
-        >>> result = thread.get()
 
-        :param int _page: A URL query parameter that specifies the page number of the result set.  Must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range will lead to no results being returned.
-
-        :param int _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 0 and 100. Any number out of this range will lead to a validation error. If the limit is not provided a default value of 50 records will be returned in the result set.
-
-        :param str _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the OData V4.01 URL conventions.
-        The filter can be applied on the following fields:
-        
-        - clientName
-        - createdTime
-        - displayName
-        - extId
-        - lastUpdatedTime
-        - objectType
-        
-        :param str _orderby: A URL query parameter that allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified the resources will be sorted in ascending order by default. For example, 'orderby=templateName desc' would get all templates sorted by templateName in desc order.
-        The orderby can be applied to the following fields:
-        
-        - createdTime
-        - displayName
-        - extId
-        - lastUpdatedTime
-        - objectType
-        
-        :param str _select: A URL query parameter that allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the OData V4.01 URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e. *), then all properties on the matching resource will be returned.
-- clientName
-- createdTime
-- description
-- displayName
-- extId
-- lastUpdatedTime
-- links
-- objectType
-- tenantId
-
-        :param bool async_req:
-        :return: iam.v4.authz.ListOperationApiResponse
-
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        all_params = ['_page', '_limit', '_filter', '_orderby', '_select']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-        all_params.append('if_match')
-        all_params.append('if_none_match')
-
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
-            if key not in all_params:
-                raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_operation_api" % key
-                )
             params[key] = val
         del params['kwargs']
+        del params['self']
+
+        # verify the required parameter 'extId' is set
+        if ('extId' not in params or params['extId'] is None):
+            raise ValueError("Missing the required parameter `extId` when calling `get_operation_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
+        if 'extId' in params and params['extId'] is not None:
+            path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
-        if '_page' in params:
-            query_params.append(('$page', params['_page']))  # noqa: E501
-        if '_limit' in params:
-            query_params.append(('$limit', params['_limit']))  # noqa: E501
-        if '_filter' in params:
-            query_params.append(('$filter', params['_filter']))  # noqa: E501
-        if '_orderby' in params:
-            query_params.append(('$orderby', params['_orderby']))  # noqa: E501
-        if '_select' in params:
-            query_params.append(('$select', params['_select']))  # noqa: E501
 
         header_params = {}
-        if 'if_match' in params and params['if_match'] is not None:
-            header_params['If-Match'] = params['if_match']  # noqa: E501
-        if 'if_none_match' in params and params['if_none_match'] is not None:
-            header_params['If-None-Match'] = params['if_none_match']  # noqa: E501
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client._select_header_accept(
+            ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
+
+        # Process operation specific headers
+        extra_params = []
+        extra_params.append('async_req')
+        extra_params.append('_return_http_data_only')
+        extra_params.append('_preload_content')
+        extra_params.append('_request_timeout')
+        all_params = set(['extId'])
+        all_params.update(extra_params)
+        for key, val in six.iteritems(params):
+            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
+                if key.lower() == 'if_match'.lower():
+                    key = 'If-Match'
+                elif key.lower() == 'if_none_match'.lower():
+                    key = 'If-None-Match'
+                header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/api/iam/v4.0.a1/authz/operations', 'GET',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type='iam.v4.authz.ListOperationApiResponse',  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def view_operation_api(self, extId, **kwargs):  # noqa: E501
-        """Get operation
-        View an operation
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authz/operations/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authz.GetOperationApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authz/operations/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authz.GetOperationApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
+
+    def list_operations(self, _page=None, _limit=None, _filter=None, _orderby=None, _select=None, **kwargs):  # noqa: E501
+        """List Operation(s)
 
-        >>> response = api.view_operation_api(extId)
+        >>> response = api.list_operations((optional) _page, (optional) _limit, (optional) _filter, (optional) _orderby, (optional) _select)
 
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
+        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.view_operation_api(extId, async_req=True)
+        >>> thread = api.list_operations(async_req=True)
         >>> result = thread.get()
 
-        :param str extId: External identifier of the operation (required)
-        :param bool async_req:
-        :return: iam.v4.authz.ViewOperationApiResponse
+        :param _page: A URL query parameter that specifies the page number of the result set. It must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range might lead to no results. 
+        :type _page:
 
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """ # noqa: E501
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.view_operation_api_with_http_info(extId, **kwargs)  # noqa: E501
-        else:
-            (data) = self.view_operation_api_with_http_info(extId, **kwargs)  # noqa: E501
-            return data
-
-    def view_operation_api_with_http_info(self, extId, **kwargs):  # noqa: E501
-        """Get operation
-        View an operation
+            :class:`int`
+        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided, a default value of 50 records will be returned in the result set. 
+        :type _limit:
 
-        >>> response = api.view_operation_api(extId)
+            :class:`int`
+        :param _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the [OData V4.01](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html) URL conventions. For example, filter '$filter=name eq 'karbon-ntnx-1.0' would filter the result on cluster name 'karbon-ntnx1.0', filter '$filter=startswith(name, 'C')' would filter on cluster name starting with 'C'. The filter can be applied to the following fields: - clientName - createdTime - displayName - entityType - extId - lastUpdatedTime - operationType 
+        :type _filter:
 
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
+            :class:`str`
+        :param _orderby: A URL query parameter that allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified, the resources will be sorted in ascending order by default. For example, '$orderby=templateName desc' would get all templates sorted by templateName in descending order. The orderby can be applied to the following fields: - createdTime - displayName - entityType - extId - lastUpdatedTime 
+        :type _orderby:
 
-        >>> thread = api.view_operation_api_with_http_info(extId, async_req=True)
-        >>> result = thread.get()
+            :class:`str`
+        :param _select: A URL query parameter that allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the [OData V4.01](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html) URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e., *), then all properties on the matching resource will be returned. - associatedEndpointList - clientName - createdTime - description - displayName - entityType - extId - lastUpdatedTime - links - operationType - relatedOperationList - tenantId 
+        :type _select:
+
+            :class:`str`
+        :param kwargs: kwargs for the method.
+                       The following can be passed for an asynchronous HTTP call::
 
-        :param str extId: External identifier of the operation (required)
-        :param bool async_req:
-        :return: iam.v4.authz.ViewOperationApiResponse
-
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        all_params = ['extId']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-        all_params.append('if_match')
-        all_params.append('if_none_match')
+                           async_req=True
+        :return: An instance of class :class:`~ntnx_iam_py_client.models.iam.v4.authz.ListOperationsApiResponse`.
 
-        params = locals()
+                 If the method is called asynchronously, returns the request thread.
+        """ # noqa: E501
+        kwargs['_return_http_data_only'] = True
+
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
-            if key not in all_params:
-                raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method view_operation_api" % key
-                )
             params[key] = val
         del params['kwargs']
-        # verify the required parameter 'extId' is set
-        if ('extId' not in params or
-                params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `view_operation_api`")  # noqa: E501
+        del params['self']
+
 
         collection_formats = {}
 
         path_params = {}
-        if 'extId' in params:
-            path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
+        if '_page' in params and params['_page'] is not None:
+            query_params.append(('$page', params['_page']))  # noqa: E501
+        if '_limit' in params and params['_limit'] is not None:
+            query_params.append(('$limit', params['_limit']))  # noqa: E501
+        if '_filter' in params and params['_filter'] is not None:
+            query_params.append(('$filter', params['_filter']))  # noqa: E501
+        if '_orderby' in params and params['_orderby'] is not None:
+            query_params.append(('$orderby', params['_orderby']))  # noqa: E501
+        if '_select' in params and params['_select'] is not None:
+            query_params.append(('$select', params['_select']))  # noqa: E501
 
         header_params = {}
-        if 'if_match' in params and params['if_match'] is not None:
-            header_params['If-Match'] = params['if_match']  # noqa: E501
-        if 'if_none_match' in params and params['if_none_match'] is not None:
-            header_params['If-None-Match'] = params['if_none_match']  # noqa: E501
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client._select_header_accept(
+            ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
+
+        # Process operation specific headers
+        extra_params = []
+        extra_params.append('async_req')
+        extra_params.append('_return_http_data_only')
+        extra_params.append('_preload_content')
+        extra_params.append('_request_timeout')
+        all_params = set(['_page', '_limit', '_filter', '_orderby', '_select'])
+        all_params.update(extra_params)
+        for key, val in six.iteritems(params):
+            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
+                if key.lower() == 'if_match'.lower():
+                    key = 'If-Match'
+                elif key.lower() == 'if_none_match'.lower():
+                    key = 'If-None-Match'
+                header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/api/iam/v4.0.a1/authz/operations/{extId}', 'GET',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type='iam.v4.authz.ViewOperationApiResponse',  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authz/operations', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authz.ListOperationsApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authz/operations', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authz.ListOperationsApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/api/role_api.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/api/user_groups_api.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,676 +1,503 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 from __future__ import absolute_import
 
 import re  # noqa: F401
 
 # python 2 and python 3 compatibility library
 import six
 
 from ntnx_iam_py_client.api_client import ApiClient
 
 
-class RoleApi(object):
+class UserGroupsApi(object):
     """IGNORE:
-    NOTE: This class is auto generated by the swagger code generator program.
-
-    Do not edit the class manually.
-    Ref: https://github.com/swagger-api/swagger-codegen
+    NOTE: A placeholder for class level description
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
+
         self.api_client = api_client
+        self.__headers_to_skip = { 'authorization', 'cookie', 'host', 'user-agent' }
 
-    def create_role_api(self, body, **kwargs):  # noqa: E501
-        """Create role
-        Create a role
+    def create_user_group(self, body, **kwargs):  # noqa: E501
+        """Create User Group
 
-        >>> response = api.create_role_api(body)
+        >>> response = api.create_user_group(body)
 
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
+        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.create_role_api(body, async_req=True)
+        >>> thread = api.create_user_group(body, async_req=True)
         >>> result = thread.get()
 
-        :param iam.v4.authz.Role body: Create a role (required)
-        :param bool async_req:
-        :return: iam.v4.authz.CreateRoleApiResponse
-
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """ # noqa: E501
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.create_role_api_with_http_info(body, **kwargs)  # noqa: E501
-        else:
-            (data) = self.create_role_api_with_http_info(body, **kwargs)  # noqa: E501
-            return data
-
-    def create_role_api_with_http_info(self, body, **kwargs):  # noqa: E501
-        """Create role
-        Create a role
-
-        >>> response = api.create_role_api(body)
+        :param body: Create a User Group.
+        :type body:
 
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
+            :class:`~ntnx_iam_py_client.models.iam.v4.authn.UserGroup`, required
+        :param kwargs: kwargs for the method.
+                       The following can be passed for an asynchronous HTTP call::
 
-        >>> thread = api.create_role_api_with_http_info(body, async_req=True)
-        >>> result = thread.get()
+                           async_req=True
+        :return: An instance of class :class:`~ntnx_iam_py_client.models.iam.v4.authn.CreateUserGroupApiResponse`.
 
-        :param iam.v4.authz.Role body: Create a role (required)
-        :param bool async_req:
-        :return: iam.v4.authz.CreateRoleApiResponse
-
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        all_params = ['body']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-        all_params.append('if_match')
-        all_params.append('if_none_match')
+                 If the method is called asynchronously, returns the request thread.
+        """ # noqa: E501
+        kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
-            if key not in all_params:
-                raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method create_role_api" % key
-                )
             params[key] = val
         del params['kwargs']
+        del params['self']
+
         # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
-            raise ValueError("Missing the required parameter `body` when calling `create_role_api`")  # noqa: E501
+        if ('body' not in params or params['body'] is None):
+            raise ValueError("Missing the required parameter `body` when calling `create_user_group`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'if_match' in params and params['if_match'] is not None:
-            header_params['If-Match'] = params['if_match']  # noqa: E501
-        if 'if_none_match' in params and params['if_none_match'] is not None:
-            header_params['If-None-Match'] = params['if_none_match']  # noqa: E501
-
-        form_params = []
-        local_var_files = {}
-
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
+        header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
+        header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
             ['application/json'])  # noqa: E501
+        if 'Content-Type' in params and params.get('Content-Type') is not None:
+            header_params['Content-Type'] = params.get('Content-Type')
+
+        # Process operation specific headers
+        extra_params = []
+        extra_params.append('async_req')
+        extra_params.append('_return_http_data_only')
+        extra_params.append('_preload_content')
+        extra_params.append('_request_timeout')
+        all_params = set(['body'])
+        all_params.update(extra_params)
+        for key, val in six.iteritems(params):
+            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
+                if key.lower() == 'if_match'.lower():
+                    key = 'If-Match'
+                elif key.lower() == 'if_none_match'.lower():
+                    key = 'If-None-Match'
+                header_params[key] = val
+
+        form_params = []
+        local_var_files = {}
 
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/api/iam/v4.0.a1/authz/roles', 'POST',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type='iam.v4.authz.CreateRoleApiResponse',  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def delete_role_api(self, extId, **kwargs):  # noqa: E501
-        """Delete role
-        Delete a role
+        body_params = None
+        if 'body' in params and params['body'] is not None:
+            body_params = params['body']
 
-        >>> response = api.delete_role_api(extId)
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authn/user-groups', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authn.CreateUserGroupApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authn/user-groups', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authn.CreateUserGroupApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
+    def delete_user_group_by_id(self, extId, **kwargs):  # noqa: E501
+        """Delete User Group
 
-        >>> thread = api.delete_role_api(extId, async_req=True)
-        >>> result = thread.get()
+        >>> response = api.delete_user_group_by_id(extId)
 
-        :param str extId: External identifier for the role (required)
-        :param bool async_req:
-        :return: iam.v4.authz.DeleteRoleApiResponse
+        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """ # noqa: E501
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.delete_role_api_with_http_info(extId, **kwargs)  # noqa: E501
-        else:
-            (data) = self.delete_role_api_with_http_info(extId, **kwargs)  # noqa: E501
-            return data
-
-    def delete_role_api_with_http_info(self, extId, **kwargs):  # noqa: E501
-        """Delete role
-        Delete a role
+        >>> thread = api.delete_user_group_by_id(extId, async_req=True)
+        >>> result = thread.get()
 
-        >>> response = api.delete_role_api(extId)
+        :param extId: External Identifier of the User Group.
+        :type extId:
 
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
+            :class:`str`, required
+        :param kwargs: kwargs for the method.
+                       The following can be passed for an asynchronous HTTP call::
 
-        >>> thread = api.delete_role_api_with_http_info(extId, async_req=True)
-        >>> result = thread.get()
+                           async_req=True
+        :return: An instance of class :class:`~ntnx_iam_py_client.models.iam.v4.authn.DeleteUserGroupApiResponse`.
 
-        :param str extId: External identifier for the role (required)
-        :param bool async_req:
-        :return: iam.v4.authz.DeleteRoleApiResponse
-
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        all_params = ['extId']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-        all_params.append('if_match')
-        all_params.append('if_none_match')
+                 If the method is called asynchronously, returns the request thread.
+        """ # noqa: E501
+        kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
-            if key not in all_params:
-                raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method delete_role_api" % key
-                )
             params[key] = val
         del params['kwargs']
+        del params['self']
+
         # verify the required parameter 'extId' is set
-        if ('extId' not in params or
-                params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `delete_role_api`")  # noqa: E501
+        if ('extId' not in params or params['extId'] is None):
+            raise ValueError("Missing the required parameter `extId` when calling `delete_user_group_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'extId' in params:
+        if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'if_match' in params and params['if_match'] is not None:
-            header_params['If-Match'] = params['if_match']  # noqa: E501
-        if 'if_none_match' in params and params['if_none_match'] is not None:
-            header_params['If-None-Match'] = params['if_none_match']  # noqa: E501
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client._select_header_accept(
+            ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
+
+        # Process operation specific headers
+        extra_params = []
+        extra_params.append('async_req')
+        extra_params.append('_return_http_data_only')
+        extra_params.append('_preload_content')
+        extra_params.append('_request_timeout')
+        all_params = set(['extId'])
+        all_params.update(extra_params)
+        for key, val in six.iteritems(params):
+            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
+                if key.lower() == 'if_match'.lower():
+                    key = 'If-Match'
+                elif key.lower() == 'if_none_match'.lower():
+                    key = 'If-None-Match'
+                header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/api/iam/v4.0.a1/authz/roles/{extId}', 'DELETE',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type='iam.v4.authz.DeleteRoleApiResponse',  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def list_role_api(self, **kwargs):  # noqa: E501
-        """List role(s)
-        List all the role(s)
+        body_params = None
 
-        >>> response = api.list_role_api((optional) _page, (optional) _limit, (optional) _filter, (optional) _orderby, (optional) _select)
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authn/user-groups/{extId}', 'DELETE',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authn.DeleteUserGroupApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authn/user-groups/{extId}', 'DELETE',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authn.DeleteUserGroupApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
+    def get_user_group_by_id(self, extId, **kwargs):  # noqa: E501
+        """Get User Group
 
-        >>> thread = api.list_role_api(async_req=True)
-        >>> result = thread.get()
+        >>> response = api.get_user_group_by_id(extId)
 
-        :param int _page: A URL query parameter that specifies the page number of the result set.  Must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range will lead to no results being returned.
+        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        :param int _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 0 and 100. Any number out of this range will lead to a validation error. If the limit is not provided a default value of 50 records will be returned in the result set.
+        >>> thread = api.get_user_group_by_id(extId, async_req=True)
+        >>> result = thread.get()
+
+        :param extId: External Identifier of the User Group.
+        :type extId:
 
-        :param str _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the OData V4.01 URL conventions.
-        The filter can be applied on the following fields:
-        
-        - clientName
-        - createdBy
-        - createdTime
-        - displayName
-        - extId
-        - isSystemDefined
-        - lastUpdatedTime
-        
-        :param str _orderby: A URL query parameter that allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified the resources will be sorted in ascending order by default. For example, 'orderby=templateName desc' would get all templates sorted by templateName in desc order.
-        The orderby can be applied to the following fields:
-        
-        - createdTime
-        - displayName
-        - extId
-        - lastUpdatedTime
-        
-        :param str _select: A URL query parameter that allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the OData V4.01 URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e. *), then all properties on the matching resource will be returned.
-- accessibleClients
-- accessibleObjectTypes
-- clientName
-- createdBy
-- createdTime
-- description
-- displayName
-- extId
-- isSystemDefined
-- lastUpdatedTime
-- links
-- operations
-- tenantId
+            :class:`str`, required
+        :param kwargs: kwargs for the method.
+                       The following can be passed for an asynchronous HTTP call::
 
-        :param bool async_req:
-        :return: iam.v4.authz.ListRoleApiResponse
+                           async_req=True
+        :return: An instance of class :class:`~ntnx_iam_py_client.models.iam.v4.authn.GetUserGroupApiResponse`.
 
-                 If the method is called asynchronously,
-                 returns the request thread.
+                 If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.list_role_api_with_http_info(**kwargs)  # noqa: E501
-        else:
-            (data) = self.list_role_api_with_http_info(**kwargs)  # noqa: E501
-            return data
-
-    def list_role_api_with_http_info(self, **kwargs):  # noqa: E501
-        """List role(s)
-        List all the role(s)
-
-        >>> response = api.list_role_api((optional) _page, (optional) _limit, (optional) _filter, (optional) _orderby, (optional) _select)
-
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-
-        >>> thread = api.list_role_api_with_http_info(async_req=True)
-        >>> result = thread.get()
-
-        :param int _page: A URL query parameter that specifies the page number of the result set.  Must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range will lead to no results being returned.
 
-        :param int _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 0 and 100. Any number out of this range will lead to a validation error. If the limit is not provided a default value of 50 records will be returned in the result set.
-
-        :param str _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the OData V4.01 URL conventions.
-        The filter can be applied on the following fields:
-        
-        - clientName
-        - createdBy
-        - createdTime
-        - displayName
-        - extId
-        - isSystemDefined
-        - lastUpdatedTime
-        
-        :param str _orderby: A URL query parameter that allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified the resources will be sorted in ascending order by default. For example, 'orderby=templateName desc' would get all templates sorted by templateName in desc order.
-        The orderby can be applied to the following fields:
-        
-        - createdTime
-        - displayName
-        - extId
-        - lastUpdatedTime
-        
-        :param str _select: A URL query parameter that allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the OData V4.01 URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e. *), then all properties on the matching resource will be returned.
-- accessibleClients
-- accessibleObjectTypes
-- clientName
-- createdBy
-- createdTime
-- description
-- displayName
-- extId
-- isSystemDefined
-- lastUpdatedTime
-- links
-- operations
-- tenantId
-
-        :param bool async_req:
-        :return: iam.v4.authz.ListRoleApiResponse
-
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        all_params = ['_page', '_limit', '_filter', '_orderby', '_select']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-        all_params.append('if_match')
-        all_params.append('if_none_match')
-
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
-            if key not in all_params:
-                raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_role_api" % key
-                )
             params[key] = val
         del params['kwargs']
+        del params['self']
+
+        # verify the required parameter 'extId' is set
+        if ('extId' not in params or params['extId'] is None):
+            raise ValueError("Missing the required parameter `extId` when calling `get_user_group_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
+        if 'extId' in params and params['extId'] is not None:
+            path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
-        if '_page' in params:
-            query_params.append(('$page', params['_page']))  # noqa: E501
-        if '_limit' in params:
-            query_params.append(('$limit', params['_limit']))  # noqa: E501
-        if '_filter' in params:
-            query_params.append(('$filter', params['_filter']))  # noqa: E501
-        if '_orderby' in params:
-            query_params.append(('$orderby', params['_orderby']))  # noqa: E501
-        if '_select' in params:
-            query_params.append(('$select', params['_select']))  # noqa: E501
 
         header_params = {}
-        if 'if_match' in params and params['if_match'] is not None:
-            header_params['If-Match'] = params['if_match']  # noqa: E501
-        if 'if_none_match' in params and params['if_none_match'] is not None:
-            header_params['If-None-Match'] = params['if_none_match']  # noqa: E501
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client._select_header_accept(
+            ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
+
+        # Process operation specific headers
+        extra_params = []
+        extra_params.append('async_req')
+        extra_params.append('_return_http_data_only')
+        extra_params.append('_preload_content')
+        extra_params.append('_request_timeout')
+        all_params = set(['extId'])
+        all_params.update(extra_params)
+        for key, val in six.iteritems(params):
+            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
+                if key.lower() == 'if_match'.lower():
+                    key = 'If-Match'
+                elif key.lower() == 'if_none_match'.lower():
+                    key = 'If-None-Match'
+                header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/api/iam/v4.0.a1/authz/roles', 'GET',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type='iam.v4.authz.ListRoleApiResponse',  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def update_role_api(self, body, extId, **kwargs):  # noqa: E501
-        """Update role
-        Update a role
-
-        >>> response = api.update_role_api(body, extId)
-
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
+        body_params = None
 
-        >>> thread = api.update_role_api(body, extId, async_req=True)
-        >>> result = thread.get()
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authn/user-groups/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authn.GetUserGroupApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authn/user-groups/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authn.GetUserGroupApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-        :param iam.v4.authz.Role body: Update a role (required)
-        :param str extId: External identifier for the role (required)
-        :param bool async_req:
-        :return: iam.v4.authz.UpdateRoleApiResponse
+    def list_user_groups(self, _page=None, _limit=None, _filter=None, _orderby=None, _select=None, **kwargs):  # noqa: E501
+        """List User Group(s)
 
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """ # noqa: E501
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.update_role_api_with_http_info(body, extId, **kwargs)  # noqa: E501
-        else:
-            (data) = self.update_role_api_with_http_info(body, extId, **kwargs)  # noqa: E501
-            return data
-
-    def update_role_api_with_http_info(self, body, extId, **kwargs):  # noqa: E501
-        """Update role
-        Update a role
+        >>> response = api.list_user_groups((optional) _page, (optional) _limit, (optional) _filter, (optional) _orderby, (optional) _select)
 
-        >>> response = api.update_role_api(body, extId)
+        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-
-        >>> thread = api.update_role_api_with_http_info(body, extId, async_req=True)
+        >>> thread = api.list_user_groups(async_req=True)
         >>> result = thread.get()
 
-        :param iam.v4.authz.Role body: Update a role (required)
-        :param str extId: External identifier for the role (required)
-        :param bool async_req:
-        :return: iam.v4.authz.UpdateRoleApiResponse
-
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        all_params = ['body', 'extId']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-        all_params.append('if_match')
-        all_params.append('if_none_match')
-
-        params = locals()
-        for key, val in six.iteritems(params['kwargs']):
-            if key not in all_params:
-                raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method update_role_api" % key
-                )
-            params[key] = val
-        del params['kwargs']
-        # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
-            raise ValueError("Missing the required parameter `body` when calling `update_role_api`")  # noqa: E501
-        # verify the required parameter 'extId' is set
-        if ('extId' not in params or
-                params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `update_role_api`")  # noqa: E501
-
-        collection_formats = {}
-
-        path_params = {}
-        if 'extId' in params:
-            path_params['extId'] = params['extId']  # noqa: E501
-
-        query_params = []
-
-        header_params = {}
-        if 'if_match' in params and params['if_match'] is not None:
-            header_params['If-Match'] = params['if_match']  # noqa: E501
-        if 'if_none_match' in params and params['if_none_match'] is not None:
-            header_params['If-None-Match'] = params['if_none_match']  # noqa: E501
-
-        form_params = []
-        local_var_files = {}
-
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
-        # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
-
-        # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        :param _page: A URL query parameter that specifies the page number of the result set. It must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range might lead to no results. 
+        :type _page:
 
-        # Authentication setting
-        auth_settings = ['basicAuthScheme']  # noqa: E501
+            :class:`int`
+        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided, a default value of 50 records will be returned in the result set. 
+        :type _limit:
 
-        return self.api_client.call_api(
-            '/api/iam/v4.0.a1/authz/roles/{extId}', 'PUT',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type='iam.v4.authz.UpdateRoleApiResponse',  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def view_role_api(self, extId, **kwargs):  # noqa: E501
-        """Get role
-        View a role
+            :class:`int`
+        :param _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the [OData V4.01](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html) URL conventions. For example, filter '$filter=name eq 'karbon-ntnx-1.0' would filter the result on cluster name 'karbon-ntnx1.0', filter '$filter=startswith(name, 'C')' would filter on cluster name starting with 'C'. The filter can be applied to the following fields: - createdBy - distinguishedName - extId - groupType - idpId - name 
+        :type _filter:
 
-        >>> response = api.view_role_api(extId)
+            :class:`str`
+        :param _orderby: A URL query parameter that allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified, the resources will be sorted in ascending order by default. For example, '$orderby=templateName desc' would get all templates sorted by templateName in descending order. The orderby can be applied to the following fields: - createdTime - distinguishedName - groupType - lastUpdatedTime - name 
+        :type _orderby:
 
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
+            :class:`str`
+        :param _select: A URL query parameter that allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the [OData V4.01](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html) URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e., *), then all properties on the matching resource will be returned. - createdBy - createdTime - distinguishedName - extId - groupType - idpId - lastUpdatedTime - links - name - tenantId 
+        :type _select:
 
-        >>> thread = api.view_role_api(extId, async_req=True)
-        >>> result = thread.get()
+            :class:`str`
+        :param kwargs: kwargs for the method.
+                       The following can be passed for an asynchronous HTTP call::
 
-        :param str extId: External identifier for the role (required)
-        :param bool async_req:
-        :return: iam.v4.authz.ViewRoleApiResponse
+                           async_req=True
+        :return: An instance of class :class:`~ntnx_iam_py_client.models.iam.v4.authn.ListUserGroupsApiResponse`.
 
-                 If the method is called asynchronously,
-                 returns the request thread.
+                 If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.view_role_api_with_http_info(extId, **kwargs)  # noqa: E501
-        else:
-            (data) = self.view_role_api_with_http_info(extId, **kwargs)  # noqa: E501
-            return data
-
-    def view_role_api_with_http_info(self, extId, **kwargs):  # noqa: E501
-        """Get role
-        View a role
 
-        >>> response = api.view_role_api(extId)
-
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-
-        >>> thread = api.view_role_api_with_http_info(extId, async_req=True)
-        >>> result = thread.get()
-
-        :param str extId: External identifier for the role (required)
-        :param bool async_req:
-        :return: iam.v4.authz.ViewRoleApiResponse
-
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        all_params = ['extId']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-        all_params.append('if_match')
-        all_params.append('if_none_match')
-
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
-            if key not in all_params:
-                raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method view_role_api" % key
-                )
             params[key] = val
         del params['kwargs']
-        # verify the required parameter 'extId' is set
-        if ('extId' not in params or
-                params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `view_role_api`")  # noqa: E501
+        del params['self']
+
 
         collection_formats = {}
 
         path_params = {}
-        if 'extId' in params:
-            path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
+        if '_page' in params and params['_page'] is not None:
+            query_params.append(('$page', params['_page']))  # noqa: E501
+        if '_limit' in params and params['_limit'] is not None:
+            query_params.append(('$limit', params['_limit']))  # noqa: E501
+        if '_filter' in params and params['_filter'] is not None:
+            query_params.append(('$filter', params['_filter']))  # noqa: E501
+        if '_orderby' in params and params['_orderby'] is not None:
+            query_params.append(('$orderby', params['_orderby']))  # noqa: E501
+        if '_select' in params and params['_select'] is not None:
+            query_params.append(('$select', params['_select']))  # noqa: E501
 
         header_params = {}
-        if 'if_match' in params and params['if_match'] is not None:
-            header_params['If-Match'] = params['if_match']  # noqa: E501
-        if 'if_none_match' in params and params['if_none_match'] is not None:
-            header_params['If-None-Match'] = params['if_none_match']  # noqa: E501
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client._select_header_accept(
+            ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
+
+        # Process operation specific headers
+        extra_params = []
+        extra_params.append('async_req')
+        extra_params.append('_return_http_data_only')
+        extra_params.append('_preload_content')
+        extra_params.append('_request_timeout')
+        all_params = set(['_page', '_limit', '_filter', '_orderby', '_select'])
+        all_params.update(extra_params)
+        for key, val in six.iteritems(params):
+            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
+                if key.lower() == 'if_match'.lower():
+                    key = 'If-Match'
+                elif key.lower() == 'if_none_match'.lower():
+                    key = 'If-None-Match'
+                header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/api/iam/v4.0.a1/authz/roles/{extId}', 'GET',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type='iam.v4.authz.ViewRoleApiResponse',  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authn/user-groups', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authn.ListUserGroupsApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authn/user-groups', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authn.ListUserGroupsApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/api/saml_identity_provider_api.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/api/authorization_policies_api.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,666 +1,634 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 from __future__ import absolute_import
 
 import re  # noqa: F401
 
 # python 2 and python 3 compatibility library
 import six
 
 from ntnx_iam_py_client.api_client import ApiClient
 
 
-class SamlIdentityProviderApi(object):
+class AuthorizationPoliciesApi(object):
     """IGNORE:
-    NOTE: This class is auto generated by the swagger code generator program.
-
-    Do not edit the class manually.
-    Ref: https://github.com/swagger-api/swagger-codegen
+    NOTE: A placeholder for class level description
     IGNORE
-    """ # noqa: E501
+    """  # noqa: E501
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
+
         self.api_client = api_client
+        self.__headers_to_skip = { 'authorization', 'cookie', 'host', 'user-agent' }
 
-    def create_saml_identity_provider(self, body, **kwargs):  # noqa: E501
-        """Create SAML Identity Provider
-        Create a SAML Identity Provider
+    def create_authorization_policy(self, body, **kwargs):  # noqa: E501
+        """Create Authorization Policy
 
-        >>> response = api.create_saml_identity_provider(body)
+        >>> response = api.create_authorization_policy(body)
 
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
+        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.create_saml_identity_provider(body, async_req=True)
+        >>> thread = api.create_authorization_policy(body, async_req=True)
         >>> result = thread.get()
 
-        :param iam.v4.authn.SamlIdentityProvider body: Create a SAML Identity Provider (required)
-        :param bool async_req:
-        :return: iam.v4.authn.CreateSamlIdentityProviderApiResponse
+        :param body: Create an Authorization Policy.
+        :type body:
 
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """ # noqa: E501
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.create_saml_identity_provider_with_http_info(body, **kwargs)  # noqa: E501
-        else:
-            (data) = self.create_saml_identity_provider_with_http_info(body, **kwargs)  # noqa: E501
-            return data
-
-    def create_saml_identity_provider_with_http_info(self, body, **kwargs):  # noqa: E501
-        """Create SAML Identity Provider
-        Create a SAML Identity Provider
+            :class:`~ntnx_iam_py_client.models.iam.v4.authz.AuthorizationPolicy`, required
+        :param kwargs: kwargs for the method.
+                       The following can be passed for an asynchronous HTTP call::
 
-        >>> response = api.create_saml_identity_provider(body)
-
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-
-        >>> thread = api.create_saml_identity_provider_with_http_info(body, async_req=True)
-        >>> result = thread.get()
+                           async_req=True
+        :return: An instance of class :class:`~ntnx_iam_py_client.models.iam.v4.authz.CreateAuthorizationPolicyApiResponse`.
 
-        :param iam.v4.authn.SamlIdentityProvider body: Create a SAML Identity Provider (required)
-        :param bool async_req:
-        :return: iam.v4.authn.CreateSamlIdentityProviderApiResponse
-
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        all_params = ['body']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-        all_params.append('if_match')
-        all_params.append('if_none_match')
+                 If the method is called asynchronously, returns the request thread.
+        """ # noqa: E501
+        kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
-            if key not in all_params:
-                raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method create_saml_identity_provider" % key
-                )
             params[key] = val
         del params['kwargs']
+        del params['self']
+
         # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
-            raise ValueError("Missing the required parameter `body` when calling `create_saml_identity_provider`")  # noqa: E501
+        if ('body' not in params or params['body'] is None):
+            raise ValueError("Missing the required parameter `body` when calling `create_authorization_policy`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'if_match' in params and params['if_match'] is not None:
-            header_params['If-Match'] = params['if_match']  # noqa: E501
-        if 'if_none_match' in params and params['if_none_match'] is not None:
-            header_params['If-None-Match'] = params['if_none_match']  # noqa: E501
-
-        form_params = []
-        local_var_files = {}
-
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
+        header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
+        header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
             ['application/json'])  # noqa: E501
+        if 'Content-Type' in params and params.get('Content-Type') is not None:
+            header_params['Content-Type'] = params.get('Content-Type')
+
+        # Process operation specific headers
+        extra_params = []
+        extra_params.append('async_req')
+        extra_params.append('_return_http_data_only')
+        extra_params.append('_preload_content')
+        extra_params.append('_request_timeout')
+        all_params = set(['body'])
+        all_params.update(extra_params)
+        for key, val in six.iteritems(params):
+            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
+                if key.lower() == 'if_match'.lower():
+                    key = 'If-Match'
+                elif key.lower() == 'if_none_match'.lower():
+                    key = 'If-None-Match'
+                header_params[key] = val
+
+        form_params = []
+        local_var_files = {}
 
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/api/iam/v4.0.a1/authn/saml-identity-providers', 'POST',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type='iam.v4.authn.CreateSamlIdentityProviderApiResponse',  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def get_saml_identity_provider_list(self, **kwargs):  # noqa: E501
-        """List SAML Identity Providers
-        View all SAML Identity Provider(s)
+        body_params = None
+        if 'body' in params and params['body'] is not None:
+            body_params = params['body']
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authz/authorization-policies', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authz.CreateAuthorizationPolicyApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authz/authorization-policies', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authz.CreateAuthorizationPolicyApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-        >>> response = api.get_saml_identity_provider_list((optional) _page, (optional) _limit, (optional) _filter, (optional) _orderby, (optional) _select)
+    def delete_authorization_policy_by_id(self, extId, **kwargs):  # noqa: E501
+        """Delete Authorization Policy
 
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
+        >>> response = api.delete_authorization_policy_by_id(extId)
 
-        >>> thread = api.get_saml_identity_provider_list(async_req=True)
-        >>> result = thread.get()
+        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        :param int _page: A URL query parameter that specifies the page number of the result set.  Must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range will lead to no results being returned.
+        >>> thread = api.delete_authorization_policy_by_id(extId, async_req=True)
+        >>> result = thread.get()
 
-        :param int _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 0 and 100. Any number out of this range will lead to a validation error. If the limit is not provided a default value of 50 records will be returned in the result set.
+        :param extId: ExtId for the Role.
+        :type extId:
 
-        :param str _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the OData V4.01 URL conventions.
-        The filter can be applied on the following fields:
-        
-        - createdBy
-        - extId
-        - name
-        
-        :param str _orderby: A URL query parameter that allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified the resources will be sorted in ascending order by default. For example, 'orderby=templateName desc' would get all templates sorted by templateName in desc order.
-        The orderby can be applied to the following fields:
-        
-        - createdTime
-        - lastUpdatedTime
-        - name
-        
-        :param str _select: A URL query parameter that allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the OData V4.01 URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e. *), then all properties on the matching resource will be returned.
-- createdBy
-- createdTime
-- customAttr
-- emailAttr
-- enableSignedAuthnReq
-- entityIssuer
-- extId
-- groupsAttr
-- groupsDelim
-- idpMetadata
-- idpMetadataUrl
-- idpProperties
-- lastUpdatedTime
-- links
-- name
-- tenantId
-- usernameAttr
+            :class:`str`, required
+        :param kwargs: kwargs for the method.
+                       The following can be passed for an asynchronous HTTP call::
 
-        :param bool async_req:
-        :return: iam.v4.authn.ListSamlIdentityProviderApiResponse
+                           async_req=True
+        :return: An instance of class :class:`~ntnx_iam_py_client.models.iam.v4.authz.DeleteAuthorizationPolicyApiResponse`.
 
-                 If the method is called asynchronously,
-                 returns the request thread.
+                 If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.get_saml_identity_provider_list_with_http_info(**kwargs)  # noqa: E501
-        else:
-            (data) = self.get_saml_identity_provider_list_with_http_info(**kwargs)  # noqa: E501
-            return data
-
-    def get_saml_identity_provider_list_with_http_info(self, **kwargs):  # noqa: E501
-        """List SAML Identity Providers
-        View all SAML Identity Provider(s)
 
-        >>> response = api.get_saml_identity_provider_list((optional) _page, (optional) _limit, (optional) _filter, (optional) _orderby, (optional) _select)
-
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-
-        >>> thread = api.get_saml_identity_provider_list_with_http_info(async_req=True)
-        >>> result = thread.get()
-
-        :param int _page: A URL query parameter that specifies the page number of the result set.  Must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range will lead to no results being returned.
-
-        :param int _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 0 and 100. Any number out of this range will lead to a validation error. If the limit is not provided a default value of 50 records will be returned in the result set.
-
-        :param str _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the OData V4.01 URL conventions.
-        The filter can be applied on the following fields:
-        
-        - createdBy
-        - extId
-        - name
-        
-        :param str _orderby: A URL query parameter that allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified the resources will be sorted in ascending order by default. For example, 'orderby=templateName desc' would get all templates sorted by templateName in desc order.
-        The orderby can be applied to the following fields:
-        
-        - createdTime
-        - lastUpdatedTime
-        - name
-        
-        :param str _select: A URL query parameter that allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the OData V4.01 URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e. *), then all properties on the matching resource will be returned.
-- createdBy
-- createdTime
-- customAttr
-- emailAttr
-- enableSignedAuthnReq
-- entityIssuer
-- extId
-- groupsAttr
-- groupsDelim
-- idpMetadata
-- idpMetadataUrl
-- idpProperties
-- lastUpdatedTime
-- links
-- name
-- tenantId
-- usernameAttr
-
-        :param bool async_req:
-        :return: iam.v4.authn.ListSamlIdentityProviderApiResponse
-
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        all_params = ['_page', '_limit', '_filter', '_orderby', '_select']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-        all_params.append('if_match')
-        all_params.append('if_none_match')
-
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
-            if key not in all_params:
-                raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_saml_identity_provider_list" % key
-                )
             params[key] = val
         del params['kwargs']
+        del params['self']
+
+        # verify the required parameter 'extId' is set
+        if ('extId' not in params or params['extId'] is None):
+            raise ValueError("Missing the required parameter `extId` when calling `delete_authorization_policy_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
+        if 'extId' in params and params['extId'] is not None:
+            path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
-        if '_page' in params:
-            query_params.append(('$page', params['_page']))  # noqa: E501
-        if '_limit' in params:
-            query_params.append(('$limit', params['_limit']))  # noqa: E501
-        if '_filter' in params:
-            query_params.append(('$filter', params['_filter']))  # noqa: E501
-        if '_orderby' in params:
-            query_params.append(('$orderby', params['_orderby']))  # noqa: E501
-        if '_select' in params:
-            query_params.append(('$select', params['_select']))  # noqa: E501
 
         header_params = {}
-        if 'if_match' in params and params['if_match'] is not None:
-            header_params['If-Match'] = params['if_match']  # noqa: E501
-        if 'if_none_match' in params and params['if_none_match'] is not None:
-            header_params['If-None-Match'] = params['if_none_match']  # noqa: E501
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client._select_header_accept(
+            ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
+
+        # Process operation specific headers
+        extra_params = []
+        extra_params.append('async_req')
+        extra_params.append('_return_http_data_only')
+        extra_params.append('_preload_content')
+        extra_params.append('_request_timeout')
+        all_params = set(['extId'])
+        all_params.update(extra_params)
+        for key, val in six.iteritems(params):
+            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
+                if key.lower() == 'if_match'.lower():
+                    key = 'If-Match'
+                elif key.lower() == 'if_none_match'.lower():
+                    key = 'If-None-Match'
+                header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/api/iam/v4.0.a1/authn/saml-identity-providers', 'GET',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type='iam.v4.authn.ListSamlIdentityProviderApiResponse',  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def get_saml_identity_providerby_id(self, extId, **kwargs):  # noqa: E501
-        """Get SAML Identity Provider
-        View a SAML Identity Provider
+        body_params = None
 
-        >>> response = api.get_saml_identity_providerby_id(extId)
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authz/authorization-policies/{extId}', 'DELETE',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authz.DeleteAuthorizationPolicyApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authz/authorization-policies/{extId}', 'DELETE',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authz.DeleteAuthorizationPolicyApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
+    def get_authorization_policy_by_id(self, extId, **kwargs):  # noqa: E501
+        """Get Authorization Policy
 
-        >>> thread = api.get_saml_identity_providerby_id(extId, async_req=True)
-        >>> result = thread.get()
+        >>> response = api.get_authorization_policy_by_id(extId)
 
-        :param str extId: External identifier of the SAML Identity Provider (required)
-        :param bool async_req:
-        :return: iam.v4.authn.GetSamlIdentityProviderApiResponse
+        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """ # noqa: E501
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.get_saml_identity_providerby_id_with_http_info(extId, **kwargs)  # noqa: E501
-        else:
-            (data) = self.get_saml_identity_providerby_id_with_http_info(extId, **kwargs)  # noqa: E501
-            return data
-
-    def get_saml_identity_providerby_id_with_http_info(self, extId, **kwargs):  # noqa: E501
-        """Get SAML Identity Provider
-        View a SAML Identity Provider
+        >>> thread = api.get_authorization_policy_by_id(extId, async_req=True)
+        >>> result = thread.get()
 
-        >>> response = api.get_saml_identity_providerby_id(extId)
+        :param extId: ExtId for the Role.
+        :type extId:
 
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
+            :class:`str`, required
+        :param kwargs: kwargs for the method.
+                       The following can be passed for an asynchronous HTTP call::
 
-        >>> thread = api.get_saml_identity_providerby_id_with_http_info(extId, async_req=True)
-        >>> result = thread.get()
+                           async_req=True
+        :return: An instance of class :class:`~ntnx_iam_py_client.models.iam.v4.authz.GetAuthorizationPolicyApiResponse`.
 
-        :param str extId: External identifier of the SAML Identity Provider (required)
-        :param bool async_req:
-        :return: iam.v4.authn.GetSamlIdentityProviderApiResponse
-
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        all_params = ['extId']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-        all_params.append('if_match')
-        all_params.append('if_none_match')
+                 If the method is called asynchronously, returns the request thread.
+        """ # noqa: E501
+        kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
-            if key not in all_params:
-                raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_saml_identity_providerby_id" % key
-                )
             params[key] = val
         del params['kwargs']
+        del params['self']
+
         # verify the required parameter 'extId' is set
-        if ('extId' not in params or
-                params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `get_saml_identity_providerby_id`")  # noqa: E501
+        if ('extId' not in params or params['extId'] is None):
+            raise ValueError("Missing the required parameter `extId` when calling `get_authorization_policy_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'extId' in params:
+        if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'if_match' in params and params['if_match'] is not None:
-            header_params['If-Match'] = params['if_match']  # noqa: E501
-        if 'if_none_match' in params and params['if_none_match'] is not None:
-            header_params['If-None-Match'] = params['if_none_match']  # noqa: E501
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client._select_header_accept(
+            ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
+
+        # Process operation specific headers
+        extra_params = []
+        extra_params.append('async_req')
+        extra_params.append('_return_http_data_only')
+        extra_params.append('_preload_content')
+        extra_params.append('_request_timeout')
+        all_params = set(['extId'])
+        all_params.update(extra_params)
+        for key, val in six.iteritems(params):
+            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
+                if key.lower() == 'if_match'.lower():
+                    key = 'If-Match'
+                elif key.lower() == 'if_none_match'.lower():
+                    key = 'If-None-Match'
+                header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/api/iam/v4.0.a1/authn/saml-identity-providers/{extId}', 'GET',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type='iam.v4.authn.GetSamlIdentityProviderApiResponse',  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def get_saml_sp_metadata(self, **kwargs):  # noqa: E501
-        """Get SP metadata for SAML Identity Provider
-        Download SP metadata for SAML Identity Provider
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authz/authorization-policies/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authz.GetAuthorizationPolicyApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authz/authorization-policies/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authz.GetAuthorizationPolicyApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
+
+    def list_authorization_policies(self, _page=None, _limit=None, _filter=None, _orderby=None, _expand=None, _select=None, **kwargs):  # noqa: E501
+        """List Authorization Polic(ies)
 
-        >>> response = api.get_saml_sp_metadata()
+        >>> response = api.list_authorization_policies((optional) _page, (optional) _limit, (optional) _filter, (optional) _orderby, (optional) _expand, (optional) _select)
 
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
+        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.get_saml_sp_metadata(async_req=True)
+        >>> thread = api.list_authorization_policies(async_req=True)
         >>> result = thread.get()
 
-        :param bool async_req:
-        :return: iam.v4.authn.GetSamlSpMetadataApiResponse
+        :param _page: A URL query parameter that specifies the page number of the result set. It must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range might lead to no results. 
+        :type _page:
 
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """ # noqa: E501
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.get_saml_sp_metadata_with_http_info(**kwargs)  # noqa: E501
-        else:
-            (data) = self.get_saml_sp_metadata_with_http_info(**kwargs)  # noqa: E501
-            return data
-
-    def get_saml_sp_metadata_with_http_info(self, **kwargs):  # noqa: E501
-        """Get SP metadata for SAML Identity Provider
-        Download SP metadata for SAML Identity Provider
+            :class:`int`
+        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided, a default value of 50 records will be returned in the result set. 
+        :type _limit:
 
-        >>> response = api.get_saml_sp_metadata()
+            :class:`int`
+        :param _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the [OData V4.01](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html) URL conventions. For example, filter '$filter=name eq 'karbon-ntnx-1.0' would filter the result on cluster name 'karbon-ntnx1.0', filter '$filter=startswith(name, 'C')' would filter on cluster name starting with 'C'. The filter can be applied to the following fields: - authorizationPolicyType - clientName - createdBy - createdTime - displayName - extId - isSystemDefined - lastUpdatedTime - role 
+        :type _filter:
 
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
+            :class:`str`
+        :param _orderby: A URL query parameter that allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified, the resources will be sorted in ascending order by default. For example, '$orderby=templateName desc' would get all templates sorted by templateName in descending order. The orderby can be applied to the following fields: - createdTime - displayName - extId - lastUpdatedTime - role 
+        :type _orderby:
 
-        >>> thread = api.get_saml_sp_metadata_with_http_info(async_req=True)
-        >>> result = thread.get()
+            :class:`str`
+        :param _expand: A URL query parameter that allows clients to request related resources when a resource that satisfies a particular request is retrieved. Each expanded item is evaluated relative to the entity containing the property being expanded. Other query options can be applied to an expanded property by appending a semicolon-separated list of query options, enclosed in parentheses, to the property name. Permissible system query options are $filter, $select and $orderby. The following expansion keys are supported. - role 
+        :type _expand:
 
-        :param bool async_req:
-        :return: iam.v4.authn.GetSamlSpMetadataApiResponse
+            :class:`str`
+        :param _select: A URL query parameter that allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the [OData V4.01](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html) URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e., *), then all properties on the matching resource will be returned. - authorizationPolicyType - clientName - createdBy - createdTime - description - displayName - entities - extId - identities - isSystemDefined - lastUpdatedTime - links - role - tenantId 
+        :type _select:
 
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        all_params = []  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-        all_params.append('if_match')
-        all_params.append('if_none_match')
+            :class:`str`
+        :param kwargs: kwargs for the method.
+                       The following can be passed for an asynchronous HTTP call::
 
-        params = locals()
+                           async_req=True
+        :return: An instance of class :class:`~ntnx_iam_py_client.models.iam.v4.authz.ListAuthorizationPoliciesApiResponse`.
+
+                 If the method is called asynchronously, returns the request thread.
+        """ # noqa: E501
+        kwargs['_return_http_data_only'] = True
+
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
-            if key not in all_params:
-                raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_saml_sp_metadata" % key
-                )
             params[key] = val
         del params['kwargs']
+        del params['self']
+
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
+        if '_page' in params and params['_page'] is not None:
+            query_params.append(('$page', params['_page']))  # noqa: E501
+        if '_limit' in params and params['_limit'] is not None:
+            query_params.append(('$limit', params['_limit']))  # noqa: E501
+        if '_filter' in params and params['_filter'] is not None:
+            query_params.append(('$filter', params['_filter']))  # noqa: E501
+        if '_orderby' in params and params['_orderby'] is not None:
+            query_params.append(('$orderby', params['_orderby']))  # noqa: E501
+        if '_expand' in params and params['_expand'] is not None:
+            query_params.append(('$expand', params['_expand']))  # noqa: E501
+        if '_select' in params and params['_select'] is not None:
+            query_params.append(('$select', params['_select']))  # noqa: E501
 
         header_params = {}
-        if 'if_match' in params and params['if_match'] is not None:
-            header_params['If-Match'] = params['if_match']  # noqa: E501
-        if 'if_none_match' in params and params['if_none_match'] is not None:
-            header_params['If-None-Match'] = params['if_none_match']  # noqa: E501
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client._select_header_accept(
+            ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
+
+        # Process operation specific headers
+        extra_params = []
+        extra_params.append('async_req')
+        extra_params.append('_return_http_data_only')
+        extra_params.append('_preload_content')
+        extra_params.append('_request_timeout')
+        all_params = set(['_page', '_limit', '_filter', '_orderby', '_expand', '_select'])
+        all_params.update(extra_params)
+        for key, val in six.iteritems(params):
+            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
+                if key.lower() == 'if_match'.lower():
+                    key = 'If-Match'
+                elif key.lower() == 'if_none_match'.lower():
+                    key = 'If-None-Match'
+                header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['text/xml', 'application/json'])  # noqa: E501
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/api/iam/v4.0.a1/authn/saml-identity-providers/saml20/sp-metadata', 'GET',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type='iam.v4.authn.GetSamlSpMetadataApiResponse',  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def update_saml_identity_provider(self, body, extId, **kwargs):  # noqa: E501
-        """Update SAML Identity Provider
-        Update a SAML Identity Provider
+        body_params = None
 
-        >>> response = api.update_saml_identity_provider(body, extId)
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authz/authorization-policies', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authz.ListAuthorizationPoliciesApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authz/authorization-policies', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authz.ListAuthorizationPoliciesApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
+    def update_authorization_policy_by_id(self, extId, body, **kwargs):  # noqa: E501
+        """Update Authorization Policy
 
-        >>> thread = api.update_saml_identity_provider(body, extId, async_req=True)
-        >>> result = thread.get()
+        >>> response = api.update_authorization_policy_by_id(extId, body)
 
-        :param iam.v4.authn.SamlIdentityProvider body: Update a SAML Identity Provider (required)
-        :param str extId: External identifier of the SAML Identity Provider (required)
-        :param bool async_req:
-        :return: iam.v4.authn.UpdateSamlIdentityProviderApiResponse
+        This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """ # noqa: E501
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.update_saml_identity_provider_with_http_info(body, extId, **kwargs)  # noqa: E501
-        else:
-            (data) = self.update_saml_identity_provider_with_http_info(body, extId, **kwargs)  # noqa: E501
-            return data
-
-    def update_saml_identity_provider_with_http_info(self, body, extId, **kwargs):  # noqa: E501
-        """Update SAML Identity Provider
-        Update a SAML Identity Provider
+        >>> thread = api.update_authorization_policy_by_id(extId, body, async_req=True)
+        >>> result = thread.get()
 
-        >>> response = api.update_saml_identity_provider(body, extId)
+        :param extId: ExtId for the Role.
+        :type extId:
 
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
+            :class:`str`, required
+        :param body: Update an Authorization Policy.
+        :type body:
 
-        >>> thread = api.update_saml_identity_provider_with_http_info(body, extId, async_req=True)
-        >>> result = thread.get()
+            :class:`~ntnx_iam_py_client.models.iam.v4.authz.AuthorizationPolicy`, required
+        :param kwargs: kwargs for the method.
+                       The following can be passed for an asynchronous HTTP call::
+
+                           async_req=True
+        :return: An instance of class :class:`~ntnx_iam_py_client.models.iam.v4.authz.UpdateAuthorizationPolicyApiResponse`.
 
-        :param iam.v4.authn.SamlIdentityProvider body: Update a SAML Identity Provider (required)
-        :param str extId: External identifier of the SAML Identity Provider (required)
-        :param bool async_req:
-        :return: iam.v4.authn.UpdateSamlIdentityProviderApiResponse
-
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        all_params = ['body', 'extId']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-        all_params.append('if_match')
-        all_params.append('if_none_match')
+                 If the method is called asynchronously, returns the request thread.
+        """ # noqa: E501
+        kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
-            if key not in all_params:
-                raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method update_saml_identity_provider" % key
-                )
             params[key] = val
         del params['kwargs']
-        # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
-            raise ValueError("Missing the required parameter `body` when calling `update_saml_identity_provider`")  # noqa: E501
+        del params['self']
+
         # verify the required parameter 'extId' is set
-        if ('extId' not in params or
-                params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `update_saml_identity_provider`")  # noqa: E501
+        if ('extId' not in params or params['extId'] is None):
+            raise ValueError("Missing the required parameter `extId` when calling `update_authorization_policy_by_id`")  # noqa: E501
+        # verify the required parameter 'body' is set
+        if ('body' not in params or params['body'] is None):
+            raise ValueError("Missing the required parameter `body` when calling `update_authorization_policy_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'extId' in params:
+        if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'if_match' in params and params['if_match'] is not None:
-            header_params['If-Match'] = params['if_match']  # noqa: E501
-        if 'if_none_match' in params and params['if_none_match'] is not None:
-            header_params['If-None-Match'] = params['if_none_match']  # noqa: E501
-
-        form_params = []
-        local_var_files = {}
-
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
+        header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
+        header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
             ['application/json'])  # noqa: E501
+        if 'Content-Type' in params and params.get('Content-Type') is not None:
+            header_params['Content-Type'] = params.get('Content-Type')
+
+        # Process operation specific headers
+        extra_params = []
+        extra_params.append('async_req')
+        extra_params.append('_return_http_data_only')
+        extra_params.append('_preload_content')
+        extra_params.append('_request_timeout')
+        all_params = set(['extId', 'body'])
+        all_params.update(extra_params)
+        for key, val in six.iteritems(params):
+            if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
+                if key.lower() == 'if_match'.lower():
+                    key = 'If-Match'
+                elif key.lower() == 'if_none_match'.lower():
+                    key = 'If-None-Match'
+                header_params[key] = val
+
+        form_params = []
+        local_var_files = {}
 
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/api/iam/v4.0.a1/authn/saml-identity-providers/{extId}', 'PUT',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type='iam.v4.authn.UpdateSamlIdentityProviderApiResponse',  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+        body_params = None
+        if 'body' in params and params['body'] is not None:
+            body_params = params['body']
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authz/authorization-policies/{extId}', 'PUT',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authz.UpdateAuthorizationPolicyApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/iam/v4.0.b1/authz/authorization-policies/{extId}', 'PUT',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='iam.v4.authz.UpdateAuthorizationPolicyApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/api_response.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/api_response.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,33 +1,27 @@
 # coding: utf-8
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import re  # noqa: F401
 
 import six
 
 
 class ApiResponse:
-    """ IGNORE:
-    NOTE: This class is auto generated by the swagger code generator program.
-
-    Do not edit the class manually.
-    IGNORE
-    """ # noqa: E501
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """ # noqa: E501
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/configuration.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/configuration.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,23 +1,24 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 from __future__ import absolute_import
 
+import os
 import copy
 import logging
 from logging.handlers import TimedRotatingFileHandler
 import multiprocessing
 import sys
 import urllib3
 
@@ -36,32 +37,51 @@
         return copy.copy(cls._default)
 
     def set_default(cls, default):
         cls._default = copy.copy(default)
 
 
 class Configuration(six.with_metaclass(TypeWithDefault, object)):
-    """Configuration class for Configuration of ApiClient.
+    """A class for the configuration of :class:`~ntnx_iam_py_client.api_client.ApiClient`.
+
     This class contains certain configuration methods and data required by the api client.
 
-    :param host: (default: localhost) Host name to connect which can be either IPv4, IPv6 or FQDN
-    :param port: (default: 9440) Port number to connect
-    :param max_retry_attempts: (default: 5) Maximum retry attempts to be made in case of status codes [408, 503, 504]
-    :param backoff_factor: (default: 3 sec) Backoff factor by which the retry request is delayed with specific number of seconds calculated by the following formula:
+    :param scheme: (:attr:`scheme`) URI scheme for connecting to the cluster (HTTP or HTTPS using SSL/TLS) (**Default** https)
+    :type scheme: :class:`str`
+    :param host: (:attr:`host`) A host name to connect which can be either IPv4, IPv6 or FQDN (**Default** localhost)
+    :type host: :class:`str`, required
+    :param port: (:attr:`port`) A port number to connect (**Default** 9440)
+    :type port: :class:`int`
+    :param username: (:attr:`username`) A username for HTTP basic authentication
+    :type username: :class:`str`, required
+    :param password: (:attr:`password`) A password for HTTP basic authentication
+    :type password: :class:`str`, required
+    :param debug: (:attr:`debug`) Runs the client in debug mode by enabling/disabling debug logging (**Default** False)
+    :type debug: :class:`bool`
+    :param verify_ssl: (:attr:`verify_ssl`) Verify SSL certificate of cluster the client will connect to (**Default** True)
+    :type verify_ssl: :class:`bool`
+    :param max_retry_attempts: (:attr:`max_retry_attempts`) Maximum retry attempts to be made in case of status codes [408, 503, 504] (**Default** 5)
+    :type max_retry_attempts: :class:`int`
+    :param backoff_factor: (:attr:`backoff_factor`) Backoff factor by which the retry request is delayed with specific number of seconds (**Default** 3).
+
+        This is calculated by the following formula: ::
+
         {backoff_factor} * (2 * ({number of retries so far} - 1))
-    :param username: Username for HTTP basic authentication
-    :param password: Password for HTTP basic authentication
-    :param debug: (default: False) Enable/Disable debug logging
-    :param logger_file: Log file location
-    """ # noqa: E501
-
-    """NOTE: This class is auto generated by the swagger code generator program.
-    Ref: https://github.com/swagger-api/swagger-codegen
-    Do not edit the class manually.
-    """ # noqa: E501
+    :type backoff_factor: :class:`float`
+    :param logger_file: (:attr:`logger_file`) File location to which logs are written to
+    :type logger_file: :class:`str`
+    :param connect_timeout: (:attr:`connect_timeout`) Connection timeout in milliseconds for all operations (**Default** 30000)
+    :type connect_timeout: :class:`int`
+    :param read_timeout: (:attr:`read_timeout`) Read timeout in milliseconds for all operations (**Default** 30000)
+    :type read_timeout: :class:`int`
+    :param download_directory: (:attr:`download_directory`) Directory location on local for files to download
+    :type download_directory: :class:`str`
+    :param download_chunk_size: (:attr:`download_chunk_size`) Chunk size in bytes for files to download (**Default** 8*1024 bytes)
+    :type download_chunk_size: :class:`int`
+    """  # noqa: E501
 
     def __init__(self):
 
         """Constructor"""
         self.__scheme = "https"
 
         # Default host name
@@ -72,18 +92,20 @@
 
         # Maximum number of allowed retries for a HTTP call
         self.__max_retry_attempts = 5
 
         # Backoff factor by which the retry request is delayed with specific number of seconds.
         self.__backoff_factor = 3
 
-        self.__user_agent = 'Nutanix-ntnx_iam_py_client/4.0.2a1'
+        self.__user_agent = 'Nutanix-ntnx_iam_py_client/4.0.2b1'
 
-        # Temp file folder for downloading files
-        self.temp_folder_path = None
+        # Directory path for downloading files
+        self.__download_directory = os.path.abspath(os.getcwd())
+        # Chunk size for downloading files
+        self.__download_chunk_size = 8*1024
 
         # Authentication Settings
         # HTTP Basic Auth
         self.__username = None
         self.__password = None
 
         # API Key authentication (NOTE: SDK currently supports basic auth only)
@@ -141,239 +163,220 @@
         self.__default_connect_timeout = 30000
         self.__default_read_timeout = 30000
         self.__connect_timeout = None
         self.__read_timeout = None
 
     @property
     def scheme(self):
-        """Retrieve current URI scheme for connecting to the cluster (HTTP or HTTPS using SSL/TLS)
+        """URI scheme for connecting to the cluster (HTTP or HTTPS using SSL/TLS) (**Default** https).
+
+        :type: :class:`str`
         """
         return self.__scheme
 
     @scheme.setter
     def scheme(self, value):
-        """Set URI scheme for connecting to the cluster (HTTP or HTTPS using SSL/TLS)
-
-        :param value: URI scheme for connecting to the cluster (HTTP or HTTPS using SSL/TLS).
-        :type: str
-        """
         self.__scheme = value
 
     @property
     def host(self):
-        """Host IPv4, IPv6 or FQDN
+        """Host name to connect which can be either IPv4, IPv6 or FQDN (**Default** localhost).
+
+        :type: :class:`str`
         """
         return self.__host
 
     @host.setter
     def host(self, value):
-        """Host IPv4/IPv6 or FQDN
-
-        :param value: Host to connect.
-        :type: str
-        """
         self.__host = value
 
     @property
     def port(self):
-        """Port number
+        """Port number to connect (**Default** 9440).
+
+        :type: :class:`int`
         """
         return self.__port
 
     @port.setter
     def port(self, value):
-        """Port number
+        self.__port = value
 
-        :param value: Port number
-        :type: int
+    @property
+    def download_directory(self):
+        """Directory path for downloading files (**Default** current directory).
+
+        :type: :class:`str`
         """
-        self.__port = value
+        return self.__download_directory
+
+    @download_directory.setter
+    def download_directory(self, value):
+        self.__download_directory = value
+
+    @property
+    def download_chunk_size(self):
+        """Chunk size for downloading files (**Default** 8*1024 bytes).
+
+        :type: :class:`int`
+        """
+        return self.__download_chunk_size
+
+    @download_chunk_size.setter
+    def download_chunk_size(self, value):
+        self.__download_chunk_size = value
 
     @property
     def max_retry_attempts(self):
-        """Maximum allowed retry attempts for a HTTP call in case of response status codes [408, 503, 504]
+        """Maximum allowed retry attempts for a HTTP call in case of response status codes [408, 503, 504] (**Default** 5).
+
+        :type: :class:`int`
         """
         return self.__max_retry_attempts
 
     @max_retry_attempts.setter
     def max_retry_attempts(self, value):
-        """Maximum allowed retry attempts for a HTTP call in case of response status codes [408, 503, 504]
-
-        :param value: Maximum allowed retry attempts
-        :type: int
-        """
         self.__max_retry_attempts = value
 
     @property
     def backoff_factor(self):
-        """Backoff factor by which the retry request is delayed with specific number of seconds.
-        This is calculated based on the following formula:
-        {backoff_factor} * (2 * ({number of retries so far} - 1))
+        """Backoff factor by which the retry request is delayed with specific number of seconds (**Default** 3).
+
+        This is calculated by the following formula: ::
+
+            {backoff_factor} * (2 * ({number of retries so far} - 1))
+
+        :type: :class:`float`
         """
         return self.__backoff_factor
 
     @backoff_factor.setter
     def backoff_factor(self, value):
-        """Backoff factor by which the retry request is delayed with specific number of seconds.
-        This is calculated based on the following formula:
-        {backoff_factor} * (2 * ({number of retries so far} - 1))
-
-        :param value: Backoff factor
-        :type: float
-        """
         self.__backoff_factor = value
 
     @property
     def user_agent(self):
         """Value for User-Agent header.
+
+        :type: :class:`str`
         """
         return self.__user_agent
 
     @property
     def username(self):
-        """User name for basic authentication
+        """Username to connect to a cluster.
+
+        :type: :class:`str`
         """
         return self.__username
 
     @username.setter
     def username(self, value):
-        """User name for basic authentication
-
-        :param value: User name
-        :type: str
-        """
         self.__username = value
 
     @property
     def password(self):
-        """Password for basic authentication
+        """Password to connect to a cluster.
+
+        :type: :class:`str`
         """
         return self.__password
 
     @password.setter
     def password(self, value):
-        """Password for basic authentication
-
-        :param value: Password
-        :type: str
-        """
         self.__password = value
 
     @property
     def verify_ssl(self):
-        """Retrieves whether client side SSL verification is enabled or not
+        """A flag to enable/disable verification the SSL certificate of target cluster.
+
+        :type: :class:`bool`
         """
         return self.__verify_ssl
 
     @verify_ssl.setter
     def verify_ssl(self, value):
-        """Toggles whether client side SSL verification needs to be enabled or not
-
-        :param value: Verify SSL handshake certificate
-        :type bool
-        """
         self.__verify_ssl = value
 
     @property
     def proxy_scheme(self):
-        """ Retrieve scheme for the proxy
+        """Scheme for the proxy URI.
+
+        :type: :class:`str`
         """
         return self.__proxy_scheme
 
     @proxy_scheme.setter
     def proxy_scheme(self, value):
-        """ Set value for the scheme for the proxy
-
-        :param value: proxy scheme
-        :type str
-        """
         self.__proxy_scheme = value
 
     @property
     def proxy_host(self):
-        """ Retrieve host for the proxy
+        """Host for the proxy URI.
+
+        :type: :class:`str`
         """
         return self.__proxy_host
 
     @proxy_host.setter
     def proxy_host(self, value):
-        """ Set value for the host for the proxy
-
-        :param value: proxy host
-        :type str
-        """
         self.__proxy_host = value
 
     @property
     def proxy_port(self):
-        """ Retrieve port for the proxy
+        """Port number for the proxy URI.
+
+        :type: :class:`int`
         """
         return self.__proxy_port
 
     @proxy_port.setter
     def proxy_port(self, value):
-        """ Set value for the port for the proxy
-
-        :param value: proxy port
-        :type int
-        """
         self.__proxy_port = value
 
     @property
     def proxy_username(self):
-        """ Retrieve username for the proxy
+        """Username for the proxy authentication.
+
+        :type: :class:`str`
         """
         return self.__proxy_username
 
     @proxy_username.setter
     def proxy_username(self, value):
-        """ Set value for the username for the proxy
-
-        :param value: proxy username
-        :type str
-        """
         self.__proxy_username = value
 
     @property
     def proxy_password(self):
-        """ Retrieve password for the proxy
+        """Password for the proxy authentication.
+
+        :type: :class:`str`
         """
         return self.__proxy_password
 
     @proxy_password.setter
     def proxy_password(self, value):
-        """ Set value for the password for the proxy
-
-        :param value: proxy password
-        :type str
-        """
         self.__proxy_password = value
 
     @property
     def logger_file(self):
-        """The logger file.
+        """File location to which debug logs are written to.
+
+        If the logger_file is None, then a  logger is configured with a console stream handler and all the file
+        handlers are removed.
+        Otherwise, a logger is configured with a file handler and stream handlers are removed.
 
-        If the logger_file is None, then add stream handler and remove file
-        handler. Otherwise, add file handler and remove stream handler.
+        Configured file handlers are time based handlers which are rotated everyday at midnight.
 
-        :param value: The logger_file path.
-        :type: str
+        :type: :class:`str`
         """
         return self.__logger_file
 
     @logger_file.setter
     def logger_file(self, value):
-        """The logger file.
-
-        If the logger_file is None, then add stream handler and remove file
-        handler. Otherwise, add file handler and remove stream handler.
-
-        :param value: The logger_file path.
-        :type: str
-        """
         self.__logger_file = value
         if self.__logger_file:
             # If set logging file,
             # then add file handler and remove stream handler.
             self.logger_file_handler = logging.handlers.TimedRotatingFileHandler(self.__logger_file, 'midnight', 1)
             self.logger_file_handler.suffix = "%Y-%m-%d"
             self.logger_file_handler.setFormatter(self.logger_formatter)
@@ -389,155 +392,139 @@
             for _, logger in six.iteritems(self.logger):
                 logger.addHandler(self.logger_stream_handler)
                 if self.logger_file_handler:
                     logger.removeHandler(self.logger_file_handler)
 
     @property
     def debug(self):
-        """Debug status
+        """Runs the client in debug mode by enabling/disabling debug logging (**Default** False).
+
+        Default logging level is INFO and all associated loggers' levels are toggled between INFO and DEBUG by this flag.
 
-        :param value: The debug status, True or False.
-        :type: bool
+        :type: :class:`bool`
         """
         return self.__debug
 
     @debug.setter
     def debug(self, value):
-        """Debug status
-
-        :param value: The debug status, True or False.
-        :type: bool
-        """
         self.__debug = value
         if self.__debug:
             # if debug status is True, turn on debug logging
             for _, logger in six.iteritems(self.logger):
                 logger.setLevel(logging.DEBUG)
-            # turn on httplib debug
-            httplib.HTTPConnection.debuglevel = 1
         else:
             # if debug status is False, turn off debug logging,
             # setting log level to default `logging.INFO`
             for _, logger in six.iteritems(self.logger):
                 logger.setLevel(logging.INFO)
-            # turn off httplib debug
-            httplib.HTTPConnection.debuglevel = 0
 
     @property
     def logger_format(self):
-        """The logger format.
-
-        The logger_formatter will be updated when sets logger_format.
+        """The log format for file or stream log handler.
 
-        :param value: The format string.
-        :type: str
+        :type: :class:`str`
         """
         return self.__logger_format
 
     @logger_format.setter
     def logger_format(self, value):
-        """The logger format.
-
-        The logger_formatter will be updated when sets logger_format.
-
-        :param value: The format string.
-        :type: str
-        """
         self.__logger_format = value
         self.logger_formatter = logging.Formatter(self.__logger_format)
 
     @property
     def default_connect_timeout(self):
-        """Default connect timeout
+        """Default connection timeout in milliseconds for a HTTP request (**Default** 30000).
+
+        :type: :class:`int`
         """
 
         return self.__default_connect_timeout
 
     @property
     def default_read_timeout(self):
-        """Default read timeout
+        """Default read timeout in milliseconds for a HTTP request (**Default** 30000).
+
+        :type: :class:`int`
         """
 
         return self.__default_read_timeout
 
     @property
     def connect_timeout(self):
-        """Connect timeout for an operation in milliseconds
+        """Connect timeout for an operation in milliseconds.
+
+        :type: :class:`int`
         """
 
         return self.__connect_timeout
 
     @connect_timeout.setter
     def connect_timeout(self, value):
-        """Connect timeout
-
-        :param value: Time in milliseconds.
-        :type: integer
-        """
-
         self.__connect_timeout = value
 
     @property
     def read_timeout(self):
-        """Read timeout for an operation in milliseconds
-        """
+        """Read timeout for an operation in milliseconds.
 
+        :type: :class:`int`
+        """
         return self.__read_timeout
 
     @read_timeout.setter
     def read_timeout(self, value):
-        """Read timeout
-
-        :param value: Time in milliseconds.
-        :type: integer
-        """
-
         self.__read_timeout = value
 
-    def get_api_key_with_prefix(self, identifier):
+    def _get_api_key_with_prefix(self, identifier):
         """Gets API key (with prefix if set).
 
-        :param identifier: The identifier of apiKey.
-        :return: The token for api key authentication.
+        :param identifier: The identifier of apiKey
+        :type identifier: :class:`str`
+        ...
+        :return: A token for api key authentication
+        :rtype: :class:`str`
         """
         if (self.api_key.get(identifier) and
                 self.api_key_prefix.get(identifier)):
             return self.api_key_prefix[identifier] + ' ' + self.api_key[identifier]  # noqa: E501
         elif self.api_key.get(identifier):
             return self.api_key[identifier]
 
     def get_basic_auth_token(self):
         """Gets HTTP basic authentication header (string).
 
-        :return: The token for basic HTTP authentication.
+        :return: A token for basic HTTP authentication.
+        :rtype: :class:`str`
         """
         if self.__username and self.__password:
             return urllib3.util.make_headers(
                 basic_auth=self.__username + ':' + self.__password
             ).get('authorization')
 
-    def auth_settings(self):
-        """Gets Auth Settings dict for api client.
-
-        :return: The Auth Settings information dict.
+    def _auth_settings(self):
+        """Gets Auth Settings configuration.
         """
         return {
             'basicAuthScheme':
                 {
                     'type': 'basic',
                     'in': 'header',
                     'key': 'Authorization',
                     'value': self.get_basic_auth_token()
                 },
+            'iam.v4.r0.b1.authn.bearerAuth':
+                {
+                    'type': 'api_key',
+                    'in': 'header',
+                    'key': 'Authorization',
+                    'value': self._get_api_key_with_prefix('Authorization')
+                },
         }
 
     def to_debug_report(self):
-        """Gets the essential information for debugging.
-
-        :return: The report for debugging.
+        """Prints the information about current OS, Python, API and SDK versions for debugging purposes
         """
         return "Python SDK Debug Report:\n"\
                "OS: {env}\n"\
                "Python Version: {pyversion}\n"\
-               "Version of the API: 4.0.2-alpha-1\n"\
-               "SDK Package Version: 4.0.2a1".\
+               "Version of the API: 4.0.2-beta-1\n"\
+               "SDK Package Version: 4.0.2b1".\
                format(env=sys.platform, pyversion=sys.version)
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client/rest.py` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client/rest.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,17 +1,17 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 from __future__ import absolute_import
 
 import io
@@ -37,15 +37,15 @@
 
 class RESTResponse(io.IOBase):
 
     def __init__(self, resp):
         self.urllib3_response = resp
         self.status = resp.status
         self.reason = resp.reason
-        self.data = resp.data
+        self.data = None
 
     def getheaders(self):
         """Returns a dictionary of the response headers."""
         return self.urllib3_response.getheaders()
 
     def getheader(self, name, default=None):
         """Returns a given response header."""
@@ -180,14 +180,16 @@
             if isinstance(_request_timeout, (int, float) if six.PY3 else (int, long, float)):  # noqa: E501,F821
                 timeout = urllib3.Timeout(total=_request_timeout)
             elif (isinstance(_request_timeout, list) and len(_request_timeout) == 2):
                 timeout = urllib3.Timeout(connect=_request_timeout[0], read=_request_timeout[1])
 
         if 'Content-Type' not in headers:
             headers['Content-Type'] = 'application/json'
+        if 'Accept' in headers and headers['Accept'] == 'application/octet-stream':
+            _preload_content = False
 
         # Print log statements
         logger.info("%s %s", method, url + '?' + urlencode(query_params) if query_params else url)
         # Print debug logs, if enabled
         if self.__configuration.debug:
             logger.debug("Request Headers:")
             for key, value in six.iteritems(headers):
@@ -198,14 +200,19 @@
             if method in ['POST', 'PUT', 'PATCH', 'OPTIONS', 'DELETE']:
                 if query_params:
                     url += '?' + urlencode(query_params)
                 if re.search('json', headers['Content-Type'], re.IGNORECASE):
                     request_body = None
                     if body is not None:
                         request_body = json.dumps(body)
+
+                    # Print request body, if debug configuration is enabled
+                    if self.__configuration.debug:
+                        logger.debug("Request Body: %s", request_body)
+
                     r = self.pool_manager.request(
                         method, url,
                         body=request_body,
                         preload_content=_preload_content,
                         timeout=timeout,
                         headers=headers)
                 elif headers['Content-Type'] == 'application/x-www-form-urlencoded':  # noqa: E501
@@ -216,31 +223,37 @@
                         preload_content=_preload_content,
                         timeout=timeout,
                         headers=headers)
                 elif headers['Content-Type'] == 'multipart/form-data':
                     # must del headers['Content-Type'], or the correct
                     # Content-Type which generated by urllib3 will be
                     # overwritten.
+                    content_type_header = headers['Content-Type']
                     del headers['Content-Type']
                     r = self.pool_manager.request(
                         method, url,
                         fields=post_params,
                         encode_multipart=True,
                         preload_content=_preload_content,
                         timeout=timeout,
                         headers=headers)
+                    headers['Content-Type'] = content_type_header
                 # Pass a `string` parameter directly in the body to support
                 # other content types than Json when `body` argument is
                 # provided in serialized form
-                elif isinstance(body, str):
+                elif isinstance(body, str) or headers['Content-Type'] == 'application/octet-stream':
                     request_body = body
+                    preload = _preload_content
+                    if headers['Content-Type'] == 'application/octet-stream':
+                        preload = False
+
                     r = self.pool_manager.request(
                         method, url,
                         body=request_body,
-                        preload_content=_preload_content,
+                        preload_content=preload,
                         timeout=timeout,
                         headers=headers)
                 else:
                     # Cannot generate the request from given parameters
                     msg = """Cannot prepare a request message for provided
                              arguments. Please check that your arguments match
                              declared content type."""
@@ -255,30 +268,27 @@
         except urllib3.exceptions.SSLError as e:
             msg = "{0}\n{1}".format(type(e).__name__, str(e))
             raise ApiException(status=0, reason=msg)
         except Exception as e:
             logger.error(str(e))
             raise
 
-        if _preload_content:
+        if r.getheader(name='Content-Type') == 'application/octet-stream' or _preload_content :
             r = RESTResponse(r)
 
-            # In the python 3, the response.data is bytes.
-            # we need to decode it to string.
-            if six.PY3:
-                r.data = r.data.decode('utf8')
-
         # Print log statements
         logger.info("Response Status: %s %s", r.status, r.reason)
         # Print debug logs, if enabled
         if self.__configuration.debug:
             logger.debug("Response Headers:")
             for key, value in six.iteritems(r.getheaders()):
                 logger.debug("%s: %s", key, value)
-            logger.debug("Response Body: %s", r.data)
+
+            if _preload_content and r.getheader("Content-Type", "application/json") != "application/octet-stream":
+                logger.debug("Response Body: %s", r.urllib3_response.data)
 
         if not 200 <= r.status <= 299 and not 401 == r.status:
             raise ApiException(http_resp=r)
 
         return r
 
     def GET(self, url, headers=None, query_params=None, _preload_content=True,
@@ -349,15 +359,16 @@
 
 class ApiException(Exception):
 
     def __init__(self, status=None, reason=None, http_resp=None):
         if http_resp:
             self.status = http_resp.status
             self.reason = http_resp.reason
-            self.body = http_resp.data
+            self.body = (http_resp.urllib3_response.data.decode('utf8') if hasattr(http_resp, 'urllib3_response')
+                        else http_resp.data.decode('utf8'))
             self.headers = http_resp.getheaders()
         else:
             self.status = status
             self.reason = reason
             self.body = None
             self.headers = None
```

### Comparing `ntnx-iam-py-client-4.0.2a1/ntnx_iam_py_client.egg-info/PKG-INFO` & `ntnx_iam_py_client-4.0.2b1/ntnx_iam_py_client.egg-info/PKG-INFO`

 * *Files 6% similar despite different names*

```diff
@@ -1,32 +1,37 @@
 Metadata-Version: 2.1
 Name: ntnx-iam-py-client
-Version: 4.0.2a1
+Version: 4.0.2b1
 Summary: Nutanix Iam Versioned APIs
 Home-page: 
 Author-email: sdk@nutanix.com
 Keywords: Nutanix,v4,SDK,Nutanix Iam Versioned APIs
 Description-Content-Type: text/markdown
 License-File: LICENSE.txt
+Requires-Dist: urllib3~=1.26
+Requires-Dist: six~=1.16
+Requires-Dist: certifi<=2023.11.17,>=2020.4.5.1
+Requires-Dist: python-dateutil~=2.8
+Requires-Dist: pysocks~=1.7
 
 # Python Client For Nutanix Iam Versioned APIs
 
-The Python client for Nutanix Iam Versioned APIs is designed for Python client application developers offering them simple and flexible access to APIs that identity and Access Management in Nutanix cluster.
+The Python client for Nutanix Iam Versioned APIs is designed for Python client application developers offering them simple and flexible access to APIs that manage Identity and Access Management of Nutanix clusters.
 ## Features
 - Invoke Nutanix APIs with a simple interface.
 - Handle Authentication seamlessly.
 - Reduce boilerplate code implementation.
 - Use standard methods for installation.
 
 ## Version
-- API version: v4.0.a1
-- Package version: 4.0.2a1
+- API version: v4.0.b1
+- Package version: 4.0.2b1
 
 ## Requirements.
-Python 3.6, 3.7, and 3.8 are fully supported and tested.
+Python 3.6, 3.7, 3.8 and 3.9 are fully supported and tested.
 
 
 ## Installation & Usage
 
 ### Installing in a virtual environment
 [virtualenv](https://virtualenv.pypa.io/en/latest/) is a tool to create isolated Python environments. The basic problem it addresses is one of dependencies and versions, and indirectly permissions. virtualenv can help you install this client without needing system install permissions. It creates an environment that has its own installation directories without sharing libraries with other virtualenv environments or the system installation.
 
@@ -80,14 +85,15 @@
 | debug     | Runs the client in debug mode if specified                                       | No       | False        |
 | verify_ssl| Verify SSL certificate of cluster the client will connect to                     | No       | True         |
 | max_retry_attempts| Maximum number of retry attempts while connecting to the cluster         | No       | 5            |
 | backoff_factor| A backoff factor to apply between attempts after the second try.             | No       | 3            |
 | logger_file | File location to which debug logs are written to                               | No       | N/A          |
 | connect_timeout | Connection timeout in milliseconds for all operations                      | No       | 30000        |
 | read_timeout | Read timeout in milliseconds for all operations                               | No       | 30000        |
+| download_directory| Directory where downloaded files will be stored in                       | No       | Current Working Directory|
 
 
 ### Sample Configuration
 ```python
 config = Configuration()
 config.host = '10.19.50.27' # IPv4/IPv6 address or FQDN of the cluster
 config.port = 9440 # Port to which to connect to
@@ -137,79 +143,79 @@
 ```
 
 ## Usage
 
 ### Invoking an operation
 ```python
 # Initialize the API
-cert_auth_provider_api_instance = CertAuthProviderApi(api_client=client) # client configured in previous step
+certificate_authentication_providers_api_instance = CertificateAuthenticationProvidersApi(api_client=client) # client configured in previous step
 extId = 'extId_example' # UUID.
 
-# Get certificate based authentication provider
+# Get Certificate based Authentication provider
 try:
-    api_response = cert_auth_provider_api_instance.handle_get_cert_auth_provider(extId)
+    api_response = certificate_authentication_providers_api_instance.get_cert_auth_provider_by_id(extId)
 except ApiException as e:
 ```
 
 ### Setting headers for individual operations
 Headers can be configured globally on the python client using the [method to set default headers](#additional-headers). However, sometimes headers need to be set on an individual operation basis. Nutanix APIs require that concurrent updates are protected using [ETag headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag).
 
 ```python
 # Initialize the API
-cert_auth_provider_api_instance = CertAuthProviderApi(api_client=client) # client configured in previous step
+certificate_authentication_providers_api_instance = CertificateAuthenticationProvidersApi(api_client=client) # client configured in previous step
 extId = 'extId_example' # UUID.
 
-# Get certificate based authentication provider
+# Get Certificate based Authentication provider
 try:
-    api_response = cert_auth_provider_api_instance.handle_get_cert_auth_provider(extId)
+    api_response = certificate_authentication_providers_api_instance.get_cert_auth_provider_by_id(extId)
 except ApiException as e:
 
 # Extract E-Tag Header
 etag_value = ApiClient.get_etag(api_response)
 
-# Update certificate based authentication provider
+# Update Certificate based Authentication provider
 try:
     # The body parameter in the following operation is received from the previous GET request's response which needs to be updated.
-    api_response = cert_auth_provider_api_instance.handle_update_cert_auth_provider(body, extId, if_match=etag_value) # Use the extracted etag value
+    api_response = certificate_authentication_providers_api_instance.update_cert_auth_provider_by_id(body, extId, if_match=etag_value) # Use the extracted etag value
 except ApiException as e:
 ```
 
 ### List Operations
 List Operations for Nutanix APIs support pagination, filtering, sorting and projections. The table below details the parameters that can be used to set the options for pagination etc.
 
 | Parameter | Description
 |-----------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
 | _page     | specifies the page number of the result set. Must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range will lead to no results being returned.|
 | _limit    | specifies the total number of records returned in the result set. Must be a positive integer between 0 and 100. Any number out of this range will lead to a validation error. If the limit is not provided a default value of 50 records will be returned in the result set|
 | _filter   | allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the [OData V4.01 URL](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part2-url-conventions.html#sec_SystemQueryOptionfilter) conventions. |
 | _orderby  | allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified the resources will be sorted in ascending order by default. For example, 'orderby=templateName desc' would get all templates sorted by templateName in desc order. |
-| _select   | allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the OData V4.01 URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e. *), then all properties on the matching resource will be returned. |
-| _expand   | allows clients to request related resources when a resource that satisfies a particular request is retrieved. Each expand item is evaluated relative to the entity containing the property being expanded. Other query options can be applied to an expanded property by appending a semicolon-separated list of query options, enclosed in parentheses, to the property name. Allowed system query options are $filter,$select, $orderby. |
+| _select   | allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the OData V4.01 URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e., *), then all properties on the matching resource will be returned. |
+| _expand   | allows clients to request related resources when a resource that satisfies a particular request is retrieved. Each expanded item is evaluated relative to the entity containing the property being expanded. Other query options can be applied to an expanded property by appending a semicolon-separated list of query options, enclosed in parentheses, to the property name. Permissible system query options are $filter,$select and $orderby. |
 
 ```python
 # Initialize the API
-cert_auth_provider_api_instance = CertAuthProviderApi(api_client=client) # client configured in previous step
+certificate_authentication_providers_api_instance = CertificateAuthenticationProvidersApi(api_client=client) # client configured in previous step
 extId = 'extId_example' # UUID.
 
-# List certificate based authentication provider(s)
+# List Certificate based Authentication provider(s)
 try:
-    api_response = cert_auth_provider_api_instance.handle_list_cert_auth_providers(
+    api_response = certificate_authentication_providers_api_instance.list_cert_auth_providers(
 	                   _page=page, # if page parameter is present
 	                   _limit=limit, # if limit parameter is present
 	                   _filter=_filter, # if filter parameter is present
 	                   _orderby=_orderby, # if orderby parameter is present
 	                   _select=select, # if select parameter is present
 	                   _expand=expand) # if expand parameter is present
 except ApiException as e:
 
 ```
 The list of filterable and sortable fields with expansion keys can be found in the documentation [here](https://developers.nutanix.com/).
 
 ## API Reference
 
-This library has a full set of [API Reference Documentation](https://developers.nutanix.com/sdk-reference?namespace=iam&version=v4.0.a1&language=python). This documentation is auto-generated, and the location may change.
+This library has a full set of [API Reference Documentation](https://developers.nutanix.com/sdk-reference?namespace=iam&version=v4.0.b1&language=python). This documentation is auto-generated, and the location may change.
 
 ## License
 This library is licensed under Nutanix proprietary license. Full license text is available in [LICENSE](https://developers.nutanix.com/license).
 
 ## Contact us
 In case of issues please reach out to us at the [mailing list](mailto:sdk@nutanix.com)
```

### Comparing `ntnx-iam-py-client-4.0.2a1/setup.py` & `ntnx_iam_py_client-4.0.2b1/setup.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,35 +1,35 @@
 # coding: utf-8
 
 
 """
 IGNORE:
     Nutanix Iam Versioned APIs
 
-    Identity and Access Management in Nutanix cluster.  # noqa: E501
+    Manage Identity and Access Management of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.2-alpha-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import io
 import os
 from setuptools import setup, find_packages  # noqa: H301
 
 NAME = "ntnx-iam-py-client"
-VERSION = "4.0.2a1"
+VERSION = "4.0.2b1"
 # To install the library, run the following
 #
 # python setup.py install
 #
 # prerequisite: setuptools
 # http://pypi.python.org/pypi/setuptools
 
-REQUIRES = ["urllib3 ~= 1.26", "six ~= 1.16", "certifi == 2020.4.5.1", "python-dateutil ~= 2.8", "pysocks ~= 1.7"]
+REQUIRES = ["urllib3 ~= 1.26", "six ~= 1.16", "certifi >=2020.4.5.1,<=2023.11.17", "python-dateutil ~= 2.8", "pysocks ~= 1.7"]
 
 package_root_path = os.path.abspath(os.path.dirname(__file__))
 readme_file_path = os.path.join(package_root_path, "README.md")
 with io.open(readme_file_path, encoding="utf-8") as readme_file:
     readme = readme_file.read()
 
 setup(
```

