# Comparing `tmp/ntnx-microseg-py-client-4.0.1a1.tar.gz` & `tmp/ntnx_microseg_py_client-4.0.1b1.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "/home/circleci/project/verify/pip-release-verify/prod-package-microseg/dist/.tmp-2rptmhn6/ntnx-microseg-py-client-4.0.1a1.tar", last modified: Mon Sep 18 22:30:47 2023, max compression
+gzip compressed data, was "/home/circleci/project/verify/pip-release-verify/prod-package-microseg/dist/.tmp-9yimlxz3/ntnx_microseg_py_client-4.0.1b1.tar", last modified: Fri May 17 07:12:10 2024, max compression
```

## Comparing `ntnx-microseg-py-client-4.0.1a1.tar` & `ntnx_microseg_py_client-4.0.1b1.tar`

### file list

```diff
@@ -1,195 +1,184 @@
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:47.650551 ntnx-microseg-py-client-4.0.1a1/
--rw-r--r--   0 circleci  (3434) circleci  (3434)    18137 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/LICENSE.txt
--rw-r--r--   0 circleci  (3434) circleci  (3434)    11633 2023-09-18 22:30:47.650551 ntnx-microseg-py-client-4.0.1a1/PKG-INFO
--rw-r--r--   0 circleci  (3434) circleci  (3434)    11203 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/README.md
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:47.617551 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/
--rw-r--r--   0 circleci  (3434) circleci  (3434)    16057 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:47.619552 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/api/
--rw-r--r--   0 circleci  (3434) circleci  (3434)      417 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/api/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    25503 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/api/address_groups_api.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    46532 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/api/directory_server_api.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    40932 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/api/network_security_policies_api.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    25520 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/api/service_groups_api.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    47704 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/api_client.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     2402 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/api_response.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    15719 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/configuration.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:47.619552 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:47.620551 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfcommon/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfcommon/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:47.620551 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfcommon/v1/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfcommon/v1/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:47.620551 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfcommon/v1/config/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6544 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfcommon/v1/config/KVPairvalue.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfcommon/v1/config/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:47.620551 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:47.621551 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:47.627551 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6649 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/AddressGroupGetResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6668 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/AddressGroupListResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6789 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/AddressGroupPolicyAssociationResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6652 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/AddressGroupTaskResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6611 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/BannerGetResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6755 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/ConfigMigrationPreviewGetResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6739 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/ConfigMigrationSummaryGetResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6687 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/DirectoryServerCreateResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6687 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/DirectoryServerDeleteResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6676 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/DirectoryServerGetResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6695 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/DirectoryServerListResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6687 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/DirectoryServerUpdateResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6701 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/DsCategoryMappingCreateResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6701 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/DsCategoryMappingDeleteResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6690 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/DsCategoryMappingGetResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6701 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/DsCategoryMappingUpdateResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6737 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/DsCategoryMappingsGetListResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6635 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/MigrationConfigSpecspec.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6673 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/MigrationConfigTaskResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6846 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/NetworkSecurityPolicyGetListResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6730 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/NetworkSecurityPolicyGetResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6861 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/NetworkSecurityPolicyImportResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6785 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/NetworkSecurityPolicyRulesGetResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6819 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/NetworkSecurityPolicyRulespec.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6715 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/NetworkSecurityPolicyTaskResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6649 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/ServiceGroupGetResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6668 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/ServiceGroupListResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6789 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/ServiceGroupPolicyAssociationResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6652 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/ServiceGroupTaskResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6593 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/TierGetResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6610 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/TierUpdateResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:47.627551 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/error/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6608 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/error/ErrorResponseerror.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/error/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    15619 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:47.627551 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/common/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/common/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:47.628551 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/common/v1/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/common/v1/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:47.629552 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/common/v1/config/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6689 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/common/v1/config/Flag.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7533 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/common/v1/config/IPv4Address.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7121 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/common/v1/config/KVPair.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7857 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/common/v1/config/Message.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4689 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/common/v1/config/MessageSeverity.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7348 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/common/v1/config/TenantAwareModel.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/common/v1/config/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:47.630551 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/common/v1/response/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6995 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/common/v1/response/ApiLink.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    10227 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/common/v1/response/ApiResponseMetadata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     5836 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/common/v1/response/ExternalizableAbstractModel.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/common/v1/response/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:47.630551 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:47.630551 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:47.647551 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7121 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/AddressGroup.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7407 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/AddressGroupGetResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7407 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/AddressGroupListResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7561 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/AddressGroupPolicyAssociationResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7337 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/AddressGroupPolicyReference.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6554 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/AddressGroupReferenceSpec.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7416 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/AddressGroupTaskResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4632 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/AllowType.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7353 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/BannerGetResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     5809 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/BannerResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4776 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/BannerType.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     5440 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/CategoryMapping.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    10202 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/CategoryMappingAdInfo.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4850 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/CategoryMappingAdStatus.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8492 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/CategoryMappingInfo.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7127 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/ConfigMigrationPolicyOptions.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     5184 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/ConfigMigrationPolicyType.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7513 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/ConfigMigrationPreviewGetResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6017 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/ConfigMigrationPreviewResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7692 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/ConfigMigrationSummary.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7506 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/ConfigMigrationSummaryGetResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    10567 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/DirectoryServer.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7449 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/DirectoryServerCreateResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7459 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/DirectoryServerDeleteResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7437 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/DirectoryServerGetResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7437 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/DirectoryServerListResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7456 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/DirectoryServerUpdateResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6424 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/DomainController.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7465 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/DsCategoryMappingCreateResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7475 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/DsCategoryMappingDeleteResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7453 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/DsCategoryMappingGetResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7472 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/DsCategoryMappingUpdateResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7485 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/DsCategoryMappingsGetListResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6000 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/FileWrapper.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7502 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/IPv4Range.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8225 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/IcmpTypeCodeSpec.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4771 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/IntraEntityGroupRuleAction.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4674 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/MatchEntity.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4661 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/MatchField.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4830 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/MatchType.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     9189 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/MatchingCriteria.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8176 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/MigrationConfig.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8172 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/MigrationConfigSpec.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7446 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/MigrationConfigTaskResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7747 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/MigrationSummary.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    17945 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/NSPApplicationRuleSpec.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7482 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/NSPIntraEntityGroupRuleSpec.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7501 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/NSPTwoEnvIsolationRuleSpec.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    12799 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/NetworkSecurityPolicy.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7597 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/NetworkSecurityPolicyGetListResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7482 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/NetworkSecurityPolicyGetResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8625 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/NetworkSecurityPolicyImportEntity.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     5105 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/NetworkSecurityPolicyImportEntityType.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4941 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/NetworkSecurityPolicyImportEntityUpdateType.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7617 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/NetworkSecurityPolicyImportResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8180 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/NetworkSecurityPolicyMigrationCountSummary.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    12719 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/NetworkSecurityPolicyMigrationMetadata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7978 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/NetworkSecurityPolicyMigrationSubnetSummary.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     9019 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/NetworkSecurityPolicyMigrationSummary.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7017 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/NetworkSecurityPolicyMigrationSummaryFailures.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8757 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/NetworkSecurityPolicyMigrationTotalCountInfo.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7530 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/NetworkSecurityPolicyMigrationTypeCountInfo.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     9169 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/NetworkSecurityPolicyRule.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7532 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/NetworkSecurityPolicyRulesGetResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7504 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/NetworkSecurityPolicyTaskResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7973 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/OptionSpec.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4197 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/PolicyReferenceActionSpec.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6514 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/PolicyReferenceSpec.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4375 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/PolicyReferenceStateSpec.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4976 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/PolicyState.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4928 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/PolicyType.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     5192 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/RuleType.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8732 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/ServiceGroup.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7407 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/ServiceGroupGetResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7407 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/ServiceGroupListResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7561 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/ServiceGroupPolicyAssociationResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7337 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/ServiceGroupPolicyReference.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6554 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/ServiceGroupReferenceSpec.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7416 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/ServiceGroupTaskResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7603 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/TcpPortRangeSpec.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4646 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/Tier.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7333 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/TierGetResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4741 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/TierName.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4618 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/TierResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7355 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/TierUpdateResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7603 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/UdpPortRangeSpec.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:47.648552 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/error/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8916 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/error/AppMessage.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6635 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/error/ErrorResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8670 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/error/SchemaValidationError.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7297 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/error/SchemaValidationErrorMessage.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/error/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:47.649551 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/prism/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/prism/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:47.649551 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/prism/v4/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/prism/v4/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:47.649551 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/prism/v4/config/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6692 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/prism/v4/config/TaskReference.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/prism/v4/config/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    15936 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/rest.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:47.618551 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client.egg-info/
--rw-r--r--   0 circleci  (3434) circleci  (3434)    11633 2023-09-18 22:30:47.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client.egg-info/PKG-INFO
--rw-r--r--   0 circleci  (3434) circleci  (3434)    12383 2023-09-18 22:30:47.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client.egg-info/SOURCES.txt
--rw-r--r--   0 circleci  (3434) circleci  (3434)        1 2023-09-18 22:30:47.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client.egg-info/dependency_links.txt
--rw-r--r--   0 circleci  (3434) circleci  (3434)       78 2023-09-18 22:30:47.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client.egg-info/requires.txt
--rw-r--r--   0 circleci  (3434) circleci  (3434)       24 2023-09-18 22:30:47.000000 ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client.egg-info/top_level.txt
--rw-r--r--   0 circleci  (3434) circleci  (3434)       38 2023-09-18 22:30:47.650551 ntnx-microseg-py-client-4.0.1a1/setup.cfg
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1283 2023-09-18 22:30:38.000000 ntnx-microseg-py-client-4.0.1a1/setup.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:12:10.197785 ntnx_microseg_py_client-4.0.1b1/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    18137 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/LICENSE.txt
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    11773 2024-05-17 07:12:10.197785 ntnx_microseg_py_client-4.0.1b1/PKG-INFO
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    11330 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/README.md
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:12:10.167785 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    14551 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:12:10.169785 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/api/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      432 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/api/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    28249 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/api/address_groups_api.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    52384 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/api/directory_server_configs_api.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    44651 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/api/network_security_policies_api.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    28331 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/api/service_groups_api.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    48823 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/api_client.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2401 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/api_response.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    16645 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/configuration.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:12:10.169785 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:12:10.169785 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfcommon/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfcommon/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:12:10.170785 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfcommon/v1/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfcommon/v1/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:12:10.170785 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfcommon/v1/config/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6947 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfcommon/v1/config/KVPairvalue.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfcommon/v1/config/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:12:10.170785 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:12:10.170785 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:12:10.176785 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7090 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/CreateAddressGroupApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7153 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/CreateDirectoryServerConfigApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7125 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/CreateDsCategoryMappingApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7153 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/CreateNetworkSecurityPolicyApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7195 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/CreateNetworkSecurityPolicyExportApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7285 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/CreateNetworkSecurityPolicyImportApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7090 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/CreateServiceGroupApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7090 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/DeleteAddressGroupApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7153 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/DeleteDirectoryServerConfigApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7125 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/DeleteDsCategoryMappingApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7153 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/DeleteNetworkSecurityPolicyApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7090 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/DeleteServiceGroupApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7073 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/GetAddressGroupApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7154 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/GetDirectoryServerConfigApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7114 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/GetDsCategoryMappingApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7154 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/GetNetworkSecurityPolicyApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7073 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/GetServiceGroupApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7099 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/ListAddressGroupsApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7180 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/ListDirectoryServerConfigsApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7140 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/ListDsCategoryMappingsApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7219 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/ListNetworkSecurityPoliciesApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7216 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/ListNetworkSecurityPolicyRulesApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7099 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/ListServiceGroupsApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7204 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/NetworkSecurityPolicyRulespec.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7090 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/UpdateAddressGroupApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7153 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/UpdateDirectoryServerConfigApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7125 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/UpdateDsCategoryMappingApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7153 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/UpdateNetworkSecurityPolicyApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7090 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/UpdateServiceGroupApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:12:10.177785 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/error/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7011 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/error/ErrorResponseerror.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/error/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:12:10.177785 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/operation/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6970 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/operation/UpgradeJobspec.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/operation/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    14098 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:12:10.177785 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/common/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/common/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:12:10.177785 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/common/v1/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/common/v1/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:12:10.179785 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/common/v1/config/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6847 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/common/v1/config/FQDN.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7073 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/common/v1/config/Flag.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8386 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/common/v1/config/IPAddressOrFQDN.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7910 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/common/v1/config/IPv4Address.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8688 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/common/v1/config/IPv6Address.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7503 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/common/v1/config/KVPair.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8238 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/common/v1/config/Message.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5136 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/common/v1/config/MessageSeverity.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7722 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/common/v1/config/TenantAwareModel.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/common/v1/config/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:12:10.180785 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/common/v1/response/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7374 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/common/v1/response/ApiLink.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    10614 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/common/v1/response/ApiResponseMetadata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6102 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/common/v1/response/ExternalizableAbstractModel.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/common/v1/response/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:12:10.180785 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:12:10.181785 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:12:10.192785 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    10115 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/AdInfo.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5111 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/AdStatus.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     9057 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/AddressGroup.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5047 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/AllowType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    19382 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/ApplicationRuleSpec.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7603 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/CategoryMapping.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7803 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/CreateAddressGroupApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7876 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/CreateDirectoryServerConfigApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7841 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/CreateDsCategoryMappingApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7860 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/CreateNetworkSecurityPolicyApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7926 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/CreateNetworkSecurityPolicyExportApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8010 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/CreateNetworkSecurityPolicyImportApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7803 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/CreateServiceGroupApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7813 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/DeleteAddressGroupApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7886 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/DeleteDirectoryServerConfigApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7851 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/DeleteDsCategoryMappingApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7870 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/DeleteNetworkSecurityPolicyApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7813 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/DeleteServiceGroupApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     9788 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/DirectoryServerConfig.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7791 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/GetAddressGroupApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7873 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/GetDirectoryServerConfigApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7832 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/GetDsCategoryMappingApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7857 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/GetNetworkSecurityPolicyApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7791 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/GetServiceGroupApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7879 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/IPv4Range.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8551 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/IcmpTypeCodeSpec.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8309 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/ImportEntity.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5328 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/ImportEntityType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5143 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/ImportEntityUpdateType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5189 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/IntraEntityGroupRuleAction.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8207 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/IntraEntityGroupRuleSpec.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7797 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/ListAddressGroupsApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7879 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/ListDirectoryServerConfigsApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7838 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/ListDsCategoryMappingsApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7904 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/ListNetworkSecurityPoliciesApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7909 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/ListNetworkSecurityPolicyRulesApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7797 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/ListServiceGroupsApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5007 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/MatchEntity.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     4995 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/MatchField.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5165 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/MatchType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     9559 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/MatchingCriteria.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    14657 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/NetworkSecurityPolicy.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6858 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/NetworkSecurityPolicyRule.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5528 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/RuleType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5406 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/SecurityPolicyScope.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5341 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/SecurityPolicyState.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5294 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/SecurityPolicyType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    10664 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/ServiceGroup.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7973 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/TcpPortRangeSpec.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8183 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/TwoEnvIsolationRuleSpec.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7973 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/UdpPortRangeSpec.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7810 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/UpdateAddressGroupApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7883 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/UpdateDirectoryServerConfigApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7848 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/UpdateDsCategoryMappingApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7867 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/UpdateNetworkSecurityPolicyApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7810 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/UpdateServiceGroupApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:12:10.193785 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/error/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     9872 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/error/AppMessage.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7009 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/error/ErrorResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     9392 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/error/SchemaValidationError.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8100 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/error/SchemaValidationErrorMessage.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/error/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:12:10.196785 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/operation/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8000 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/operation/DryRunSpec.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7533 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/operation/DryRunSummary.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     9138 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/operation/PolicyCount.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7497 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/operation/PolicyCountByType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    13272 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/operation/PolicyMetadata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6231 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/operation/PolicyPreview.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     9354 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/operation/PolicyUpgradeSummary.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7460 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/operation/SecurityPolicyOptions.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5478 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/operation/SecurityPolicyType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8581 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/operation/SubnetUpgradeSummary.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8208 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/operation/TotalPolicyCount.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8439 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/operation/UpgradeJob.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8542 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/operation/UpgradeSpec.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/operation/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:12:10.196785 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/prism/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/prism/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:12:10.196785 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/prism/v4/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/prism/v4/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:12:10.196785 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/prism/v4/config/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7070 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/prism/v4/config/TaskReference.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/prism/v4/config/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    16559 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/rest.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:12:10.197785 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client.egg-info/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    11773 2024-05-17 07:12:10.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client.egg-info/PKG-INFO
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    11422 2024-05-17 07:12:10.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client.egg-info/SOURCES.txt
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        1 2024-05-17 07:12:10.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client.egg-info/dependency_links.txt
+-rw-r--r--   0 circleci  (3434) circleci  (3434)       91 2024-05-17 07:12:10.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client.egg-info/requires.txt
+-rw-r--r--   0 circleci  (3434) circleci  (3434)       24 2024-05-17 07:12:10.000000 ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client.egg-info/top_level.txt
+-rw-r--r--   0 circleci  (3434) circleci  (3434)       38 2024-05-17 07:12:10.197785 ntnx_microseg_py_client-4.0.1b1/setup.cfg
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1294 2024-05-17 07:12:04.000000 ntnx_microseg_py_client-4.0.1b1/setup.py
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/LICENSE.txt` & `ntnx_microseg_py_client-4.0.1b1/LICENSE.txt`

 * *Files identical despite different names*

### Comparing `ntnx-microseg-py-client-4.0.1a1/PKG-INFO` & `ntnx_microseg_py_client-4.0.1b1/PKG-INFO`

 * *Files 3% similar despite different names*

```diff
@@ -1,37 +1,37 @@
 Metadata-Version: 2.1
 Name: ntnx-microseg-py-client
-Version: 4.0.1a1
+Version: 4.0.1b1
 Summary: Nutanix Microseg Versioned APIs
 Home-page: 
 Author-email: sdk@nutanix.com
 Keywords: Nutanix,v4,SDK,Nutanix Microseg Versioned APIs
 Description-Content-Type: text/markdown
 License-File: LICENSE.txt
 Requires-Dist: urllib3~=1.26
 Requires-Dist: six~=1.16
-Requires-Dist: certifi==2020.4.5.1
+Requires-Dist: certifi<=2023.11.17,>=2020.4.5.1
 Requires-Dist: python-dateutil~=2.8
 Requires-Dist: pysocks~=1.7
 
 # Python Client For Nutanix Microseg Versioned APIs
 
 The Python client for Nutanix Microseg Versioned APIs is designed for Python client application developers offering them simple and flexible access to APIs that manage Network Security Policy configuration of Nutanix clusters.
 ## Features
 - Invoke Nutanix APIs with a simple interface.
 - Handle Authentication seamlessly.
 - Reduce boilerplate code implementation.
 - Use standard methods for installation.
 
 ## Version
-- API version: v4.0.a1
-- Package version: 4.0.1a1
+- API version: v4.0.b1
+- Package version: 4.0.1b1
 
 ## Requirements.
-Python 3.6, 3.7, and 3.8 are fully supported and tested.
+Python 3.6, 3.7, 3.8 and 3.9 are fully supported and tested.
 
 
 ## Installation & Usage
 
 ### Installing in a virtual environment
 [virtualenv](https://virtualenv.pypa.io/en/latest/) is a tool to create isolated Python environments. The basic problem it addresses is one of dependencies and versions, and indirectly permissions. virtualenv can help you install this client without needing system install permissions. It creates an environment that has its own installation directories without sharing libraries with other virtualenv environments or the system installation.
 
@@ -85,14 +85,15 @@
 | debug     | Runs the client in debug mode if specified                                       | No       | False        |
 | verify_ssl| Verify SSL certificate of cluster the client will connect to                     | No       | True         |
 | max_retry_attempts| Maximum number of retry attempts while connecting to the cluster         | No       | 5            |
 | backoff_factor| A backoff factor to apply between attempts after the second try.             | No       | 3            |
 | logger_file | File location to which debug logs are written to                               | No       | N/A          |
 | connect_timeout | Connection timeout in milliseconds for all operations                      | No       | 30000        |
 | read_timeout | Read timeout in milliseconds for all operations                               | No       | 30000        |
+| download_directory| Directory where downloaded files will be stored in                       | No       | Current Working Directory|
 
 
 ### Sample Configuration
 ```python
 config = Configuration()
 config.host = '10.19.50.27' # IPv4/IPv6 address or FQDN of the cluster
 config.port = 9440 # Port to which to connect to
@@ -145,61 +146,61 @@
 
 ### Invoking an operation
 ```python
 # Initialize the API
 address_groups_api_instance = AddressGroupsApi(api_client=client) # client configured in previous step
 extId = 'extId_example' # UUID.
 
-# Get a address group by UUID.
+# Get an Address Group by ExtID
 try:
-    api_response = address_groups_api_instance.get_address_group_by_ext_id(extId)
+    api_response = address_groups_api_instance.get_address_group_by_id(extId)
 except ApiException as e:
 ```
 
 ### Setting headers for individual operations
 Headers can be configured globally on the python client using the [method to set default headers](#additional-headers). However, sometimes headers need to be set on an individual operation basis. Nutanix APIs require that concurrent updates are protected using [ETag headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag).
 
 ```python
 # Initialize the API
 address_groups_api_instance = AddressGroupsApi(api_client=client) # client configured in previous step
 extId = 'extId_example' # UUID.
 
-# Get a address group by UUID.
+# Get an Address Group by ExtID
 try:
-    api_response = address_groups_api_instance.get_address_group_by_ext_id(extId)
+    api_response = address_groups_api_instance.get_address_group_by_id(extId)
 except ApiException as e:
 
 # Extract E-Tag Header
 etag_value = ApiClient.get_etag(api_response)
 
-# Updates a address group by UUID.
+# Update an Address Group
 try:
     # The body parameter in the following operation is received from the previous GET request's response which needs to be updated.
-    api_response = address_groups_api_instance.update_address_group_by_ext_id(body, extId, if_match=etag_value) # Use the extracted etag value
+    api_response = address_groups_api_instance.update_address_group_by_id(body, extId, if_match=etag_value) # Use the extracted etag value
 except ApiException as e:
 ```
 
 ### List Operations
 List Operations for Nutanix APIs support pagination, filtering, sorting and projections. The table below details the parameters that can be used to set the options for pagination etc.
 
 | Parameter | Description
 |-----------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
 | _page     | specifies the page number of the result set. Must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range will lead to no results being returned.|
 | _limit    | specifies the total number of records returned in the result set. Must be a positive integer between 0 and 100. Any number out of this range will lead to a validation error. If the limit is not provided a default value of 50 records will be returned in the result set|
 | _filter   | allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the [OData V4.01 URL](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part2-url-conventions.html#sec_SystemQueryOptionfilter) conventions. |
 | _orderby  | allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified the resources will be sorted in ascending order by default. For example, 'orderby=templateName desc' would get all templates sorted by templateName in desc order. |
-| _select   | allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the OData V4.01 URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e. *), then all properties on the matching resource will be returned. |
-| _expand   | allows clients to request related resources when a resource that satisfies a particular request is retrieved. Each expand item is evaluated relative to the entity containing the property being expanded. Other query options can be applied to an expanded property by appending a semicolon-separated list of query options, enclosed in parentheses, to the property name. Allowed system query options are $filter,$select, $orderby. |
+| _select   | allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the OData V4.01 URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e., *), then all properties on the matching resource will be returned. |
+| _expand   | allows clients to request related resources when a resource that satisfies a particular request is retrieved. Each expanded item is evaluated relative to the entity containing the property being expanded. Other query options can be applied to an expanded property by appending a semicolon-separated list of query options, enclosed in parentheses, to the property name. Permissible system query options are $filter,$select and $orderby. |
 
 ```python
 # Initialize the API
 address_groups_api_instance = AddressGroupsApi(api_client=client) # client configured in previous step
 extId = 'extId_example' # UUID.
 
-# Gets a list of address groups.
+# List all the Address Groups
 try:
     api_response = address_groups_api_instance.list_address_groups(
 	                   _page=page, # if page parameter is present
 	                   _limit=limit, # if limit parameter is present
 	                   _filter=_filter, # if filter parameter is present
 	                   _orderby=_orderby, # if orderby parameter is present
 	                   _select=select, # if select parameter is present
@@ -207,14 +208,14 @@
 except ApiException as e:
 
 ```
 The list of filterable and sortable fields with expansion keys can be found in the documentation [here](https://developers.nutanix.com/).
 
 ## API Reference
 
-This library has a full set of [API Reference Documentation](https://developers.nutanix.com/sdk-reference?namespace=microseg&version=v4.0.a1&language=python). This documentation is auto-generated, and the location may change.
+This library has a full set of [API Reference Documentation](https://developers.nutanix.com/sdk-reference?namespace=microseg&version=v4.0.b1&language=python). This documentation is auto-generated, and the location may change.
 
 ## License
 This library is licensed under Nutanix proprietary license. Full license text is available in [LICENSE](https://developers.nutanix.com/license).
 
 ## Contact us
 In case of issues please reach out to us at the [mailing list](mailto:sdk@nutanix.com)
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/README.md` & `ntnx_microseg_py_client-4.0.1b1/README.md`

 * *Files 3% similar despite different names*

```diff
@@ -4,19 +4,19 @@
 ## Features
 - Invoke Nutanix APIs with a simple interface.
 - Handle Authentication seamlessly.
 - Reduce boilerplate code implementation.
 - Use standard methods for installation.
 
 ## Version
-- API version: v4.0.a1
-- Package version: 4.0.1a1
+- API version: v4.0.b1
+- Package version: 4.0.1b1
 
 ## Requirements.
-Python 3.6, 3.7, and 3.8 are fully supported and tested.
+Python 3.6, 3.7, 3.8 and 3.9 are fully supported and tested.
 
 
 ## Installation & Usage
 
 ### Installing in a virtual environment
 [virtualenv](https://virtualenv.pypa.io/en/latest/) is a tool to create isolated Python environments. The basic problem it addresses is one of dependencies and versions, and indirectly permissions. virtualenv can help you install this client without needing system install permissions. It creates an environment that has its own installation directories without sharing libraries with other virtualenv environments or the system installation.
 
@@ -70,14 +70,15 @@
 | debug     | Runs the client in debug mode if specified                                       | No       | False        |
 | verify_ssl| Verify SSL certificate of cluster the client will connect to                     | No       | True         |
 | max_retry_attempts| Maximum number of retry attempts while connecting to the cluster         | No       | 5            |
 | backoff_factor| A backoff factor to apply between attempts after the second try.             | No       | 3            |
 | logger_file | File location to which debug logs are written to                               | No       | N/A          |
 | connect_timeout | Connection timeout in milliseconds for all operations                      | No       | 30000        |
 | read_timeout | Read timeout in milliseconds for all operations                               | No       | 30000        |
+| download_directory| Directory where downloaded files will be stored in                       | No       | Current Working Directory|
 
 
 ### Sample Configuration
 ```python
 config = Configuration()
 config.host = '10.19.50.27' # IPv4/IPv6 address or FQDN of the cluster
 config.port = 9440 # Port to which to connect to
@@ -130,61 +131,61 @@
 
 ### Invoking an operation
 ```python
 # Initialize the API
 address_groups_api_instance = AddressGroupsApi(api_client=client) # client configured in previous step
 extId = 'extId_example' # UUID.
 
-# Get a address group by UUID.
+# Get an Address Group by ExtID
 try:
-    api_response = address_groups_api_instance.get_address_group_by_ext_id(extId)
+    api_response = address_groups_api_instance.get_address_group_by_id(extId)
 except ApiException as e:
 ```
 
 ### Setting headers for individual operations
 Headers can be configured globally on the python client using the [method to set default headers](#additional-headers). However, sometimes headers need to be set on an individual operation basis. Nutanix APIs require that concurrent updates are protected using [ETag headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag).
 
 ```python
 # Initialize the API
 address_groups_api_instance = AddressGroupsApi(api_client=client) # client configured in previous step
 extId = 'extId_example' # UUID.
 
-# Get a address group by UUID.
+# Get an Address Group by ExtID
 try:
-    api_response = address_groups_api_instance.get_address_group_by_ext_id(extId)
+    api_response = address_groups_api_instance.get_address_group_by_id(extId)
 except ApiException as e:
 
 # Extract E-Tag Header
 etag_value = ApiClient.get_etag(api_response)
 
-# Updates a address group by UUID.
+# Update an Address Group
 try:
     # The body parameter in the following operation is received from the previous GET request's response which needs to be updated.
-    api_response = address_groups_api_instance.update_address_group_by_ext_id(body, extId, if_match=etag_value) # Use the extracted etag value
+    api_response = address_groups_api_instance.update_address_group_by_id(body, extId, if_match=etag_value) # Use the extracted etag value
 except ApiException as e:
 ```
 
 ### List Operations
 List Operations for Nutanix APIs support pagination, filtering, sorting and projections. The table below details the parameters that can be used to set the options for pagination etc.
 
 | Parameter | Description
 |-----------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
 | _page     | specifies the page number of the result set. Must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range will lead to no results being returned.|
 | _limit    | specifies the total number of records returned in the result set. Must be a positive integer between 0 and 100. Any number out of this range will lead to a validation error. If the limit is not provided a default value of 50 records will be returned in the result set|
 | _filter   | allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the [OData V4.01 URL](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part2-url-conventions.html#sec_SystemQueryOptionfilter) conventions. |
 | _orderby  | allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified the resources will be sorted in ascending order by default. For example, 'orderby=templateName desc' would get all templates sorted by templateName in desc order. |
-| _select   | allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the OData V4.01 URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e. *), then all properties on the matching resource will be returned. |
-| _expand   | allows clients to request related resources when a resource that satisfies a particular request is retrieved. Each expand item is evaluated relative to the entity containing the property being expanded. Other query options can be applied to an expanded property by appending a semicolon-separated list of query options, enclosed in parentheses, to the property name. Allowed system query options are $filter,$select, $orderby. |
+| _select   | allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the OData V4.01 URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e., *), then all properties on the matching resource will be returned. |
+| _expand   | allows clients to request related resources when a resource that satisfies a particular request is retrieved. Each expanded item is evaluated relative to the entity containing the property being expanded. Other query options can be applied to an expanded property by appending a semicolon-separated list of query options, enclosed in parentheses, to the property name. Permissible system query options are $filter,$select and $orderby. |
 
 ```python
 # Initialize the API
 address_groups_api_instance = AddressGroupsApi(api_client=client) # client configured in previous step
 extId = 'extId_example' # UUID.
 
-# Gets a list of address groups.
+# List all the Address Groups
 try:
     api_response = address_groups_api_instance.list_address_groups(
 	                   _page=page, # if page parameter is present
 	                   _limit=limit, # if limit parameter is present
 	                   _filter=_filter, # if filter parameter is present
 	                   _orderby=_orderby, # if orderby parameter is present
 	                   _select=select, # if select parameter is present
@@ -192,14 +193,14 @@
 except ApiException as e:
 
 ```
 The list of filterable and sortable fields with expansion keys can be found in the documentation [here](https://developers.nutanix.com/).
 
 ## API Reference
 
-This library has a full set of [API Reference Documentation](https://developers.nutanix.com/sdk-reference?namespace=microseg&version=v4.0.a1&language=python). This documentation is auto-generated, and the location may change.
+This library has a full set of [API Reference Documentation](https://developers.nutanix.com/sdk-reference?namespace=microseg&version=v4.0.b1&language=python). This documentation is auto-generated, and the location may change.
 
 ## License
 This library is licensed under Nutanix proprietary license. Full license text is available in [LICENSE](https://developers.nutanix.com/license).
 
 ## Contact us
 In case of issues please reach out to us at the [mailing list](mailto:sdk@nutanix.com)
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/__init__.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/__init__.py`

 * *Files 9% similar despite different names*

```diff
@@ -5,156 +5,141 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 from __future__ import absolute_import
 
 # import apis into sdk package
 from ntnx_microseg_py_client.api.address_groups_api import AddressGroupsApi
-from ntnx_microseg_py_client.api.directory_server_api import DirectoryServerApi
+from ntnx_microseg_py_client.api.directory_server_configs_api import DirectoryServerConfigsApi
 from ntnx_microseg_py_client.api.network_security_policies_api import NetworkSecurityPoliciesApi
 from ntnx_microseg_py_client.api.service_groups_api import ServiceGroupsApi
 # import ApiClient
 from ntnx_microseg_py_client.api_client import ApiClient
 from ntnx_microseg_py_client.configuration import Configuration
 # import models into sdk package
 from ntnx_microseg_py_client.models.OneOfcommon.v1.config.KVPairvalue import KVPairvalue
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.AddressGroupGetResponsedata import AddressGroupGetResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.AddressGroupListResponsedata import AddressGroupListResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.AddressGroupPolicyAssociationResponsedata import AddressGroupPolicyAssociationResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.AddressGroupTaskResponsedata import AddressGroupTaskResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.BannerGetResponsedata import BannerGetResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.ConfigMigrationPreviewGetResponsedata import ConfigMigrationPreviewGetResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.ConfigMigrationSummaryGetResponsedata import ConfigMigrationSummaryGetResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.DirectoryServerCreateResponsedata import DirectoryServerCreateResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.DirectoryServerDeleteResponsedata import DirectoryServerDeleteResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.DirectoryServerGetResponsedata import DirectoryServerGetResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.DirectoryServerListResponsedata import DirectoryServerListResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.DirectoryServerUpdateResponsedata import DirectoryServerUpdateResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.DsCategoryMappingCreateResponsedata import DsCategoryMappingCreateResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.DsCategoryMappingDeleteResponsedata import DsCategoryMappingDeleteResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.DsCategoryMappingGetResponsedata import DsCategoryMappingGetResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.DsCategoryMappingUpdateResponsedata import DsCategoryMappingUpdateResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.DsCategoryMappingsGetListResponsedata import DsCategoryMappingsGetListResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.MigrationConfigSpecspec import MigrationConfigSpecspec
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.MigrationConfigTaskResponsedata import MigrationConfigTaskResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.NetworkSecurityPolicyGetListResponsedata import NetworkSecurityPolicyGetListResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.NetworkSecurityPolicyGetResponsedata import NetworkSecurityPolicyGetResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.NetworkSecurityPolicyImportResponsedata import NetworkSecurityPolicyImportResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.NetworkSecurityPolicyRulesGetResponsedata import NetworkSecurityPolicyRulesGetResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.CreateAddressGroupApiResponsedata import CreateAddressGroupApiResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.CreateDirectoryServerConfigApiResponsedata import CreateDirectoryServerConfigApiResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.CreateDsCategoryMappingApiResponsedata import CreateDsCategoryMappingApiResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.CreateNetworkSecurityPolicyApiResponsedata import CreateNetworkSecurityPolicyApiResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.CreateNetworkSecurityPolicyExportApiResponsedata import CreateNetworkSecurityPolicyExportApiResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.CreateNetworkSecurityPolicyImportApiResponsedata import CreateNetworkSecurityPolicyImportApiResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.CreateServiceGroupApiResponsedata import CreateServiceGroupApiResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.DeleteAddressGroupApiResponsedata import DeleteAddressGroupApiResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.DeleteDirectoryServerConfigApiResponsedata import DeleteDirectoryServerConfigApiResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.DeleteDsCategoryMappingApiResponsedata import DeleteDsCategoryMappingApiResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.DeleteNetworkSecurityPolicyApiResponsedata import DeleteNetworkSecurityPolicyApiResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.DeleteServiceGroupApiResponsedata import DeleteServiceGroupApiResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.GetAddressGroupApiResponsedata import GetAddressGroupApiResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.GetDirectoryServerConfigApiResponsedata import GetDirectoryServerConfigApiResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.GetDsCategoryMappingApiResponsedata import GetDsCategoryMappingApiResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.GetNetworkSecurityPolicyApiResponsedata import GetNetworkSecurityPolicyApiResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.GetServiceGroupApiResponsedata import GetServiceGroupApiResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.ListAddressGroupsApiResponsedata import ListAddressGroupsApiResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.ListDirectoryServerConfigsApiResponsedata import ListDirectoryServerConfigsApiResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.ListDsCategoryMappingsApiResponsedata import ListDsCategoryMappingsApiResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.ListNetworkSecurityPoliciesApiResponsedata import ListNetworkSecurityPoliciesApiResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.ListNetworkSecurityPolicyRulesApiResponsedata import ListNetworkSecurityPolicyRulesApiResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.ListServiceGroupsApiResponsedata import ListServiceGroupsApiResponsedata
 from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.NetworkSecurityPolicyRulespec import NetworkSecurityPolicyRulespec
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.NetworkSecurityPolicyTaskResponsedata import NetworkSecurityPolicyTaskResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.ServiceGroupGetResponsedata import ServiceGroupGetResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.ServiceGroupListResponsedata import ServiceGroupListResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.ServiceGroupPolicyAssociationResponsedata import ServiceGroupPolicyAssociationResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.ServiceGroupTaskResponsedata import ServiceGroupTaskResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.TierGetResponsedata import TierGetResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.TierUpdateResponsedata import TierUpdateResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.UpdateAddressGroupApiResponsedata import UpdateAddressGroupApiResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.UpdateDirectoryServerConfigApiResponsedata import UpdateDirectoryServerConfigApiResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.UpdateDsCategoryMappingApiResponsedata import UpdateDsCategoryMappingApiResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.UpdateNetworkSecurityPolicyApiResponsedata import UpdateNetworkSecurityPolicyApiResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.UpdateServiceGroupApiResponsedata import UpdateServiceGroupApiResponsedata
 from ntnx_microseg_py_client.models.OneOfmicroseg.v4.error.ErrorResponseerror import ErrorResponseerror
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.operation.UpgradeJobspec import UpgradeJobspec
+from ntnx_microseg_py_client.models.common.v1.config.FQDN import FQDN
 from ntnx_microseg_py_client.models.common.v1.config.Flag import Flag
+from ntnx_microseg_py_client.models.common.v1.config.IPAddressOrFQDN import IPAddressOrFQDN
 from ntnx_microseg_py_client.models.common.v1.config.IPv4Address import IPv4Address
+from ntnx_microseg_py_client.models.common.v1.config.IPv6Address import IPv6Address
 from ntnx_microseg_py_client.models.common.v1.config.KVPair import KVPair
 from ntnx_microseg_py_client.models.common.v1.config.Message import Message
 from ntnx_microseg_py_client.models.common.v1.config.MessageSeverity import MessageSeverity
 from ntnx_microseg_py_client.models.common.v1.config.TenantAwareModel import TenantAwareModel
 from ntnx_microseg_py_client.models.common.v1.response.ApiLink import ApiLink
 from ntnx_microseg_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata
 from ntnx_microseg_py_client.models.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel
+from ntnx_microseg_py_client.models.microseg.v4.config.AdInfo import AdInfo
+from ntnx_microseg_py_client.models.microseg.v4.config.AdStatus import AdStatus
 from ntnx_microseg_py_client.models.microseg.v4.config.AddressGroup import AddressGroup
-from ntnx_microseg_py_client.models.microseg.v4.config.AddressGroupGetResponse import AddressGroupGetResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.AddressGroupListResponse import AddressGroupListResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.AddressGroupPolicyAssociationResponse import AddressGroupPolicyAssociationResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.AddressGroupPolicyReference import AddressGroupPolicyReference
-from ntnx_microseg_py_client.models.microseg.v4.config.AddressGroupReferenceSpec import AddressGroupReferenceSpec
-from ntnx_microseg_py_client.models.microseg.v4.config.AddressGroupTaskResponse import AddressGroupTaskResponse
 from ntnx_microseg_py_client.models.microseg.v4.config.AllowType import AllowType
-from ntnx_microseg_py_client.models.microseg.v4.config.BannerGetResponse import BannerGetResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.BannerResponse import BannerResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.BannerType import BannerType
+from ntnx_microseg_py_client.models.microseg.v4.config.ApplicationRuleSpec import ApplicationRuleSpec
 from ntnx_microseg_py_client.models.microseg.v4.config.CategoryMapping import CategoryMapping
-from ntnx_microseg_py_client.models.microseg.v4.config.CategoryMappingAdInfo import CategoryMappingAdInfo
-from ntnx_microseg_py_client.models.microseg.v4.config.CategoryMappingAdStatus import CategoryMappingAdStatus
-from ntnx_microseg_py_client.models.microseg.v4.config.CategoryMappingInfo import CategoryMappingInfo
-from ntnx_microseg_py_client.models.microseg.v4.config.ConfigMigrationPolicyOptions import ConfigMigrationPolicyOptions
-from ntnx_microseg_py_client.models.microseg.v4.config.ConfigMigrationPolicyType import ConfigMigrationPolicyType
-from ntnx_microseg_py_client.models.microseg.v4.config.ConfigMigrationPreviewGetResponse import ConfigMigrationPreviewGetResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.ConfigMigrationPreviewResponse import ConfigMigrationPreviewResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.ConfigMigrationSummary import ConfigMigrationSummary
-from ntnx_microseg_py_client.models.microseg.v4.config.ConfigMigrationSummaryGetResponse import ConfigMigrationSummaryGetResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.DirectoryServer import DirectoryServer
-from ntnx_microseg_py_client.models.microseg.v4.config.DirectoryServerCreateResponse import DirectoryServerCreateResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.DirectoryServerDeleteResponse import DirectoryServerDeleteResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.DirectoryServerGetResponse import DirectoryServerGetResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.DirectoryServerListResponse import DirectoryServerListResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.DirectoryServerUpdateResponse import DirectoryServerUpdateResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.DomainController import DomainController
-from ntnx_microseg_py_client.models.microseg.v4.config.DsCategoryMappingCreateResponse import DsCategoryMappingCreateResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.DsCategoryMappingDeleteResponse import DsCategoryMappingDeleteResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.DsCategoryMappingGetResponse import DsCategoryMappingGetResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.DsCategoryMappingUpdateResponse import DsCategoryMappingUpdateResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.DsCategoryMappingsGetListResponse import DsCategoryMappingsGetListResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.FileWrapper import FileWrapper
+from ntnx_microseg_py_client.models.microseg.v4.config.CreateAddressGroupApiResponse import CreateAddressGroupApiResponse
+from ntnx_microseg_py_client.models.microseg.v4.config.CreateDirectoryServerConfigApiResponse import CreateDirectoryServerConfigApiResponse
+from ntnx_microseg_py_client.models.microseg.v4.config.CreateDsCategoryMappingApiResponse import CreateDsCategoryMappingApiResponse
+from ntnx_microseg_py_client.models.microseg.v4.config.CreateNetworkSecurityPolicyApiResponse import CreateNetworkSecurityPolicyApiResponse
+from ntnx_microseg_py_client.models.microseg.v4.config.CreateNetworkSecurityPolicyExportApiResponse import CreateNetworkSecurityPolicyExportApiResponse
+from ntnx_microseg_py_client.models.microseg.v4.config.CreateNetworkSecurityPolicyImportApiResponse import CreateNetworkSecurityPolicyImportApiResponse
+from ntnx_microseg_py_client.models.microseg.v4.config.CreateServiceGroupApiResponse import CreateServiceGroupApiResponse
+from ntnx_microseg_py_client.models.microseg.v4.config.DeleteAddressGroupApiResponse import DeleteAddressGroupApiResponse
+from ntnx_microseg_py_client.models.microseg.v4.config.DeleteDirectoryServerConfigApiResponse import DeleteDirectoryServerConfigApiResponse
+from ntnx_microseg_py_client.models.microseg.v4.config.DeleteDsCategoryMappingApiResponse import DeleteDsCategoryMappingApiResponse
+from ntnx_microseg_py_client.models.microseg.v4.config.DeleteNetworkSecurityPolicyApiResponse import DeleteNetworkSecurityPolicyApiResponse
+from ntnx_microseg_py_client.models.microseg.v4.config.DeleteServiceGroupApiResponse import DeleteServiceGroupApiResponse
+from ntnx_microseg_py_client.models.microseg.v4.config.DirectoryServerConfig import DirectoryServerConfig
+from ntnx_microseg_py_client.models.microseg.v4.config.GetAddressGroupApiResponse import GetAddressGroupApiResponse
+from ntnx_microseg_py_client.models.microseg.v4.config.GetDirectoryServerConfigApiResponse import GetDirectoryServerConfigApiResponse
+from ntnx_microseg_py_client.models.microseg.v4.config.GetDsCategoryMappingApiResponse import GetDsCategoryMappingApiResponse
+from ntnx_microseg_py_client.models.microseg.v4.config.GetNetworkSecurityPolicyApiResponse import GetNetworkSecurityPolicyApiResponse
+from ntnx_microseg_py_client.models.microseg.v4.config.GetServiceGroupApiResponse import GetServiceGroupApiResponse
 from ntnx_microseg_py_client.models.microseg.v4.config.IPv4Range import IPv4Range
 from ntnx_microseg_py_client.models.microseg.v4.config.IcmpTypeCodeSpec import IcmpTypeCodeSpec
+from ntnx_microseg_py_client.models.microseg.v4.config.ImportEntity import ImportEntity
+from ntnx_microseg_py_client.models.microseg.v4.config.ImportEntityType import ImportEntityType
+from ntnx_microseg_py_client.models.microseg.v4.config.ImportEntityUpdateType import ImportEntityUpdateType
 from ntnx_microseg_py_client.models.microseg.v4.config.IntraEntityGroupRuleAction import IntraEntityGroupRuleAction
+from ntnx_microseg_py_client.models.microseg.v4.config.IntraEntityGroupRuleSpec import IntraEntityGroupRuleSpec
+from ntnx_microseg_py_client.models.microseg.v4.config.ListAddressGroupsApiResponse import ListAddressGroupsApiResponse
+from ntnx_microseg_py_client.models.microseg.v4.config.ListDirectoryServerConfigsApiResponse import ListDirectoryServerConfigsApiResponse
+from ntnx_microseg_py_client.models.microseg.v4.config.ListDsCategoryMappingsApiResponse import ListDsCategoryMappingsApiResponse
+from ntnx_microseg_py_client.models.microseg.v4.config.ListNetworkSecurityPoliciesApiResponse import ListNetworkSecurityPoliciesApiResponse
+from ntnx_microseg_py_client.models.microseg.v4.config.ListNetworkSecurityPolicyRulesApiResponse import ListNetworkSecurityPolicyRulesApiResponse
+from ntnx_microseg_py_client.models.microseg.v4.config.ListServiceGroupsApiResponse import ListServiceGroupsApiResponse
 from ntnx_microseg_py_client.models.microseg.v4.config.MatchEntity import MatchEntity
 from ntnx_microseg_py_client.models.microseg.v4.config.MatchField import MatchField
 from ntnx_microseg_py_client.models.microseg.v4.config.MatchType import MatchType
 from ntnx_microseg_py_client.models.microseg.v4.config.MatchingCriteria import MatchingCriteria
-from ntnx_microseg_py_client.models.microseg.v4.config.MigrationConfig import MigrationConfig
-from ntnx_microseg_py_client.models.microseg.v4.config.MigrationConfigSpec import MigrationConfigSpec
-from ntnx_microseg_py_client.models.microseg.v4.config.MigrationConfigTaskResponse import MigrationConfigTaskResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.MigrationSummary import MigrationSummary
-from ntnx_microseg_py_client.models.microseg.v4.config.NSPApplicationRuleSpec import NSPApplicationRuleSpec
-from ntnx_microseg_py_client.models.microseg.v4.config.NSPIntraEntityGroupRuleSpec import NSPIntraEntityGroupRuleSpec
-from ntnx_microseg_py_client.models.microseg.v4.config.NSPTwoEnvIsolationRuleSpec import NSPTwoEnvIsolationRuleSpec
 from ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicy import NetworkSecurityPolicy
-from ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyGetListResponse import NetworkSecurityPolicyGetListResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyGetResponse import NetworkSecurityPolicyGetResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyImportEntity import NetworkSecurityPolicyImportEntity
-from ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyImportEntityType import NetworkSecurityPolicyImportEntityType
-from ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyImportEntityUpdateType import NetworkSecurityPolicyImportEntityUpdateType
-from ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyImportResponse import NetworkSecurityPolicyImportResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyMigrationCountSummary import NetworkSecurityPolicyMigrationCountSummary
-from ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyMigrationMetadata import NetworkSecurityPolicyMigrationMetadata
-from ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyMigrationSubnetSummary import NetworkSecurityPolicyMigrationSubnetSummary
-from ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyMigrationSummary import NetworkSecurityPolicyMigrationSummary
-from ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyMigrationSummaryFailures import NetworkSecurityPolicyMigrationSummaryFailures
-from ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyMigrationTotalCountInfo import NetworkSecurityPolicyMigrationTotalCountInfo
-from ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyMigrationTypeCountInfo import NetworkSecurityPolicyMigrationTypeCountInfo
 from ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyRule import NetworkSecurityPolicyRule
-from ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyRulesGetResponse import NetworkSecurityPolicyRulesGetResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyTaskResponse import NetworkSecurityPolicyTaskResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.OptionSpec import OptionSpec
-from ntnx_microseg_py_client.models.microseg.v4.config.PolicyReferenceActionSpec import PolicyReferenceActionSpec
-from ntnx_microseg_py_client.models.microseg.v4.config.PolicyReferenceSpec import PolicyReferenceSpec
-from ntnx_microseg_py_client.models.microseg.v4.config.PolicyReferenceStateSpec import PolicyReferenceStateSpec
-from ntnx_microseg_py_client.models.microseg.v4.config.PolicyState import PolicyState
-from ntnx_microseg_py_client.models.microseg.v4.config.PolicyType import PolicyType
 from ntnx_microseg_py_client.models.microseg.v4.config.RuleType import RuleType
+from ntnx_microseg_py_client.models.microseg.v4.config.SecurityPolicyScope import SecurityPolicyScope
+from ntnx_microseg_py_client.models.microseg.v4.config.SecurityPolicyState import SecurityPolicyState
+from ntnx_microseg_py_client.models.microseg.v4.config.SecurityPolicyType import SecurityPolicyType as ConfigSecurityPolicyType
 from ntnx_microseg_py_client.models.microseg.v4.config.ServiceGroup import ServiceGroup
-from ntnx_microseg_py_client.models.microseg.v4.config.ServiceGroupGetResponse import ServiceGroupGetResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.ServiceGroupListResponse import ServiceGroupListResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.ServiceGroupPolicyAssociationResponse import ServiceGroupPolicyAssociationResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.ServiceGroupPolicyReference import ServiceGroupPolicyReference
-from ntnx_microseg_py_client.models.microseg.v4.config.ServiceGroupReferenceSpec import ServiceGroupReferenceSpec
-from ntnx_microseg_py_client.models.microseg.v4.config.ServiceGroupTaskResponse import ServiceGroupTaskResponse
 from ntnx_microseg_py_client.models.microseg.v4.config.TcpPortRangeSpec import TcpPortRangeSpec
-from ntnx_microseg_py_client.models.microseg.v4.config.Tier import Tier
-from ntnx_microseg_py_client.models.microseg.v4.config.TierGetResponse import TierGetResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.TierName import TierName
-from ntnx_microseg_py_client.models.microseg.v4.config.TierResponse import TierResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.TierUpdateResponse import TierUpdateResponse
+from ntnx_microseg_py_client.models.microseg.v4.config.TwoEnvIsolationRuleSpec import TwoEnvIsolationRuleSpec
 from ntnx_microseg_py_client.models.microseg.v4.config.UdpPortRangeSpec import UdpPortRangeSpec
+from ntnx_microseg_py_client.models.microseg.v4.config.UpdateAddressGroupApiResponse import UpdateAddressGroupApiResponse
+from ntnx_microseg_py_client.models.microseg.v4.config.UpdateDirectoryServerConfigApiResponse import UpdateDirectoryServerConfigApiResponse
+from ntnx_microseg_py_client.models.microseg.v4.config.UpdateDsCategoryMappingApiResponse import UpdateDsCategoryMappingApiResponse
+from ntnx_microseg_py_client.models.microseg.v4.config.UpdateNetworkSecurityPolicyApiResponse import UpdateNetworkSecurityPolicyApiResponse
+from ntnx_microseg_py_client.models.microseg.v4.config.UpdateServiceGroupApiResponse import UpdateServiceGroupApiResponse
 from ntnx_microseg_py_client.models.microseg.v4.error.AppMessage import AppMessage
 from ntnx_microseg_py_client.models.microseg.v4.error.ErrorResponse import ErrorResponse
 from ntnx_microseg_py_client.models.microseg.v4.error.SchemaValidationError import SchemaValidationError
 from ntnx_microseg_py_client.models.microseg.v4.error.SchemaValidationErrorMessage import SchemaValidationErrorMessage
+from ntnx_microseg_py_client.models.microseg.v4.operation.DryRunSpec import DryRunSpec
+from ntnx_microseg_py_client.models.microseg.v4.operation.DryRunSummary import DryRunSummary
+from ntnx_microseg_py_client.models.microseg.v4.operation.PolicyCount import PolicyCount
+from ntnx_microseg_py_client.models.microseg.v4.operation.PolicyCountByType import PolicyCountByType
+from ntnx_microseg_py_client.models.microseg.v4.operation.PolicyMetadata import PolicyMetadata
+from ntnx_microseg_py_client.models.microseg.v4.operation.PolicyPreview import PolicyPreview
+from ntnx_microseg_py_client.models.microseg.v4.operation.PolicyUpgradeSummary import PolicyUpgradeSummary
+from ntnx_microseg_py_client.models.microseg.v4.operation.SecurityPolicyOptions import SecurityPolicyOptions
+from ntnx_microseg_py_client.models.microseg.v4.operation.SecurityPolicyType import SecurityPolicyType as OperationSecurityPolicyType
+from ntnx_microseg_py_client.models.microseg.v4.operation.SubnetUpgradeSummary import SubnetUpgradeSummary
+from ntnx_microseg_py_client.models.microseg.v4.operation.TotalPolicyCount import TotalPolicyCount
+from ntnx_microseg_py_client.models.microseg.v4.operation.UpgradeJob import UpgradeJob
+from ntnx_microseg_py_client.models.microseg.v4.operation.UpgradeSpec import UpgradeSpec
 from ntnx_microseg_py_client.models.prism.v4.config.TaskReference import TaskReference
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/api/address_groups_api.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/api/address_groups_api.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,15 +3,15 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 from __future__ import absolute_import
 
 import re  # noqa: F401
@@ -29,40 +29,41 @@
     """  # noqa: E501
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
 
         self.api_client = api_client
-        self.__headers_to_skip = { 'authorization', 'cookie', 'ntnx-request-id', 'host', 'user-agent' }
+        self.__headers_to_skip = { 'authorization', 'cookie', 'host', 'user-agent' }
 
     def create_address_group(self, body, **kwargs):  # noqa: E501
-        """Creates a address group.
+        """Create an Address Group
 
         >>> response = api.create_address_group(body)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
         >>> thread = api.create_address_group(body, async_req=True)
         >>> result = thread.get()
 
         :param body: 
         :type body:
+
             :class:`~ntnx_microseg_py_client.models.microseg.v4.config.AddressGroup`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.AddressGroupTaskResponse`.
+        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.CreateAddressGroupApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'body' is set
         if ('body' not in params or params['body'] is None):
@@ -74,18 +75,22 @@
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
             ['application/json'])  # noqa: E501
+        if 'Content-Type' in params and params.get('Content-Type') is not None:
+            header_params['Content-Type'] = params.get('Content-Type')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -98,100 +103,106 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
+        # Authentication setting
+        auth_settings = ['basicAuthScheme']  # noqa: E501
+
         body_params = None
         if 'body' in params and params['body'] is not None:
             body_params = params['body']
 
-        # Authentication setting
-        auth_settings = ['basicAuthScheme']  # noqa: E501
-
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/address-groups', 'POST',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.AddressGroupTaskResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/address-groups', 'POST',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.AddressGroupTaskResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/address-groups', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.CreateAddressGroupApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/address-groups', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.CreateAddressGroupApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def delete_address_group_by_ext_id(self, extId, **kwargs):  # noqa: E501
-        """Deletes a address group by UUID.
+    def delete_address_group_by_id(self, extId, **kwargs):  # noqa: E501
+        """Delete an Address Group
 
-        >>> response = api.delete_address_group_by_ext_id(extId)
+        >>> response = api.delete_address_group_by_id(extId)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.delete_address_group_by_ext_id(extId, async_req=True)
+        >>> thread = api.delete_address_group_by_id(extId, async_req=True)
         >>> result = thread.get()
 
-        :param extId: Address Group UUID.
+        :param extId: Address group UUID.
         :type extId:
+
             :class:`str`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.AddressGroupTaskResponse`.
+        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.DeleteAddressGroupApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `delete_address_group_by_ext_id`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `delete_address_group_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -204,98 +215,104 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/address-groups/{extId}', 'DELETE',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.AddressGroupTaskResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/address-groups/{extId}', 'DELETE',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.AddressGroupTaskResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/address-groups/{extId}', 'DELETE',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.DeleteAddressGroupApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/address-groups/{extId}', 'DELETE',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.DeleteAddressGroupApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def get_address_group_by_ext_id(self, extId, **kwargs):  # noqa: E501
-        """Get a address group by UUID.
+    def get_address_group_by_id(self, extId, **kwargs):  # noqa: E501
+        """Get an Address Group by ExtID
 
-        >>> response = api.get_address_group_by_ext_id(extId)
+        >>> response = api.get_address_group_by_id(extId)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.get_address_group_by_ext_id(extId, async_req=True)
+        >>> thread = api.get_address_group_by_id(extId, async_req=True)
         >>> result = thread.get()
 
-        :param extId: Address Group UUID.
+        :param extId: Address group UUID.
         :type extId:
+
             :class:`str`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.AddressGroupGetResponse`.
+        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.GetAddressGroupApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `get_address_group_by_ext_id`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `get_address_group_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -308,86 +325,97 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/address-groups/{extId}', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.AddressGroupGetResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/address-groups/{extId}', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.AddressGroupGetResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/address-groups/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.GetAddressGroupApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/address-groups/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.GetAddressGroupApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def list_address_groups(self, _page=None, _limit=None, _filter=None, _orderby=None, **kwargs):  # noqa: E501
-        """Gets a list of address groups.
+    def list_address_groups(self, _page=None, _limit=None, _filter=None, _orderby=None, _select=None, **kwargs):  # noqa: E501
+        """List all the Address Groups
 
-        >>> response = api.list_address_groups((optional) _page, (optional) _limit, (optional) _filter, (optional) _orderby)
+        >>> response = api.list_address_groups((optional) _page, (optional) _limit, (optional) _filter, (optional) _orderby, (optional) _select)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
         >>> thread = api.list_address_groups(async_req=True)
         >>> result = thread.get()
 
-        :param _page: A URL query parameter that specifies the page number of the result set.  Must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range will lead to no results being returned. 
+        :param _page: A URL query parameter that specifies the page number of the result set. It must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range might lead to no results. 
         :type _page:
+
             :class:`int`
-        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided a default value of 50 records will be returned in the result set. 
+        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided, a default value of 50 records will be returned in the result set. 
         :type _limit:
+
             :class:`int`
-        :param _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the OData V4.01 URL conventions. For example, filter '$filter=name eq 'karbon-ntnx-1.0' would filter result on cluster name karbon-ntnx1.0, filter '$filter=startswith(name, 'C')' would filter on cluster name starting with C. The filter can be applied on the following fields: - description - extId - name 
+        :param _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the [OData V4.01](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html) URL conventions. For example, filter '$filter=name eq 'karbon-ntnx-1.0' would filter the result on cluster name 'karbon-ntnx1.0', filter '$filter=startswith(name, 'C')' would filter on cluster name starting with 'C'. The filter can be applied to the following fields: - createdBy - description - extId - name 
         :type _filter:
+
             :class:`str`
-        :param _orderby: A URL query parameter that allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified the resources will be sorted in ascending order by default. For example, '$orderby=templateName desc' would get all templates sorted by templateName in desc order. The orderby can be applied to the following fields: - description - extId - name 
+        :param _orderby: A URL query parameter that allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified, the resources will be sorted in ascending order by default. For example, '$orderby=templateName desc' would get all templates sorted by templateName in descending order. The orderby can be applied to the following fields: - description - extId - name 
         :type _orderby:
+
+            :class:`str`
+        :param _select: A URL query parameter that allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the [OData V4.01](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html) URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e., *), then all properties on the matching resource will be returned. - createdBy - description - extId - ipRanges - links - name - policyReferences - tenantId 
+        :type _select:
+
             :class:`str`
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.AddressGroupListResponse`.
+        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.ListAddressGroupsApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
 
         collection_formats = {}
@@ -399,133 +427,146 @@
             query_params.append(('$page', params['_page']))  # noqa: E501
         if '_limit' in params and params['_limit'] is not None:
             query_params.append(('$limit', params['_limit']))  # noqa: E501
         if '_filter' in params and params['_filter'] is not None:
             query_params.append(('$filter', params['_filter']))  # noqa: E501
         if '_orderby' in params and params['_orderby'] is not None:
             query_params.append(('$orderby', params['_orderby']))  # noqa: E501
+        if '_select' in params and params['_select'] is not None:
+            query_params.append(('$select', params['_select']))  # noqa: E501
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
-        all_params = set(['_page', '_limit', '_filter', '_orderby'])
+        all_params = set(['_page', '_limit', '_filter', '_orderby', '_select'])
         all_params.update(extra_params)
         for key, val in six.iteritems(params):
             if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                 if key.lower() == 'if_match'.lower():
                     key = 'If-Match'
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/address-groups', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.AddressGroupListResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/address-groups', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.AddressGroupListResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/address-groups', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.ListAddressGroupsApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/address-groups', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.ListAddressGroupsApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def update_address_group_by_ext_id(self, extId, body, **kwargs):  # noqa: E501
-        """Updates a address group by UUID.
+    def update_address_group_by_id(self, extId, body, **kwargs):  # noqa: E501
+        """Update an Address Group
 
-        >>> response = api.update_address_group_by_ext_id(extId, body)
+        >>> response = api.update_address_group_by_id(extId, body)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.update_address_group_by_ext_id(extId, body, async_req=True)
+        >>> thread = api.update_address_group_by_id(extId, body, async_req=True)
         >>> result = thread.get()
 
-        :param extId: Address Group UUID.
+        :param extId: Address group UUID.
         :type extId:
+
             :class:`str`, required
-        :param body: Updates a address group by UUID.
+        :param body: Updates the Address Group with the provided ExtID.
         :type body:
+
             :class:`~ntnx_microseg_py_client.models.microseg.v4.config.AddressGroup`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.AddressGroupTaskResponse`.
+        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.UpdateAddressGroupApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `update_address_group_by_ext_id`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `update_address_group_by_id`")  # noqa: E501
         # verify the required parameter 'body' is set
         if ('body' not in params or params['body'] is None):
-            raise ValueError("Missing the required parameter `body` when calling `update_address_group_by_ext_id`")  # noqa: E501
+            raise ValueError("Missing the required parameter `body` when calling `update_address_group_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
             ['application/json'])  # noqa: E501
+        if 'Content-Type' in params and params.get('Content-Type') is not None:
+            header_params['Content-Type'] = params.get('Content-Type')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -538,47 +579,50 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
+        # Authentication setting
+        auth_settings = ['basicAuthScheme']  # noqa: E501
+
         body_params = None
         if 'body' in params and params['body'] is not None:
             body_params = params['body']
 
-        # Authentication setting
-        auth_settings = ['basicAuthScheme']  # noqa: E501
-
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/address-groups/{extId}', 'PUT',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.AddressGroupTaskResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/address-groups/{extId}', 'PUT',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.AddressGroupTaskResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/address-groups/{extId}', 'PUT',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.UpdateAddressGroupApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/address-groups/{extId}', 'PUT',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.UpdateAddressGroupApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/api/directory_server_api.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/api/directory_server_configs_api.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,66 +3,67 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 from __future__ import absolute_import
 
 import re  # noqa: F401
 
 # python 2 and python 3 compatibility library
 import six
 
 from ntnx_microseg_py_client.api_client import ApiClient
 
 
-class DirectoryServerApi(object):
+class DirectoryServerConfigsApi(object):
     """IGNORE:
     NOTE: A placeholder for class level description
     IGNORE
     """  # noqa: E501
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
 
         self.api_client = api_client
-        self.__headers_to_skip = { 'authorization', 'cookie', 'ntnx-request-id', 'host', 'user-agent' }
+        self.__headers_to_skip = { 'authorization', 'cookie', 'host', 'user-agent' }
 
     def create_category_mapping(self, body, **kwargs):  # noqa: E501
-        """Create a mapping between a group in AD and a category/value.
+        """Create an AD Group and Category Mapping
 
         >>> response = api.create_category_mapping(body)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
         >>> thread = api.create_category_mapping(body, async_req=True)
         >>> result = thread.get()
 
-        :param body: Create a mapping between a group in AD and a category/value.
+        :param body: Creates the mapping between a group in Active Directory and the Category.
         :type body:
+
             :class:`~ntnx_microseg_py_client.models.microseg.v4.config.CategoryMapping`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.DsCategoryMappingCreateResponse`.
+        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.CreateDsCategoryMappingApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'body' is set
         if ('body' not in params or params['body'] is None):
@@ -74,18 +75,22 @@
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
             ['application/json'])  # noqa: E501
+        if 'Content-Type' in params and params.get('Content-Type') is not None:
+            header_params['Content-Type'] = params.get('Content-Type')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -98,102 +103,110 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
+        # Authentication setting
+        auth_settings = ['basicAuthScheme']  # noqa: E501
+
         body_params = None
         if 'body' in params and params['body'] is not None:
             body_params = params['body']
 
-        # Authentication setting
-        auth_settings = ['basicAuthScheme']  # noqa: E501
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/category-mappings', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.CreateDsCategoryMappingApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/category-mappings', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.CreateDsCategoryMappingApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/category-mappings', 'POST',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.DsCategoryMappingCreateResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/category-mappings', 'POST',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.DsCategoryMappingCreateResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+    def create_directory_server_config(self, body, **kwargs):  # noqa: E501
+        """Configure Directory Servers
 
-    def create_directory_server(self, body, **kwargs):  # noqa: E501
-        """Configures directory servers.
-
-        >>> response = api.create_directory_server(body)
+        >>> response = api.create_directory_server_config(body)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.create_directory_server(body, async_req=True)
+        >>> thread = api.create_directory_server_config(body, async_req=True)
         >>> result = thread.get()
 
-        :param body: Allows for configuring various aspects of identity categorization.
+        :param body: Configures various aspects of identity categorization.
         :type body:
-            :class:`~ntnx_microseg_py_client.models.microseg.v4.config.DirectoryServer`, required
+
+            :class:`~ntnx_microseg_py_client.models.microseg.v4.config.DirectoryServerConfig`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.DirectoryServerCreateResponse`.
+        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.CreateDirectoryServerConfigApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'body' is set
         if ('body' not in params or params['body'] is None):
-            raise ValueError("Missing the required parameter `body` when calling `create_directory_server`")  # noqa: E501
+            raise ValueError("Missing the required parameter `body` when calling `create_directory_server_config`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
             ['application/json'])  # noqa: E501
+        if 'Content-Type' in params and params.get('Content-Type') is not None:
+            header_params['Content-Type'] = params.get('Content-Type')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -206,100 +219,106 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
+        # Authentication setting
+        auth_settings = ['basicAuthScheme']  # noqa: E501
+
         body_params = None
         if 'body' in params and params['body'] is not None:
             body_params = params['body']
 
-        # Authentication setting
-        auth_settings = ['basicAuthScheme']  # noqa: E501
-
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/directory-servers', 'POST',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.DirectoryServerCreateResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/directory-servers', 'POST',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.DirectoryServerCreateResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/directory-server-configs', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.CreateDirectoryServerConfigApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/directory-server-configs', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.CreateDirectoryServerConfigApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def delete_directory_server(self, extId, **kwargs):  # noqa: E501
-        """Delete directory server by UUID.
+    def delete_directory_server_config_by_id(self, extId, **kwargs):  # noqa: E501
+        """Delete a Directory Server by ExtID
 
-        >>> response = api.delete_directory_server(extId)
+        >>> response = api.delete_directory_server_config_by_id(extId)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.delete_directory_server(extId, async_req=True)
+        >>> thread = api.delete_directory_server_config_by_id(extId, async_req=True)
         >>> result = thread.get()
 
         :param extId: UUID to specify Directory Server.
         :type extId:
+
             :class:`str`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.DirectoryServerDeleteResponse`.
+        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.DeleteDirectoryServerConfigApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `delete_directory_server`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `delete_directory_server_config_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -312,98 +331,104 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/directory-servers/{extId}', 'DELETE',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.DirectoryServerDeleteResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/directory-servers/{extId}', 'DELETE',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.DirectoryServerDeleteResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/directory-server-configs/{extId}', 'DELETE',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.DeleteDirectoryServerConfigApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/directory-server-configs/{extId}', 'DELETE',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.DeleteDirectoryServerConfigApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def delete_ds_category_mapping_by_ext_id(self, extId, **kwargs):  # noqa: E501
-        """Delete a directory configuration by UUID.
+    def delete_ds_category_mapping_by_id(self, extId, **kwargs):  # noqa: E501
+        """Delete a Directory Config by ExtID
 
-        >>> response = api.delete_ds_category_mapping_by_ext_id(extId)
+        >>> response = api.delete_ds_category_mapping_by_id(extId)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.delete_ds_category_mapping_by_ext_id(extId, async_req=True)
+        >>> thread = api.delete_ds_category_mapping_by_id(extId, async_req=True)
         >>> result = thread.get()
 
-        :param extId: Category mapping UUID.
+        :param extId: Category Mapping UUID.
         :type extId:
+
             :class:`str`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.DsCategoryMappingDeleteResponse`.
+        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.DeleteDsCategoryMappingApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `delete_ds_category_mapping_by_ext_id`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `delete_ds_category_mapping_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -416,98 +441,104 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/category-mappings/{extId}', 'DELETE',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.DsCategoryMappingDeleteResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/category-mappings/{extId}', 'DELETE',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.DsCategoryMappingDeleteResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/category-mappings/{extId}', 'DELETE',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.DeleteDsCategoryMappingApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/category-mappings/{extId}', 'DELETE',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.DeleteDsCategoryMappingApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def get_directory_server(self, extId, **kwargs):  # noqa: E501
-        """Gets directory server configuration.
+    def get_directory_server_config_by_id(self, extId, **kwargs):  # noqa: E501
+        """Get details of Directory Server by ExtID
 
-        >>> response = api.get_directory_server(extId)
+        >>> response = api.get_directory_server_config_by_id(extId)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.get_directory_server(extId, async_req=True)
+        >>> thread = api.get_directory_server_config_by_id(extId, async_req=True)
         >>> result = thread.get()
 
         :param extId: UUID to specify Directory Server.
         :type extId:
+
             :class:`str`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.DirectoryServerGetResponse`.
+        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.GetDirectoryServerConfigApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `get_directory_server`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `get_directory_server_config_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -520,98 +551,104 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/directory-servers/{extId}', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.DirectoryServerGetResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/directory-servers/{extId}', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.DirectoryServerGetResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
 
-    def get_ds_category_mapping_by_ext_id(self, extId, **kwargs):  # noqa: E501
-        """Gets a category to directory configuration information by UUID.
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/directory-server-configs/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.GetDirectoryServerConfigApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/directory-server-configs/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.GetDirectoryServerConfigApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-        >>> response = api.get_ds_category_mapping_by_ext_id(extId)
+    def get_ds_category_mapping_by_id(self, extId, **kwargs):  # noqa: E501
+        """Get a Category to Directory Config information by ExtID
+
+        >>> response = api.get_ds_category_mapping_by_id(extId)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.get_ds_category_mapping_by_ext_id(extId, async_req=True)
+        >>> thread = api.get_ds_category_mapping_by_id(extId, async_req=True)
         >>> result = thread.get()
 
-        :param extId: Category mapping UUID.
+        :param extId: Category Mapping UUID.
         :type extId:
+
             :class:`str`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.DsCategoryMappingGetResponse`.
+        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.GetDsCategoryMappingApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `get_ds_category_mapping_by_ext_id`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `get_ds_category_mapping_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -624,80 +661,89 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/category-mappings/{extId}', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.DsCategoryMappingGetResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/category-mappings/{extId}', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.DsCategoryMappingGetResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/category-mappings/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.GetDsCategoryMappingApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/category-mappings/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.GetDsCategoryMappingApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def list_category_mappings(self, _page=None, _limit=None, **kwargs):  # noqa: E501
-        """Identity Catgorization Category Mapping lists.
+    def list_category_mappings(self, _page=None, _limit=None, _select=None, **kwargs):  # noqa: E501
+        """List all the Directory Server Category Mappings
 
-        >>> response = api.list_category_mappings((optional) _page, (optional) _limit)
+        >>> response = api.list_category_mappings((optional) _page, (optional) _limit, (optional) _select)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
         >>> thread = api.list_category_mappings(async_req=True)
         >>> result = thread.get()
 
-        :param _page: A URL query parameter that specifies the page number of the result set.  Must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range will lead to no results being returned. 
+        :param _page: A URL query parameter that specifies the page number of the result set. It must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range might lead to no results. 
         :type _page:
+
             :class:`int`
-        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided a default value of 50 records will be returned in the result set. 
+        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided, a default value of 50 records will be returned in the result set. 
         :type _limit:
+
             :class:`int`
+        :param _select: A URL query parameter that allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the [OData V4.01](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html) URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e., *), then all properties on the matching resource will be returned. - adInfo/directoryServiceReference - adInfo/objectIdentifier - adInfo/objectPath - adInfo/status - categoryName - categoryValue - extId - links - name - tenantId 
+        :type _select:
+
+            :class:`str`
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.DsCategoryMappingsGetListResponse`.
+        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.ListDsCategoryMappingsApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
 
         collection_formats = {}
@@ -705,229 +751,253 @@
         path_params = {}
 
         query_params = []
         if '_page' in params and params['_page'] is not None:
             query_params.append(('$page', params['_page']))  # noqa: E501
         if '_limit' in params and params['_limit'] is not None:
             query_params.append(('$limit', params['_limit']))  # noqa: E501
+        if '_select' in params and params['_select'] is not None:
+            query_params.append(('$select', params['_select']))  # noqa: E501
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
-        all_params = set(['_page', '_limit'])
+        all_params = set(['_page', '_limit', '_select'])
         all_params.update(extra_params)
         for key, val in six.iteritems(params):
             if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                 if key.lower() == 'if_match'.lower():
                     key = 'If-Match'
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/category-mappings', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.DsCategoryMappingsGetListResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/category-mappings', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.DsCategoryMappingsGetListResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/category-mappings', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.ListDsCategoryMappingsApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/category-mappings', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.ListDsCategoryMappingsApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def list_directory_server(self, **kwargs):  # noqa: E501
-        """Lists directory servers.
+    def list_directory_server_configs(self, _select=None, **kwargs):  # noqa: E501
+        """List all the Directory Servers
 
-        >>> response = api.list_directory_server()
+        >>> response = api.list_directory_server_configs((optional) _select)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.list_directory_server(async_req=True)
+        >>> thread = api.list_directory_server_configs(async_req=True)
         >>> result = thread.get()
 
+        :param _select: A URL query parameter that allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the [OData V4.01](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html) URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e., *), then all properties on the matching resource will be returned. - directoryServiceReference - domainControllers - extId - isDefaultCategoryEnabled - links - matchingCriterias - shouldKeepDefaultCategoryOnLogin - tenantId 
+        :type _select:
+
+            :class:`str`
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.DirectoryServerListResponse`.
+        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.ListDirectoryServerConfigsApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
+        if '_select' in params and params['_select'] is not None:
+            query_params.append(('$select', params['_select']))  # noqa: E501
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
-        all_params = set([])
+        all_params = set(['_select'])
         all_params.update(extra_params)
         for key, val in six.iteritems(params):
             if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                 if key.lower() == 'if_match'.lower():
                     key = 'If-Match'
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/directory-servers', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.DirectoryServerListResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/directory-servers', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.DirectoryServerListResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/directory-server-configs', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.ListDirectoryServerConfigsApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/directory-server-configs', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.ListDirectoryServerConfigsApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def update_directory_server(self, extId, body, **kwargs):  # noqa: E501
-        """Update directory server by UUID.
+    def update_directory_server_config_by_id(self, extId, body, **kwargs):  # noqa: E501
+        """Update a Directory Server by ExtID
 
-        >>> response = api.update_directory_server(extId, body)
+        >>> response = api.update_directory_server_config_by_id(extId, body)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.update_directory_server(extId, body, async_req=True)
+        >>> thread = api.update_directory_server_config_by_id(extId, body, async_req=True)
         >>> result = thread.get()
 
         :param extId: UUID to specify Directory Server.
         :type extId:
+
             :class:`str`, required
-        :param body: Update directory server by UUID.
+        :param body: Updates the Directory Server Config with the provided ExtID.
         :type body:
-            :class:`~ntnx_microseg_py_client.models.microseg.v4.config.DirectoryServer`, required
+
+            :class:`~ntnx_microseg_py_client.models.microseg.v4.config.DirectoryServerConfig`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.DirectoryServerUpdateResponse`.
+        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.UpdateDirectoryServerConfigApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `update_directory_server`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `update_directory_server_config_by_id`")  # noqa: E501
         # verify the required parameter 'body' is set
         if ('body' not in params or params['body'] is None):
-            raise ValueError("Missing the required parameter `body` when calling `update_directory_server`")  # noqa: E501
+            raise ValueError("Missing the required parameter `body` when calling `update_directory_server_config_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
             ['application/json'])  # noqa: E501
+        if 'Content-Type' in params and params.get('Content-Type') is not None:
+            header_params['Content-Type'] = params.get('Content-Type')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -940,110 +1010,119 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
+        # Authentication setting
+        auth_settings = ['basicAuthScheme']  # noqa: E501
+
         body_params = None
         if 'body' in params and params['body'] is not None:
             body_params = params['body']
 
-        # Authentication setting
-        auth_settings = ['basicAuthScheme']  # noqa: E501
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/directory-server-configs/{extId}', 'PUT',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.UpdateDirectoryServerConfigApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/directory-server-configs/{extId}', 'PUT',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.UpdateDirectoryServerConfigApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/directory-servers/{extId}', 'PUT',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.DirectoryServerUpdateResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/directory-servers/{extId}', 'PUT',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.DirectoryServerUpdateResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+    def update_ds_category_mapping_by_id(self, extId, body, **kwargs):  # noqa: E501
+        """Update a Category to Directory Config mapping by ExtID
 
-    def update_ds_category_mapping_by_ext_id(self, extId, body, **kwargs):  # noqa: E501
-        """Update a category to directory configuration mapping information by UUID.
-
-        >>> response = api.update_ds_category_mapping_by_ext_id(extId, body)
+        >>> response = api.update_ds_category_mapping_by_id(extId, body)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.update_ds_category_mapping_by_ext_id(extId, body, async_req=True)
+        >>> thread = api.update_ds_category_mapping_by_id(extId, body, async_req=True)
         >>> result = thread.get()
 
-        :param extId: Category mapping UUID.
+        :param extId: Category Mapping UUID.
         :type extId:
+
             :class:`str`, required
-        :param body: Update a category to directory configuration mapping information by UUID.
+        :param body: Updates the category to directory configuration mapping information with the provided ExtID.
         :type body:
+
             :class:`~ntnx_microseg_py_client.models.microseg.v4.config.CategoryMapping`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.DsCategoryMappingUpdateResponse`.
+        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.UpdateDsCategoryMappingApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `update_ds_category_mapping_by_ext_id`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `update_ds_category_mapping_by_id`")  # noqa: E501
         # verify the required parameter 'body' is set
         if ('body' not in params or params['body'] is None):
-            raise ValueError("Missing the required parameter `body` when calling `update_ds_category_mapping_by_ext_id`")  # noqa: E501
+            raise ValueError("Missing the required parameter `body` when calling `update_ds_category_mapping_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
             ['application/json'])  # noqa: E501
+        if 'Content-Type' in params and params.get('Content-Type') is not None:
+            header_params['Content-Type'] = params.get('Content-Type')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -1056,47 +1135,50 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
+        # Authentication setting
+        auth_settings = ['basicAuthScheme']  # noqa: E501
+
         body_params = None
         if 'body' in params and params['body'] is not None:
             body_params = params['body']
 
-        # Authentication setting
-        auth_settings = ['basicAuthScheme']  # noqa: E501
-
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/category-mappings/{extId}', 'PUT',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.DsCategoryMappingUpdateResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/category-mappings/{extId}', 'PUT',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.DsCategoryMappingUpdateResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/category-mappings/{extId}', 'PUT',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.UpdateDsCategoryMappingApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/category-mappings/{extId}', 'PUT',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.UpdateDsCategoryMappingApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/api/network_security_policies_api.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/api/network_security_policies_api.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 from __future__ import absolute_import
 
 import re  # noqa: F401
 
 # python 2 and python 3 compatibility library
 import six
+from pathlib import Path
 
 from ntnx_microseg_py_client.api_client import ApiClient
 
 
 class NetworkSecurityPoliciesApi(object):
     """IGNORE:
     NOTE: A placeholder for class level description
@@ -29,265 +30,306 @@
     """  # noqa: E501
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
 
         self.api_client = api_client
-        self.__headers_to_skip = { 'authorization', 'cookie', 'ntnx-request-id', 'host', 'user-agent' }
+        self.__headers_to_skip = { 'authorization', 'cookie', 'host', 'user-agent' }
 
-    def create_network_security_policy(self, body, **kwargs):  # noqa: E501
-        """Creates a network security policy.
+    def apply_network_security_policy_import(self, path, **kwargs):  # noqa: E501
+        """Import Network Security Policies
 
-        >>> response = api.create_network_security_policy(body)
+        >>> response = api.apply_network_security_policy_import(path)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.create_network_security_policy(body, async_req=True)
+        >>> thread = api.apply_network_security_policy_import(path, async_req=True)
         >>> result = thread.get()
 
-        :param body: 
-        :type body:
-            :class:`~ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicy`, required
+        :param path: 
+        :type path:
+
+            :class:`~pathlib.Path`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyTaskResponse`.
+        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.CreateNetworkSecurityPolicyImportApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
-        # verify the required parameter 'body' is set
-        if ('body' not in params or params['body'] is None):
-            raise ValueError("Missing the required parameter `body` when calling `create_network_security_policy`")  # noqa: E501
+        # verify the required parameter 'path' is set
+        if ('path' not in params or params['path'] is None):
+            raise ValueError("Missing the required parameter `path` when calling `apply_network_security_policy_import`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+            ['application/octet-stream'])  # noqa: E501
+        if 'Content-Type' in params and params.get('Content-Type') is not None:
+            header_params['Content-Type'] = params.get('Content-Type')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
-        all_params = set(['body'])
+        all_params = set(['path'])
         all_params.update(extra_params)
         for key, val in six.iteritems(params):
             if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                 if key.lower() == 'if_match'.lower():
                     key = 'If-Match'
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params and params['body'] is not None:
-            body_params = params['body']
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/policies', 'POST',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.NetworkSecurityPolicyTaskResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/policies', 'POST',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.NetworkSecurityPolicyTaskResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+        if 'path' in params and params['path'] is not None:
+            body_params = params['path']
+            filepath = params['path']
+            if not isinstance(filepath, Path) or not filepath.is_file():
+                raise ValueError("The required parameter `path` is not a valid Path file when calling `apply_network_security_policy_import`")  # noqa: E501
+
+            header_params['Content-Length'] = filepath.stat().st_size
+            if 'Content-Disposition' not in header_params:
+                header_params['Content-Disposition'] = 'attachment; filename="' + filepath.name + '"'
+
+            body_params = filepath.open(mode='rb')
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/policies/$actions/import', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.CreateNetworkSecurityPolicyImportApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/policies/$actions/import', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.CreateNetworkSecurityPolicyImportApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            body_params.close()
+            
 
-    def create_network_security_policy_export(self, **kwargs):  # noqa: E501
-        """Export all network security policies to save and for subsequent import.
+    def create_network_security_policy(self, body, **kwargs):  # noqa: E501
+        """Create a Network Security Policy
 
-        >>> response = api.create_network_security_policy_export()
+        >>> response = api.create_network_security_policy(body)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.create_network_security_policy_export(async_req=True)
+        >>> thread = api.create_network_security_policy(body, async_req=True)
         >>> result = thread.get()
 
+        :param body: 
+        :type body:
+
+            :class:`~ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicy`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyTaskResponse`.
+        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.CreateNetworkSecurityPolicyApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
+        # verify the required parameter 'body' is set
+        if ('body' not in params or params['body'] is None):
+            raise ValueError("Missing the required parameter `body` when calling `create_network_security_policy`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
+
+        # HTTP header `Content-Type`
+        header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
+            ['application/json'])  # noqa: E501
+        if 'Content-Type' in params and params.get('Content-Type') is not None:
+            header_params['Content-Type'] = params.get('Content-Type')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
-        all_params = set([])
+        all_params = set(['body'])
         all_params.update(extra_params)
         for key, val in six.iteritems(params):
             if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                 if key.lower() == 'if_match'.lower():
                     key = 'If-Match'
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/policies/$actions/export', 'POST',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.NetworkSecurityPolicyTaskResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/policies/$actions/export', 'POST',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.NetworkSecurityPolicyTaskResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+        if 'body' in params and params['body'] is not None:
+            body_params = params['body']
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/policies', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.CreateNetworkSecurityPolicyApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/policies', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.CreateNetworkSecurityPolicyApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def delete_network_security_policy_by_ext_id(self, extId, **kwargs):  # noqa: E501
-        """Deletes a network security policy by UUID.
+    def delete_network_security_policy_by_id(self, extId, **kwargs):  # noqa: E501
+        """Delete a Network Security Policy by ExtID
 
-        >>> response = api.delete_network_security_policy_by_ext_id(extId)
+        >>> response = api.delete_network_security_policy_by_id(extId)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.delete_network_security_policy_by_ext_id(extId, async_req=True)
+        >>> thread = api.delete_network_security_policy_by_id(extId, async_req=True)
         >>> result = thread.get()
 
         :param extId: Network security policy UUID.
         :type extId:
+
             :class:`str`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyTaskResponse`.
+        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.DeleteNetworkSecurityPolicyApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `delete_network_security_policy_by_ext_id`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `delete_network_security_policy_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -300,555 +342,581 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/policies/{extId}', 'DELETE',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.NetworkSecurityPolicyTaskResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/policies/{extId}', 'DELETE',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.NetworkSecurityPolicyTaskResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/policies/{extId}', 'DELETE',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.DeleteNetworkSecurityPolicyApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/policies/{extId}', 'DELETE',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.DeleteNetworkSecurityPolicyApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def get_network_security_policy_by_ext_id(self, extId, **kwargs):  # noqa: E501
-        """Gets a network security policy by UUID.
+    def export_network_security_policy(self, **kwargs):  # noqa: E501
+        """Export Network Security Policies
 
-        >>> response = api.get_network_security_policy_by_ext_id(extId)
+        >>> response = api.export_network_security_policy()
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.get_network_security_policy_by_ext_id(extId, async_req=True)
+        >>> thread = api.export_network_security_policy(async_req=True)
         >>> result = thread.get()
 
-        :param extId: Network security policy UUID.
-        :type extId:
-            :class:`str`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyGetResponse`.
+        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.CreateNetworkSecurityPolicyExportApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
-        # verify the required parameter 'extId' is set
-        if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `get_network_security_policy_by_ext_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'extId' in params and params['extId'] is not None:
-            path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
-        all_params = set(['extId'])
+        all_params = set([])
         all_params.update(extra_params)
         for key, val in six.iteritems(params):
             if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                 if key.lower() == 'if_match'.lower():
                     key = 'If-Match'
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/policies/{extId}', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.NetworkSecurityPolicyGetResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/policies/{extId}', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.NetworkSecurityPolicyGetResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/policies/$actions/prepare-export', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.CreateNetworkSecurityPolicyExportApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/policies/$actions/prepare-export', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.CreateNetworkSecurityPolicyExportApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def get_network_security_policy_list(self, _page=None, _limit=None, _filter=None, _orderby=None, _select=None, **kwargs):  # noqa: E501
-        """Gets a list of network security policies.
+    def get_network_security_policy_by_id(self, extId, **kwargs):  # noqa: E501
+        """Get a Network Security Policy by ExtID
 
-        >>> response = api.get_network_security_policy_list((optional) _page, (optional) _limit, (optional) _filter, (optional) _orderby, (optional) _select)
+        >>> response = api.get_network_security_policy_by_id(extId)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.get_network_security_policy_list(async_req=True)
+        >>> thread = api.get_network_security_policy_by_id(extId, async_req=True)
         >>> result = thread.get()
 
-        :param _page: A URL query parameter that specifies the page number of the result set.  Must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range will lead to no results being returned. 
-        :type _page:
-            :class:`int`
-        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided a default value of 50 records will be returned in the result set. 
-        :type _limit:
-            :class:`int`
-        :param _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the OData V4.01 URL conventions. For example, filter '$filter=name eq 'karbon-ntnx-1.0' would filter result on cluster name karbon-ntnx1.0, filter '$filter=startswith(name, 'C')' would filter on cluster name starting with C. The filter can be applied on the following fields: - description - extId - isHitlogEnabled - isIpv6TrafficAllowed - isSystemDefined - name - securedGroups - state - type - vpcExtId 
-        :type _filter:
-            :class:`str`
-        :param _orderby: A URL query parameter that allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified the resources will be sorted in ascending order by default. For example, '$orderby=templateName desc' would get all templates sorted by templateName in desc order. The orderby can be applied to the following fields: - creationTime - description - extId - lastUpdateTime - name - state - type 
-        :type _orderby:
-            :class:`str`
-        :param _select: A URL query parameter that allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the OData V4.01 URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e. *), then all properties on the matching resource will be returned. - creationTime - description - extId - isHitlogEnabled - isIpv6TrafficAllowed - isSystemDefined - lastUpdateTime - links - name - rules - securedGroups - state - tenantId - type - vpcExtId 
-        :type _select:
-            :class:`str`
+        :param extId: Network security policy UUID.
+        :type extId:
+
+            :class:`str`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyGetListResponse`.
+        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.GetNetworkSecurityPolicyApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
+        # verify the required parameter 'extId' is set
+        if ('extId' not in params or params['extId'] is None):
+            raise ValueError("Missing the required parameter `extId` when calling `get_network_security_policy_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
+        if 'extId' in params and params['extId'] is not None:
+            path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
-        if '_page' in params and params['_page'] is not None:
-            query_params.append(('$page', params['_page']))  # noqa: E501
-        if '_limit' in params and params['_limit'] is not None:
-            query_params.append(('$limit', params['_limit']))  # noqa: E501
-        if '_filter' in params and params['_filter'] is not None:
-            query_params.append(('$filter', params['_filter']))  # noqa: E501
-        if '_orderby' in params and params['_orderby'] is not None:
-            query_params.append(('$orderby', params['_orderby']))  # noqa: E501
-        if '_select' in params and params['_select'] is not None:
-            query_params.append(('$select', params['_select']))  # noqa: E501
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
-            ['application/json', 'application/octet-stream'])  # noqa: E501
+            ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
-        all_params = set(['_page', '_limit', '_filter', '_orderby', '_select'])
+        all_params = set(['extId'])
         all_params.update(extra_params)
         for key, val in six.iteritems(params):
             if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                 if key.lower() == 'if_match'.lower():
                     key = 'If-Match'
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/policies', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.NetworkSecurityPolicyGetListResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/policies', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.NetworkSecurityPolicyGetListResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
 
-    def get_network_security_policy_rules(self, extId, _page=None, _limit=None, **kwargs):  # noqa: E501
-        """Get a list of network security policy rules by policy UUID.
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/policies/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.GetNetworkSecurityPolicyApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/policies/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.GetNetworkSecurityPolicyApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-        >>> response = api.get_network_security_policy_rules(extId, (optional) _page, (optional) _limit)
+    def list_network_security_policies(self, _page=None, _limit=None, _filter=None, _orderby=None, _select=None, **kwargs):  # noqa: E501
+        """List all the Network Security Policies
+
+        >>> response = api.list_network_security_policies((optional) _page, (optional) _limit, (optional) _filter, (optional) _orderby, (optional) _select)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.get_network_security_policy_rules(extId, async_req=True)
+        >>> thread = api.list_network_security_policies(async_req=True)
         >>> result = thread.get()
 
-        :param extId: Network security policy UUID.
-        :type extId:
-            :class:`str`, required
-        :param _page: A URL query parameter that specifies the page number of the result set.  Must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range will lead to no results being returned. 
+        :param _page: A URL query parameter that specifies the page number of the result set. It must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range might lead to no results. 
         :type _page:
+
             :class:`int`
-        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided a default value of 50 records will be returned in the result set. 
+        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided, a default value of 50 records will be returned in the result set. 
         :type _limit:
+
             :class:`int`
+        :param _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the [OData V4.01](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html) URL conventions. For example, filter '$filter=name eq 'karbon-ntnx-1.0' would filter the result on cluster name 'karbon-ntnx1.0', filter '$filter=startswith(name, 'C')' would filter on cluster name starting with 'C'. The filter can be applied to the following fields: - createdBy - description - extId - isHitlogEnabled - isIpv6TrafficAllowed - isSystemDefined - name - securedGroups - state - type - vpcReferences 
+        :type _filter:
+
+            :class:`str`
+        :param _orderby: A URL query parameter that allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified, the resources will be sorted in ascending order by default. For example, '$orderby=templateName desc' would get all templates sorted by templateName in descending order. The orderby can be applied to the following fields: - creationTime - description - extId - lastUpdateTime - name - state - type 
+        :type _orderby:
+
+            :class:`str`
+        :param _select: A URL query parameter that allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the [OData V4.01](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html) URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e., *), then all properties on the matching resource will be returned. - createdBy - creationTime - description - extId - isHitlogEnabled - isIpv6TrafficAllowed - isSystemDefined - lastUpdateTime - links - name - rules - scope - securedGroups - state - tenantId - type - vpcReferences 
+        :type _select:
+
+            :class:`str`
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyRulesGetResponse`.
+        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.ListNetworkSecurityPoliciesApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
-        # verify the required parameter 'extId' is set
-        if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `get_network_security_policy_rules`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'extId' in params and params['extId'] is not None:
-            path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
         if '_page' in params and params['_page'] is not None:
             query_params.append(('$page', params['_page']))  # noqa: E501
         if '_limit' in params and params['_limit'] is not None:
             query_params.append(('$limit', params['_limit']))  # noqa: E501
+        if '_filter' in params and params['_filter'] is not None:
+            query_params.append(('$filter', params['_filter']))  # noqa: E501
+        if '_orderby' in params and params['_orderby'] is not None:
+            query_params.append(('$orderby', params['_orderby']))  # noqa: E501
+        if '_select' in params and params['_select'] is not None:
+            query_params.append(('$select', params['_select']))  # noqa: E501
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
-            ['application/json'])  # noqa: E501
+            ['application/json', 'application/octet-stream'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
-        all_params = set(['extId', '_page', '_limit'])
+        all_params = set(['_page', '_limit', '_filter', '_orderby', '_select'])
         all_params.update(extra_params)
         for key, val in six.iteritems(params):
             if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                 if key.lower() == 'if_match'.lower():
                     key = 'If-Match'
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/policies/{extId}/rules', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.NetworkSecurityPolicyRulesGetResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/policies/{extId}/rules', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.NetworkSecurityPolicyRulesGetResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/policies', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.ListNetworkSecurityPoliciesApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/policies', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.ListNetworkSecurityPoliciesApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def set_network_security_policy_import_apply(self, body, **kwargs):  # noqa: E501
-        """Imports all the network security rules specified by the data.
+    def list_network_security_policy_rules(self, extId, _page=None, _limit=None, **kwargs):  # noqa: E501
+        """List all the Network Security Policy rules by policy ExtID
 
-        >>> response = api.set_network_security_policy_import_apply(body)
+        >>> response = api.list_network_security_policy_rules(extId, (optional) _page, (optional) _limit)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.set_network_security_policy_import_apply(body, async_req=True)
+        >>> thread = api.list_network_security_policy_rules(extId, async_req=True)
         >>> result = thread.get()
 
-        :param body: 
-        :type body:
-            :class:`~ntnx_microseg_py_client.models.Object`, required
+        :param extId: Network security policy UUID.
+        :type extId:
+
+            :class:`str`, required
+        :param _page: A URL query parameter that specifies the page number of the result set. It must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range might lead to no results. 
+        :type _page:
+
+            :class:`int`
+        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided, a default value of 50 records will be returned in the result set. 
+        :type _limit:
+
+            :class:`int`
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyImportResponse`.
+        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.ListNetworkSecurityPolicyRulesApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
-        # verify the required parameter 'body' is set
-        if ('body' not in params or params['body'] is None):
-            raise ValueError("Missing the required parameter `body` when calling `set_network_security_policy_import_apply`")  # noqa: E501
+        # verify the required parameter 'extId' is set
+        if ('extId' not in params or params['extId'] is None):
+            raise ValueError("Missing the required parameter `extId` when calling `list_network_security_policy_rules`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
+        if 'extId' in params and params['extId'] is not None:
+            path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
+        if '_page' in params and params['_page'] is not None:
+            query_params.append(('$page', params['_page']))  # noqa: E501
+        if '_limit' in params and params['_limit'] is not None:
+            query_params.append(('$limit', params['_limit']))  # noqa: E501
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
-
-        # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
-            ['application/octet-stream'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
-        all_params = set(['body'])
+        all_params = set(['extId', '_page', '_limit'])
         all_params.update(extra_params)
         for key, val in six.iteritems(params):
             if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                 if key.lower() == 'if_match'.lower():
                     key = 'If-Match'
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params and params['body'] is not None:
-            body_params = params['body']
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/policies/$actions/import', 'POST',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.NetworkSecurityPolicyImportResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/policies/$actions/import', 'POST',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.NetworkSecurityPolicyImportResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/policies/{extId}/rules', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.ListNetworkSecurityPolicyRulesApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/policies/{extId}/rules', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.ListNetworkSecurityPolicyRulesApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def update_network_security_policy_by_ext_id(self, extId, body, **kwargs):  # noqa: E501
-        """Updates a network security policy by UUID.
+    def update_network_security_policy_by_id(self, extId, body, **kwargs):  # noqa: E501
+        """Update a Network Security Policy by ExtID
 
-        >>> response = api.update_network_security_policy_by_ext_id(extId, body)
+        >>> response = api.update_network_security_policy_by_id(extId, body)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.update_network_security_policy_by_ext_id(extId, body, async_req=True)
+        >>> thread = api.update_network_security_policy_by_id(extId, body, async_req=True)
         >>> result = thread.get()
 
         :param extId: Network security policy UUID.
         :type extId:
+
             :class:`str`, required
-        :param body: Updates a network security policy by UUID.
+        :param body: Updates the Network Security Policy with the provided ExtID.
         :type body:
+
             :class:`~ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicy`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyTaskResponse`.
+        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.UpdateNetworkSecurityPolicyApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `update_network_security_policy_by_ext_id`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `update_network_security_policy_by_id`")  # noqa: E501
         # verify the required parameter 'body' is set
         if ('body' not in params or params['body'] is None):
-            raise ValueError("Missing the required parameter `body` when calling `update_network_security_policy_by_ext_id`")  # noqa: E501
+            raise ValueError("Missing the required parameter `body` when calling `update_network_security_policy_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
             ['application/json'])  # noqa: E501
+        if 'Content-Type' in params and params.get('Content-Type') is not None:
+            header_params['Content-Type'] = params.get('Content-Type')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -861,47 +929,50 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
+        # Authentication setting
+        auth_settings = ['basicAuthScheme']  # noqa: E501
+
         body_params = None
         if 'body' in params and params['body'] is not None:
             body_params = params['body']
 
-        # Authentication setting
-        auth_settings = ['basicAuthScheme']  # noqa: E501
-
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/policies/{extId}', 'PUT',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.NetworkSecurityPolicyTaskResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/policies/{extId}', 'PUT',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.NetworkSecurityPolicyTaskResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/policies/{extId}', 'PUT',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.UpdateNetworkSecurityPolicyApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/policies/{extId}', 'PUT',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.UpdateNetworkSecurityPolicyApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/api/service_groups_api.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/api/service_groups_api.py`

 * *Files 15% similar despite different names*

```diff
@@ -3,15 +3,15 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 from __future__ import absolute_import
 
 import re  # noqa: F401
@@ -29,40 +29,41 @@
     """  # noqa: E501
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
 
         self.api_client = api_client
-        self.__headers_to_skip = { 'authorization', 'cookie', 'ntnx-request-id', 'host', 'user-agent' }
+        self.__headers_to_skip = { 'authorization', 'cookie', 'host', 'user-agent' }
 
     def create_service_group(self, body, **kwargs):  # noqa: E501
-        """Creates a service group.
+        """Create a Service Group
 
         >>> response = api.create_service_group(body)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
         >>> thread = api.create_service_group(body, async_req=True)
         >>> result = thread.get()
 
         :param body: 
         :type body:
+
             :class:`~ntnx_microseg_py_client.models.microseg.v4.config.ServiceGroup`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.ServiceGroupTaskResponse`.
+        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.CreateServiceGroupApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'body' is set
         if ('body' not in params or params['body'] is None):
@@ -74,18 +75,22 @@
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
             ['application/json'])  # noqa: E501
+        if 'Content-Type' in params and params.get('Content-Type') is not None:
+            header_params['Content-Type'] = params.get('Content-Type')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -98,100 +103,106 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
+        # Authentication setting
+        auth_settings = ['basicAuthScheme']  # noqa: E501
+
         body_params = None
         if 'body' in params and params['body'] is not None:
             body_params = params['body']
 
-        # Authentication setting
-        auth_settings = ['basicAuthScheme']  # noqa: E501
-
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/service-groups', 'POST',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.ServiceGroupTaskResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/service-groups', 'POST',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.ServiceGroupTaskResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/service-groups', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.CreateServiceGroupApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/service-groups', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.CreateServiceGroupApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def delete_service_group_by_ext_id(self, extId, **kwargs):  # noqa: E501
-        """Deletes a service group by UUID.
+    def delete_service_group_by_id(self, extId, **kwargs):  # noqa: E501
+        """Delete a Service Group by ExtID
 
-        >>> response = api.delete_service_group_by_ext_id(extId)
+        >>> response = api.delete_service_group_by_id(extId)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.delete_service_group_by_ext_id(extId, async_req=True)
+        >>> thread = api.delete_service_group_by_id(extId, async_req=True)
         >>> result = thread.get()
 
         :param extId: Service Group UUID.
         :type extId:
+
             :class:`str`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.ServiceGroupTaskResponse`.
+        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.DeleteServiceGroupApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `delete_service_group_by_ext_id`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `delete_service_group_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -204,98 +215,104 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/service-groups/{extId}', 'DELETE',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.ServiceGroupTaskResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/service-groups/{extId}', 'DELETE',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.ServiceGroupTaskResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/service-groups/{extId}', 'DELETE',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.DeleteServiceGroupApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/service-groups/{extId}', 'DELETE',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.DeleteServiceGroupApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def get_service_group_by_ext_id(self, extId, **kwargs):  # noqa: E501
-        """Get a service group by UUID.
+    def get_service_group_by_id(self, extId, **kwargs):  # noqa: E501
+        """Get a Service Group by ExtID
 
-        >>> response = api.get_service_group_by_ext_id(extId)
+        >>> response = api.get_service_group_by_id(extId)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.get_service_group_by_ext_id(extId, async_req=True)
+        >>> thread = api.get_service_group_by_id(extId, async_req=True)
         >>> result = thread.get()
 
         :param extId: Service Group UUID.
         :type extId:
+
             :class:`str`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.ServiceGroupGetResponse`.
+        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.GetServiceGroupApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `get_service_group_by_ext_id`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `get_service_group_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -308,86 +325,97 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/service-groups/{extId}', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.ServiceGroupGetResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/service-groups/{extId}', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.ServiceGroupGetResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/service-groups/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.GetServiceGroupApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/service-groups/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.GetServiceGroupApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def list_service_groups(self, _page=None, _limit=None, _filter=None, _orderby=None, **kwargs):  # noqa: E501
-        """Gets a list of service groups
+    def list_service_groups(self, _page=None, _limit=None, _filter=None, _orderby=None, _select=None, **kwargs):  # noqa: E501
+        """List all the Service Groups
 
-        >>> response = api.list_service_groups((optional) _page, (optional) _limit, (optional) _filter, (optional) _orderby)
+        >>> response = api.list_service_groups((optional) _page, (optional) _limit, (optional) _filter, (optional) _orderby, (optional) _select)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
         >>> thread = api.list_service_groups(async_req=True)
         >>> result = thread.get()
 
-        :param _page: A URL query parameter that specifies the page number of the result set.  Must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range will lead to no results being returned. 
+        :param _page: A URL query parameter that specifies the page number of the result set. It must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range might lead to no results. 
         :type _page:
+
             :class:`int`
-        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided a default value of 50 records will be returned in the result set. 
+        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided, a default value of 50 records will be returned in the result set. 
         :type _limit:
+
             :class:`int`
-        :param _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the OData V4.01 URL conventions. For example, filter '$filter=name eq 'karbon-ntnx-1.0' would filter result on cluster name karbon-ntnx1.0, filter '$filter=startswith(name, 'C')' would filter on cluster name starting with C. The filter can be applied on the following fields: - description - extId - isSystemDefined - name 
+        :param _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the [OData V4.01](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html) URL conventions. For example, filter '$filter=name eq 'karbon-ntnx-1.0' would filter the result on cluster name 'karbon-ntnx1.0', filter '$filter=startswith(name, 'C')' would filter on cluster name starting with 'C'. The filter can be applied to the following fields: - createdBy - description - extId - isSystemDefined - name 
         :type _filter:
+
             :class:`str`
-        :param _orderby: A URL query parameter that allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified the resources will be sorted in ascending order by default. For example, '$orderby=templateName desc' would get all templates sorted by templateName in desc order. The orderby can be applied to the following fields: - description - extId - name 
+        :param _orderby: A URL query parameter that allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified, the resources will be sorted in ascending order by default. For example, '$orderby=templateName desc' would get all templates sorted by templateName in descending order. The orderby can be applied to the following fields: - description - extId - name 
         :type _orderby:
+
+            :class:`str`
+        :param _select: A URL query parameter that allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the [OData V4.01](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html) URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e., *), then all properties on the matching resource will be returned. - createdBy - description - extId - icmpServices - isSystemDefined - links - name - policyReferences - tcpServices - tenantId - udpServices 
+        :type _select:
+
             :class:`str`
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.ServiceGroupListResponse`.
+        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.ListServiceGroupsApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
 
         collection_formats = {}
@@ -399,133 +427,146 @@
             query_params.append(('$page', params['_page']))  # noqa: E501
         if '_limit' in params and params['_limit'] is not None:
             query_params.append(('$limit', params['_limit']))  # noqa: E501
         if '_filter' in params and params['_filter'] is not None:
             query_params.append(('$filter', params['_filter']))  # noqa: E501
         if '_orderby' in params and params['_orderby'] is not None:
             query_params.append(('$orderby', params['_orderby']))  # noqa: E501
+        if '_select' in params and params['_select'] is not None:
+            query_params.append(('$select', params['_select']))  # noqa: E501
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
-        all_params = set(['_page', '_limit', '_filter', '_orderby'])
+        all_params = set(['_page', '_limit', '_filter', '_orderby', '_select'])
         all_params.update(extra_params)
         for key, val in six.iteritems(params):
             if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                 if key.lower() == 'if_match'.lower():
                     key = 'If-Match'
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/service-groups', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.ServiceGroupListResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/service-groups', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.ServiceGroupListResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/service-groups', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.ListServiceGroupsApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/service-groups', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.ListServiceGroupsApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def update_service_group_by_ext_id(self, extId, body, **kwargs):  # noqa: E501
-        """Updates a service group by UUID.
+    def update_service_group_by_id(self, extId, body, **kwargs):  # noqa: E501
+        """Update a Service Group by ExtID
 
-        >>> response = api.update_service_group_by_ext_id(extId, body)
+        >>> response = api.update_service_group_by_id(extId, body)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.update_service_group_by_ext_id(extId, body, async_req=True)
+        >>> thread = api.update_service_group_by_id(extId, body, async_req=True)
         >>> result = thread.get()
 
         :param extId: Service Group UUID.
         :type extId:
+
             :class:`str`, required
-        :param body: Updates a service group by UUID.
+        :param body: Updates the Service Group with the provided ExtID.
         :type body:
+
             :class:`~ntnx_microseg_py_client.models.microseg.v4.config.ServiceGroup`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.ServiceGroupTaskResponse`.
+        :return: An instance of class :class:`~ntnx_microseg_py_client.models.microseg.v4.config.UpdateServiceGroupApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `update_service_group_by_ext_id`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `update_service_group_by_id`")  # noqa: E501
         # verify the required parameter 'body' is set
         if ('body' not in params or params['body'] is None):
-            raise ValueError("Missing the required parameter `body` when calling `update_service_group_by_ext_id`")  # noqa: E501
+            raise ValueError("Missing the required parameter `body` when calling `update_service_group_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
             ['application/json'])  # noqa: E501
+        if 'Content-Type' in params and params.get('Content-Type') is not None:
+            header_params['Content-Type'] = params.get('Content-Type')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -538,47 +579,50 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
+        # Authentication setting
+        auth_settings = ['basicAuthScheme']  # noqa: E501
+
         body_params = None
         if 'body' in params and params['body'] is not None:
             body_params = params['body']
 
-        # Authentication setting
-        auth_settings = ['basicAuthScheme']  # noqa: E501
-
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/service-groups/{extId}', 'PUT',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.ServiceGroupTaskResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/microseg/v4.0.a1/config/service-groups/{extId}', 'PUT',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='microseg.v4.config.ServiceGroupTaskResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/service-groups/{extId}', 'PUT',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.UpdateServiceGroupApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/microseg/v4.0.b1/config/service-groups/{extId}', 'PUT',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='microseg.v4.config.UpdateServiceGroupApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/api_client.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/api_client.py`

 * *Files 11% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 from __future__ import absolute_import
 
 import datetime
@@ -25,14 +25,22 @@
 import uuid
 import logging
 
 # python 2 and python 3 compatibility library
 import six
 from six.moves.urllib.parse import quote
 
+from pathlib import Path
+
+
+try:
+    import urllib3
+except ImportError:
+    raise ImportError('Api client requires urllib3.')
+
 from ntnx_microseg_py_client.configuration import Configuration
 import ntnx_microseg_py_client.models
 from ntnx_microseg_py_client import rest
 
 PY2 = sys.version_info[0] < 3
 
 logger = logging.getLogger(__name__)
@@ -41,160 +49,145 @@
 
     """API client to handle the client-server communication, and is invariant across implementations.
 
     :param configuration: Configuration object for this client
     :type configuration: :class:`~ntnx_vmm_py_client.configuration.Configuration`, required
     """  # noqa: E501
 
-    SDK_VERSION = "v4.0.a1"
+    SDK_VERSION = "v4.0.b1"
     PRIMITIVE_TYPES = (float, bool, bytes, six.text_type) + six.integer_types
     NATIVE_TYPES_MAPPING = {
         'int': int,
         'long': int if six.PY3 else long,  # noqa: F821
         'float': float,
         'str': str,
         'bool': bool,
         'date': datetime.date,
         'datetime': datetime.datetime,
         'object': object,
     }
     DUPLICATE_SCHEMA_MAPPING = {
     # Populated if multiple schemas exist with the same name
-        'microseg.v4.config.ConfigMigrationPolicyType' : 'ConfigMigrationPolicyType',
-        'microseg.v4.config.ServiceGroupReferenceSpec' : 'ServiceGroupReferenceSpec',
-        'OneOfmicroseg.v4.config.AddressGroupListResponsedata' : 'AddressGroupListResponsedata',
+        'OneOfmicroseg.v4.config.ListNetworkSecurityPoliciesApiResponsedata' : 'ListNetworkSecurityPoliciesApiResponsedata',
+        'microseg.v4.config.DeleteDsCategoryMappingApiResponse' : 'DeleteDsCategoryMappingApiResponse',
         'common.v1.config.IPv4Address' : 'IPv4Address',
-        'microseg.v4.config.OptionSpec' : 'OptionSpec',
-        'microseg.v4.config.CategoryMappingInfo' : 'CategoryMappingInfo',
-        'OneOfmicroseg.v4.config.BannerGetResponsedata' : 'BannerGetResponsedata',
-        'microseg.v4.config.DsCategoryMappingGetResponse' : 'DsCategoryMappingGetResponse',
-        'microseg.v4.config.ServiceGroupTaskResponse' : 'ServiceGroupTaskResponse',
+        'common.v1.config.FQDN' : 'FQDN',
+        'common.v1.config.IPv6Address' : 'IPv6Address',
         'common.v1.config.Flag' : 'Flag',
         'microseg.v4.config.IntraEntityGroupRuleAction' : 'IntraEntityGroupRuleAction',
+        'microseg.v4.config.CreateDsCategoryMappingApiResponse' : 'CreateDsCategoryMappingApiResponse',
         'microseg.v4.config.AddressGroup' : 'AddressGroup',
-        'microseg.v4.config.NetworkSecurityPolicyMigrationSubnetSummary' : 'NetworkSecurityPolicyMigrationSubnetSummary',
-        'microseg.v4.config.MigrationConfigTaskResponse' : 'MigrationConfigTaskResponse',
-        'microseg.v4.config.BannerType' : 'BannerType',
-        'microseg.v4.config.DirectoryServerDeleteResponse' : 'DirectoryServerDeleteResponse',
-        'microseg.v4.config.TierName' : 'TierName',
-        'OneOfmicroseg.v4.config.NetworkSecurityPolicyRulesGetResponsedata' : 'NetworkSecurityPolicyRulesGetResponsedata',
-        'OneOfmicroseg.v4.config.NetworkSecurityPolicyGetResponsedata' : 'NetworkSecurityPolicyGetResponsedata',
-        'microseg.v4.config.AddressGroupGetResponse' : 'AddressGroupGetResponse',
-        'microseg.v4.config.ServiceGroupPolicyReference' : 'ServiceGroupPolicyReference',
-        'microseg.v4.config.AddressGroupPolicyReference' : 'AddressGroupPolicyReference',
+        'microseg.v4.operation.SecurityPolicyOptions' : 'SecurityPolicyOptions',
+        'OneOfmicroseg.v4.config.CreateNetworkSecurityPolicyApiResponsedata' : 'CreateNetworkSecurityPolicyApiResponsedata',
         'microseg.v4.config.IcmpTypeCodeSpec' : 'IcmpTypeCodeSpec',
         'prism.v4.config.TaskReference' : 'TaskReference',
-        'microseg.v4.config.MigrationConfig' : 'MigrationConfig',
-        'microseg.v4.config.NetworkSecurityPolicyMigrationSummaryFailures' : 'NetworkSecurityPolicyMigrationSummaryFailures',
-        'microseg.v4.config.NetworkSecurityPolicyMigrationMetadata' : 'NetworkSecurityPolicyMigrationMetadata',
+        'microseg.v4.config.GetServiceGroupApiResponse' : 'GetServiceGroupApiResponse',
+        'microseg.v4.config.UpdateDsCategoryMappingApiResponse' : 'UpdateDsCategoryMappingApiResponse',
         'microseg.v4.config.ServiceGroup' : 'ServiceGroup',
-        'microseg.v4.config.DirectoryServerCreateResponse' : 'DirectoryServerCreateResponse',
-        'microseg.v4.config.TierGetResponse' : 'TierGetResponse',
+        'OneOfmicroseg.v4.config.UpdateDsCategoryMappingApiResponsedata' : 'UpdateDsCategoryMappingApiResponsedata',
         'microseg.v4.error.ErrorResponse' : 'ErrorResponse',
-        'OneOfmicroseg.v4.config.TierUpdateResponsedata' : 'TierUpdateResponsedata',
-        'microseg.v4.config.DirectoryServer' : 'DirectoryServer',
+        'OneOfmicroseg.v4.config.CreateNetworkSecurityPolicyImportApiResponsedata' : 'CreateNetworkSecurityPolicyImportApiResponsedata',
+        'OneOfmicroseg.v4.config.UpdateDirectoryServerConfigApiResponsedata' : 'UpdateDirectoryServerConfigApiResponsedata',
         'OneOfmicroseg.v4.config.NetworkSecurityPolicyRulespec' : 'NetworkSecurityPolicyRulespec',
-        'OneOfmicroseg.v4.config.AddressGroupGetResponsedata' : 'AddressGroupGetResponsedata',
-        'OneOfmicroseg.v4.config.DsCategoryMappingDeleteResponsedata' : 'DsCategoryMappingDeleteResponsedata',
-        'OneOfmicroseg.v4.config.ServiceGroupGetResponsedata' : 'ServiceGroupGetResponsedata',
-        'microseg.v4.config.DirectoryServerGetResponse' : 'DirectoryServerGetResponse',
-        'microseg.v4.config.NetworkSecurityPolicyTaskResponse' : 'NetworkSecurityPolicyTaskResponse',
-        'microseg.v4.config.NetworkSecurityPolicyMigrationTypeCountInfo' : 'NetworkSecurityPolicyMigrationTypeCountInfo',
+        'microseg.v4.operation.SubnetUpgradeSummary' : 'SubnetUpgradeSummary',
+        'microseg.v4.config.UpdateDirectoryServerConfigApiResponse' : 'UpdateDirectoryServerConfigApiResponse',
+        'microseg.v4.operation.UpgradeSpec' : 'UpgradeSpec',
         'microseg.v4.config.UdpPortRangeSpec' : 'UdpPortRangeSpec',
-        'OneOfmicroseg.v4.config.AddressGroupPolicyAssociationResponsedata' : 'AddressGroupPolicyAssociationResponsedata',
-        'microseg.v4.config.NetworkSecurityPolicyMigrationTotalCountInfo' : 'NetworkSecurityPolicyMigrationTotalCountInfo',
-        'microseg.v4.config.NetworkSecurityPolicyImportEntity' : 'NetworkSecurityPolicyImportEntity',
-        'microseg.v4.config.PolicyReferenceStateSpec' : 'PolicyReferenceStateSpec',
-        'OneOfmicroseg.v4.config.ServiceGroupPolicyAssociationResponsedata' : 'ServiceGroupPolicyAssociationResponsedata',
-        'OneOfmicroseg.v4.config.NetworkSecurityPolicyGetListResponsedata' : 'NetworkSecurityPolicyGetListResponsedata',
+        'microseg.v4.operation.UpgradeJob' : 'UpgradeJob',
+        'OneOfmicroseg.v4.config.ListNetworkSecurityPolicyRulesApiResponsedata' : 'ListNetworkSecurityPolicyRulesApiResponsedata',
+        'microseg.v4.config.UpdateNetworkSecurityPolicyApiResponse' : 'UpdateNetworkSecurityPolicyApiResponse',
+        'OneOfmicroseg.v4.operation.UpgradeJobspec' : 'UpgradeJobspec',
         'microseg.v4.config.MatchEntity' : 'MatchEntity',
-        'microseg.v4.config.BannerResponse' : 'BannerResponse',
         'microseg.v4.config.MatchingCriteria' : 'MatchingCriteria',
-        'OneOfmicroseg.v4.config.DsCategoryMappingGetResponsedata' : 'DsCategoryMappingGetResponsedata',
+        'microseg.v4.operation.PolicyUpgradeSummary' : 'PolicyUpgradeSummary',
+        'microseg.v4.config.CreateNetworkSecurityPolicyApiResponse' : 'CreateNetworkSecurityPolicyApiResponse',
+        'microseg.v4.config.CreateServiceGroupApiResponse' : 'CreateServiceGroupApiResponse',
         'microseg.v4.error.SchemaValidationError' : 'SchemaValidationError',
-        'OneOfmicroseg.v4.config.DirectoryServerUpdateResponsedata' : 'DirectoryServerUpdateResponsedata',
-        'OneOfmicroseg.v4.config.NetworkSecurityPolicyImportResponsedata' : 'NetworkSecurityPolicyImportResponsedata',
-        'microseg.v4.config.DsCategoryMappingUpdateResponse' : 'DsCategoryMappingUpdateResponse',
-        'microseg.v4.config.PolicyType' : 'PolicyType',
-        'microseg.v4.config.PolicyState' : 'PolicyState',
-        'microseg.v4.config.PolicyReferenceActionSpec' : 'PolicyReferenceActionSpec',
+        'OneOfmicroseg.v4.config.CreateServiceGroupApiResponsedata' : 'CreateServiceGroupApiResponsedata',
+        'microseg.v4.operation.PolicyPreview' : 'PolicyPreview',
+        'OneOfmicroseg.v4.config.GetServiceGroupApiResponsedata' : 'GetServiceGroupApiResponsedata',
+        'OneOfmicroseg.v4.config.DeleteNetworkSecurityPolicyApiResponsedata' : 'DeleteNetworkSecurityPolicyApiResponsedata',
+        'OneOfmicroseg.v4.config.UpdateNetworkSecurityPolicyApiResponsedata' : 'UpdateNetworkSecurityPolicyApiResponsedata',
+        'common.v1.config.IPAddressOrFQDN' : 'IPAddressOrFQDN',
+        'microseg.v4.config.IntraEntityGroupRuleSpec' : 'IntraEntityGroupRuleSpec',
+        'OneOfmicroseg.v4.config.UpdateServiceGroupApiResponsedata' : 'UpdateServiceGroupApiResponsedata',
         'microseg.v4.error.AppMessage' : 'AppMessage',
-        'microseg.v4.config.ConfigMigrationSummary' : 'ConfigMigrationSummary',
+        'OneOfmicroseg.v4.config.ListDsCategoryMappingsApiResponsedata' : 'ListDsCategoryMappingsApiResponsedata',
         'common.v1.response.ApiResponseMetadata' : 'ApiResponseMetadata',
-        'microseg.v4.config.NSPIntraEntityGroupRuleSpec' : 'NSPIntraEntityGroupRuleSpec',
-        'microseg.v4.config.TierUpdateResponse' : 'TierUpdateResponse',
-        'OneOfmicroseg.v4.config.NetworkSecurityPolicyTaskResponsedata' : 'NetworkSecurityPolicyTaskResponsedata',
-        'OneOfmicroseg.v4.config.ServiceGroupListResponsedata' : 'ServiceGroupListResponsedata',
-        'microseg.v4.config.DirectoryServerUpdateResponse' : 'DirectoryServerUpdateResponse',
-        'microseg.v4.config.ServiceGroupListResponse' : 'ServiceGroupListResponse',
+        'microseg.v4.config.AdInfo' : 'AdInfo',
+        'OneOfmicroseg.v4.config.GetDirectoryServerConfigApiResponsedata' : 'GetDirectoryServerConfigApiResponsedata',
+        'microseg.v4.operation.DryRunSpec' : 'DryRunSpec',
+        'microseg.v4.config.DeleteServiceGroupApiResponse' : 'DeleteServiceGroupApiResponse',
+        'microseg.v4.config.GetDsCategoryMappingApiResponse' : 'GetDsCategoryMappingApiResponse',
+        'OneOfmicroseg.v4.config.DeleteAddressGroupApiResponsedata' : 'DeleteAddressGroupApiResponsedata',
+        'OneOfmicroseg.v4.config.ListDirectoryServerConfigsApiResponsedata' : 'ListDirectoryServerConfigsApiResponsedata',
+        'microseg.v4.config.SecurityPolicyScope' : 'SecurityPolicyScope',
+        'OneOfmicroseg.v4.config.GetNetworkSecurityPolicyApiResponsedata' : 'GetNetworkSecurityPolicyApiResponsedata',
+        'microseg.v4.config.DeleteAddressGroupApiResponse' : 'DeleteAddressGroupApiResponse',
         'common.v1.response.ExternalizableAbstractModel' : 'ExternalizableAbstractModel',
+        'microseg.v4.operation.SecurityPolicyType' : 'OperationSecurityPolicyType',
+        'OneOfmicroseg.v4.config.DeleteDirectoryServerConfigApiResponsedata' : 'DeleteDirectoryServerConfigApiResponsedata',
         'common.v1.config.Message' : 'Message',
+        'microseg.v4.config.AdStatus' : 'AdStatus',
+        'microseg.v4.config.ListNetworkSecurityPoliciesApiResponse' : 'ListNetworkSecurityPoliciesApiResponse',
         'microseg.v4.error.SchemaValidationErrorMessage' : 'SchemaValidationErrorMessage',
-        'OneOfmicroseg.v4.config.DirectoryServerListResponsedata' : 'DirectoryServerListResponsedata',
         'microseg.v4.config.MatchField' : 'MatchField',
+        'microseg.v4.config.GetAddressGroupApiResponse' : 'GetAddressGroupApiResponse',
         'microseg.v4.config.NetworkSecurityPolicy' : 'NetworkSecurityPolicy',
-        'OneOfmicroseg.v4.config.TierGetResponsedata' : 'TierGetResponsedata',
-        'microseg.v4.config.ServiceGroupGetResponse' : 'ServiceGroupGetResponse',
+        'microseg.v4.config.CreateDirectoryServerConfigApiResponse' : 'CreateDirectoryServerConfigApiResponse',
+        'microseg.v4.config.ListServiceGroupsApiResponse' : 'ListServiceGroupsApiResponse',
         'OneOfcommon.v1.config.KVPairvalue' : 'KVPairvalue',
-        'OneOfmicroseg.v4.config.MigrationConfigSpecspec' : 'MigrationConfigSpecspec',
+        'microseg.v4.config.DirectoryServerConfig' : 'DirectoryServerConfig',
+        'microseg.v4.config.GetDirectoryServerConfigApiResponse' : 'GetDirectoryServerConfigApiResponse',
         'microseg.v4.config.RuleType' : 'RuleType',
-        'OneOfmicroseg.v4.config.ConfigMigrationPreviewGetResponsedata' : 'ConfigMigrationPreviewGetResponsedata',
+        'OneOfmicroseg.v4.config.CreateNetworkSecurityPolicyExportApiResponsedata' : 'CreateNetworkSecurityPolicyExportApiResponsedata',
         'microseg.v4.config.CategoryMapping' : 'CategoryMapping',
-        'OneOfmicroseg.v4.config.DirectoryServerGetResponsedata' : 'DirectoryServerGetResponsedata',
-        'microseg.v4.config.NetworkSecurityPolicyGetListResponse' : 'NetworkSecurityPolicyGetListResponse',
-        'microseg.v4.config.AddressGroupTaskResponse' : 'AddressGroupTaskResponse',
-        'microseg.v4.config.MigrationConfigSpec' : 'MigrationConfigSpec',
-        'microseg.v4.config.NetworkSecurityPolicyImportEntityUpdateType' : 'NetworkSecurityPolicyImportEntityUpdateType',
-        'microseg.v4.config.NetworkSecurityPolicyImportResponse' : 'NetworkSecurityPolicyImportResponse',
-        'microseg.v4.config.NetworkSecurityPolicyMigrationSummary' : 'NetworkSecurityPolicyMigrationSummary',
-        'OneOfmicroseg.v4.config.DsCategoryMappingsGetListResponsedata' : 'DsCategoryMappingsGetListResponsedata',
+        'microseg.v4.config.TwoEnvIsolationRuleSpec' : 'TwoEnvIsolationRuleSpec',
+        'OneOfmicroseg.v4.config.CreateDsCategoryMappingApiResponsedata' : 'CreateDsCategoryMappingApiResponsedata',
+        'OneOfmicroseg.v4.config.DeleteDsCategoryMappingApiResponsedata' : 'DeleteDsCategoryMappingApiResponsedata',
         'common.v1.config.MessageSeverity' : 'MessageSeverity',
-        'OneOfmicroseg.v4.config.DsCategoryMappingCreateResponsedata' : 'DsCategoryMappingCreateResponsedata',
-        'microseg.v4.config.DirectoryServerListResponse' : 'DirectoryServerListResponse',
-        'microseg.v4.config.TierResponse' : 'TierResponse',
+        'OneOfmicroseg.v4.config.CreateDirectoryServerConfigApiResponsedata' : 'CreateDirectoryServerConfigApiResponsedata',
+        'microseg.v4.config.GetNetworkSecurityPolicyApiResponse' : 'GetNetworkSecurityPolicyApiResponse',
+        'microseg.v4.operation.PolicyMetadata' : 'PolicyMetadata',
+        'microseg.v4.config.ListDsCategoryMappingsApiResponse' : 'ListDsCategoryMappingsApiResponse',
         'microseg.v4.config.TcpPortRangeSpec' : 'TcpPortRangeSpec',
-        'microseg.v4.config.ConfigMigrationPreviewGetResponse' : 'ConfigMigrationPreviewGetResponse',
-        'microseg.v4.config.AddressGroupListResponse' : 'AddressGroupListResponse',
-        'microseg.v4.config.ConfigMigrationSummaryGetResponse' : 'ConfigMigrationSummaryGetResponse',
-        'OneOfmicroseg.v4.config.MigrationConfigTaskResponsedata' : 'MigrationConfigTaskResponsedata',
-        'OneOfmicroseg.v4.config.DirectoryServerDeleteResponsedata' : 'DirectoryServerDeleteResponsedata',
+        'microseg.v4.operation.DryRunSummary' : 'DryRunSummary',
+        'microseg.v4.config.ApplicationRuleSpec' : 'ApplicationRuleSpec',
+        'microseg.v4.config.CreateAddressGroupApiResponse' : 'CreateAddressGroupApiResponse',
+        'microseg.v4.operation.PolicyCountByType' : 'PolicyCountByType',
         'common.v1.response.ApiLink' : 'ApiLink',
-        'microseg.v4.config.DsCategoryMappingsGetListResponse' : 'DsCategoryMappingsGetListResponse',
-        'OneOfmicroseg.v4.config.DirectoryServerCreateResponsedata' : 'DirectoryServerCreateResponsedata',
-        'microseg.v4.config.DsCategoryMappingDeleteResponse' : 'DsCategoryMappingDeleteResponse',
-        'microseg.v4.config.NetworkSecurityPolicyImportEntityType' : 'NetworkSecurityPolicyImportEntityType',
+        'microseg.v4.config.ImportEntityType' : 'ImportEntityType',
+        'microseg.v4.config.DeleteNetworkSecurityPolicyApiResponse' : 'DeleteNetworkSecurityPolicyApiResponse',
+        'microseg.v4.config.SecurityPolicyState' : 'SecurityPolicyState',
+        'OneOfmicroseg.v4.config.GetDsCategoryMappingApiResponsedata' : 'GetDsCategoryMappingApiResponsedata',
         'microseg.v4.config.NetworkSecurityPolicyRule' : 'NetworkSecurityPolicyRule',
-        'microseg.v4.config.NetworkSecurityPolicyRulesGetResponse' : 'NetworkSecurityPolicyRulesGetResponse',
-        'microseg.v4.config.CategoryMappingAdStatus' : 'CategoryMappingAdStatus',
-        'microseg.v4.config.DomainController' : 'DomainController',
-        'microseg.v4.config.MigrationSummary' : 'MigrationSummary',
-        'microseg.v4.config.FileWrapper' : 'FileWrapper',
-        'microseg.v4.config.NetworkSecurityPolicyMigrationCountSummary' : 'NetworkSecurityPolicyMigrationCountSummary',
-        'microseg.v4.config.PolicyReferenceSpec' : 'PolicyReferenceSpec',
-        'microseg.v4.config.ConfigMigrationPolicyOptions' : 'ConfigMigrationPolicyOptions',
-        'microseg.v4.config.NSPTwoEnvIsolationRuleSpec' : 'NSPTwoEnvIsolationRuleSpec',
-        'microseg.v4.config.AddressGroupReferenceSpec' : 'AddressGroupReferenceSpec',
-        'OneOfmicroseg.v4.config.ConfigMigrationSummaryGetResponsedata' : 'ConfigMigrationSummaryGetResponsedata',
-        'OneOfmicroseg.v4.config.AddressGroupTaskResponsedata' : 'AddressGroupTaskResponsedata',
+        'microseg.v4.operation.PolicyCount' : 'PolicyCount',
+        'microseg.v4.config.ImportEntity' : 'ImportEntity',
+        'microseg.v4.config.DeleteDirectoryServerConfigApiResponse' : 'DeleteDirectoryServerConfigApiResponse',
+        'OneOfmicroseg.v4.config.CreateAddressGroupApiResponsedata' : 'CreateAddressGroupApiResponsedata',
+        'microseg.v4.config.UpdateServiceGroupApiResponse' : 'UpdateServiceGroupApiResponse',
+        'OneOfmicroseg.v4.config.GetAddressGroupApiResponsedata' : 'GetAddressGroupApiResponsedata',
+        'microseg.v4.config.ListDirectoryServerConfigsApiResponse' : 'ListDirectoryServerConfigsApiResponse',
         'microseg.v4.config.IPv4Range' : 'IPv4Range',
-        'OneOfmicroseg.v4.config.DsCategoryMappingUpdateResponsedata' : 'DsCategoryMappingUpdateResponsedata',
-        'OneOfmicroseg.v4.config.ServiceGroupTaskResponsedata' : 'ServiceGroupTaskResponsedata',
+        'OneOfmicroseg.v4.config.ListServiceGroupsApiResponsedata' : 'ListServiceGroupsApiResponsedata',
+        'microseg.v4.config.CreateNetworkSecurityPolicyImportApiResponse' : 'CreateNetworkSecurityPolicyImportApiResponse',
         'OneOfmicroseg.v4.error.ErrorResponseerror' : 'ErrorResponseerror',
-        'microseg.v4.config.ConfigMigrationPreviewResponse' : 'ConfigMigrationPreviewResponse',
         'microseg.v4.config.MatchType' : 'MatchType',
-        'microseg.v4.config.ServiceGroupPolicyAssociationResponse' : 'ServiceGroupPolicyAssociationResponse',
-        'microseg.v4.config.AddressGroupPolicyAssociationResponse' : 'AddressGroupPolicyAssociationResponse',
+        'microseg.v4.config.CreateNetworkSecurityPolicyExportApiResponse' : 'CreateNetworkSecurityPolicyExportApiResponse',
+        'microseg.v4.config.SecurityPolicyType' : 'ConfigSecurityPolicyType',
         'common.v1.config.TenantAwareModel' : 'TenantAwareModel',
-        'microseg.v4.config.DsCategoryMappingCreateResponse' : 'DsCategoryMappingCreateResponse',
-        'microseg.v4.config.BannerGetResponse' : 'BannerGetResponse',
-        'microseg.v4.config.Tier' : 'Tier',
-        'microseg.v4.config.CategoryMappingAdInfo' : 'CategoryMappingAdInfo',
-        'microseg.v4.config.NSPApplicationRuleSpec' : 'NSPApplicationRuleSpec',
+        'microseg.v4.config.ListAddressGroupsApiResponse' : 'ListAddressGroupsApiResponse',
+        'OneOfmicroseg.v4.config.DeleteServiceGroupApiResponsedata' : 'DeleteServiceGroupApiResponsedata',
+        'microseg.v4.operation.TotalPolicyCount' : 'TotalPolicyCount',
+        'microseg.v4.config.ImportEntityUpdateType' : 'ImportEntityUpdateType',
+        'microseg.v4.config.ListNetworkSecurityPolicyRulesApiResponse' : 'ListNetworkSecurityPolicyRulesApiResponse',
+        'microseg.v4.config.UpdateAddressGroupApiResponse' : 'UpdateAddressGroupApiResponse',
+        'OneOfmicroseg.v4.config.UpdateAddressGroupApiResponsedata' : 'UpdateAddressGroupApiResponsedata',
         'microseg.v4.config.AllowType' : 'AllowType',
-        'microseg.v4.config.NetworkSecurityPolicyGetResponse' : 'NetworkSecurityPolicyGetResponse',
+        'OneOfmicroseg.v4.config.ListAddressGroupsApiResponsedata' : 'ListAddressGroupsApiResponsedata',
         'common.v1.config.KVPair' : 'KVPair'
     }
 
     def __init__(self, configuration=None):
         if configuration is None:
             configuration = Configuration()
         self.configuration = configuration
@@ -349,15 +342,15 @@
         # post parameters
         if post_params or files:
             post_params = self.__prepare_post_parameters(post_params, files)
             post_params = self.__sanitize_for_serialization(post_params)
             post_params = self.__parameters_to_tuples(post_params, collection_formats)
 
         # body
-        if body:
+        if body and 'application/octet-stream' not in header_params['Content-Type']:
             body = self.__sanitize_for_serialization(body)
 
         # request url
         url = config.scheme + '://' + config.host + ':' + str(config.port) + resource_path
 
         # perform request and return response
         response_data = self.request(
@@ -386,28 +379,57 @@
                 raise ntnx_microseg_py_client.rest.ApiException(http_resp=response_data)
 
         if self.__refresh_cookie:
             self.__update_cookies(response_data)
 
         self.last_response = response_data
         return_data = response_data
-        if _preload_content:
-            # deserialize response data
+
+        # deserialize response data
+        try:
             if response_data.status != 204:
-                return_data = json.loads(response_data.data)
-                return_data = self.__add_header_to_reserved(response_data, return_data, "ETag")
-                if response_type is None and "$objectType" in return_data:
-                    response_type = return_data.get("$objectType")
-                if PY2:
-                    inner_response_type = response_type.encode('utf-8', 'ignore')
+                # Download a file
+                if response_data.getheader(name='Content-Type') == 'application/octet-stream':
+                    download_path = self.__deserialize_file(response_data)
+                    download_path = Path(download_path)
+
+                    # convert response type to class
+                    response_type = self.__getattr(response_type)
+                    data = {"path": download_path}
+                    data["$objectType"] = "pathlib.Path"
+                    data["$reserved"] = {}
+                    data["$unknownFields"] = {}
+                    return response_type(data=data)
                 else:
-                    inner_response_type = response_type
-                return self.deserialize(return_data, inner_response_type)
+                    if _preload_content:
+                        # Read the data from original urllib3 response
+                        response_data.data = response_data.urllib3_response.data
+                        # In the python 3, the response.data is bytes which needs to be decoded to string.
+                        if six.PY3:
+                            response_data.data = response_data.data.decode('utf-8')
+
+                        return_data = json.loads(response_data.data)
+                        return_data = self.__add_header_to_reserved(response_data, return_data, "ETag")
+                        if response_type is None and "$objectType" in return_data:
+                            response_type = return_data.get("$objectType")
+                        if PY2:
+                            inner_response_type = response_type.encode('utf-8', 'ignore')
+                        else:
+                            inner_response_type = response_type
+
+                        return self.deserialize(return_data, inner_response_type)
+                    else:
+                        return_data = response_data
             else:
-                return_data = None
+                if _preload_content:
+                    return_data = None
+        finally:
+            if 'Content-Type' in header_params and header_params['Content-Type'] == 'application/octet-stream':
+                response_data.urllib3_response.drain_conn()
+                response_data.urllib3_response.release_conn()
         if _return_http_data_only:
             return (return_data)
         else:
             return (return_data, response_data.status,
                     response_data.getheaders())
     def __sanitize_for_serialization(self, obj):
         """Builds a JSON POST object.
@@ -482,14 +504,17 @@
         :type discriminator: :class:`str`
         :return: Deserialized object
         :rtype: :class:`object`
         """  # noqa: E501
         if data is None:
             return None
         if type(klass) == str:
+            if klass == 'pathlib.Path':
+                data['path'] = Path(data['path'])
+                return data
             if klass.startswith('list['):
                 sub_kls = re.match(r'list\[(.*)\]', klass).group(1)
                 return [self.deserialize(sub_data, sub_kls)
                         for sub_data in data]
             if klass.startswith('dict('):
                 sub_kls = re.match(r'dict\(([^,]*), (.*)\)', klass).group(2)
                 return {str(k): self.deserialize(v, sub_kls)
@@ -701,19 +726,17 @@
         :type accepts: :class:`list`
         :return: If application/json is available, returns that.
             Otherwise, returns a comma separated string of all the provided Accept types
         """  # noqa: E501
 
         if not accepts:
             return
+
         accepts = [x.lower() for x in accepts]
-        if 'application/json' in accepts:
-            return 'application/json'
-        else:
-            return ', '.join(accepts)
+        return ', '.join(accepts)
 
     def _select_header_content_type(self, content_types):
         """Returns `Content-Type` based on an array of content_types provided.
 
         :param content_types: List of content-types
         :type content_types: :class:`list`
         :return: Content-Type (e.g. application/json)
@@ -798,24 +821,32 @@
 
         Saves response body into a file in a temporary folder, using the filename from the `Content-Disposition` header if provided.
 
         :param response: :class:`~ntnx_microseg_py_client.rest.RESTResponse`
         :return: File path
         """
 
-        fd, path = tempfile.mkstemp(dir=self.configuration.temp_folder_path)
-        os.close(fd)
-        os.remove(path)
+        path = ''
         content_disposition = response.getheader("Content-Disposition")
         if content_disposition:
-            filename = re.search(r'filename=[\'"]?([^\'"\s]+)[\'"]?',
-                                 content_disposition).group(1)
-            path = os.path.join(os.path.dirname(path), filename)
+            filename = re.search(r'filename=[\'"]?([^\'"*]+)[\'"]?', content_disposition).group(1)
+            path = os.path.join(self.configuration.download_directory, filename)
+        else:
+            fd, path = tempfile.mkstemp(dir=self.configuration.download_directory)
+            os.close(fd)
+
+        path_tup = os.path.splitext(path)
+        timestring = datetime.datetime.now().strftime("%Y-%m-%dT%H:%M:%S.%f")[:-3]
+        path = "%s_%s%s" % (path_tup[0], timestring, path_tup[1])
+        logger.info('Writing response data to file at %s' % path)
         with open(path, "wb") as f:
-            f.write(response.data)
+            if isinstance(response.urllib3_response, urllib3.response.HTTPResponse):
+                for chunk in response.urllib3_response.stream(self.configuration.download_chunk_size):
+                    f.write(chunk)
+
         return path
 
     def __deserialize_primitive(self, data, klass):
         """Deserializes string to primitive type.
 
         :param data:
         :type data: :class:`str`
@@ -920,15 +951,16 @@
                                 if type(value_item) is not dict:
                                     one_of_value.append(self.deserialize(value_item, type(value_item)))
                                 else:
                                     one_of_value.append(self.deserialize(value_item, self.__getattr(value_item['$objectType'])))
                         elif type(value) is dict:
                             # OneOf of dict type can be a single response object or a map of primitive types
                             if '$objectType' in value:
-                                one_of_value = self.deserialize(value, self.__getattr(value['$objectType']))
+                                one_of_value = self.deserialize(value, value['$objectType']
+                                    if value['$objectType'] == 'pathlib.Path' else self.__getattr(value['$objectType']))
                             else:
                                 one_of_value = {}
                                 for item_key, item_value in six.iteritems(value):
                                     one_of_value[item_key] = self.deserialize(item_value, type(item_value))
                         else:
                             one_of_value = value
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/api_response.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/api_response.py`

 * *Files 1% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import re  # noqa: F401
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/configuration.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/configuration.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,21 +3,22 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 from __future__ import absolute_import
 
+import os
 import copy
 import logging
 from logging.handlers import TimedRotatingFileHandler
 import multiprocessing
 import sys
 import urllib3
 
@@ -68,14 +69,18 @@
     :type backoff_factor: :class:`float`
     :param logger_file: (:attr:`logger_file`) File location to which logs are written to
     :type logger_file: :class:`str`
     :param connect_timeout: (:attr:`connect_timeout`) Connection timeout in milliseconds for all operations (**Default** 30000)
     :type connect_timeout: :class:`int`
     :param read_timeout: (:attr:`read_timeout`) Read timeout in milliseconds for all operations (**Default** 30000)
     :type read_timeout: :class:`int`
+    :param download_directory: (:attr:`download_directory`) Directory location on local for files to download
+    :type download_directory: :class:`str`
+    :param download_chunk_size: (:attr:`download_chunk_size`) Chunk size in bytes for files to download (**Default** 8*1024 bytes)
+    :type download_chunk_size: :class:`int`
     """  # noqa: E501
 
     def __init__(self):
 
         """Constructor"""
         self.__scheme = "https"
 
@@ -87,18 +92,20 @@
 
         # Maximum number of allowed retries for a HTTP call
         self.__max_retry_attempts = 5
 
         # Backoff factor by which the retry request is delayed with specific number of seconds.
         self.__backoff_factor = 3
 
-        self.__user_agent = 'Nutanix-ntnx_microseg_py_client/4.0.1a1'
+        self.__user_agent = 'Nutanix-ntnx_microseg_py_client/4.0.1b1'
 
-        # Temp file folder for downloading files
-        self.temp_folder_path = None
+        # Directory path for downloading files
+        self.__download_directory = os.path.abspath(os.getcwd())
+        # Chunk size for downloading files
+        self.__download_chunk_size = 8*1024
 
         # Authentication Settings
         # HTTP Basic Auth
         self.__username = None
         self.__password = None
 
         # API Key authentication (NOTE: SDK currently supports basic auth only)
@@ -191,14 +198,38 @@
         return self.__port
 
     @port.setter
     def port(self, value):
         self.__port = value
 
     @property
+    def download_directory(self):
+        """Directory path for downloading files (**Default** current directory).
+
+        :type: :class:`str`
+        """
+        return self.__download_directory
+
+    @download_directory.setter
+    def download_directory(self, value):
+        self.__download_directory = value
+
+    @property
+    def download_chunk_size(self):
+        """Chunk size for downloading files (**Default** 8*1024 bytes).
+
+        :type: :class:`int`
+        """
+        return self.__download_chunk_size
+
+    @download_chunk_size.setter
+    def download_chunk_size(self, value):
+        self.__download_chunk_size = value
+
+    @property
     def max_retry_attempts(self):
         """Maximum allowed retry attempts for a HTTP call in case of response status codes [408, 503, 504] (**Default** 5).
 
         :type: :class:`int`
         """
         return self.__max_retry_attempts
 
@@ -376,23 +407,19 @@
     @debug.setter
     def debug(self, value):
         self.__debug = value
         if self.__debug:
             # if debug status is True, turn on debug logging
             for _, logger in six.iteritems(self.logger):
                 logger.setLevel(logging.DEBUG)
-            # turn on httplib debug
-            httplib.HTTPConnection.debuglevel = 1
         else:
             # if debug status is False, turn off debug logging,
             # setting log level to default `logging.INFO`
             for _, logger in six.iteritems(self.logger):
                 logger.setLevel(logging.INFO)
-            # turn off httplib debug
-            httplib.HTTPConnection.debuglevel = 0
 
     @property
     def logger_format(self):
         """The log format for file or stream log handler.
 
         :type: :class:`str`
         """
@@ -487,10 +514,10 @@
 
     def to_debug_report(self):
         """Prints the information about current OS, Python, API and SDK versions for debugging purposes
         """
         return "Python SDK Debug Report:\n"\
                "OS: {env}\n"\
                "Python Version: {pyversion}\n"\
-               "Version of the API: 4.0.1-alpha-1\n"\
-               "SDK Package Version: 4.0.1a1".\
+               "Version of the API: 4.0.1-beta-1\n"\
+               "SDK Package Version: 4.0.1b1".\
                format(env=sys.platform, pyversion=sys.version)
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfcommon/v1/config/KVPairvalue.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/DeleteNetworkSecurityPolicyApiResponsedata.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class KVPairvalue(object):
+class DeleteNetworkSecurityPolicyApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,51 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'String': 'str',
-        'Integer': 'int',
-        'Boolean': 'bool',
-        'List<String>': 'list[str]',
-        'Map<String, String>': 'dict(str, str)'
+        'prism.v4.config.TaskReference': 'prism.v4.config.TaskReference',
+        'microseg.v4.error.ErrorResponse': 'microseg.v4.error.ErrorResponse'
     }
 
-    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$valueItemDiscriminator'
+    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfcommon.v1.config.KVPairvalue'
+        return 'OneOfmicroseg.v4.config.DeleteNetworkSecurityPolicyApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -117,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in KVPairvalue.discriminator_value_class_map.values():
-            return list(KVPairvalue.discriminator_value_class_map.keys())[list(KVPairvalue.discriminator_value_class_map.values()).index(disc)]
+        if disc in DeleteNetworkSecurityPolicyApiResponsedata.discriminator_value_class_map.values():
+            return list(DeleteNetworkSecurityPolicyApiResponsedata.discriminator_value_class_map.keys())[list(DeleteNetworkSecurityPolicyApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(KVPairvalue, dict):
+        if issubclass(DeleteNetworkSecurityPolicyApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -172,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, KVPairvalue):
+        if not isinstance(other, DeleteNetworkSecurityPolicyApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/AddressGroupGetResponsedata.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/GetAddressGroupApiResponsedata.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class AddressGroupGetResponsedata(object):
+class GetAddressGroupApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -52,35 +53,35 @@
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfmicroseg.v4.config.AddressGroupGetResponsedata'
+        return 'OneOfmicroseg.v4.config.GetAddressGroupApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in AddressGroupGetResponsedata.discriminator_value_class_map.values():
-            return list(AddressGroupGetResponsedata.discriminator_value_class_map.keys())[list(AddressGroupGetResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in GetAddressGroupApiResponsedata.discriminator_value_class_map.values():
+            return list(GetAddressGroupApiResponsedata.discriminator_value_class_map.keys())[list(GetAddressGroupApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(AddressGroupGetResponsedata, dict):
+        if issubclass(GetAddressGroupApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, AddressGroupGetResponsedata):
+        if not isinstance(other, GetAddressGroupApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/AddressGroupListResponsedata.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/CreateAddressGroupApiResponsedata.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class AddressGroupListResponsedata(object):
+class CreateAddressGroupApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'List<microseg.v4.config.AddressGroup>': 'list[microseg.v4.config.AddressGroup]',
+        'prism.v4.config.TaskReference': 'prism.v4.config.TaskReference',
         'microseg.v4.error.ErrorResponse': 'microseg.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfmicroseg.v4.config.AddressGroupListResponsedata'
+        return 'OneOfmicroseg.v4.config.CreateAddressGroupApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in AddressGroupListResponsedata.discriminator_value_class_map.values():
-            return list(AddressGroupListResponsedata.discriminator_value_class_map.keys())[list(AddressGroupListResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in CreateAddressGroupApiResponsedata.discriminator_value_class_map.values():
+            return list(CreateAddressGroupApiResponsedata.discriminator_value_class_map.keys())[list(CreateAddressGroupApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(AddressGroupListResponsedata, dict):
+        if issubclass(CreateAddressGroupApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, AddressGroupListResponsedata):
+        if not isinstance(other, CreateAddressGroupApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/AddressGroupPolicyAssociationResponsedata.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/ListAddressGroupsApiResponsedata.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class AddressGroupPolicyAssociationResponsedata(object):
+class ListAddressGroupsApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'List<microseg.v4.config.AddressGroupPolicyReference>': 'list[microseg.v4.config.AddressGroupPolicyReference]',
+        'List<microseg.v4.config.AddressGroup>': 'list[microseg.v4.config.AddressGroup]',
         'microseg.v4.error.ErrorResponse': 'microseg.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfmicroseg.v4.config.AddressGroupPolicyAssociationResponsedata'
+        return 'OneOfmicroseg.v4.config.ListAddressGroupsApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in AddressGroupPolicyAssociationResponsedata.discriminator_value_class_map.values():
-            return list(AddressGroupPolicyAssociationResponsedata.discriminator_value_class_map.keys())[list(AddressGroupPolicyAssociationResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in ListAddressGroupsApiResponsedata.discriminator_value_class_map.values():
+            return list(ListAddressGroupsApiResponsedata.discriminator_value_class_map.keys())[list(ListAddressGroupsApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(AddressGroupPolicyAssociationResponsedata, dict):
+        if issubclass(ListAddressGroupsApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, AddressGroupPolicyAssociationResponsedata):
+        if not isinstance(other, ListAddressGroupsApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/AddressGroupTaskResponsedata.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/UpdateAddressGroupApiResponsedata.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class AddressGroupTaskResponsedata(object):
+class UpdateAddressGroupApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -52,35 +53,35 @@
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfmicroseg.v4.config.AddressGroupTaskResponsedata'
+        return 'OneOfmicroseg.v4.config.UpdateAddressGroupApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in AddressGroupTaskResponsedata.discriminator_value_class_map.values():
-            return list(AddressGroupTaskResponsedata.discriminator_value_class_map.keys())[list(AddressGroupTaskResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in UpdateAddressGroupApiResponsedata.discriminator_value_class_map.values():
+            return list(UpdateAddressGroupApiResponsedata.discriminator_value_class_map.keys())[list(UpdateAddressGroupApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(AddressGroupTaskResponsedata, dict):
+        if issubclass(UpdateAddressGroupApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, AddressGroupTaskResponsedata):
+        if not isinstance(other, UpdateAddressGroupApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/BannerGetResponsedata.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/DeleteAddressGroupApiResponsedata.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class BannerGetResponsedata(object):
+class DeleteAddressGroupApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'microseg.v4.config.BannerResponse': 'microseg.v4.config.BannerResponse',
+        'prism.v4.config.TaskReference': 'prism.v4.config.TaskReference',
         'microseg.v4.error.ErrorResponse': 'microseg.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfmicroseg.v4.config.BannerGetResponsedata'
+        return 'OneOfmicroseg.v4.config.DeleteAddressGroupApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in BannerGetResponsedata.discriminator_value_class_map.values():
-            return list(BannerGetResponsedata.discriminator_value_class_map.keys())[list(BannerGetResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in DeleteAddressGroupApiResponsedata.discriminator_value_class_map.values():
+            return list(DeleteAddressGroupApiResponsedata.discriminator_value_class_map.keys())[list(DeleteAddressGroupApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(BannerGetResponsedata, dict):
+        if issubclass(DeleteAddressGroupApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, BannerGetResponsedata):
+        if not isinstance(other, DeleteAddressGroupApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/ConfigMigrationPreviewGetResponsedata.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/GetDirectoryServerConfigApiResponsedata.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class ConfigMigrationPreviewGetResponsedata(object):
+class GetDirectoryServerConfigApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'microseg.v4.config.ConfigMigrationPreviewResponse': 'microseg.v4.config.ConfigMigrationPreviewResponse',
+        'microseg.v4.config.DirectoryServerConfig': 'microseg.v4.config.DirectoryServerConfig',
         'microseg.v4.error.ErrorResponse': 'microseg.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfmicroseg.v4.config.ConfigMigrationPreviewGetResponsedata'
+        return 'OneOfmicroseg.v4.config.GetDirectoryServerConfigApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in ConfigMigrationPreviewGetResponsedata.discriminator_value_class_map.values():
-            return list(ConfigMigrationPreviewGetResponsedata.discriminator_value_class_map.keys())[list(ConfigMigrationPreviewGetResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in GetDirectoryServerConfigApiResponsedata.discriminator_value_class_map.values():
+            return list(GetDirectoryServerConfigApiResponsedata.discriminator_value_class_map.keys())[list(GetDirectoryServerConfigApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ConfigMigrationPreviewGetResponsedata, dict):
+        if issubclass(GetDirectoryServerConfigApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ConfigMigrationPreviewGetResponsedata):
+        if not isinstance(other, GetDirectoryServerConfigApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/ConfigMigrationSummaryGetResponsedata.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/CreateDirectoryServerConfigApiResponsedata.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class ConfigMigrationSummaryGetResponsedata(object):
+class CreateDirectoryServerConfigApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'microseg.v4.config.ConfigMigrationSummary': 'microseg.v4.config.ConfigMigrationSummary',
+        'prism.v4.config.TaskReference': 'prism.v4.config.TaskReference',
         'microseg.v4.error.ErrorResponse': 'microseg.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfmicroseg.v4.config.ConfigMigrationSummaryGetResponsedata'
+        return 'OneOfmicroseg.v4.config.CreateDirectoryServerConfigApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in ConfigMigrationSummaryGetResponsedata.discriminator_value_class_map.values():
-            return list(ConfigMigrationSummaryGetResponsedata.discriminator_value_class_map.keys())[list(ConfigMigrationSummaryGetResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in CreateDirectoryServerConfigApiResponsedata.discriminator_value_class_map.values():
+            return list(CreateDirectoryServerConfigApiResponsedata.discriminator_value_class_map.keys())[list(CreateDirectoryServerConfigApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ConfigMigrationSummaryGetResponsedata, dict):
+        if issubclass(CreateDirectoryServerConfigApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ConfigMigrationSummaryGetResponsedata):
+        if not isinstance(other, CreateDirectoryServerConfigApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/DirectoryServerCreateResponsedata.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/DeleteServiceGroupApiResponsedata.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class DirectoryServerCreateResponsedata(object):
+class DeleteServiceGroupApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -52,35 +53,35 @@
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfmicroseg.v4.config.DirectoryServerCreateResponsedata'
+        return 'OneOfmicroseg.v4.config.DeleteServiceGroupApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in DirectoryServerCreateResponsedata.discriminator_value_class_map.values():
-            return list(DirectoryServerCreateResponsedata.discriminator_value_class_map.keys())[list(DirectoryServerCreateResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in DeleteServiceGroupApiResponsedata.discriminator_value_class_map.values():
+            return list(DeleteServiceGroupApiResponsedata.discriminator_value_class_map.keys())[list(DeleteServiceGroupApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(DirectoryServerCreateResponsedata, dict):
+        if issubclass(DeleteServiceGroupApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, DirectoryServerCreateResponsedata):
+        if not isinstance(other, DeleteServiceGroupApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/DirectoryServerDeleteResponsedata.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/UpdateServiceGroupApiResponsedata.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class DirectoryServerDeleteResponsedata(object):
+class UpdateServiceGroupApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -52,35 +53,35 @@
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfmicroseg.v4.config.DirectoryServerDeleteResponsedata'
+        return 'OneOfmicroseg.v4.config.UpdateServiceGroupApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in DirectoryServerDeleteResponsedata.discriminator_value_class_map.values():
-            return list(DirectoryServerDeleteResponsedata.discriminator_value_class_map.keys())[list(DirectoryServerDeleteResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in UpdateServiceGroupApiResponsedata.discriminator_value_class_map.values():
+            return list(UpdateServiceGroupApiResponsedata.discriminator_value_class_map.keys())[list(UpdateServiceGroupApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(DirectoryServerDeleteResponsedata, dict):
+        if issubclass(UpdateServiceGroupApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, DirectoryServerDeleteResponsedata):
+        if not isinstance(other, UpdateServiceGroupApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/DirectoryServerGetResponsedata.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/UpdateDirectoryServerConfigApiResponsedata.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class DirectoryServerGetResponsedata(object):
+class UpdateDirectoryServerConfigApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'microseg.v4.config.DirectoryServer': 'microseg.v4.config.DirectoryServer',
+        'prism.v4.config.TaskReference': 'prism.v4.config.TaskReference',
         'microseg.v4.error.ErrorResponse': 'microseg.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfmicroseg.v4.config.DirectoryServerGetResponsedata'
+        return 'OneOfmicroseg.v4.config.UpdateDirectoryServerConfigApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in DirectoryServerGetResponsedata.discriminator_value_class_map.values():
-            return list(DirectoryServerGetResponsedata.discriminator_value_class_map.keys())[list(DirectoryServerGetResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in UpdateDirectoryServerConfigApiResponsedata.discriminator_value_class_map.values():
+            return list(UpdateDirectoryServerConfigApiResponsedata.discriminator_value_class_map.keys())[list(UpdateDirectoryServerConfigApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(DirectoryServerGetResponsedata, dict):
+        if issubclass(UpdateDirectoryServerConfigApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, DirectoryServerGetResponsedata):
+        if not isinstance(other, UpdateDirectoryServerConfigApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/DirectoryServerListResponsedata.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/GetServiceGroupApiResponsedata.py`

 * *Files 13% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class DirectoryServerListResponsedata(object):
+class GetServiceGroupApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'List<microseg.v4.config.DirectoryServer>': 'list[microseg.v4.config.DirectoryServer]',
+        'microseg.v4.config.ServiceGroup': 'microseg.v4.config.ServiceGroup',
         'microseg.v4.error.ErrorResponse': 'microseg.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfmicroseg.v4.config.DirectoryServerListResponsedata'
+        return 'OneOfmicroseg.v4.config.GetServiceGroupApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in DirectoryServerListResponsedata.discriminator_value_class_map.values():
-            return list(DirectoryServerListResponsedata.discriminator_value_class_map.keys())[list(DirectoryServerListResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in GetServiceGroupApiResponsedata.discriminator_value_class_map.values():
+            return list(GetServiceGroupApiResponsedata.discriminator_value_class_map.keys())[list(GetServiceGroupApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(DirectoryServerListResponsedata, dict):
+        if issubclass(GetServiceGroupApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, DirectoryServerListResponsedata):
+        if not isinstance(other, GetServiceGroupApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/DirectoryServerUpdateResponsedata.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/ListServiceGroupsApiResponsedata.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class DirectoryServerUpdateResponsedata(object):
+class ListServiceGroupsApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'prism.v4.config.TaskReference': 'prism.v4.config.TaskReference',
+        'List<microseg.v4.config.ServiceGroup>': 'list[microseg.v4.config.ServiceGroup]',
         'microseg.v4.error.ErrorResponse': 'microseg.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfmicroseg.v4.config.DirectoryServerUpdateResponsedata'
+        return 'OneOfmicroseg.v4.config.ListServiceGroupsApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in DirectoryServerUpdateResponsedata.discriminator_value_class_map.values():
-            return list(DirectoryServerUpdateResponsedata.discriminator_value_class_map.keys())[list(DirectoryServerUpdateResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in ListServiceGroupsApiResponsedata.discriminator_value_class_map.values():
+            return list(ListServiceGroupsApiResponsedata.discriminator_value_class_map.keys())[list(ListServiceGroupsApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(DirectoryServerUpdateResponsedata, dict):
+        if issubclass(ListServiceGroupsApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, DirectoryServerUpdateResponsedata):
+        if not isinstance(other, ListServiceGroupsApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/DsCategoryMappingCreateResponsedata.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/GetDsCategoryMappingApiResponsedata.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class DsCategoryMappingCreateResponsedata(object):
+class GetDsCategoryMappingApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'prism.v4.config.TaskReference': 'prism.v4.config.TaskReference',
+        'microseg.v4.config.CategoryMapping': 'microseg.v4.config.CategoryMapping',
         'microseg.v4.error.ErrorResponse': 'microseg.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfmicroseg.v4.config.DsCategoryMappingCreateResponsedata'
+        return 'OneOfmicroseg.v4.config.GetDsCategoryMappingApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in DsCategoryMappingCreateResponsedata.discriminator_value_class_map.values():
-            return list(DsCategoryMappingCreateResponsedata.discriminator_value_class_map.keys())[list(DsCategoryMappingCreateResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in GetDsCategoryMappingApiResponsedata.discriminator_value_class_map.values():
+            return list(GetDsCategoryMappingApiResponsedata.discriminator_value_class_map.keys())[list(GetDsCategoryMappingApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(DsCategoryMappingCreateResponsedata, dict):
+        if issubclass(GetDsCategoryMappingApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, DsCategoryMappingCreateResponsedata):
+        if not isinstance(other, GetDsCategoryMappingApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/DsCategoryMappingDeleteResponsedata.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/operation/UpgradeJobspec.py`

 * *Files 11% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class DsCategoryMappingDeleteResponsedata(object):
+class UpgradeJobspec(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'prism.v4.config.TaskReference': 'prism.v4.config.TaskReference',
-        'microseg.v4.error.ErrorResponse': 'microseg.v4.error.ErrorResponse'
+        'microseg.v4.operation.UpgradeSpec': 'microseg.v4.operation.UpgradeSpec',
+        'microseg.v4.operation.DryRunSpec': 'microseg.v4.operation.DryRunSpec'
     }
 
-    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
+    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$specItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfmicroseg.v4.config.DsCategoryMappingDeleteResponsedata'
+        return 'OneOfmicroseg.v4.operation.UpgradeJobspec'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in DsCategoryMappingDeleteResponsedata.discriminator_value_class_map.values():
-            return list(DsCategoryMappingDeleteResponsedata.discriminator_value_class_map.keys())[list(DsCategoryMappingDeleteResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in UpgradeJobspec.discriminator_value_class_map.values():
+            return list(UpgradeJobspec.discriminator_value_class_map.keys())[list(UpgradeJobspec.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(DsCategoryMappingDeleteResponsedata, dict):
+        if issubclass(UpgradeJobspec, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, DsCategoryMappingDeleteResponsedata):
+        if not isinstance(other, UpgradeJobspec):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/DsCategoryMappingGetResponsedata.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/error/ErrorResponse.py`

 * *Files 11% similar despite different names*

```diff
@@ -3,161 +3,190 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
+import ntnx_microseg_py_client.models
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.error.ErrorResponseerror import ErrorResponseerror  # noqa: F401,E501
 
-class DsCategoryMappingGetResponsedata(object):
+class ErrorResponse(object):
 
-    """
+    """This schema is auto-generated by the Open API Dev Platform as REST response for 4xx and 5xx error responses.
 
+    :param error: (:attr:`error`) 
+    :type error: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
+        'error': 'OneOfmicroseg.v4.error.ErrorResponseerror',
+        '_reserved': 'dict(str, object)',
+        '_object_type': 'str',
+        '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
+        'error': 'error',
+        '_reserved': '$reserved',
+        '_object_type': '$objectType',
+        '_unknown_fields': '$unknownFields',
     }
 
-    discriminator_value_class_map = {
-        'EMPTY_LIST': 'list[str]',
-        'EMPTY_MAP': 'dict(str, object)',
-        'microseg.v4.config.CategoryMapping': 'microseg.v4.config.CategoryMapping',
-        'microseg.v4.error.ErrorResponse': 'microseg.v4.error.ErrorResponse'
-    }
-
-    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
-    def __init__(self, *args, **kwargs):  # noqa: E501
+    def __init__(self, error=None, *args, **kwargs):  # noqa: E501
+        self.__error = None
         self.discriminator = None
+        if error is not None:
+            self.__error = error
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfmicroseg.v4.config.DsCategoryMappingGetResponsedata'
+        return 'microseg.v4.error.ErrorResponse'
 
-    def _initialize_fq_object_type(self):
-        return ''
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
-    def get_real_child_model(self, discriminator):
-        """Returns the real base class specified by the discriminator"""
-        if discriminator is not None and discriminator in self.discriminator_value_class_map:
-            return self.discriminator_value_class_map.get(discriminator)
-        return None
-
-    @staticmethod
-    def get_discriminator_from_object(value):
-        """Returns the discriminator for the provided object.
+    @property
+    def error(self):
         """
-        if not value:
-            disc = 'list[str]'
-        elif hasattr(value, "_object_type"):
-            disc = value.get_object_type()
-        elif type(value) == list:
-            if hasattr(value[0], "_object_type"):
-                datatype = value[0].get_object_type()
-            else:
-                datatype = type(value[0]).__name__
-            disc = 'list[' + datatype + ']'
-        elif type(value) == dict:
-            if hasattr(next(iter(value.values())), "_object_type"):
-                datatype = next(iter(value.values())).get_object_type()
-            else:
-                datatype = type(next(iter(value.values()))).__name__
-            disc = 'dict(str, ' + datatype + ')'
-        else:
-            disc = type(value).__name__
-        if disc in DsCategoryMappingGetResponsedata.discriminator_value_class_map.values():
-            return list(DsCategoryMappingGetResponsedata.discriminator_value_class_map.keys())[list(DsCategoryMappingGetResponsedata.discriminator_value_class_map.values()).index(disc)]
-        return None
+        
+
+        :type:
+                :class:`~ntnx_microseg_py_client.models.microseg.v4.error.AppMessage` | 
+                :class:`~ntnx_microseg_py_client.models.microseg.v4.error.SchemaValidationError`
+                    """  # noqa: E501
+        return self.__error
+
+    @error.setter
+    def error(self, error):
+
+        self.__error = error
+
+    @property
+    def _reserved(self):
+        """
+        
 
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
+        return self.__dollar_reserved
+
+    @property
+    def _object_type(self):
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__dollar_object_type
+
+    @property
+    def _unknown_fields(self):
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
+        return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
+            if attr_type.startswith('OneOf'):
+                type = getattr(ntnx_microseg_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(DsCategoryMappingGetResponsedata, dict):
+        if issubclass(ErrorResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +198,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, DsCategoryMappingGetResponsedata):
+        if not isinstance(other, ErrorResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/DsCategoryMappingUpdateResponsedata.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/ListDsCategoryMappingsApiResponsedata.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class DsCategoryMappingUpdateResponsedata(object):
+class ListDsCategoryMappingsApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'prism.v4.config.TaskReference': 'prism.v4.config.TaskReference',
+        'List<microseg.v4.config.CategoryMapping>': 'list[microseg.v4.config.CategoryMapping]',
         'microseg.v4.error.ErrorResponse': 'microseg.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfmicroseg.v4.config.DsCategoryMappingUpdateResponsedata'
+        return 'OneOfmicroseg.v4.config.ListDsCategoryMappingsApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in DsCategoryMappingUpdateResponsedata.discriminator_value_class_map.values():
-            return list(DsCategoryMappingUpdateResponsedata.discriminator_value_class_map.keys())[list(DsCategoryMappingUpdateResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in ListDsCategoryMappingsApiResponsedata.discriminator_value_class_map.values():
+            return list(ListDsCategoryMappingsApiResponsedata.discriminator_value_class_map.keys())[list(ListDsCategoryMappingsApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(DsCategoryMappingUpdateResponsedata, dict):
+        if issubclass(ListDsCategoryMappingsApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, DsCategoryMappingUpdateResponsedata):
+        if not isinstance(other, ListDsCategoryMappingsApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/DsCategoryMappingsGetListResponsedata.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/DeleteDsCategoryMappingApiResponsedata.py`

 * *Files 9% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class DsCategoryMappingsGetListResponsedata(object):
+class DeleteDsCategoryMappingApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'List<microseg.v4.config.CategoryMapping>': 'list[microseg.v4.config.CategoryMapping]',
+        'prism.v4.config.TaskReference': 'prism.v4.config.TaskReference',
         'microseg.v4.error.ErrorResponse': 'microseg.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfmicroseg.v4.config.DsCategoryMappingsGetListResponsedata'
+        return 'OneOfmicroseg.v4.config.DeleteDsCategoryMappingApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in DsCategoryMappingsGetListResponsedata.discriminator_value_class_map.values():
-            return list(DsCategoryMappingsGetListResponsedata.discriminator_value_class_map.keys())[list(DsCategoryMappingsGetListResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in DeleteDsCategoryMappingApiResponsedata.discriminator_value_class_map.values():
+            return list(DeleteDsCategoryMappingApiResponsedata.discriminator_value_class_map.keys())[list(DeleteDsCategoryMappingApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(DsCategoryMappingsGetListResponsedata, dict):
+        if issubclass(DeleteDsCategoryMappingApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, DsCategoryMappingsGetListResponsedata):
+        if not isinstance(other, DeleteDsCategoryMappingApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/MigrationConfigSpecspec.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/common/v1/config/FQDN.py`

 * *Files 12% similar despite different names*

```diff
@@ -3,161 +3,188 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class MigrationConfigSpecspec(object):
+class FQDN(object):
 
-    """
+    """A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System. 
 
+    :param value: (:attr:`value`) 
+    :type value: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
+        'value': 'str',
+        '_reserved': 'dict(str, object)',
+        '_object_type': 'str',
+        '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
+        'value': 'value',
+        '_reserved': '$reserved',
+        '_object_type': '$objectType',
+        '_unknown_fields': '$unknownFields',
     }
 
-    discriminator_value_class_map = {
-        'EMPTY_LIST': 'list[str]',
-        'EMPTY_MAP': 'dict(str, object)',
-        'microseg.v4.config.MigrationConfig': 'microseg.v4.config.MigrationConfig',
-        'microseg.v4.config.MigrationSummary': 'microseg.v4.config.MigrationSummary'
-    }
-
-    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$specItemDiscriminator'
 
 
-    def __init__(self, *args, **kwargs):  # noqa: E501
+    def __init__(self, value=None, *args, **kwargs):  # noqa: E501
+        self.__value = None
         self.discriminator = None
+        if value is not None:
+            self.__value = value
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfmicroseg.v4.config.MigrationConfigSpecspec'
+        return 'common.v1.config.FQDN'
 
-    def _initialize_fq_object_type(self):
-        return ''
+    def _initialize_object_version(self):
+        return 'v1.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
-    def get_real_child_model(self, discriminator):
-        """Returns the real base class specified by the discriminator"""
-        if discriminator is not None and discriminator in self.discriminator_value_class_map:
-            return self.discriminator_value_class_map.get(discriminator)
-        return None
-
-    @staticmethod
-    def get_discriminator_from_object(value):
-        """Returns the discriminator for the provided object.
+    @property
+    def value(self):
         """
-        if not value:
-            disc = 'list[str]'
-        elif hasattr(value, "_object_type"):
-            disc = value.get_object_type()
-        elif type(value) == list:
-            if hasattr(value[0], "_object_type"):
-                datatype = value[0].get_object_type()
-            else:
-                datatype = type(value[0]).__name__
-            disc = 'list[' + datatype + ']'
-        elif type(value) == dict:
-            if hasattr(next(iter(value.values())), "_object_type"):
-                datatype = next(iter(value.values())).get_object_type()
-            else:
-                datatype = type(next(iter(value.values()))).__name__
-            disc = 'dict(str, ' + datatype + ')'
-        else:
-            disc = type(value).__name__
-        if disc in MigrationConfigSpecspec.discriminator_value_class_map.values():
-            return list(MigrationConfigSpecspec.discriminator_value_class_map.keys())[list(MigrationConfigSpecspec.discriminator_value_class_map.values()).index(disc)]
-        return None
+        
 
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__value
+
+    @value.setter
+    def value(self, value):
+        if value is not None and not re.search('^(?:[a-z0-9][\\w\\-]*[a-z0-9]*\\.)*(?:(?:(?:[a-z0-9][\\w\\-]*[a-z0-9]*)(?:\\.[a-z0-9]+)?))$', value):  # noqa: E501
+            raise ValueError(r"Invalid value for `value`, must be a follow pattern or equal to `/^(?:[a-z0-9][\\w\\-]*[a-z0-9]*\\.)*(?:(?:(?:[a-z0-9][\\w\\-]*[a-z0-9]*)(?:\\.[a-z0-9]+)?))$/`")  # noqa: E501
+
+        self.__value = value
+
+    @property
+    def _reserved(self):
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
+        return self.__dollar_reserved
+
+    @property
+    def _object_type(self):
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__dollar_object_type
+
+    @property
+    def _unknown_fields(self):
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
+        return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(MigrationConfigSpecspec, dict):
+        if issubclass(FQDN, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +196,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, MigrationConfigSpecspec):
+        if not isinstance(other, FQDN):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/MigrationConfigTaskResponsedata.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/CreateDsCategoryMappingApiResponsedata.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class MigrationConfigTaskResponsedata(object):
+class CreateDsCategoryMappingApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -52,35 +53,35 @@
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfmicroseg.v4.config.MigrationConfigTaskResponsedata'
+        return 'OneOfmicroseg.v4.config.CreateDsCategoryMappingApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in MigrationConfigTaskResponsedata.discriminator_value_class_map.values():
-            return list(MigrationConfigTaskResponsedata.discriminator_value_class_map.keys())[list(MigrationConfigTaskResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in CreateDsCategoryMappingApiResponsedata.discriminator_value_class_map.values():
+            return list(CreateDsCategoryMappingApiResponsedata.discriminator_value_class_map.keys())[list(CreateDsCategoryMappingApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(MigrationConfigTaskResponsedata, dict):
+        if issubclass(CreateDsCategoryMappingApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, MigrationConfigTaskResponsedata):
+        if not isinstance(other, CreateDsCategoryMappingApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/NetworkSecurityPolicyGetListResponsedata.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/GetNetworkSecurityPolicyApiResponsedata.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class NetworkSecurityPolicyGetListResponsedata(object):
+class GetNetworkSecurityPolicyApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,49 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'List<microseg.v4.config.NetworkSecurityPolicy>': 'list[microseg.v4.config.NetworkSecurityPolicy]',
-        'microseg.v4.config.FileWrapper': 'microseg.v4.config.FileWrapper',
+        'microseg.v4.config.NetworkSecurityPolicy': 'microseg.v4.config.NetworkSecurityPolicy',
         'microseg.v4.error.ErrorResponse': 'microseg.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfmicroseg.v4.config.NetworkSecurityPolicyGetListResponsedata'
+        return 'OneOfmicroseg.v4.config.GetNetworkSecurityPolicyApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -115,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in NetworkSecurityPolicyGetListResponsedata.discriminator_value_class_map.values():
-            return list(NetworkSecurityPolicyGetListResponsedata.discriminator_value_class_map.keys())[list(NetworkSecurityPolicyGetListResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in GetNetworkSecurityPolicyApiResponsedata.discriminator_value_class_map.values():
+            return list(GetNetworkSecurityPolicyApiResponsedata.discriminator_value_class_map.keys())[list(GetNetworkSecurityPolicyApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(NetworkSecurityPolicyGetListResponsedata, dict):
+        if issubclass(GetNetworkSecurityPolicyApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -170,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, NetworkSecurityPolicyGetListResponsedata):
+        if not isinstance(other, GetNetworkSecurityPolicyApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/NetworkSecurityPolicyGetResponsedata.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/CreateNetworkSecurityPolicyApiResponsedata.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class NetworkSecurityPolicyGetResponsedata(object):
+class CreateNetworkSecurityPolicyApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'microseg.v4.config.NetworkSecurityPolicy': 'microseg.v4.config.NetworkSecurityPolicy',
+        'prism.v4.config.TaskReference': 'prism.v4.config.TaskReference',
         'microseg.v4.error.ErrorResponse': 'microseg.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfmicroseg.v4.config.NetworkSecurityPolicyGetResponsedata'
+        return 'OneOfmicroseg.v4.config.CreateNetworkSecurityPolicyApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in NetworkSecurityPolicyGetResponsedata.discriminator_value_class_map.values():
-            return list(NetworkSecurityPolicyGetResponsedata.discriminator_value_class_map.keys())[list(NetworkSecurityPolicyGetResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in CreateNetworkSecurityPolicyApiResponsedata.discriminator_value_class_map.values():
+            return list(CreateNetworkSecurityPolicyApiResponsedata.discriminator_value_class_map.keys())[list(CreateNetworkSecurityPolicyApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(NetworkSecurityPolicyGetResponsedata, dict):
+        if issubclass(CreateNetworkSecurityPolicyApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, NetworkSecurityPolicyGetResponsedata):
+        if not isinstance(other, CreateNetworkSecurityPolicyApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/NetworkSecurityPolicyImportResponsedata.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/UpdateNetworkSecurityPolicyApiResponsedata.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class NetworkSecurityPolicyImportResponsedata(object):
+class UpdateNetworkSecurityPolicyApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -40,48 +41,47 @@
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
         'prism.v4.config.TaskReference': 'prism.v4.config.TaskReference',
-        'List<microseg.v4.config.NetworkSecurityPolicyImportEntity>': 'list[microseg.v4.config.NetworkSecurityPolicyImportEntity]',
         'microseg.v4.error.ErrorResponse': 'microseg.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfmicroseg.v4.config.NetworkSecurityPolicyImportResponsedata'
+        return 'OneOfmicroseg.v4.config.UpdateNetworkSecurityPolicyApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -115,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in NetworkSecurityPolicyImportResponsedata.discriminator_value_class_map.values():
-            return list(NetworkSecurityPolicyImportResponsedata.discriminator_value_class_map.keys())[list(NetworkSecurityPolicyImportResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in UpdateNetworkSecurityPolicyApiResponsedata.discriminator_value_class_map.values():
+            return list(UpdateNetworkSecurityPolicyApiResponsedata.discriminator_value_class_map.keys())[list(UpdateNetworkSecurityPolicyApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(NetworkSecurityPolicyImportResponsedata, dict):
+        if issubclass(UpdateNetworkSecurityPolicyApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -170,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, NetworkSecurityPolicyImportResponsedata):
+        if not isinstance(other, UpdateNetworkSecurityPolicyApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/NetworkSecurityPolicyRulesGetResponsedata.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/CreateServiceGroupApiResponsedata.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class NetworkSecurityPolicyRulesGetResponsedata(object):
+class CreateServiceGroupApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'List<microseg.v4.config.NetworkSecurityPolicyRule>': 'list[microseg.v4.config.NetworkSecurityPolicyRule]',
+        'prism.v4.config.TaskReference': 'prism.v4.config.TaskReference',
         'microseg.v4.error.ErrorResponse': 'microseg.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfmicroseg.v4.config.NetworkSecurityPolicyRulesGetResponsedata'
+        return 'OneOfmicroseg.v4.config.CreateServiceGroupApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in NetworkSecurityPolicyRulesGetResponsedata.discriminator_value_class_map.values():
-            return list(NetworkSecurityPolicyRulesGetResponsedata.discriminator_value_class_map.keys())[list(NetworkSecurityPolicyRulesGetResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in CreateServiceGroupApiResponsedata.discriminator_value_class_map.values():
+            return list(CreateServiceGroupApiResponsedata.discriminator_value_class_map.keys())[list(CreateServiceGroupApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(NetworkSecurityPolicyRulesGetResponsedata, dict):
+        if issubclass(CreateServiceGroupApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, NetworkSecurityPolicyRulesGetResponsedata):
+        if not isinstance(other, CreateServiceGroupApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/NetworkSecurityPolicyRulespec.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/NetworkSecurityPolicyRulespec.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
 class NetworkSecurityPolicyRulespec(object):
 
     """
 
 
     """
@@ -39,49 +40,49 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'microseg.v4.config.NSPTwoEnvIsolationRuleSpec': 'microseg.v4.config.NSPTwoEnvIsolationRuleSpec',
-        'microseg.v4.config.NSPApplicationRuleSpec': 'microseg.v4.config.NSPApplicationRuleSpec',
-        'microseg.v4.config.NSPIntraEntityGroupRuleSpec': 'microseg.v4.config.NSPIntraEntityGroupRuleSpec'
+        'microseg.v4.config.TwoEnvIsolationRuleSpec': 'microseg.v4.config.TwoEnvIsolationRuleSpec',
+        'microseg.v4.config.ApplicationRuleSpec': 'microseg.v4.config.ApplicationRuleSpec',
+        'microseg.v4.config.IntraEntityGroupRuleSpec': 'microseg.v4.config.IntraEntityGroupRuleSpec'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$specItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'OneOfmicroseg.v4.config.NetworkSecurityPolicyRulespec'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -128,28 +129,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/NetworkSecurityPolicyTaskResponsedata.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/CreateNetworkSecurityPolicyExportApiResponsedata.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class NetworkSecurityPolicyTaskResponsedata(object):
+class CreateNetworkSecurityPolicyExportApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -52,35 +53,35 @@
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfmicroseg.v4.config.NetworkSecurityPolicyTaskResponsedata'
+        return 'OneOfmicroseg.v4.config.CreateNetworkSecurityPolicyExportApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in NetworkSecurityPolicyTaskResponsedata.discriminator_value_class_map.values():
-            return list(NetworkSecurityPolicyTaskResponsedata.discriminator_value_class_map.keys())[list(NetworkSecurityPolicyTaskResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in CreateNetworkSecurityPolicyExportApiResponsedata.discriminator_value_class_map.values():
+            return list(CreateNetworkSecurityPolicyExportApiResponsedata.discriminator_value_class_map.keys())[list(CreateNetworkSecurityPolicyExportApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(NetworkSecurityPolicyTaskResponsedata, dict):
+        if issubclass(CreateNetworkSecurityPolicyExportApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, NetworkSecurityPolicyTaskResponsedata):
+        if not isinstance(other, CreateNetworkSecurityPolicyExportApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/ServiceGroupGetResponsedata.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfcommon/v1/config/KVPairvalue.py`

 * *Files 14% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class ServiceGroupGetResponsedata(object):
+class KVPairvalue(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,51 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'microseg.v4.config.ServiceGroup': 'microseg.v4.config.ServiceGroup',
-        'microseg.v4.error.ErrorResponse': 'microseg.v4.error.ErrorResponse'
+        'String': 'str',
+        'Integer': 'int',
+        'Boolean': 'bool',
+        'List<String>': 'list[str]',
+        'Map<String, String>': 'dict(str, str)'
     }
 
-    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
+    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$valueItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfmicroseg.v4.config.ServiceGroupGetResponsedata'
+        return 'OneOfcommon.v1.config.KVPairvalue'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +118,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in ServiceGroupGetResponsedata.discriminator_value_class_map.values():
-            return list(ServiceGroupGetResponsedata.discriminator_value_class_map.keys())[list(ServiceGroupGetResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in KVPairvalue.discriminator_value_class_map.values():
+            return list(KVPairvalue.discriminator_value_class_map.keys())[list(KVPairvalue.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ServiceGroupGetResponsedata, dict):
+        if issubclass(KVPairvalue, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +178,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ServiceGroupGetResponsedata):
+        if not isinstance(other, KVPairvalue):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/ServiceGroupListResponsedata.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/ListDirectoryServerConfigsApiResponsedata.py`

 * *Files 12% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class ServiceGroupListResponsedata(object):
+class ListDirectoryServerConfigsApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'List<microseg.v4.config.ServiceGroup>': 'list[microseg.v4.config.ServiceGroup]',
+        'List<microseg.v4.config.DirectoryServerConfig>': 'list[microseg.v4.config.DirectoryServerConfig]',
         'microseg.v4.error.ErrorResponse': 'microseg.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfmicroseg.v4.config.ServiceGroupListResponsedata'
+        return 'OneOfmicroseg.v4.config.ListDirectoryServerConfigsApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in ServiceGroupListResponsedata.discriminator_value_class_map.values():
-            return list(ServiceGroupListResponsedata.discriminator_value_class_map.keys())[list(ServiceGroupListResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in ListDirectoryServerConfigsApiResponsedata.discriminator_value_class_map.values():
+            return list(ListDirectoryServerConfigsApiResponsedata.discriminator_value_class_map.keys())[list(ListDirectoryServerConfigsApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ServiceGroupListResponsedata, dict):
+        if issubclass(ListDirectoryServerConfigsApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ServiceGroupListResponsedata):
+        if not isinstance(other, ListDirectoryServerConfigsApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/ServiceGroupPolicyAssociationResponsedata.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/common/v1/config/Flag.py`

 * *Files 14% similar despite different names*

```diff
@@ -3,161 +3,209 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class ServiceGroupPolicyAssociationResponsedata(object):
+class Flag(object):
 
-    """
+    """Many entities in the Nutanix APIs carry flags.  This object captures all the flags associated with that entity through this object.  The field that hosts this type of object must have an attribute called x-bounded-map-keys that tells which flags are actually present for that entity. 
 
+    :param name: (:attr:`name`) 
+    :type name: 
+    :param value: (:attr:`value`) 
+    :type value: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
+        'name': 'str',
+        'value': 'bool',
+        '_reserved': 'dict(str, object)',
+        '_object_type': 'str',
+        '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
+        'name': 'name',
+        'value': 'value',
+        '_reserved': '$reserved',
+        '_object_type': '$objectType',
+        '_unknown_fields': '$unknownFields',
     }
 
-    discriminator_value_class_map = {
-        'EMPTY_LIST': 'list[str]',
-        'EMPTY_MAP': 'dict(str, object)',
-        'List<microseg.v4.config.ServiceGroupPolicyReference>': 'list[microseg.v4.config.ServiceGroupPolicyReference]',
-        'microseg.v4.error.ErrorResponse': 'microseg.v4.error.ErrorResponse'
-    }
-
-    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
-    def __init__(self, *args, **kwargs):  # noqa: E501
+    def __init__(self, name=None, value=False, *args, **kwargs):  # noqa: E501
+        self.__name = None
+        self.__value = None
         self.discriminator = None
+        if name is not None:
+            self.__name = name
+        if value is not None:
+            self.__value = value
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfmicroseg.v4.config.ServiceGroupPolicyAssociationResponsedata'
+        return 'common.v1.config.Flag'
 
-    def _initialize_fq_object_type(self):
-        return ''
+    def _initialize_object_version(self):
+        return 'v1.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
-    def get_real_child_model(self, discriminator):
-        """Returns the real base class specified by the discriminator"""
-        if discriminator is not None and discriminator in self.discriminator_value_class_map:
-            return self.discriminator_value_class_map.get(discriminator)
-        return None
-
-    @staticmethod
-    def get_discriminator_from_object(value):
-        """Returns the discriminator for the provided object.
-        """
-        if not value:
-            disc = 'list[str]'
-        elif hasattr(value, "_object_type"):
-            disc = value.get_object_type()
-        elif type(value) == list:
-            if hasattr(value[0], "_object_type"):
-                datatype = value[0].get_object_type()
-            else:
-                datatype = type(value[0]).__name__
-            disc = 'list[' + datatype + ']'
-        elif type(value) == dict:
-            if hasattr(next(iter(value.values())), "_object_type"):
-                datatype = next(iter(value.values())).get_object_type()
-            else:
-                datatype = type(next(iter(value.values()))).__name__
-            disc = 'dict(str, ' + datatype + ')'
-        else:
-            disc = type(value).__name__
-        if disc in ServiceGroupPolicyAssociationResponsedata.discriminator_value_class_map.values():
-            return list(ServiceGroupPolicyAssociationResponsedata.discriminator_value_class_map.keys())[list(ServiceGroupPolicyAssociationResponsedata.discriminator_value_class_map.values()).index(disc)]
-        return None
+    @property
+    def name(self):
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__name
+
+    @name.setter
+    def name(self, name):
+
+        self.__name = name
+
+    @property
+    def value(self):
+        """
+        
+
+        :type:
+
+                :class:`~bool`
+        """  # noqa: E501
+        return self.__value
 
+    @value.setter
+    def value(self, value):
+
+        self.__value = value
+
+    @property
+    def _reserved(self):
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
+        return self.__dollar_reserved
+
+    @property
+    def _object_type(self):
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__dollar_object_type
+
+    @property
+    def _unknown_fields(self):
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
+        return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ServiceGroupPolicyAssociationResponsedata, dict):
+        if issubclass(Flag, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +217,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ServiceGroupPolicyAssociationResponsedata):
+        if not isinstance(other, Flag):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/ServiceGroupTaskResponsedata.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/common/v1/response/ApiLink.py`

 * *Files 13% similar despite different names*

```diff
@@ -3,161 +3,209 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class ServiceGroupTaskResponsedata(object):
+class ApiLink(object):
 
-    """
+    """A HATEOAS style link for the response.  Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource. 
 
+    :param href: (:attr:`href`) The URL at which the entity described by the link can be accessed. 
+    :type href: 
+    :param rel: (:attr:`rel`) A name that identifies the relationship of the link to the object that is returned by the URL.  The unique value of \"self\" identifies the URL for the object. 
+    :type rel: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
+        'href': 'str',
+        'rel': 'str',
+        '_reserved': 'dict(str, object)',
+        '_object_type': 'str',
+        '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
+        'href': 'href',
+        'rel': 'rel',
+        '_reserved': '$reserved',
+        '_object_type': '$objectType',
+        '_unknown_fields': '$unknownFields',
     }
 
-    discriminator_value_class_map = {
-        'EMPTY_LIST': 'list[str]',
-        'EMPTY_MAP': 'dict(str, object)',
-        'prism.v4.config.TaskReference': 'prism.v4.config.TaskReference',
-        'microseg.v4.error.ErrorResponse': 'microseg.v4.error.ErrorResponse'
-    }
-
-    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
-    def __init__(self, *args, **kwargs):  # noqa: E501
+    def __init__(self, href=None, rel=None, *args, **kwargs):  # noqa: E501
+        self.__href = None
+        self.__rel = None
         self.discriminator = None
+        if href is not None:
+            self.__href = href
+        if rel is not None:
+            self.__rel = rel
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfmicroseg.v4.config.ServiceGroupTaskResponsedata'
+        return 'common.v1.response.ApiLink'
 
-    def _initialize_fq_object_type(self):
-        return ''
+    def _initialize_object_version(self):
+        return 'v1.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
-    def get_real_child_model(self, discriminator):
-        """Returns the real base class specified by the discriminator"""
-        if discriminator is not None and discriminator in self.discriminator_value_class_map:
-            return self.discriminator_value_class_map.get(discriminator)
-        return None
-
-    @staticmethod
-    def get_discriminator_from_object(value):
-        """Returns the discriminator for the provided object.
-        """
-        if not value:
-            disc = 'list[str]'
-        elif hasattr(value, "_object_type"):
-            disc = value.get_object_type()
-        elif type(value) == list:
-            if hasattr(value[0], "_object_type"):
-                datatype = value[0].get_object_type()
-            else:
-                datatype = type(value[0]).__name__
-            disc = 'list[' + datatype + ']'
-        elif type(value) == dict:
-            if hasattr(next(iter(value.values())), "_object_type"):
-                datatype = next(iter(value.values())).get_object_type()
-            else:
-                datatype = type(next(iter(value.values()))).__name__
-            disc = 'dict(str, ' + datatype + ')'
-        else:
-            disc = type(value).__name__
-        if disc in ServiceGroupTaskResponsedata.discriminator_value_class_map.values():
-            return list(ServiceGroupTaskResponsedata.discriminator_value_class_map.keys())[list(ServiceGroupTaskResponsedata.discriminator_value_class_map.values()).index(disc)]
-        return None
+    @property
+    def href(self):
+        """
+        The URL at which the entity described by the link can be accessed. 
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__href
+
+    @href.setter
+    def href(self, href):
+
+        self.__href = href
+
+    @property
+    def rel(self):
+        """
+        A name that identifies the relationship of the link to the object that is returned by the URL.  The unique value of \"self\" identifies the URL for the object. 
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__rel
 
+    @rel.setter
+    def rel(self, rel):
+
+        self.__rel = rel
+
+    @property
+    def _reserved(self):
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
+        return self.__dollar_reserved
+
+    @property
+    def _object_type(self):
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__dollar_object_type
+
+    @property
+    def _unknown_fields(self):
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
+        return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ServiceGroupTaskResponsedata, dict):
+        if issubclass(ApiLink, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +217,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ServiceGroupTaskResponsedata):
+        if not isinstance(other, ApiLink):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/TierGetResponsedata.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/error/ErrorResponseerror.py`

 * *Files 14% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class TierGetResponsedata(object):
+class ErrorResponseerror(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'microseg.v4.config.TierResponse': 'microseg.v4.config.TierResponse',
-        'microseg.v4.error.ErrorResponse': 'microseg.v4.error.ErrorResponse'
+        'List<microseg.v4.error.AppMessage>': 'list[microseg.v4.error.AppMessage]',
+        'microseg.v4.error.SchemaValidationError': 'microseg.v4.error.SchemaValidationError'
     }
 
-    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
+    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$errorItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfmicroseg.v4.config.TierGetResponsedata'
+        return 'OneOfmicroseg.v4.error.ErrorResponseerror'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in TierGetResponsedata.discriminator_value_class_map.values():
-            return list(TierGetResponsedata.discriminator_value_class_map.keys())[list(TierGetResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in ErrorResponseerror.discriminator_value_class_map.values():
+            return list(ErrorResponseerror.discriminator_value_class_map.keys())[list(ErrorResponseerror.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(TierGetResponsedata, dict):
+        if issubclass(ErrorResponseerror, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, TierGetResponsedata):
+        if not isinstance(other, ErrorResponseerror):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/TierUpdateResponsedata.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/ImportEntityUpdateType.py`

 * *Files 17% similar despite different names*

```diff
@@ -3,161 +3,123 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class TierUpdateResponsedata(object):
+class ImportEntityUpdateType(object):
 
-    """
+    """Type of update of the entity.
 
 
-    """
-    """
-    IGNORE:
-    Attributes:
-      swagger_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-    IGNORE
-    """  # noqa: E501
-    swagger_types = {
-    }
-
-    attribute_map = {
-    }
-
-    discriminator_value_class_map = {
-        'EMPTY_LIST': 'list[str]',
-        'EMPTY_MAP': 'dict(str, object)',
-        'prism.v4.config.TaskReference': 'prism.v4.config.TaskReference',
-        'microseg.v4.error.ErrorResponse': 'microseg.v4.error.ErrorResponse'
-    }
+    Allowed enum values:
 
-    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
+        - _UNKNOWN
+        - _REDACTED
+        - ADD: Added Entity after Import.
+        - DELETE: Deleted Entity after Import.
+        - MODIFY: Modified Entity after Import.
+    """
+    _UNKNOWN = "$UNKNOWN"
+    _REDACTED = "$REDACTED"
+    ADD = "ADD"
+    DELETE = "DELETE"
+    MODIFY = "MODIFY"
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfmicroseg.v4.config.TierUpdateResponsedata'
+        return 'microseg.v4.config.ImportEntityUpdateType'
 
-    def _initialize_fq_object_type(self):
-        return ''
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
-    def get_real_child_model(self, discriminator):
-        """Returns the real base class specified by the discriminator"""
-        if discriminator is not None and discriminator in self.discriminator_value_class_map:
-            return self.discriminator_value_class_map.get(discriminator)
-        return None
-
-    @staticmethod
-    def get_discriminator_from_object(value):
-        """Returns the discriminator for the provided object.
-        """
-        if not value:
-            disc = 'list[str]'
-        elif hasattr(value, "_object_type"):
-            disc = value.get_object_type()
-        elif type(value) == list:
-            if hasattr(value[0], "_object_type"):
-                datatype = value[0].get_object_type()
-            else:
-                datatype = type(value[0]).__name__
-            disc = 'list[' + datatype + ']'
-        elif type(value) == dict:
-            if hasattr(next(iter(value.values())), "_object_type"):
-                datatype = next(iter(value.values())).get_object_type()
-            else:
-                datatype = type(next(iter(value.values()))).__name__
-            disc = 'dict(str, ' + datatype + ')'
-        else:
-            disc = type(value).__name__
-        if disc in TierUpdateResponsedata.discriminator_value_class_map.values():
-            return list(TierUpdateResponsedata.discriminator_value_class_map.keys())[list(TierUpdateResponsedata.discriminator_value_class_map.values()).index(disc)]
-        return None
-
-
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(TierUpdateResponsedata, dict):
+        if issubclass(ImportEntityUpdateType, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +131,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, TierUpdateResponsedata):
+        if not isinstance(other, ImportEntityUpdateType):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/error/ErrorResponseerror.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/UpdateDsCategoryMappingApiResponsedata.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class ErrorResponseerror(object):
+class UpdateDsCategoryMappingApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'List<microseg.v4.error.AppMessage>': 'list[microseg.v4.error.AppMessage]',
-        'microseg.v4.error.SchemaValidationError': 'microseg.v4.error.SchemaValidationError'
+        'prism.v4.config.TaskReference': 'prism.v4.config.TaskReference',
+        'microseg.v4.error.ErrorResponse': 'microseg.v4.error.ErrorResponse'
     }
 
-    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$errorItemDiscriminator'
+    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfmicroseg.v4.error.ErrorResponseerror'
+        return 'OneOfmicroseg.v4.config.UpdateDsCategoryMappingApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in ErrorResponseerror.discriminator_value_class_map.values():
-            return list(ErrorResponseerror.discriminator_value_class_map.keys())[list(ErrorResponseerror.discriminator_value_class_map.values()).index(disc)]
+        if disc in UpdateDsCategoryMappingApiResponsedata.discriminator_value_class_map.values():
+            return list(UpdateDsCategoryMappingApiResponsedata.discriminator_value_class_map.keys())[list(UpdateDsCategoryMappingApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ErrorResponseerror, dict):
+        if issubclass(UpdateDsCategoryMappingApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ErrorResponseerror):
+        if not isinstance(other, UpdateDsCategoryMappingApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/__init__.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -4,149 +4,134 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 from __future__ import absolute_import
 
 # import models into model package
 from ntnx_microseg_py_client.models.OneOfcommon.v1.config.KVPairvalue import KVPairvalue
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.AddressGroupGetResponsedata import AddressGroupGetResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.AddressGroupListResponsedata import AddressGroupListResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.AddressGroupPolicyAssociationResponsedata import AddressGroupPolicyAssociationResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.AddressGroupTaskResponsedata import AddressGroupTaskResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.BannerGetResponsedata import BannerGetResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.ConfigMigrationPreviewGetResponsedata import ConfigMigrationPreviewGetResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.ConfigMigrationSummaryGetResponsedata import ConfigMigrationSummaryGetResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.DirectoryServerCreateResponsedata import DirectoryServerCreateResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.DirectoryServerDeleteResponsedata import DirectoryServerDeleteResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.DirectoryServerGetResponsedata import DirectoryServerGetResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.DirectoryServerListResponsedata import DirectoryServerListResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.DirectoryServerUpdateResponsedata import DirectoryServerUpdateResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.DsCategoryMappingCreateResponsedata import DsCategoryMappingCreateResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.DsCategoryMappingDeleteResponsedata import DsCategoryMappingDeleteResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.DsCategoryMappingGetResponsedata import DsCategoryMappingGetResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.DsCategoryMappingUpdateResponsedata import DsCategoryMappingUpdateResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.DsCategoryMappingsGetListResponsedata import DsCategoryMappingsGetListResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.MigrationConfigSpecspec import MigrationConfigSpecspec
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.MigrationConfigTaskResponsedata import MigrationConfigTaskResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.NetworkSecurityPolicyGetListResponsedata import NetworkSecurityPolicyGetListResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.NetworkSecurityPolicyGetResponsedata import NetworkSecurityPolicyGetResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.NetworkSecurityPolicyImportResponsedata import NetworkSecurityPolicyImportResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.NetworkSecurityPolicyRulesGetResponsedata import NetworkSecurityPolicyRulesGetResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.CreateAddressGroupApiResponsedata import CreateAddressGroupApiResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.CreateDirectoryServerConfigApiResponsedata import CreateDirectoryServerConfigApiResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.CreateDsCategoryMappingApiResponsedata import CreateDsCategoryMappingApiResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.CreateNetworkSecurityPolicyApiResponsedata import CreateNetworkSecurityPolicyApiResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.CreateNetworkSecurityPolicyExportApiResponsedata import CreateNetworkSecurityPolicyExportApiResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.CreateNetworkSecurityPolicyImportApiResponsedata import CreateNetworkSecurityPolicyImportApiResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.CreateServiceGroupApiResponsedata import CreateServiceGroupApiResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.DeleteAddressGroupApiResponsedata import DeleteAddressGroupApiResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.DeleteDirectoryServerConfigApiResponsedata import DeleteDirectoryServerConfigApiResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.DeleteDsCategoryMappingApiResponsedata import DeleteDsCategoryMappingApiResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.DeleteNetworkSecurityPolicyApiResponsedata import DeleteNetworkSecurityPolicyApiResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.DeleteServiceGroupApiResponsedata import DeleteServiceGroupApiResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.GetAddressGroupApiResponsedata import GetAddressGroupApiResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.GetDirectoryServerConfigApiResponsedata import GetDirectoryServerConfigApiResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.GetDsCategoryMappingApiResponsedata import GetDsCategoryMappingApiResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.GetNetworkSecurityPolicyApiResponsedata import GetNetworkSecurityPolicyApiResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.GetServiceGroupApiResponsedata import GetServiceGroupApiResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.ListAddressGroupsApiResponsedata import ListAddressGroupsApiResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.ListDirectoryServerConfigsApiResponsedata import ListDirectoryServerConfigsApiResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.ListDsCategoryMappingsApiResponsedata import ListDsCategoryMappingsApiResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.ListNetworkSecurityPoliciesApiResponsedata import ListNetworkSecurityPoliciesApiResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.ListNetworkSecurityPolicyRulesApiResponsedata import ListNetworkSecurityPolicyRulesApiResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.ListServiceGroupsApiResponsedata import ListServiceGroupsApiResponsedata
 from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.NetworkSecurityPolicyRulespec import NetworkSecurityPolicyRulespec
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.NetworkSecurityPolicyTaskResponsedata import NetworkSecurityPolicyTaskResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.ServiceGroupGetResponsedata import ServiceGroupGetResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.ServiceGroupListResponsedata import ServiceGroupListResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.ServiceGroupPolicyAssociationResponsedata import ServiceGroupPolicyAssociationResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.ServiceGroupTaskResponsedata import ServiceGroupTaskResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.TierGetResponsedata import TierGetResponsedata
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.TierUpdateResponsedata import TierUpdateResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.UpdateAddressGroupApiResponsedata import UpdateAddressGroupApiResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.UpdateDirectoryServerConfigApiResponsedata import UpdateDirectoryServerConfigApiResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.UpdateDsCategoryMappingApiResponsedata import UpdateDsCategoryMappingApiResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.UpdateNetworkSecurityPolicyApiResponsedata import UpdateNetworkSecurityPolicyApiResponsedata
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.UpdateServiceGroupApiResponsedata import UpdateServiceGroupApiResponsedata
 from ntnx_microseg_py_client.models.OneOfmicroseg.v4.error.ErrorResponseerror import ErrorResponseerror
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.operation.UpgradeJobspec import UpgradeJobspec
+from ntnx_microseg_py_client.models.common.v1.config.FQDN import FQDN
 from ntnx_microseg_py_client.models.common.v1.config.Flag import Flag
+from ntnx_microseg_py_client.models.common.v1.config.IPAddressOrFQDN import IPAddressOrFQDN
 from ntnx_microseg_py_client.models.common.v1.config.IPv4Address import IPv4Address
+from ntnx_microseg_py_client.models.common.v1.config.IPv6Address import IPv6Address
 from ntnx_microseg_py_client.models.common.v1.config.KVPair import KVPair
 from ntnx_microseg_py_client.models.common.v1.config.Message import Message
 from ntnx_microseg_py_client.models.common.v1.config.MessageSeverity import MessageSeverity
 from ntnx_microseg_py_client.models.common.v1.config.TenantAwareModel import TenantAwareModel
 from ntnx_microseg_py_client.models.common.v1.response.ApiLink import ApiLink
 from ntnx_microseg_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata
 from ntnx_microseg_py_client.models.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel
+from ntnx_microseg_py_client.models.microseg.v4.config.AdInfo import AdInfo
+from ntnx_microseg_py_client.models.microseg.v4.config.AdStatus import AdStatus
 from ntnx_microseg_py_client.models.microseg.v4.config.AddressGroup import AddressGroup
-from ntnx_microseg_py_client.models.microseg.v4.config.AddressGroupGetResponse import AddressGroupGetResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.AddressGroupListResponse import AddressGroupListResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.AddressGroupPolicyAssociationResponse import AddressGroupPolicyAssociationResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.AddressGroupPolicyReference import AddressGroupPolicyReference
-from ntnx_microseg_py_client.models.microseg.v4.config.AddressGroupReferenceSpec import AddressGroupReferenceSpec
-from ntnx_microseg_py_client.models.microseg.v4.config.AddressGroupTaskResponse import AddressGroupTaskResponse
 from ntnx_microseg_py_client.models.microseg.v4.config.AllowType import AllowType
-from ntnx_microseg_py_client.models.microseg.v4.config.BannerGetResponse import BannerGetResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.BannerResponse import BannerResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.BannerType import BannerType
+from ntnx_microseg_py_client.models.microseg.v4.config.ApplicationRuleSpec import ApplicationRuleSpec
 from ntnx_microseg_py_client.models.microseg.v4.config.CategoryMapping import CategoryMapping
-from ntnx_microseg_py_client.models.microseg.v4.config.CategoryMappingAdInfo import CategoryMappingAdInfo
-from ntnx_microseg_py_client.models.microseg.v4.config.CategoryMappingAdStatus import CategoryMappingAdStatus
-from ntnx_microseg_py_client.models.microseg.v4.config.CategoryMappingInfo import CategoryMappingInfo
-from ntnx_microseg_py_client.models.microseg.v4.config.ConfigMigrationPolicyOptions import ConfigMigrationPolicyOptions
-from ntnx_microseg_py_client.models.microseg.v4.config.ConfigMigrationPolicyType import ConfigMigrationPolicyType
-from ntnx_microseg_py_client.models.microseg.v4.config.ConfigMigrationPreviewGetResponse import ConfigMigrationPreviewGetResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.ConfigMigrationPreviewResponse import ConfigMigrationPreviewResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.ConfigMigrationSummary import ConfigMigrationSummary
-from ntnx_microseg_py_client.models.microseg.v4.config.ConfigMigrationSummaryGetResponse import ConfigMigrationSummaryGetResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.DirectoryServer import DirectoryServer
-from ntnx_microseg_py_client.models.microseg.v4.config.DirectoryServerCreateResponse import DirectoryServerCreateResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.DirectoryServerDeleteResponse import DirectoryServerDeleteResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.DirectoryServerGetResponse import DirectoryServerGetResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.DirectoryServerListResponse import DirectoryServerListResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.DirectoryServerUpdateResponse import DirectoryServerUpdateResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.DomainController import DomainController
-from ntnx_microseg_py_client.models.microseg.v4.config.DsCategoryMappingCreateResponse import DsCategoryMappingCreateResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.DsCategoryMappingDeleteResponse import DsCategoryMappingDeleteResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.DsCategoryMappingGetResponse import DsCategoryMappingGetResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.DsCategoryMappingUpdateResponse import DsCategoryMappingUpdateResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.DsCategoryMappingsGetListResponse import DsCategoryMappingsGetListResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.FileWrapper import FileWrapper
+from ntnx_microseg_py_client.models.microseg.v4.config.CreateAddressGroupApiResponse import CreateAddressGroupApiResponse
+from ntnx_microseg_py_client.models.microseg.v4.config.CreateDirectoryServerConfigApiResponse import CreateDirectoryServerConfigApiResponse
+from ntnx_microseg_py_client.models.microseg.v4.config.CreateDsCategoryMappingApiResponse import CreateDsCategoryMappingApiResponse
+from ntnx_microseg_py_client.models.microseg.v4.config.CreateNetworkSecurityPolicyApiResponse import CreateNetworkSecurityPolicyApiResponse
+from ntnx_microseg_py_client.models.microseg.v4.config.CreateNetworkSecurityPolicyExportApiResponse import CreateNetworkSecurityPolicyExportApiResponse
+from ntnx_microseg_py_client.models.microseg.v4.config.CreateNetworkSecurityPolicyImportApiResponse import CreateNetworkSecurityPolicyImportApiResponse
+from ntnx_microseg_py_client.models.microseg.v4.config.CreateServiceGroupApiResponse import CreateServiceGroupApiResponse
+from ntnx_microseg_py_client.models.microseg.v4.config.DeleteAddressGroupApiResponse import DeleteAddressGroupApiResponse
+from ntnx_microseg_py_client.models.microseg.v4.config.DeleteDirectoryServerConfigApiResponse import DeleteDirectoryServerConfigApiResponse
+from ntnx_microseg_py_client.models.microseg.v4.config.DeleteDsCategoryMappingApiResponse import DeleteDsCategoryMappingApiResponse
+from ntnx_microseg_py_client.models.microseg.v4.config.DeleteNetworkSecurityPolicyApiResponse import DeleteNetworkSecurityPolicyApiResponse
+from ntnx_microseg_py_client.models.microseg.v4.config.DeleteServiceGroupApiResponse import DeleteServiceGroupApiResponse
+from ntnx_microseg_py_client.models.microseg.v4.config.DirectoryServerConfig import DirectoryServerConfig
+from ntnx_microseg_py_client.models.microseg.v4.config.GetAddressGroupApiResponse import GetAddressGroupApiResponse
+from ntnx_microseg_py_client.models.microseg.v4.config.GetDirectoryServerConfigApiResponse import GetDirectoryServerConfigApiResponse
+from ntnx_microseg_py_client.models.microseg.v4.config.GetDsCategoryMappingApiResponse import GetDsCategoryMappingApiResponse
+from ntnx_microseg_py_client.models.microseg.v4.config.GetNetworkSecurityPolicyApiResponse import GetNetworkSecurityPolicyApiResponse
+from ntnx_microseg_py_client.models.microseg.v4.config.GetServiceGroupApiResponse import GetServiceGroupApiResponse
 from ntnx_microseg_py_client.models.microseg.v4.config.IPv4Range import IPv4Range
 from ntnx_microseg_py_client.models.microseg.v4.config.IcmpTypeCodeSpec import IcmpTypeCodeSpec
+from ntnx_microseg_py_client.models.microseg.v4.config.ImportEntity import ImportEntity
+from ntnx_microseg_py_client.models.microseg.v4.config.ImportEntityType import ImportEntityType
+from ntnx_microseg_py_client.models.microseg.v4.config.ImportEntityUpdateType import ImportEntityUpdateType
 from ntnx_microseg_py_client.models.microseg.v4.config.IntraEntityGroupRuleAction import IntraEntityGroupRuleAction
+from ntnx_microseg_py_client.models.microseg.v4.config.IntraEntityGroupRuleSpec import IntraEntityGroupRuleSpec
+from ntnx_microseg_py_client.models.microseg.v4.config.ListAddressGroupsApiResponse import ListAddressGroupsApiResponse
+from ntnx_microseg_py_client.models.microseg.v4.config.ListDirectoryServerConfigsApiResponse import ListDirectoryServerConfigsApiResponse
+from ntnx_microseg_py_client.models.microseg.v4.config.ListDsCategoryMappingsApiResponse import ListDsCategoryMappingsApiResponse
+from ntnx_microseg_py_client.models.microseg.v4.config.ListNetworkSecurityPoliciesApiResponse import ListNetworkSecurityPoliciesApiResponse
+from ntnx_microseg_py_client.models.microseg.v4.config.ListNetworkSecurityPolicyRulesApiResponse import ListNetworkSecurityPolicyRulesApiResponse
+from ntnx_microseg_py_client.models.microseg.v4.config.ListServiceGroupsApiResponse import ListServiceGroupsApiResponse
 from ntnx_microseg_py_client.models.microseg.v4.config.MatchEntity import MatchEntity
 from ntnx_microseg_py_client.models.microseg.v4.config.MatchField import MatchField
 from ntnx_microseg_py_client.models.microseg.v4.config.MatchType import MatchType
 from ntnx_microseg_py_client.models.microseg.v4.config.MatchingCriteria import MatchingCriteria
-from ntnx_microseg_py_client.models.microseg.v4.config.MigrationConfig import MigrationConfig
-from ntnx_microseg_py_client.models.microseg.v4.config.MigrationConfigSpec import MigrationConfigSpec
-from ntnx_microseg_py_client.models.microseg.v4.config.MigrationConfigTaskResponse import MigrationConfigTaskResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.MigrationSummary import MigrationSummary
-from ntnx_microseg_py_client.models.microseg.v4.config.NSPApplicationRuleSpec import NSPApplicationRuleSpec
-from ntnx_microseg_py_client.models.microseg.v4.config.NSPIntraEntityGroupRuleSpec import NSPIntraEntityGroupRuleSpec
-from ntnx_microseg_py_client.models.microseg.v4.config.NSPTwoEnvIsolationRuleSpec import NSPTwoEnvIsolationRuleSpec
 from ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicy import NetworkSecurityPolicy
-from ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyGetListResponse import NetworkSecurityPolicyGetListResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyGetResponse import NetworkSecurityPolicyGetResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyImportEntity import NetworkSecurityPolicyImportEntity
-from ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyImportEntityType import NetworkSecurityPolicyImportEntityType
-from ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyImportEntityUpdateType import NetworkSecurityPolicyImportEntityUpdateType
-from ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyImportResponse import NetworkSecurityPolicyImportResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyMigrationCountSummary import NetworkSecurityPolicyMigrationCountSummary
-from ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyMigrationMetadata import NetworkSecurityPolicyMigrationMetadata
-from ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyMigrationSubnetSummary import NetworkSecurityPolicyMigrationSubnetSummary
-from ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyMigrationSummary import NetworkSecurityPolicyMigrationSummary
-from ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyMigrationSummaryFailures import NetworkSecurityPolicyMigrationSummaryFailures
-from ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyMigrationTotalCountInfo import NetworkSecurityPolicyMigrationTotalCountInfo
-from ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyMigrationTypeCountInfo import NetworkSecurityPolicyMigrationTypeCountInfo
 from ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyRule import NetworkSecurityPolicyRule
-from ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyRulesGetResponse import NetworkSecurityPolicyRulesGetResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyTaskResponse import NetworkSecurityPolicyTaskResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.OptionSpec import OptionSpec
-from ntnx_microseg_py_client.models.microseg.v4.config.PolicyReferenceActionSpec import PolicyReferenceActionSpec
-from ntnx_microseg_py_client.models.microseg.v4.config.PolicyReferenceSpec import PolicyReferenceSpec
-from ntnx_microseg_py_client.models.microseg.v4.config.PolicyReferenceStateSpec import PolicyReferenceStateSpec
-from ntnx_microseg_py_client.models.microseg.v4.config.PolicyState import PolicyState
-from ntnx_microseg_py_client.models.microseg.v4.config.PolicyType import PolicyType
 from ntnx_microseg_py_client.models.microseg.v4.config.RuleType import RuleType
+from ntnx_microseg_py_client.models.microseg.v4.config.SecurityPolicyScope import SecurityPolicyScope
+from ntnx_microseg_py_client.models.microseg.v4.config.SecurityPolicyState import SecurityPolicyState
+from ntnx_microseg_py_client.models.microseg.v4.config.SecurityPolicyType import SecurityPolicyType as ConfigSecurityPolicyType
 from ntnx_microseg_py_client.models.microseg.v4.config.ServiceGroup import ServiceGroup
-from ntnx_microseg_py_client.models.microseg.v4.config.ServiceGroupGetResponse import ServiceGroupGetResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.ServiceGroupListResponse import ServiceGroupListResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.ServiceGroupPolicyAssociationResponse import ServiceGroupPolicyAssociationResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.ServiceGroupPolicyReference import ServiceGroupPolicyReference
-from ntnx_microseg_py_client.models.microseg.v4.config.ServiceGroupReferenceSpec import ServiceGroupReferenceSpec
-from ntnx_microseg_py_client.models.microseg.v4.config.ServiceGroupTaskResponse import ServiceGroupTaskResponse
 from ntnx_microseg_py_client.models.microseg.v4.config.TcpPortRangeSpec import TcpPortRangeSpec
-from ntnx_microseg_py_client.models.microseg.v4.config.Tier import Tier
-from ntnx_microseg_py_client.models.microseg.v4.config.TierGetResponse import TierGetResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.TierName import TierName
-from ntnx_microseg_py_client.models.microseg.v4.config.TierResponse import TierResponse
-from ntnx_microseg_py_client.models.microseg.v4.config.TierUpdateResponse import TierUpdateResponse
+from ntnx_microseg_py_client.models.microseg.v4.config.TwoEnvIsolationRuleSpec import TwoEnvIsolationRuleSpec
 from ntnx_microseg_py_client.models.microseg.v4.config.UdpPortRangeSpec import UdpPortRangeSpec
+from ntnx_microseg_py_client.models.microseg.v4.config.UpdateAddressGroupApiResponse import UpdateAddressGroupApiResponse
+from ntnx_microseg_py_client.models.microseg.v4.config.UpdateDirectoryServerConfigApiResponse import UpdateDirectoryServerConfigApiResponse
+from ntnx_microseg_py_client.models.microseg.v4.config.UpdateDsCategoryMappingApiResponse import UpdateDsCategoryMappingApiResponse
+from ntnx_microseg_py_client.models.microseg.v4.config.UpdateNetworkSecurityPolicyApiResponse import UpdateNetworkSecurityPolicyApiResponse
+from ntnx_microseg_py_client.models.microseg.v4.config.UpdateServiceGroupApiResponse import UpdateServiceGroupApiResponse
 from ntnx_microseg_py_client.models.microseg.v4.error.AppMessage import AppMessage
 from ntnx_microseg_py_client.models.microseg.v4.error.ErrorResponse import ErrorResponse
 from ntnx_microseg_py_client.models.microseg.v4.error.SchemaValidationError import SchemaValidationError
 from ntnx_microseg_py_client.models.microseg.v4.error.SchemaValidationErrorMessage import SchemaValidationErrorMessage
+from ntnx_microseg_py_client.models.microseg.v4.operation.DryRunSpec import DryRunSpec
+from ntnx_microseg_py_client.models.microseg.v4.operation.DryRunSummary import DryRunSummary
+from ntnx_microseg_py_client.models.microseg.v4.operation.PolicyCount import PolicyCount
+from ntnx_microseg_py_client.models.microseg.v4.operation.PolicyCountByType import PolicyCountByType
+from ntnx_microseg_py_client.models.microseg.v4.operation.PolicyMetadata import PolicyMetadata
+from ntnx_microseg_py_client.models.microseg.v4.operation.PolicyPreview import PolicyPreview
+from ntnx_microseg_py_client.models.microseg.v4.operation.PolicyUpgradeSummary import PolicyUpgradeSummary
+from ntnx_microseg_py_client.models.microseg.v4.operation.SecurityPolicyOptions import SecurityPolicyOptions
+from ntnx_microseg_py_client.models.microseg.v4.operation.SecurityPolicyType import SecurityPolicyType as OperationSecurityPolicyType
+from ntnx_microseg_py_client.models.microseg.v4.operation.SubnetUpgradeSummary import SubnetUpgradeSummary
+from ntnx_microseg_py_client.models.microseg.v4.operation.TotalPolicyCount import TotalPolicyCount
+from ntnx_microseg_py_client.models.microseg.v4.operation.UpgradeJob import UpgradeJob
+from ntnx_microseg_py_client.models.microseg.v4.operation.UpgradeSpec import UpgradeSpec
 from ntnx_microseg_py_client.models.prism.v4.config.TaskReference import TaskReference
 from ntnx_microseg_py_client.api_response import ApiResponse
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/common/v1/config/Flag.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/common/v1/config/KVPair.py`

 * *Files 13% similar despite different names*

```diff
@@ -3,48 +3,51 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
+import ntnx_microseg_py_client.models
+from ntnx_microseg_py_client.models.OneOfcommon.v1.config.KVPairvalue import KVPairvalue  # noqa: F401,E501
 
-class Flag(object):
+class KVPair(object):
 
-    """Many entities in the Nutanix APIs carry flags.  This object captures all the flags associated with that entity through this object.  The field that hosts this type of object must have an attribute called x-bounded-map-keys that tells which flags are actually present for that entity. 
+    """A map describing a set of keys and their corresponding values. 
 
-    :param name: (:attr:`name`) 
+    :param name: (:attr:`name`) The key of this key-value pair
     :type name: 
-    :param value: (:attr:`value`) 
+    :param value: (:attr:`value`) The value associated with the key for this key-value pair
     :type value: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'name': 'str',
-        'value': 'bool',
+        'value': 'OneOfcommon.v1.config.KVPairvalue',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'name': 'name',
@@ -52,47 +55,47 @@
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, name=None, value=False, *args, **kwargs):  # noqa: E501
+    def __init__(self, name=None, value=None, *args, **kwargs):  # noqa: E501
         self.__name = None
         self.__value = None
         self.discriminator = None
         if name is not None:
             self.__name = name
         if value is not None:
             self.__value = value
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'common.v1.config.Flag'
+        return 'common.v1.config.KVPair'
 
-    def _initialize_fq_object_type(self):
-        return 'common.v1.r0.a3.config.Flag'
+    def _initialize_object_version(self):
+        return 'v1.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -101,15 +104,15 @@
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def name(self):
         """
-        
+        The key of this key-value pair
 
         :type:
 
                 :class:`~str`
         """  # noqa: E501
         return self.__name
 
@@ -117,20 +120,23 @@
     def name(self, name):
 
         self.__name = name
 
     @property
     def value(self):
         """
-        
+        The value associated with the key for this key-value pair
 
         :type:
-
-                :class:`~bool`
-        """  # noqa: E501
+                :class:`~str` | 
+                :class:`~int` | 
+                :class:`~bool` | 
+                :class:`~list[str]` | 
+                :class:`~dict(str, str)`
+                    """  # noqa: E501
         return self.__value
 
     @value.setter
     def value(self, value):
 
         self.__value = value
 
@@ -169,37 +175,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
+            if attr_type.startswith('OneOf'):
+                type = getattr(ntnx_microseg_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(Flag, dict):
+        if issubclass(KVPair, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -211,15 +224,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, Flag):
+        if not isinstance(other, KVPair):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/common/v1/config/IPv4Address.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/common/v1/config/IPv4Address.py`

 * *Files 9% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
 class IPv4Address(object):
 
     """
 
     :param value: (:attr:`value`) 
     :type value: 
@@ -66,33 +67,33 @@
             self.__prefix_length = prefix_length
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'common.v1.config.IPv4Address'
 
-    def _initialize_fq_object_type(self):
-        return 'common.v1.r0.a3.config.IPv4Address'
+    def _initialize_object_version(self):
+        return 'v1.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -175,28 +176,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/common/v1/config/KVPair.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/CreateServiceGroupApiResponse.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,145 +3,143 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_microseg_py_client.models
-from ntnx_microseg_py_client.models.OneOfcommon.v1.config.KVPairvalue import KVPairvalue  # noqa: F401,E501
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.CreateServiceGroupApiResponsedata import CreateServiceGroupApiResponsedata  # noqa: F401,E501
+from ntnx_microseg_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class KVPair(object):
+class CreateServiceGroupApiResponse(object):
 
-    """A map describing a set of keys and their corresponding values. 
+    """REST response for all response codes in API path /microseg/v4.0.b1/config/service-groups Post operation
 
-    :param name: (:attr:`name`) The key of this key-value pair
-    :type name: 
-    :param value: (:attr:`value`) The value associated with the key for this key-value pair
-    :type value: 
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'name': 'str',
-        'value': 'OneOfcommon.v1.config.KVPairvalue',
+        'metadata': 'common.v1.response.ApiResponseMetadata',
+        'data': 'OneOfmicroseg.v4.config.CreateServiceGroupApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'name': 'name',
-        'value': 'value',
+        'metadata': 'metadata',
+        'data': 'data',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, name=None, value=None, *args, **kwargs):  # noqa: E501
-        self.__name = None
-        self.__value = None
+    def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
+        self.__metadata = None
+        self.__data = None
         self.discriminator = None
-        if name is not None:
-            self.__name = name
-        if value is not None:
-            self.__value = value
+        if metadata is not None:
+            self.__metadata = metadata
+        if data is not None:
+            self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'common.v1.config.KVPair'
+        return 'microseg.v4.config.CreateServiceGroupApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'common.v1.r0.a3.config.KVPair'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def name(self):
+    def metadata(self):
         """
-        The key of this key-value pair
+        
 
         :type:
-
-                :class:`~str`
+            :class:`~ntnx_microseg_py_client.models.common.v1.response.ApiResponseMetadata`
         """  # noqa: E501
-        return self.__name
+        return self.__metadata
 
-    @name.setter
-    def name(self, name):
+    @metadata.setter
+    def metadata(self, metadata):
 
-        self.__name = name
+        self.__metadata = metadata
 
     @property
-    def value(self):
+    def data(self):
         """
-        The value associated with the key for this key-value pair
+        
 
         :type:
-                :class:`~str` | 
-                :class:`~int` | 
-                :class:`~bool` | 
-                :class:`~list[str]` | 
-                :class:`~dict(str, str)`
+                :class:`~ntnx_microseg_py_client.models.prism.v4.config.TaskReference` | 
+                :class:`~ntnx_microseg_py_client.models.microseg.v4.error.ErrorResponse`
                     """  # noqa: E501
-        return self.__value
+        return self.__data
 
-    @value.setter
-    def value(self, value):
+    @data.setter
+    def data(self, data):
 
-        self.__value = value
+        self.__data = data
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -174,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_microseg_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(KVPair, dict):
+        if issubclass(CreateServiceGroupApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -218,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, KVPair):
+        if not isinstance(other, CreateServiceGroupApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/common/v1/config/Message.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/common/v1/config/Message.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_microseg_py_client.models.common.v1.config.MessageSeverity import MessageSeverity  # noqa: F401,E501
 
 class Message(object):
 
     """
 
     :param code: (:attr:`code`) A code that uniquely identifies a message. 
@@ -81,33 +82,33 @@
             self.__severity = severity
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'common.v1.config.Message'
 
-    def _initialize_fq_object_type(self):
-        return 'common.v1.r0.a3.config.Message'
+    def _initialize_object_version(self):
+        return 'v1.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -215,28 +216,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/common/v1/config/MessageSeverity.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/MatchField.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,73 +3,70 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class MessageSeverity(object):
+class MatchField(object):
 
-    """The message severity. 
+    """The field to match on. Today only NAME is supported, which matches on an entity's name.
 
 
     Allowed enum values:
 
         - _UNKNOWN
         - _REDACTED
-        - INFO
-        - WARNING
-        - ERROR
+        - NAME: NAME
     """
     _UNKNOWN = "$UNKNOWN"
     _REDACTED = "$REDACTED"
-    INFO = "INFO"
-    WARNING = "WARNING"
-    ERROR = "ERROR"
+    NAME = "NAME"
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'common.v1.config.MessageSeverity'
+        return 'microseg.v4.config.MatchField'
 
-    def _initialize_fq_object_type(self):
-        return 'common.v1.r0.a3.config.MessageSeverity'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -84,36 +81,41 @@
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(MessageSeverity, dict):
+        if issubclass(MatchField, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -125,15 +127,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, MessageSeverity):
+        if not isinstance(other, MatchField):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/common/v1/config/TenantAwareModel.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/common/v1/config/TenantAwareModel.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,31 +3,32 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
 class TenantAwareModel(object):
 
     """A model base class whose instances are bound to a specific tenant.  This model adds a tenantId to the base model class that it extends and is automatically set by the server. 
 
-    :param tenant_id: (:attr:`tenant_id`) A globally unique identifier that represents the tenant that owns this entity.  It is automatically assigned by the system and is immutable from an API consumer perspective (some use cases may cause this Id to change - for instance a use case may require the transfer of ownership of the entity, but these cases are handled automatically on the server). 
+    :param tenant_id: (:attr:`tenant_id`) A globally unique identifier that represents the tenant that owns this entity. The system automatically assigns it, and it and is immutable from an API consumer perspective (some use cases may cause this Id to change - For instance, a use case may require the transfer of ownership of the entity, but these cases are handled automatically on the server). 
     :type tenant_id: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
@@ -59,33 +60,33 @@
             self.__tenant_id = tenant_id
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'common.v1.config.TenantAwareModel'
 
-    def _initialize_fq_object_type(self):
-        return 'common.v1.r0.a3.config.TenantAwareModel'
+    def _initialize_object_version(self):
+        return 'v1.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -94,15 +95,15 @@
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def tenant_id(self):
         """
-        A globally unique identifier that represents the tenant that owns this entity.  It is automatically assigned by the system and is immutable from an API consumer perspective (some use cases may cause this Id to change - for instance a use case may require the transfer of ownership of the entity, but these cases are handled automatically on the server). 
+        A globally unique identifier that represents the tenant that owns this entity. The system automatically assigns it, and it and is immutable from an API consumer perspective (some use cases may cause this Id to change - For instance, a use case may require the transfer of ownership of the entity, but these cases are handled automatically on the server). 
 
         :type:
 
                 :class:`~str`
         """  # noqa: E501
         return self.__tenant_id
 
@@ -148,28 +149,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/common/v1/response/ApiLink.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/operation/SecurityPolicyOptions.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,140 +3,141 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class ApiLink(object):
+class SecurityPolicyOptions(object):
 
-    """A HATEOAS style link for the response.  Each link contains a user friendly name identifying the link and an address for retrieving the particular resource. 
+    """Policy-wide options for a security policy.
 
-    :param href: (:attr:`href`) The URL at which the entity described by the link can be accessed. 
-    :type href: 
-    :param rel: (:attr:`rel`) A name that identifies the relationship of the link to the object that is returned by the URL.  The unique value of \"self\" identifies the URL for the object. 
-    :type rel: 
+    :param is_ipv6_traffic_allowed: (:attr:`is_ipv6_traffic_allowed`) 
+    :type is_ipv6_traffic_allowed: 
+    :param is_hitlog_enabled: (:attr:`is_hitlog_enabled`) 
+    :type is_hitlog_enabled: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'href': 'str',
-        'rel': 'str',
+        'is_ipv6_traffic_allowed': 'bool',
+        'is_hitlog_enabled': 'bool',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'href': 'href',
-        'rel': 'rel',
+        'is_ipv6_traffic_allowed': 'isIpv6TrafficAllowed',
+        'is_hitlog_enabled': 'isHitlogEnabled',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, href=None, rel=None, *args, **kwargs):  # noqa: E501
-        self.__href = None
-        self.__rel = None
+    def __init__(self, is_ipv6_traffic_allowed=False, is_hitlog_enabled=False, *args, **kwargs):  # noqa: E501
+        self.__is_ipv6_traffic_allowed = None
+        self.__is_hitlog_enabled = None
         self.discriminator = None
-        if href is not None:
-            self.__href = href
-        if rel is not None:
-            self.__rel = rel
+        if is_ipv6_traffic_allowed is not None:
+            self.__is_ipv6_traffic_allowed = is_ipv6_traffic_allowed
+        if is_hitlog_enabled is not None:
+            self.__is_hitlog_enabled = is_hitlog_enabled
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'common.v1.response.ApiLink'
+        return 'microseg.v4.operation.SecurityPolicyOptions'
 
-    def _initialize_fq_object_type(self):
-        return 'common.v1.r0.a3.response.ApiLink'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def href(self):
+    def is_ipv6_traffic_allowed(self):
         """
-        The URL at which the entity described by the link can be accessed. 
+        
 
         :type:
 
-                :class:`~str`
+                :class:`~bool`
         """  # noqa: E501
-        return self.__href
+        return self.__is_ipv6_traffic_allowed
 
-    @href.setter
-    def href(self, href):
+    @is_ipv6_traffic_allowed.setter
+    def is_ipv6_traffic_allowed(self, is_ipv6_traffic_allowed):
 
-        self.__href = href
+        self.__is_ipv6_traffic_allowed = is_ipv6_traffic_allowed
 
     @property
-    def rel(self):
+    def is_hitlog_enabled(self):
         """
-        A name that identifies the relationship of the link to the object that is returned by the URL.  The unique value of \"self\" identifies the URL for the object. 
+        
 
         :type:
 
-                :class:`~str`
+                :class:`~bool`
         """  # noqa: E501
-        return self.__rel
+        return self.__is_hitlog_enabled
 
-    @rel.setter
-    def rel(self, rel):
+    @is_hitlog_enabled.setter
+    def is_hitlog_enabled(self, is_hitlog_enabled):
 
-        self.__rel = rel
+        self.__is_hitlog_enabled = is_hitlog_enabled
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -169,37 +170,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ApiLink, dict):
+        if issubclass(SecurityPolicyOptions, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -211,15 +217,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ApiLink):
+        if not isinstance(other, SecurityPolicyOptions):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/common/v1/response/ApiResponseMetadata.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/common/v1/response/ApiResponseMetadata.py`

 * *Files 9% similar despite different names*

```diff
@@ -3,35 +3,36 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_microseg_py_client.models.common.v1.config.Flag import Flag  # noqa: F401,E501
 from ntnx_microseg_py_client.models.common.v1.config.KVPair import KVPair  # noqa: F401,E501
 from ntnx_microseg_py_client.models.common.v1.config.Message import Message  # noqa: F401,E501
 from ntnx_microseg_py_client.models.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
 
 class ApiResponseMetadata(object):
 
     """The metadata associated with an API response. This value is always present and minimally contains the self-link for the API request that produced this response. It also contains pagination data for the paginated requests. 
 
-    :param flags: (:attr:`flags`) An array of flags that may indicate the status of the response. For example a flag with name isPaginated and value false indicates that the response is not paginated. 
+    :param flags: (:attr:`flags`) An array of flags that may indicate the status of the response. For example, a flag with the name 'isPaginated' and value 'false', indicates that the response is not paginated. 
     :type flags: 
     :param links: (:attr:`links`) An array of HATEOAS style links for the response that may also include pagination links for list operations. 
     :type links: 
     :param total_available_results: (:attr:`total_available_results`) The total number of entities that are available on the server for this type. 
     :type total_available_results: 
     :param messages: (:attr:`messages`) Information, Warning or Error messages that might provide additional contextual information related to the operation. 
     :type messages: 
@@ -91,33 +92,33 @@
             self.__extra_info = extra_info
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'common.v1.response.ApiResponseMetadata'
 
-    def _initialize_fq_object_type(self):
-        return 'common.v1.r0.a3.response.ApiResponseMetadata'
+    def _initialize_object_version(self):
+        return 'v1.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -126,15 +127,15 @@
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def flags(self):
         """
-        An array of flags that may indicate the status of the response. For example a flag with name isPaginated and value false indicates that the response is not paginated. 
+        An array of flags that may indicate the status of the response. For example, a flag with the name 'isPaginated' and value 'false', indicates that the response is not paginated. 
 
         :type:
              list[ :class:`~ntnx_microseg_py_client.models.common.v1.config.Flag` ]
         """  # noqa: E501
         return self.__flags
 
     @flags.setter
@@ -238,28 +239,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/common/v1/response/ExternalizableAbstractModel.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/common/v1/response/ExternalizableAbstractModel.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,35 +3,36 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_microseg_py_client.models.common.v1.config.TenantAwareModel import TenantAwareModel  # noqa: F401,E501
 from ntnx_microseg_py_client.models.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
 
 class ExternalizableAbstractModel(TenantAwareModel):
 
-    """A model that represents an object instance that is accessible through an API endpoint.  Instances of this type get an extId field that contains the globally unique identifier for that instance.  Externally accessible instances are always tenant aware and therefore extend the TenantAwareModel 
+    """A model that represents an object instance that is accessible through an API endpoint.  Instances of this type get an extId field that contains the globally unique identifier for that instance.  Externally accessible instances are always tenant aware and, therefore, extend the TenantAwareModel 
 
     :param ext_id: (:attr:`ext_id`) A globally unique identifier of an instance that is suitable for external consumption. 
     :type ext_id: 
-    :param links: (:attr:`links`) A HATEOAS style link for the response.  Each link contains a user friendly name identifying the link and an address for retrieving the particular resource. 
+    :param links: (:attr:`links`) A HATEOAS style link for the response.  Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource. 
     :type links: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
@@ -69,16 +70,16 @@
             self.__ext_id = ext_id
         if links is not None:
             self.__links = links
 
     def _initialize_object_type(self):
         return 'common.v1.response.ExternalizableAbstractModel'
 
-    def _initialize_fq_object_type(self):
-        return 'common.v1.r0.a3.response.ExternalizableAbstractModel'
+    def _initialize_object_version(self):
+        return 'v1.r0.b1'
 
 
     @property
     def ext_id(self):
         """
         A globally unique identifier of an instance that is suitable for external consumption. 
 
@@ -94,15 +95,15 @@
             raise ValueError(r"Invalid value for `ext_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
 
         self.__ext_id = ext_id
 
     @property
     def links(self):
         """
-        A HATEOAS style link for the response.  Each link contains a user friendly name identifying the link and an address for retrieving the particular resource. 
+        A HATEOAS style link for the response.  Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource. 
 
         :type:
              list[ :class:`~ntnx_microseg_py_client.models.common.v1.response.ApiLink` ]
         """  # noqa: E501
         return self.__links
 
     @links.setter
@@ -114,28 +115,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/AddressGroup.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/GetNetworkSecurityPolicyApiResponse.py`

 * *Files 22% similar despite different names*

```diff
@@ -3,202 +3,213 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_microseg_py_client.models.common.v1.config.IPv4Address import IPv4Address  # noqa: F401,E501
-from ntnx_microseg_py_client.models.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
-from ntnx_microseg_py_client.models.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel  # noqa: F401,E501
-from ntnx_microseg_py_client.models.microseg.v4.config.IPv4Range import IPv4Range  # noqa: F401,E501
-
-class AddressGroup(ExternalizableAbstractModel):
-
-    """
-
-    :param name: (:attr:`name`) A short identifier for a address group.
-    :type name: required
-    :param description: (:attr:`description`) A user defined annotation for a address group.
-    :type description: 
-    :param ipv4_addresses: (:attr:`ipv4_addresses`) List of CIDR blocks in the address group.
-    :type ipv4_addresses: 
-    :param ip_ranges: (:attr:`ip_ranges`) List of IP range containing start and end IP.
-    :type ip_ranges: 
+from pathlib import Path
+import ntnx_microseg_py_client.models
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.GetNetworkSecurityPolicyApiResponsedata import GetNetworkSecurityPolicyApiResponsedata  # noqa: F401,E501
+from ntnx_microseg_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class GetNetworkSecurityPolicyApiResponse(object):
+
+    """REST response for all response codes in API path /microseg/v4.0.b1/config/policies/{extId} Get operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'name': 'str',
-        'description': 'str',
-        'ipv4_addresses': 'list[common.v1.config.IPv4Address]',
-        'ip_ranges': 'list[microseg.v4.config.IPv4Range]',
-        'ext_id': 'str',
-        'links': 'list[common.v1.response.ApiLink]',
-        'tenant_id': 'str',
+        'metadata': 'common.v1.response.ApiResponseMetadata',
+        'data': 'OneOfmicroseg.v4.config.GetNetworkSecurityPolicyApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'name': 'name',
-        'description': 'description',
-        'ipv4_addresses': 'ipv4Addresses',
-        'ip_ranges': 'ipRanges',
-        'ext_id': 'extId',
-        'links': 'links',
-        'tenant_id': 'tenantId',
+        'metadata': 'metadata',
+        'data': 'data',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, name=None, description=None, ipv4_addresses=None, ip_ranges=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
-        ExternalizableAbstractModel.__init__(self, ext_id, links, tenant_id, *args, **kwargs)
-        self.__name = None
-        self.__description = None
-        self.__ipv4_addresses = None
-        self.__ip_ranges = None
+    def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
+        self.__metadata = None
+        self.__data = None
         self.discriminator = None
-        self.__name = name
-        if description is not None:
-            self.__description = description
-        if ipv4_addresses is not None:
-            self.__ipv4_addresses = ipv4_addresses
-        if ip_ranges is not None:
-            self.__ip_ranges = ip_ranges
+        if metadata is not None:
+            self.__metadata = metadata
+        if data is not None:
+            self.__data = data
+        # populate hidden vars if not empty
+        self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.AddressGroup'
+        return 'microseg.v4.config.GetNetworkSecurityPolicyApiResponse'
+
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
+
+    def _populate_hidden_vars(self, kwargs):
+        if "_reserved" in kwargs and kwargs["_reserved"] is not None:
+            self.__dollar_reserved = kwargs["_reserved"]
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+            self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
+        else :
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
+        if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
+            self.__dollar_unknown_fields = kwargs["_unknown_fields"]
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+            self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
+        else :
+            self.__dollar_unknown_fields = {}
+        if "_object_type" in kwargs and kwargs["_object_type"] is not None:
+            self.__dollar_object_type = kwargs["_object_type"]
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+            self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
+        else:
+            self.__dollar_object_type = self._initialize_object_type()
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.AddressGroup'
+    def get_object_type(self):
+        return self.__dollar_object_type
 
+    def get_reserved(self):
+        return self.__dollar_reserved
+
+    def get_unknown_fields(self):
+        return self.__dollar_unknown_fields
 
     @property
-    def name(self):
+    def metadata(self):
         """
-        A short identifier for a address group.
+        
 
         :type:
-
-                :class:`~str`
+            :class:`~ntnx_microseg_py_client.models.common.v1.response.ApiResponseMetadata`
         """  # noqa: E501
-        return self.__name
+        return self.__metadata
 
-    @name.setter
-    def name(self, name):
-        if name is None:
-            raise ValueError("Invalid value for `name`, must not be `None`")  # noqa: E501
-        if name is not None and len(name) > 64:
-            raise ValueError("Invalid value for `name`, length must be less than or equal to `64`")  # noqa: E501
+    @metadata.setter
+    def metadata(self, metadata):
 
-        self.__name = name
+        self.__metadata = metadata
 
     @property
-    def description(self):
+    def data(self):
         """
-        A user defined annotation for a address group.
+        
 
         :type:
+                :class:`~ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicy` | 
+                :class:`~ntnx_microseg_py_client.models.microseg.v4.error.ErrorResponse`
+                    """  # noqa: E501
+        return self.__data
 
-                :class:`~str`
-        """  # noqa: E501
-        return self.__description
+    @data.setter
+    def data(self, data):
 
-    @description.setter
-    def description(self, description):
-        if description is not None and len(description) > 1000:
-            raise ValueError("Invalid value for `description`, length must be less than or equal to `1000`")  # noqa: E501
-
-        self.__description = description
+        self.__data = data
 
     @property
-    def ipv4_addresses(self):
+    def _reserved(self):
         """
-        List of CIDR blocks in the address group.
+        
 
         :type:
-             list[ :class:`~ntnx_microseg_py_client.models.common.v1.config.IPv4Address` ]
+            dict(str, :class:`~object`)
         """  # noqa: E501
-        return self.__ipv4_addresses
-
-    @ipv4_addresses.setter
-    def ipv4_addresses(self, ipv4_addresses):
-
-        self.__ipv4_addresses = ipv4_addresses
+        return self.__dollar_reserved
 
     @property
-    def ip_ranges(self):
+    def _object_type(self):
         """
-        List of IP range containing start and end IP.
+        
 
         :type:
-             list[ :class:`~ntnx_microseg_py_client.models.microseg.v4.config.IPv4Range` ]
+
+                :class:`~str`
         """  # noqa: E501
-        return self.__ip_ranges
+        return self.__dollar_object_type
 
-    @ip_ranges.setter
-    def ip_ranges(self, ip_ranges):
+    @property
+    def _unknown_fields(self):
+        """
+        
 
-        self.__ip_ranges = ip_ranges
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
+        return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
+            if attr_type.startswith('OneOf'):
+                type = getattr(ntnx_microseg_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(AddressGroup, dict):
+        if issubclass(GetNetworkSecurityPolicyApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -210,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, AddressGroup):
+        if not isinstance(other, GetNetworkSecurityPolicyApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/AddressGroupGetResponse.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/GetServiceGroupApiResponse.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_microseg_py_client.models
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.AddressGroupGetResponsedata import AddressGroupGetResponsedata  # noqa: F401,E501
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.GetServiceGroupApiResponsedata import GetServiceGroupApiResponsedata  # noqa: F401,E501
 from ntnx_microseg_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class AddressGroupGetResponse(object):
+class GetServiceGroupApiResponse(object):
 
-    """REST response for all response codes in API path /microseg/v4.0.a1/config/address-groups/{extId} Get operation
+    """REST response for all response codes in API path /microseg/v4.0.b1/config/service-groups/{extId} Get operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfmicroseg.v4.config.AddressGroupGetResponsedata',
+        'data': 'OneOfmicroseg.v4.config.GetServiceGroupApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.AddressGroupGetResponse'
+        return 'microseg.v4.config.GetServiceGroupApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.AddressGroupGetResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -122,15 +123,15 @@
 
     @property
     def data(self):
         """
         
 
         :type:
-                :class:`~ntnx_microseg_py_client.models.microseg.v4.config.AddressGroup` | 
+                :class:`~ntnx_microseg_py_client.models.microseg.v4.config.ServiceGroup` | 
                 :class:`~ntnx_microseg_py_client.models.microseg.v4.error.ErrorResponse`
                     """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
@@ -171,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_microseg_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(AddressGroupGetResponse, dict):
+        if issubclass(GetServiceGroupApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, AddressGroupGetResponse):
+        if not isinstance(other, GetServiceGroupApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/AddressGroupListResponse.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/ListAddressGroupsApiResponse.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_microseg_py_client.models
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.AddressGroupListResponsedata import AddressGroupListResponsedata  # noqa: F401,E501
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.ListAddressGroupsApiResponsedata import ListAddressGroupsApiResponsedata  # noqa: F401,E501
 from ntnx_microseg_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class AddressGroupListResponse(object):
+class ListAddressGroupsApiResponse(object):
 
-    """REST response for all response codes in API path /microseg/v4.0.a1/config/address-groups Get operation
+    """REST response for all response codes in API path /microseg/v4.0.b1/config/address-groups Get operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfmicroseg.v4.config.AddressGroupListResponsedata',
+        'data': 'OneOfmicroseg.v4.config.ListAddressGroupsApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.AddressGroupListResponse'
+        return 'microseg.v4.config.ListAddressGroupsApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.AddressGroupListResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -171,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_microseg_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(AddressGroupListResponse, dict):
+        if issubclass(ListAddressGroupsApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, AddressGroupListResponse):
+        if not isinstance(other, ListAddressGroupsApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/AddressGroupPolicyAssociationResponse.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/DeleteDirectoryServerConfigApiResponse.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_microseg_py_client.models
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.AddressGroupPolicyAssociationResponsedata import AddressGroupPolicyAssociationResponsedata  # noqa: F401,E501
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.DeleteDirectoryServerConfigApiResponsedata import DeleteDirectoryServerConfigApiResponsedata  # noqa: F401,E501
 from ntnx_microseg_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class AddressGroupPolicyAssociationResponse(object):
+class DeleteDirectoryServerConfigApiResponse(object):
 
-    """REST response for all response codes in API path /microseg/v4.0.a1/config/address-groups/$actions/build-policy-association Post operation
+    """REST response for all response codes in API path /microseg/v4.0.b1/config/directory-server-configs/{extId} Delete operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfmicroseg.v4.config.AddressGroupPolicyAssociationResponsedata',
+        'data': 'OneOfmicroseg.v4.config.DeleteDirectoryServerConfigApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.AddressGroupPolicyAssociationResponse'
+        return 'microseg.v4.config.DeleteDirectoryServerConfigApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.AddressGroupPolicyAssociationResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -122,15 +123,15 @@
 
     @property
     def data(self):
         """
         
 
         :type:
-                :class:`~ntnx_microseg_py_client.models.microseg.v4.config.AddressGroupPolicyReference` | 
+                :class:`~ntnx_microseg_py_client.models.prism.v4.config.TaskReference` | 
                 :class:`~ntnx_microseg_py_client.models.microseg.v4.error.ErrorResponse`
                     """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
@@ -171,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_microseg_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(AddressGroupPolicyAssociationResponse, dict):
+        if issubclass(DeleteDirectoryServerConfigApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, AddressGroupPolicyAssociationResponse):
+        if not isinstance(other, DeleteDirectoryServerConfigApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/AddressGroupPolicyReference.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/UpdateNetworkSecurityPolicyApiResponse.py`

 * *Files 14% similar despite different names*

```diff
@@ -3,141 +3,143 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-
-class AddressGroupPolicyReference(object):
-
-    """Reference to policy associated with address group.
-
-    :param address_group_uuid: (:attr:`address_group_uuid`) 
-    :type address_group_uuid: 
-    :param policy_uuids: (:attr:`policy_uuids`) 
-    :type policy_uuids: 
+from pathlib import Path
+import ntnx_microseg_py_client.models
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.UpdateNetworkSecurityPolicyApiResponsedata import UpdateNetworkSecurityPolicyApiResponsedata  # noqa: F401,E501
+from ntnx_microseg_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class UpdateNetworkSecurityPolicyApiResponse(object):
+
+    """REST response for all response codes in API path /microseg/v4.0.b1/config/policies/{extId} Put operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'address_group_uuid': 'str',
-        'policy_uuids': 'list[str]',
+        'metadata': 'common.v1.response.ApiResponseMetadata',
+        'data': 'OneOfmicroseg.v4.config.UpdateNetworkSecurityPolicyApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'address_group_uuid': 'addressGroupUuid',
-        'policy_uuids': 'policyUuids',
+        'metadata': 'metadata',
+        'data': 'data',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, address_group_uuid=None, policy_uuids=None, *args, **kwargs):  # noqa: E501
-        self.__address_group_uuid = None
-        self.__policy_uuids = None
+    def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
+        self.__metadata = None
+        self.__data = None
         self.discriminator = None
-        if address_group_uuid is not None:
-            self.__address_group_uuid = address_group_uuid
-        if policy_uuids is not None:
-            self.__policy_uuids = policy_uuids
+        if metadata is not None:
+            self.__metadata = metadata
+        if data is not None:
+            self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.AddressGroupPolicyReference'
+        return 'microseg.v4.config.UpdateNetworkSecurityPolicyApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.AddressGroupPolicyReference'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def address_group_uuid(self):
+    def metadata(self):
         """
         
 
         :type:
-
-                :class:`~str`
+            :class:`~ntnx_microseg_py_client.models.common.v1.response.ApiResponseMetadata`
         """  # noqa: E501
-        return self.__address_group_uuid
+        return self.__metadata
 
-    @address_group_uuid.setter
-    def address_group_uuid(self, address_group_uuid):
-        if address_group_uuid is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', address_group_uuid):  # noqa: E501
-            raise ValueError(r"Invalid value for `address_group_uuid`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
+    @metadata.setter
+    def metadata(self, metadata):
 
-        self.__address_group_uuid = address_group_uuid
+        self.__metadata = metadata
 
     @property
-    def policy_uuids(self):
+    def data(self):
         """
         
 
         :type:
-            list[ :class:`~str` ]
-        """  # noqa: E501
-        return self.__policy_uuids
+                :class:`~ntnx_microseg_py_client.models.prism.v4.config.TaskReference` | 
+                :class:`~ntnx_microseg_py_client.models.microseg.v4.error.ErrorResponse`
+                    """  # noqa: E501
+        return self.__data
 
-    @policy_uuids.setter
-    def policy_uuids(self, policy_uuids):
+    @data.setter
+    def data(self, data):
 
-        self.__policy_uuids = policy_uuids
+        self.__data = data
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -170,37 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
+            if attr_type.startswith('OneOf'):
+                type = getattr(ntnx_microseg_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(AddressGroupPolicyReference, dict):
+        if issubclass(UpdateNetworkSecurityPolicyApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -212,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, AddressGroupPolicyReference):
+        if not isinstance(other, UpdateNetworkSecurityPolicyApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/AddressGroupReferenceSpec.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/common/v1/config/MessageSeverity.py`

 * *Files 24% similar despite different names*

```diff
@@ -3,180 +3,126 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class AddressGroupReferenceSpec(object):
+class MessageSeverity(object):
 
-    """List of address group UUID
+    """The message severity. 
 
-    :param address_group_uuid_list: (:attr:`address_group_uuid_list`) 
-    :type address_group_uuid_list: required
 
-    """
-    """
-    IGNORE:
-    Attributes:
-      swagger_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-    IGNORE
-    """  # noqa: E501
-    swagger_types = {
-        'address_group_uuid_list': 'list[str]',
-        '_reserved': 'dict(str, object)',
-        '_object_type': 'str',
-        '_unknown_fields': 'dict(str, object)',
-    }
-
-    attribute_map = {
-        'address_group_uuid_list': 'addressGroupUuidList',
-        '_reserved': '$reserved',
-        '_object_type': '$objectType',
-        '_unknown_fields': '$unknownFields',
-    }
+    Allowed enum values:
+
+        - _UNKNOWN
+        - _REDACTED
+        - INFO: Information about successful completion.
 
+        - WARNING: Warning indicating future error.
+
+        - ERROR: Error indicating failed completion.
+
+    """
+    _UNKNOWN = "$UNKNOWN"
+    _REDACTED = "$REDACTED"
+    INFO = "INFO"
+    WARNING = "WARNING"
+    ERROR = "ERROR"
 
 
-    def __init__(self, address_group_uuid_list=None, *args, **kwargs):  # noqa: E501
-        self.__address_group_uuid_list = None
+    def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
-        self.__address_group_uuid_list = address_group_uuid_list
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.AddressGroupReferenceSpec'
+        return 'common.v1.config.MessageSeverity'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.AddressGroupReferenceSpec'
+    def _initialize_object_version(self):
+        return 'v1.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
-    @property
-    def address_group_uuid_list(self):
-        """
-        
-
-        :type:
-            list[ :class:`~str` ]
-        """  # noqa: E501
-        return self.__address_group_uuid_list
-
-    @address_group_uuid_list.setter
-    def address_group_uuid_list(self, address_group_uuid_list):
-        if address_group_uuid_list is None:
-            raise ValueError("Invalid value for `address_group_uuid_list`, must not be `None`")  # noqa: E501
-
-        self.__address_group_uuid_list = address_group_uuid_list
-
-    @property
-    def _reserved(self):
-        """
-        
-
-        :type:
-            dict(str, :class:`~object`)
-        """  # noqa: E501
-        return self.__dollar_reserved
-
-    @property
-    def _object_type(self):
-        """
-        
-
-        :type:
-
-                :class:`~str`
-        """  # noqa: E501
-        return self.__dollar_object_type
-
-    @property
-    def _unknown_fields(self):
-        """
-        
-
-        :type:
-            dict(str, :class:`~object`)
-        """  # noqa: E501
-        return self.__dollar_unknown_fields
-
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(AddressGroupReferenceSpec, dict):
+        if issubclass(MessageSeverity, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -188,15 +134,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, AddressGroupReferenceSpec):
+        if not isinstance(other, MessageSeverity):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/AddressGroupTaskResponse.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/DeleteNetworkSecurityPolicyApiResponse.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_microseg_py_client.models
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.AddressGroupTaskResponsedata import AddressGroupTaskResponsedata  # noqa: F401,E501
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.DeleteNetworkSecurityPolicyApiResponsedata import DeleteNetworkSecurityPolicyApiResponsedata  # noqa: F401,E501
 from ntnx_microseg_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class AddressGroupTaskResponse(object):
+class DeleteNetworkSecurityPolicyApiResponse(object):
 
-    """REST response for all response codes in API path /microseg/v4.0.a1/config/address-groups/{extId} Delete operation
+    """REST response for all response codes in API path /microseg/v4.0.b1/config/policies/{extId} Delete operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfmicroseg.v4.config.AddressGroupTaskResponsedata',
+        'data': 'OneOfmicroseg.v4.config.DeleteNetworkSecurityPolicyApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.AddressGroupTaskResponse'
+        return 'microseg.v4.config.DeleteNetworkSecurityPolicyApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.AddressGroupTaskResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -171,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_microseg_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(AddressGroupTaskResponse, dict):
+        if issubclass(DeleteNetworkSecurityPolicyApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, AddressGroupTaskResponse):
+        if not isinstance(other, DeleteNetworkSecurityPolicyApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/AllowType.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/AllowType.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,29 +3,30 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
 class AllowType(object):
 
-    """
+    """A specification to how allow mode traffic should be applied, either ALL or NONE.
 
 
     Allowed enum values:
 
         - _UNKNOWN
         - _REDACTED
         - ALL: Allow All Traffic.
@@ -41,33 +42,33 @@
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'microseg.v4.config.AllowType'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.AllowType'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -82,27 +83,32 @@
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/BannerGetResponse.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/CreateDirectoryServerConfigApiResponse.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_microseg_py_client.models
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.BannerGetResponsedata import BannerGetResponsedata  # noqa: F401,E501
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.CreateDirectoryServerConfigApiResponsedata import CreateDirectoryServerConfigApiResponsedata  # noqa: F401,E501
 from ntnx_microseg_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class BannerGetResponse(object):
+class CreateDirectoryServerConfigApiResponse(object):
 
-    """REST response for all response codes in API path /microseg/v4.0.a1/config/cadmus/banners Get operation
+    """REST response for all response codes in API path /microseg/v4.0.b1/config/directory-server-configs Post operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfmicroseg.v4.config.BannerGetResponsedata',
+        'data': 'OneOfmicroseg.v4.config.CreateDirectoryServerConfigApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.BannerGetResponse'
+        return 'microseg.v4.config.CreateDirectoryServerConfigApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.BannerGetResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -122,15 +123,15 @@
 
     @property
     def data(self):
         """
         
 
         :type:
-                :class:`~ntnx_microseg_py_client.models.microseg.v4.config.BannerResponse` | 
+                :class:`~ntnx_microseg_py_client.models.prism.v4.config.TaskReference` | 
                 :class:`~ntnx_microseg_py_client.models.microseg.v4.error.ErrorResponse`
                     """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
@@ -171,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_microseg_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(BannerGetResponse, dict):
+        if issubclass(CreateDirectoryServerConfigApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, BannerGetResponse):
+        if not isinstance(other, CreateDirectoryServerConfigApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/BannerResponse.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/AdStatus.py`

 * *Files 22% similar despite different names*

```diff
@@ -3,155 +3,123 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_microseg_py_client.models.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
-from ntnx_microseg_py_client.models.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel  # noqa: F401,E501
-from ntnx_microseg_py_client.models.microseg.v4.config.BannerType import BannerType  # noqa: F401,E501
+from pathlib import Path
 
-class BannerResponse(ExternalizableAbstractModel):
+class AdStatus(object):
 
-    """
+    """The mapping status of AD Mapping.
 
-    :param banner_type: (:attr:`banner_type`) 
-    :type banner_type: 
-    :param tier_memory_in_gb: (:attr:`tier_memory_in_gb`) Memory associated with the current mode of operation for cadmus.
-    :type tier_memory_in_gb: 
 
-    """
-    """
-    IGNORE:
-    Attributes:
-      swagger_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-    IGNORE
-    """  # noqa: E501
-    swagger_types = {
-        'banner_type': 'microseg.v4.config.BannerType',
-        'tier_memory_in_gb': 'int',
-        'ext_id': 'str',
-        'links': 'list[common.v1.response.ApiLink]',
-        'tenant_id': 'str',
-        '_reserved': 'dict(str, object)',
-        '_object_type': 'str',
-        '_unknown_fields': 'dict(str, object)',
-    }
-
-    attribute_map = {
-        'banner_type': 'bannerType',
-        'tier_memory_in_gb': 'tierMemoryInGB',
-        'ext_id': 'extId',
-        'links': 'links',
-        'tenant_id': 'tenantId',
-        '_reserved': '$reserved',
-        '_object_type': '$objectType',
-        '_unknown_fields': '$unknownFields',
-    }
+    Allowed enum values:
 
+        - _UNKNOWN
+        - _REDACTED
+        - USABLE: USABLE
+        - DELETED: DELETED
+        - DIRECTORY_NOT_CONFIGURED: DIRECTORY_NOT_CONFIGURED
+    """
+    _UNKNOWN = "$UNKNOWN"
+    _REDACTED = "$REDACTED"
+    USABLE = "USABLE"
+    DELETED = "DELETED"
+    DIRECTORY_NOT_CONFIGURED = "DIRECTORY_NOT_CONFIGURED"
 
 
-    def __init__(self, banner_type=None, tier_memory_in_gb=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
-        ExternalizableAbstractModel.__init__(self, ext_id, links, tenant_id, *args, **kwargs)
-        self.__banner_type = None
-        self.__tier_memory_in_gb = None
+    def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
-        if banner_type is not None:
-            self.__banner_type = banner_type
-        if tier_memory_in_gb is not None:
-            self.__tier_memory_in_gb = tier_memory_in_gb
+        # populate hidden vars if not empty
+        self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.BannerResponse'
-
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.BannerResponse'
+        return 'microseg.v4.config.AdStatus'
 
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
-    @property
-    def banner_type(self):
-        """
-        
-
-        :type:
-            :class:`~ntnx_microseg_py_client.models.microseg.v4.config.BannerType`
-        """  # noqa: E501
-        return self.__banner_type
-
-    @banner_type.setter
-    def banner_type(self, banner_type):
-
-        self.__banner_type = banner_type
-
-    @property
-    def tier_memory_in_gb(self):
-        """
-        Memory associated with the current mode of operation for cadmus.
+    def _populate_hidden_vars(self, kwargs):
+        if "_reserved" in kwargs and kwargs["_reserved"] is not None:
+            self.__dollar_reserved = kwargs["_reserved"]
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+            self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
+        else :
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
+        if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
+            self.__dollar_unknown_fields = kwargs["_unknown_fields"]
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+            self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
+        else :
+            self.__dollar_unknown_fields = {}
+        if "_object_type" in kwargs and kwargs["_object_type"] is not None:
+            self.__dollar_object_type = kwargs["_object_type"]
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+            self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
+        else:
+            self.__dollar_object_type = self._initialize_object_type()
 
-        :type:
+    def get_object_type(self):
+        return self.__dollar_object_type
 
-                :class:`~int`
-        """  # noqa: E501
-        return self.__tier_memory_in_gb
-
-    @tier_memory_in_gb.setter
-    def tier_memory_in_gb(self, tier_memory_in_gb):
-        if tier_memory_in_gb is not None and tier_memory_in_gb > 6:  # noqa: E501
-            raise ValueError("Invalid value for `tier_memory_in_gb`, must be a value less than or equal to `6`")  # noqa: E501
-        if tier_memory_in_gb is not None and tier_memory_in_gb < 2:  # noqa: E501
-            raise ValueError("Invalid value for `tier_memory_in_gb`, must be a value greater than or equal to `2`")  # noqa: E501
+    def get_reserved(self):
+        return self.__dollar_reserved
 
-        self.__tier_memory_in_gb = tier_memory_in_gb
+    def get_unknown_fields(self):
+        return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(BannerResponse, dict):
+        if issubclass(AdStatus, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -163,15 +131,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, BannerResponse):
+        if not isinstance(other, AdStatus):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/BannerType.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/MatchEntity.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,73 +3,70 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class BannerType(object):
+class MatchEntity(object):
 
-    """Shows whether the banner is for a warning(shown in yellow) or for an error(shown in red).
+    """The entity to perform matching on. Currently, only the target VM that a logon occurred on is supported.
 
 
     Allowed enum values:
 
         - _UNKNOWN
         - _REDACTED
-        - WARNING: Warning Banner
-        - ERROR: Error Banner
-        - INFO: No Banner
+        - VM: VM
     """
     _UNKNOWN = "$UNKNOWN"
     _REDACTED = "$REDACTED"
-    WARNING = "WARNING"
-    ERROR = "ERROR"
-    INFO = "INFO"
+    VM = "VM"
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.BannerType'
+        return 'microseg.v4.config.MatchEntity'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.BannerType'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -84,36 +81,41 @@
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(BannerType, dict):
+        if issubclass(MatchEntity, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -125,15 +127,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, BannerType):
+        if not isinstance(other, MatchEntity):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/CategoryMapping.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/ImportEntityType.py`

 * *Files 24% similar despite different names*

```diff
@@ -3,155 +3,127 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_microseg_py_client.models.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
-from ntnx_microseg_py_client.models.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel  # noqa: F401,E501
-from ntnx_microseg_py_client.models.microseg.v4.config.CategoryMappingInfo import CategoryMappingInfo  # noqa: F401,E501
+from pathlib import Path
 
-class CategoryMapping(ExternalizableAbstractModel):
+class ImportEntityType(object):
 
-    """
+    """Type of the entity.
 
-    :param name: (:attr:`name`) Name of category mapping.
-    :type name: required
-    :param resources: (:attr:`resources`) 
-    :type resources: required
 
-    """
-    """
-    IGNORE:
-    Attributes:
-      swagger_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-    IGNORE
-    """  # noqa: E501
-    swagger_types = {
-        'name': 'str',
-        'resources': 'microseg.v4.config.CategoryMappingInfo',
-        'ext_id': 'str',
-        'links': 'list[common.v1.response.ApiLink]',
-        'tenant_id': 'str',
-        '_reserved': 'dict(str, object)',
-        '_object_type': 'str',
-        '_unknown_fields': 'dict(str, object)',
-    }
-
-    attribute_map = {
-        'name': 'name',
-        'resources': 'resources',
-        'ext_id': 'extId',
-        'links': 'links',
-        'tenant_id': 'tenantId',
-        '_reserved': '$reserved',
-        '_object_type': '$objectType',
-        '_unknown_fields': '$unknownFields',
-    }
+    Allowed enum values:
 
+        - _UNKNOWN
+        - _REDACTED
+        - CATEGORY: Imported Category.
+        - NETWORK_FUNCTION_CHAIN: Imported Network Function Chain.
+        - POLICY: Imported Policy.
+        - ADDRESS_GROUP: Imported an Address group.
+        - SERVICE_GROUP: Imported Service group.
+    """
+    _UNKNOWN = "$UNKNOWN"
+    _REDACTED = "$REDACTED"
+    CATEGORY = "CATEGORY"
+    NETWORK_FUNCTION_CHAIN = "NETWORK_FUNCTION_CHAIN"
+    POLICY = "POLICY"
+    ADDRESS_GROUP = "ADDRESS_GROUP"
+    SERVICE_GROUP = "SERVICE_GROUP"
 
 
-    def __init__(self, name=None, resources=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
-        ExternalizableAbstractModel.__init__(self, ext_id, links, tenant_id, *args, **kwargs)
-        self.__name = None
-        self.__resources = None
+    def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
-        self.__name = name
-        self.__resources = resources
+        # populate hidden vars if not empty
+        self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.CategoryMapping'
-
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.CategoryMapping'
+        return 'microseg.v4.config.ImportEntityType'
 
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
-    @property
-    def name(self):
-        """
-        Name of category mapping.
+    def _populate_hidden_vars(self, kwargs):
+        if "_reserved" in kwargs and kwargs["_reserved"] is not None:
+            self.__dollar_reserved = kwargs["_reserved"]
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+            self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
+        else :
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
+        if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
+            self.__dollar_unknown_fields = kwargs["_unknown_fields"]
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+            self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
+        else :
+            self.__dollar_unknown_fields = {}
+        if "_object_type" in kwargs and kwargs["_object_type"] is not None:
+            self.__dollar_object_type = kwargs["_object_type"]
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+            self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
+        else:
+            self.__dollar_object_type = self._initialize_object_type()
 
-        :type:
-
-                :class:`~str`
-        """  # noqa: E501
-        return self.__name
-
-    @name.setter
-    def name(self, name):
-        if name is None:
-            raise ValueError("Invalid value for `name`, must not be `None`")  # noqa: E501
-        if name is not None and len(name) > 10000:
-            raise ValueError("Invalid value for `name`, length must be less than or equal to `10000`")  # noqa: E501
-
-        self.__name = name
-
-    @property
-    def resources(self):
-        """
-        
+    def get_object_type(self):
+        return self.__dollar_object_type
 
-        :type:
-            :class:`~ntnx_microseg_py_client.models.microseg.v4.config.CategoryMappingInfo`
-        """  # noqa: E501
-        return self.__resources
-
-    @resources.setter
-    def resources(self, resources):
-        if resources is None:
-            raise ValueError("Invalid value for `resources`, must not be `None`")  # noqa: E501
+    def get_reserved(self):
+        return self.__dollar_reserved
 
-        self.__resources = resources
+    def get_unknown_fields(self):
+        return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(CategoryMapping, dict):
+        if issubclass(ImportEntityType, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -163,15 +135,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, CategoryMapping):
+        if not isinstance(other, ImportEntityType):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/CategoryMappingAdInfo.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/ServiceGroup.py`

 * *Files 26% similar despite different names*

```diff
@@ -3,277 +3,301 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_microseg_py_client.models.microseg.v4.config.CategoryMappingAdStatus import CategoryMappingAdStatus  # noqa: F401,E501
+from pathlib import Path
+from ntnx_microseg_py_client.models.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
+from ntnx_microseg_py_client.models.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel  # noqa: F401,E501
+from ntnx_microseg_py_client.models.microseg.v4.config.IcmpTypeCodeSpec import IcmpTypeCodeSpec  # noqa: F401,E501
+from ntnx_microseg_py_client.models.microseg.v4.config.TcpPortRangeSpec import TcpPortRangeSpec  # noqa: F401,E501
+from ntnx_microseg_py_client.models.microseg.v4.config.UdpPortRangeSpec import UdpPortRangeSpec  # noqa: F401,E501
 
-class CategoryMappingAdInfo(object):
+class ServiceGroup(ExternalizableAbstractModel):
 
-    """A mapping to an object in Active Directory.
+    """
 
-    :param directory_service_name: (:attr:`directory_service_name`) The name of the directory service that will be used for mapping.
-    :type directory_service_name: 
-    :param directory_service_ext_id: (:attr:`directory_service_ext_id`) The extId of the directory service that will be used for mapping.
-    :type directory_service_ext_id: 
-    :param object_identifier: (:attr:`object_identifier`) The objectGUID for the object in AD.
-    :type object_identifier: required
-    :param object_path: (:attr:`object_path`) The path for the mapped object in AD.
-    :type object_path: 
-    :param status: (:attr:`status`) 
-    :type status: 
+    :param name: (:attr:`name`) A short identifier for a Service Group.
+    :type name: required
+    :param description: (:attr:`description`) A user defined annotation for a Service Group.
+    :type description: 
+    :param is_system_defined: (:attr:`is_system_defined`) Service Group is system defined or not.
+    :type is_system_defined: 
+    :param tcp_services: (:attr:`tcp_services`) List of TCP ports in the service.
+    :type tcp_services: 
+    :param udp_services: (:attr:`udp_services`) List of UDP ports in the service.
+    :type udp_services: 
+    :param icmp_services: (:attr:`icmp_services`) Icmp Type Code List.
+    :type icmp_services: 
+    :param policy_references: (:attr:`policy_references`) Reference to policy associated with Service Group.
+    :type policy_references: 
+    :param created_by: (:attr:`created_by`) 
+    :type created_by: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'directory_service_name': 'str',
-        'directory_service_ext_id': 'str',
-        'object_identifier': 'str',
-        'object_path': 'str',
-        'status': 'microseg.v4.config.CategoryMappingAdStatus',
+        'name': 'str',
+        'description': 'str',
+        'is_system_defined': 'bool',
+        'tcp_services': 'list[microseg.v4.config.TcpPortRangeSpec]',
+        'udp_services': 'list[microseg.v4.config.UdpPortRangeSpec]',
+        'icmp_services': 'list[microseg.v4.config.IcmpTypeCodeSpec]',
+        'policy_references': 'list[str]',
+        'created_by': 'str',
+        'ext_id': 'str',
+        'links': 'list[common.v1.response.ApiLink]',
+        'tenant_id': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'directory_service_name': 'directoryServiceName',
-        'directory_service_ext_id': 'directoryServiceExtId',
-        'object_identifier': 'objectIdentifier',
-        'object_path': 'objectPath',
-        'status': 'status',
+        'name': 'name',
+        'description': 'description',
+        'is_system_defined': 'isSystemDefined',
+        'tcp_services': 'tcpServices',
+        'udp_services': 'udpServices',
+        'icmp_services': 'icmpServices',
+        'policy_references': 'policyReferences',
+        'created_by': 'createdBy',
+        'ext_id': 'extId',
+        'links': 'links',
+        'tenant_id': 'tenantId',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, directory_service_name=None, directory_service_ext_id=None, object_identifier=None, object_path=None, status=None, *args, **kwargs):  # noqa: E501
-        self.__directory_service_name = None
-        self.__directory_service_ext_id = None
-        self.__object_identifier = None
-        self.__object_path = None
-        self.__status = None
+    def __init__(self, name=None, description=None, is_system_defined=None, tcp_services=None, udp_services=None, icmp_services=None, policy_references=None, created_by=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
+        ExternalizableAbstractModel.__init__(self, ext_id, links, tenant_id, *args, **kwargs)
+        self.__name = None
+        self.__description = None
+        self.__is_system_defined = None
+        self.__tcp_services = None
+        self.__udp_services = None
+        self.__icmp_services = None
+        self.__policy_references = None
+        self.__created_by = None
         self.discriminator = None
-        if directory_service_name is not None:
-            self.__directory_service_name = directory_service_name
-        if directory_service_ext_id is not None:
-            self.__directory_service_ext_id = directory_service_ext_id
-        self.__object_identifier = object_identifier
-        if object_path is not None:
-            self.__object_path = object_path
-        if status is not None:
-            self.__status = status
-        # populate hidden vars if not empty
-        self._populate_hidden_vars(kwargs)
+        self.__name = name
+        if description is not None:
+            self.__description = description
+        if is_system_defined is not None:
+            self.__is_system_defined = is_system_defined
+        if tcp_services is not None:
+            self.__tcp_services = tcp_services
+        if udp_services is not None:
+            self.__udp_services = udp_services
+        if icmp_services is not None:
+            self.__icmp_services = icmp_services
+        if policy_references is not None:
+            self.__policy_references = policy_references
+        if created_by is not None:
+            self.__created_by = created_by
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.CategoryMappingAdInfo'
-
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.CategoryMappingAdInfo'
-
-    def _populate_hidden_vars(self, kwargs):
-        if "_reserved" in kwargs and kwargs["_reserved"] is not None:
-            self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
-            self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
-        else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
-        if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
-            self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
-            self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
-        else :
-            self.__dollar_unknown_fields = {}
-        if "_object_type" in kwargs and kwargs["_object_type"] is not None:
-            self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
-            self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
-        else:
-            self.__dollar_object_type = self._initialize_object_type()
+        return 'microseg.v4.config.ServiceGroup'
 
-    def get_object_type(self):
-        return self.__dollar_object_type
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
-    def get_reserved(self):
-        return self.__dollar_reserved
-
-    def get_unknown_fields(self):
-        return self.__dollar_unknown_fields
 
     @property
-    def directory_service_name(self):
+    def name(self):
         """
-        The name of the directory service that will be used for mapping.
+        A short identifier for a Service Group.
 
         :type:
 
                 :class:`~str`
         """  # noqa: E501
-        return self.__directory_service_name
+        return self.__name
 
-    @directory_service_name.setter
-    def directory_service_name(self, directory_service_name):
+    @name.setter
+    def name(self, name):
+        if name is None:
+            raise ValueError("Invalid value for `name`, must not be `None`")  # noqa: E501
+        if name is not None and len(name) > 64:
+            raise ValueError("Invalid value for `name`, length must be less than or equal to `64`")  # noqa: E501
 
-        self.__directory_service_name = directory_service_name
+        self.__name = name
 
     @property
-    def directory_service_ext_id(self):
+    def description(self):
         """
-        The extId of the directory service that will be used for mapping.
+        A user defined annotation for a Service Group.
 
         :type:
 
                 :class:`~str`
         """  # noqa: E501
-        return self.__directory_service_ext_id
+        return self.__description
 
-    @directory_service_ext_id.setter
-    def directory_service_ext_id(self, directory_service_ext_id):
-        if directory_service_ext_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', directory_service_ext_id):  # noqa: E501
-            raise ValueError(r"Invalid value for `directory_service_ext_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
+    @description.setter
+    def description(self, description):
+        if description is not None and len(description) > 1000:
+            raise ValueError("Invalid value for `description`, length must be less than or equal to `1000`")  # noqa: E501
 
-        self.__directory_service_ext_id = directory_service_ext_id
+        self.__description = description
 
     @property
-    def object_identifier(self):
+    def is_system_defined(self):
         """
-        The objectGUID for the object in AD.
+        Service Group is system defined or not.
 
         :type:
 
-                :class:`~str`
+                :class:`~bool`
         """  # noqa: E501
-        return self.__object_identifier
+        return self.__is_system_defined
 
-    @object_identifier.setter
-    def object_identifier(self, object_identifier):
-        if object_identifier is None:
-            raise ValueError("Invalid value for `object_identifier`, must not be `None`")  # noqa: E501
-        if object_identifier is not None and len(object_identifier) > 200:
-            raise ValueError("Invalid value for `object_identifier`, length must be less than or equal to `200`")  # noqa: E501
+    @is_system_defined.setter
+    def is_system_defined(self, is_system_defined):
 
-        self.__object_identifier = object_identifier
+        self.__is_system_defined = is_system_defined
 
     @property
-    def object_path(self):
+    def tcp_services(self):
         """
-        The path for the mapped object in AD.
+        List of TCP ports in the service.
 
         :type:
-
-                :class:`~str`
+             list[ :class:`~ntnx_microseg_py_client.models.microseg.v4.config.TcpPortRangeSpec` ]
         """  # noqa: E501
-        return self.__object_path
+        return self.__tcp_services
 
-    @object_path.setter
-    def object_path(self, object_path):
+    @tcp_services.setter
+    def tcp_services(self, tcp_services):
 
-        self.__object_path = object_path
+        self.__tcp_services = tcp_services
 
     @property
-    def status(self):
+    def udp_services(self):
         """
-        
+        List of UDP ports in the service.
 
         :type:
-            :class:`~ntnx_microseg_py_client.models.microseg.v4.config.CategoryMappingAdStatus`
+             list[ :class:`~ntnx_microseg_py_client.models.microseg.v4.config.UdpPortRangeSpec` ]
         """  # noqa: E501
-        return self.__status
+        return self.__udp_services
 
-    @status.setter
-    def status(self, status):
+    @udp_services.setter
+    def udp_services(self, udp_services):
 
-        self.__status = status
+        self.__udp_services = udp_services
 
     @property
-    def _reserved(self):
+    def icmp_services(self):
         """
-        
+        Icmp Type Code List.
 
         :type:
-            dict(str, :class:`~object`)
+             list[ :class:`~ntnx_microseg_py_client.models.microseg.v4.config.IcmpTypeCodeSpec` ]
         """  # noqa: E501
-        return self.__dollar_reserved
+        return self.__icmp_services
+
+    @icmp_services.setter
+    def icmp_services(self, icmp_services):
+
+        self.__icmp_services = icmp_services
 
     @property
-    def _object_type(self):
+    def policy_references(self):
         """
-        
+        Reference to policy associated with Service Group.
 
         :type:
-
-                :class:`~str`
+            list[ :class:`~str` ]
         """  # noqa: E501
-        return self.__dollar_object_type
+        return self.__policy_references
+
+    @policy_references.setter
+    def policy_references(self, policy_references):
+
+        self.__policy_references = policy_references
 
     @property
-    def _unknown_fields(self):
+    def created_by(self):
         """
         
 
         :type:
-            dict(str, :class:`~object`)
+
+                :class:`~str`
         """  # noqa: E501
-        return self.__dollar_unknown_fields
+        return self.__created_by
+
+    @created_by.setter
+    def created_by(self, created_by):
+        if created_by is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', created_by):  # noqa: E501
+            raise ValueError(r"Invalid value for `created_by`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
+
+        self.__created_by = created_by
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(CategoryMappingAdInfo, dict):
+        if issubclass(ServiceGroup, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -285,15 +309,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, CategoryMappingAdInfo):
+        if not isinstance(other, ServiceGroup):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/CategoryMappingAdStatus.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/RuleType.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,73 +3,76 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class CategoryMappingAdStatus(object):
+class RuleType(object):
 
-    """The mapping status of AD Mapping.
+    """The type for a rule - the value chosen here restricts which specification can be chosen.
 
 
     Allowed enum values:
 
         - _UNKNOWN
         - _REDACTED
-        - USABLE: USABLE
-        - DELETED: DELETED
-        - DIRECTORY_NOT_CONFIGURED: DIRECTORY_NOT_CONFIGURED
+        - QUARANTINE: An Application Rule where inbound and outbound traffic is not allowed.
+        - TWO_ENV_ISOLATION: A rule for specifying that two environments should be isolated from each other. Specify both 'firstIsolationGroup' and 'secondIsolationGroup'.
+        - APPLICATION: A rule for specifying allowed traffic for an application.
+        - INTRA_GROUP: A rule for specifying allowed traffic inside of a secured entity group.
     """
     _UNKNOWN = "$UNKNOWN"
     _REDACTED = "$REDACTED"
-    USABLE = "USABLE"
-    DELETED = "DELETED"
-    DIRECTORY_NOT_CONFIGURED = "DIRECTORY_NOT_CONFIGURED"
+    QUARANTINE = "QUARANTINE"
+    TWO_ENV_ISOLATION = "TWO_ENV_ISOLATION"
+    APPLICATION = "APPLICATION"
+    INTRA_GROUP = "INTRA_GROUP"
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.CategoryMappingAdStatus'
+        return 'microseg.v4.config.RuleType'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.CategoryMappingAdStatus'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -84,36 +87,41 @@
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(CategoryMappingAdStatus, dict):
+        if issubclass(RuleType, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -125,15 +133,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, CategoryMappingAdStatus):
+        if not isinstance(other, RuleType):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/CategoryMappingInfo.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/ListDsCategoryMappingsApiResponse.py`

 * *Files 16% similar despite different names*

```diff
@@ -3,170 +3,143 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_microseg_py_client.models.microseg.v4.config.CategoryMappingAdInfo import CategoryMappingAdInfo  # noqa: F401,E501
-
-class CategoryMappingInfo(object):
-
-    """A mapping from an object to a category value.
-
-    :param category_name: (:attr:`category_name`) The name for the category that this mapping is for.
-    :type category_name: required
-    :param category_value: (:attr:`category_value`) The value for the category that this mapping is for.
-    :type category_value: required
-    :param ad_mapping: (:attr:`ad_mapping`) 
-    :type ad_mapping: required
+from pathlib import Path
+import ntnx_microseg_py_client.models
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.ListDsCategoryMappingsApiResponsedata import ListDsCategoryMappingsApiResponsedata  # noqa: F401,E501
+from ntnx_microseg_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class ListDsCategoryMappingsApiResponse(object):
+
+    """REST response for all response codes in API path /microseg/v4.0.b1/config/category-mappings Get operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'category_name': 'str',
-        'category_value': 'str',
-        'ad_mapping': 'microseg.v4.config.CategoryMappingAdInfo',
+        'metadata': 'common.v1.response.ApiResponseMetadata',
+        'data': 'OneOfmicroseg.v4.config.ListDsCategoryMappingsApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'category_name': 'categoryName',
-        'category_value': 'categoryValue',
-        'ad_mapping': 'adMapping',
+        'metadata': 'metadata',
+        'data': 'data',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, category_name=None, category_value=None, ad_mapping=None, *args, **kwargs):  # noqa: E501
-        self.__category_name = None
-        self.__category_value = None
-        self.__ad_mapping = None
+    def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
+        self.__metadata = None
+        self.__data = None
         self.discriminator = None
-        self.__category_name = category_name
-        self.__category_value = category_value
-        self.__ad_mapping = ad_mapping
+        if metadata is not None:
+            self.__metadata = metadata
+        if data is not None:
+            self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.CategoryMappingInfo'
+        return 'microseg.v4.config.ListDsCategoryMappingsApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.CategoryMappingInfo'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def category_name(self):
+    def metadata(self):
         """
-        The name for the category that this mapping is for.
-
-        :type:
-
-                :class:`~str`
-        """  # noqa: E501
-        return self.__category_name
-
-    @category_name.setter
-    def category_name(self, category_name):
-        if category_name is None:
-            raise ValueError("Invalid value for `category_name`, must not be `None`")  # noqa: E501
-        if category_name is not None and len(category_name) > 200:
-            raise ValueError("Invalid value for `category_name`, length must be less than or equal to `200`")  # noqa: E501
-
-        self.__category_name = category_name
-
-    @property
-    def category_value(self):
-        """
-        The value for the category that this mapping is for.
+        
 
         :type:
-
-                :class:`~str`
+            :class:`~ntnx_microseg_py_client.models.common.v1.response.ApiResponseMetadata`
         """  # noqa: E501
-        return self.__category_value
+        return self.__metadata
 
-    @category_value.setter
-    def category_value(self, category_value):
-        if category_value is None:
-            raise ValueError("Invalid value for `category_value`, must not be `None`")  # noqa: E501
-        if category_value is not None and len(category_value) > 200:
-            raise ValueError("Invalid value for `category_value`, length must be less than or equal to `200`")  # noqa: E501
+    @metadata.setter
+    def metadata(self, metadata):
 
-        self.__category_value = category_value
+        self.__metadata = metadata
 
     @property
-    def ad_mapping(self):
+    def data(self):
         """
         
 
         :type:
-            :class:`~ntnx_microseg_py_client.models.microseg.v4.config.CategoryMappingAdInfo`
-        """  # noqa: E501
-        return self.__ad_mapping
+                :class:`~ntnx_microseg_py_client.models.microseg.v4.config.CategoryMapping` | 
+                :class:`~ntnx_microseg_py_client.models.microseg.v4.error.ErrorResponse`
+                    """  # noqa: E501
+        return self.__data
 
-    @ad_mapping.setter
-    def ad_mapping(self, ad_mapping):
-        if ad_mapping is None:
-            raise ValueError("Invalid value for `ad_mapping`, must not be `None`")  # noqa: E501
+    @data.setter
+    def data(self, data):
 
-        self.__ad_mapping = ad_mapping
+        self.__data = data
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -199,37 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
+            if attr_type.startswith('OneOf'):
+                type = getattr(ntnx_microseg_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(CategoryMappingInfo, dict):
+        if issubclass(ListDsCategoryMappingsApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -241,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, CategoryMappingInfo):
+        if not isinstance(other, ListDsCategoryMappingsApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/ConfigMigrationPolicyOptions.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/UpdateDirectoryServerConfigApiResponse.py`

 * *Files 13% similar despite different names*

```diff
@@ -3,140 +3,143 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-
-class ConfigMigrationPolicyOptions(object):
-
-    """Policy-wide options for a security policy.
-
-    :param is_ipv6_traffic_allowed: (:attr:`is_ipv6_traffic_allowed`) 
-    :type is_ipv6_traffic_allowed: 
-    :param is_hitlog_enabled: (:attr:`is_hitlog_enabled`) 
-    :type is_hitlog_enabled: 
+from pathlib import Path
+import ntnx_microseg_py_client.models
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.UpdateDirectoryServerConfigApiResponsedata import UpdateDirectoryServerConfigApiResponsedata  # noqa: F401,E501
+from ntnx_microseg_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class UpdateDirectoryServerConfigApiResponse(object):
+
+    """REST response for all response codes in API path /microseg/v4.0.b1/config/directory-server-configs/{extId} Put operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'is_ipv6_traffic_allowed': 'bool',
-        'is_hitlog_enabled': 'bool',
+        'metadata': 'common.v1.response.ApiResponseMetadata',
+        'data': 'OneOfmicroseg.v4.config.UpdateDirectoryServerConfigApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'is_ipv6_traffic_allowed': 'isIpv6TrafficAllowed',
-        'is_hitlog_enabled': 'isHitlogEnabled',
+        'metadata': 'metadata',
+        'data': 'data',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, is_ipv6_traffic_allowed=False, is_hitlog_enabled=False, *args, **kwargs):  # noqa: E501
-        self.__is_ipv6_traffic_allowed = None
-        self.__is_hitlog_enabled = None
+    def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
+        self.__metadata = None
+        self.__data = None
         self.discriminator = None
-        if is_ipv6_traffic_allowed is not None:
-            self.__is_ipv6_traffic_allowed = is_ipv6_traffic_allowed
-        if is_hitlog_enabled is not None:
-            self.__is_hitlog_enabled = is_hitlog_enabled
+        if metadata is not None:
+            self.__metadata = metadata
+        if data is not None:
+            self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.ConfigMigrationPolicyOptions'
+        return 'microseg.v4.config.UpdateDirectoryServerConfigApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.ConfigMigrationPolicyOptions'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def is_ipv6_traffic_allowed(self):
+    def metadata(self):
         """
         
 
         :type:
-
-                :class:`~bool`
+            :class:`~ntnx_microseg_py_client.models.common.v1.response.ApiResponseMetadata`
         """  # noqa: E501
-        return self.__is_ipv6_traffic_allowed
+        return self.__metadata
 
-    @is_ipv6_traffic_allowed.setter
-    def is_ipv6_traffic_allowed(self, is_ipv6_traffic_allowed):
+    @metadata.setter
+    def metadata(self, metadata):
 
-        self.__is_ipv6_traffic_allowed = is_ipv6_traffic_allowed
+        self.__metadata = metadata
 
     @property
-    def is_hitlog_enabled(self):
+    def data(self):
         """
         
 
         :type:
+                :class:`~ntnx_microseg_py_client.models.prism.v4.config.TaskReference` | 
+                :class:`~ntnx_microseg_py_client.models.microseg.v4.error.ErrorResponse`
+                    """  # noqa: E501
+        return self.__data
 
-                :class:`~bool`
-        """  # noqa: E501
-        return self.__is_hitlog_enabled
-
-    @is_hitlog_enabled.setter
-    def is_hitlog_enabled(self, is_hitlog_enabled):
+    @data.setter
+    def data(self, data):
 
-        self.__is_hitlog_enabled = is_hitlog_enabled
+        self.__data = data
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -169,37 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
+            if attr_type.startswith('OneOf'):
+                type = getattr(ntnx_microseg_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ConfigMigrationPolicyOptions, dict):
+        if issubclass(UpdateDirectoryServerConfigApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -211,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ConfigMigrationPolicyOptions):
+        if not isinstance(other, UpdateDirectoryServerConfigApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/ConfigMigrationPolicyType.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/SecurityPolicyState.py`

 * *Files 9% similar despite different names*

```diff
@@ -3,75 +3,74 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class ConfigMigrationPolicyType(object):
+class SecurityPolicyState(object):
 
-    """Defines the type of rules that can be used in a policy.<br> It can be one of following types   - QUARANTINE POLICY   - ISOLATION POLICY   - APPLICATION POLICY   - AD POLICY 
+    """Whether the policy is applied or monitored; can be omitted or set null to save the policy without applying or monitoring it.
 
 
     Allowed enum values:
 
         - _UNKNOWN
         - _REDACTED
-        - QUARANTINE: A Policy where inbound and outbound traffic is not allowed.
-        - ISOLATION: A Policy where two environments are isolated from each other.
-        - APPLICATION: A Policy for specifying allowed traffic for an application.
-        - AD: A Policy for securing an AD group.
+        - SAVE: Policy is just created and saved in DB.
+        - MONITOR: Monitors the flow and doesn't drop the traffic.
+        - ENFORCE: Policy is enforced and the traffic from/to specified inbounds/outbounds is allowed and rest is dropped.
     """
     _UNKNOWN = "$UNKNOWN"
     _REDACTED = "$REDACTED"
-    QUARANTINE = "QUARANTINE"
-    ISOLATION = "ISOLATION"
-    APPLICATION = "APPLICATION"
-    AD = "AD"
+    SAVE = "SAVE"
+    MONITOR = "MONITOR"
+    ENFORCE = "ENFORCE"
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.ConfigMigrationPolicyType'
+        return 'microseg.v4.config.SecurityPolicyState'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.ConfigMigrationPolicyType'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -86,36 +85,41 @@
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ConfigMigrationPolicyType, dict):
+        if issubclass(SecurityPolicyState, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -127,15 +131,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ConfigMigrationPolicyType):
+        if not isinstance(other, SecurityPolicyState):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/ConfigMigrationPreviewGetResponse.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/GetDirectoryServerConfigApiResponse.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_microseg_py_client.models
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.ConfigMigrationPreviewGetResponsedata import ConfigMigrationPreviewGetResponsedata  # noqa: F401,E501
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.GetDirectoryServerConfigApiResponsedata import GetDirectoryServerConfigApiResponsedata  # noqa: F401,E501
 from ntnx_microseg_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class ConfigMigrationPreviewGetResponse(object):
+class GetDirectoryServerConfigApiResponse(object):
 
-    """REST response for all response codes in API path /microseg/v4.0.a1/config/flow-migrator/previews/{extId} Get operation
+    """REST response for all response codes in API path /microseg/v4.0.b1/config/directory-server-configs/{extId} Get operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfmicroseg.v4.config.ConfigMigrationPreviewGetResponsedata',
+        'data': 'OneOfmicroseg.v4.config.GetDirectoryServerConfigApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.ConfigMigrationPreviewGetResponse'
+        return 'microseg.v4.config.GetDirectoryServerConfigApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.ConfigMigrationPreviewGetResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -122,15 +123,15 @@
 
     @property
     def data(self):
         """
         
 
         :type:
-                :class:`~ntnx_microseg_py_client.models.microseg.v4.config.ConfigMigrationPreviewResponse` | 
+                :class:`~ntnx_microseg_py_client.models.microseg.v4.config.DirectoryServerConfig` | 
                 :class:`~ntnx_microseg_py_client.models.microseg.v4.error.ErrorResponse`
                     """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
@@ -171,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_microseg_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ConfigMigrationPreviewGetResponse, dict):
+        if issubclass(GetDirectoryServerConfigApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ConfigMigrationPreviewGetResponse):
+        if not isinstance(other, GetDirectoryServerConfigApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/ConfigMigrationPreviewResponse.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/operation/PolicyPreview.py`

 * *Files 13% similar despite different names*

```diff
@@ -3,36 +3,37 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_microseg_py_client.models.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
 from ntnx_microseg_py_client.models.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel  # noqa: F401,E501
 from ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicy import NetworkSecurityPolicy  # noqa: F401,E501
 
-class ConfigMigrationPreviewResponse(ExternalizableAbstractModel):
+class PolicyPreview(ExternalizableAbstractModel):
 
     """
 
     :param new_policy_spec: (:attr:`new_policy_spec`) 
     :type new_policy_spec: 
-    :param system_generated_policies: (:attr:`system_generated_policies`) This field corresponds to a list of policy spec which captures the system generated FNS 2.0 policies as a result of a single FNS 1.0 policy migration. 
+    :param system_generated_policies: (:attr:`system_generated_policies`) This field corresponds to a list of policy specifications which captures the system generated FNS Next-Gen policies as a result of a single FNS policy upgrade. 
     :type system_generated_policies: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
@@ -72,18 +73,18 @@
         self.discriminator = None
         if new_policy_spec is not None:
             self.__new_policy_spec = new_policy_spec
         if system_generated_policies is not None:
             self.__system_generated_policies = system_generated_policies
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.ConfigMigrationPreviewResponse'
+        return 'microseg.v4.operation.PolicyPreview'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.ConfigMigrationPreviewResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     @property
     def new_policy_spec(self):
         """
         
 
@@ -96,15 +97,15 @@
     def new_policy_spec(self, new_policy_spec):
 
         self.__new_policy_spec = new_policy_spec
 
     @property
     def system_generated_policies(self):
         """
-        This field corresponds to a list of policy spec which captures the system generated FNS 2.0 policies as a result of a single FNS 1.0 policy migration. 
+        This field corresponds to a list of policy specifications which captures the system generated FNS Next-Gen policies as a result of a single FNS policy upgrade. 
 
         :type:
              list[ :class:`~ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicy` ]
         """  # noqa: E501
         return self.__system_generated_policies
 
     @system_generated_policies.setter
@@ -116,37 +117,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ConfigMigrationPreviewResponse, dict):
+        if issubclass(PolicyPreview, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -158,15 +164,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ConfigMigrationPreviewResponse):
+        if not isinstance(other, PolicyPreview):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/ConfigMigrationSummary.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/ImportEntity.py`

 * *Files 22% similar despite different names*

```diff
@@ -3,197 +3,237 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_microseg_py_client.models.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
-from ntnx_microseg_py_client.models.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel  # noqa: F401,E501
-from ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyMigrationCountSummary import NetworkSecurityPolicyMigrationCountSummary  # noqa: F401,E501
-from ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyMigrationSubnetSummary import NetworkSecurityPolicyMigrationSubnetSummary  # noqa: F401,E501
-from ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyMigrationSummary import NetworkSecurityPolicyMigrationSummary  # noqa: F401,E501
-from ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyMigrationSummaryFailures import NetworkSecurityPolicyMigrationSummaryFailures  # noqa: F401,E501
-
-class ConfigMigrationSummary(ExternalizableAbstractModel):
-
-    """
-
-    :param policy_summaries: (:attr:`policy_summaries`) 
-    :type policy_summaries: 
-    :param count_summary: (:attr:`count_summary`) 
-    :type count_summary: 
-    :param subnet_summaries: (:attr:`subnet_summaries`) 
-    :type subnet_summaries: 
-    :param summary_failures: (:attr:`summary_failures`) 
-    :type summary_failures: 
+from pathlib import Path
+from ntnx_microseg_py_client.models.microseg.v4.config.ImportEntityType import ImportEntityType  # noqa: F401,E501
+from ntnx_microseg_py_client.models.microseg.v4.config.ImportEntityUpdateType import ImportEntityUpdateType  # noqa: F401,E501
+
+class ImportEntity(object):
+
+    """Network security rule import response data.
+
+    :param type: (:attr:`type`) 
+    :type type: required
+    :param name: (:attr:`name`) Name of the entity.
+    :type name: required
+    :param update_type: (:attr:`update_type`) 
+    :type update_type: required
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'policy_summaries': 'list[microseg.v4.config.NetworkSecurityPolicyMigrationSummary]',
-        'count_summary': 'microseg.v4.config.NetworkSecurityPolicyMigrationCountSummary',
-        'subnet_summaries': 'list[microseg.v4.config.NetworkSecurityPolicyMigrationSubnetSummary]',
-        'summary_failures': 'list[microseg.v4.config.NetworkSecurityPolicyMigrationSummaryFailures]',
-        'ext_id': 'str',
-        'links': 'list[common.v1.response.ApiLink]',
-        'tenant_id': 'str',
+        'type': 'microseg.v4.config.ImportEntityType',
+        'name': 'str',
+        'update_type': 'microseg.v4.config.ImportEntityUpdateType',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'policy_summaries': 'policySummaries',
-        'count_summary': 'countSummary',
-        'subnet_summaries': 'subnetSummaries',
-        'summary_failures': 'summaryFailures',
-        'ext_id': 'extId',
-        'links': 'links',
-        'tenant_id': 'tenantId',
+        'type': 'type',
+        'name': 'name',
+        'update_type': 'updateType',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, policy_summaries=None, count_summary=None, subnet_summaries=None, summary_failures=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
-        ExternalizableAbstractModel.__init__(self, ext_id, links, tenant_id, *args, **kwargs)
-        self.__policy_summaries = None
-        self.__count_summary = None
-        self.__subnet_summaries = None
-        self.__summary_failures = None
+    def __init__(self, type=None, name=None, update_type=None, *args, **kwargs):  # noqa: E501
+        self.__type = None
+        self.__name = None
+        self.__update_type = None
         self.discriminator = None
-        if policy_summaries is not None:
-            self.__policy_summaries = policy_summaries
-        if count_summary is not None:
-            self.__count_summary = count_summary
-        if subnet_summaries is not None:
-            self.__subnet_summaries = subnet_summaries
-        if summary_failures is not None:
-            self.__summary_failures = summary_failures
+        self.__type = type
+        self.__name = name
+        self.__update_type = update_type
+        # populate hidden vars if not empty
+        self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.ConfigMigrationSummary'
+        return 'microseg.v4.config.ImportEntity'
+
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
+
+    def _populate_hidden_vars(self, kwargs):
+        if "_reserved" in kwargs and kwargs["_reserved"] is not None:
+            self.__dollar_reserved = kwargs["_reserved"]
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+            self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
+        else :
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
+        if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
+            self.__dollar_unknown_fields = kwargs["_unknown_fields"]
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+            self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
+        else :
+            self.__dollar_unknown_fields = {}
+        if "_object_type" in kwargs and kwargs["_object_type"] is not None:
+            self.__dollar_object_type = kwargs["_object_type"]
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+            self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
+        else:
+            self.__dollar_object_type = self._initialize_object_type()
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.ConfigMigrationSummary'
+    def get_object_type(self):
+        return self.__dollar_object_type
 
+    def get_reserved(self):
+        return self.__dollar_reserved
+
+    def get_unknown_fields(self):
+        return self.__dollar_unknown_fields
 
     @property
-    def policy_summaries(self):
+    def type(self):
         """
         
 
         :type:
-             list[ :class:`~ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyMigrationSummary` ]
+            :class:`~ntnx_microseg_py_client.models.microseg.v4.config.ImportEntityType`
         """  # noqa: E501
-        return self.__policy_summaries
+        return self.__type
 
-    @policy_summaries.setter
-    def policy_summaries(self, policy_summaries):
+    @type.setter
+    def type(self, type):
+        if type is None:
+            raise ValueError("Invalid value for `type`, must not be `None`")  # noqa: E501
 
-        self.__policy_summaries = policy_summaries
+        self.__type = type
 
     @property
-    def count_summary(self):
+    def name(self):
         """
-        
+        Name of the entity.
 
         :type:
-            :class:`~ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyMigrationCountSummary`
+
+                :class:`~str`
         """  # noqa: E501
-        return self.__count_summary
+        return self.__name
 
-    @count_summary.setter
-    def count_summary(self, count_summary):
+    @name.setter
+    def name(self, name):
+        if name is None:
+            raise ValueError("Invalid value for `name`, must not be `None`")  # noqa: E501
+        if name is not None and len(name) > 100:
+            raise ValueError("Invalid value for `name`, length must be less than or equal to `100`")  # noqa: E501
 
-        self.__count_summary = count_summary
+        self.__name = name
 
     @property
-    def subnet_summaries(self):
+    def update_type(self):
         """
         
 
         :type:
-             list[ :class:`~ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyMigrationSubnetSummary` ]
+            :class:`~ntnx_microseg_py_client.models.microseg.v4.config.ImportEntityUpdateType`
         """  # noqa: E501
-        return self.__subnet_summaries
+        return self.__update_type
 
-    @subnet_summaries.setter
-    def subnet_summaries(self, subnet_summaries):
+    @update_type.setter
+    def update_type(self, update_type):
+        if update_type is None:
+            raise ValueError("Invalid value for `update_type`, must not be `None`")  # noqa: E501
+
+        self.__update_type = update_type
+
+    @property
+    def _reserved(self):
+        """
+        
 
-        self.__subnet_summaries = subnet_summaries
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
+        return self.__dollar_reserved
 
     @property
-    def summary_failures(self):
+    def _object_type(self):
         """
         
 
         :type:
-             list[ :class:`~ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyMigrationSummaryFailures` ]
+
+                :class:`~str`
         """  # noqa: E501
-        return self.__summary_failures
+        return self.__dollar_object_type
 
-    @summary_failures.setter
-    def summary_failures(self, summary_failures):
+    @property
+    def _unknown_fields(self):
+        """
+        
 
-        self.__summary_failures = summary_failures
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
+        return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ConfigMigrationSummary, dict):
+        if issubclass(ImportEntity, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -205,15 +245,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ConfigMigrationSummary):
+        if not isinstance(other, ImportEntity):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/ConfigMigrationSummaryGetResponse.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/CreateNetworkSecurityPolicyImportApiResponse.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_microseg_py_client.models
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.ConfigMigrationSummaryGetResponsedata import ConfigMigrationSummaryGetResponsedata  # noqa: F401,E501
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.CreateNetworkSecurityPolicyImportApiResponsedata import CreateNetworkSecurityPolicyImportApiResponsedata  # noqa: F401,E501
 from ntnx_microseg_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class ConfigMigrationSummaryGetResponse(object):
+class CreateNetworkSecurityPolicyImportApiResponse(object):
 
-    """REST response for all response codes in API path /microseg/v4.0.a1/config/flow-migrator/summaries/{extId} Get operation
+    """REST response for all response codes in API path /microseg/v4.0.b1/config/policies/$actions/import Post operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfmicroseg.v4.config.ConfigMigrationSummaryGetResponsedata',
+        'data': 'OneOfmicroseg.v4.config.CreateNetworkSecurityPolicyImportApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.ConfigMigrationSummaryGetResponse'
+        return 'microseg.v4.config.CreateNetworkSecurityPolicyImportApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.ConfigMigrationSummaryGetResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -122,15 +123,16 @@
 
     @property
     def data(self):
         """
         
 
         :type:
-                :class:`~ntnx_microseg_py_client.models.microseg.v4.config.ConfigMigrationSummary` | 
+                :class:`~ntnx_microseg_py_client.models.prism.v4.config.TaskReference` | 
+                :class:`~ntnx_microseg_py_client.models.microseg.v4.config.ImportEntity` | 
                 :class:`~ntnx_microseg_py_client.models.microseg.v4.error.ErrorResponse`
                     """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
@@ -171,39 +173,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_microseg_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ConfigMigrationSummaryGetResponse, dict):
+        if issubclass(CreateNetworkSecurityPolicyImportApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +222,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ConfigMigrationSummaryGetResponse):
+        if not isinstance(other, CreateNetworkSecurityPolicyImportApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/DirectoryServer.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/DirectoryServerConfig.py`

 * *Files 17% similar despite different names*

```diff
@@ -3,44 +3,43 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
+from ntnx_microseg_py_client.models.common.v1.config.IPAddressOrFQDN import IPAddressOrFQDN  # noqa: F401,E501
 from ntnx_microseg_py_client.models.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
 from ntnx_microseg_py_client.models.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel  # noqa: F401,E501
-from ntnx_microseg_py_client.models.microseg.v4.config.DomainController import DomainController  # noqa: F401,E501
 from ntnx_microseg_py_client.models.microseg.v4.config.MatchingCriteria import MatchingCriteria  # noqa: F401,E501
 
-class DirectoryServer(ExternalizableAbstractModel):
+class DirectoryServerConfig(ExternalizableAbstractModel):
 
     """
 
-    :param is_default_category_enabled: (:attr:`is_default_category_enabled`) Enablement status of the default category. (**Default** False)
+    :param is_default_category_enabled: (:attr:`is_default_category_enabled`) Enablement status of the default category.
     :type is_default_category_enabled: 
-    :param should_keep_default_category_on_login: (:attr:`should_keep_default_category_on_login`) Retain default category on user login. (**Default** False)
+    :param should_keep_default_category_on_login: (:attr:`should_keep_default_category_on_login`) Retain default category on user login.
     :type should_keep_default_category_on_login: 
     :param matching_criterias: (:attr:`matching_criterias`) The matching criteria used to determine whether an entity will be categorized by identity categorization. If match type is ALL, all the entities will be categorized.
     :type matching_criterias: 
-    :param directory_service_name: (:attr:`directory_service_name`) The name of the directory service that will be used for mapping.
-    :type directory_service_name: 
-    :param directory_service_ext_id: (:attr:`directory_service_ext_id`) The extId of the directory service that will be used for mapping.
-    :type directory_service_ext_id: 
+    :param directory_service_reference: (:attr:`directory_service_reference`) The ExtID of the directory service that will be used for mapping.
+    :type directory_service_reference: 
     :param domain_controllers: (:attr:`domain_controllers`) List of domain controllers to be used for event scraping.
     :type domain_controllers: 
 
     """
     """
     IGNORE:
     Attributes:
@@ -50,69 +49,64 @@
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'is_default_category_enabled': 'bool',
         'should_keep_default_category_on_login': 'bool',
         'matching_criterias': 'list[microseg.v4.config.MatchingCriteria]',
-        'directory_service_name': 'str',
-        'directory_service_ext_id': 'str',
-        'domain_controllers': 'list[microseg.v4.config.DomainController]',
+        'directory_service_reference': 'str',
+        'domain_controllers': 'list[common.v1.config.IPAddressOrFQDN]',
         'ext_id': 'str',
         'links': 'list[common.v1.response.ApiLink]',
         'tenant_id': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'is_default_category_enabled': 'isDefaultCategoryEnabled',
         'should_keep_default_category_on_login': 'shouldKeepDefaultCategoryOnLogin',
         'matching_criterias': 'matchingCriterias',
-        'directory_service_name': 'directoryServiceName',
-        'directory_service_ext_id': 'directoryServiceExtId',
+        'directory_service_reference': 'directoryServiceReference',
         'domain_controllers': 'domainControllers',
         'ext_id': 'extId',
         'links': 'links',
         'tenant_id': 'tenantId',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, is_default_category_enabled=False, should_keep_default_category_on_login=False, matching_criterias=None, directory_service_name=None, directory_service_ext_id=None, domain_controllers=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
+    def __init__(self, is_default_category_enabled=None, should_keep_default_category_on_login=None, matching_criterias=None, directory_service_reference=None, domain_controllers=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
         ExternalizableAbstractModel.__init__(self, ext_id, links, tenant_id, *args, **kwargs)
         self.__is_default_category_enabled = None
         self.__should_keep_default_category_on_login = None
         self.__matching_criterias = None
-        self.__directory_service_name = None
-        self.__directory_service_ext_id = None
+        self.__directory_service_reference = None
         self.__domain_controllers = None
         self.discriminator = None
         if is_default_category_enabled is not None:
             self.__is_default_category_enabled = is_default_category_enabled
         if should_keep_default_category_on_login is not None:
             self.__should_keep_default_category_on_login = should_keep_default_category_on_login
         if matching_criterias is not None:
             self.__matching_criterias = matching_criterias
-        if directory_service_name is not None:
-            self.__directory_service_name = directory_service_name
-        if directory_service_ext_id is not None:
-            self.__directory_service_ext_id = directory_service_ext_id
+        if directory_service_reference is not None:
+            self.__directory_service_reference = directory_service_reference
         if domain_controllers is not None:
             self.__domain_controllers = domain_controllers
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.DirectoryServer'
+        return 'microseg.v4.config.DirectoryServerConfig'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.DirectoryServer'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     @property
     def is_default_category_enabled(self):
         """
         Enablement status of the default category.
 
@@ -155,56 +149,38 @@
 
     @matching_criterias.setter
     def matching_criterias(self, matching_criterias):
 
         self.__matching_criterias = matching_criterias
 
     @property
-    def directory_service_name(self):
+    def directory_service_reference(self):
         """
-        The name of the directory service that will be used for mapping.
+        The ExtID of the directory service that will be used for mapping.
 
         :type:
 
                 :class:`~str`
         """  # noqa: E501
-        return self.__directory_service_name
+        return self.__directory_service_reference
 
-    @directory_service_name.setter
-    def directory_service_name(self, directory_service_name):
-        if directory_service_name is not None and len(directory_service_name) > 200:
-            raise ValueError("Invalid value for `directory_service_name`, length must be less than or equal to `200`")  # noqa: E501
+    @directory_service_reference.setter
+    def directory_service_reference(self, directory_service_reference):
+        if directory_service_reference is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', directory_service_reference):  # noqa: E501
+            raise ValueError(r"Invalid value for `directory_service_reference`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
 
-        self.__directory_service_name = directory_service_name
-
-    @property
-    def directory_service_ext_id(self):
-        """
-        The extId of the directory service that will be used for mapping.
-
-        :type:
-
-                :class:`~str`
-        """  # noqa: E501
-        return self.__directory_service_ext_id
-
-    @directory_service_ext_id.setter
-    def directory_service_ext_id(self, directory_service_ext_id):
-        if directory_service_ext_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', directory_service_ext_id):  # noqa: E501
-            raise ValueError(r"Invalid value for `directory_service_ext_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
-
-        self.__directory_service_ext_id = directory_service_ext_id
+        self.__directory_service_reference = directory_service_reference
 
     @property
     def domain_controllers(self):
         """
         List of domain controllers to be used for event scraping.
 
         :type:
-             list[ :class:`~ntnx_microseg_py_client.models.microseg.v4.config.DomainController` ]
+             list[ :class:`~ntnx_microseg_py_client.models.common.v1.config.IPAddressOrFQDN` ]
         """  # noqa: E501
         return self.__domain_controllers
 
     @domain_controllers.setter
     def domain_controllers(self, domain_controllers):
 
         self.__domain_controllers = domain_controllers
@@ -213,37 +189,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(DirectoryServer, dict):
+        if issubclass(DirectoryServerConfig, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -255,15 +236,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, DirectoryServer):
+        if not isinstance(other, DirectoryServerConfig):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/DirectoryServerCreateResponse.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/ListServiceGroupsApiResponse.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_microseg_py_client.models
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.DirectoryServerCreateResponsedata import DirectoryServerCreateResponsedata  # noqa: F401,E501
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.ListServiceGroupsApiResponsedata import ListServiceGroupsApiResponsedata  # noqa: F401,E501
 from ntnx_microseg_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class DirectoryServerCreateResponse(object):
+class ListServiceGroupsApiResponse(object):
 
-    """REST response for all response codes in API path /microseg/v4.0.a1/config/directory-servers Post operation
+    """REST response for all response codes in API path /microseg/v4.0.b1/config/service-groups Get operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfmicroseg.v4.config.DirectoryServerCreateResponsedata',
+        'data': 'OneOfmicroseg.v4.config.ListServiceGroupsApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.DirectoryServerCreateResponse'
+        return 'microseg.v4.config.ListServiceGroupsApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.DirectoryServerCreateResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -122,15 +123,15 @@
 
     @property
     def data(self):
         """
         
 
         :type:
-                :class:`~ntnx_microseg_py_client.models.prism.v4.config.TaskReference` | 
+                :class:`~ntnx_microseg_py_client.models.microseg.v4.config.ServiceGroup` | 
                 :class:`~ntnx_microseg_py_client.models.microseg.v4.error.ErrorResponse`
                     """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
@@ -171,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_microseg_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(DirectoryServerCreateResponse, dict):
+        if issubclass(ListServiceGroupsApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, DirectoryServerCreateResponse):
+        if not isinstance(other, ListServiceGroupsApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/DirectoryServerDeleteResponse.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/DeleteServiceGroupApiResponse.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_microseg_py_client.models
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.DirectoryServerDeleteResponsedata import DirectoryServerDeleteResponsedata  # noqa: F401,E501
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.DeleteServiceGroupApiResponsedata import DeleteServiceGroupApiResponsedata  # noqa: F401,E501
 from ntnx_microseg_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class DirectoryServerDeleteResponse(object):
+class DeleteServiceGroupApiResponse(object):
 
-    """REST response for all response codes in API path /microseg/v4.0.a1/config/directory-servers/{extId} Delete operation
+    """REST response for all response codes in API path /microseg/v4.0.b1/config/service-groups/{extId} Delete operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfmicroseg.v4.config.DirectoryServerDeleteResponsedata',
+        'data': 'OneOfmicroseg.v4.config.DeleteServiceGroupApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.DirectoryServerDeleteResponse'
+        return 'microseg.v4.config.DeleteServiceGroupApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.DirectoryServerDeleteResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -171,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_microseg_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(DirectoryServerDeleteResponse, dict):
+        if issubclass(DeleteServiceGroupApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, DirectoryServerDeleteResponse):
+        if not isinstance(other, DeleteServiceGroupApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/DirectoryServerGetResponse.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/CreateAddressGroupApiResponse.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_microseg_py_client.models
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.DirectoryServerGetResponsedata import DirectoryServerGetResponsedata  # noqa: F401,E501
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.CreateAddressGroupApiResponsedata import CreateAddressGroupApiResponsedata  # noqa: F401,E501
 from ntnx_microseg_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class DirectoryServerGetResponse(object):
+class CreateAddressGroupApiResponse(object):
 
-    """REST response for all response codes in API path /microseg/v4.0.a1/config/directory-servers/{extId} Get operation
+    """REST response for all response codes in API path /microseg/v4.0.b1/config/address-groups Post operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfmicroseg.v4.config.DirectoryServerGetResponsedata',
+        'data': 'OneOfmicroseg.v4.config.CreateAddressGroupApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.DirectoryServerGetResponse'
+        return 'microseg.v4.config.CreateAddressGroupApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.DirectoryServerGetResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -122,15 +123,15 @@
 
     @property
     def data(self):
         """
         
 
         :type:
-                :class:`~ntnx_microseg_py_client.models.microseg.v4.config.DirectoryServer` | 
+                :class:`~ntnx_microseg_py_client.models.prism.v4.config.TaskReference` | 
                 :class:`~ntnx_microseg_py_client.models.microseg.v4.error.ErrorResponse`
                     """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
@@ -171,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_microseg_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(DirectoryServerGetResponse, dict):
+        if issubclass(CreateAddressGroupApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, DirectoryServerGetResponse):
+        if not isinstance(other, CreateAddressGroupApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/DirectoryServerListResponse.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/GetAddressGroupApiResponse.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_microseg_py_client.models
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.DirectoryServerListResponsedata import DirectoryServerListResponsedata  # noqa: F401,E501
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.GetAddressGroupApiResponsedata import GetAddressGroupApiResponsedata  # noqa: F401,E501
 from ntnx_microseg_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class DirectoryServerListResponse(object):
+class GetAddressGroupApiResponse(object):
 
-    """REST response for all response codes in API path /microseg/v4.0.a1/config/directory-servers Get operation
+    """REST response for all response codes in API path /microseg/v4.0.b1/config/address-groups/{extId} Get operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfmicroseg.v4.config.DirectoryServerListResponsedata',
+        'data': 'OneOfmicroseg.v4.config.GetAddressGroupApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.DirectoryServerListResponse'
+        return 'microseg.v4.config.GetAddressGroupApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.DirectoryServerListResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -122,15 +123,15 @@
 
     @property
     def data(self):
         """
         
 
         :type:
-                :class:`~ntnx_microseg_py_client.models.microseg.v4.config.DirectoryServer` | 
+                :class:`~ntnx_microseg_py_client.models.microseg.v4.config.AddressGroup` | 
                 :class:`~ntnx_microseg_py_client.models.microseg.v4.error.ErrorResponse`
                     """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
@@ -171,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_microseg_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(DirectoryServerListResponse, dict):
+        if issubclass(GetAddressGroupApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, DirectoryServerListResponse):
+        if not isinstance(other, GetAddressGroupApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/DirectoryServerUpdateResponse.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/GetDsCategoryMappingApiResponse.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_microseg_py_client.models
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.DirectoryServerUpdateResponsedata import DirectoryServerUpdateResponsedata  # noqa: F401,E501
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.GetDsCategoryMappingApiResponsedata import GetDsCategoryMappingApiResponsedata  # noqa: F401,E501
 from ntnx_microseg_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class DirectoryServerUpdateResponse(object):
+class GetDsCategoryMappingApiResponse(object):
 
-    """REST response for all response codes in API path /microseg/v4.0.a1/config/directory-servers/{extId} Put operation
+    """REST response for all response codes in API path /microseg/v4.0.b1/config/category-mappings/{extId} Get operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfmicroseg.v4.config.DirectoryServerUpdateResponsedata',
+        'data': 'OneOfmicroseg.v4.config.GetDsCategoryMappingApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.DirectoryServerUpdateResponse'
+        return 'microseg.v4.config.GetDsCategoryMappingApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.DirectoryServerUpdateResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -122,15 +123,15 @@
 
     @property
     def data(self):
         """
         
 
         :type:
-                :class:`~ntnx_microseg_py_client.models.prism.v4.config.TaskReference` | 
+                :class:`~ntnx_microseg_py_client.models.microseg.v4.config.CategoryMapping` | 
                 :class:`~ntnx_microseg_py_client.models.microseg.v4.error.ErrorResponse`
                     """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
@@ -171,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_microseg_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(DirectoryServerUpdateResponse, dict):
+        if issubclass(GetDsCategoryMappingApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, DirectoryServerUpdateResponse):
+        if not isinstance(other, GetDsCategoryMappingApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/DomainController.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/prism/v4/config/TaskReference.py`

 * *Files 12% similar despite different names*

```diff
@@ -3,120 +3,120 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class DomainController(object):
+class TaskReference(object):
 
-    """Configuration for an AD domain controller.
+    """A reference to a task tracking an asynchronous operation. The status of the task can be queried by making a GET request to the task URI provided in the metadata section of the API response.
 
-    :param host: (:attr:`host`) IPv4 Address or hostname for the domain controller.
-    :type host: required
+    :param ext_id: (:attr:`ext_id`) A globally unique identifier of a task.
+    :type ext_id: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'host': 'str',
+        'ext_id': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'host': 'host',
+        'ext_id': 'extId',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, host=None, *args, **kwargs):  # noqa: E501
-        self.__host = None
+    def __init__(self, ext_id=None, *args, **kwargs):  # noqa: E501
+        self.__ext_id = None
         self.discriminator = None
-        self.__host = host
+        if ext_id is not None:
+            self.__ext_id = ext_id
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.DomainController'
+        return 'prism.v4.config.TaskReference'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.DomainController'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def host(self):
+    def ext_id(self):
         """
-        IPv4 Address or hostname for the domain controller.
+        A globally unique identifier of a task.
 
         :type:
 
                 :class:`~str`
         """  # noqa: E501
-        return self.__host
+        return self.__ext_id
 
-    @host.setter
-    def host(self, host):
-        if host is None:
-            raise ValueError("Invalid value for `host`, must not be `None`")  # noqa: E501
-        if host is not None and len(host) > 200:
-            raise ValueError("Invalid value for `host`, length must be less than or equal to `200`")  # noqa: E501
+    @ext_id.setter
+    def ext_id(self, ext_id):
+        if ext_id is not None and not re.search('^[a-zA-Z0-9\/+]*={0,2}:[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}', ext_id):  # noqa: E501
+            raise ValueError(r"Invalid value for `ext_id`, must be a follow pattern or equal to `/^[a-zA-Z0-9\/+]*={0,2}:[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}/`")  # noqa: E501
 
-        self.__host = host
+        self.__ext_id = ext_id
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -149,37 +149,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(DomainController, dict):
+        if issubclass(TaskReference, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -191,15 +196,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, DomainController):
+        if not isinstance(other, TaskReference):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/DsCategoryMappingCreateResponse.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/CreateDsCategoryMappingApiResponse.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_microseg_py_client.models
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.DsCategoryMappingCreateResponsedata import DsCategoryMappingCreateResponsedata  # noqa: F401,E501
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.CreateDsCategoryMappingApiResponsedata import CreateDsCategoryMappingApiResponsedata  # noqa: F401,E501
 from ntnx_microseg_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class DsCategoryMappingCreateResponse(object):
+class CreateDsCategoryMappingApiResponse(object):
 
-    """REST response for all response codes in API path /microseg/v4.0.a1/config/category-mappings Post operation
+    """REST response for all response codes in API path /microseg/v4.0.b1/config/category-mappings Post operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfmicroseg.v4.config.DsCategoryMappingCreateResponsedata',
+        'data': 'OneOfmicroseg.v4.config.CreateDsCategoryMappingApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.DsCategoryMappingCreateResponse'
+        return 'microseg.v4.config.CreateDsCategoryMappingApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.DsCategoryMappingCreateResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -171,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_microseg_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(DsCategoryMappingCreateResponse, dict):
+        if issubclass(CreateDsCategoryMappingApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, DsCategoryMappingCreateResponse):
+        if not isinstance(other, CreateDsCategoryMappingApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/DsCategoryMappingDeleteResponse.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/DeleteDsCategoryMappingApiResponse.py`

 * *Files 12% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_microseg_py_client.models
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.DsCategoryMappingDeleteResponsedata import DsCategoryMappingDeleteResponsedata  # noqa: F401,E501
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.DeleteDsCategoryMappingApiResponsedata import DeleteDsCategoryMappingApiResponsedata  # noqa: F401,E501
 from ntnx_microseg_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class DsCategoryMappingDeleteResponse(object):
+class DeleteDsCategoryMappingApiResponse(object):
 
-    """REST response for all response codes in API path /microseg/v4.0.a1/config/category-mappings/{extId} Delete operation
+    """REST response for all response codes in API path /microseg/v4.0.b1/config/category-mappings/{extId} Delete operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfmicroseg.v4.config.DsCategoryMappingDeleteResponsedata',
+        'data': 'OneOfmicroseg.v4.config.DeleteDsCategoryMappingApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.DsCategoryMappingDeleteResponse'
+        return 'microseg.v4.config.DeleteDsCategoryMappingApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.DsCategoryMappingDeleteResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -171,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_microseg_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(DsCategoryMappingDeleteResponse, dict):
+        if issubclass(DeleteDsCategoryMappingApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, DsCategoryMappingDeleteResponse):
+        if not isinstance(other, DeleteDsCategoryMappingApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/DsCategoryMappingGetResponse.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/UpdateDsCategoryMappingApiResponse.py`

 * *Files 9% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_microseg_py_client.models
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.DsCategoryMappingGetResponsedata import DsCategoryMappingGetResponsedata  # noqa: F401,E501
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.UpdateDsCategoryMappingApiResponsedata import UpdateDsCategoryMappingApiResponsedata  # noqa: F401,E501
 from ntnx_microseg_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class DsCategoryMappingGetResponse(object):
+class UpdateDsCategoryMappingApiResponse(object):
 
-    """REST response for all response codes in API path /microseg/v4.0.a1/config/category-mappings/{extId} Get operation
+    """REST response for all response codes in API path /microseg/v4.0.b1/config/category-mappings/{extId} Put operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfmicroseg.v4.config.DsCategoryMappingGetResponsedata',
+        'data': 'OneOfmicroseg.v4.config.UpdateDsCategoryMappingApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.DsCategoryMappingGetResponse'
+        return 'microseg.v4.config.UpdateDsCategoryMappingApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.DsCategoryMappingGetResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -122,15 +123,15 @@
 
     @property
     def data(self):
         """
         
 
         :type:
-                :class:`~ntnx_microseg_py_client.models.microseg.v4.config.CategoryMapping` | 
+                :class:`~ntnx_microseg_py_client.models.prism.v4.config.TaskReference` | 
                 :class:`~ntnx_microseg_py_client.models.microseg.v4.error.ErrorResponse`
                     """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
@@ -171,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_microseg_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(DsCategoryMappingGetResponse, dict):
+        if issubclass(UpdateDsCategoryMappingApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, DsCategoryMappingGetResponse):
+        if not isinstance(other, UpdateDsCategoryMappingApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/DsCategoryMappingUpdateResponse.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/UpdateServiceGroupApiResponse.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_microseg_py_client.models
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.DsCategoryMappingUpdateResponsedata import DsCategoryMappingUpdateResponsedata  # noqa: F401,E501
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.UpdateServiceGroupApiResponsedata import UpdateServiceGroupApiResponsedata  # noqa: F401,E501
 from ntnx_microseg_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class DsCategoryMappingUpdateResponse(object):
+class UpdateServiceGroupApiResponse(object):
 
-    """REST response for all response codes in API path /microseg/v4.0.a1/config/category-mappings/{extId} Put operation
+    """REST response for all response codes in API path /microseg/v4.0.b1/config/service-groups/{extId} Put operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfmicroseg.v4.config.DsCategoryMappingUpdateResponsedata',
+        'data': 'OneOfmicroseg.v4.config.UpdateServiceGroupApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.DsCategoryMappingUpdateResponse'
+        return 'microseg.v4.config.UpdateServiceGroupApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.DsCategoryMappingUpdateResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -171,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_microseg_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(DsCategoryMappingUpdateResponse, dict):
+        if issubclass(UpdateServiceGroupApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, DsCategoryMappingUpdateResponse):
+        if not isinstance(other, UpdateServiceGroupApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/DsCategoryMappingsGetListResponse.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/operation/SubnetUpgradeSummary.py`

 * *Files 14% similar despite different names*

```diff
@@ -3,142 +3,169 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_microseg_py_client.models
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.DsCategoryMappingsGetListResponsedata import DsCategoryMappingsGetListResponsedata  # noqa: F401,E501
-from ntnx_microseg_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
-
-class DsCategoryMappingsGetListResponse(object):
-
-    """REST response for all response codes in API path /microseg/v4.0.a1/config/category-mappings Get operation
-
-    :param metadata: (:attr:`metadata`) 
-    :type metadata: 
-    :param data: (:attr:`data`) 
-    :type data: 
+from pathlib import Path
+
+class SubnetUpgradeSummary(object):
+
+    """Subnet information to be communicated for subnet upgrade as part of Flow upgrade to FNS Next-Gen.<br> The info includes vlanID, vlanName and subnetUuid. 
+
+    :param vlan_name: (:attr:`vlan_name`) Vlan name in the upgrade.
+    :type vlan_name: 
+    :param vlan_id: (:attr:`vlan_id`) Vlan id used in the upgrade.
+    :type vlan_id: required
+    :param subnet_reference: (:attr:`subnet_reference`) Subnet ExtID used in upgrade.
+    :type subnet_reference: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfmicroseg.v4.config.DsCategoryMappingsGetListResponsedata',
+        'vlan_name': 'str',
+        'vlan_id': 'int',
+        'subnet_reference': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'metadata': 'metadata',
-        'data': 'data',
+        'vlan_name': 'vlanName',
+        'vlan_id': 'vlanID',
+        'subnet_reference': 'subnetReference',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        self.__metadata = None
-        self.__data = None
+    def __init__(self, vlan_name=None, vlan_id=None, subnet_reference=None, *args, **kwargs):  # noqa: E501
+        self.__vlan_name = None
+        self.__vlan_id = None
+        self.__subnet_reference = None
         self.discriminator = None
-        if metadata is not None:
-            self.__metadata = metadata
-        if data is not None:
-            self.__data = data
+        if vlan_name is not None:
+            self.__vlan_name = vlan_name
+        self.__vlan_id = vlan_id
+        if subnet_reference is not None:
+            self.__subnet_reference = subnet_reference
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.DsCategoryMappingsGetListResponse'
+        return 'microseg.v4.operation.SubnetUpgradeSummary'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.DsCategoryMappingsGetListResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def metadata(self):
+    def vlan_name(self):
         """
-        
+        Vlan name in the upgrade.
 
         :type:
-            :class:`~ntnx_microseg_py_client.models.common.v1.response.ApiResponseMetadata`
+
+                :class:`~str`
         """  # noqa: E501
-        return self.__metadata
+        return self.__vlan_name
 
-    @metadata.setter
-    def metadata(self, metadata):
+    @vlan_name.setter
+    def vlan_name(self, vlan_name):
+        if vlan_name is not None and len(vlan_name) > 64:
+            raise ValueError("Invalid value for `vlan_name`, length must be less than or equal to `64`")  # noqa: E501
 
-        self.__metadata = metadata
+        self.__vlan_name = vlan_name
 
     @property
-    def data(self):
+    def vlan_id(self):
         """
-        
+        Vlan id used in the upgrade.
 
         :type:
-                :class:`~ntnx_microseg_py_client.models.microseg.v4.config.CategoryMapping` | 
-                :class:`~ntnx_microseg_py_client.models.microseg.v4.error.ErrorResponse`
-                    """  # noqa: E501
-        return self.__data
 
-    @data.setter
-    def data(self, data):
+                :class:`~int`
+        """  # noqa: E501
+        return self.__vlan_id
+
+    @vlan_id.setter
+    def vlan_id(self, vlan_id):
+        if vlan_id is None:
+            raise ValueError("Invalid value for `vlan_id`, must not be `None`")  # noqa: E501
 
-        self.__data = data
+        self.__vlan_id = vlan_id
+
+    @property
+    def subnet_reference(self):
+        """
+        Subnet ExtID used in upgrade.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__subnet_reference
+
+    @subnet_reference.setter
+    def subnet_reference(self, subnet_reference):
+        if subnet_reference is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', subnet_reference):  # noqa: E501
+            raise ValueError(r"Invalid value for `subnet_reference`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
+
+        self.__subnet_reference = subnet_reference
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -171,39 +198,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
-            if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_microseg_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(DsCategoryMappingsGetListResponse, dict):
+        if issubclass(SubnetUpgradeSummary, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +245,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, DsCategoryMappingsGetListResponse):
+        if not isinstance(other, SubnetUpgradeSummary):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/FileWrapper.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/operation/SecurityPolicyType.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,180 +3,125 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class FileWrapper(object):
+class SecurityPolicyType(object):
 
-    """
+    """Defines the type of rules that can be used in a policy.<br> It can be one of following types   - QUARANTINE POLICY   - ISOLATION POLICY   - APPLICATION POLICY   - AD POLICY 
 
-    :param file: (:attr:`file`) 
-    :type file: 
 
-    """
-    """
-    IGNORE:
-    Attributes:
-      swagger_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-    IGNORE
-    """  # noqa: E501
-    swagger_types = {
-        'file': 'str',
-        '_reserved': 'dict(str, object)',
-        '_object_type': 'str',
-        '_unknown_fields': 'dict(str, object)',
-    }
-
-    attribute_map = {
-        'file': 'file',
-        '_reserved': '$reserved',
-        '_object_type': '$objectType',
-        '_unknown_fields': '$unknownFields',
-    }
+    Allowed enum values:
 
+        - _UNKNOWN
+        - _REDACTED
+        - QUARANTINE: A Policy where inbound and outbound traffic is not allowed.
+        - ISOLATION: A Policy where two environments are isolated from each other.
+        - APPLICATION: A Policy for specifying allowed traffic for an application.
+        - AD: A Policy for securing an AD group.
+    """
+    _UNKNOWN = "$UNKNOWN"
+    _REDACTED = "$REDACTED"
+    QUARANTINE = "QUARANTINE"
+    ISOLATION = "ISOLATION"
+    APPLICATION = "APPLICATION"
+    AD = "AD"
 
 
-    def __init__(self, file=None, *args, **kwargs):  # noqa: E501
-        self.__file = None
+    def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
-        if file is not None:
-            self.__file = file
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.FileWrapper'
+        return 'microseg.v4.operation.SecurityPolicyType'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.FileWrapper'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
-    @property
-    def file(self):
-        """
-        
-
-        :type:
-
-                :class:`~str`
-        """  # noqa: E501
-        return self.__file
-
-    @file.setter
-    def file(self, file):
-
-        self.__file = file
-
-    @property
-    def _reserved(self):
-        """
-        
-
-        :type:
-            dict(str, :class:`~object`)
-        """  # noqa: E501
-        return self.__dollar_reserved
-
-    @property
-    def _object_type(self):
-        """
-        
-
-        :type:
-
-                :class:`~str`
-        """  # noqa: E501
-        return self.__dollar_object_type
-
-    @property
-    def _unknown_fields(self):
-        """
-        
-
-        :type:
-            dict(str, :class:`~object`)
-        """  # noqa: E501
-        return self.__dollar_unknown_fields
-
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(FileWrapper, dict):
+        if issubclass(SecurityPolicyType, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -188,15 +133,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, FileWrapper):
+        if not isinstance(other, SecurityPolicyType):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/IPv4Range.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/IPv4Range.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
 class IPv4Range(object):
 
     """IP range containing start and end IP.
 
     :param start_ip: (:attr:`start_ip`) 
     :type start_ip: required
@@ -64,33 +65,33 @@
         self.__end_ip = end_ip
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'microseg.v4.config.IPv4Range'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.IPv4Range'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -175,28 +176,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/IcmpTypeCodeSpec.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/IcmpTypeCodeSpec.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,136 +3,137 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
 class IcmpTypeCodeSpec(object):
 
-    """Icmp Type Code Object
+    """Icmp Type Code Object. This object contains values for Icmp type and Icmp code.
 
-    :param is_all_code_type_allowed: (:attr:`is_all_code_type_allowed`) Set this field to true if both Type and Code is ANY. (**Default** False)
-    :type is_all_code_type_allowed: 
-    :param type: (:attr:`type`) Ignore this field if Type has to be ANY.
+    :param is_all_allowed: (:attr:`is_all_allowed`) Set this field to true if both Type and Code is ANY. (**Default** False)
+    :type is_all_allowed: 
+    :param type: (:attr:`type`) Icmp service Type. Ignore this field if Type has to be ANY.
     :type type: 
-    :param code: (:attr:`code`) Ignore this field if Code has to be ANY.
+    :param code: (:attr:`code`) Icmp service Code. Ignore this field if Code has to be ANY.
     :type code: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'is_all_code_type_allowed': 'bool',
+        'is_all_allowed': 'bool',
         'type': 'int',
         'code': 'int',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'is_all_code_type_allowed': 'isAllCodeTypeAllowed',
+        'is_all_allowed': 'isAllAllowed',
         'type': 'type',
         'code': 'code',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, is_all_code_type_allowed=False, type=None, code=None, *args, **kwargs):  # noqa: E501
-        self.__is_all_code_type_allowed = None
+    def __init__(self, is_all_allowed=False, type=None, code=None, *args, **kwargs):  # noqa: E501
+        self.__is_all_allowed = None
         self.__type = None
         self.__code = None
         self.discriminator = None
-        if is_all_code_type_allowed is not None:
-            self.__is_all_code_type_allowed = is_all_code_type_allowed
+        if is_all_allowed is not None:
+            self.__is_all_allowed = is_all_allowed
         if type is not None:
             self.__type = type
         if code is not None:
             self.__code = code
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'microseg.v4.config.IcmpTypeCodeSpec'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.IcmpTypeCodeSpec'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def is_all_code_type_allowed(self):
+    def is_all_allowed(self):
         """
         Set this field to true if both Type and Code is ANY.
 
         :type:
 
                 :class:`~bool`
         """  # noqa: E501
-        return self.__is_all_code_type_allowed
+        return self.__is_all_allowed
 
-    @is_all_code_type_allowed.setter
-    def is_all_code_type_allowed(self, is_all_code_type_allowed):
+    @is_all_allowed.setter
+    def is_all_allowed(self, is_all_allowed):
 
-        self.__is_all_code_type_allowed = is_all_code_type_allowed
+        self.__is_all_allowed = is_all_allowed
 
     @property
     def type(self):
         """
-        Ignore this field if Type has to be ANY.
+        Icmp service Type. Ignore this field if Type has to be ANY.
 
         :type:
 
                 :class:`~int`
         """  # noqa: E501
         return self.__type
 
@@ -144,15 +145,15 @@
             raise ValueError("Invalid value for `type`, must be a value greater than or equal to `0`")  # noqa: E501
 
         self.__type = type
 
     @property
     def code(self):
         """
-        Ignore this field if Code has to be ANY.
+        Icmp service Code. Ignore this field if Code has to be ANY.
 
         :type:
 
                 :class:`~int`
         """  # noqa: E501
         return self.__code
 
@@ -200,28 +201,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/IntraEntityGroupRuleAction.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/MatchType.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,71 +3,72 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class IntraEntityGroupRuleAction(object):
+class MatchType(object):
 
-    """
+    """The type of match. Today only CONTAINS and ALL are supported. CONTAINS performs a substring match on the given entity and field for the criteria value whereas ALL allows all string to match on the given entity.
 
 
     Allowed enum values:
 
         - _UNKNOWN
         - _REDACTED
-        - ALLOW: Allow traffic between Intra Entity Groups.
-        - DENY: Deny traffic between Intra Entity Groups.
+        - CONTAINS: CONTAINS
+        - ALL: ALL
     """
     _UNKNOWN = "$UNKNOWN"
     _REDACTED = "$REDACTED"
-    ALLOW = "ALLOW"
-    DENY = "DENY"
+    CONTAINS = "CONTAINS"
+    ALL = "ALL"
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.IntraEntityGroupRuleAction'
+        return 'microseg.v4.config.MatchType'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.IntraEntityGroupRuleAction'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -82,36 +83,41 @@
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(IntraEntityGroupRuleAction, dict):
+        if issubclass(MatchType, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -123,15 +129,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, IntraEntityGroupRuleAction):
+        if not isinstance(other, MatchType):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/MatchEntity.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/SecurityPolicyType.py`

 * *Files 9% similar despite different names*

```diff
@@ -3,69 +3,74 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class MatchEntity(object):
+class SecurityPolicyType(object):
 
-    """The entity to perform matching on. Currently, only the target VM that a logon occurred on is supported.
+    """Defines the type of rules that can be used in a policy.
 
 
     Allowed enum values:
 
         - _UNKNOWN
         - _REDACTED
-        - VM: VM
+        - QUARANTINE: A Policy where inbound and outbound traffic is not allowed.
+        - ISOLATION: A Policy where two environments are isolated from each other.
+        - APPLICATION: A Policy for specifying allowed traffic for an application.
     """
     _UNKNOWN = "$UNKNOWN"
     _REDACTED = "$REDACTED"
-    VM = "VM"
+    QUARANTINE = "QUARANTINE"
+    ISOLATION = "ISOLATION"
+    APPLICATION = "APPLICATION"
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.MatchEntity'
+        return 'microseg.v4.config.SecurityPolicyType'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.MatchEntity'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -80,36 +85,41 @@
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(MatchEntity, dict):
+        if issubclass(SecurityPolicyType, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -121,15 +131,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, MatchEntity):
+        if not isinstance(other, SecurityPolicyType):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/MatchField.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/IntraEntityGroupRuleAction.py`

 * *Files 12% similar despite different names*

```diff
@@ -3,69 +3,72 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class MatchField(object):
+class IntraEntityGroupRuleAction(object):
 
-    """The field to match on. Today only NAME is supported, which matches on an entity's name.
+    """A specification to whether traffic between intra secured group entities should be allowed or denied.
 
 
     Allowed enum values:
 
         - _UNKNOWN
         - _REDACTED
-        - NAME: NAME
+        - ALLOW: Allow traffic between Intra Entity Groups.
+        - DENY: Deny traffic between Intra Entity Groups.
     """
     _UNKNOWN = "$UNKNOWN"
     _REDACTED = "$REDACTED"
-    NAME = "NAME"
+    ALLOW = "ALLOW"
+    DENY = "DENY"
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.MatchField'
+        return 'microseg.v4.config.IntraEntityGroupRuleAction'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.MatchField'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -80,36 +83,41 @@
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(MatchField, dict):
+        if issubclass(IntraEntityGroupRuleAction, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -121,15 +129,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, MatchField):
+        if not isinstance(other, IntraEntityGroupRuleAction):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/MatchType.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/SecurityPolicyScope.py`

 * *Files 14% similar despite different names*

```diff
@@ -3,71 +3,74 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class MatchType(object):
+class SecurityPolicyScope(object):
 
-    """The type of match. Today only CONTAINS and ALL are supported. CONTAINS performs a substring match on the given entity and field for the criteria value whereas ALL allows all string to match on the given entity.
+    """Defines the scope of the policy. Currently, only ALL_VLAN and VPC_LIST are supported. If scope is not provided, the default is set based on whether vpcReferences field is provided or not.
 
 
     Allowed enum values:
 
         - _UNKNOWN
         - _REDACTED
-        - CONTAINS: CONTAINS
-        - ALL: ALL
+        - ALL_VLAN: Policy is scoped to all the VLANs.
+        - ALL_VPC: Policy is scoped to all the VPCs. This value is not supported in this release.
+        - VPC_LIST: Policy is scoped to the list of VPCs specified in vpcReferences.
     """
     _UNKNOWN = "$UNKNOWN"
     _REDACTED = "$REDACTED"
-    CONTAINS = "CONTAINS"
-    ALL = "ALL"
+    ALL_VLAN = "ALL_VLAN"
+    ALL_VPC = "ALL_VPC"
+    VPC_LIST = "VPC_LIST"
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.MatchType'
+        return 'microseg.v4.config.SecurityPolicyScope'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.MatchType'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -82,36 +85,41 @@
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(MatchType, dict):
+        if issubclass(SecurityPolicyScope, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -123,15 +131,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, MatchType):
+        if not isinstance(other, SecurityPolicyScope):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/MatchingCriteria.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/MatchingCriteria.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_microseg_py_client.models.microseg.v4.config.MatchEntity import MatchEntity  # noqa: F401,E501
 from ntnx_microseg_py_client.models.microseg.v4.config.MatchField import MatchField  # noqa: F401,E501
 from ntnx_microseg_py_client.models.microseg.v4.config.MatchType import MatchType  # noqa: F401,E501
 
 class MatchingCriteria(object):
 
     """The matching criteria used to determine whether an entity will be categorized by identity categorization. If match type is ALL, all the entities will be categorized.
@@ -80,33 +81,33 @@
             self.__criteria = criteria
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'microseg.v4.config.MatchingCriteria'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.MatchingCriteria'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -220,28 +221,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/MigrationConfig.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/operation/DryRunSpec.py`

 * *Files 14% similar despite different names*

```diff
@@ -3,141 +3,140 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class MigrationConfig(object):
+class DryRunSpec(object):
 
-    """__Request body for Actual Config Migration__  It contains two required fields: - forceMonitor - migrateSecuredSubnets 
+    """_Body for requesting Config Upgrade Summary_  It contains two fields:   - policyNames   - isIncludeSecureSubnetsInfo 
 
-    :param is_force_monitor: (:attr:`is_force_monitor`) It can only have Boolean values `true` or `false`.<br> If true, force all the policies to be in monitor mode after migration.<br> The policies would remain in same the same state they were pre migration, otherwise. 
-    :type is_force_monitor: required
-    :param should_migrate_secured_subnets_only: (:attr:`should_migrate_secured_subnets_only`) It can only have Boolean values `true` or `false`.<br> If true, migrate subnets belonging to VMs secured by NSPs.<br> ALL subnets are migrated, otherwise. 
-    :type should_migrate_secured_subnets_only: 
+    :param policy_names: (:attr:`policy_names`) List of FNS policies selected for upgrade.
+    :type policy_names: 
+    :param should_include_secure_subnets_info: (:attr:`should_include_secure_subnets_info`) If set to true, displays upgrade information only for subnets with VMs secured by NSPs.<br> Else, the upgrade information is displayed for all the subnets. 
+    :type should_include_secure_subnets_info: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'is_force_monitor': 'bool',
-        'should_migrate_secured_subnets_only': 'bool',
+        'policy_names': 'list[str]',
+        'should_include_secure_subnets_info': 'bool',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'is_force_monitor': 'isForceMonitor',
-        'should_migrate_secured_subnets_only': 'shouldMigrateSecuredSubnetsOnly',
+        'policy_names': 'policyNames',
+        'should_include_secure_subnets_info': 'shouldIncludeSecureSubnetsInfo',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, is_force_monitor=None, should_migrate_secured_subnets_only=None, *args, **kwargs):  # noqa: E501
-        self.__is_force_monitor = None
-        self.__should_migrate_secured_subnets_only = None
+    def __init__(self, policy_names=None, should_include_secure_subnets_info=None, *args, **kwargs):  # noqa: E501
+        self.__policy_names = None
+        self.__should_include_secure_subnets_info = None
         self.discriminator = None
-        self.__is_force_monitor = is_force_monitor
-        if should_migrate_secured_subnets_only is not None:
-            self.__should_migrate_secured_subnets_only = should_migrate_secured_subnets_only
+        if policy_names is not None:
+            self.__policy_names = policy_names
+        if should_include_secure_subnets_info is not None:
+            self.__should_include_secure_subnets_info = should_include_secure_subnets_info
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.MigrationConfig'
+        return 'microseg.v4.operation.DryRunSpec'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.MigrationConfig'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def is_force_monitor(self):
+    def policy_names(self):
         """
-        It can only have Boolean values `true` or `false`.<br> If true, force all the policies to be in monitor mode after migration.<br> The policies would remain in same the same state they were pre migration, otherwise. 
+        List of FNS policies selected for upgrade.
 
         :type:
-
-                :class:`~bool`
+            list[ :class:`~str` ]
         """  # noqa: E501
-        return self.__is_force_monitor
+        return self.__policy_names
 
-    @is_force_monitor.setter
-    def is_force_monitor(self, is_force_monitor):
-        if is_force_monitor is None:
-            raise ValueError("Invalid value for `is_force_monitor`, must not be `None`")  # noqa: E501
+    @policy_names.setter
+    def policy_names(self, policy_names):
 
-        self.__is_force_monitor = is_force_monitor
+        self.__policy_names = policy_names
 
     @property
-    def should_migrate_secured_subnets_only(self):
+    def should_include_secure_subnets_info(self):
         """
-        It can only have Boolean values `true` or `false`.<br> If true, migrate subnets belonging to VMs secured by NSPs.<br> ALL subnets are migrated, otherwise. 
+        If set to true, displays upgrade information only for subnets with VMs secured by NSPs.<br> Else, the upgrade information is displayed for all the subnets. 
 
         :type:
 
                 :class:`~bool`
         """  # noqa: E501
-        return self.__should_migrate_secured_subnets_only
+        return self.__should_include_secure_subnets_info
 
-    @should_migrate_secured_subnets_only.setter
-    def should_migrate_secured_subnets_only(self, should_migrate_secured_subnets_only):
+    @should_include_secure_subnets_info.setter
+    def should_include_secure_subnets_info(self, should_include_secure_subnets_info):
 
-        self.__should_migrate_secured_subnets_only = should_migrate_secured_subnets_only
+        self.__should_include_secure_subnets_info = should_include_secure_subnets_info
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -170,37 +169,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(MigrationConfig, dict):
+        if issubclass(DryRunSpec, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -212,15 +216,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, MigrationConfig):
+        if not isinstance(other, DryRunSpec):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/MigrationConfigSpec.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/operation/UpgradeJob.py`

 * *Files 12% similar despite different names*

```diff
@@ -3,33 +3,34 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_microseg_py_client.models
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.MigrationConfigSpecspec import MigrationConfigSpecspec  # noqa: F401,E501
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.operation.UpgradeJobspec import UpgradeJobspec  # noqa: F401,E501
 
-class MigrationConfigSpec(object):
+class UpgradeJob(object):
 
-    """__Request body for Config Migration__  It contains two fields: - isDryRun - spec  The spec can be one of two types based on isDryRun boolean value.  A sample request body with the flag set would look like this: ``` { \"isDryRun\": true, \"spec\": {   \"policyNames\" : [],   \"shouldIncludeSecureSubnetsInfo\" : false   } } ```  A sample request body with the flag unset would look like this: ``` { \"isDryRun\": false, \"spec\": {   \"isForceMonitor\" : true,   \"shouldMigrateSecuredSubnetsOnly\" : false   } } ``` 
+    """__Request body for Config Upgrade__  It contains two fields: - isDryRun - spec  The spec can be one of two types based on isDryRun boolean value.  A sample request body with the flag set would look like this: ``` { \"isDryRun\": true, \"spec\": {   \"policyNames\" : [],   \"shouldIncludeSecureSubnetsInfo\" : false   } } ```  A sample request body with the flag unset would look like this: ``` { \"isDryRun\": false, \"spec\": {   \"isForceMonitor\" : true,   \"shouldUpgradeSecuredSubnetsOnly\" : false   } } ``` 
 
-    :param is_dry_run: (:attr:`is_dry_run`) It can only have Boolean values `true` or `false`.<br> If true, it will trigger a dry run of Flow Config Migration. The policies and subnets will not be actually migrated.<br> If false, the config migration will be triggered.  (**Default** False)
+    :param is_dry_run: (:attr:`is_dry_run`) If set to true, it will trigger a dry run of Flow configuration upgrade. As part of this dry run, the policies and subnets will not be upgraded.<br> If set to false, the configuration upgrade is triggered.  (**Default** False)
     :type is_dry_run: 
     :param spec: (:attr:`spec`) 
     :type spec: required
 
     """
     """
     IGNORE:
@@ -38,15 +39,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'is_dry_run': 'bool',
-        'spec': 'OneOfmicroseg.v4.config.MigrationConfigSpecspec',
+        'spec': 'OneOfmicroseg.v4.operation.UpgradeJobspec',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'is_dry_run': 'isDryRun',
@@ -65,35 +66,35 @@
         if is_dry_run is not None:
             self.__is_dry_run = is_dry_run
         self.__spec = spec
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.MigrationConfigSpec'
+        return 'microseg.v4.operation.UpgradeJob'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.MigrationConfigSpec'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -102,15 +103,15 @@
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def is_dry_run(self):
         """
-        It can only have Boolean values `true` or `false`.<br> If true, it will trigger a dry run of Flow Config Migration. The policies and subnets will not be actually migrated.<br> If false, the config migration will be triggered. 
+        If set to true, it will trigger a dry run of Flow configuration upgrade. As part of this dry run, the policies and subnets will not be upgraded.<br> If set to false, the configuration upgrade is triggered. 
 
         :type:
 
                 :class:`~bool`
         """  # noqa: E501
         return self.__is_dry_run
 
@@ -121,16 +122,16 @@
 
     @property
     def spec(self):
         """
         
 
         :type:
-                :class:`~ntnx_microseg_py_client.models.microseg.v4.config.MigrationConfig` | 
-                :class:`~ntnx_microseg_py_client.models.microseg.v4.config.MigrationSummary`
+                :class:`~ntnx_microseg_py_client.models.microseg.v4.operation.UpgradeSpec` | 
+                :class:`~ntnx_microseg_py_client.models.microseg.v4.operation.DryRunSpec`
                     """  # noqa: E501
         return self.__spec
 
     @spec.setter
     def spec(self, spec):
         if spec is None:
             raise ValueError("Invalid value for `spec`, must not be `None`")  # noqa: E501
@@ -172,39 +173,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_microseg_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(MigrationConfigSpec, dict):
+        if issubclass(UpgradeJob, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -216,15 +222,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, MigrationConfigSpec):
+        if not isinstance(other, UpgradeJob):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/MigrationConfigTaskResponse.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/DeleteAddressGroupApiResponse.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_microseg_py_client.models
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.MigrationConfigTaskResponsedata import MigrationConfigTaskResponsedata  # noqa: F401,E501
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.DeleteAddressGroupApiResponsedata import DeleteAddressGroupApiResponsedata  # noqa: F401,E501
 from ntnx_microseg_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class MigrationConfigTaskResponse(object):
+class DeleteAddressGroupApiResponse(object):
 
-    """REST response for all response codes in API path /microseg/v4.0.a1/config/flow-migrator/$actions/migrate Post operation
+    """REST response for all response codes in API path /microseg/v4.0.b1/config/address-groups/{extId} Delete operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfmicroseg.v4.config.MigrationConfigTaskResponsedata',
+        'data': 'OneOfmicroseg.v4.config.DeleteAddressGroupApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.MigrationConfigTaskResponse'
+        return 'microseg.v4.config.DeleteAddressGroupApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.MigrationConfigTaskResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -171,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_microseg_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(MigrationConfigTaskResponse, dict):
+        if issubclass(DeleteAddressGroupApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, MigrationConfigTaskResponse):
+        if not isinstance(other, DeleteAddressGroupApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/MigrationSummary.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/TwoEnvIsolationRuleSpec.py`

 * *Files 21% similar despite different names*

```diff
@@ -3,139 +3,141 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class MigrationSummary(object):
+class TwoEnvIsolationRuleSpec(object):
 
-    """_Body for requesting Config Migration Summary_  It contains two fields:   - policyNames   - isIncludeSecureSubnetsInfo 
+    """A rule for specifying that two environments should be isolated from each other. Specify both 'firstIsolationGroup' and 'secondIsolationGroup'.
 
-    :param policy_names: (:attr:`policy_names`) List of FNS 1.0 policies selected for Migration Summary.
-    :type policy_names: 
-    :param should_include_secure_subnets_info: (:attr:`should_include_secure_subnets_info`) It can only have Boolean values `true` or `false`.<br> If true, shows migration info ONLY for subnets belonging to VMs secured by NSPs.<br> Shows migration info for ALL subnets, otherwise. 
-    :type should_include_secure_subnets_info: 
+    :param first_isolation_group: (:attr:`first_isolation_group`) Denotes the first group of category uuids that will be used in an isolation policy.
+    :type first_isolation_group: required
+    :param second_isolation_group: (:attr:`second_isolation_group`) Denotes the second group of category uuids that will be used in an isolation policy.
+    :type second_isolation_group: required
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'policy_names': 'list[str]',
-        'should_include_secure_subnets_info': 'bool',
+        'first_isolation_group': 'list[str]',
+        'second_isolation_group': 'list[str]',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'policy_names': 'policyNames',
-        'should_include_secure_subnets_info': 'shouldIncludeSecureSubnetsInfo',
+        'first_isolation_group': 'firstIsolationGroup',
+        'second_isolation_group': 'secondIsolationGroup',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, policy_names=None, should_include_secure_subnets_info=None, *args, **kwargs):  # noqa: E501
-        self.__policy_names = None
-        self.__should_include_secure_subnets_info = None
+    def __init__(self, first_isolation_group=None, second_isolation_group=None, *args, **kwargs):  # noqa: E501
+        self.__first_isolation_group = None
+        self.__second_isolation_group = None
         self.discriminator = None
-        if policy_names is not None:
-            self.__policy_names = policy_names
-        if should_include_secure_subnets_info is not None:
-            self.__should_include_secure_subnets_info = should_include_secure_subnets_info
+        self.__first_isolation_group = first_isolation_group
+        self.__second_isolation_group = second_isolation_group
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.MigrationSummary'
+        return 'microseg.v4.config.TwoEnvIsolationRuleSpec'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.MigrationSummary'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def policy_names(self):
+    def first_isolation_group(self):
         """
-        List of FNS 1.0 policies selected for Migration Summary.
+        Denotes the first group of category uuids that will be used in an isolation policy.
 
         :type:
             list[ :class:`~str` ]
         """  # noqa: E501
-        return self.__policy_names
+        return self.__first_isolation_group
 
-    @policy_names.setter
-    def policy_names(self, policy_names):
+    @first_isolation_group.setter
+    def first_isolation_group(self, first_isolation_group):
+        if first_isolation_group is None:
+            raise ValueError("Invalid value for `first_isolation_group`, must not be `None`")  # noqa: E501
 
-        self.__policy_names = policy_names
+        self.__first_isolation_group = first_isolation_group
 
     @property
-    def should_include_secure_subnets_info(self):
+    def second_isolation_group(self):
         """
-        It can only have Boolean values `true` or `false`.<br> If true, shows migration info ONLY for subnets belonging to VMs secured by NSPs.<br> Shows migration info for ALL subnets, otherwise. 
+        Denotes the second group of category uuids that will be used in an isolation policy.
 
         :type:
-
-                :class:`~bool`
+            list[ :class:`~str` ]
         """  # noqa: E501
-        return self.__should_include_secure_subnets_info
+        return self.__second_isolation_group
 
-    @should_include_secure_subnets_info.setter
-    def should_include_secure_subnets_info(self, should_include_secure_subnets_info):
+    @second_isolation_group.setter
+    def second_isolation_group(self, second_isolation_group):
+        if second_isolation_group is None:
+            raise ValueError("Invalid value for `second_isolation_group`, must not be `None`")  # noqa: E501
 
-        self.__should_include_secure_subnets_info = should_include_secure_subnets_info
+        self.__second_isolation_group = second_isolation_group
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -168,37 +170,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(MigrationSummary, dict):
+        if issubclass(TwoEnvIsolationRuleSpec, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -210,15 +217,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, MigrationSummary):
+        if not isinstance(other, TwoEnvIsolationRuleSpec):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/NSPApplicationRuleSpec.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/ApplicationRuleSpec.py`

 * *Files 24% similar despite different names*

```diff
@@ -3,235 +3,236 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_microseg_py_client.models.common.v1.config.IPv4Address import IPv4Address  # noqa: F401,E501
 from ntnx_microseg_py_client.models.microseg.v4.config.AllowType import AllowType  # noqa: F401,E501
 from ntnx_microseg_py_client.models.microseg.v4.config.IcmpTypeCodeSpec import IcmpTypeCodeSpec  # noqa: F401,E501
 from ntnx_microseg_py_client.models.microseg.v4.config.TcpPortRangeSpec import TcpPortRangeSpec  # noqa: F401,E501
 from ntnx_microseg_py_client.models.microseg.v4.config.UdpPortRangeSpec import UdpPortRangeSpec  # noqa: F401,E501
 
-class NSPApplicationRuleSpec(object):
+class ApplicationRuleSpec(object):
 
     """A rule for specifying allowed traffic for an application.
 
-    :param secured_group: (:attr:`secured_group`) 
-    :type secured_group: required
-    :param source_allow_spec: (:attr:`source_allow_spec`) 
-    :type source_allow_spec: 
+    :param secured_group_category_references: (:attr:`secured_group_category_references`) A set of network endpoints which is protected by a Network Security Policy and defined as a list of categories.
+    :type secured_group_category_references: required
+    :param src_allow_spec: (:attr:`src_allow_spec`) 
+    :type src_allow_spec: 
     :param dest_allow_spec: (:attr:`dest_allow_spec`) 
     :type dest_allow_spec: 
-    :param source_categories: (:attr:`source_categories`) 
-    :type source_categories: 
-    :param dest_categories: (:attr:`dest_categories`) 
-    :type dest_categories: 
-    :param source_subnet: (:attr:`source_subnet`) 
-    :type source_subnet: 
+    :param src_category_references: (:attr:`src_category_references`) List of categories that define a set of network endpoints as inbound.
+    :type src_category_references: 
+    :param dest_category_references: (:attr:`dest_category_references`) List of categories that define a set of network endpoints as outbound.
+    :type dest_category_references: 
+    :param src_subnet: (:attr:`src_subnet`) 
+    :type src_subnet: 
     :param dest_subnet: (:attr:`dest_subnet`) 
     :type dest_subnet: 
-    :param source_address_group: (:attr:`source_address_group`) A reference to an address group.
-    :type source_address_group: 
-    :param dest_address_group: (:attr:`dest_address_group`) A reference to an address group.
-    :type dest_address_group: 
-    :param service_groups: (:attr:`service_groups`) 
-    :type service_groups: 
-    :param is_all_protocol_allowed: (:attr:`is_all_protocol_allowed`) 
+    :param src_address_group_references: (:attr:`src_address_group_references`) A list of address group references.
+    :type src_address_group_references: 
+    :param dest_address_group_references: (:attr:`dest_address_group_references`) A list of address group references.
+    :type dest_address_group_references: 
+    :param service_group_references: (:attr:`service_group_references`) 
+    :type service_group_references: 
+    :param is_all_protocol_allowed: (:attr:`is_all_protocol_allowed`) Denotes if rule allows traffic for all protocol.
     :type is_all_protocol_allowed: 
     :param tcp_services: (:attr:`tcp_services`) 
     :type tcp_services: 
     :param udp_services: (:attr:`udp_services`) 
     :type udp_services: 
     :param icmp_services: (:attr:`icmp_services`) Icmp Type Code List.
     :type icmp_services: 
-    :param network_function_chain_ext_id: (:attr:`network_function_chain_ext_id`) 
-    :type network_function_chain_ext_id: 
+    :param network_function_chain_reference: (:attr:`network_function_chain_reference`) A reference to the network function chain in the rule.
+    :type network_function_chain_reference: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'secured_group': 'list[str]',
-        'source_allow_spec': 'microseg.v4.config.AllowType',
+        'secured_group_category_references': 'list[str]',
+        'src_allow_spec': 'microseg.v4.config.AllowType',
         'dest_allow_spec': 'microseg.v4.config.AllowType',
-        'source_categories': 'list[str]',
-        'dest_categories': 'list[str]',
-        'source_subnet': 'common.v1.config.IPv4Address',
+        'src_category_references': 'list[str]',
+        'dest_category_references': 'list[str]',
+        'src_subnet': 'common.v1.config.IPv4Address',
         'dest_subnet': 'common.v1.config.IPv4Address',
-        'source_address_group': 'str',
-        'dest_address_group': 'str',
-        'service_groups': 'list[str]',
+        'src_address_group_references': 'list[str]',
+        'dest_address_group_references': 'list[str]',
+        'service_group_references': 'list[str]',
         'is_all_protocol_allowed': 'bool',
         'tcp_services': 'list[microseg.v4.config.TcpPortRangeSpec]',
         'udp_services': 'list[microseg.v4.config.UdpPortRangeSpec]',
         'icmp_services': 'list[microseg.v4.config.IcmpTypeCodeSpec]',
-        'network_function_chain_ext_id': 'str',
+        'network_function_chain_reference': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'secured_group': 'securedGroup',
-        'source_allow_spec': 'sourceAllowSpec',
+        'secured_group_category_references': 'securedGroupCategoryReferences',
+        'src_allow_spec': 'srcAllowSpec',
         'dest_allow_spec': 'destAllowSpec',
-        'source_categories': 'sourceCategories',
-        'dest_categories': 'destCategories',
-        'source_subnet': 'sourceSubnet',
+        'src_category_references': 'srcCategoryReferences',
+        'dest_category_references': 'destCategoryReferences',
+        'src_subnet': 'srcSubnet',
         'dest_subnet': 'destSubnet',
-        'source_address_group': 'sourceAddressGroup',
-        'dest_address_group': 'destAddressGroup',
-        'service_groups': 'serviceGroups',
+        'src_address_group_references': 'srcAddressGroupReferences',
+        'dest_address_group_references': 'destAddressGroupReferences',
+        'service_group_references': 'serviceGroupReferences',
         'is_all_protocol_allowed': 'isAllProtocolAllowed',
         'tcp_services': 'tcpServices',
         'udp_services': 'udpServices',
         'icmp_services': 'icmpServices',
-        'network_function_chain_ext_id': 'networkFunctionChainExtId',
+        'network_function_chain_reference': 'networkFunctionChainReference',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, secured_group=None, source_allow_spec=None, dest_allow_spec=None, source_categories=None, dest_categories=None, source_subnet=None, dest_subnet=None, source_address_group=None, dest_address_group=None, service_groups=None, is_all_protocol_allowed=None, tcp_services=None, udp_services=None, icmp_services=None, network_function_chain_ext_id=None, *args, **kwargs):  # noqa: E501
-        self.__secured_group = None
-        self.__source_allow_spec = None
+    def __init__(self, secured_group_category_references=None, src_allow_spec=None, dest_allow_spec=None, src_category_references=None, dest_category_references=None, src_subnet=None, dest_subnet=None, src_address_group_references=None, dest_address_group_references=None, service_group_references=None, is_all_protocol_allowed=None, tcp_services=None, udp_services=None, icmp_services=None, network_function_chain_reference=None, *args, **kwargs):  # noqa: E501
+        self.__secured_group_category_references = None
+        self.__src_allow_spec = None
         self.__dest_allow_spec = None
-        self.__source_categories = None
-        self.__dest_categories = None
-        self.__source_subnet = None
+        self.__src_category_references = None
+        self.__dest_category_references = None
+        self.__src_subnet = None
         self.__dest_subnet = None
-        self.__source_address_group = None
-        self.__dest_address_group = None
-        self.__service_groups = None
+        self.__src_address_group_references = None
+        self.__dest_address_group_references = None
+        self.__service_group_references = None
         self.__is_all_protocol_allowed = None
         self.__tcp_services = None
         self.__udp_services = None
         self.__icmp_services = None
-        self.__network_function_chain_ext_id = None
+        self.__network_function_chain_reference = None
         self.discriminator = None
-        self.__secured_group = secured_group
-        if source_allow_spec is not None:
-            self.__source_allow_spec = source_allow_spec
+        self.__secured_group_category_references = secured_group_category_references
+        if src_allow_spec is not None:
+            self.__src_allow_spec = src_allow_spec
         if dest_allow_spec is not None:
             self.__dest_allow_spec = dest_allow_spec
-        if source_categories is not None:
-            self.__source_categories = source_categories
-        if dest_categories is not None:
-            self.__dest_categories = dest_categories
-        if source_subnet is not None:
-            self.__source_subnet = source_subnet
+        if src_category_references is not None:
+            self.__src_category_references = src_category_references
+        if dest_category_references is not None:
+            self.__dest_category_references = dest_category_references
+        if src_subnet is not None:
+            self.__src_subnet = src_subnet
         if dest_subnet is not None:
             self.__dest_subnet = dest_subnet
-        if source_address_group is not None:
-            self.__source_address_group = source_address_group
-        if dest_address_group is not None:
-            self.__dest_address_group = dest_address_group
-        if service_groups is not None:
-            self.__service_groups = service_groups
+        if src_address_group_references is not None:
+            self.__src_address_group_references = src_address_group_references
+        if dest_address_group_references is not None:
+            self.__dest_address_group_references = dest_address_group_references
+        if service_group_references is not None:
+            self.__service_group_references = service_group_references
         if is_all_protocol_allowed is not None:
             self.__is_all_protocol_allowed = is_all_protocol_allowed
         if tcp_services is not None:
             self.__tcp_services = tcp_services
         if udp_services is not None:
             self.__udp_services = udp_services
         if icmp_services is not None:
             self.__icmp_services = icmp_services
-        if network_function_chain_ext_id is not None:
-            self.__network_function_chain_ext_id = network_function_chain_ext_id
+        if network_function_chain_reference is not None:
+            self.__network_function_chain_reference = network_function_chain_reference
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.NSPApplicationRuleSpec'
+        return 'microseg.v4.config.ApplicationRuleSpec'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.NSPApplicationRuleSpec'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def secured_group(self):
+    def secured_group_category_references(self):
         """
-        
+        A set of network endpoints which is protected by a Network Security Policy and defined as a list of categories.
 
         :type:
             list[ :class:`~str` ]
         """  # noqa: E501
-        return self.__secured_group
+        return self.__secured_group_category_references
 
-    @secured_group.setter
-    def secured_group(self, secured_group):
-        if secured_group is None:
-            raise ValueError("Invalid value for `secured_group`, must not be `None`")  # noqa: E501
+    @secured_group_category_references.setter
+    def secured_group_category_references(self, secured_group_category_references):
+        if secured_group_category_references is None:
+            raise ValueError("Invalid value for `secured_group_category_references`, must not be `None`")  # noqa: E501
 
-        self.__secured_group = secured_group
+        self.__secured_group_category_references = secured_group_category_references
 
     @property
-    def source_allow_spec(self):
+    def src_allow_spec(self):
         """
         
 
         :type:
             :class:`~ntnx_microseg_py_client.models.microseg.v4.config.AllowType`
         """  # noqa: E501
-        return self.__source_allow_spec
+        return self.__src_allow_spec
 
-    @source_allow_spec.setter
-    def source_allow_spec(self, source_allow_spec):
+    @src_allow_spec.setter
+    def src_allow_spec(self, src_allow_spec):
 
-        self.__source_allow_spec = source_allow_spec
+        self.__src_allow_spec = src_allow_spec
 
     @property
     def dest_allow_spec(self):
         """
         
 
         :type:
@@ -241,57 +242,57 @@
 
     @dest_allow_spec.setter
     def dest_allow_spec(self, dest_allow_spec):
 
         self.__dest_allow_spec = dest_allow_spec
 
     @property
-    def source_categories(self):
+    def src_category_references(self):
         """
-        
+        List of categories that define a set of network endpoints as inbound.
 
         :type:
             list[ :class:`~str` ]
         """  # noqa: E501
-        return self.__source_categories
+        return self.__src_category_references
 
-    @source_categories.setter
-    def source_categories(self, source_categories):
+    @src_category_references.setter
+    def src_category_references(self, src_category_references):
 
-        self.__source_categories = source_categories
+        self.__src_category_references = src_category_references
 
     @property
-    def dest_categories(self):
+    def dest_category_references(self):
         """
-        
+        List of categories that define a set of network endpoints as outbound.
 
         :type:
             list[ :class:`~str` ]
         """  # noqa: E501
-        return self.__dest_categories
+        return self.__dest_category_references
 
-    @dest_categories.setter
-    def dest_categories(self, dest_categories):
+    @dest_category_references.setter
+    def dest_category_references(self, dest_category_references):
 
-        self.__dest_categories = dest_categories
+        self.__dest_category_references = dest_category_references
 
     @property
-    def source_subnet(self):
+    def src_subnet(self):
         """
         
 
         :type:
             :class:`~ntnx_microseg_py_client.models.common.v1.config.IPv4Address`
         """  # noqa: E501
-        return self.__source_subnet
+        return self.__src_subnet
 
-    @source_subnet.setter
-    def source_subnet(self, source_subnet):
+    @src_subnet.setter
+    def src_subnet(self, src_subnet):
 
-        self.__source_subnet = source_subnet
+        self.__src_subnet = src_subnet
 
     @property
     def dest_subnet(self):
         """
         
 
         :type:
@@ -301,68 +302,62 @@
 
     @dest_subnet.setter
     def dest_subnet(self, dest_subnet):
 
         self.__dest_subnet = dest_subnet
 
     @property
-    def source_address_group(self):
+    def src_address_group_references(self):
         """
-        A reference to an address group.
+        A list of address group references.
 
         :type:
-
-                :class:`~str`
+            list[ :class:`~str` ]
         """  # noqa: E501
-        return self.__source_address_group
+        return self.__src_address_group_references
 
-    @source_address_group.setter
-    def source_address_group(self, source_address_group):
-        if source_address_group is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', source_address_group):  # noqa: E501
-            raise ValueError(r"Invalid value for `source_address_group`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
+    @src_address_group_references.setter
+    def src_address_group_references(self, src_address_group_references):
 
-        self.__source_address_group = source_address_group
+        self.__src_address_group_references = src_address_group_references
 
     @property
-    def dest_address_group(self):
+    def dest_address_group_references(self):
         """
-        A reference to an address group.
+        A list of address group references.
 
         :type:
-
-                :class:`~str`
+            list[ :class:`~str` ]
         """  # noqa: E501
-        return self.__dest_address_group
+        return self.__dest_address_group_references
 
-    @dest_address_group.setter
-    def dest_address_group(self, dest_address_group):
-        if dest_address_group is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', dest_address_group):  # noqa: E501
-            raise ValueError(r"Invalid value for `dest_address_group`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
+    @dest_address_group_references.setter
+    def dest_address_group_references(self, dest_address_group_references):
 
-        self.__dest_address_group = dest_address_group
+        self.__dest_address_group_references = dest_address_group_references
 
     @property
-    def service_groups(self):
+    def service_group_references(self):
         """
         
 
         :type:
             list[ :class:`~str` ]
         """  # noqa: E501
-        return self.__service_groups
+        return self.__service_group_references
 
-    @service_groups.setter
-    def service_groups(self, service_groups):
+    @service_group_references.setter
+    def service_group_references(self, service_group_references):
 
-        self.__service_groups = service_groups
+        self.__service_group_references = service_group_references
 
     @property
     def is_all_protocol_allowed(self):
         """
-        
+        Denotes if rule allows traffic for all protocol.
 
         :type:
 
                 :class:`~bool`
         """  # noqa: E501
         return self.__is_all_protocol_allowed
 
@@ -413,30 +408,30 @@
 
     @icmp_services.setter
     def icmp_services(self, icmp_services):
 
         self.__icmp_services = icmp_services
 
     @property
-    def network_function_chain_ext_id(self):
+    def network_function_chain_reference(self):
         """
-        
+        A reference to the network function chain in the rule.
 
         :type:
 
                 :class:`~str`
         """  # noqa: E501
-        return self.__network_function_chain_ext_id
+        return self.__network_function_chain_reference
 
-    @network_function_chain_ext_id.setter
-    def network_function_chain_ext_id(self, network_function_chain_ext_id):
-        if network_function_chain_ext_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', network_function_chain_ext_id):  # noqa: E501
-            raise ValueError(r"Invalid value for `network_function_chain_ext_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
+    @network_function_chain_reference.setter
+    def network_function_chain_reference(self, network_function_chain_reference):
+        if network_function_chain_reference is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', network_function_chain_reference):  # noqa: E501
+            raise ValueError(r"Invalid value for `network_function_chain_reference`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
 
-        self.__network_function_chain_ext_id = network_function_chain_ext_id
+        self.__network_function_chain_reference = network_function_chain_reference
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -469,37 +464,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(NSPApplicationRuleSpec, dict):
+        if issubclass(ApplicationRuleSpec, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -511,15 +511,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, NSPApplicationRuleSpec):
+        if not isinstance(other, ApplicationRuleSpec):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/NSPIntraEntityGroupRuleSpec.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/IntraEntityGroupRuleSpec.py`

 * *Files 17% similar despite different names*

```diff
@@ -3,124 +3,125 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_microseg_py_client.models.microseg.v4.config.IntraEntityGroupRuleAction import IntraEntityGroupRuleAction  # noqa: F401,E501
 
-class NSPIntraEntityGroupRuleSpec(object):
+class IntraEntityGroupRuleSpec(object):
 
     """A rule for specifying allowed traffic inside of a secured entity group.
 
-    :param secured_group: (:attr:`secured_group`) 
-    :type secured_group: required
+    :param secured_group_category_references: (:attr:`secured_group_category_references`) 
+    :type secured_group_category_references: required
     :param secured_group_action: (:attr:`secured_group_action`) 
     :type secured_group_action: required
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'secured_group': 'list[str]',
+        'secured_group_category_references': 'list[str]',
         'secured_group_action': 'microseg.v4.config.IntraEntityGroupRuleAction',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'secured_group': 'securedGroup',
+        'secured_group_category_references': 'securedGroupCategoryReferences',
         'secured_group_action': 'securedGroupAction',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, secured_group=None, secured_group_action=None, *args, **kwargs):  # noqa: E501
-        self.__secured_group = None
+    def __init__(self, secured_group_category_references=None, secured_group_action=None, *args, **kwargs):  # noqa: E501
+        self.__secured_group_category_references = None
         self.__secured_group_action = None
         self.discriminator = None
-        self.__secured_group = secured_group
+        self.__secured_group_category_references = secured_group_category_references
         self.__secured_group_action = secured_group_action
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.NSPIntraEntityGroupRuleSpec'
+        return 'microseg.v4.config.IntraEntityGroupRuleSpec'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.NSPIntraEntityGroupRuleSpec'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def secured_group(self):
+    def secured_group_category_references(self):
         """
         
 
         :type:
             list[ :class:`~str` ]
         """  # noqa: E501
-        return self.__secured_group
+        return self.__secured_group_category_references
 
-    @secured_group.setter
-    def secured_group(self, secured_group):
-        if secured_group is None:
-            raise ValueError("Invalid value for `secured_group`, must not be `None`")  # noqa: E501
+    @secured_group_category_references.setter
+    def secured_group_category_references(self, secured_group_category_references):
+        if secured_group_category_references is None:
+            raise ValueError("Invalid value for `secured_group_category_references`, must not be `None`")  # noqa: E501
 
-        self.__secured_group = secured_group
+        self.__secured_group_category_references = secured_group_category_references
 
     @property
     def secured_group_action(self):
         """
         
 
         :type:
@@ -170,37 +171,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(NSPIntraEntityGroupRuleSpec, dict):
+        if issubclass(IntraEntityGroupRuleSpec, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -212,15 +218,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, NSPIntraEntityGroupRuleSpec):
+        if not isinstance(other, IntraEntityGroupRuleSpec):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/NSPTwoEnvIsolationRuleSpec.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/operation/PolicyCountByType.py`

 * *Files 26% similar despite different names*

```diff
@@ -3,140 +3,141 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-
-class NSPTwoEnvIsolationRuleSpec(object):
-
-    """A rule for specifying that two environments should be isolated from each other. Specify both 'firstIsolationGroup' and 'secondIsolationGroup'.
-
-    :param first_isolation_group: (:attr:`first_isolation_group`) 
-    :type first_isolation_group: required
-    :param second_isolation_group: (:attr:`second_isolation_group`) 
-    :type second_isolation_group: required
+from pathlib import Path
+from ntnx_microseg_py_client.models.microseg.v4.operation.PolicyCount import PolicyCount  # noqa: F401,E501
+from ntnx_microseg_py_client.models.microseg.v4.operation.SecurityPolicyType import SecurityPolicyType  # noqa: F401,E501
+
+class PolicyCountByType(object):
+
+    """Count statistics for number of policies before and after the upgrade as well as type of policy.
+
+    :param type: (:attr:`type`) 
+    :type type: 
+    :param count_summary: (:attr:`count_summary`) 
+    :type count_summary: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'first_isolation_group': 'list[str]',
-        'second_isolation_group': 'list[str]',
+        'type': 'microseg.v4.operation.SecurityPolicyType',
+        'count_summary': 'microseg.v4.operation.PolicyCount',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'first_isolation_group': 'firstIsolationGroup',
-        'second_isolation_group': 'secondIsolationGroup',
+        'type': 'type',
+        'count_summary': 'countSummary',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, first_isolation_group=None, second_isolation_group=None, *args, **kwargs):  # noqa: E501
-        self.__first_isolation_group = None
-        self.__second_isolation_group = None
+    def __init__(self, type=None, count_summary=None, *args, **kwargs):  # noqa: E501
+        self.__type = None
+        self.__count_summary = None
         self.discriminator = None
-        self.__first_isolation_group = first_isolation_group
-        self.__second_isolation_group = second_isolation_group
+        if type is not None:
+            self.__type = type
+        if count_summary is not None:
+            self.__count_summary = count_summary
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.NSPTwoEnvIsolationRuleSpec'
+        return 'microseg.v4.operation.PolicyCountByType'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.NSPTwoEnvIsolationRuleSpec'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def first_isolation_group(self):
+    def type(self):
         """
         
 
         :type:
-            list[ :class:`~str` ]
+            :class:`~ntnx_microseg_py_client.models.microseg.v4.operation.SecurityPolicyType`
         """  # noqa: E501
-        return self.__first_isolation_group
+        return self.__type
 
-    @first_isolation_group.setter
-    def first_isolation_group(self, first_isolation_group):
-        if first_isolation_group is None:
-            raise ValueError("Invalid value for `first_isolation_group`, must not be `None`")  # noqa: E501
+    @type.setter
+    def type(self, type):
 
-        self.__first_isolation_group = first_isolation_group
+        self.__type = type
 
     @property
-    def second_isolation_group(self):
+    def count_summary(self):
         """
         
 
         :type:
-            list[ :class:`~str` ]
+            :class:`~ntnx_microseg_py_client.models.microseg.v4.operation.PolicyCount`
         """  # noqa: E501
-        return self.__second_isolation_group
+        return self.__count_summary
 
-    @second_isolation_group.setter
-    def second_isolation_group(self, second_isolation_group):
-        if second_isolation_group is None:
-            raise ValueError("Invalid value for `second_isolation_group`, must not be `None`")  # noqa: E501
+    @count_summary.setter
+    def count_summary(self, count_summary):
 
-        self.__second_isolation_group = second_isolation_group
+        self.__count_summary = count_summary
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -169,37 +170,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(NSPTwoEnvIsolationRuleSpec, dict):
+        if issubclass(PolicyCountByType, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -211,15 +217,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, NSPTwoEnvIsolationRuleSpec):
+        if not isinstance(other, PolicyCountByType):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/NetworkSecurityPolicy.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/NetworkSecurityPolicy.py`

 * *Files 17% similar despite different names*

```diff
@@ -3,30 +3,32 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_microseg_py_client.models.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
 from ntnx_microseg_py_client.models.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel  # noqa: F401,E501
 from ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyRule import NetworkSecurityPolicyRule  # noqa: F401,E501
-from ntnx_microseg_py_client.models.microseg.v4.config.PolicyState import PolicyState  # noqa: F401,E501
-from ntnx_microseg_py_client.models.microseg.v4.config.PolicyType import PolicyType  # noqa: F401,E501
+from ntnx_microseg_py_client.models.microseg.v4.config.SecurityPolicyScope import SecurityPolicyScope  # noqa: F401,E501
+from ntnx_microseg_py_client.models.microseg.v4.config.SecurityPolicyState import SecurityPolicyState  # noqa: F401,E501
+from ntnx_microseg_py_client.models.microseg.v4.config.SecurityPolicyType import SecurityPolicyType  # noqa: F401,E501
 
 class NetworkSecurityPolicy(ExternalizableAbstractModel):
 
     """
 
     :param name: (:attr:`name`) Name of the Flow Network Security Policy.<br> It can have a maximum length of 63 characters. 
     :type name: required
@@ -34,52 +36,58 @@
     :type type: required
     :param description: (:attr:`description`) A user defined annotation for a policy.
     :type description: 
     :param state: (:attr:`state`) 
     :type state: 
     :param rules: (:attr:`rules`) A list of rules that form a policy. For isolation policies, use isolation rules; for application or quarantine policies, use application rules.
     :type rules: 
-    :param is_ipv6_traffic_allowed: (:attr:`is_ipv6_traffic_allowed`) If Ipv6 Traffic is allowed
+    :param is_ipv6_traffic_allowed: (:attr:`is_ipv6_traffic_allowed`) If Ipv6 Traffic is allowed.
     :type is_ipv6_traffic_allowed: 
-    :param is_hitlog_enabled: (:attr:`is_hitlog_enabled`) If Hitlog is enabled
+    :param is_hitlog_enabled: (:attr:`is_hitlog_enabled`) If Hitlog is enabled.
     :type is_hitlog_enabled: 
-    :param vpc_ext_id: (:attr:`vpc_ext_id`) 
-    :type vpc_ext_id: 
-    :param secured_groups: (:attr:`secured_groups`) 
+    :param scope: (:attr:`scope`) 
+    :type scope: 
+    :param vpc_references: (:attr:`vpc_references`) A list of external ids for VPCs, used only when the scope of policy is a list of VPCs.
+    :type vpc_references: 
+    :param secured_groups: (:attr:`secured_groups`) Uuids of the secured groups in the NSP.
     :type secured_groups: 
     :param last_update_time: (:attr:`last_update_time`) 
     :type last_update_time: 
     :param creation_time: (:attr:`creation_time`) 
     :type creation_time: 
     :param is_system_defined: (:attr:`is_system_defined`) 
     :type is_system_defined: 
+    :param created_by: (:attr:`created_by`) 
+    :type created_by: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'name': 'str',
-        'type': 'microseg.v4.config.PolicyType',
+        'type': 'microseg.v4.config.SecurityPolicyType',
         'description': 'str',
-        'state': 'microseg.v4.config.PolicyState',
+        'state': 'microseg.v4.config.SecurityPolicyState',
         'rules': 'list[microseg.v4.config.NetworkSecurityPolicyRule]',
         'is_ipv6_traffic_allowed': 'bool',
         'is_hitlog_enabled': 'bool',
-        'vpc_ext_id': 'str',
+        'scope': 'microseg.v4.config.SecurityPolicyScope',
+        'vpc_references': 'list[str]',
         'secured_groups': 'list[str]',
         'last_update_time': 'datetime',
         'creation_time': 'datetime',
         'is_system_defined': 'bool',
+        'created_by': 'str',
         'ext_id': 'str',
         'links': 'list[common.v1.response.ApiLink]',
         'tenant_id': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
@@ -88,72 +96,80 @@
         'name': 'name',
         'type': 'type',
         'description': 'description',
         'state': 'state',
         'rules': 'rules',
         'is_ipv6_traffic_allowed': 'isIpv6TrafficAllowed',
         'is_hitlog_enabled': 'isHitlogEnabled',
-        'vpc_ext_id': 'vpcExtId',
+        'scope': 'scope',
+        'vpc_references': 'vpcReferences',
         'secured_groups': 'securedGroups',
         'last_update_time': 'lastUpdateTime',
         'creation_time': 'creationTime',
         'is_system_defined': 'isSystemDefined',
+        'created_by': 'createdBy',
         'ext_id': 'extId',
         'links': 'links',
         'tenant_id': 'tenantId',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, name=None, type=None, description=None, state=None, rules=None, is_ipv6_traffic_allowed=None, is_hitlog_enabled=None, vpc_ext_id=None, secured_groups=None, last_update_time=None, creation_time=None, is_system_defined=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
+    def __init__(self, name=None, type=None, description=None, state=None, rules=None, is_ipv6_traffic_allowed=None, is_hitlog_enabled=None, scope=None, vpc_references=None, secured_groups=None, last_update_time=None, creation_time=None, is_system_defined=None, created_by=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
         ExternalizableAbstractModel.__init__(self, ext_id, links, tenant_id, *args, **kwargs)
         self.__name = None
         self.__type = None
         self.__description = None
         self.__state = None
         self.__rules = None
         self.__is_ipv6_traffic_allowed = None
         self.__is_hitlog_enabled = None
-        self.__vpc_ext_id = None
+        self.__scope = None
+        self.__vpc_references = None
         self.__secured_groups = None
         self.__last_update_time = None
         self.__creation_time = None
         self.__is_system_defined = None
+        self.__created_by = None
         self.discriminator = None
         self.__name = name
         self.__type = type
         if description is not None:
             self.__description = description
         if state is not None:
             self.__state = state
         if rules is not None:
             self.__rules = rules
         if is_ipv6_traffic_allowed is not None:
             self.__is_ipv6_traffic_allowed = is_ipv6_traffic_allowed
         if is_hitlog_enabled is not None:
             self.__is_hitlog_enabled = is_hitlog_enabled
-        if vpc_ext_id is not None:
-            self.__vpc_ext_id = vpc_ext_id
+        if scope is not None:
+            self.__scope = scope
+        if vpc_references is not None:
+            self.__vpc_references = vpc_references
         if secured_groups is not None:
             self.__secured_groups = secured_groups
         if last_update_time is not None:
             self.__last_update_time = last_update_time
         if creation_time is not None:
             self.__creation_time = creation_time
         if is_system_defined is not None:
             self.__is_system_defined = is_system_defined
+        if created_by is not None:
+            self.__created_by = created_by
 
     def _initialize_object_type(self):
         return 'microseg.v4.config.NetworkSecurityPolicy'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.NetworkSecurityPolicy'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     @property
     def name(self):
         """
         Name of the Flow Network Security Policy.<br> It can have a maximum length of 63 characters. 
 
@@ -174,15 +190,15 @@
 
     @property
     def type(self):
         """
         
 
         :type:
-            :class:`~ntnx_microseg_py_client.models.microseg.v4.config.PolicyType`
+            :class:`~ntnx_microseg_py_client.models.microseg.v4.config.SecurityPolicyType`
         """  # noqa: E501
         return self.__type
 
     @type.setter
     def type(self, type):
         if type is None:
             raise ValueError("Invalid value for `type`, must not be `None`")  # noqa: E501
@@ -209,15 +225,15 @@
 
     @property
     def state(self):
         """
         
 
         :type:
-            :class:`~ntnx_microseg_py_client.models.microseg.v4.config.PolicyState`
+            :class:`~ntnx_microseg_py_client.models.microseg.v4.config.SecurityPolicyState`
         """  # noqa: E501
         return self.__state
 
     @state.setter
     def state(self, state):
 
         self.__state = state
@@ -236,15 +252,15 @@
     def rules(self, rules):
 
         self.__rules = rules
 
     @property
     def is_ipv6_traffic_allowed(self):
         """
-        If Ipv6 Traffic is allowed
+        If Ipv6 Traffic is allowed.
 
         :type:
 
                 :class:`~bool`
         """  # noqa: E501
         return self.__is_ipv6_traffic_allowed
 
@@ -252,49 +268,61 @@
     def is_ipv6_traffic_allowed(self, is_ipv6_traffic_allowed):
 
         self.__is_ipv6_traffic_allowed = is_ipv6_traffic_allowed
 
     @property
     def is_hitlog_enabled(self):
         """
-        If Hitlog is enabled
+        If Hitlog is enabled.
 
         :type:
 
                 :class:`~bool`
         """  # noqa: E501
         return self.__is_hitlog_enabled
 
     @is_hitlog_enabled.setter
     def is_hitlog_enabled(self, is_hitlog_enabled):
 
         self.__is_hitlog_enabled = is_hitlog_enabled
 
     @property
-    def vpc_ext_id(self):
+    def scope(self):
         """
         
 
         :type:
+            :class:`~ntnx_microseg_py_client.models.microseg.v4.config.SecurityPolicyScope`
+        """  # noqa: E501
+        return self.__scope
 
-                :class:`~str`
+    @scope.setter
+    def scope(self, scope):
+
+        self.__scope = scope
+
+    @property
+    def vpc_references(self):
+        """
+        A list of external ids for VPCs, used only when the scope of policy is a list of VPCs.
+
+        :type:
+            list[ :class:`~str` ]
         """  # noqa: E501
-        return self.__vpc_ext_id
+        return self.__vpc_references
 
-    @vpc_ext_id.setter
-    def vpc_ext_id(self, vpc_ext_id):
-        if vpc_ext_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', vpc_ext_id):  # noqa: E501
-            raise ValueError(r"Invalid value for `vpc_ext_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
+    @vpc_references.setter
+    def vpc_references(self, vpc_references):
 
-        self.__vpc_ext_id = vpc_ext_id
+        self.__vpc_references = vpc_references
 
     @property
     def secured_groups(self):
         """
-        
+        Uuids of the secured groups in the NSP.
 
         :type:
             list[ :class:`~str` ]
         """  # noqa: E501
         return self.__secured_groups
 
     @secured_groups.setter
@@ -346,36 +374,59 @@
         return self.__is_system_defined
 
     @is_system_defined.setter
     def is_system_defined(self, is_system_defined):
 
         self.__is_system_defined = is_system_defined
 
+    @property
+    def created_by(self):
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__created_by
+
+    @created_by.setter
+    def created_by(self, created_by):
+        if created_by is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', created_by):  # noqa: E501
+            raise ValueError(r"Invalid value for `created_by`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
+
+        self.__created_by = created_by
+
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/NetworkSecurityPolicyGetListResponse.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/CreateNetworkSecurityPolicyApiResponse.py`

 * *Files 9% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_microseg_py_client.models
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.NetworkSecurityPolicyGetListResponsedata import NetworkSecurityPolicyGetListResponsedata  # noqa: F401,E501
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.CreateNetworkSecurityPolicyApiResponsedata import CreateNetworkSecurityPolicyApiResponsedata  # noqa: F401,E501
 from ntnx_microseg_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class NetworkSecurityPolicyGetListResponse(object):
+class CreateNetworkSecurityPolicyApiResponse(object):
 
-    """REST response for all response codes in API path /microseg/v4.0.a1/config/policies Get operation
+    """REST response for all response codes in API path /microseg/v4.0.b1/config/policies Post operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfmicroseg.v4.config.NetworkSecurityPolicyGetListResponsedata',
+        'data': 'OneOfmicroseg.v4.config.CreateNetworkSecurityPolicyApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.NetworkSecurityPolicyGetListResponse'
+        return 'microseg.v4.config.CreateNetworkSecurityPolicyApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.NetworkSecurityPolicyGetListResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -122,16 +123,15 @@
 
     @property
     def data(self):
         """
         
 
         :type:
-                :class:`~ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicy` | 
-                :class:`~ntnx_microseg_py_client.models.microseg.v4.config.FileWrapper` | 
+                :class:`~ntnx_microseg_py_client.models.prism.v4.config.TaskReference` | 
                 :class:`~ntnx_microseg_py_client.models.microseg.v4.error.ErrorResponse`
                     """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
@@ -172,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_microseg_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(NetworkSecurityPolicyGetListResponse, dict):
+        if issubclass(CreateNetworkSecurityPolicyApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -216,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, NetworkSecurityPolicyGetListResponse):
+        if not isinstance(other, CreateNetworkSecurityPolicyApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/NetworkSecurityPolicyGetResponse.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/CreateNetworkSecurityPolicyExportApiResponse.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_microseg_py_client.models
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.NetworkSecurityPolicyGetResponsedata import NetworkSecurityPolicyGetResponsedata  # noqa: F401,E501
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.CreateNetworkSecurityPolicyExportApiResponsedata import CreateNetworkSecurityPolicyExportApiResponsedata  # noqa: F401,E501
 from ntnx_microseg_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class NetworkSecurityPolicyGetResponse(object):
+class CreateNetworkSecurityPolicyExportApiResponse(object):
 
-    """REST response for all response codes in API path /microseg/v4.0.a1/config/policies/{extId} Get operation
+    """REST response for all response codes in API path /microseg/v4.0.b1/config/policies/$actions/prepare-export Post operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfmicroseg.v4.config.NetworkSecurityPolicyGetResponsedata',
+        'data': 'OneOfmicroseg.v4.config.CreateNetworkSecurityPolicyExportApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.NetworkSecurityPolicyGetResponse'
+        return 'microseg.v4.config.CreateNetworkSecurityPolicyExportApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.NetworkSecurityPolicyGetResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -122,15 +123,15 @@
 
     @property
     def data(self):
         """
         
 
         :type:
-                :class:`~ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicy` | 
+                :class:`~ntnx_microseg_py_client.models.prism.v4.config.TaskReference` | 
                 :class:`~ntnx_microseg_py_client.models.microseg.v4.error.ErrorResponse`
                     """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
@@ -171,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_microseg_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(NetworkSecurityPolicyGetResponse, dict):
+        if issubclass(CreateNetworkSecurityPolicyExportApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, NetworkSecurityPolicyGetResponse):
+        if not isinstance(other, CreateNetworkSecurityPolicyExportApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/NetworkSecurityPolicyImportEntity.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/error/AppMessage.py`

 * *Files 23% similar despite different names*

```diff
@@ -3,168 +3,232 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyImportEntityType import NetworkSecurityPolicyImportEntityType  # noqa: F401,E501
-from ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyImportEntityUpdateType import NetworkSecurityPolicyImportEntityUpdateType  # noqa: F401,E501
+from pathlib import Path
+from ntnx_microseg_py_client.models.common.v1.config.MessageSeverity import MessageSeverity  # noqa: F401,E501
 
-class NetworkSecurityPolicyImportEntity(object):
+class AppMessage(object):
 
-    """Network security rule import response data.
+    """Message with associated severity describing status of the current operation.
 
-    :param entity_type: (:attr:`entity_type`) 
-    :type entity_type: required
-    :param entity_name: (:attr:`entity_name`) Name of the entity.
-    :type entity_name: required
-    :param entity_update_type: (:attr:`entity_update_type`) 
-    :type entity_update_type: required
+    :param message: (:attr:`message`) The message string.
+    :type message: 
+    :param severity: (:attr:`severity`) 
+    :type severity: 
+    :param code: (:attr:`code`) The code associated with this message.This string is typically prefixed by the namespace the endpoint belongs to. For example: VMM-40000
+    :type code: 
+    :param locale: (:attr:`locale`) Locale for this message. The default locale would be 'en-US'. (**Default** 'en_US')
+    :type locale: 
+    :param error_group: (:attr:`error_group`) The error group associated with this message of severity ERROR.
+    :type error_group: 
+    :param arguments_map: (:attr:`arguments_map`) The map of argument name to value.
+    :type arguments_map: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'entity_type': 'microseg.v4.config.NetworkSecurityPolicyImportEntityType',
-        'entity_name': 'str',
-        'entity_update_type': 'microseg.v4.config.NetworkSecurityPolicyImportEntityUpdateType',
+        'message': 'str',
+        'severity': 'common.v1.config.MessageSeverity',
+        'code': 'str',
+        'locale': 'str',
+        'error_group': 'str',
+        'arguments_map': 'dict(str, str)',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'entity_type': 'entityType',
-        'entity_name': 'entityName',
-        'entity_update_type': 'entityUpdateType',
+        'message': 'message',
+        'severity': 'severity',
+        'code': 'code',
+        'locale': 'locale',
+        'error_group': 'errorGroup',
+        'arguments_map': 'argumentsMap',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, entity_type=None, entity_name=None, entity_update_type=None, *args, **kwargs):  # noqa: E501
-        self.__entity_type = None
-        self.__entity_name = None
-        self.__entity_update_type = None
+    def __init__(self, message=None, severity=None, code=None, locale='en_US', error_group=None, arguments_map=None, *args, **kwargs):  # noqa: E501
+        self.__message = None
+        self.__severity = None
+        self.__code = None
+        self.__locale = None
+        self.__error_group = None
+        self.__arguments_map = None
         self.discriminator = None
-        self.__entity_type = entity_type
-        self.__entity_name = entity_name
-        self.__entity_update_type = entity_update_type
+        if message is not None:
+            self.__message = message
+        if severity is not None:
+            self.__severity = severity
+        if code is not None:
+            self.__code = code
+        if locale is not None:
+            self.__locale = locale
+        if error_group is not None:
+            self.__error_group = error_group
+        if arguments_map is not None:
+            self.__arguments_map = arguments_map
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.NetworkSecurityPolicyImportEntity'
+        return 'microseg.v4.error.AppMessage'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.NetworkSecurityPolicyImportEntity'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def entity_type(self):
+    def message(self):
+        """
+        The message string.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__message
+
+    @message.setter
+    def message(self, message):
+
+        self.__message = message
+
+    @property
+    def severity(self):
         """
         
 
         :type:
-            :class:`~ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyImportEntityType`
+            :class:`~ntnx_microseg_py_client.models.common.v1.config.MessageSeverity`
         """  # noqa: E501
-        return self.__entity_type
+        return self.__severity
 
-    @entity_type.setter
-    def entity_type(self, entity_type):
-        if entity_type is None:
-            raise ValueError("Invalid value for `entity_type`, must not be `None`")  # noqa: E501
+    @severity.setter
+    def severity(self, severity):
 
-        self.__entity_type = entity_type
+        self.__severity = severity
 
     @property
-    def entity_name(self):
+    def code(self):
         """
-        Name of the entity.
+        The code associated with this message.This string is typically prefixed by the namespace the endpoint belongs to. For example: VMM-40000
 
         :type:
 
                 :class:`~str`
         """  # noqa: E501
-        return self.__entity_name
+        return self.__code
 
-    @entity_name.setter
-    def entity_name(self, entity_name):
-        if entity_name is None:
-            raise ValueError("Invalid value for `entity_name`, must not be `None`")  # noqa: E501
-        if entity_name is not None and len(entity_name) > 100:
-            raise ValueError("Invalid value for `entity_name`, length must be less than or equal to `100`")  # noqa: E501
+    @code.setter
+    def code(self, code):
 
-        self.__entity_name = entity_name
+        self.__code = code
 
     @property
-    def entity_update_type(self):
+    def locale(self):
         """
-        
+        Locale for this message. The default locale would be 'en-US'.
 
         :type:
-            :class:`~ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyImportEntityUpdateType`
+
+                :class:`~str`
         """  # noqa: E501
-        return self.__entity_update_type
+        return self.__locale
 
-    @entity_update_type.setter
-    def entity_update_type(self, entity_update_type):
-        if entity_update_type is None:
-            raise ValueError("Invalid value for `entity_update_type`, must not be `None`")  # noqa: E501
+    @locale.setter
+    def locale(self, locale):
 
-        self.__entity_update_type = entity_update_type
+        self.__locale = locale
+
+    @property
+    def error_group(self):
+        """
+        The error group associated with this message of severity ERROR.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__error_group
+
+    @error_group.setter
+    def error_group(self, error_group):
+
+        self.__error_group = error_group
+
+    @property
+    def arguments_map(self):
+        """
+        The map of argument name to value.
+
+        :type:
+            dict(str, :class:`~str`)
+        """  # noqa: E501
+        return self.__arguments_map
+
+    @arguments_map.setter
+    def arguments_map(self, arguments_map):
+
+        self.__arguments_map = arguments_map
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -197,37 +261,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(NetworkSecurityPolicyImportEntity, dict):
+        if issubclass(AppMessage, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -239,15 +308,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, NetworkSecurityPolicyImportEntity):
+        if not isinstance(other, AppMessage):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/NetworkSecurityPolicyImportEntityType.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/ListNetworkSecurityPoliciesApiResponsedata.py`

 * *Files 22% similar despite different names*

```diff
@@ -3,121 +3,168 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class NetworkSecurityPolicyImportEntityType(object):
-
-    """Type of the entity.
+class ListNetworkSecurityPoliciesApiResponsedata(object):
 
+    """
 
-    Allowed enum values:
 
-        - _UNKNOWN
-        - _REDACTED
-        - CATEGORY: Imported Category.
-        - NETWORK_FUNCTION_CHAIN: Imported Network Function Chain.
-        - POLICY: Imported Policy.
-        - ADDRESS_GROUP: Imported an Address group.
-        - SERVICE_GROUP: Imported Service group.
     """
-    _UNKNOWN = "$UNKNOWN"
-    _REDACTED = "$REDACTED"
-    CATEGORY = "CATEGORY"
-    NETWORK_FUNCTION_CHAIN = "NETWORK_FUNCTION_CHAIN"
-    POLICY = "POLICY"
-    ADDRESS_GROUP = "ADDRESS_GROUP"
-    SERVICE_GROUP = "SERVICE_GROUP"
+    """
+    IGNORE:
+    Attributes:
+      swagger_types (dict): The key is attribute name
+                            and the value is attribute type.
+      attribute_map (dict): The key is attribute name
+                            and the value is json key in definition.
+    IGNORE
+    """  # noqa: E501
+    swagger_types = {
+    }
+
+    attribute_map = {
+    }
+
+    discriminator_value_class_map = {
+        'EMPTY_LIST': 'list[str]',
+        'EMPTY_MAP': 'dict(str, object)',
+        'List<microseg.v4.config.NetworkSecurityPolicy>': 'list[microseg.v4.config.NetworkSecurityPolicy]',
+        'pathlib.Path': 'Path',
+        'microseg.v4.error.ErrorResponse': 'microseg.v4.error.ErrorResponse'
+    }
+
+    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.NetworkSecurityPolicyImportEntityType'
+        return 'OneOfmicroseg.v4.config.ListNetworkSecurityPoliciesApiResponsedata'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.NetworkSecurityPolicyImportEntityType'
+    def _initialize_object_version(self):
+        return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
+    def get_real_child_model(self, discriminator):
+        """Returns the real base class specified by the discriminator"""
+        if discriminator is not None and discriminator in self.discriminator_value_class_map:
+            return self.discriminator_value_class_map.get(discriminator)
+        return None
+
+    @staticmethod
+    def get_discriminator_from_object(value):
+        """Returns the discriminator for the provided object.
+        """
+        if not value:
+            disc = 'list[str]'
+        elif hasattr(value, "_object_type"):
+            disc = value.get_object_type()
+        elif type(value) == list:
+            if hasattr(value[0], "_object_type"):
+                datatype = value[0].get_object_type()
+            else:
+                datatype = type(value[0]).__name__
+            disc = 'list[' + datatype + ']'
+        elif type(value) == dict:
+            if hasattr(next(iter(value.values())), "_object_type"):
+                datatype = next(iter(value.values())).get_object_type()
+            else:
+                datatype = type(next(iter(value.values()))).__name__
+            disc = 'dict(str, ' + datatype + ')'
+        else:
+            disc = type(value).__name__
+        if disc in ListNetworkSecurityPoliciesApiResponsedata.discriminator_value_class_map.values():
+            return list(ListNetworkSecurityPoliciesApiResponsedata.discriminator_value_class_map.keys())[list(ListNetworkSecurityPoliciesApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        return None
+
+
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(NetworkSecurityPolicyImportEntityType, dict):
+        if issubclass(ListNetworkSecurityPoliciesApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -129,15 +176,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, NetworkSecurityPolicyImportEntityType):
+        if not isinstance(other, ListNetworkSecurityPoliciesApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/NetworkSecurityPolicyImportEntityUpdateType.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/ListNetworkSecurityPolicyRulesApiResponsedata.py`

 * *Files 24% similar despite different names*

```diff
@@ -3,117 +3,167 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class NetworkSecurityPolicyImportEntityUpdateType(object):
-
-    """Type of update of the entity.
+class ListNetworkSecurityPolicyRulesApiResponsedata(object):
 
+    """
 
-    Allowed enum values:
 
-        - _UNKNOWN
-        - _REDACTED
-        - ADDED: Added Entity after Import.
-        - DELETED: Deleted Entity after Import.
-        - MODIFIED: Modified Entity after Import.
     """
-    _UNKNOWN = "$UNKNOWN"
-    _REDACTED = "$REDACTED"
-    ADDED = "ADDED"
-    DELETED = "DELETED"
-    MODIFIED = "MODIFIED"
+    """
+    IGNORE:
+    Attributes:
+      swagger_types (dict): The key is attribute name
+                            and the value is attribute type.
+      attribute_map (dict): The key is attribute name
+                            and the value is json key in definition.
+    IGNORE
+    """  # noqa: E501
+    swagger_types = {
+    }
+
+    attribute_map = {
+    }
+
+    discriminator_value_class_map = {
+        'EMPTY_LIST': 'list[str]',
+        'EMPTY_MAP': 'dict(str, object)',
+        'List<microseg.v4.config.NetworkSecurityPolicyRule>': 'list[microseg.v4.config.NetworkSecurityPolicyRule]',
+        'microseg.v4.error.ErrorResponse': 'microseg.v4.error.ErrorResponse'
+    }
+
+    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.NetworkSecurityPolicyImportEntityUpdateType'
+        return 'OneOfmicroseg.v4.config.ListNetworkSecurityPolicyRulesApiResponsedata'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.NetworkSecurityPolicyImportEntityUpdateType'
+    def _initialize_object_version(self):
+        return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
+    def get_real_child_model(self, discriminator):
+        """Returns the real base class specified by the discriminator"""
+        if discriminator is not None and discriminator in self.discriminator_value_class_map:
+            return self.discriminator_value_class_map.get(discriminator)
+        return None
+
+    @staticmethod
+    def get_discriminator_from_object(value):
+        """Returns the discriminator for the provided object.
+        """
+        if not value:
+            disc = 'list[str]'
+        elif hasattr(value, "_object_type"):
+            disc = value.get_object_type()
+        elif type(value) == list:
+            if hasattr(value[0], "_object_type"):
+                datatype = value[0].get_object_type()
+            else:
+                datatype = type(value[0]).__name__
+            disc = 'list[' + datatype + ']'
+        elif type(value) == dict:
+            if hasattr(next(iter(value.values())), "_object_type"):
+                datatype = next(iter(value.values())).get_object_type()
+            else:
+                datatype = type(next(iter(value.values()))).__name__
+            disc = 'dict(str, ' + datatype + ')'
+        else:
+            disc = type(value).__name__
+        if disc in ListNetworkSecurityPolicyRulesApiResponsedata.discriminator_value_class_map.values():
+            return list(ListNetworkSecurityPolicyRulesApiResponsedata.discriminator_value_class_map.keys())[list(ListNetworkSecurityPolicyRulesApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        return None
+
+
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(NetworkSecurityPolicyImportEntityUpdateType, dict):
+        if issubclass(ListNetworkSecurityPolicyRulesApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -125,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, NetworkSecurityPolicyImportEntityUpdateType):
+        if not isinstance(other, ListNetworkSecurityPolicyRulesApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/NetworkSecurityPolicyImportResponse.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/ListNetworkSecurityPoliciesApiResponse.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_microseg_py_client.models
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.NetworkSecurityPolicyImportResponsedata import NetworkSecurityPolicyImportResponsedata  # noqa: F401,E501
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.ListNetworkSecurityPoliciesApiResponsedata import ListNetworkSecurityPoliciesApiResponsedata  # noqa: F401,E501
 from ntnx_microseg_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class NetworkSecurityPolicyImportResponse(object):
+class ListNetworkSecurityPoliciesApiResponse(object):
 
-    """REST response for all response codes in API path /microseg/v4.0.a1/config/policies/$actions/import Post operation
+    """REST response for all response codes in API path /microseg/v4.0.b1/config/policies Get operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfmicroseg.v4.config.NetworkSecurityPolicyImportResponsedata',
+        'data': 'OneOfmicroseg.v4.config.ListNetworkSecurityPoliciesApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.NetworkSecurityPolicyImportResponse'
+        return 'microseg.v4.config.ListNetworkSecurityPoliciesApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.NetworkSecurityPolicyImportResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -122,16 +123,16 @@
 
     @property
     def data(self):
         """
         
 
         :type:
-                :class:`~ntnx_microseg_py_client.models.prism.v4.config.TaskReference` | 
-                :class:`~ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyImportEntity` | 
+                :class:`~ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicy` | 
+                :class:`~Path` | 
                 :class:`~ntnx_microseg_py_client.models.microseg.v4.error.ErrorResponse`
                     """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
@@ -172,39 +173,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_microseg_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(NetworkSecurityPolicyImportResponse, dict):
+        if issubclass(ListNetworkSecurityPoliciesApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -216,15 +222,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, NetworkSecurityPolicyImportResponse):
+        if not isinstance(other, ListNetworkSecurityPoliciesApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/NetworkSecurityPolicyMigrationCountSummary.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/operation/TotalPolicyCount.py`

 * *Files 16% similar despite different names*

```diff
@@ -3,31 +3,32 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyMigrationTotalCountInfo import NetworkSecurityPolicyMigrationTotalCountInfo  # noqa: F401,E501
-from ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyMigrationTypeCountInfo import NetworkSecurityPolicyMigrationTypeCountInfo  # noqa: F401,E501
+from pathlib import Path
+from ntnx_microseg_py_client.models.microseg.v4.operation.PolicyCount import PolicyCount  # noqa: F401,E501
+from ntnx_microseg_py_client.models.microseg.v4.operation.PolicyCountByType import PolicyCountByType  # noqa: F401,E501
 
-class NetworkSecurityPolicyMigrationCountSummary(object):
+class TotalPolicyCount(object):
 
-    """Cumulative and type based policy counts pre and post Flow migration to FNS 2.0.<br> Contains the summary total policy counts and the policy counts grouped by policy type. 
+    """Cumulative and type based policy counts pre and post Flow upgrade to FNS Next-Gen.<br> Contains the summary total policy counts and the policy counts grouped by policy type. 
 
     :param total_counts_summary: (:attr:`total_counts_summary`) 
     :type total_counts_summary: required
     :param policy_type_counts_summary: (:attr:`policy_type_counts_summary`) 
     :type policy_type_counts_summary: 
 
     """
@@ -37,16 +38,16 @@
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'total_counts_summary': 'microseg.v4.config.NetworkSecurityPolicyMigrationTotalCountInfo',
-        'policy_type_counts_summary': 'list[microseg.v4.config.NetworkSecurityPolicyMigrationTypeCountInfo]',
+        'total_counts_summary': 'microseg.v4.operation.PolicyCount',
+        'policy_type_counts_summary': 'list[microseg.v4.operation.PolicyCountByType]',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'total_counts_summary': 'totalCountsSummary',
@@ -65,35 +66,35 @@
         self.__total_counts_summary = total_counts_summary
         if policy_type_counts_summary is not None:
             self.__policy_type_counts_summary = policy_type_counts_summary
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.NetworkSecurityPolicyMigrationCountSummary'
+        return 'microseg.v4.operation.TotalPolicyCount'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.NetworkSecurityPolicyMigrationCountSummary'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -105,15 +106,15 @@
 
     @property
     def total_counts_summary(self):
         """
         
 
         :type:
-            :class:`~ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyMigrationTotalCountInfo`
+            :class:`~ntnx_microseg_py_client.models.microseg.v4.operation.PolicyCount`
         """  # noqa: E501
         return self.__total_counts_summary
 
     @total_counts_summary.setter
     def total_counts_summary(self, total_counts_summary):
         if total_counts_summary is None:
             raise ValueError("Invalid value for `total_counts_summary`, must not be `None`")  # noqa: E501
@@ -122,15 +123,15 @@
 
     @property
     def policy_type_counts_summary(self):
         """
         
 
         :type:
-             list[ :class:`~ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyMigrationTypeCountInfo` ]
+             list[ :class:`~ntnx_microseg_py_client.models.microseg.v4.operation.PolicyCountByType` ]
         """  # noqa: E501
         return self.__policy_type_counts_summary
 
     @policy_type_counts_summary.setter
     def policy_type_counts_summary(self, policy_type_counts_summary):
 
         self.__policy_type_counts_summary = policy_type_counts_summary
@@ -170,37 +171,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(NetworkSecurityPolicyMigrationCountSummary, dict):
+        if issubclass(TotalPolicyCount, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -212,15 +218,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, NetworkSecurityPolicyMigrationCountSummary):
+        if not isinstance(other, TotalPolicyCount):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/NetworkSecurityPolicyMigrationMetadata.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/operation/PolicyMetadata.py`

 * *Files 15% similar despite different names*

```diff
@@ -3,139 +3,141 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_microseg_py_client.models.microseg.v4.config.ConfigMigrationPolicyOptions import ConfigMigrationPolicyOptions  # noqa: F401,E501
-from ntnx_microseg_py_client.models.microseg.v4.config.ConfigMigrationPolicyType import ConfigMigrationPolicyType  # noqa: F401,E501
-from ntnx_microseg_py_client.models.microseg.v4.config.PolicyState import PolicyState  # noqa: F401,E501
+from pathlib import Path
+from ntnx_microseg_py_client.models.microseg.v4.config.SecurityPolicyState import SecurityPolicyState  # noqa: F401,E501
+from ntnx_microseg_py_client.models.microseg.v4.operation.SecurityPolicyOptions import SecurityPolicyOptions  # noqa: F401,E501
+from ntnx_microseg_py_client.models.microseg.v4.operation.SecurityPolicyType import SecurityPolicyType  # noqa: F401,E501
 
-class NetworkSecurityPolicyMigrationMetadata(object):
+class PolicyMetadata(object):
 
-    """The meta information about a Flow Network Security Policy.<br> The info captures the secured Categories, state of policy, policy type, last modified time, previewId and options.<br> The PreviewId can be used to fetch the complete FNS 2.0 policy preview using Preview GET API.<br> A sample call would look like ``` /microseg/v4.0.a1/flow-migrator/preview/8f094d6c-d7b2-32c2-8223-462c6c5e06db ``` 
+    """The meta information about a Flow Network Security Policy.<br> The info captures the secured Categories, state of policy, policy type, last modified time, previewId and options.<br> The PreviewId can be used to fetch the complete FNS Next-Gen policy preview using Preview GET API.<br> A sample call would look like ``` /microseg/v4.0.a1/operation/policy-preview/8f094d6c-d7b2-32c2-8223-462c6c5e06db ``` 
 
-    :param description: (:attr:`description`) A user defined annotation for a policy metadata during migration.
+    :param description: (:attr:`description`) A user defined annotation for a policy metadata during upgrade.
     :type description: 
-    :param secured_group_category_uuids: (:attr:`secured_group_category_uuids`) List of categories external IDs being secured by the Flow Network Security Policy.
-    :type secured_group_category_uuids: required
+    :param secured_group_category_references: (:attr:`secured_group_category_references`) List of categories external IDs being secured by the Flow Network Security Policy.
+    :type secured_group_category_references: 
     :param state: (:attr:`state`) 
     :type state: required
-    :param last_update_time: (:attr:`last_update_time`) 
+    :param last_update_time: (:attr:`last_update_time`) Last update time for the network security policy.
     :type last_update_time: 
     :param type: (:attr:`type`) 
     :type type: 
-    :param preview_id: (:attr:`preview_id`) This is a system generated identifier which can be used to preview the complete FNS 2.0 policy corresponding with a FNS 1.0 policy using Preview GET API. A sample call would look like ``` /microseg/v4.0.a1/flow-migrator/preview/8f094d6c-d7b2-32c2-8223-462c6c5e06db ``` 
-    :type preview_id: 
+    :param preview_reference: (:attr:`preview_reference`) This is a system generated identifier which can be used to preview the complete FNS Next-Gen policy corresponding with a FNS policy using Preview GET API. A sample call would look like ``` /microseg/v4.0.a1/operation/policy-preview/8f094d6c-d7b2-32c2-8223-462c6c5e06db ``` 
+    :type preview_reference: 
     :param options: (:attr:`options`) 
     :type options: 
-    :param name: (:attr:`name`) 
+    :param name: (:attr:`name`) Name of the network security policy.
     :type name: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'description': 'str',
-        'secured_group_category_uuids': 'list[str]',
-        'state': 'microseg.v4.config.PolicyState',
+        'secured_group_category_references': 'list[str]',
+        'state': 'microseg.v4.config.SecurityPolicyState',
         'last_update_time': 'datetime',
-        'type': 'microseg.v4.config.ConfigMigrationPolicyType',
-        'preview_id': 'str',
-        'options': 'microseg.v4.config.ConfigMigrationPolicyOptions',
+        'type': 'microseg.v4.operation.SecurityPolicyType',
+        'preview_reference': 'str',
+        'options': 'microseg.v4.operation.SecurityPolicyOptions',
         'name': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'description': 'description',
-        'secured_group_category_uuids': 'securedGroupCategoryUuids',
+        'secured_group_category_references': 'securedGroupCategoryReferences',
         'state': 'state',
         'last_update_time': 'lastUpdateTime',
         'type': 'type',
-        'preview_id': 'previewId',
+        'preview_reference': 'previewReference',
         'options': 'options',
         'name': 'name',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, description=None, secured_group_category_uuids=None, state=None, last_update_time=None, type=None, preview_id=None, options=None, name=None, *args, **kwargs):  # noqa: E501
+    def __init__(self, description=None, secured_group_category_references=None, state=None, last_update_time=None, type=None, preview_reference=None, options=None, name=None, *args, **kwargs):  # noqa: E501
         self.__description = None
-        self.__secured_group_category_uuids = None
+        self.__secured_group_category_references = None
         self.__state = None
         self.__last_update_time = None
         self.__type = None
-        self.__preview_id = None
+        self.__preview_reference = None
         self.__options = None
         self.__name = None
         self.discriminator = None
         if description is not None:
             self.__description = description
-        self.__secured_group_category_uuids = secured_group_category_uuids
+        if secured_group_category_references is not None:
+            self.__secured_group_category_references = secured_group_category_references
         self.__state = state
         if last_update_time is not None:
             self.__last_update_time = last_update_time
         if type is not None:
             self.__type = type
-        if preview_id is not None:
-            self.__preview_id = preview_id
+        if preview_reference is not None:
+            self.__preview_reference = preview_reference
         if options is not None:
             self.__options = options
         if name is not None:
             self.__name = name
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.NetworkSecurityPolicyMigrationMetadata'
+        return 'microseg.v4.operation.PolicyMetadata'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.NetworkSecurityPolicyMigrationMetadata'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -144,15 +146,15 @@
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def description(self):
         """
-        A user defined annotation for a policy metadata during migration.
+        A user defined annotation for a policy metadata during upgrade.
 
         :type:
 
                 :class:`~str`
         """  # noqa: E501
         return self.__description
 
@@ -160,51 +162,49 @@
     def description(self, description):
         if description is not None and len(description) > 512:
             raise ValueError("Invalid value for `description`, length must be less than or equal to `512`")  # noqa: E501
 
         self.__description = description
 
     @property
-    def secured_group_category_uuids(self):
+    def secured_group_category_references(self):
         """
         List of categories external IDs being secured by the Flow Network Security Policy.
 
         :type:
             list[ :class:`~str` ]
         """  # noqa: E501
-        return self.__secured_group_category_uuids
+        return self.__secured_group_category_references
 
-    @secured_group_category_uuids.setter
-    def secured_group_category_uuids(self, secured_group_category_uuids):
-        if secured_group_category_uuids is None:
-            raise ValueError("Invalid value for `secured_group_category_uuids`, must not be `None`")  # noqa: E501
+    @secured_group_category_references.setter
+    def secured_group_category_references(self, secured_group_category_references):
 
-        self.__secured_group_category_uuids = secured_group_category_uuids
+        self.__secured_group_category_references = secured_group_category_references
 
     @property
     def state(self):
         """
         
 
         :type:
-            :class:`~ntnx_microseg_py_client.models.microseg.v4.config.PolicyState`
+            :class:`~ntnx_microseg_py_client.models.microseg.v4.config.SecurityPolicyState`
         """  # noqa: E501
         return self.__state
 
     @state.setter
     def state(self, state):
         if state is None:
             raise ValueError("Invalid value for `state`, must not be `None`")  # noqa: E501
 
         self.__state = state
 
     @property
     def last_update_time(self):
         """
-        
+        Last update time for the network security policy.
 
         :type:
 
                 :class:`~datetime`
         """  # noqa: E501
         return self.__last_update_time
 
@@ -215,60 +215,60 @@
 
     @property
     def type(self):
         """
         
 
         :type:
-            :class:`~ntnx_microseg_py_client.models.microseg.v4.config.ConfigMigrationPolicyType`
+            :class:`~ntnx_microseg_py_client.models.microseg.v4.operation.SecurityPolicyType`
         """  # noqa: E501
         return self.__type
 
     @type.setter
     def type(self, type):
 
         self.__type = type
 
     @property
-    def preview_id(self):
+    def preview_reference(self):
         """
-        This is a system generated identifier which can be used to preview the complete FNS 2.0 policy corresponding with a FNS 1.0 policy using Preview GET API. A sample call would look like ``` /microseg/v4.0.a1/flow-migrator/preview/8f094d6c-d7b2-32c2-8223-462c6c5e06db ``` 
+        This is a system generated identifier which can be used to preview the complete FNS Next-Gen policy corresponding with a FNS policy using Preview GET API. A sample call would look like ``` /microseg/v4.0.a1/operation/policy-preview/8f094d6c-d7b2-32c2-8223-462c6c5e06db ``` 
 
         :type:
 
                 :class:`~str`
         """  # noqa: E501
-        return self.__preview_id
+        return self.__preview_reference
 
-    @preview_id.setter
-    def preview_id(self, preview_id):
-        if preview_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', preview_id):  # noqa: E501
-            raise ValueError(r"Invalid value for `preview_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
+    @preview_reference.setter
+    def preview_reference(self, preview_reference):
+        if preview_reference is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', preview_reference):  # noqa: E501
+            raise ValueError(r"Invalid value for `preview_reference`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
 
-        self.__preview_id = preview_id
+        self.__preview_reference = preview_reference
 
     @property
     def options(self):
         """
         
 
         :type:
-            :class:`~ntnx_microseg_py_client.models.microseg.v4.config.ConfigMigrationPolicyOptions`
+            :class:`~ntnx_microseg_py_client.models.microseg.v4.operation.SecurityPolicyOptions`
         """  # noqa: E501
         return self.__options
 
     @options.setter
     def options(self, options):
 
         self.__options = options
 
     @property
     def name(self):
         """
-        
+        Name of the network security policy.
 
         :type:
 
                 :class:`~str`
         """  # noqa: E501
         return self.__name
 
@@ -312,37 +312,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(NetworkSecurityPolicyMigrationMetadata, dict):
+        if issubclass(PolicyMetadata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -354,15 +359,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, NetworkSecurityPolicyMigrationMetadata):
+        if not isinstance(other, PolicyMetadata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/NetworkSecurityPolicyMigrationSubnetSummary.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/TcpPortRangeSpec.py`

 * *Files 16% similar despite different names*

```diff
@@ -3,167 +3,151 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class NetworkSecurityPolicyMigrationSubnetSummary(object):
+class TcpPortRangeSpec(object):
 
-    """Subnet information to be communicated for subnet migration as part of Flow migration to FNS 2.0.<br> The info includes vlanID, vlanName and subnetUuid. 
+    """Range of TCP/UDP ports.
 
-    :param vlan_name: (:attr:`vlan_name`) 
-    :type vlan_name: 
-    :param vlan_id: (:attr:`vlan_id`) 
-    :type vlan_id: required
-    :param subnet_uuid: (:attr:`subnet_uuid`) 
-    :type subnet_uuid: required
+    :param start_port: (:attr:`start_port`) 
+    :type start_port: required
+    :param end_port: (:attr:`end_port`) 
+    :type end_port: required
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'vlan_name': 'str',
-        'vlan_id': 'int',
-        'subnet_uuid': 'str',
+        'start_port': 'int',
+        'end_port': 'int',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'vlan_name': 'vlanName',
-        'vlan_id': 'vlanID',
-        'subnet_uuid': 'subnetUuid',
+        'start_port': 'startPort',
+        'end_port': 'endPort',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, vlan_name=None, vlan_id=None, subnet_uuid=None, *args, **kwargs):  # noqa: E501
-        self.__vlan_name = None
-        self.__vlan_id = None
-        self.__subnet_uuid = None
+    def __init__(self, start_port=None, end_port=None, *args, **kwargs):  # noqa: E501
+        self.__start_port = None
+        self.__end_port = None
         self.discriminator = None
-        if vlan_name is not None:
-            self.__vlan_name = vlan_name
-        self.__vlan_id = vlan_id
-        self.__subnet_uuid = subnet_uuid
+        self.__start_port = start_port
+        self.__end_port = end_port
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.NetworkSecurityPolicyMigrationSubnetSummary'
+        return 'microseg.v4.config.TcpPortRangeSpec'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.NetworkSecurityPolicyMigrationSubnetSummary'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def vlan_name(self):
-        """
-        
-
-        :type:
-
-                :class:`~str`
-        """  # noqa: E501
-        return self.__vlan_name
-
-    @vlan_name.setter
-    def vlan_name(self, vlan_name):
-
-        self.__vlan_name = vlan_name
-
-    @property
-    def vlan_id(self):
+    def start_port(self):
         """
         
 
         :type:
 
                 :class:`~int`
         """  # noqa: E501
-        return self.__vlan_id
+        return self.__start_port
 
-    @vlan_id.setter
-    def vlan_id(self, vlan_id):
-        if vlan_id is None:
-            raise ValueError("Invalid value for `vlan_id`, must not be `None`")  # noqa: E501
+    @start_port.setter
+    def start_port(self, start_port):
+        if start_port is None:
+            raise ValueError("Invalid value for `start_port`, must not be `None`")  # noqa: E501
+        if start_port is not None and start_port > 65535:  # noqa: E501
+            raise ValueError("Invalid value for `start_port`, must be a value less than or equal to `65535`")  # noqa: E501
+        if start_port is not None and start_port < 0:  # noqa: E501
+            raise ValueError("Invalid value for `start_port`, must be a value greater than or equal to `0`")  # noqa: E501
 
-        self.__vlan_id = vlan_id
+        self.__start_port = start_port
 
     @property
-    def subnet_uuid(self):
+    def end_port(self):
         """
         
 
         :type:
 
-                :class:`~str`
+                :class:`~int`
         """  # noqa: E501
-        return self.__subnet_uuid
+        return self.__end_port
 
-    @subnet_uuid.setter
-    def subnet_uuid(self, subnet_uuid):
-        if subnet_uuid is None:
-            raise ValueError("Invalid value for `subnet_uuid`, must not be `None`")  # noqa: E501
-        if subnet_uuid is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', subnet_uuid):  # noqa: E501
-            raise ValueError(r"Invalid value for `subnet_uuid`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
+    @end_port.setter
+    def end_port(self, end_port):
+        if end_port is None:
+            raise ValueError("Invalid value for `end_port`, must not be `None`")  # noqa: E501
+        if end_port is not None and end_port > 65535:  # noqa: E501
+            raise ValueError("Invalid value for `end_port`, must be a value less than or equal to `65535`")  # noqa: E501
+        if end_port is not None and end_port < 0:  # noqa: E501
+            raise ValueError("Invalid value for `end_port`, must be a value greater than or equal to `0`")  # noqa: E501
 
-        self.__subnet_uuid = subnet_uuid
+        self.__end_port = end_port
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -196,37 +180,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(NetworkSecurityPolicyMigrationSubnetSummary, dict):
+        if issubclass(TcpPortRangeSpec, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -238,15 +227,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, NetworkSecurityPolicyMigrationSubnetSummary):
+        if not isinstance(other, TcpPortRangeSpec):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/NetworkSecurityPolicyMigrationSummary.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/operation/PolicyUpgradeSummary.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,52 +3,53 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyMigrationMetadata import NetworkSecurityPolicyMigrationMetadata  # noqa: F401,E501
+from pathlib import Path
+from ntnx_microseg_py_client.models.microseg.v4.operation.PolicyMetadata import PolicyMetadata  # noqa: F401,E501
 
-class NetworkSecurityPolicyMigrationSummary(object):
+class PolicyUpgradeSummary(object):
 
-    """Specifies the policy name along with the policy metadata.<br> For cases where a single FNS 1.0 policy conversion results in multiple FNS 2.0 policies, it also contains a list of policy metadata corresponding to those system generated policies. 
+    """Specifies the policy name along with the policy metadata.<br> For cases where a single FNS policy conversion results in multiple FNS Next-Gen policies, it also contains a list of policy metadata corresponding to those system generated policies. 
 
     :param policy_name: (:attr:`policy_name`) Name of the Flow Network Security Policy.<br> It can have a maximum length of 63 characters. 
     :type policy_name: required
     :param policy_metadata: (:attr:`policy_metadata`) 
     :type policy_metadata: required
-    :param system_gen_policy_metadata: (:attr:`system_gen_policy_metadata`) A list of Policy metadata of system generated isolation policies that would get created as part of a successful Flow migration. 
+    :param system_gen_policy_metadata: (:attr:`system_gen_policy_metadata`) A list of Policy metadata of system generated isolation policies that would get created as part of a successful Flow upgrade. 
     :type system_gen_policy_metadata: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'policy_name': 'str',
-        'policy_metadata': 'microseg.v4.config.NetworkSecurityPolicyMigrationMetadata',
-        'system_gen_policy_metadata': 'list[microseg.v4.config.NetworkSecurityPolicyMigrationMetadata]',
+        'policy_metadata': 'microseg.v4.operation.PolicyMetadata',
+        'system_gen_policy_metadata': 'list[microseg.v4.operation.PolicyMetadata]',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'policy_name': 'policyName',
@@ -70,35 +71,35 @@
         self.__policy_metadata = policy_metadata
         if system_gen_policy_metadata is not None:
             self.__system_gen_policy_metadata = system_gen_policy_metadata
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.NetworkSecurityPolicyMigrationSummary'
+        return 'microseg.v4.operation.PolicyUpgradeSummary'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.NetworkSecurityPolicyMigrationSummary'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -119,41 +120,43 @@
         """  # noqa: E501
         return self.__policy_name
 
     @policy_name.setter
     def policy_name(self, policy_name):
         if policy_name is None:
             raise ValueError("Invalid value for `policy_name`, must not be `None`")  # noqa: E501
+        if policy_name is not None and len(policy_name) > 63:
+            raise ValueError("Invalid value for `policy_name`, length must be less than or equal to `63`")  # noqa: E501
 
         self.__policy_name = policy_name
 
     @property
     def policy_metadata(self):
         """
         
 
         :type:
-            :class:`~ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyMigrationMetadata`
+            :class:`~ntnx_microseg_py_client.models.microseg.v4.operation.PolicyMetadata`
         """  # noqa: E501
         return self.__policy_metadata
 
     @policy_metadata.setter
     def policy_metadata(self, policy_metadata):
         if policy_metadata is None:
             raise ValueError("Invalid value for `policy_metadata`, must not be `None`")  # noqa: E501
 
         self.__policy_metadata = policy_metadata
 
     @property
     def system_gen_policy_metadata(self):
         """
-        A list of Policy metadata of system generated isolation policies that would get created as part of a successful Flow migration. 
+        A list of Policy metadata of system generated isolation policies that would get created as part of a successful Flow upgrade. 
 
         :type:
-             list[ :class:`~ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyMigrationMetadata` ]
+             list[ :class:`~ntnx_microseg_py_client.models.microseg.v4.operation.PolicyMetadata` ]
         """  # noqa: E501
         return self.__system_gen_policy_metadata
 
     @system_gen_policy_metadata.setter
     def system_gen_policy_metadata(self, system_gen_policy_metadata):
 
         self.__system_gen_policy_metadata = system_gen_policy_metadata
@@ -193,37 +196,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(NetworkSecurityPolicyMigrationSummary, dict):
+        if issubclass(PolicyUpgradeSummary, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -235,15 +243,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, NetworkSecurityPolicyMigrationSummary):
+        if not isinstance(other, PolicyUpgradeSummary):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/NetworkSecurityPolicyMigrationSummaryFailures.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/UpdateAddressGroupApiResponse.py`

 * *Files 18% similar despite different names*

```diff
@@ -3,140 +3,143 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-
-class NetworkSecurityPolicyMigrationSummaryFailures(object):
-
-    """Outlines the error code and description of failure during summarising the migration.
-
-    :param error_code: (:attr:`error_code`) 
-    :type error_code: 
-    :param error_description: (:attr:`error_description`) 
-    :type error_description: 
+from pathlib import Path
+import ntnx_microseg_py_client.models
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.UpdateAddressGroupApiResponsedata import UpdateAddressGroupApiResponsedata  # noqa: F401,E501
+from ntnx_microseg_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class UpdateAddressGroupApiResponse(object):
+
+    """REST response for all response codes in API path /microseg/v4.0.b1/config/address-groups/{extId} Put operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'error_code': 'str',
-        'error_description': 'str',
+        'metadata': 'common.v1.response.ApiResponseMetadata',
+        'data': 'OneOfmicroseg.v4.config.UpdateAddressGroupApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'error_code': 'errorCode',
-        'error_description': 'errorDescription',
+        'metadata': 'metadata',
+        'data': 'data',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, error_code=None, error_description=None, *args, **kwargs):  # noqa: E501
-        self.__error_code = None
-        self.__error_description = None
+    def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
+        self.__metadata = None
+        self.__data = None
         self.discriminator = None
-        if error_code is not None:
-            self.__error_code = error_code
-        if error_description is not None:
-            self.__error_description = error_description
+        if metadata is not None:
+            self.__metadata = metadata
+        if data is not None:
+            self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.NetworkSecurityPolicyMigrationSummaryFailures'
+        return 'microseg.v4.config.UpdateAddressGroupApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.NetworkSecurityPolicyMigrationSummaryFailures'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def error_code(self):
+    def metadata(self):
         """
         
 
         :type:
-
-                :class:`~str`
+            :class:`~ntnx_microseg_py_client.models.common.v1.response.ApiResponseMetadata`
         """  # noqa: E501
-        return self.__error_code
+        return self.__metadata
 
-    @error_code.setter
-    def error_code(self, error_code):
+    @metadata.setter
+    def metadata(self, metadata):
 
-        self.__error_code = error_code
+        self.__metadata = metadata
 
     @property
-    def error_description(self):
+    def data(self):
         """
         
 
         :type:
+                :class:`~ntnx_microseg_py_client.models.prism.v4.config.TaskReference` | 
+                :class:`~ntnx_microseg_py_client.models.microseg.v4.error.ErrorResponse`
+                    """  # noqa: E501
+        return self.__data
 
-                :class:`~str`
-        """  # noqa: E501
-        return self.__error_description
-
-    @error_description.setter
-    def error_description(self, error_description):
+    @data.setter
+    def data(self, data):
 
-        self.__error_description = error_description
+        self.__data = data
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -169,37 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
+            if attr_type.startswith('OneOf'):
+                type = getattr(ntnx_microseg_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(NetworkSecurityPolicyMigrationSummaryFailures, dict):
+        if issubclass(UpdateAddressGroupApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -211,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, NetworkSecurityPolicyMigrationSummaryFailures):
+        if not isinstance(other, UpdateAddressGroupApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/NetworkSecurityPolicyMigrationTotalCountInfo.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/operation/PolicyCount.py`

 * *Files 11% similar despite different names*

```diff
@@ -3,35 +3,36 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class NetworkSecurityPolicyMigrationTotalCountInfo(object):
+class PolicyCount(object):
 
-    """Cumulative Policy counts pre and post Flow migration to FNS 2.0. Contains total count of FNS 2.0 policies that'll be created post successful migration, total count of FNS 1.0 policies before migration and the total count of FNS 2.0 policies which were system generated as a result of FNS 1.0 to FNS 2.0 conversion.<br> 
+    """Cumulative Policy counts pre and post Flow upgrade to FNS Next-Gen. Contains total count of FNS Next-Gen policies that'll be created post successful upgrade, total count of FNS policies before upgrade and the total count of FNS Next-Gen policies which were system generated as a result of FNS to FNS Next-Gen conversion.<br> 
 
-    :param new_policies_count: (:attr:`new_policies_count`) 
+    :param new_policies_count: (:attr:`new_policies_count`) Number of policies after the upgrade.
     :type new_policies_count: required
-    :param old_policies_count: (:attr:`old_policies_count`) 
+    :param old_policies_count: (:attr:`old_policies_count`) Number of policies before the migration.
     :type old_policies_count: required
-    :param system_defined_policies_count: (:attr:`system_defined_policies_count`) Count of isolation policies that would be genrated post migration to FNS 2.0.
+    :param system_defined_policies_count: (:attr:`system_defined_policies_count`) Count of isolation policies that would be generated post upgrade to FNS Next-Gen.
     :type system_defined_policies_count: required
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
@@ -68,35 +69,35 @@
         self.__new_policies_count = new_policies_count
         self.__old_policies_count = old_policies_count
         self.__system_defined_policies_count = system_defined_policies_count
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.NetworkSecurityPolicyMigrationTotalCountInfo'
+        return 'microseg.v4.operation.PolicyCount'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.NetworkSecurityPolicyMigrationTotalCountInfo'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -105,15 +106,15 @@
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def new_policies_count(self):
         """
-        
+        Number of policies after the upgrade.
 
         :type:
 
                 :class:`~int`
         """  # noqa: E501
         return self.__new_policies_count
 
@@ -123,15 +124,15 @@
             raise ValueError("Invalid value for `new_policies_count`, must not be `None`")  # noqa: E501
 
         self.__new_policies_count = new_policies_count
 
     @property
     def old_policies_count(self):
         """
-        
+        Number of policies before the migration.
 
         :type:
 
                 :class:`~int`
         """  # noqa: E501
         return self.__old_policies_count
 
@@ -141,15 +142,15 @@
             raise ValueError("Invalid value for `old_policies_count`, must not be `None`")  # noqa: E501
 
         self.__old_policies_count = old_policies_count
 
     @property
     def system_defined_policies_count(self):
         """
-        Count of isolation policies that would be genrated post migration to FNS 2.0.
+        Count of isolation policies that would be generated post upgrade to FNS Next-Gen.
 
         :type:
 
                 :class:`~int`
         """  # noqa: E501
         return self.__system_defined_policies_count
 
@@ -195,37 +196,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(NetworkSecurityPolicyMigrationTotalCountInfo, dict):
+        if issubclass(PolicyCount, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -237,15 +243,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, NetworkSecurityPolicyMigrationTotalCountInfo):
+        if not isinstance(other, PolicyCount):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/NetworkSecurityPolicyMigrationTypeCountInfo.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/ListNetworkSecurityPolicyRulesApiResponse.py`

 * *Files 14% similar despite different names*

```diff
@@ -3,140 +3,143 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_microseg_py_client.models.microseg.v4.config.ConfigMigrationPolicyType import ConfigMigrationPolicyType  # noqa: F401,E501
-from ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyMigrationTotalCountInfo import NetworkSecurityPolicyMigrationTotalCountInfo  # noqa: F401,E501
-
-class NetworkSecurityPolicyMigrationTypeCountInfo(object):
-
-    """Policy type based counts pre and post Flow migration to FNS 2.0.<br> This will be grouped by policy types which can be one of following four types:   - QUARANTINE POLICY   - ISOLATION POLICY   - APPLICATION POLICY   - AD POLICY 
-
-    :param type: (:attr:`type`) 
-    :type type: 
-    :param count_summary: (:attr:`count_summary`) 
-    :type count_summary: 
+from pathlib import Path
+import ntnx_microseg_py_client.models
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.ListNetworkSecurityPolicyRulesApiResponsedata import ListNetworkSecurityPolicyRulesApiResponsedata  # noqa: F401,E501
+from ntnx_microseg_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class ListNetworkSecurityPolicyRulesApiResponse(object):
+
+    """REST response for all response codes in API path /microseg/v4.0.b1/config/policies/{extId}/rules Get operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'type': 'microseg.v4.config.ConfigMigrationPolicyType',
-        'count_summary': 'microseg.v4.config.NetworkSecurityPolicyMigrationTotalCountInfo',
+        'metadata': 'common.v1.response.ApiResponseMetadata',
+        'data': 'OneOfmicroseg.v4.config.ListNetworkSecurityPolicyRulesApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'type': 'type',
-        'count_summary': 'countSummary',
+        'metadata': 'metadata',
+        'data': 'data',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, type=None, count_summary=None, *args, **kwargs):  # noqa: E501
-        self.__type = None
-        self.__count_summary = None
+    def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
+        self.__metadata = None
+        self.__data = None
         self.discriminator = None
-        if type is not None:
-            self.__type = type
-        if count_summary is not None:
-            self.__count_summary = count_summary
+        if metadata is not None:
+            self.__metadata = metadata
+        if data is not None:
+            self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.NetworkSecurityPolicyMigrationTypeCountInfo'
+        return 'microseg.v4.config.ListNetworkSecurityPolicyRulesApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.NetworkSecurityPolicyMigrationTypeCountInfo'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def type(self):
+    def metadata(self):
         """
         
 
         :type:
-            :class:`~ntnx_microseg_py_client.models.microseg.v4.config.ConfigMigrationPolicyType`
+            :class:`~ntnx_microseg_py_client.models.common.v1.response.ApiResponseMetadata`
         """  # noqa: E501
-        return self.__type
+        return self.__metadata
 
-    @type.setter
-    def type(self, type):
+    @metadata.setter
+    def metadata(self, metadata):
 
-        self.__type = type
+        self.__metadata = metadata
 
     @property
-    def count_summary(self):
+    def data(self):
         """
         
 
         :type:
-            :class:`~ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyMigrationTotalCountInfo`
-        """  # noqa: E501
-        return self.__count_summary
+                :class:`~ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyRule` | 
+                :class:`~ntnx_microseg_py_client.models.microseg.v4.error.ErrorResponse`
+                    """  # noqa: E501
+        return self.__data
 
-    @count_summary.setter
-    def count_summary(self, count_summary):
+    @data.setter
+    def data(self, data):
 
-        self.__count_summary = count_summary
+        self.__data = data
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -169,37 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
+            if attr_type.startswith('OneOf'):
+                type = getattr(ntnx_microseg_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(NetworkSecurityPolicyMigrationTypeCountInfo, dict):
+        if issubclass(ListNetworkSecurityPolicyRulesApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -211,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, NetworkSecurityPolicyMigrationTypeCountInfo):
+        if not isinstance(other, ListNetworkSecurityPolicyRulesApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/NetworkSecurityPolicyRule.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/common/v1/config/IPAddressOrFQDN.py`

 * *Files 16% similar despite different names*

```diff
@@ -3,195 +3,164 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_microseg_py_client.models
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.NetworkSecurityPolicyRulespec import NetworkSecurityPolicyRulespec  # noqa: F401,E501
-from ntnx_microseg_py_client.models.microseg.v4.config.RuleType import RuleType  # noqa: F401,E501
-
-class NetworkSecurityPolicyRule(object):
-
-    """
-
-    :param id: (:attr:`id`) Rule UUID; should be used to identify an individual rule uniquely.
-    :type id: 
-    :param description: (:attr:`description`) A user defined annotation for a rule.
-    :type description: 
-    :param type: (:attr:`type`) 
-    :type type: required
-    :param spec: (:attr:`spec`) 
-    :type spec: required
+from pathlib import Path
+from ntnx_microseg_py_client.models.common.v1.config.FQDN import FQDN  # noqa: F401,E501
+from ntnx_microseg_py_client.models.common.v1.config.IPv4Address import IPv4Address  # noqa: F401,E501
+from ntnx_microseg_py_client.models.common.v1.config.IPv6Address import IPv6Address  # noqa: F401,E501
+
+class IPAddressOrFQDN(object):
+
+    """An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format or a Fully Qualified Domain Name. 
+
+    :param ipv4: (:attr:`ipv4`) 
+    :type ipv4: 
+    :param ipv6: (:attr:`ipv6`) 
+    :type ipv6: 
+    :param fqdn: (:attr:`fqdn`) 
+    :type fqdn: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'id': 'str',
-        'description': 'str',
-        'type': 'microseg.v4.config.RuleType',
-        'spec': 'OneOfmicroseg.v4.config.NetworkSecurityPolicyRulespec',
+        'ipv4': 'common.v1.config.IPv4Address',
+        'ipv6': 'common.v1.config.IPv6Address',
+        'fqdn': 'common.v1.config.FQDN',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'id': 'id',
-        'description': 'description',
-        'type': 'type',
-        'spec': 'spec',
+        'ipv4': 'ipv4',
+        'ipv6': 'ipv6',
+        'fqdn': 'fqdn',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, id=None, description=None, type=None, spec=None, *args, **kwargs):  # noqa: E501
-        self.__id = None
-        self.__description = None
-        self.__type = None
-        self.__spec = None
+    def __init__(self, ipv4=None, ipv6=None, fqdn=None, *args, **kwargs):  # noqa: E501
+        self.__ipv4 = None
+        self.__ipv6 = None
+        self.__fqdn = None
         self.discriminator = None
-        if id is not None:
-            self.__id = id
-        if description is not None:
-            self.__description = description
-        self.__type = type
-        self.__spec = spec
+        if ipv4 is not None:
+            self.__ipv4 = ipv4
+        if ipv6 is not None:
+            self.__ipv6 = ipv6
+        if fqdn is not None:
+            self.__fqdn = fqdn
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.NetworkSecurityPolicyRule'
+        return 'common.v1.config.IPAddressOrFQDN'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.NetworkSecurityPolicyRule'
+    def _initialize_object_version(self):
+        return 'v1.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def id(self):
+    def ipv4(self):
         """
-        Rule UUID; should be used to identify an individual rule uniquely.
+        
 
         :type:
-
-                :class:`~str`
+            :class:`~ntnx_microseg_py_client.models.common.v1.config.IPv4Address`
         """  # noqa: E501
-        return self.__id
+        return self.__ipv4
 
-    @id.setter
-    def id(self, id):
-        if id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', id):  # noqa: E501
-            raise ValueError(r"Invalid value for `id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
+    @ipv4.setter
+    def ipv4(self, ipv4):
 
-        self.__id = id
+        self.__ipv4 = ipv4
 
     @property
-    def description(self):
+    def ipv6(self):
         """
-        A user defined annotation for a rule.
+        
 
         :type:
-
-                :class:`~str`
+            :class:`~ntnx_microseg_py_client.models.common.v1.config.IPv6Address`
         """  # noqa: E501
-        return self.__description
+        return self.__ipv6
 
-    @description.setter
-    def description(self, description):
-        if description is not None and len(description) > 64:
-            raise ValueError("Invalid value for `description`, length must be less than or equal to `64`")  # noqa: E501
+    @ipv6.setter
+    def ipv6(self, ipv6):
 
-        self.__description = description
+        self.__ipv6 = ipv6
 
     @property
-    def type(self):
+    def fqdn(self):
         """
         
 
         :type:
-            :class:`~ntnx_microseg_py_client.models.microseg.v4.config.RuleType`
+            :class:`~ntnx_microseg_py_client.models.common.v1.config.FQDN`
         """  # noqa: E501
-        return self.__type
+        return self.__fqdn
 
-    @type.setter
-    def type(self, type):
-        if type is None:
-            raise ValueError("Invalid value for `type`, must not be `None`")  # noqa: E501
+    @fqdn.setter
+    def fqdn(self, fqdn):
 
-        self.__type = type
-
-    @property
-    def spec(self):
-        """
-        
-
-        :type:
-                :class:`~ntnx_microseg_py_client.models.microseg.v4.config.NSPTwoEnvIsolationRuleSpec` | 
-                :class:`~ntnx_microseg_py_client.models.microseg.v4.config.NSPApplicationRuleSpec` | 
-                :class:`~ntnx_microseg_py_client.models.microseg.v4.config.NSPIntraEntityGroupRuleSpec`
-                    """  # noqa: E501
-        return self.__spec
-
-    @spec.setter
-    def spec(self, spec):
-        if spec is None:
-            raise ValueError("Invalid value for `spec`, must not be `None`")  # noqa: E501
-
-        self.__spec = spec
+        self.__fqdn = fqdn
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -224,39 +193,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
-            if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_microseg_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(NetworkSecurityPolicyRule, dict):
+        if issubclass(IPAddressOrFQDN, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -268,16 +240,28 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, NetworkSecurityPolicyRule):
+        if not isinstance(other, IPAddressOrFQDN):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
 
+    def has_ipv4(self):
+        """Returns true if `ipv4` has non-none value"""
+        return self._ipv4 is None
+    def has_ipv6(self):
+        """Returns true if `ipv6` has non-none value"""
+        return self._ipv6 is None
+    def has_fqdn(self):
+        """Returns true if `fqdn` has non-none value"""
+        return self._fqdn is None
+    def is_valid(self):
+        """Returns true if any one of the attributes has non-none value"""
+        return self.has_ipv4() or self.has_ipv6() or self.has_fqdn()
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/NetworkSecurityPolicyRulesGetResponse.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/ListDirectoryServerConfigsApiResponse.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_microseg_py_client.models
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.NetworkSecurityPolicyRulesGetResponsedata import NetworkSecurityPolicyRulesGetResponsedata  # noqa: F401,E501
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.ListDirectoryServerConfigsApiResponsedata import ListDirectoryServerConfigsApiResponsedata  # noqa: F401,E501
 from ntnx_microseg_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class NetworkSecurityPolicyRulesGetResponse(object):
+class ListDirectoryServerConfigsApiResponse(object):
 
-    """REST response for all response codes in API path /microseg/v4.0.a1/config/policies/{extId}/rules Get operation
+    """REST response for all response codes in API path /microseg/v4.0.b1/config/directory-server-configs Get operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfmicroseg.v4.config.NetworkSecurityPolicyRulesGetResponsedata',
+        'data': 'OneOfmicroseg.v4.config.ListDirectoryServerConfigsApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.NetworkSecurityPolicyRulesGetResponse'
+        return 'microseg.v4.config.ListDirectoryServerConfigsApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.NetworkSecurityPolicyRulesGetResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -122,15 +123,15 @@
 
     @property
     def data(self):
         """
         
 
         :type:
-                :class:`~ntnx_microseg_py_client.models.microseg.v4.config.NetworkSecurityPolicyRule` | 
+                :class:`~ntnx_microseg_py_client.models.microseg.v4.config.DirectoryServerConfig` | 
                 :class:`~ntnx_microseg_py_client.models.microseg.v4.error.ErrorResponse`
                     """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
@@ -171,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_microseg_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(NetworkSecurityPolicyRulesGetResponse, dict):
+        if issubclass(ListDirectoryServerConfigsApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, NetworkSecurityPolicyRulesGetResponse):
+        if not isinstance(other, ListDirectoryServerConfigsApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/NetworkSecurityPolicyTaskResponse.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/UdpPortRangeSpec.py`

 * *Files 15% similar despite different names*

```diff
@@ -3,142 +3,151 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_microseg_py_client.models
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.NetworkSecurityPolicyTaskResponsedata import NetworkSecurityPolicyTaskResponsedata  # noqa: F401,E501
-from ntnx_microseg_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
-
-class NetworkSecurityPolicyTaskResponse(object):
-
-    """REST response for all response codes in API path /microseg/v4.0.a1/config/policies/$actions/set-allow-ipv6-traffic Post operation
-
-    :param metadata: (:attr:`metadata`) 
-    :type metadata: 
-    :param data: (:attr:`data`) 
-    :type data: 
+from pathlib import Path
+
+class UdpPortRangeSpec(object):
+
+    """Range of TCP/UDP ports.
+
+    :param start_port: (:attr:`start_port`) 
+    :type start_port: required
+    :param end_port: (:attr:`end_port`) 
+    :type end_port: required
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfmicroseg.v4.config.NetworkSecurityPolicyTaskResponsedata',
+        'start_port': 'int',
+        'end_port': 'int',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'metadata': 'metadata',
-        'data': 'data',
+        'start_port': 'startPort',
+        'end_port': 'endPort',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        self.__metadata = None
-        self.__data = None
+    def __init__(self, start_port=None, end_port=None, *args, **kwargs):  # noqa: E501
+        self.__start_port = None
+        self.__end_port = None
         self.discriminator = None
-        if metadata is not None:
-            self.__metadata = metadata
-        if data is not None:
-            self.__data = data
+        self.__start_port = start_port
+        self.__end_port = end_port
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.NetworkSecurityPolicyTaskResponse'
+        return 'microseg.v4.config.UdpPortRangeSpec'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.NetworkSecurityPolicyTaskResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def metadata(self):
+    def start_port(self):
         """
         
 
         :type:
-            :class:`~ntnx_microseg_py_client.models.common.v1.response.ApiResponseMetadata`
+
+                :class:`~int`
         """  # noqa: E501
-        return self.__metadata
+        return self.__start_port
 
-    @metadata.setter
-    def metadata(self, metadata):
+    @start_port.setter
+    def start_port(self, start_port):
+        if start_port is None:
+            raise ValueError("Invalid value for `start_port`, must not be `None`")  # noqa: E501
+        if start_port is not None and start_port > 65535:  # noqa: E501
+            raise ValueError("Invalid value for `start_port`, must be a value less than or equal to `65535`")  # noqa: E501
+        if start_port is not None and start_port < 0:  # noqa: E501
+            raise ValueError("Invalid value for `start_port`, must be a value greater than or equal to `0`")  # noqa: E501
 
-        self.__metadata = metadata
+        self.__start_port = start_port
 
     @property
-    def data(self):
+    def end_port(self):
         """
         
 
         :type:
-                :class:`~ntnx_microseg_py_client.models.prism.v4.config.TaskReference` | 
-                :class:`~ntnx_microseg_py_client.models.microseg.v4.error.ErrorResponse`
-                    """  # noqa: E501
-        return self.__data
 
-    @data.setter
-    def data(self, data):
+                :class:`~int`
+        """  # noqa: E501
+        return self.__end_port
+
+    @end_port.setter
+    def end_port(self, end_port):
+        if end_port is None:
+            raise ValueError("Invalid value for `end_port`, must not be `None`")  # noqa: E501
+        if end_port is not None and end_port > 65535:  # noqa: E501
+            raise ValueError("Invalid value for `end_port`, must be a value less than or equal to `65535`")  # noqa: E501
+        if end_port is not None and end_port < 0:  # noqa: E501
+            raise ValueError("Invalid value for `end_port`, must be a value greater than or equal to `0`")  # noqa: E501
 
-        self.__data = data
+        self.__end_port = end_port
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -171,39 +180,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
-            if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_microseg_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(NetworkSecurityPolicyTaskResponse, dict):
+        if issubclass(UdpPortRangeSpec, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +227,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, NetworkSecurityPolicyTaskResponse):
+        if not isinstance(other, UdpPortRangeSpec):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/OptionSpec.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/DeleteDirectoryServerConfigApiResponsedata.py`

 * *Files 21% similar despite different names*

```diff
@@ -3,232 +3,167 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_microseg_py_client.models.microseg.v4.config.TierName import TierName  # noqa: F401,E501
+from pathlib import Path
 
-class OptionSpec(object):
+class DeleteDirectoryServerConfigApiResponsedata(object):
 
-    """List of available tiers
+    """
 
-    :param name: (:attr:`name`) 
-    :type name: 
-    :param memory_in_gb: (:attr:`memory_in_gb`) Memory in GB of the tier
-    :type memory_in_gb: 
-    :param description: (:attr:`description`) Description of the tier
-    :type description: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'name': 'microseg.v4.config.TierName',
-        'memory_in_gb': 'int',
-        'description': 'str',
-        '_reserved': 'dict(str, object)',
-        '_object_type': 'str',
-        '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'name': 'name',
-        'memory_in_gb': 'memoryInGB',
-        'description': 'description',
-        '_reserved': '$reserved',
-        '_object_type': '$objectType',
-        '_unknown_fields': '$unknownFields',
     }
 
+    discriminator_value_class_map = {
+        'EMPTY_LIST': 'list[str]',
+        'EMPTY_MAP': 'dict(str, object)',
+        'prism.v4.config.TaskReference': 'prism.v4.config.TaskReference',
+        'microseg.v4.error.ErrorResponse': 'microseg.v4.error.ErrorResponse'
+    }
+
+    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
-    def __init__(self, name=None, memory_in_gb=None, description=None, *args, **kwargs):  # noqa: E501
-        self.__name = None
-        self.__memory_in_gb = None
-        self.__description = None
+    def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
-        if name is not None:
-            self.__name = name
-        if memory_in_gb is not None:
-            self.__memory_in_gb = memory_in_gb
-        if description is not None:
-            self.__description = description
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.OptionSpec'
+        return 'OneOfmicroseg.v4.config.DeleteDirectoryServerConfigApiResponsedata'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.OptionSpec'
+    def _initialize_object_version(self):
+        return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
-    @property
-    def name(self):
-        """
-        
-
-        :type:
-            :class:`~ntnx_microseg_py_client.models.microseg.v4.config.TierName`
-        """  # noqa: E501
-        return self.__name
-
-    @name.setter
-    def name(self, name):
-
-        self.__name = name
-
-    @property
-    def memory_in_gb(self):
-        """
-        Memory in GB of the tier
-
-        :type:
-
-                :class:`~int`
-        """  # noqa: E501
-        return self.__memory_in_gb
-
-    @memory_in_gb.setter
-    def memory_in_gb(self, memory_in_gb):
-        if memory_in_gb is not None and memory_in_gb > 6:  # noqa: E501
-            raise ValueError("Invalid value for `memory_in_gb`, must be a value less than or equal to `6`")  # noqa: E501
-        if memory_in_gb is not None and memory_in_gb < 2:  # noqa: E501
-            raise ValueError("Invalid value for `memory_in_gb`, must be a value greater than or equal to `2`")  # noqa: E501
-
-        self.__memory_in_gb = memory_in_gb
-
-    @property
-    def description(self):
-        """
-        Description of the tier
-
-        :type:
-
-                :class:`~str`
-        """  # noqa: E501
-        return self.__description
-
-    @description.setter
-    def description(self, description):
-        if description is not None and len(description) > 30:
-            raise ValueError("Invalid value for `description`, length must be less than or equal to `30`")  # noqa: E501
-
-        self.__description = description
-
-    @property
-    def _reserved(self):
-        """
-        
-
-        :type:
-            dict(str, :class:`~object`)
-        """  # noqa: E501
-        return self.__dollar_reserved
-
-    @property
-    def _object_type(self):
-        """
-        
-
-        :type:
-
-                :class:`~str`
-        """  # noqa: E501
-        return self.__dollar_object_type
-
-    @property
-    def _unknown_fields(self):
-        """
-        
+    def get_real_child_model(self, discriminator):
+        """Returns the real base class specified by the discriminator"""
+        if discriminator is not None and discriminator in self.discriminator_value_class_map:
+            return self.discriminator_value_class_map.get(discriminator)
+        return None
+
+    @staticmethod
+    def get_discriminator_from_object(value):
+        """Returns the discriminator for the provided object.
+        """
+        if not value:
+            disc = 'list[str]'
+        elif hasattr(value, "_object_type"):
+            disc = value.get_object_type()
+        elif type(value) == list:
+            if hasattr(value[0], "_object_type"):
+                datatype = value[0].get_object_type()
+            else:
+                datatype = type(value[0]).__name__
+            disc = 'list[' + datatype + ']'
+        elif type(value) == dict:
+            if hasattr(next(iter(value.values())), "_object_type"):
+                datatype = next(iter(value.values())).get_object_type()
+            else:
+                datatype = type(next(iter(value.values()))).__name__
+            disc = 'dict(str, ' + datatype + ')'
+        else:
+            disc = type(value).__name__
+        if disc in DeleteDirectoryServerConfigApiResponsedata.discriminator_value_class_map.values():
+            return list(DeleteDirectoryServerConfigApiResponsedata.discriminator_value_class_map.keys())[list(DeleteDirectoryServerConfigApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        return None
 
-        :type:
-            dict(str, :class:`~object`)
-        """  # noqa: E501
-        return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(OptionSpec, dict):
+        if issubclass(DeleteDirectoryServerConfigApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -240,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, OptionSpec):
+        if not isinstance(other, DeleteDirectoryServerConfigApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/PolicyReferenceSpec.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/NetworkSecurityPolicyRule.py`

 * *Files 25% similar despite different names*

```diff
@@ -3,180 +3,189 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
+import ntnx_microseg_py_client.models
+from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.NetworkSecurityPolicyRulespec import NetworkSecurityPolicyRulespec  # noqa: F401,E501
+from ntnx_microseg_py_client.models.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
+from ntnx_microseg_py_client.models.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel  # noqa: F401,E501
+from ntnx_microseg_py_client.models.microseg.v4.config.RuleType import RuleType  # noqa: F401,E501
 
-class PolicyReferenceSpec(object):
+class NetworkSecurityPolicyRule(ExternalizableAbstractModel):
 
-    """A list of external ids for a set of network security policies.
+    """
 
-    :param policy_ext_ids: (:attr:`policy_ext_ids`) A list of external ids for a set of network security policies.
-    :type policy_ext_ids: required
+    :param description: (:attr:`description`) A user defined annotation for a rule.
+    :type description: 
+    :param type: (:attr:`type`) 
+    :type type: required
+    :param spec: (:attr:`spec`) 
+    :type spec: required
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'policy_ext_ids': 'list[str]',
+        'description': 'str',
+        'type': 'microseg.v4.config.RuleType',
+        'spec': 'OneOfmicroseg.v4.config.NetworkSecurityPolicyRulespec',
+        'ext_id': 'str',
+        'links': 'list[common.v1.response.ApiLink]',
+        'tenant_id': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'policy_ext_ids': 'policyExtIds',
+        'description': 'description',
+        'type': 'type',
+        'spec': 'spec',
+        'ext_id': 'extId',
+        'links': 'links',
+        'tenant_id': 'tenantId',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, policy_ext_ids=None, *args, **kwargs):  # noqa: E501
-        self.__policy_ext_ids = None
+    def __init__(self, description=None, type=None, spec=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
+        ExternalizableAbstractModel.__init__(self, ext_id, links, tenant_id, *args, **kwargs)
+        self.__description = None
+        self.__type = None
+        self.__spec = None
         self.discriminator = None
-        self.__policy_ext_ids = policy_ext_ids
-        # populate hidden vars if not empty
-        self._populate_hidden_vars(kwargs)
+        if description is not None:
+            self.__description = description
+        self.__type = type
+        self.__spec = spec
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.PolicyReferenceSpec'
-
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.PolicyReferenceSpec'
-
-    def _populate_hidden_vars(self, kwargs):
-        if "_reserved" in kwargs and kwargs["_reserved"] is not None:
-            self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
-            self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
-        else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
-        if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
-            self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
-            self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
-        else :
-            self.__dollar_unknown_fields = {}
-        if "_object_type" in kwargs and kwargs["_object_type"] is not None:
-            self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
-            self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
-        else:
-            self.__dollar_object_type = self._initialize_object_type()
+        return 'microseg.v4.config.NetworkSecurityPolicyRule'
 
-    def get_object_type(self):
-        return self.__dollar_object_type
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
-    def get_reserved(self):
-        return self.__dollar_reserved
-
-    def get_unknown_fields(self):
-        return self.__dollar_unknown_fields
 
     @property
-    def policy_ext_ids(self):
+    def description(self):
         """
-        A list of external ids for a set of network security policies.
+        A user defined annotation for a rule.
 
         :type:
-            list[ :class:`~str` ]
+
+                :class:`~str`
         """  # noqa: E501
-        return self.__policy_ext_ids
+        return self.__description
 
-    @policy_ext_ids.setter
-    def policy_ext_ids(self, policy_ext_ids):
-        if policy_ext_ids is None:
-            raise ValueError("Invalid value for `policy_ext_ids`, must not be `None`")  # noqa: E501
+    @description.setter
+    def description(self, description):
+        if description is not None and len(description) > 64:
+            raise ValueError("Invalid value for `description`, length must be less than or equal to `64`")  # noqa: E501
 
-        self.__policy_ext_ids = policy_ext_ids
+        self.__description = description
 
     @property
-    def _reserved(self):
+    def type(self):
         """
         
 
         :type:
-            dict(str, :class:`~object`)
+            :class:`~ntnx_microseg_py_client.models.microseg.v4.config.RuleType`
         """  # noqa: E501
-        return self.__dollar_reserved
+        return self.__type
 
-    @property
-    def _object_type(self):
-        """
-        
+    @type.setter
+    def type(self, type):
+        if type is None:
+            raise ValueError("Invalid value for `type`, must not be `None`")  # noqa: E501
 
-        :type:
-
-                :class:`~str`
-        """  # noqa: E501
-        return self.__dollar_object_type
+        self.__type = type
 
     @property
-    def _unknown_fields(self):
+    def spec(self):
         """
         
 
         :type:
-            dict(str, :class:`~object`)
-        """  # noqa: E501
-        return self.__dollar_unknown_fields
+                :class:`~ntnx_microseg_py_client.models.microseg.v4.config.TwoEnvIsolationRuleSpec` | 
+                :class:`~ntnx_microseg_py_client.models.microseg.v4.config.ApplicationRuleSpec` | 
+                :class:`~ntnx_microseg_py_client.models.microseg.v4.config.IntraEntityGroupRuleSpec`
+                    """  # noqa: E501
+        return self.__spec
+
+    @spec.setter
+    def spec(self, spec):
+        if spec is None:
+            raise ValueError("Invalid value for `spec`, must not be `None`")  # noqa: E501
+
+        self.__spec = spec
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
+            if attr_type.startswith('OneOf'):
+                type = getattr(ntnx_microseg_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(PolicyReferenceSpec, dict):
+        if issubclass(NetworkSecurityPolicyRule, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -188,15 +197,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, PolicyReferenceSpec):
+        if not isinstance(other, NetworkSecurityPolicyRule):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/ServiceGroup.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/operation/DryRunSummary.py`

 * *Files 26% similar despite different names*

```diff
@@ -3,248 +3,203 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
+from ntnx_microseg_py_client.models.common.v1.config.Message import Message  # noqa: F401,E501
 from ntnx_microseg_py_client.models.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
 from ntnx_microseg_py_client.models.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel  # noqa: F401,E501
-from ntnx_microseg_py_client.models.microseg.v4.config.IcmpTypeCodeSpec import IcmpTypeCodeSpec  # noqa: F401,E501
-from ntnx_microseg_py_client.models.microseg.v4.config.TcpPortRangeSpec import TcpPortRangeSpec  # noqa: F401,E501
-from ntnx_microseg_py_client.models.microseg.v4.config.UdpPortRangeSpec import UdpPortRangeSpec  # noqa: F401,E501
+from ntnx_microseg_py_client.models.microseg.v4.operation.PolicyUpgradeSummary import PolicyUpgradeSummary  # noqa: F401,E501
+from ntnx_microseg_py_client.models.microseg.v4.operation.SubnetUpgradeSummary import SubnetUpgradeSummary  # noqa: F401,E501
+from ntnx_microseg_py_client.models.microseg.v4.operation.TotalPolicyCount import TotalPolicyCount  # noqa: F401,E501
 
-class ServiceGroup(ExternalizableAbstractModel):
+class DryRunSummary(ExternalizableAbstractModel):
 
     """
 
-    :param name: (:attr:`name`) A short identifier for a service group.
-    :type name: required
-    :param description: (:attr:`description`) A user defined annotation for a service group.
-    :type description: 
-    :param is_system_defined: (:attr:`is_system_defined`) Service Group is system defined or not.
-    :type is_system_defined: 
-    :param tcp_services: (:attr:`tcp_services`) List of TCP ports in the service.
-    :type tcp_services: 
-    :param udp_services: (:attr:`udp_services`) List of UDP ports in the service.
-    :type udp_services: 
-    :param icmp_services: (:attr:`icmp_services`) Icmp Type Code List.
-    :type icmp_services: 
+    :param policy_summaries: (:attr:`policy_summaries`) 
+    :type policy_summaries: 
+    :param count_summary: (:attr:`count_summary`) 
+    :type count_summary: 
+    :param subnet_summaries: (:attr:`subnet_summaries`) 
+    :type subnet_summaries: 
+    :param summary_failures: (:attr:`summary_failures`) 
+    :type summary_failures: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'name': 'str',
-        'description': 'str',
-        'is_system_defined': 'bool',
-        'tcp_services': 'list[microseg.v4.config.TcpPortRangeSpec]',
-        'udp_services': 'list[microseg.v4.config.UdpPortRangeSpec]',
-        'icmp_services': 'list[microseg.v4.config.IcmpTypeCodeSpec]',
+        'policy_summaries': 'list[microseg.v4.operation.PolicyUpgradeSummary]',
+        'count_summary': 'microseg.v4.operation.TotalPolicyCount',
+        'subnet_summaries': 'list[microseg.v4.operation.SubnetUpgradeSummary]',
+        'summary_failures': 'list[common.v1.config.Message]',
         'ext_id': 'str',
         'links': 'list[common.v1.response.ApiLink]',
         'tenant_id': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'name': 'name',
-        'description': 'description',
-        'is_system_defined': 'isSystemDefined',
-        'tcp_services': 'tcpServices',
-        'udp_services': 'udpServices',
-        'icmp_services': 'icmpServices',
+        'policy_summaries': 'policySummaries',
+        'count_summary': 'countSummary',
+        'subnet_summaries': 'subnetSummaries',
+        'summary_failures': 'summaryFailures',
         'ext_id': 'extId',
         'links': 'links',
         'tenant_id': 'tenantId',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, name=None, description=None, is_system_defined=None, tcp_services=None, udp_services=None, icmp_services=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
+    def __init__(self, policy_summaries=None, count_summary=None, subnet_summaries=None, summary_failures=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
         ExternalizableAbstractModel.__init__(self, ext_id, links, tenant_id, *args, **kwargs)
-        self.__name = None
-        self.__description = None
-        self.__is_system_defined = None
-        self.__tcp_services = None
-        self.__udp_services = None
-        self.__icmp_services = None
+        self.__policy_summaries = None
+        self.__count_summary = None
+        self.__subnet_summaries = None
+        self.__summary_failures = None
         self.discriminator = None
-        self.__name = name
-        if description is not None:
-            self.__description = description
-        if is_system_defined is not None:
-            self.__is_system_defined = is_system_defined
-        if tcp_services is not None:
-            self.__tcp_services = tcp_services
-        if udp_services is not None:
-            self.__udp_services = udp_services
-        if icmp_services is not None:
-            self.__icmp_services = icmp_services
+        if policy_summaries is not None:
+            self.__policy_summaries = policy_summaries
+        if count_summary is not None:
+            self.__count_summary = count_summary
+        if subnet_summaries is not None:
+            self.__subnet_summaries = subnet_summaries
+        if summary_failures is not None:
+            self.__summary_failures = summary_failures
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.ServiceGroup'
+        return 'microseg.v4.operation.DryRunSummary'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.ServiceGroup'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     @property
-    def name(self):
+    def policy_summaries(self):
         """
-        A short identifier for a service group.
+        
 
         :type:
-
-                :class:`~str`
-        """  # noqa: E501
-        return self.__name
-
-    @name.setter
-    def name(self, name):
-        if name is None:
-            raise ValueError("Invalid value for `name`, must not be `None`")  # noqa: E501
-        if name is not None and len(name) > 64:
-            raise ValueError("Invalid value for `name`, length must be less than or equal to `64`")  # noqa: E501
-
-        self.__name = name
-
-    @property
-    def description(self):
-        """
-        A user defined annotation for a service group.
-
-        :type:
-
-                :class:`~str`
+             list[ :class:`~ntnx_microseg_py_client.models.microseg.v4.operation.PolicyUpgradeSummary` ]
         """  # noqa: E501
-        return self.__description
+        return self.__policy_summaries
 
-    @description.setter
-    def description(self, description):
-        if description is not None and len(description) > 1000:
-            raise ValueError("Invalid value for `description`, length must be less than or equal to `1000`")  # noqa: E501
+    @policy_summaries.setter
+    def policy_summaries(self, policy_summaries):
 
-        self.__description = description
+        self.__policy_summaries = policy_summaries
 
     @property
-    def is_system_defined(self):
+    def count_summary(self):
         """
-        Service Group is system defined or not.
+        
 
         :type:
-
-                :class:`~bool`
-        """  # noqa: E501
-        return self.__is_system_defined
-
-    @is_system_defined.setter
-    def is_system_defined(self, is_system_defined):
-
-        self.__is_system_defined = is_system_defined
-
-    @property
-    def tcp_services(self):
-        """
-        List of TCP ports in the service.
-
-        :type:
-             list[ :class:`~ntnx_microseg_py_client.models.microseg.v4.config.TcpPortRangeSpec` ]
+            :class:`~ntnx_microseg_py_client.models.microseg.v4.operation.TotalPolicyCount`
         """  # noqa: E501
-        return self.__tcp_services
+        return self.__count_summary
 
-    @tcp_services.setter
-    def tcp_services(self, tcp_services):
+    @count_summary.setter
+    def count_summary(self, count_summary):
 
-        self.__tcp_services = tcp_services
+        self.__count_summary = count_summary
 
     @property
-    def udp_services(self):
+    def subnet_summaries(self):
         """
-        List of UDP ports in the service.
+        
 
         :type:
-             list[ :class:`~ntnx_microseg_py_client.models.microseg.v4.config.UdpPortRangeSpec` ]
+             list[ :class:`~ntnx_microseg_py_client.models.microseg.v4.operation.SubnetUpgradeSummary` ]
         """  # noqa: E501
-        return self.__udp_services
+        return self.__subnet_summaries
 
-    @udp_services.setter
-    def udp_services(self, udp_services):
+    @subnet_summaries.setter
+    def subnet_summaries(self, subnet_summaries):
 
-        self.__udp_services = udp_services
+        self.__subnet_summaries = subnet_summaries
 
     @property
-    def icmp_services(self):
+    def summary_failures(self):
         """
-        Icmp Type Code List.
+        
 
         :type:
-             list[ :class:`~ntnx_microseg_py_client.models.microseg.v4.config.IcmpTypeCodeSpec` ]
+             list[ :class:`~ntnx_microseg_py_client.models.common.v1.config.Message` ]
         """  # noqa: E501
-        return self.__icmp_services
+        return self.__summary_failures
 
-    @icmp_services.setter
-    def icmp_services(self, icmp_services):
+    @summary_failures.setter
+    def summary_failures(self, summary_failures):
 
-        self.__icmp_services = icmp_services
+        self.__summary_failures = summary_failures
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ServiceGroup, dict):
+        if issubclass(DryRunSummary, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -256,15 +211,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ServiceGroup):
+        if not isinstance(other, DryRunSummary):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/ServiceGroupGetResponse.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/error/SchemaValidationErrorMessage.py`

 * *Files 18% similar despite different names*

```diff
@@ -3,142 +3,164 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_microseg_py_client.models
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.ServiceGroupGetResponsedata import ServiceGroupGetResponsedata  # noqa: F401,E501
-from ntnx_microseg_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
-
-class ServiceGroupGetResponse(object):
-
-    """REST response for all response codes in API path /microseg/v4.0.a1/config/service-groups/{extId} Get operation
-
-    :param metadata: (:attr:`metadata`) 
-    :type metadata: 
-    :param data: (:attr:`data`) 
-    :type data: 
+from pathlib import Path
+
+class SchemaValidationErrorMessage(object):
+
+    """This schema is generated from SchemaValidationErrorMessage.java
+
+    :param location: (:attr:`location`) The part of the request that failed validation. Validation can fail for path, query parameters, and request body.
+    :type location: 
+    :param message: (:attr:`message`) The detailed message for the validation error.
+    :type message: 
+    :param attribute_path: (:attr:`attribute_path`) The path of the attribute that failed validation in the schema.
+    :type attribute_path: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfmicroseg.v4.config.ServiceGroupGetResponsedata',
+        'location': 'str',
+        'message': 'str',
+        'attribute_path': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'metadata': 'metadata',
-        'data': 'data',
+        'location': 'location',
+        'message': 'message',
+        'attribute_path': 'attributePath',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        self.__metadata = None
-        self.__data = None
+    def __init__(self, location=None, message=None, attribute_path=None, *args, **kwargs):  # noqa: E501
+        self.__location = None
+        self.__message = None
+        self.__attribute_path = None
         self.discriminator = None
-        if metadata is not None:
-            self.__metadata = metadata
-        if data is not None:
-            self.__data = data
+        if location is not None:
+            self.__location = location
+        if message is not None:
+            self.__message = message
+        if attribute_path is not None:
+            self.__attribute_path = attribute_path
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.ServiceGroupGetResponse'
+        return 'microseg.v4.error.SchemaValidationErrorMessage'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.ServiceGroupGetResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def metadata(self):
+    def location(self):
         """
-        
+        The part of the request that failed validation. Validation can fail for path, query parameters, and request body.
 
         :type:
-            :class:`~ntnx_microseg_py_client.models.common.v1.response.ApiResponseMetadata`
+
+                :class:`~str`
         """  # noqa: E501
-        return self.__metadata
+        return self.__location
 
-    @metadata.setter
-    def metadata(self, metadata):
+    @location.setter
+    def location(self, location):
 
-        self.__metadata = metadata
+        self.__location = location
 
     @property
-    def data(self):
+    def message(self):
         """
-        
+        The detailed message for the validation error.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__message
+
+    @message.setter
+    def message(self, message):
+
+        self.__message = message
+
+    @property
+    def attribute_path(self):
+        """
+        The path of the attribute that failed validation in the schema.
 
         :type:
-                :class:`~ntnx_microseg_py_client.models.microseg.v4.config.ServiceGroup` | 
-                :class:`~ntnx_microseg_py_client.models.microseg.v4.error.ErrorResponse`
-                    """  # noqa: E501
-        return self.__data
 
-    @data.setter
-    def data(self, data):
+                :class:`~str`
+        """  # noqa: E501
+        return self.__attribute_path
+
+    @attribute_path.setter
+    def attribute_path(self, attribute_path):
 
-        self.__data = data
+        self.__attribute_path = attribute_path
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -171,39 +193,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
-            if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_microseg_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ServiceGroupGetResponse, dict):
+        if issubclass(SchemaValidationErrorMessage, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +240,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ServiceGroupGetResponse):
+        if not isinstance(other, SchemaValidationErrorMessage):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/ServiceGroupListResponse.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/OneOfmicroseg/v4/config/CreateNetworkSecurityPolicyImportApiResponsedata.py`

 * *Files 20% similar despite different names*

```diff
@@ -3,207 +3,168 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_microseg_py_client.models
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.ServiceGroupListResponsedata import ServiceGroupListResponsedata  # noqa: F401,E501
-from ntnx_microseg_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
-
-class ServiceGroupListResponse(object):
-
-    """REST response for all response codes in API path /microseg/v4.0.a1/config/service-groups Get operation
-
-    :param metadata: (:attr:`metadata`) 
-    :type metadata: 
-    :param data: (:attr:`data`) 
-    :type data: 
+from pathlib import Path
+
+class CreateNetworkSecurityPolicyImportApiResponsedata(object):
+
+    """
+
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfmicroseg.v4.config.ServiceGroupListResponsedata',
-        '_reserved': 'dict(str, object)',
-        '_object_type': 'str',
-        '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'metadata': 'metadata',
-        'data': 'data',
-        '_reserved': '$reserved',
-        '_object_type': '$objectType',
-        '_unknown_fields': '$unknownFields',
     }
 
+    discriminator_value_class_map = {
+        'EMPTY_LIST': 'list[str]',
+        'EMPTY_MAP': 'dict(str, object)',
+        'prism.v4.config.TaskReference': 'prism.v4.config.TaskReference',
+        'List<microseg.v4.config.ImportEntity>': 'list[microseg.v4.config.ImportEntity]',
+        'microseg.v4.error.ErrorResponse': 'microseg.v4.error.ErrorResponse'
+    }
+
+    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
-    def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        self.__metadata = None
-        self.__data = None
+    def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
-        if metadata is not None:
-            self.__metadata = metadata
-        if data is not None:
-            self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.ServiceGroupListResponse'
+        return 'OneOfmicroseg.v4.config.CreateNetworkSecurityPolicyImportApiResponsedata'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.ServiceGroupListResponse'
+    def _initialize_object_version(self):
+        return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
-    @property
-    def metadata(self):
-        """
-        
-
-        :type:
-            :class:`~ntnx_microseg_py_client.models.common.v1.response.ApiResponseMetadata`
-        """  # noqa: E501
-        return self.__metadata
-
-    @metadata.setter
-    def metadata(self, metadata):
-
-        self.__metadata = metadata
-
-    @property
-    def data(self):
-        """
-        
-
-        :type:
-                :class:`~ntnx_microseg_py_client.models.microseg.v4.config.ServiceGroup` | 
-                :class:`~ntnx_microseg_py_client.models.microseg.v4.error.ErrorResponse`
-                    """  # noqa: E501
-        return self.__data
-
-    @data.setter
-    def data(self, data):
-
-        self.__data = data
-
-    @property
-    def _reserved(self):
-        """
-        
-
-        :type:
-            dict(str, :class:`~object`)
-        """  # noqa: E501
-        return self.__dollar_reserved
-
-    @property
-    def _object_type(self):
-        """
-        
-
-        :type:
-
-                :class:`~str`
-        """  # noqa: E501
-        return self.__dollar_object_type
-
-    @property
-    def _unknown_fields(self):
-        """
-        
+    def get_real_child_model(self, discriminator):
+        """Returns the real base class specified by the discriminator"""
+        if discriminator is not None and discriminator in self.discriminator_value_class_map:
+            return self.discriminator_value_class_map.get(discriminator)
+        return None
+
+    @staticmethod
+    def get_discriminator_from_object(value):
+        """Returns the discriminator for the provided object.
+        """
+        if not value:
+            disc = 'list[str]'
+        elif hasattr(value, "_object_type"):
+            disc = value.get_object_type()
+        elif type(value) == list:
+            if hasattr(value[0], "_object_type"):
+                datatype = value[0].get_object_type()
+            else:
+                datatype = type(value[0]).__name__
+            disc = 'list[' + datatype + ']'
+        elif type(value) == dict:
+            if hasattr(next(iter(value.values())), "_object_type"):
+                datatype = next(iter(value.values())).get_object_type()
+            else:
+                datatype = type(next(iter(value.values()))).__name__
+            disc = 'dict(str, ' + datatype + ')'
+        else:
+            disc = type(value).__name__
+        if disc in CreateNetworkSecurityPolicyImportApiResponsedata.discriminator_value_class_map.values():
+            return list(CreateNetworkSecurityPolicyImportApiResponsedata.discriminator_value_class_map.keys())[list(CreateNetworkSecurityPolicyImportApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        return None
 
-        :type:
-            dict(str, :class:`~object`)
-        """  # noqa: E501
-        return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
-            if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_microseg_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ServiceGroupListResponse, dict):
+        if issubclass(CreateNetworkSecurityPolicyImportApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +176,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ServiceGroupListResponse):
+        if not isinstance(other, CreateNetworkSecurityPolicyImportApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/config/ServiceGroupPolicyAssociationResponse.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/common/v1/config/IPv6Address.py`

 * *Files 19% similar despite different names*

```diff
@@ -3,142 +3,147 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_microseg_py_client.models
-from ntnx_microseg_py_client.models.OneOfmicroseg.v4.config.ServiceGroupPolicyAssociationResponsedata import ServiceGroupPolicyAssociationResponsedata  # noqa: F401,E501
-from ntnx_microseg_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
-
-class ServiceGroupPolicyAssociationResponse(object):
-
-    """REST response for all response codes in API path /microseg/v4.0.a1/config/service-groups/$actions/build-policy-association Post operation
-
-    :param metadata: (:attr:`metadata`) 
-    :type metadata: 
-    :param data: (:attr:`data`) 
-    :type data: 
+from pathlib import Path
+
+class IPv6Address(object):
+
+    """
+
+    :param value: (:attr:`value`) 
+    :type value: 
+    :param prefix_length: (:attr:`prefix_length`) The prefix length of the network to which this host IPv6 address belongs.  (**Default** 128)
+    :type prefix_length: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfmicroseg.v4.config.ServiceGroupPolicyAssociationResponsedata',
+        'value': 'str',
+        'prefix_length': 'int',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'metadata': 'metadata',
-        'data': 'data',
+        'value': 'value',
+        'prefix_length': 'prefixLength',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        self.__metadata = None
-        self.__data = None
+    def __init__(self, value=None, prefix_length=128, *args, **kwargs):  # noqa: E501
+        self.__value = None
+        self.__prefix_length = None
         self.discriminator = None
-        if metadata is not None:
-            self.__metadata = metadata
-        if data is not None:
-            self.__data = data
+        if value is not None:
+            self.__value = value
+        if prefix_length is not None:
+            self.__prefix_length = prefix_length
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.config.ServiceGroupPolicyAssociationResponse'
+        return 'common.v1.config.IPv6Address'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.config.ServiceGroupPolicyAssociationResponse'
+    def _initialize_object_version(self):
+        return 'v1.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def metadata(self):
+    def value(self):
         """
         
 
         :type:
-            :class:`~ntnx_microseg_py_client.models.common.v1.response.ApiResponseMetadata`
+
+                :class:`~str`
         """  # noqa: E501
-        return self.__metadata
+        return self.__value
 
-    @metadata.setter
-    def metadata(self, metadata):
+    @value.setter
+    def value(self, value):
+        if value is not None and not re.search('^(?:(?:(?:[A-Fa-f0-9]{1,4}:){6}|(?=(?:[A-Fa-f0-9]{0,4}:){0,6}(?:[0-9]{1,3}\\.){3}[0-9]{1,3}$)(([0-9a-fA-F]{1,4}:){0,5}|:)((:[0-9a-fA-F]{1,4}){1,5}:|:)|::(?:[A-Fa-f0-9]{1,4}:){5})(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])|(?:[A-Fa-f0-9]{1,4}:){7}[A-Fa-f0-9]{1,4}|(?=(?:[A-Fa-f0-9]{0,4}:){0,7}[A-Fa-f0-9]{0,4}$)(([0-9a-fA-F]{1,4}:){1,7}|:)((:[0-9a-fA-F]{1,4}){1,7}|:)|(?:[A-Fa-f0-9]{1,4}:){7}:|:(:[A-Fa-f0-9]{1,4}){7})$', value):  # noqa: E501
+            raise ValueError(r"Invalid value for `value`, must be a follow pattern or equal to `/^(?:(?:(?:[A-Fa-f0-9]{1,4}:){6}|(?=(?:[A-Fa-f0-9]{0,4}:){0,6}(?:[0-9]{1,3}\\.){3}[0-9]{1,3}$)(([0-9a-fA-F]{1,4}:){0,5}|:)((:[0-9a-fA-F]{1,4}){1,5}:|:)|::(?:[A-Fa-f0-9]{1,4}:){5})(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])|(?:[A-Fa-f0-9]{1,4}:){7}[A-Fa-f0-9]{1,4}|(?=(?:[A-Fa-f0-9]{0,4}:){0,7}[A-Fa-f0-9]{0,4}$)(([0-9a-fA-F]{1,4}:){1,7}|:)((:[0-9a-fA-F]{1,4}){1,7}|:)|(?:[A-Fa-f0-9]{1,4}:){7}:|:(:[A-Fa-f0-9]{1,4}){7})$/`")  # noqa: E501
 
-        self.__metadata = metadata
+        self.__value = value
 
     @property
-    def data(self):
+    def prefix_length(self):
         """
-        
+        The prefix length of the network to which this host IPv6 address belongs. 
 
         :type:
-                :class:`~ntnx_microseg_py_client.models.microseg.v4.config.ServiceGroupPolicyReference` | 
-                :class:`~ntnx_microseg_py_client.models.microseg.v4.error.ErrorResponse`
-                    """  # noqa: E501
-        return self.__data
 
-    @data.setter
-    def data(self, data):
+                :class:`~int`
+        """  # noqa: E501
+        return self.__prefix_length
+
+    @prefix_length.setter
+    def prefix_length(self, prefix_length):
+        if prefix_length is not None and prefix_length > 128:  # noqa: E501
+            raise ValueError("Invalid value for `prefix_length`, must be a value less than or equal to `128`")  # noqa: E501
+        if prefix_length is not None and prefix_length < 0:  # noqa: E501
+            raise ValueError("Invalid value for `prefix_length`, must be a value greater than or equal to `0`")  # noqa: E501
 
-        self.__data = data
+        self.__prefix_length = prefix_length
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -171,39 +176,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
-            if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_microseg_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ServiceGroupPolicyAssociationResponse, dict):
+        if issubclass(IPv6Address, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +223,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ServiceGroupPolicyAssociationResponse):
+        if not isinstance(other, IPv6Address):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/error/AppMessage.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/error/SchemaValidationError.py`

 * *Files 16% similar despite different names*

```diff
@@ -3,231 +3,210 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_microseg_py_client.models.common.v1.config.MessageSeverity import MessageSeverity  # noqa: F401,E501
+from pathlib import Path
+from ntnx_microseg_py_client.models.microseg.v4.error.SchemaValidationErrorMessage import SchemaValidationErrorMessage  # noqa: F401,E501
 
-class AppMessage(object):
+class SchemaValidationError(object):
 
-    """This schema is generated from AppMessage.java
+    """This schema is generated from SchemaValidationError.java
 
-    :param message: (:attr:`message`) 
-    :type message: 
-    :param severity: (:attr:`severity`) 
-    :type severity: 
-    :param code: (:attr:`code`) 
-    :type code: 
-    :param locale: (:attr:`locale`) The locale for the message description. (**Default** 'en_US')
-    :type locale: 
-    :param error_group: (:attr:`error_group`) 
-    :type error_group: 
-    :param arguments_map: (:attr:`arguments_map`) 
-    :type arguments_map: 
+    :param timestamp: (:attr:`timestamp`) Timestamp of the response.
+    :type timestamp: 
+    :param status_code: (:attr:`status_code`) The HTTP status code of the response.
+    :type status_code: 
+    :param error: (:attr:`error`) The generic error message for the response.
+    :type error: 
+    :param path: (:attr:`path`) API path on which the request was made.
+    :type path: 
+    :param validation_error_messages: (:attr:`validation_error_messages`) List of validation error messages
+    :type validation_error_messages: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'message': 'str',
-        'severity': 'common.v1.config.MessageSeverity',
-        'code': 'str',
-        'locale': 'str',
-        'error_group': 'str',
-        'arguments_map': 'dict(str, str)',
+        'timestamp': 'str',
+        'status_code': 'int',
+        'error': 'str',
+        'path': 'str',
+        'validation_error_messages': 'list[microseg.v4.error.SchemaValidationErrorMessage]',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'message': 'message',
-        'severity': 'severity',
-        'code': 'code',
-        'locale': 'locale',
-        'error_group': 'errorGroup',
-        'arguments_map': 'argumentsMap',
+        'timestamp': 'timestamp',
+        'status_code': 'statusCode',
+        'error': 'error',
+        'path': 'path',
+        'validation_error_messages': 'validationErrorMessages',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, message=None, severity=None, code=None, locale='en_US', error_group=None, arguments_map=None, *args, **kwargs):  # noqa: E501
-        self.__message = None
-        self.__severity = None
-        self.__code = None
-        self.__locale = None
-        self.__error_group = None
-        self.__arguments_map = None
+    def __init__(self, timestamp=None, status_code=None, error=None, path=None, validation_error_messages=None, *args, **kwargs):  # noqa: E501
+        self.__timestamp = None
+        self.__status_code = None
+        self.__error = None
+        self.__path = None
+        self.__validation_error_messages = None
         self.discriminator = None
-        if message is not None:
-            self.__message = message
-        if severity is not None:
-            self.__severity = severity
-        if code is not None:
-            self.__code = code
-        if locale is not None:
-            self.__locale = locale
-        if error_group is not None:
-            self.__error_group = error_group
-        if arguments_map is not None:
-            self.__arguments_map = arguments_map
+        if timestamp is not None:
+            self.__timestamp = timestamp
+        if status_code is not None:
+            self.__status_code = status_code
+        if error is not None:
+            self.__error = error
+        if path is not None:
+            self.__path = path
+        if validation_error_messages is not None:
+            self.__validation_error_messages = validation_error_messages
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'microseg.v4.error.AppMessage'
+        return 'microseg.v4.error.SchemaValidationError'
 
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.error.AppMessage'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def message(self):
+    def timestamp(self):
         """
-        
+        Timestamp of the response.
 
         :type:
 
                 :class:`~str`
         """  # noqa: E501
-        return self.__message
-
-    @message.setter
-    def message(self, message):
-
-        self.__message = message
-
-    @property
-    def severity(self):
-        """
-        
-
-        :type:
-            :class:`~ntnx_microseg_py_client.models.common.v1.config.MessageSeverity`
-        """  # noqa: E501
-        return self.__severity
+        return self.__timestamp
 
-    @severity.setter
-    def severity(self, severity):
+    @timestamp.setter
+    def timestamp(self, timestamp):
 
-        self.__severity = severity
+        self.__timestamp = timestamp
 
     @property
-    def code(self):
+    def status_code(self):
         """
-        
+        The HTTP status code of the response.
 
         :type:
 
-                :class:`~str`
+                :class:`~int`
         """  # noqa: E501
-        return self.__code
+        return self.__status_code
 
-    @code.setter
-    def code(self, code):
+    @status_code.setter
+    def status_code(self, status_code):
 
-        self.__code = code
+        self.__status_code = status_code
 
     @property
-    def locale(self):
+    def error(self):
         """
-        The locale for the message description.
+        The generic error message for the response.
 
         :type:
 
                 :class:`~str`
         """  # noqa: E501
-        return self.__locale
+        return self.__error
 
-    @locale.setter
-    def locale(self, locale):
+    @error.setter
+    def error(self, error):
 
-        self.__locale = locale
+        self.__error = error
 
     @property
-    def error_group(self):
+    def path(self):
         """
-        
+        API path on which the request was made.
 
         :type:
 
                 :class:`~str`
         """  # noqa: E501
-        return self.__error_group
+        return self.__path
 
-    @error_group.setter
-    def error_group(self, error_group):
+    @path.setter
+    def path(self, path):
 
-        self.__error_group = error_group
+        self.__path = path
 
     @property
-    def arguments_map(self):
+    def validation_error_messages(self):
         """
-        
+        List of validation error messages
 
         :type:
-            dict(str, :class:`~str`)
+             list[ :class:`~ntnx_microseg_py_client.models.microseg.v4.error.SchemaValidationErrorMessage` ]
         """  # noqa: E501
-        return self.__arguments_map
+        return self.__validation_error_messages
 
-    @arguments_map.setter
-    def arguments_map(self, arguments_map):
+    @validation_error_messages.setter
+    def validation_error_messages(self, validation_error_messages):
 
-        self.__arguments_map = arguments_map
+        self.__validation_error_messages = validation_error_messages
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -260,37 +239,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(AppMessage, dict):
+        if issubclass(SchemaValidationError, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -302,15 +286,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, AppMessage):
+        if not isinstance(other, SchemaValidationError):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/models/microseg/v4/error/SchemaValidationError.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/models/microseg/v4/config/AddressGroup.py`

 * *Files 27% similar despite different names*

```diff
@@ -3,272 +3,255 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_microseg_py_client.models.microseg.v4.error.SchemaValidationErrorMessage import SchemaValidationErrorMessage  # noqa: F401,E501
+from pathlib import Path
+from ntnx_microseg_py_client.models.common.v1.config.IPv4Address import IPv4Address  # noqa: F401,E501
+from ntnx_microseg_py_client.models.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
+from ntnx_microseg_py_client.models.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel  # noqa: F401,E501
+from ntnx_microseg_py_client.models.microseg.v4.config.IPv4Range import IPv4Range  # noqa: F401,E501
 
-class SchemaValidationError(object):
+class AddressGroup(ExternalizableAbstractModel):
 
-    """This schema is generated from SchemaValidationError.java
+    """
 
-    :param timestamp: (:attr:`timestamp`) 
-    :type timestamp: 
-    :param status_code: (:attr:`status_code`) 
-    :type status_code: 
-    :param error: (:attr:`error`) 
-    :type error: 
-    :param path: (:attr:`path`) 
-    :type path: 
-    :param validation_error_messages: (:attr:`validation_error_messages`) 
-    :type validation_error_messages: 
+    :param name: (:attr:`name`) A short identifier for an Address Group.
+    :type name: required
+    :param description: (:attr:`description`) A user defined annotation for an Address Group.
+    :type description: 
+    :param ipv4_addresses: (:attr:`ipv4_addresses`) List of CIDR blocks in the Address Group.
+    :type ipv4_addresses: 
+    :param ip_ranges: (:attr:`ip_ranges`) List of IP range containing start and end IP.
+    :type ip_ranges: 
+    :param policy_references: (:attr:`policy_references`) Reference to policy associated with Address Group.
+    :type policy_references: 
+    :param created_by: (:attr:`created_by`) 
+    :type created_by: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'timestamp': 'str',
-        'status_code': 'int',
-        'error': 'str',
-        'path': 'str',
-        'validation_error_messages': 'list[microseg.v4.error.SchemaValidationErrorMessage]',
+        'name': 'str',
+        'description': 'str',
+        'ipv4_addresses': 'list[common.v1.config.IPv4Address]',
+        'ip_ranges': 'list[microseg.v4.config.IPv4Range]',
+        'policy_references': 'list[str]',
+        'created_by': 'str',
+        'ext_id': 'str',
+        'links': 'list[common.v1.response.ApiLink]',
+        'tenant_id': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'timestamp': 'timestamp',
-        'status_code': 'statusCode',
-        'error': 'error',
-        'path': 'path',
-        'validation_error_messages': 'validationErrorMessages',
+        'name': 'name',
+        'description': 'description',
+        'ipv4_addresses': 'ipv4Addresses',
+        'ip_ranges': 'ipRanges',
+        'policy_references': 'policyReferences',
+        'created_by': 'createdBy',
+        'ext_id': 'extId',
+        'links': 'links',
+        'tenant_id': 'tenantId',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, timestamp=None, status_code=None, error=None, path=None, validation_error_messages=None, *args, **kwargs):  # noqa: E501
-        self.__timestamp = None
-        self.__status_code = None
-        self.__error = None
-        self.__path = None
-        self.__validation_error_messages = None
+    def __init__(self, name=None, description=None, ipv4_addresses=None, ip_ranges=None, policy_references=None, created_by=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
+        ExternalizableAbstractModel.__init__(self, ext_id, links, tenant_id, *args, **kwargs)
+        self.__name = None
+        self.__description = None
+        self.__ipv4_addresses = None
+        self.__ip_ranges = None
+        self.__policy_references = None
+        self.__created_by = None
         self.discriminator = None
-        if timestamp is not None:
-            self.__timestamp = timestamp
-        if status_code is not None:
-            self.__status_code = status_code
-        if error is not None:
-            self.__error = error
-        if path is not None:
-            self.__path = path
-        if validation_error_messages is not None:
-            self.__validation_error_messages = validation_error_messages
-        # populate hidden vars if not empty
-        self._populate_hidden_vars(kwargs)
+        self.__name = name
+        if description is not None:
+            self.__description = description
+        if ipv4_addresses is not None:
+            self.__ipv4_addresses = ipv4_addresses
+        if ip_ranges is not None:
+            self.__ip_ranges = ip_ranges
+        if policy_references is not None:
+            self.__policy_references = policy_references
+        if created_by is not None:
+            self.__created_by = created_by
 
     def _initialize_object_type(self):
-        return 'microseg.v4.error.SchemaValidationError'
-
-    def _initialize_fq_object_type(self):
-        return 'microseg.v4.r0.a1.error.SchemaValidationError'
-
-    def _populate_hidden_vars(self, kwargs):
-        if "_reserved" in kwargs and kwargs["_reserved"] is not None:
-            self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
-            self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
-        else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
-        if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
-            self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
-            self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
-        else :
-            self.__dollar_unknown_fields = {}
-        if "_object_type" in kwargs and kwargs["_object_type"] is not None:
-            self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
-            self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
-        else:
-            self.__dollar_object_type = self._initialize_object_type()
-
-    def get_object_type(self):
-        return self.__dollar_object_type
+        return 'microseg.v4.config.AddressGroup'
 
-    def get_reserved(self):
-        return self.__dollar_reserved
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
-    def get_unknown_fields(self):
-        return self.__dollar_unknown_fields
 
     @property
-    def timestamp(self):
+    def name(self):
         """
-        
+        A short identifier for an Address Group.
 
         :type:
 
                 :class:`~str`
         """  # noqa: E501
-        return self.__timestamp
+        return self.__name
 
-    @timestamp.setter
-    def timestamp(self, timestamp):
+    @name.setter
+    def name(self, name):
+        if name is None:
+            raise ValueError("Invalid value for `name`, must not be `None`")  # noqa: E501
+        if name is not None and len(name) > 64:
+            raise ValueError("Invalid value for `name`, length must be less than or equal to `64`")  # noqa: E501
 
-        self.__timestamp = timestamp
+        self.__name = name
 
     @property
-    def status_code(self):
+    def description(self):
         """
-        
+        A user defined annotation for an Address Group.
 
         :type:
 
-                :class:`~int`
+                :class:`~str`
         """  # noqa: E501
-        return self.__status_code
+        return self.__description
 
-    @status_code.setter
-    def status_code(self, status_code):
+    @description.setter
+    def description(self, description):
+        if description is not None and len(description) > 1000:
+            raise ValueError("Invalid value for `description`, length must be less than or equal to `1000`")  # noqa: E501
 
-        self.__status_code = status_code
+        self.__description = description
 
     @property
-    def error(self):
+    def ipv4_addresses(self):
         """
-        
+        List of CIDR blocks in the Address Group.
 
         :type:
-
-                :class:`~str`
+             list[ :class:`~ntnx_microseg_py_client.models.common.v1.config.IPv4Address` ]
         """  # noqa: E501
-        return self.__error
+        return self.__ipv4_addresses
 
-    @error.setter
-    def error(self, error):
+    @ipv4_addresses.setter
+    def ipv4_addresses(self, ipv4_addresses):
 
-        self.__error = error
+        self.__ipv4_addresses = ipv4_addresses
 
     @property
-    def path(self):
+    def ip_ranges(self):
         """
-        
+        List of IP range containing start and end IP.
 
         :type:
-
-                :class:`~str`
+             list[ :class:`~ntnx_microseg_py_client.models.microseg.v4.config.IPv4Range` ]
         """  # noqa: E501
-        return self.__path
+        return self.__ip_ranges
 
-    @path.setter
-    def path(self, path):
+    @ip_ranges.setter
+    def ip_ranges(self, ip_ranges):
 
-        self.__path = path
+        self.__ip_ranges = ip_ranges
 
     @property
-    def validation_error_messages(self):
+    def policy_references(self):
         """
-        
+        Reference to policy associated with Address Group.
 
         :type:
-             list[ :class:`~ntnx_microseg_py_client.models.microseg.v4.error.SchemaValidationErrorMessage` ]
+            list[ :class:`~str` ]
         """  # noqa: E501
-        return self.__validation_error_messages
+        return self.__policy_references
 
-    @validation_error_messages.setter
-    def validation_error_messages(self, validation_error_messages):
+    @policy_references.setter
+    def policy_references(self, policy_references):
 
-        self.__validation_error_messages = validation_error_messages
+        self.__policy_references = policy_references
 
     @property
-    def _reserved(self):
-        """
-        
-
-        :type:
-            dict(str, :class:`~object`)
-        """  # noqa: E501
-        return self.__dollar_reserved
-
-    @property
-    def _object_type(self):
+    def created_by(self):
         """
         
 
         :type:
 
                 :class:`~str`
         """  # noqa: E501
-        return self.__dollar_object_type
+        return self.__created_by
 
-    @property
-    def _unknown_fields(self):
-        """
-        
+    @created_by.setter
+    def created_by(self, created_by):
+        if created_by is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', created_by):  # noqa: E501
+            raise ValueError(r"Invalid value for `created_by`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
 
-        :type:
-            dict(str, :class:`~object`)
-        """  # noqa: E501
-        return self.__dollar_unknown_fields
+        self.__created_by = created_by
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(SchemaValidationError, dict):
+        if issubclass(AddressGroup, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -280,15 +263,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, SchemaValidationError):
+        if not isinstance(other, AddressGroup):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client/rest.py` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client/rest.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,15 +3,15 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 from __future__ import absolute_import
 
 import io
@@ -37,15 +37,15 @@
 
 class RESTResponse(io.IOBase):
 
     def __init__(self, resp):
         self.urllib3_response = resp
         self.status = resp.status
         self.reason = resp.reason
-        self.data = resp.data
+        self.data = None
 
     def getheaders(self):
         """Returns a dictionary of the response headers."""
         return self.urllib3_response.getheaders()
 
     def getheader(self, name, default=None):
         """Returns a given response header."""
@@ -180,14 +180,16 @@
             if isinstance(_request_timeout, (int, float) if six.PY3 else (int, long, float)):  # noqa: E501,F821
                 timeout = urllib3.Timeout(total=_request_timeout)
             elif (isinstance(_request_timeout, list) and len(_request_timeout) == 2):
                 timeout = urllib3.Timeout(connect=_request_timeout[0], read=_request_timeout[1])
 
         if 'Content-Type' not in headers:
             headers['Content-Type'] = 'application/json'
+        if 'Accept' in headers and headers['Accept'] == 'application/octet-stream':
+            _preload_content = False
 
         # Print log statements
         logger.info("%s %s", method, url + '?' + urlencode(query_params) if query_params else url)
         # Print debug logs, if enabled
         if self.__configuration.debug:
             logger.debug("Request Headers:")
             for key, value in six.iteritems(headers):
@@ -221,31 +223,37 @@
                         preload_content=_preload_content,
                         timeout=timeout,
                         headers=headers)
                 elif headers['Content-Type'] == 'multipart/form-data':
                     # must del headers['Content-Type'], or the correct
                     # Content-Type which generated by urllib3 will be
                     # overwritten.
+                    content_type_header = headers['Content-Type']
                     del headers['Content-Type']
                     r = self.pool_manager.request(
                         method, url,
                         fields=post_params,
                         encode_multipart=True,
                         preload_content=_preload_content,
                         timeout=timeout,
                         headers=headers)
+                    headers['Content-Type'] = content_type_header
                 # Pass a `string` parameter directly in the body to support
                 # other content types than Json when `body` argument is
                 # provided in serialized form
-                elif isinstance(body, str):
+                elif isinstance(body, str) or headers['Content-Type'] == 'application/octet-stream':
                     request_body = body
+                    preload = _preload_content
+                    if headers['Content-Type'] == 'application/octet-stream':
+                        preload = False
+
                     r = self.pool_manager.request(
                         method, url,
                         body=request_body,
-                        preload_content=_preload_content,
+                        preload_content=preload,
                         timeout=timeout,
                         headers=headers)
                 else:
                     # Cannot generate the request from given parameters
                     msg = """Cannot prepare a request message for provided
                              arguments. Please check that your arguments match
                              declared content type."""
@@ -260,30 +268,27 @@
         except urllib3.exceptions.SSLError as e:
             msg = "{0}\n{1}".format(type(e).__name__, str(e))
             raise ApiException(status=0, reason=msg)
         except Exception as e:
             logger.error(str(e))
             raise
 
-        if _preload_content:
+        if r.getheader(name='Content-Type') == 'application/octet-stream' or _preload_content :
             r = RESTResponse(r)
 
-            # In the python 3, the response.data is bytes.
-            # we need to decode it to string.
-            if six.PY3:
-                r.data = r.data.decode('utf8')
-
         # Print log statements
         logger.info("Response Status: %s %s", r.status, r.reason)
         # Print debug logs, if enabled
         if self.__configuration.debug:
             logger.debug("Response Headers:")
             for key, value in six.iteritems(r.getheaders()):
                 logger.debug("%s: %s", key, value)
-            logger.debug("Response Body: %s", r.data)
+
+            if _preload_content and r.getheader("Content-Type", "application/json") != "application/octet-stream":
+                logger.debug("Response Body: %s", r.urllib3_response.data)
 
         if not 200 <= r.status <= 299 and not 401 == r.status:
             raise ApiException(http_resp=r)
 
         return r
 
     def GET(self, url, headers=None, query_params=None, _preload_content=True,
@@ -354,15 +359,16 @@
 
 class ApiException(Exception):
 
     def __init__(self, status=None, reason=None, http_resp=None):
         if http_resp:
             self.status = http_resp.status
             self.reason = http_resp.reason
-            self.body = http_resp.data
+            self.body = (http_resp.urllib3_response.data.decode('utf8') if hasattr(http_resp, 'urllib3_response')
+                        else http_resp.data.decode('utf8'))
             self.headers = http_resp.getheaders()
         else:
             self.status = status
             self.reason = reason
             self.body = None
             self.headers = None
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/ntnx_microseg_py_client.egg-info/PKG-INFO` & `ntnx_microseg_py_client-4.0.1b1/ntnx_microseg_py_client.egg-info/PKG-INFO`

 * *Files 3% similar despite different names*

```diff
@@ -1,37 +1,37 @@
 Metadata-Version: 2.1
 Name: ntnx-microseg-py-client
-Version: 4.0.1a1
+Version: 4.0.1b1
 Summary: Nutanix Microseg Versioned APIs
 Home-page: 
 Author-email: sdk@nutanix.com
 Keywords: Nutanix,v4,SDK,Nutanix Microseg Versioned APIs
 Description-Content-Type: text/markdown
 License-File: LICENSE.txt
 Requires-Dist: urllib3~=1.26
 Requires-Dist: six~=1.16
-Requires-Dist: certifi==2020.4.5.1
+Requires-Dist: certifi<=2023.11.17,>=2020.4.5.1
 Requires-Dist: python-dateutil~=2.8
 Requires-Dist: pysocks~=1.7
 
 # Python Client For Nutanix Microseg Versioned APIs
 
 The Python client for Nutanix Microseg Versioned APIs is designed for Python client application developers offering them simple and flexible access to APIs that manage Network Security Policy configuration of Nutanix clusters.
 ## Features
 - Invoke Nutanix APIs with a simple interface.
 - Handle Authentication seamlessly.
 - Reduce boilerplate code implementation.
 - Use standard methods for installation.
 
 ## Version
-- API version: v4.0.a1
-- Package version: 4.0.1a1
+- API version: v4.0.b1
+- Package version: 4.0.1b1
 
 ## Requirements.
-Python 3.6, 3.7, and 3.8 are fully supported and tested.
+Python 3.6, 3.7, 3.8 and 3.9 are fully supported and tested.
 
 
 ## Installation & Usage
 
 ### Installing in a virtual environment
 [virtualenv](https://virtualenv.pypa.io/en/latest/) is a tool to create isolated Python environments. The basic problem it addresses is one of dependencies and versions, and indirectly permissions. virtualenv can help you install this client without needing system install permissions. It creates an environment that has its own installation directories without sharing libraries with other virtualenv environments or the system installation.
 
@@ -85,14 +85,15 @@
 | debug     | Runs the client in debug mode if specified                                       | No       | False        |
 | verify_ssl| Verify SSL certificate of cluster the client will connect to                     | No       | True         |
 | max_retry_attempts| Maximum number of retry attempts while connecting to the cluster         | No       | 5            |
 | backoff_factor| A backoff factor to apply between attempts after the second try.             | No       | 3            |
 | logger_file | File location to which debug logs are written to                               | No       | N/A          |
 | connect_timeout | Connection timeout in milliseconds for all operations                      | No       | 30000        |
 | read_timeout | Read timeout in milliseconds for all operations                               | No       | 30000        |
+| download_directory| Directory where downloaded files will be stored in                       | No       | Current Working Directory|
 
 
 ### Sample Configuration
 ```python
 config = Configuration()
 config.host = '10.19.50.27' # IPv4/IPv6 address or FQDN of the cluster
 config.port = 9440 # Port to which to connect to
@@ -145,61 +146,61 @@
 
 ### Invoking an operation
 ```python
 # Initialize the API
 address_groups_api_instance = AddressGroupsApi(api_client=client) # client configured in previous step
 extId = 'extId_example' # UUID.
 
-# Get a address group by UUID.
+# Get an Address Group by ExtID
 try:
-    api_response = address_groups_api_instance.get_address_group_by_ext_id(extId)
+    api_response = address_groups_api_instance.get_address_group_by_id(extId)
 except ApiException as e:
 ```
 
 ### Setting headers for individual operations
 Headers can be configured globally on the python client using the [method to set default headers](#additional-headers). However, sometimes headers need to be set on an individual operation basis. Nutanix APIs require that concurrent updates are protected using [ETag headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag).
 
 ```python
 # Initialize the API
 address_groups_api_instance = AddressGroupsApi(api_client=client) # client configured in previous step
 extId = 'extId_example' # UUID.
 
-# Get a address group by UUID.
+# Get an Address Group by ExtID
 try:
-    api_response = address_groups_api_instance.get_address_group_by_ext_id(extId)
+    api_response = address_groups_api_instance.get_address_group_by_id(extId)
 except ApiException as e:
 
 # Extract E-Tag Header
 etag_value = ApiClient.get_etag(api_response)
 
-# Updates a address group by UUID.
+# Update an Address Group
 try:
     # The body parameter in the following operation is received from the previous GET request's response which needs to be updated.
-    api_response = address_groups_api_instance.update_address_group_by_ext_id(body, extId, if_match=etag_value) # Use the extracted etag value
+    api_response = address_groups_api_instance.update_address_group_by_id(body, extId, if_match=etag_value) # Use the extracted etag value
 except ApiException as e:
 ```
 
 ### List Operations
 List Operations for Nutanix APIs support pagination, filtering, sorting and projections. The table below details the parameters that can be used to set the options for pagination etc.
 
 | Parameter | Description
 |-----------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
 | _page     | specifies the page number of the result set. Must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range will lead to no results being returned.|
 | _limit    | specifies the total number of records returned in the result set. Must be a positive integer between 0 and 100. Any number out of this range will lead to a validation error. If the limit is not provided a default value of 50 records will be returned in the result set|
 | _filter   | allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the [OData V4.01 URL](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part2-url-conventions.html#sec_SystemQueryOptionfilter) conventions. |
 | _orderby  | allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified the resources will be sorted in ascending order by default. For example, 'orderby=templateName desc' would get all templates sorted by templateName in desc order. |
-| _select   | allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the OData V4.01 URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e. *), then all properties on the matching resource will be returned. |
-| _expand   | allows clients to request related resources when a resource that satisfies a particular request is retrieved. Each expand item is evaluated relative to the entity containing the property being expanded. Other query options can be applied to an expanded property by appending a semicolon-separated list of query options, enclosed in parentheses, to the property name. Allowed system query options are $filter,$select, $orderby. |
+| _select   | allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the OData V4.01 URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e., *), then all properties on the matching resource will be returned. |
+| _expand   | allows clients to request related resources when a resource that satisfies a particular request is retrieved. Each expanded item is evaluated relative to the entity containing the property being expanded. Other query options can be applied to an expanded property by appending a semicolon-separated list of query options, enclosed in parentheses, to the property name. Permissible system query options are $filter,$select and $orderby. |
 
 ```python
 # Initialize the API
 address_groups_api_instance = AddressGroupsApi(api_client=client) # client configured in previous step
 extId = 'extId_example' # UUID.
 
-# Gets a list of address groups.
+# List all the Address Groups
 try:
     api_response = address_groups_api_instance.list_address_groups(
 	                   _page=page, # if page parameter is present
 	                   _limit=limit, # if limit parameter is present
 	                   _filter=_filter, # if filter parameter is present
 	                   _orderby=_orderby, # if orderby parameter is present
 	                   _select=select, # if select parameter is present
@@ -207,14 +208,14 @@
 except ApiException as e:
 
 ```
 The list of filterable and sortable fields with expansion keys can be found in the documentation [here](https://developers.nutanix.com/).
 
 ## API Reference
 
-This library has a full set of [API Reference Documentation](https://developers.nutanix.com/sdk-reference?namespace=microseg&version=v4.0.a1&language=python). This documentation is auto-generated, and the location may change.
+This library has a full set of [API Reference Documentation](https://developers.nutanix.com/sdk-reference?namespace=microseg&version=v4.0.b1&language=python). This documentation is auto-generated, and the location may change.
 
 ## License
 This library is licensed under Nutanix proprietary license. Full license text is available in [LICENSE](https://developers.nutanix.com/license).
 
 ## Contact us
 In case of issues please reach out to us at the [mailing list](mailto:sdk@nutanix.com)
```

### Comparing `ntnx-microseg-py-client-4.0.1a1/setup.py` & `ntnx_microseg_py_client-4.0.1b1/setup.py`

 * *Files 16% similar despite different names*

```diff
@@ -3,33 +3,33 @@
 
 """
 IGNORE:
     Nutanix Microseg Versioned APIs
 
     Manage Network Security Policy configuration of Nutanix clusters.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-alpha-1
+    OpenAPI spec version: 4.0.1-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import io
 import os
 from setuptools import setup, find_packages  # noqa: H301
 
 NAME = "ntnx-microseg-py-client"
-VERSION = "4.0.1a1"
+VERSION = "4.0.1b1"
 # To install the library, run the following
 #
 # python setup.py install
 #
 # prerequisite: setuptools
 # http://pypi.python.org/pypi/setuptools
 
-REQUIRES = ["urllib3 ~= 1.26", "six ~= 1.16", "certifi == 2020.4.5.1", "python-dateutil ~= 2.8", "pysocks ~= 1.7"]
+REQUIRES = ["urllib3 ~= 1.26", "six ~= 1.16", "certifi >=2020.4.5.1,<=2023.11.17", "python-dateutil ~= 2.8", "pysocks ~= 1.7"]
 
 package_root_path = os.path.abspath(os.path.dirname(__file__))
 readme_file_path = os.path.join(package_root_path, "README.md")
 with io.open(readme_file_path, encoding="utf-8") as readme_file:
     readme = readme_file.read()
 
 setup(
```

