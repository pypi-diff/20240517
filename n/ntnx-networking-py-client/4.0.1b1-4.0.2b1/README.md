# Comparing `tmp/ntnx-networking-py-client-4.0.1b1.tar.gz` & `tmp/ntnx_networking_py_client-4.0.2b1.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "/home/circleci/project/verify/pip-release-verify/prod-package-networking/dist/.tmp-76wiagmw/ntnx-networking-py-client-4.0.1b1.t", last modified: Mon Sep 18 22:30:03 2023, max compression
+gzip compressed data, was "/home/circleci/project/verify/pip-release-verify/prod-package-networking/dist/.tmp-sp10gkzl/ntnx_networking_py_client-4.0.2b1.t", last modified: Fri May 17 07:11:43 2024, max compression
```

## Comparing `ntnx-networking-py-client-4.0.1b1.tar` & `ntnx_networking_py_client-4.0.2b1.tar`

### file list

```diff
@@ -1,368 +1,359 @@
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:03.587499 ntnx-networking-py-client-4.0.1b1/
--rw-r--r--   0 circleci  (3434) circleci  (3434)    18137 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/LICENSE.txt
--rw-r--r--   0 circleci  (3434) circleci  (3434)    11689 2023-09-18 22:30:03.586500 ntnx-networking-py-client-4.0.1b1/PKG-INFO
--rw-r--r--   0 circleci  (3434) circleci  (3434)    11253 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/README.md
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:03.521499 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/
--rw-r--r--   0 circleci  (3434) circleci  (3434)    32717 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:03.527500 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1993 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    26357 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api/bgp_session_api.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     5837 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api/bridge_api.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6592 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api/cluster_capability_api.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    26359 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api/floating_ip_api.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    31221 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api/gateway_api.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    22970 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api/ipfix_exporter_api.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    30380 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api/layer2_stretch_api.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     9044 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api/layer2_stretch_stats_api.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    24089 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api/network_controller_api.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    15849 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api/route_table_api.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    25744 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api/routing_policy_api.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     5592 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api/routing_policy_stats_api.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    27085 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api/subnet_api.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    11019 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api/subnet_reserve_unreserve_ip_api.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    25566 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api/traffic_mirror_api.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7983 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api/traffic_mirror_stats_api.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    11532 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api/uplink_bond_api.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    24546 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api/virtual_switch_api.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     5106 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api/virtual_switch_node_info_api.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    25866 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api/vpc_api.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     9710 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api/vpc_ns_stats_api.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    11407 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api/vpc_virtual_switch_mappings_api.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    36051 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api/vpn_connection_api.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     9012 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api/vpn_connection_stats_api.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    58014 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api_client.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     2429 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api_response.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    15751 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/configuration.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:03.527500 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:03.527500 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfcommon/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfcommon/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:03.527500 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfcommon/v1/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfcommon/v1/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:03.528499 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfcommon/v1/config/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6571 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfcommon/v1/config/KVPairvalue.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfcommon/v1/config/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:03.528499 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:03.528499 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:03.538499 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6647 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/AncConfigApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6668 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/BgpSessionApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6818 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/BgpSessionListApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6686 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/CloudNetworkApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6726 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/CloudNetworkListApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6743 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/ClusterCapabilityApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6731 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/ClusterFlowStatusApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6668 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/FloatingIpApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6818 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/FloatingIpListApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6745 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/FloatingIpProjectionassociation.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6675 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/FloatingIpassociation.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6677 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/FlowGatewayApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6758 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/FlowGatewayKeepAliveApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6717 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/FlowGatewayListApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6641 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/GatewayApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6785 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/GatewayListApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6710 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/GatewayProjectionservices.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6640 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/Gatewayservices.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6695 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/IPFIXExporterApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6735 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/IPFIXExporterListApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6695 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/Layer2StretchApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6735 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/Layer2StretchListApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6830 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/Layer2StretchRelatedEntitiesApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6740 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/NetworkCloudConfigApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6780 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/NetworkCloudConfigListApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6731 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/NetworkControllerApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6771 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/NetworkControllerListApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6911 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/NodeSchedulableStatusApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6668 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/RouteTableApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6708 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/RouteTableListApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6695 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/RoutingPolicyApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6735 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/RoutingPolicyListApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6949 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/RoutingPolicyMatchConditionprotocol_parameters.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6632 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/SubnetApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6774 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/SubnetListApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6685 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/TaskReferenceApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6695 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/TrafficMirrorApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6735 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/TrafficMirrorListApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6668 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/UplinkBondApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6708 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/UplinkBondListApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6695 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/VirtualSwitchApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6851 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/VirtualSwitchListApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6605 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/VpcApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6741 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/VpcListApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6804 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/VpcVirtualSwitchMappingsApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6695 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/VpnConnectionApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6735 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/VpnConnectionListApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6705 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/VpnVendorListApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:03.538499 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/error/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6645 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/error/ErrorResponseerror.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/error/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:03.539500 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/stats/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6737 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/stats/Layer2StretchStatsApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6684 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/stats/TaskReferenceApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6737 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/stats/TrafficMirrorStatsApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6665 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/stats/VpcNsStatsApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6737 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/stats/VpnConnectionStatsApiResponsedata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/stats/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    30701 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:03.539500 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/common/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/common/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:03.539500 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/common/v1/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/common/v1/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:03.542499 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/common/v1/config/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8006 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/common/v1/config/EntityReference.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     5692 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/common/v1/config/EntityType.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6716 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/common/v1/config/Flag.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7281 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/common/v1/config/IPAddress.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7560 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/common/v1/config/IPv4Address.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8338 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/common/v1/config/IPv6Address.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7154 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/common/v1/config/KVPair.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7888 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/common/v1/config/Message.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4716 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/common/v1/config/MessageSeverity.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    10632 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/common/v1/config/Metadata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7375 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/common/v1/config/TenantAwareModel.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/common/v1/config/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:03.543500 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/common/v1/response/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7022 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/common/v1/response/ApiLink.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    10270 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/common/v1/response/ApiResponseMetadata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     5869 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/common/v1/response/ExternalizableAbstractModel.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/common/v1/response/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:03.543500 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/common/v1/stats/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4915 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/common/v1/stats/DownSamplingOperator.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/common/v1/stats/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:03.543500 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:03.543500 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:03.582500 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     9696 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/Address.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4784 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/AddressType.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7307 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/AddressTypeObject.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     9449 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/Anc.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7410 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/AncConfigApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7291 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/AssignedAddress.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     5016 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/AuthenticationAlgorithm.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4756 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/AuthenticationType.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     9900 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/AuthorizationData.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    10220 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/AzureConfig.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    10951 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/AzureExternalSubnetBinding.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8715 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/AzureExternalSubnetConfig.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8070 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/BgpConfig.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7599 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/BgpInfo.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    14722 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/BgpSession.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7442 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/BgpSessionApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7570 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/BgpSessionListApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6606 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/BgpSessionProjection.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4911 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/BondModeType.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6569 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/Bridge.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     5156 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/BridgeProjection.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7297 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/Capability.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6274 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/CloudNetwork.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7462 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/CloudNetworkApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7486 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/CloudNetworkListApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4720 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/CloudSubstrate.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8361 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/Cluster.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6398 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/ClusterCapability.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7497 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/ClusterCapabilityApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6712 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/ClusterFlowStatus.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7504 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/ClusterFlowStatusApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7641 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/ClusterStatus.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4883 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/ControllerStatus.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4843 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/DefaultVlanStack.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    10412 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/DhcpOptions.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7838 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/DpdConfig.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4893 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/DpdOperation.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4866 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/EncryptionAlgorithm.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7163 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/ExportScope.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4796 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/ExporterProtocol.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     9625 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/ExternalSubnet.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7335 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/FloatingIPAddress.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7598 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/FloatingIPv4Address.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8376 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/FloatingIPv6Address.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    14817 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/FloatingIp.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7442 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/FloatingIpApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7570 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/FloatingIpListApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8673 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/FloatingIpProjection.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8530 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/FlowGateway.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7452 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/FlowGatewayApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7439 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/FlowGatewayKeepAlive.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7546 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/FlowGatewayKeepAliveApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     9904 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/FlowGatewayKeepAliveRequestSpec.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7476 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/FlowGatewayListApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4930 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/FlowGatewayState.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6866 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/FlowGatewayStatus.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    14396 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/Gateway.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7411 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/GatewayApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8783 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/GatewayDeployment.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7536 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/GatewayListApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    10073 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/GatewayManagementInterface.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7726 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/GatewayNic.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7298 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/GatewayNodeReference.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7692 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/GatewayProjection.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4798 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/GatewayRole.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     9616 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/Host.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7429 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/ICMPObject.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7215 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/IPConfig.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    10000 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/IPFIXExporter.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7472 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/IPFIXExporterApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7496 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/IPFIXExporterListApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7935 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/IPPoolUsage.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7198 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/IPSubnet.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8878 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/IPUsage.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8857 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/IPv4Config.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7021 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/IPv4Pool.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7345 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/IPv4Subnet.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8857 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/IPv6Config.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7021 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/IPv6Pool.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7347 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/IPv6Subnet.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4458 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/IbgpConfig.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8378 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/InternalRoutingConfig.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     9265 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/IpReserveSpec.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     9327 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/IpUnreserveSpec.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    15959 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/IpsecConfig.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    11419 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/Layer2Stretch.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7473 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/Layer2StretchApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7497 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/Layer2StretchListApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8279 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/Layer2StretchRelatedEntities.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7634 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/Layer2StretchRelatedEntitiesApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    10084 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/Layer2StretchSubnetInfo.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     9868 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/Layer2StretchVpnConnectionInfo.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    10773 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/Layer2StretchVtepGatewayInfo.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7466 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/LayerFourProtocolObject.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7890 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/LearnedAddress.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7730 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/LocalBgpGateway.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7728 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/LocalBgpService.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     9098 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/LocalNetworkServices.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7257 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/LocalVpnService.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6708 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/LocalVtepService.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4794 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/MigrationState.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4868 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/NetworkCloudConfig.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7516 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/NetworkCloudConfigApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7540 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/NetworkCloudConfigListApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8949 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/NetworkController.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7504 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/NetworkControllerApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7528 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/NetworkControllerListApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4632 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/NetworkingBaseModel.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     5066 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/NexthopType.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7566 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/NodeSchedulableStatus.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7659 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/NodeSchedulableStatusApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4084 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/NodeSchedulableStatusProjection.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8041 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/OspfConfig.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7599 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/PortRange.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7634 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/PrivateIpAssociation.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6788 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/ProtocolNumberObject.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4994 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/ProtocolType.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7112 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/PublicIpMapping.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7093 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/QosConfig.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6867 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/RemoteBgpGateway.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7383 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/RemoteBgpService.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8375 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/RemoteNetworkServices.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     9227 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/RemoteVpnService.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7345 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/RemoteVtepService.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7784 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/RemoteVtepStretchStatus.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     5212 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/RerouteFallbackAction.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7537 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/RerouteParam.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4969 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/ReserveType.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6452 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/ReservedAddress.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    12035 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/Route.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8633 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/RouteTable.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7442 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/RouteTableApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7466 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/RouteTableListApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8511 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/RoutingPolicy.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7419 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/RoutingPolicyAction.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4956 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/RoutingPolicyActionType.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7473 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/RoutingPolicyApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7497 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/RoutingPolicyListApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     9549 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/RoutingPolicyMatchCondition.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8432 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/RoutingPolicyRule.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4758 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/ScopeType.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    12065 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/SiteParams.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4670 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/State.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6712 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/Status.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4865 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/StretchConnectionType.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8625 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/StretchStatus.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    24167 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/Subnet.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7401 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/SubnetApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6678 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/SubnetInfo.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7525 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/SubnetListApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     9370 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/SubnetProjection.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4656 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/SubnetType.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7478 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/TaskReferenceApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    10166 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/TrafficMirror.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7472 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/TrafficMirrorApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7496 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/TrafficMirrorListApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8066 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/TrafficMirrorPort.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4900 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/TrafficMirrorPortNicType.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4919 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/TrafficMirrorSourcePort.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     5152 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/TrafficMirrorSourcePortDirection.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4950 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/UnreserveType.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     9759 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/UplinkBond.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7442 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/UplinkBondApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4918 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/UplinkBondLacpStatus.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7466 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/UplinkBondListApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4961 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/UplinkBondType.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7234 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/UplinkBondVirtualSwitchInfo.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     9957 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/VirtualSwitch.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7473 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/VirtualSwitchApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7604 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/VirtualSwitchListApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6688 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/VirtualSwitchProjection.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6590 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/VlanSubnetMigrationSpec.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6052 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/Vm.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6186 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/VmNic.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7882 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/VmNicAssociation.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     3660 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/VmNicProjection.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     3580 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/VmProjection.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8685 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/VnicMigrationItem.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6770 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/VnicMigrationSpec.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    10883 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/Vpc.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7371 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/VpcApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6638 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/VpcDhcpOptions.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7492 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/VpcListApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7080 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/VpcProjection.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7125 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/VpcVirtualSwitchMapping.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7574 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/VpcVirtualSwitchMappingsApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     5150 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/VpnAppliance.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    16168 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/VpnConnection.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7472 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/VpnConnectionApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7496 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/VpnConnectionListApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7490 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/VpnVendorListApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6246 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/Vtep.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:03.583500 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/error/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8951 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/error/AppMessage.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6684 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/error/ErrorResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8711 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/error/SchemaValidationError.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7328 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/error/SchemaValidationErrorMessage.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/error/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:03.585500 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/stats/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6236 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/stats/Layer2StretchStats.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7512 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/stats/Layer2StretchStatsApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7107 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/stats/RoutingPolicyClearCountersSpec.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     5662 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/stats/StatsQueryResponseBase.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7478 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/stats/TaskReferenceApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4867 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/stats/TrafficMirrorState.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6730 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/stats/TrafficMirrorStats.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7511 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/stats/TrafficMirrorStatsApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7482 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/stats/TrafficMirrorStatsData.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    12419 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/stats/VpcNsStats.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7455 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/stats/VpcNsStatsApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     5730 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/stats/VpnConnectionStats.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7511 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/stats/VpnConnectionStatsApiResponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/stats/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:03.586500 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/prism/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/prism/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:03.586500 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/prism/v4/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/prism/v4/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:03.586500 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/prism/v4/config/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6719 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/prism/v4/config/TaskReference.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/prism/v4/config/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    15963 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/rest.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-09-18 22:30:03.522499 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client.egg-info/
--rw-r--r--   0 circleci  (3434) circleci  (3434)    11689 2023-09-18 22:30:03.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client.egg-info/PKG-INFO
--rw-r--r--   0 circleci  (3434) circleci  (3434)    24982 2023-09-18 22:30:03.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client.egg-info/SOURCES.txt
--rw-r--r--   0 circleci  (3434) circleci  (3434)        1 2023-09-18 22:30:03.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client.egg-info/dependency_links.txt
--rw-r--r--   0 circleci  (3434) circleci  (3434)       78 2023-09-18 22:30:03.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client.egg-info/requires.txt
--rw-r--r--   0 circleci  (3434) circleci  (3434)       26 2023-09-18 22:30:03.000000 ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client.egg-info/top_level.txt
--rw-r--r--   0 circleci  (3434) circleci  (3434)       38 2023-09-18 22:30:03.587499 ntnx-networking-py-client-4.0.1b1/setup.cfg
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1316 2023-09-18 22:29:53.000000 ntnx-networking-py-client-4.0.1b1/setup.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:43.107556 ntnx_networking_py_client-4.0.2b1/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    18137 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/LICENSE.txt
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    11861 2024-05-17 07:11:43.106556 ntnx_networking_py_client-4.0.2b1/PKG-INFO
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    11412 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/README.md
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:43.033556 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    31731 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:43.040556 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2024 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    28284 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api/bgp_sessions_api.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6368 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api/bridges_api.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6989 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api/cluster_capabilities_api.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    28401 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api/floating_ips_api.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    33646 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api/gateways_api.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    24909 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api/ipfix_exporters_api.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     9966 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api/layer2_stretch_stats_api.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    32760 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api/layer2_stretches_api.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    26019 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api/network_controllers_api.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    17068 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api/route_tables_api.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    29363 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api/routing_policies_api.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6037 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api/routing_policy_stats_api.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    12055 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api/subnet_ip_reservation_api.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    29030 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api/subnets_api.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8914 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api/traffic_mirror_stats_api.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    27594 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api/traffic_mirrors_api.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    12264 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api/uplink_bonds_api.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5586 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api/virtual_switch_nodes_info_api.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    27314 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api/virtual_switches_api.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    10617 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api/vpc_ns_stats_api.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    12123 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api/vpc_virtual_switch_mappings_api.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    27920 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api/vpcs_api.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     9934 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api/vpn_connection_stats_api.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    38892 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api/vpn_connections_api.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    59531 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api_client.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2429 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api_response.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    16679 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/configuration.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:43.040556 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:43.041556 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfcommon/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfcommon/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:43.041556 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfcommon/v1/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfcommon/v1/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:43.041556 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfcommon/v1/config/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6975 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfcommon/v1/config/KVPairvalue.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfcommon/v1/config/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:43.041556 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:43.042556 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:43.051556 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7149 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/FloatingIpProjectionassociation.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7079 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/FloatingIpassociation.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7114 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/GatewayProjectionservices.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7044 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/Gatewayservices.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7093 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/GetBgpSessionApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7093 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/GetFloatingIpApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7066 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/GetGatewayApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7120 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/GetIPFIXExporterApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7120 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/GetLayer2StretchApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7156 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/GetNetworkControllerApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7093 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/GetRouteTableApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7120 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/GetRoutingPolicyApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7057 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/GetSubnetApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7120 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/GetTrafficMirrorApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7093 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/GetUplinkBondApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7120 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/GetVirtualSwitchApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7030 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/GetVpcApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7120 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/GetVpnConnectionApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7229 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListBgpSessionsApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7189 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListClusterCapabilitiesApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7229 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListFloatingIpsApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7196 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListGatewaysApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7146 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListIPFIXExportersApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7262 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListLayer2StretchRelatedEntitiesApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7153 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListLayer2StretchesApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7182 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListNetworkControllersApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7357 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListNodeSchedulableStatusesApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7119 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListRouteTablesApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7269 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListRoutingPoliciesApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7185 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListSubnetsApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7146 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListTrafficMirrorsApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7119 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListUplinkBondsApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7269 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListVirtualSwitchesApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7236 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListVpcVirtualSwitchMappingsApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7152 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListVpcsApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7146 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListVpnConnectionsApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7158 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListVpnVendorConfigsApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7353 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/RoutingPolicyMatchConditionprotocol_parameters.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7089 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/TaskReferenceApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:43.051556 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/error/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7049 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/error/ErrorResponseerror.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/error/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:43.053556 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/stats/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7162 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/stats/GetLayer2StretchStatsApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7162 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/stats/GetTrafficMirrorStatsApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7090 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/stats/GetVpcNsStatsApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7162 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/stats/GetVpnConnectionStatsApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7088 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/stats/TaskReferenceApiResponsedata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/stats/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    29684 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:43.053556 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/common/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/common/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:43.053556 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/common/v1/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/common/v1/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:43.056556 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/common/v1/config/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8380 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/common/v1/config/EntityReference.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6029 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/common/v1/config/EntityType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7101 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/common/v1/config/Flag.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7661 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/common/v1/config/IPAddress.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7938 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/common/v1/config/IPv4Address.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8716 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/common/v1/config/IPv6Address.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7537 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/common/v1/config/KVPair.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8270 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/common/v1/config/Message.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5164 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/common/v1/config/MessageSeverity.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    11013 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/common/v1/config/Metadata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7750 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/common/v1/config/TenantAwareModel.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/common/v1/config/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:43.057556 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/common/v1/response/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7402 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/common/v1/response/ApiLink.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    10658 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/common/v1/response/ApiResponseMetadata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6136 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/common/v1/response/ExternalizableAbstractModel.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/common/v1/response/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:43.057556 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/common/v1/stats/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5535 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/common/v1/stats/DownSamplingOperator.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/common/v1/stats/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:43.057556 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:43.058556 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:43.101556 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    10074 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/Address.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5116 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/AddressType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7675 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/AddressTypeObject.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     9736 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/Anc.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7661 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/AssignedAddress.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5336 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/AuthenticationAlgorithm.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5081 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/AuthenticationType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    10268 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/AuthorizationData.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7312 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/AwsConfig.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8101 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/AwsExternalSubnetConfig.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    10034 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/AwsSubnetConfig.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    10594 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/AzureConfig.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    11310 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/AzureExternalSubnetBinding.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     9075 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/AzureExternalSubnetConfig.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8446 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/BgpConfig.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8196 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/BgpInfo.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    16136 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/BgpSession.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7210 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/BgpSessionProjection.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5242 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/BondModeType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8344 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/Bridge.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6006 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/BridgeProjection.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7672 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/Capability.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6552 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/CloudNetwork.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5117 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/CloudSubstrate.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8739 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/Cluster.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6671 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ClusterCapability.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7080 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ClusterFlowStatus.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8219 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ClusterStatus.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5210 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ControllerStatus.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5170 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/DefaultVlanStack.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    10786 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/DhcpOptions.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8214 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/DpdConfig.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5224 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/DpdOperation.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5306 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/EncryptionAlgorithm.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7537 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ExportScope.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5123 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ExporterProtocol.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    12388 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ExternalSubnet.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7703 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/FloatingIPAddress.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7964 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/FloatingIPv4Address.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8742 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/FloatingIPv6Address.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    15188 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/FloatingIp.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8943 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/FloatingIpProjection.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8809 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/FlowGateway.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7804 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/FlowGatewayKeepAlive.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    10258 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/FlowGatewayKeepAliveRequestSpec.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5257 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/FlowGatewayState.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7234 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/FlowGatewayStatus.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    14679 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/Gateway.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     9998 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/GatewayDeployment.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    10491 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/GatewayInterface.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    10432 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/GatewayManagementInterface.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8388 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/GatewayNic.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7663 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/GatewayNodeReference.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7965 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/GatewayProjection.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5130 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/GatewayRole.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7827 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/GetBgpSessionApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7827 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/GetFloatingIpApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7799 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/GetGatewayApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7854 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/GetIPFIXExporterApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7855 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/GetLayer2StretchApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7882 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/GetNetworkControllerApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7827 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/GetRouteTableApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7855 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/GetRoutingPolicyApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7790 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/GetSubnetApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7854 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/GetTrafficMirrorApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7827 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/GetUplinkBondApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7855 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/GetVirtualSwitchApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7763 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/GetVpcApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7854 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/GetVpnConnectionApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     9997 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/Host.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7804 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ICMPObject.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7592 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/IPConfig.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    10277 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/IPFIXExporter.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8309 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/IPPoolUsage.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7575 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/IPSubnet.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     9256 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/IPUsage.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     9232 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/IPv4Config.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7398 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/IPv4Pool.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7720 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/IPv4Subnet.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     9232 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/IPv6Config.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7398 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/IPv6Pool.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7722 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/IPv6Subnet.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     4738 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/IbgpConfig.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8742 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/InternalRoutingConfig.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     9637 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/IpReserveSpec.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     9697 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/IpUnreserveSpec.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    16333 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/IpsecConfig.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    11696 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/Layer2Stretch.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8636 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/Layer2StretchRelatedEntities.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    10446 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/Layer2StretchSubnetInfo.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    10223 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/Layer2StretchVpnConnectionInfo.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    11130 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/Layer2StretchVtepGatewayInfo.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7828 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/LayerFourProtocolObject.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8261 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/LearnedAddress.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7937 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ListBgpSessionsApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7896 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ListClusterCapabilitiesApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7937 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ListFloatingIpsApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7906 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ListGatewaysApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7860 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ListIPFIXExportersApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8008 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ListLayer2StretchRelatedEntitiesApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7868 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ListLayer2StretchesApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7888 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ListNetworkControllersApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8054 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ListNodeSchedulableStatusesApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7833 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ListRouteTablesApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7975 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ListRoutingPoliciesApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7896 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ListSubnetsApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7860 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ListTrafficMirrorsApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7833 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ListUplinkBondsApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7975 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ListVirtualSwitchesApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7952 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ListVpcVirtualSwitchMappingsApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7866 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ListVpcsApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7860 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ListVpnConnectionsApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7900 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ListVpnVendorConfigsApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8394 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/LocalBgpGateway.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8276 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/LocalBgpService.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    10336 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/LocalNetworkServices.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7627 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/LocalVpnService.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7077 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/LocalVtepService.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5123 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/MigrationState.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5758 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/NetworkCloudConfig.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     9222 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/NetworkController.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     4903 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/NetworkingBaseModel.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5398 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/NexthopType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7893 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/NodeSchedulableStatus.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     4343 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/NodeSchedulableStatusProjection.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8416 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/OspfConfig.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7975 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/PortRange.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7999 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/PrivateIpAssociation.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7153 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ProtocolNumberObject.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5325 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ProtocolType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7482 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/PublicIpMapping.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7469 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/QosConfig.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7423 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/RemoteBgpGateway.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7752 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/RemoteBgpService.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8739 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/RemoteNetworkServices.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     9596 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/RemoteVpnService.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7713 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/RemoteVtepService.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8146 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/RemoteVtepStretchStatus.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5534 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/RerouteFallbackAction.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     9289 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/RerouteParam.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5301 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ReserveType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6822 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ReservedAddress.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    12415 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/Route.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8913 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/RouteTable.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     9372 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/RoutingPolicy.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8633 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/RoutingPolicyAction.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5357 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/RoutingPolicyActionType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     9907 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/RoutingPolicyMatchCondition.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5857 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/RoutingPolicyProjection.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8800 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/RoutingPolicyRule.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5092 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ScopeType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    12440 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/SiteParams.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5008 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/State.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7091 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/Status.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5187 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/StretchConnectionType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8997 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/StretchStatus.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    24451 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/Subnet.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7053 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/SubnetInfo.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     9644 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/SubnetProjection.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     4989 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/SubnetType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7839 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/TaskReferenceApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    11750 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/TrafficMirror.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8415 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/TrafficMirrorPort.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5219 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/TrafficMirrorPortNicType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5186 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/TrafficMirrorSourcePort.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5463 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/TrafficMirrorSourcePortDirection.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5280 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/UnreserveType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    10039 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/UplinkBond.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5249 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/UplinkBondLacpStatus.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5290 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/UplinkBondType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7592 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/UplinkBondVirtualSwitchInfo.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    10234 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/VirtualSwitch.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6956 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/VirtualSwitchProjection.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6930 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/VlanSubnetMigrationSpec.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6435 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/Vm.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6566 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/VmNic.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8251 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/VmNicAssociation.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     3935 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/VmNicProjection.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     3858 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/VmProjection.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     9053 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/VnicMigrationItem.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6245 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/VnicMigrationItemSpec.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7138 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/VnicMigrationSpec.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    11843 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/Vpc.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7009 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/VpcDhcpOptions.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6429 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/VpcName.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     3886 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/VpcNameProjection.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7629 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/VpcProjection.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     4983 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/VpcType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7597 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/VpcVirtualSwitchMapping.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5428 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/VpnAppliance.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    16536 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/VpnConnection.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6627 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/Vtep.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:43.102556 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/error/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     9906 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/error/AppMessage.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7057 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/error/ErrorResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     9432 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/error/SchemaValidationError.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8130 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/error/SchemaValidationErrorMessage.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/error/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:43.105556 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/stats/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7890 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/stats/GetLayer2StretchStatsApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7889 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/stats/GetTrafficMirrorStatsApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7841 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/stats/GetVpcNsStatsApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7889 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/stats/GetVpnConnectionStatsApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6591 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/stats/Layer2StretchStats.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7463 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/stats/RoutingPolicyClearCountersSpec.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5931 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/stats/StatsQueryResponseBase.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7840 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/stats/TaskReferenceApiResponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5193 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/stats/TrafficMirrorState.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7003 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/stats/TrafficMirrorStats.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7846 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/stats/TrafficMirrorStatsData.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    12700 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/stats/VpcNsStats.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6085 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/stats/VpnConnectionStats.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/stats/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:43.105556 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/prism/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/prism/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:43.105556 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/prism/v4/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/prism/v4/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:43.106556 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/prism/v4/config/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7098 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/prism/v4/config/TaskReference.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/prism/v4/config/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    16587 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/rest.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2024-05-17 07:11:43.106556 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client.egg-info/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    11861 2024-05-17 07:11:42.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client.egg-info/PKG-INFO
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    24250 2024-05-17 07:11:43.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client.egg-info/SOURCES.txt
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        1 2024-05-17 07:11:42.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client.egg-info/dependency_links.txt
+-rw-r--r--   0 circleci  (3434) circleci  (3434)       91 2024-05-17 07:11:42.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client.egg-info/requires.txt
+-rw-r--r--   0 circleci  (3434) circleci  (3434)       26 2024-05-17 07:11:42.000000 ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client.egg-info/top_level.txt
+-rw-r--r--   0 circleci  (3434) circleci  (3434)       38 2024-05-17 07:11:43.107556 ntnx_networking_py_client-4.0.2b1/setup.cfg
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1328 2024-05-17 07:11:37.000000 ntnx_networking_py_client-4.0.2b1/setup.py
```

### Comparing `ntnx-networking-py-client-4.0.1b1/LICENSE.txt` & `ntnx_networking_py_client-4.0.2b1/LICENSE.txt`

 * *Files identical despite different names*

### Comparing `ntnx-networking-py-client-4.0.1b1/PKG-INFO` & `ntnx_networking_py_client-4.0.2b1/PKG-INFO`

 * *Files 3% similar despite different names*

```diff
@@ -1,37 +1,37 @@
 Metadata-Version: 2.1
 Name: ntnx-networking-py-client
-Version: 4.0.1b1
+Version: 4.0.2b1
 Summary: Nutanix Networking Versioned APIs
 Home-page: 
 Author-email: sdk@nutanix.com
 Keywords: Nutanix,v4,SDK,Nutanix Networking Versioned APIs
 Description-Content-Type: text/markdown
 License-File: LICENSE.txt
 Requires-Dist: urllib3~=1.26
 Requires-Dist: six~=1.16
-Requires-Dist: certifi==2020.4.5.1
+Requires-Dist: certifi<=2023.11.17,>=2020.4.5.1
 Requires-Dist: python-dateutil~=2.8
 Requires-Dist: pysocks~=1.7
 
 # Python Client For Nutanix Networking Versioned APIs
 
 The Python client for Nutanix Networking Versioned APIs is designed for Python client application developers offering them simple and flexible access to APIs that manage networking configuration on Nutanix clusters, including AHV and advanced networking.
 ## Features
 - Invoke Nutanix APIs with a simple interface.
 - Handle Authentication seamlessly.
 - Reduce boilerplate code implementation.
 - Use standard methods for installation.
 
 ## Version
 - API version: v4.0.b1
-- Package version: 4.0.1b1
+- Package version: 4.0.2b1
 
 ## Requirements.
-Python 3.6, 3.7, and 3.8 are fully supported and tested.
+Python 3.6, 3.7, 3.8 and 3.9 are fully supported and tested.
 
 
 ## Installation & Usage
 
 ### Installing in a virtual environment
 [virtualenv](https://virtualenv.pypa.io/en/latest/) is a tool to create isolated Python environments. The basic problem it addresses is one of dependencies and versions, and indirectly permissions. virtualenv can help you install this client without needing system install permissions. It creates an environment that has its own installation directories without sharing libraries with other virtualenv environments or the system installation.
 
@@ -85,14 +85,15 @@
 | debug     | Runs the client in debug mode if specified                                       | No       | False        |
 | verify_ssl| Verify SSL certificate of cluster the client will connect to                     | No       | True         |
 | max_retry_attempts| Maximum number of retry attempts while connecting to the cluster         | No       | 5            |
 | backoff_factor| A backoff factor to apply between attempts after the second try.             | No       | 3            |
 | logger_file | File location to which debug logs are written to                               | No       | N/A          |
 | connect_timeout | Connection timeout in milliseconds for all operations                      | No       | 30000        |
 | read_timeout | Read timeout in milliseconds for all operations                               | No       | 30000        |
+| download_directory| Directory where downloaded files will be stored in                       | No       | Current Working Directory|
 
 
 ### Sample Configuration
 ```python
 config = Configuration()
 config.host = '10.19.50.27' # IPv4/IPv6 address or FQDN of the cluster
 config.port = 9440 # Port to which to connect to
@@ -142,66 +143,66 @@
 ```
 
 ## Usage
 
 ### Invoking an operation
 ```python
 # Initialize the API
-flow_gateway_api_instance = FlowGatewayApi(api_client=client) # client configured in previous step
+flow_gateways_api_instance = FlowGatewaysApi(api_client=client) # client configured in previous step
 extId = 'extId_example' # UUID.
 
 # Get the Atlas Flow Gateway with the specified UUID.
 try:
-    api_response = flow_gateway_api_instance.get_atlas_flow_gateway(extId)
+    api_response = flow_gateways_api_instance.get_flow_gateway_by_id(extId)
 except ApiException as e:
 ```
 
 ### Setting headers for individual operations
 Headers can be configured globally on the python client using the [method to set default headers](#additional-headers). However, sometimes headers need to be set on an individual operation basis. Nutanix APIs require that concurrent updates are protected using [ETag headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag).
 
 ```python
 # Initialize the API
-flow_gateway_api_instance = FlowGatewayApi(api_client=client) # client configured in previous step
+flow_gateways_api_instance = FlowGatewaysApi(api_client=client) # client configured in previous step
 extId = 'extId_example' # UUID.
 
 # Get the Atlas Flow Gateway with the specified UUID.
 try:
-    api_response = flow_gateway_api_instance.get_atlas_flow_gateway(extId)
+    api_response = flow_gateways_api_instance.get_flow_gateway_by_id(extId)
 except ApiException as e:
 
 # Extract E-Tag Header
 etag_value = ApiClient.get_etag(api_response)
 
 # Update the specified Atlas Flow Gateway.
 try:
     # The body parameter in the following operation is received from the previous GET request's response which needs to be updated.
-    api_response = flow_gateway_api_instance.update_atlas_flow_gateway(body, extId, if_match=etag_value) # Use the extracted etag value
+    api_response = flow_gateways_api_instance.update_flow_gateway_by_id(body, extId, if_match=etag_value) # Use the extracted etag value
 except ApiException as e:
 ```
 
 ### List Operations
 List Operations for Nutanix APIs support pagination, filtering, sorting and projections. The table below details the parameters that can be used to set the options for pagination etc.
 
 | Parameter | Description
 |-----------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
 | _page     | specifies the page number of the result set. Must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range will lead to no results being returned.|
 | _limit    | specifies the total number of records returned in the result set. Must be a positive integer between 0 and 100. Any number out of this range will lead to a validation error. If the limit is not provided a default value of 50 records will be returned in the result set|
 | _filter   | allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the [OData V4.01 URL](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part2-url-conventions.html#sec_SystemQueryOptionfilter) conventions. |
 | _orderby  | allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified the resources will be sorted in ascending order by default. For example, 'orderby=templateName desc' would get all templates sorted by templateName in desc order. |
-| _select   | allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the OData V4.01 URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e. *), then all properties on the matching resource will be returned. |
-| _expand   | allows clients to request related resources when a resource that satisfies a particular request is retrieved. Each expand item is evaluated relative to the entity containing the property being expanded. Other query options can be applied to an expanded property by appending a semicolon-separated list of query options, enclosed in parentheses, to the property name. Allowed system query options are $filter,$select, $orderby. |
+| _select   | allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the OData V4.01 URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e., *), then all properties on the matching resource will be returned. |
+| _expand   | allows clients to request related resources when a resource that satisfies a particular request is retrieved. Each expanded item is evaluated relative to the entity containing the property being expanded. Other query options can be applied to an expanded property by appending a semicolon-separated list of query options, enclosed in parentheses, to the property name. Permissible system query options are $filter,$select and $orderby. |
 
 ```python
 # Initialize the API
-bgp_session_api_instance = BgpSessionApi(api_client=client) # client configured in previous step
+bgp_sessions_api_instance = BgpSessionsApi(api_client=client) # client configured in previous step
 extId = 'extId_example' # UUID.
 
 # List BGP sessions request.
 try:
-    api_response = bgp_session_api_instance.list_bgp_sessions(
+    api_response = bgp_sessions_api_instance.list_bgp_sessions(
 	                   _page=page, # if page parameter is present
 	                   _limit=limit, # if limit parameter is present
 	                   _filter=_filter, # if filter parameter is present
 	                   _orderby=_orderby, # if orderby parameter is present
 	                   _select=select, # if select parameter is present
 	                   _expand=expand) # if expand parameter is present
 except ApiException as e:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/README.md` & `ntnx_networking_py_client-4.0.2b1/README.md`

 * *Files 2% similar despite different names*

```diff
@@ -5,18 +5,18 @@
 - Invoke Nutanix APIs with a simple interface.
 - Handle Authentication seamlessly.
 - Reduce boilerplate code implementation.
 - Use standard methods for installation.
 
 ## Version
 - API version: v4.0.b1
-- Package version: 4.0.1b1
+- Package version: 4.0.2b1
 
 ## Requirements.
-Python 3.6, 3.7, and 3.8 are fully supported and tested.
+Python 3.6, 3.7, 3.8 and 3.9 are fully supported and tested.
 
 
 ## Installation & Usage
 
 ### Installing in a virtual environment
 [virtualenv](https://virtualenv.pypa.io/en/latest/) is a tool to create isolated Python environments. The basic problem it addresses is one of dependencies and versions, and indirectly permissions. virtualenv can help you install this client without needing system install permissions. It creates an environment that has its own installation directories without sharing libraries with other virtualenv environments or the system installation.
 
@@ -70,14 +70,15 @@
 | debug     | Runs the client in debug mode if specified                                       | No       | False        |
 | verify_ssl| Verify SSL certificate of cluster the client will connect to                     | No       | True         |
 | max_retry_attempts| Maximum number of retry attempts while connecting to the cluster         | No       | 5            |
 | backoff_factor| A backoff factor to apply between attempts after the second try.             | No       | 3            |
 | logger_file | File location to which debug logs are written to                               | No       | N/A          |
 | connect_timeout | Connection timeout in milliseconds for all operations                      | No       | 30000        |
 | read_timeout | Read timeout in milliseconds for all operations                               | No       | 30000        |
+| download_directory| Directory where downloaded files will be stored in                       | No       | Current Working Directory|
 
 
 ### Sample Configuration
 ```python
 config = Configuration()
 config.host = '10.19.50.27' # IPv4/IPv6 address or FQDN of the cluster
 config.port = 9440 # Port to which to connect to
@@ -127,66 +128,66 @@
 ```
 
 ## Usage
 
 ### Invoking an operation
 ```python
 # Initialize the API
-flow_gateway_api_instance = FlowGatewayApi(api_client=client) # client configured in previous step
+flow_gateways_api_instance = FlowGatewaysApi(api_client=client) # client configured in previous step
 extId = 'extId_example' # UUID.
 
 # Get the Atlas Flow Gateway with the specified UUID.
 try:
-    api_response = flow_gateway_api_instance.get_atlas_flow_gateway(extId)
+    api_response = flow_gateways_api_instance.get_flow_gateway_by_id(extId)
 except ApiException as e:
 ```
 
 ### Setting headers for individual operations
 Headers can be configured globally on the python client using the [method to set default headers](#additional-headers). However, sometimes headers need to be set on an individual operation basis. Nutanix APIs require that concurrent updates are protected using [ETag headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag).
 
 ```python
 # Initialize the API
-flow_gateway_api_instance = FlowGatewayApi(api_client=client) # client configured in previous step
+flow_gateways_api_instance = FlowGatewaysApi(api_client=client) # client configured in previous step
 extId = 'extId_example' # UUID.
 
 # Get the Atlas Flow Gateway with the specified UUID.
 try:
-    api_response = flow_gateway_api_instance.get_atlas_flow_gateway(extId)
+    api_response = flow_gateways_api_instance.get_flow_gateway_by_id(extId)
 except ApiException as e:
 
 # Extract E-Tag Header
 etag_value = ApiClient.get_etag(api_response)
 
 # Update the specified Atlas Flow Gateway.
 try:
     # The body parameter in the following operation is received from the previous GET request's response which needs to be updated.
-    api_response = flow_gateway_api_instance.update_atlas_flow_gateway(body, extId, if_match=etag_value) # Use the extracted etag value
+    api_response = flow_gateways_api_instance.update_flow_gateway_by_id(body, extId, if_match=etag_value) # Use the extracted etag value
 except ApiException as e:
 ```
 
 ### List Operations
 List Operations for Nutanix APIs support pagination, filtering, sorting and projections. The table below details the parameters that can be used to set the options for pagination etc.
 
 | Parameter | Description
 |-----------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
 | _page     | specifies the page number of the result set. Must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range will lead to no results being returned.|
 | _limit    | specifies the total number of records returned in the result set. Must be a positive integer between 0 and 100. Any number out of this range will lead to a validation error. If the limit is not provided a default value of 50 records will be returned in the result set|
 | _filter   | allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the [OData V4.01 URL](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part2-url-conventions.html#sec_SystemQueryOptionfilter) conventions. |
 | _orderby  | allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified the resources will be sorted in ascending order by default. For example, 'orderby=templateName desc' would get all templates sorted by templateName in desc order. |
-| _select   | allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the OData V4.01 URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e. *), then all properties on the matching resource will be returned. |
-| _expand   | allows clients to request related resources when a resource that satisfies a particular request is retrieved. Each expand item is evaluated relative to the entity containing the property being expanded. Other query options can be applied to an expanded property by appending a semicolon-separated list of query options, enclosed in parentheses, to the property name. Allowed system query options are $filter,$select, $orderby. |
+| _select   | allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the OData V4.01 URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e., *), then all properties on the matching resource will be returned. |
+| _expand   | allows clients to request related resources when a resource that satisfies a particular request is retrieved. Each expanded item is evaluated relative to the entity containing the property being expanded. Other query options can be applied to an expanded property by appending a semicolon-separated list of query options, enclosed in parentheses, to the property name. Permissible system query options are $filter,$select and $orderby. |
 
 ```python
 # Initialize the API
-bgp_session_api_instance = BgpSessionApi(api_client=client) # client configured in previous step
+bgp_sessions_api_instance = BgpSessionsApi(api_client=client) # client configured in previous step
 extId = 'extId_example' # UUID.
 
 # List BGP sessions request.
 try:
-    api_response = bgp_session_api_instance.list_bgp_sessions(
+    api_response = bgp_sessions_api_instance.list_bgp_sessions(
 	                   _page=page, # if page parameter is present
 	                   _limit=limit, # if limit parameter is present
 	                   _filter=_filter, # if filter parameter is present
 	                   _orderby=_orderby, # if orderby parameter is present
 	                   _select=select, # if select parameter is present
 	                   _expand=expand) # if expand parameter is present
 except ApiException as e:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/__init__.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/__init__.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,109 +1,71 @@
 # coding: utf-8
 
 # flake8: noqa
 
-
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 from __future__ import absolute_import
 
-# import apis into sdk package
-from ntnx_networking_py_client.api.bgp_session_api import BgpSessionApi
-from ntnx_networking_py_client.api.bridge_api import BridgeApi
-from ntnx_networking_py_client.api.cluster_capability_api import ClusterCapabilityApi
-from ntnx_networking_py_client.api.floating_ip_api import FloatingIpApi
-from ntnx_networking_py_client.api.gateway_api import GatewayApi
-from ntnx_networking_py_client.api.ipfix_exporter_api import IPFIXExporterApi
-from ntnx_networking_py_client.api.layer2_stretch_api import Layer2StretchApi
-from ntnx_networking_py_client.api.layer2_stretch_stats_api import Layer2StretchStatsApi
-from ntnx_networking_py_client.api.network_controller_api import NetworkControllerApi
-from ntnx_networking_py_client.api.route_table_api import RouteTableApi
-from ntnx_networking_py_client.api.routing_policy_api import RoutingPolicyApi
-from ntnx_networking_py_client.api.routing_policy_stats_api import RoutingPolicyStatsApi
-from ntnx_networking_py_client.api.subnet_api import SubnetApi
-from ntnx_networking_py_client.api.subnet_reserve_unreserve_ip_api import SubnetReserveUnreserveIpApi
-from ntnx_networking_py_client.api.traffic_mirror_api import TrafficMirrorApi
-from ntnx_networking_py_client.api.traffic_mirror_stats_api import TrafficMirrorStatsApi
-from ntnx_networking_py_client.api.uplink_bond_api import UplinkBondApi
-from ntnx_networking_py_client.api.virtual_switch_api import VirtualSwitchApi
-from ntnx_networking_py_client.api.virtual_switch_node_info_api import VirtualSwitchNodeInfoApi
-from ntnx_networking_py_client.api.vpc_api import VpcApi
-from ntnx_networking_py_client.api.vpc_ns_stats_api import VpcNsStatsApi
-from ntnx_networking_py_client.api.vpc_virtual_switch_mappings_api import VpcVirtualSwitchMappingsApi
-from ntnx_networking_py_client.api.vpn_connection_api import VpnConnectionApi
-from ntnx_networking_py_client.api.vpn_connection_stats_api import VpnConnectionStatsApi
-# import ApiClient
-from ntnx_networking_py_client.api_client import ApiClient
-from ntnx_networking_py_client.configuration import Configuration
-# import models into sdk package
+# import models into model package
 from ntnx_networking_py_client.models.OneOfcommon.v1.config.KVPairvalue import KVPairvalue
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.AncConfigApiResponsedata import AncConfigApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.BgpSessionApiResponsedata import BgpSessionApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.BgpSessionListApiResponsedata import BgpSessionListApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.CloudNetworkApiResponsedata import CloudNetworkApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.CloudNetworkListApiResponsedata import CloudNetworkListApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ClusterCapabilityApiResponsedata import ClusterCapabilityApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ClusterFlowStatusApiResponsedata import ClusterFlowStatusApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.FloatingIpApiResponsedata import FloatingIpApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.FloatingIpListApiResponsedata import FloatingIpListApiResponsedata
 from ntnx_networking_py_client.models.OneOfnetworking.v4.config.FloatingIpProjectionassociation import FloatingIpProjectionassociation
 from ntnx_networking_py_client.models.OneOfnetworking.v4.config.FloatingIpassociation import FloatingIpassociation
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.FlowGatewayApiResponsedata import FlowGatewayApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.FlowGatewayKeepAliveApiResponsedata import FlowGatewayKeepAliveApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.FlowGatewayListApiResponsedata import FlowGatewayListApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.GatewayApiResponsedata import GatewayApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.GatewayListApiResponsedata import GatewayListApiResponsedata
 from ntnx_networking_py_client.models.OneOfnetworking.v4.config.GatewayProjectionservices import GatewayProjectionservices
 from ntnx_networking_py_client.models.OneOfnetworking.v4.config.Gatewayservices import Gatewayservices
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.IPFIXExporterApiResponsedata import IPFIXExporterApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.IPFIXExporterListApiResponsedata import IPFIXExporterListApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.Layer2StretchApiResponsedata import Layer2StretchApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.Layer2StretchListApiResponsedata import Layer2StretchListApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.Layer2StretchRelatedEntitiesApiResponsedata import Layer2StretchRelatedEntitiesApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.NetworkCloudConfigApiResponsedata import NetworkCloudConfigApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.NetworkCloudConfigListApiResponsedata import NetworkCloudConfigListApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.NetworkControllerApiResponsedata import NetworkControllerApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.NetworkControllerListApiResponsedata import NetworkControllerListApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.NodeSchedulableStatusApiResponsedata import NodeSchedulableStatusApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.RouteTableApiResponsedata import RouteTableApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.RouteTableListApiResponsedata import RouteTableListApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.RoutingPolicyApiResponsedata import RoutingPolicyApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.RoutingPolicyListApiResponsedata import RoutingPolicyListApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.GetBgpSessionApiResponsedata import GetBgpSessionApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.GetFloatingIpApiResponsedata import GetFloatingIpApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.GetGatewayApiResponsedata import GetGatewayApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.GetIPFIXExporterApiResponsedata import GetIPFIXExporterApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.GetLayer2StretchApiResponsedata import GetLayer2StretchApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.GetNetworkControllerApiResponsedata import GetNetworkControllerApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.GetRouteTableApiResponsedata import GetRouteTableApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.GetRoutingPolicyApiResponsedata import GetRoutingPolicyApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.GetSubnetApiResponsedata import GetSubnetApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.GetTrafficMirrorApiResponsedata import GetTrafficMirrorApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.GetUplinkBondApiResponsedata import GetUplinkBondApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.GetVirtualSwitchApiResponsedata import GetVirtualSwitchApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.GetVpcApiResponsedata import GetVpcApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.GetVpnConnectionApiResponsedata import GetVpnConnectionApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListBgpSessionsApiResponsedata import ListBgpSessionsApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListClusterCapabilitiesApiResponsedata import ListClusterCapabilitiesApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListFloatingIpsApiResponsedata import ListFloatingIpsApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListGatewaysApiResponsedata import ListGatewaysApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListIPFIXExportersApiResponsedata import ListIPFIXExportersApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListLayer2StretchRelatedEntitiesApiResponsedata import ListLayer2StretchRelatedEntitiesApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListLayer2StretchesApiResponsedata import ListLayer2StretchesApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListNetworkControllersApiResponsedata import ListNetworkControllersApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListNodeSchedulableStatusesApiResponsedata import ListNodeSchedulableStatusesApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListRouteTablesApiResponsedata import ListRouteTablesApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListRoutingPoliciesApiResponsedata import ListRoutingPoliciesApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListSubnetsApiResponsedata import ListSubnetsApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListTrafficMirrorsApiResponsedata import ListTrafficMirrorsApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListUplinkBondsApiResponsedata import ListUplinkBondsApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListVirtualSwitchesApiResponsedata import ListVirtualSwitchesApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListVpcVirtualSwitchMappingsApiResponsedata import ListVpcVirtualSwitchMappingsApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListVpcsApiResponsedata import ListVpcsApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListVpnConnectionsApiResponsedata import ListVpnConnectionsApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListVpnVendorConfigsApiResponsedata import ListVpnVendorConfigsApiResponsedata
 from ntnx_networking_py_client.models.OneOfnetworking.v4.config.RoutingPolicyMatchConditionprotocol_parameters import RoutingPolicyMatchConditionprotocol_parameters
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.SubnetApiResponsedata import SubnetApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.SubnetListApiResponsedata import SubnetListApiResponsedata
 from ntnx_networking_py_client.models.OneOfnetworking.v4.config.TaskReferenceApiResponsedata import TaskReferenceApiResponsedata as ConfigTaskReferenceApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.TrafficMirrorApiResponsedata import TrafficMirrorApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.TrafficMirrorListApiResponsedata import TrafficMirrorListApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.UplinkBondApiResponsedata import UplinkBondApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.UplinkBondListApiResponsedata import UplinkBondListApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.VirtualSwitchApiResponsedata import VirtualSwitchApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.VirtualSwitchListApiResponsedata import VirtualSwitchListApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.VpcApiResponsedata import VpcApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.VpcListApiResponsedata import VpcListApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.VpcVirtualSwitchMappingsApiResponsedata import VpcVirtualSwitchMappingsApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.VpnConnectionApiResponsedata import VpnConnectionApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.VpnConnectionListApiResponsedata import VpnConnectionListApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.VpnVendorListApiResponsedata import VpnVendorListApiResponsedata
 from ntnx_networking_py_client.models.OneOfnetworking.v4.error.ErrorResponseerror import ErrorResponseerror
-from ntnx_networking_py_client.models.OneOfnetworking.v4.stats.Layer2StretchStatsApiResponsedata import Layer2StretchStatsApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.stats.GetLayer2StretchStatsApiResponsedata import GetLayer2StretchStatsApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.stats.GetTrafficMirrorStatsApiResponsedata import GetTrafficMirrorStatsApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.stats.GetVpcNsStatsApiResponsedata import GetVpcNsStatsApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.stats.GetVpnConnectionStatsApiResponsedata import GetVpnConnectionStatsApiResponsedata
 from ntnx_networking_py_client.models.OneOfnetworking.v4.stats.TaskReferenceApiResponsedata import TaskReferenceApiResponsedata as StatsTaskReferenceApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.stats.TrafficMirrorStatsApiResponsedata import TrafficMirrorStatsApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.stats.VpcNsStatsApiResponsedata import VpcNsStatsApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.stats.VpnConnectionStatsApiResponsedata import VpnConnectionStatsApiResponsedata
 from ntnx_networking_py_client.models.common.v1.config.EntityReference import EntityReference
 from ntnx_networking_py_client.models.common.v1.config.EntityType import EntityType
 from ntnx_networking_py_client.models.common.v1.config.Flag import Flag
 from ntnx_networking_py_client.models.common.v1.config.IPAddress import IPAddress
 from ntnx_networking_py_client.models.common.v1.config.IPv4Address import IPv4Address
 from ntnx_networking_py_client.models.common.v1.config.IPv6Address import IPv6Address
 from ntnx_networking_py_client.models.common.v1.config.KVPair import KVPair
@@ -115,81 +77,83 @@
 from ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata
 from ntnx_networking_py_client.models.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel
 from ntnx_networking_py_client.models.common.v1.stats.DownSamplingOperator import DownSamplingOperator
 from ntnx_networking_py_client.models.networking.v4.config.Address import Address
 from ntnx_networking_py_client.models.networking.v4.config.AddressType import AddressType
 from ntnx_networking_py_client.models.networking.v4.config.AddressTypeObject import AddressTypeObject
 from ntnx_networking_py_client.models.networking.v4.config.Anc import Anc
-from ntnx_networking_py_client.models.networking.v4.config.AncConfigApiResponse import AncConfigApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.AssignedAddress import AssignedAddress
 from ntnx_networking_py_client.models.networking.v4.config.AuthenticationAlgorithm import AuthenticationAlgorithm
 from ntnx_networking_py_client.models.networking.v4.config.AuthenticationType import AuthenticationType
 from ntnx_networking_py_client.models.networking.v4.config.AuthorizationData import AuthorizationData
+from ntnx_networking_py_client.models.networking.v4.config.AwsConfig import AwsConfig
+from ntnx_networking_py_client.models.networking.v4.config.AwsExternalSubnetConfig import AwsExternalSubnetConfig
+from ntnx_networking_py_client.models.networking.v4.config.AwsSubnetConfig import AwsSubnetConfig
 from ntnx_networking_py_client.models.networking.v4.config.AzureConfig import AzureConfig
 from ntnx_networking_py_client.models.networking.v4.config.AzureExternalSubnetBinding import AzureExternalSubnetBinding
 from ntnx_networking_py_client.models.networking.v4.config.AzureExternalSubnetConfig import AzureExternalSubnetConfig
 from ntnx_networking_py_client.models.networking.v4.config.BgpConfig import BgpConfig
 from ntnx_networking_py_client.models.networking.v4.config.BgpInfo import BgpInfo
 from ntnx_networking_py_client.models.networking.v4.config.BgpSession import BgpSession
-from ntnx_networking_py_client.models.networking.v4.config.BgpSessionApiResponse import BgpSessionApiResponse
-from ntnx_networking_py_client.models.networking.v4.config.BgpSessionListApiResponse import BgpSessionListApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.BgpSessionProjection import BgpSessionProjection
 from ntnx_networking_py_client.models.networking.v4.config.BondModeType import BondModeType
 from ntnx_networking_py_client.models.networking.v4.config.Bridge import Bridge
 from ntnx_networking_py_client.models.networking.v4.config.BridgeProjection import BridgeProjection
 from ntnx_networking_py_client.models.networking.v4.config.Capability import Capability
 from ntnx_networking_py_client.models.networking.v4.config.CloudNetwork import CloudNetwork
-from ntnx_networking_py_client.models.networking.v4.config.CloudNetworkApiResponse import CloudNetworkApiResponse
-from ntnx_networking_py_client.models.networking.v4.config.CloudNetworkListApiResponse import CloudNetworkListApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.CloudSubstrate import CloudSubstrate
 from ntnx_networking_py_client.models.networking.v4.config.Cluster import Cluster
 from ntnx_networking_py_client.models.networking.v4.config.ClusterCapability import ClusterCapability
-from ntnx_networking_py_client.models.networking.v4.config.ClusterCapabilityApiResponse import ClusterCapabilityApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.ClusterFlowStatus import ClusterFlowStatus
-from ntnx_networking_py_client.models.networking.v4.config.ClusterFlowStatusApiResponse import ClusterFlowStatusApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.ClusterStatus import ClusterStatus
 from ntnx_networking_py_client.models.networking.v4.config.ControllerStatus import ControllerStatus
 from ntnx_networking_py_client.models.networking.v4.config.DefaultVlanStack import DefaultVlanStack
 from ntnx_networking_py_client.models.networking.v4.config.DhcpOptions import DhcpOptions
 from ntnx_networking_py_client.models.networking.v4.config.DpdConfig import DpdConfig
 from ntnx_networking_py_client.models.networking.v4.config.DpdOperation import DpdOperation
 from ntnx_networking_py_client.models.networking.v4.config.EncryptionAlgorithm import EncryptionAlgorithm
 from ntnx_networking_py_client.models.networking.v4.config.ExportScope import ExportScope
 from ntnx_networking_py_client.models.networking.v4.config.ExporterProtocol import ExporterProtocol
 from ntnx_networking_py_client.models.networking.v4.config.ExternalSubnet import ExternalSubnet
 from ntnx_networking_py_client.models.networking.v4.config.FloatingIPAddress import FloatingIPAddress
 from ntnx_networking_py_client.models.networking.v4.config.FloatingIPv4Address import FloatingIPv4Address
 from ntnx_networking_py_client.models.networking.v4.config.FloatingIPv6Address import FloatingIPv6Address
 from ntnx_networking_py_client.models.networking.v4.config.FloatingIp import FloatingIp
-from ntnx_networking_py_client.models.networking.v4.config.FloatingIpApiResponse import FloatingIpApiResponse
-from ntnx_networking_py_client.models.networking.v4.config.FloatingIpListApiResponse import FloatingIpListApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.FloatingIpProjection import FloatingIpProjection
 from ntnx_networking_py_client.models.networking.v4.config.FlowGateway import FlowGateway
-from ntnx_networking_py_client.models.networking.v4.config.FlowGatewayApiResponse import FlowGatewayApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.FlowGatewayKeepAlive import FlowGatewayKeepAlive
-from ntnx_networking_py_client.models.networking.v4.config.FlowGatewayKeepAliveApiResponse import FlowGatewayKeepAliveApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.FlowGatewayKeepAliveRequestSpec import FlowGatewayKeepAliveRequestSpec
-from ntnx_networking_py_client.models.networking.v4.config.FlowGatewayListApiResponse import FlowGatewayListApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.FlowGatewayState import FlowGatewayState
 from ntnx_networking_py_client.models.networking.v4.config.FlowGatewayStatus import FlowGatewayStatus
 from ntnx_networking_py_client.models.networking.v4.config.Gateway import Gateway
-from ntnx_networking_py_client.models.networking.v4.config.GatewayApiResponse import GatewayApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.GatewayDeployment import GatewayDeployment
-from ntnx_networking_py_client.models.networking.v4.config.GatewayListApiResponse import GatewayListApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.GatewayInterface import GatewayInterface
 from ntnx_networking_py_client.models.networking.v4.config.GatewayManagementInterface import GatewayManagementInterface
 from ntnx_networking_py_client.models.networking.v4.config.GatewayNic import GatewayNic
 from ntnx_networking_py_client.models.networking.v4.config.GatewayNodeReference import GatewayNodeReference
 from ntnx_networking_py_client.models.networking.v4.config.GatewayProjection import GatewayProjection
 from ntnx_networking_py_client.models.networking.v4.config.GatewayRole import GatewayRole
+from ntnx_networking_py_client.models.networking.v4.config.GetBgpSessionApiResponse import GetBgpSessionApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.GetFloatingIpApiResponse import GetFloatingIpApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.GetGatewayApiResponse import GetGatewayApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.GetIPFIXExporterApiResponse import GetIPFIXExporterApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.GetLayer2StretchApiResponse import GetLayer2StretchApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.GetNetworkControllerApiResponse import GetNetworkControllerApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.GetRouteTableApiResponse import GetRouteTableApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.GetRoutingPolicyApiResponse import GetRoutingPolicyApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.GetSubnetApiResponse import GetSubnetApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.GetTrafficMirrorApiResponse import GetTrafficMirrorApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.GetUplinkBondApiResponse import GetUplinkBondApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.GetVirtualSwitchApiResponse import GetVirtualSwitchApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.GetVpcApiResponse import GetVpcApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.GetVpnConnectionApiResponse import GetVpnConnectionApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.Host import Host
 from ntnx_networking_py_client.models.networking.v4.config.ICMPObject import ICMPObject
 from ntnx_networking_py_client.models.networking.v4.config.IPConfig import IPConfig
 from ntnx_networking_py_client.models.networking.v4.config.IPFIXExporter import IPFIXExporter
-from ntnx_networking_py_client.models.networking.v4.config.IPFIXExporterApiResponse import IPFIXExporterApiResponse
-from ntnx_networking_py_client.models.networking.v4.config.IPFIXExporterListApiResponse import IPFIXExporterListApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.IPPoolUsage import IPPoolUsage
 from ntnx_networking_py_client.models.networking.v4.config.IPSubnet import IPSubnet
 from ntnx_networking_py_client.models.networking.v4.config.IPUsage import IPUsage
 from ntnx_networking_py_client.models.networking.v4.config.IPv4Config import IPv4Config
 from ntnx_networking_py_client.models.networking.v4.config.IPv4Pool import IPv4Pool
 from ntnx_networking_py_client.models.networking.v4.config.IPv4Subnet import IPv4Subnet
 from ntnx_networking_py_client.models.networking.v4.config.IPv6Config import IPv6Config
@@ -197,39 +161,50 @@
 from ntnx_networking_py_client.models.networking.v4.config.IPv6Subnet import IPv6Subnet
 from ntnx_networking_py_client.models.networking.v4.config.IbgpConfig import IbgpConfig
 from ntnx_networking_py_client.models.networking.v4.config.InternalRoutingConfig import InternalRoutingConfig
 from ntnx_networking_py_client.models.networking.v4.config.IpReserveSpec import IpReserveSpec
 from ntnx_networking_py_client.models.networking.v4.config.IpUnreserveSpec import IpUnreserveSpec
 from ntnx_networking_py_client.models.networking.v4.config.IpsecConfig import IpsecConfig
 from ntnx_networking_py_client.models.networking.v4.config.Layer2Stretch import Layer2Stretch
-from ntnx_networking_py_client.models.networking.v4.config.Layer2StretchApiResponse import Layer2StretchApiResponse
-from ntnx_networking_py_client.models.networking.v4.config.Layer2StretchListApiResponse import Layer2StretchListApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.Layer2StretchRelatedEntities import Layer2StretchRelatedEntities
-from ntnx_networking_py_client.models.networking.v4.config.Layer2StretchRelatedEntitiesApiResponse import Layer2StretchRelatedEntitiesApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.Layer2StretchSubnetInfo import Layer2StretchSubnetInfo
 from ntnx_networking_py_client.models.networking.v4.config.Layer2StretchVpnConnectionInfo import Layer2StretchVpnConnectionInfo
 from ntnx_networking_py_client.models.networking.v4.config.Layer2StretchVtepGatewayInfo import Layer2StretchVtepGatewayInfo
 from ntnx_networking_py_client.models.networking.v4.config.LayerFourProtocolObject import LayerFourProtocolObject
 from ntnx_networking_py_client.models.networking.v4.config.LearnedAddress import LearnedAddress
+from ntnx_networking_py_client.models.networking.v4.config.ListBgpSessionsApiResponse import ListBgpSessionsApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.ListClusterCapabilitiesApiResponse import ListClusterCapabilitiesApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.ListFloatingIpsApiResponse import ListFloatingIpsApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.ListGatewaysApiResponse import ListGatewaysApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.ListIPFIXExportersApiResponse import ListIPFIXExportersApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.ListLayer2StretchRelatedEntitiesApiResponse import ListLayer2StretchRelatedEntitiesApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.ListLayer2StretchesApiResponse import ListLayer2StretchesApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.ListNetworkControllersApiResponse import ListNetworkControllersApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.ListNodeSchedulableStatusesApiResponse import ListNodeSchedulableStatusesApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.ListRouteTablesApiResponse import ListRouteTablesApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.ListRoutingPoliciesApiResponse import ListRoutingPoliciesApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.ListSubnetsApiResponse import ListSubnetsApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.ListTrafficMirrorsApiResponse import ListTrafficMirrorsApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.ListUplinkBondsApiResponse import ListUplinkBondsApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.ListVirtualSwitchesApiResponse import ListVirtualSwitchesApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.ListVpcVirtualSwitchMappingsApiResponse import ListVpcVirtualSwitchMappingsApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.ListVpcsApiResponse import ListVpcsApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.ListVpnConnectionsApiResponse import ListVpnConnectionsApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.ListVpnVendorConfigsApiResponse import ListVpnVendorConfigsApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.LocalBgpGateway import LocalBgpGateway
 from ntnx_networking_py_client.models.networking.v4.config.LocalBgpService import LocalBgpService
 from ntnx_networking_py_client.models.networking.v4.config.LocalNetworkServices import LocalNetworkServices
 from ntnx_networking_py_client.models.networking.v4.config.LocalVpnService import LocalVpnService
 from ntnx_networking_py_client.models.networking.v4.config.LocalVtepService import LocalVtepService
 from ntnx_networking_py_client.models.networking.v4.config.MigrationState import MigrationState
 from ntnx_networking_py_client.models.networking.v4.config.NetworkCloudConfig import NetworkCloudConfig
-from ntnx_networking_py_client.models.networking.v4.config.NetworkCloudConfigApiResponse import NetworkCloudConfigApiResponse
-from ntnx_networking_py_client.models.networking.v4.config.NetworkCloudConfigListApiResponse import NetworkCloudConfigListApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.NetworkController import NetworkController
-from ntnx_networking_py_client.models.networking.v4.config.NetworkControllerApiResponse import NetworkControllerApiResponse
-from ntnx_networking_py_client.models.networking.v4.config.NetworkControllerListApiResponse import NetworkControllerListApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.NetworkingBaseModel import NetworkingBaseModel
 from ntnx_networking_py_client.models.networking.v4.config.NexthopType import NexthopType
 from ntnx_networking_py_client.models.networking.v4.config.NodeSchedulableStatus import NodeSchedulableStatus
-from ntnx_networking_py_client.models.networking.v4.config.NodeSchedulableStatusApiResponse import NodeSchedulableStatusApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.NodeSchedulableStatusProjection import NodeSchedulableStatusProjection
 from ntnx_networking_py_client.models.networking.v4.config.OspfConfig import OspfConfig
 from ntnx_networking_py_client.models.networking.v4.config.PortRange import PortRange
 from ntnx_networking_py_client.models.networking.v4.config.PrivateIpAssociation import PrivateIpAssociation
 from ntnx_networking_py_client.models.networking.v4.config.ProtocolNumberObject import ProtocolNumberObject
 from ntnx_networking_py_client.models.networking.v4.config.ProtocolType import ProtocolType
 from ntnx_networking_py_client.models.networking.v4.config.PublicIpMapping import PublicIpMapping
@@ -242,86 +217,74 @@
 from ntnx_networking_py_client.models.networking.v4.config.RemoteVtepStretchStatus import RemoteVtepStretchStatus
 from ntnx_networking_py_client.models.networking.v4.config.RerouteFallbackAction import RerouteFallbackAction
 from ntnx_networking_py_client.models.networking.v4.config.RerouteParam import RerouteParam
 from ntnx_networking_py_client.models.networking.v4.config.ReserveType import ReserveType
 from ntnx_networking_py_client.models.networking.v4.config.ReservedAddress import ReservedAddress
 from ntnx_networking_py_client.models.networking.v4.config.Route import Route
 from ntnx_networking_py_client.models.networking.v4.config.RouteTable import RouteTable
-from ntnx_networking_py_client.models.networking.v4.config.RouteTableApiResponse import RouteTableApiResponse
-from ntnx_networking_py_client.models.networking.v4.config.RouteTableListApiResponse import RouteTableListApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.RoutingPolicy import RoutingPolicy
 from ntnx_networking_py_client.models.networking.v4.config.RoutingPolicyAction import RoutingPolicyAction
 from ntnx_networking_py_client.models.networking.v4.config.RoutingPolicyActionType import RoutingPolicyActionType
-from ntnx_networking_py_client.models.networking.v4.config.RoutingPolicyApiResponse import RoutingPolicyApiResponse
-from ntnx_networking_py_client.models.networking.v4.config.RoutingPolicyListApiResponse import RoutingPolicyListApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.RoutingPolicyMatchCondition import RoutingPolicyMatchCondition
+from ntnx_networking_py_client.models.networking.v4.config.RoutingPolicyProjection import RoutingPolicyProjection
 from ntnx_networking_py_client.models.networking.v4.config.RoutingPolicyRule import RoutingPolicyRule
 from ntnx_networking_py_client.models.networking.v4.config.ScopeType import ScopeType
 from ntnx_networking_py_client.models.networking.v4.config.SiteParams import SiteParams
 from ntnx_networking_py_client.models.networking.v4.config.State import State
 from ntnx_networking_py_client.models.networking.v4.config.Status import Status
 from ntnx_networking_py_client.models.networking.v4.config.StretchConnectionType import StretchConnectionType
 from ntnx_networking_py_client.models.networking.v4.config.StretchStatus import StretchStatus
 from ntnx_networking_py_client.models.networking.v4.config.Subnet import Subnet
-from ntnx_networking_py_client.models.networking.v4.config.SubnetApiResponse import SubnetApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.SubnetInfo import SubnetInfo
-from ntnx_networking_py_client.models.networking.v4.config.SubnetListApiResponse import SubnetListApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.SubnetProjection import SubnetProjection
 from ntnx_networking_py_client.models.networking.v4.config.SubnetType import SubnetType
 from ntnx_networking_py_client.models.networking.v4.config.TaskReferenceApiResponse import TaskReferenceApiResponse as ConfigTaskReferenceApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.TrafficMirror import TrafficMirror
-from ntnx_networking_py_client.models.networking.v4.config.TrafficMirrorApiResponse import TrafficMirrorApiResponse
-from ntnx_networking_py_client.models.networking.v4.config.TrafficMirrorListApiResponse import TrafficMirrorListApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.TrafficMirrorPort import TrafficMirrorPort
 from ntnx_networking_py_client.models.networking.v4.config.TrafficMirrorPortNicType import TrafficMirrorPortNicType
 from ntnx_networking_py_client.models.networking.v4.config.TrafficMirrorSourcePort import TrafficMirrorSourcePort
 from ntnx_networking_py_client.models.networking.v4.config.TrafficMirrorSourcePortDirection import TrafficMirrorSourcePortDirection
 from ntnx_networking_py_client.models.networking.v4.config.UnreserveType import UnreserveType
 from ntnx_networking_py_client.models.networking.v4.config.UplinkBond import UplinkBond
-from ntnx_networking_py_client.models.networking.v4.config.UplinkBondApiResponse import UplinkBondApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.UplinkBondLacpStatus import UplinkBondLacpStatus
-from ntnx_networking_py_client.models.networking.v4.config.UplinkBondListApiResponse import UplinkBondListApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.UplinkBondType import UplinkBondType
 from ntnx_networking_py_client.models.networking.v4.config.UplinkBondVirtualSwitchInfo import UplinkBondVirtualSwitchInfo
 from ntnx_networking_py_client.models.networking.v4.config.VirtualSwitch import VirtualSwitch
-from ntnx_networking_py_client.models.networking.v4.config.VirtualSwitchApiResponse import VirtualSwitchApiResponse
-from ntnx_networking_py_client.models.networking.v4.config.VirtualSwitchListApiResponse import VirtualSwitchListApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.VirtualSwitchProjection import VirtualSwitchProjection
 from ntnx_networking_py_client.models.networking.v4.config.VlanSubnetMigrationSpec import VlanSubnetMigrationSpec
 from ntnx_networking_py_client.models.networking.v4.config.Vm import Vm
 from ntnx_networking_py_client.models.networking.v4.config.VmNic import VmNic
 from ntnx_networking_py_client.models.networking.v4.config.VmNicAssociation import VmNicAssociation
 from ntnx_networking_py_client.models.networking.v4.config.VmNicProjection import VmNicProjection
 from ntnx_networking_py_client.models.networking.v4.config.VmProjection import VmProjection
 from ntnx_networking_py_client.models.networking.v4.config.VnicMigrationItem import VnicMigrationItem
+from ntnx_networking_py_client.models.networking.v4.config.VnicMigrationItemSpec import VnicMigrationItemSpec
 from ntnx_networking_py_client.models.networking.v4.config.VnicMigrationSpec import VnicMigrationSpec
 from ntnx_networking_py_client.models.networking.v4.config.Vpc import Vpc
-from ntnx_networking_py_client.models.networking.v4.config.VpcApiResponse import VpcApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.VpcDhcpOptions import VpcDhcpOptions
-from ntnx_networking_py_client.models.networking.v4.config.VpcListApiResponse import VpcListApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.VpcName import VpcName
+from ntnx_networking_py_client.models.networking.v4.config.VpcNameProjection import VpcNameProjection
 from ntnx_networking_py_client.models.networking.v4.config.VpcProjection import VpcProjection
+from ntnx_networking_py_client.models.networking.v4.config.VpcType import VpcType
 from ntnx_networking_py_client.models.networking.v4.config.VpcVirtualSwitchMapping import VpcVirtualSwitchMapping
-from ntnx_networking_py_client.models.networking.v4.config.VpcVirtualSwitchMappingsApiResponse import VpcVirtualSwitchMappingsApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.VpnAppliance import VpnAppliance
 from ntnx_networking_py_client.models.networking.v4.config.VpnConnection import VpnConnection
-from ntnx_networking_py_client.models.networking.v4.config.VpnConnectionApiResponse import VpnConnectionApiResponse
-from ntnx_networking_py_client.models.networking.v4.config.VpnConnectionListApiResponse import VpnConnectionListApiResponse
-from ntnx_networking_py_client.models.networking.v4.config.VpnVendorListApiResponse import VpnVendorListApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.Vtep import Vtep
 from ntnx_networking_py_client.models.networking.v4.error.AppMessage import AppMessage
 from ntnx_networking_py_client.models.networking.v4.error.ErrorResponse import ErrorResponse
 from ntnx_networking_py_client.models.networking.v4.error.SchemaValidationError import SchemaValidationError
 from ntnx_networking_py_client.models.networking.v4.error.SchemaValidationErrorMessage import SchemaValidationErrorMessage
+from ntnx_networking_py_client.models.networking.v4.stats.GetLayer2StretchStatsApiResponse import GetLayer2StretchStatsApiResponse
+from ntnx_networking_py_client.models.networking.v4.stats.GetTrafficMirrorStatsApiResponse import GetTrafficMirrorStatsApiResponse
+from ntnx_networking_py_client.models.networking.v4.stats.GetVpcNsStatsApiResponse import GetVpcNsStatsApiResponse
+from ntnx_networking_py_client.models.networking.v4.stats.GetVpnConnectionStatsApiResponse import GetVpnConnectionStatsApiResponse
 from ntnx_networking_py_client.models.networking.v4.stats.Layer2StretchStats import Layer2StretchStats
-from ntnx_networking_py_client.models.networking.v4.stats.Layer2StretchStatsApiResponse import Layer2StretchStatsApiResponse
 from ntnx_networking_py_client.models.networking.v4.stats.RoutingPolicyClearCountersSpec import RoutingPolicyClearCountersSpec
 from ntnx_networking_py_client.models.networking.v4.stats.StatsQueryResponseBase import StatsQueryResponseBase
 from ntnx_networking_py_client.models.networking.v4.stats.TaskReferenceApiResponse import TaskReferenceApiResponse as StatsTaskReferenceApiResponse
 from ntnx_networking_py_client.models.networking.v4.stats.TrafficMirrorState import TrafficMirrorState
 from ntnx_networking_py_client.models.networking.v4.stats.TrafficMirrorStats import TrafficMirrorStats
-from ntnx_networking_py_client.models.networking.v4.stats.TrafficMirrorStatsApiResponse import TrafficMirrorStatsApiResponse
 from ntnx_networking_py_client.models.networking.v4.stats.TrafficMirrorStatsData import TrafficMirrorStatsData
 from ntnx_networking_py_client.models.networking.v4.stats.VpcNsStats import VpcNsStats
-from ntnx_networking_py_client.models.networking.v4.stats.VpcNsStatsApiResponse import VpcNsStatsApiResponse
 from ntnx_networking_py_client.models.networking.v4.stats.VpnConnectionStats import VpnConnectionStats
-from ntnx_networking_py_client.models.networking.v4.stats.VpnConnectionStatsApiResponse import VpnConnectionStatsApiResponse
 from ntnx_networking_py_client.models.prism.v4.config.TaskReference import TaskReference
+from ntnx_networking_py_client.api_response import ApiResponse
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api/__init__.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,30 +1,30 @@
 
 from __future__ import absolute_import
 
 # flake8: noqa
 
 # import apis into api package
-from ntnx_networking_py_client.api.bgp_session_api import BgpSessionApi
-from ntnx_networking_py_client.api.bridge_api import BridgeApi
-from ntnx_networking_py_client.api.cluster_capability_api import ClusterCapabilityApi
-from ntnx_networking_py_client.api.floating_ip_api import FloatingIpApi
-from ntnx_networking_py_client.api.gateway_api import GatewayApi
-from ntnx_networking_py_client.api.ipfix_exporter_api import IPFIXExporterApi
-from ntnx_networking_py_client.api.layer2_stretch_api import Layer2StretchApi
+from ntnx_networking_py_client.api.bgp_sessions_api import BgpSessionsApi
+from ntnx_networking_py_client.api.bridges_api import BridgesApi
+from ntnx_networking_py_client.api.cluster_capabilities_api import ClusterCapabilitiesApi
+from ntnx_networking_py_client.api.floating_ips_api import FloatingIpsApi
+from ntnx_networking_py_client.api.gateways_api import GatewaysApi
+from ntnx_networking_py_client.api.ipfix_exporters_api import IPFIXExportersApi
 from ntnx_networking_py_client.api.layer2_stretch_stats_api import Layer2StretchStatsApi
-from ntnx_networking_py_client.api.network_controller_api import NetworkControllerApi
-from ntnx_networking_py_client.api.route_table_api import RouteTableApi
-from ntnx_networking_py_client.api.routing_policy_api import RoutingPolicyApi
+from ntnx_networking_py_client.api.layer2_stretches_api import Layer2StretchesApi
+from ntnx_networking_py_client.api.network_controllers_api import NetworkControllersApi
+from ntnx_networking_py_client.api.route_tables_api import RouteTablesApi
+from ntnx_networking_py_client.api.routing_policies_api import RoutingPoliciesApi
 from ntnx_networking_py_client.api.routing_policy_stats_api import RoutingPolicyStatsApi
-from ntnx_networking_py_client.api.subnet_api import SubnetApi
-from ntnx_networking_py_client.api.subnet_reserve_unreserve_ip_api import SubnetReserveUnreserveIpApi
-from ntnx_networking_py_client.api.traffic_mirror_api import TrafficMirrorApi
+from ntnx_networking_py_client.api.subnet_ip_reservation_api import SubnetIPReservationApi
+from ntnx_networking_py_client.api.subnets_api import SubnetsApi
 from ntnx_networking_py_client.api.traffic_mirror_stats_api import TrafficMirrorStatsApi
-from ntnx_networking_py_client.api.uplink_bond_api import UplinkBondApi
-from ntnx_networking_py_client.api.virtual_switch_api import VirtualSwitchApi
-from ntnx_networking_py_client.api.virtual_switch_node_info_api import VirtualSwitchNodeInfoApi
-from ntnx_networking_py_client.api.vpc_api import VpcApi
+from ntnx_networking_py_client.api.traffic_mirrors_api import TrafficMirrorsApi
+from ntnx_networking_py_client.api.uplink_bonds_api import UplinkBondsApi
+from ntnx_networking_py_client.api.virtual_switch_nodes_info_api import VirtualSwitchNodesInfoApi
+from ntnx_networking_py_client.api.virtual_switches_api import VirtualSwitchesApi
 from ntnx_networking_py_client.api.vpc_ns_stats_api import VpcNsStatsApi
 from ntnx_networking_py_client.api.vpc_virtual_switch_mappings_api import VpcVirtualSwitchMappingsApi
-from ntnx_networking_py_client.api.vpn_connection_api import VpnConnectionApi
+from ntnx_networking_py_client.api.vpcs_api import VpcsApi
 from ntnx_networking_py_client.api.vpn_connection_stats_api import VpnConnectionStatsApi
+from ntnx_networking_py_client.api.vpn_connections_api import VpnConnectionsApi
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api/bgp_session_api.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api/bgp_sessions_api.py`

 * *Files 3% similar despite different names*

```diff
@@ -3,66 +3,67 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 from __future__ import absolute_import
 
 import re  # noqa: F401
 
 # python 2 and python 3 compatibility library
 import six
 
 from ntnx_networking_py_client.api_client import ApiClient
 
 
-class BgpSessionApi(object):
+class BgpSessionsApi(object):
     """IGNORE:
     NOTE: A placeholder for class level description
     IGNORE
     """  # noqa: E501
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
 
         self.api_client = api_client
-        self.__headers_to_skip = { 'authorization', 'cookie', 'ntnx-request-id', 'host', 'user-agent' }
+        self.__headers_to_skip = { 'authorization', 'cookie', 'host', 'user-agent' }
 
     def create_bgp_session(self, body, **kwargs):  # noqa: E501
         """Create BGP session.
 
         >>> response = api.create_bgp_session(body)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
         >>> thread = api.create_bgp_session(body, async_req=True)
         >>> result = thread.get()
 
         :param body: Create BGP session request body.
         :type body:
+
             :class:`~ntnx_networking_py_client.models.networking.v4.config.BgpSession`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
         :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.TaskReferenceApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'body' is set
         if ('body' not in params or params['body'] is None):
@@ -74,18 +75,22 @@
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
             ['application/json'])  # noqa: E501
+        if 'Content-Type' in params and params.get('Content-Type') is not None:
+            header_params['Content-Type'] = params.get('Content-Type')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -98,100 +103,106 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
+        # Authentication setting
+        auth_settings = ['basicAuthScheme']  # noqa: E501
+
         body_params = None
         if 'body' in params and params['body'] is not None:
             body_params = params['body']
 
-        # Authentication setting
-        auth_settings = ['basicAuthScheme']  # noqa: E501
-
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/bgp-sessions', 'POST',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/bgp-sessions', 'POST',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/bgp-sessions', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/bgp-sessions', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def delete_bgp_session(self, extId, **kwargs):  # noqa: E501
+    def delete_bgp_session_by_id(self, extId, **kwargs):  # noqa: E501
         """Delete BGP session request.
 
-        >>> response = api.delete_bgp_session(extId)
+        >>> response = api.delete_bgp_session_by_id(extId)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.delete_bgp_session(extId, async_req=True)
+        >>> thread = api.delete_bgp_session_by_id(extId, async_req=True)
         >>> result = thread.get()
 
-        :param extId: BGP session UUID. Requires Prism Central >= pc.2022.9.
+        :param extId: BGP session UUID.
         :type extId:
+
             :class:`str`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
         :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.TaskReferenceApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `delete_bgp_session`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `delete_bgp_session_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -204,98 +215,104 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/bgp-sessions/{extId}', 'DELETE',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/bgp-sessions/{extId}', 'DELETE',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/bgp-sessions/{extId}', 'DELETE',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/bgp-sessions/{extId}', 'DELETE',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def get_bgp_session(self, extId, **kwargs):  # noqa: E501
+    def get_bgp_session_by_id(self, extId, **kwargs):  # noqa: E501
         """Get BGP session request.
 
-        >>> response = api.get_bgp_session(extId)
+        >>> response = api.get_bgp_session_by_id(extId)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.get_bgp_session(extId, async_req=True)
+        >>> thread = api.get_bgp_session_by_id(extId, async_req=True)
         >>> result = thread.get()
 
-        :param extId: BGP session UUID. Requires Prism Central >= pc.2022.9.
+        :param extId: BGP session UUID.
         :type extId:
+
             :class:`str`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.BgpSessionApiResponse`.
+        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.GetBgpSessionApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `get_bgp_session`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `get_bgp_session_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -308,89 +325,97 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/bgp-sessions/{extId}', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.BgpSessionApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/bgp-sessions/{extId}', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.BgpSessionApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/bgp-sessions/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.GetBgpSessionApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/bgp-sessions/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.GetBgpSessionApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
     def list_bgp_sessions(self, _page=None, _limit=None, _filter=None, _orderby=None, _expand=None, **kwargs):  # noqa: E501
         """List BGP sessions request.
 
         >>> response = api.list_bgp_sessions((optional) _page, (optional) _limit, (optional) _filter, (optional) _orderby, (optional) _expand)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
         >>> thread = api.list_bgp_sessions(async_req=True)
         >>> result = thread.get()
 
-        :param _page: A URL query parameter that specifies the page number of the result set.  Must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range will lead to no results being returned. 
+        :param _page: A URL query parameter that specifies the page number of the result set. It must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range might lead to no results. 
         :type _page:
+
             :class:`int`
-        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided a default value of 50 records will be returned in the result set. 
+        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided, a default value of 50 records will be returned in the result set. 
         :type _limit:
+
             :class:`int`
-        :param _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the OData V4.01 URL conventions. For example, filter '$filter=name eq 'karbon-ntnx-1.0' would filter result on cluster name karbon-ntnx1.0, filter '$filter=startswith(name, 'C')' would filter on cluster name starting with C. The filter can be applied on the following fields: - dynamicRoutePriority - localGatewayReference - name - remoteGatewayReference 
+        :param _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the [OData V4.01](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html) URL conventions. For example, filter '$filter=name eq 'karbon-ntnx-1.0' would filter the result on cluster name 'karbon-ntnx1.0', filter '$filter=startswith(name, 'C')' would filter on cluster name starting with 'C'. The filter can be applied to the following fields: - dynamicRoutePriority - localGatewayReference - name - remoteGatewayReference 
         :type _filter:
+
             :class:`str`
-        :param _orderby: A URL query parameter that allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified the resources will be sorted in ascending order by default. For example, '$orderby=templateName desc' would get all templates sorted by templateName in desc order. The orderby can be applied to the following fields: - dynamicRoutePriority - name 
+        :param _orderby: A URL query parameter that allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified, the resources will be sorted in ascending order by default. For example, '$orderby=templateName desc' would get all templates sorted by templateName in descending order. The orderby can be applied to the following fields: - dynamicRoutePriority - name 
         :type _orderby:
+
             :class:`str`
-        :param _expand: A URL query parameter that allows clients to request related resources when a resource that satisfies a particular request is retrieved. Each expand item is evaluated relative to the entity containing the property being expanded. Other query options can be applied to an expanded property by appending a semicolon-separated list of query options, enclosed in parentheses, to the property name. Allowed system query options are $filter, $select, $orderby. The following expansion keys are supported. - localGateway - remoteGateway 
+        :param _expand: A URL query parameter that allows clients to request related resources when a resource that satisfies a particular request is retrieved. Each expanded item is evaluated relative to the entity containing the property being expanded. Other query options can be applied to an expanded property by appending a semicolon-separated list of query options, enclosed in parentheses, to the property name. Permissible system query options are $filter, $select and $orderby. The following expansion keys are supported. - localGateway - remoteGateway 
         :type _expand:
+
             :class:`str`
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.BgpSessionListApiResponse`.
+        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.ListBgpSessionsApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
 
         collection_formats = {}
@@ -409,14 +434,16 @@
         if '_expand' in params and params['_expand'] is not None:
             query_params.append(('$expand', params['_expand']))  # noqa: E501
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -429,108 +456,117 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/bgp-sessions', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.BgpSessionListApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/bgp-sessions', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.BgpSessionListApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/bgp-sessions', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.ListBgpSessionsApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/bgp-sessions', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.ListBgpSessionsApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def update_bgp_session(self, extId, body, **kwargs):  # noqa: E501
+    def update_bgp_session_by_id(self, extId, body, **kwargs):  # noqa: E501
         """Update BGP session request.
 
-        >>> response = api.update_bgp_session(extId, body)
+        >>> response = api.update_bgp_session_by_id(extId, body)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.update_bgp_session(extId, body, async_req=True)
+        >>> thread = api.update_bgp_session_by_id(extId, body, async_req=True)
         >>> result = thread.get()
 
-        :param extId: BGP session UUID. Requires Prism Central >= pc.2022.9.
+        :param extId: BGP session UUID.
         :type extId:
+
             :class:`str`, required
         :param body: Update BGP session request body.
         :type body:
+
             :class:`~ntnx_networking_py_client.models.networking.v4.config.BgpSession`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
         :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.TaskReferenceApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `update_bgp_session`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `update_bgp_session_by_id`")  # noqa: E501
         # verify the required parameter 'body' is set
         if ('body' not in params or params['body'] is None):
-            raise ValueError("Missing the required parameter `body` when calling `update_bgp_session`")  # noqa: E501
+            raise ValueError("Missing the required parameter `body` when calling `update_bgp_session_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
             ['application/json'])  # noqa: E501
+        if 'Content-Type' in params and params.get('Content-Type') is not None:
+            header_params['Content-Type'] = params.get('Content-Type')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -543,47 +579,50 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
+        # Authentication setting
+        auth_settings = ['basicAuthScheme']  # noqa: E501
+
         body_params = None
         if 'body' in params and params['body'] is not None:
             body_params = params['body']
 
-        # Authentication setting
-        auth_settings = ['basicAuthScheme']  # noqa: E501
-
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/bgp-sessions/{extId}', 'PUT',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/bgp-sessions/{extId}', 'PUT',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/bgp-sessions/{extId}', 'PUT',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/bgp-sessions/{extId}', 'PUT',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api/bridge_api.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api/bridges_api.py`

 * *Files 14% similar despite different names*

```diff
@@ -3,94 +3,100 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 from __future__ import absolute_import
 
 import re  # noqa: F401
 
 # python 2 and python 3 compatibility library
 import six
 
 from ntnx_networking_py_client.api_client import ApiClient
 
 
-class BridgeApi(object):
+class BridgesApi(object):
     """IGNORE:
     NOTE: A placeholder for class level description
     IGNORE
     """  # noqa: E501
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
 
         self.api_client = api_client
-        self.__headers_to_skip = { 'authorization', 'cookie', 'ntnx-request-id', 'host', 'user-agent' }
+        self.__headers_to_skip = { 'authorization', 'cookie', 'host', 'user-agent' }
 
-    def migrate_bridge_to_virtual_switches(self, body, X_Cluster_Id=None, **kwargs):  # noqa: E501
+    def migrate_bridge(self, body, X_Cluster_Id=None, **kwargs):  # noqa: E501
         """Create a Virtual Switch from an existing bridge
 
-        >>> response = api.migrate_bridge_to_virtual_switches(body, (optional) X_Cluster_Id)
+        >>> response = api.migrate_bridge(body, (optional) X_Cluster_Id)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.migrate_bridge_to_virtual_switches(body, async_req=True)
+        >>> thread = api.migrate_bridge(body, async_req=True)
         >>> result = thread.get()
 
         :param body: Schema of bridge to migrate to a Virtual Switch
         :type body:
+
             :class:`~ntnx_networking_py_client.models.networking.v4.config.Bridge`, required
-        :param X_Cluster_Id: Prism Element Cluster UUID
+        :param X_Cluster_Id: Prism Element cluster reference. This header can be optionally supplied for Virtual Switch list requests, but is deprecated for all other Virtual Switch fetch/create/update/delete requests. 
         :type X_Cluster_Id:
+
             :class:`str`
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
         :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.TaskReferenceApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'body' is set
         if ('body' not in params or params['body'] is None):
-            raise ValueError("Missing the required parameter `body` when calling `migrate_bridge_to_virtual_switches`")  # noqa: E501
+            raise ValueError("Missing the required parameter `body` when calling `migrate_bridge`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
         if 'X_Cluster_Id' in params and params['X_Cluster_Id'] is not None:
             header_params['X-Cluster-Id'] = params['X_Cluster_Id']  # noqa: E501
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
             ['application/json'])  # noqa: E501
+        if 'Content-Type' in params and params.get('Content-Type') is not None:
+            header_params['Content-Type'] = params.get('Content-Type')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -103,47 +109,50 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
+        # Authentication setting
+        auth_settings = ['basicAuthScheme']  # noqa: E501
+
         body_params = None
         if 'body' in params and params['body'] is not None:
             body_params = params['body']
 
-        # Authentication setting
-        auth_settings = ['basicAuthScheme']  # noqa: E501
-
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/virtual-switches/$actions/migrate', 'POST',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/virtual-switches/$actions/migrate', 'POST',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/virtual-switches/$actions/migrate', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/virtual-switches/$actions/migrate', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api/cluster_capability_api.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api/cluster_capabilities_api.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,72 +3,75 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 from __future__ import absolute_import
 
 import re  # noqa: F401
 
 # python 2 and python 3 compatibility library
 import six
 
 from ntnx_networking_py_client.api_client import ApiClient
 
 
-class ClusterCapabilityApi(object):
+class ClusterCapabilitiesApi(object):
     """IGNORE:
     NOTE: A placeholder for class level description
     IGNORE
     """  # noqa: E501
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
 
         self.api_client = api_client
-        self.__headers_to_skip = { 'authorization', 'cookie', 'ntnx-request-id', 'host', 'user-agent' }
+        self.__headers_to_skip = { 'authorization', 'cookie', 'host', 'user-agent' }
 
-    def get_cluster_capabilities(self, _page=None, _limit=None, _filter=None, **kwargs):  # noqa: E501
+    def list_cluster_capabilities(self, _page=None, _limit=None, _filter=None, **kwargs):  # noqa: E501
         """Get cluster capabilities
 
-        >>> response = api.get_cluster_capabilities((optional) _page, (optional) _limit, (optional) _filter)
+        >>> response = api.list_cluster_capabilities((optional) _page, (optional) _limit, (optional) _filter)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.get_cluster_capabilities(async_req=True)
+        >>> thread = api.list_cluster_capabilities(async_req=True)
         >>> result = thread.get()
 
-        :param _page: A URL query parameter that specifies the page number of the result set.  Must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range will lead to no results being returned. 
+        :param _page: A URL query parameter that specifies the page number of the result set. It must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range might lead to no results. 
         :type _page:
+
             :class:`int`
-        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided a default value of 50 records will be returned in the result set. 
+        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided, a default value of 50 records will be returned in the result set. 
         :type _limit:
+
             :class:`int`
-        :param _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the OData V4.01 URL conventions. For example, filter '$filter=name eq 'karbon-ntnx-1.0' would filter result on cluster name karbon-ntnx1.0, filter '$filter=startswith(name, 'C')' would filter on cluster name starting with C. The filter can be applied on the following fields: - clusterId 
+        :param _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the [OData V4.01](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html) URL conventions. For example, filter '$filter=name eq 'karbon-ntnx-1.0' would filter the result on cluster name 'karbon-ntnx1.0', filter '$filter=startswith(name, 'C')' would filter on cluster name starting with 'C'. The filter can be applied to the following fields: - clusterId 
         :type _filter:
+
             :class:`str`
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.ClusterCapabilityApiResponse`.
+        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.ListClusterCapabilitiesApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
 
         collection_formats = {}
@@ -83,14 +86,16 @@
         if '_filter' in params and params['_filter'] is not None:
             query_params.append(('$filter', params['_filter']))  # noqa: E501
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -103,45 +108,48 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/capabilities', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.ClusterCapabilityApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/capabilities', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.ClusterCapabilityApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/capabilities', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.ListClusterCapabilitiesApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/capabilities', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.ListClusterCapabilitiesApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api/floating_ip_api.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api/vpcs_api.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,89 +3,94 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 from __future__ import absolute_import
 
 import re  # noqa: F401
 
 # python 2 and python 3 compatibility library
 import six
 
 from ntnx_networking_py_client.api_client import ApiClient
 
 
-class FloatingIpApi(object):
+class VpcsApi(object):
     """IGNORE:
     NOTE: A placeholder for class level description
     IGNORE
     """  # noqa: E501
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
 
         self.api_client = api_client
-        self.__headers_to_skip = { 'authorization', 'cookie', 'ntnx-request-id', 'host', 'user-agent' }
+        self.__headers_to_skip = { 'authorization', 'cookie', 'host', 'user-agent' }
 
-    def create_floating_ip(self, body, **kwargs):  # noqa: E501
-        """Create a floating IP.
+    def create_vpc(self, body, **kwargs):  # noqa: E501
+        """Create a VPC.
 
-        >>> response = api.create_floating_ip(body)
+        >>> response = api.create_vpc(body)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.create_floating_ip(body, async_req=True)
+        >>> thread = api.create_vpc(body, async_req=True)
         >>> result = thread.get()
 
-        :param body: Task Id corresponding to the Create Floating IP operation.
+        :param body: Request schema to create the VPC.
         :type body:
-            :class:`~ntnx_networking_py_client.models.networking.v4.config.FloatingIp`, required
+
+            :class:`~ntnx_networking_py_client.models.networking.v4.config.Vpc`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
         :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.TaskReferenceApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'body' is set
         if ('body' not in params or params['body'] is None):
-            raise ValueError("Missing the required parameter `body` when calling `create_floating_ip`")  # noqa: E501
+            raise ValueError("Missing the required parameter `body` when calling `create_vpc`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
             ['application/json'])  # noqa: E501
+        if 'Content-Type' in params and params.get('Content-Type') is not None:
+            header_params['Content-Type'] = params.get('Content-Type')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -98,100 +103,106 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
+        # Authentication setting
+        auth_settings = ['basicAuthScheme']  # noqa: E501
+
         body_params = None
         if 'body' in params and params['body'] is not None:
             body_params = params['body']
 
-        # Authentication setting
-        auth_settings = ['basicAuthScheme']  # noqa: E501
-
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/floating-ips', 'POST',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/floating-ips', 'POST',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/vpcs', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/vpcs', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def delete_floating_ip(self, extId, **kwargs):  # noqa: E501
-        """Delete the floating IP corresponding to the extId.
+    def delete_vpc_by_id(self, extId, **kwargs):  # noqa: E501
+        """Delete the specified VPC.
 
-        >>> response = api.delete_floating_ip(extId)
+        >>> response = api.delete_vpc_by_id(extId)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.delete_floating_ip(extId, async_req=True)
+        >>> thread = api.delete_vpc_by_id(extId, async_req=True)
         >>> result = thread.get()
 
-        :param extId: ExtId of the floating IP.
+        :param extId: The UUID of the VPC.
         :type extId:
+
             :class:`str`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
         :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.TaskReferenceApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `delete_floating_ip`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `delete_vpc_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -204,98 +215,104 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/floating-ips/{extId}', 'DELETE',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/floating-ips/{extId}', 'DELETE',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/vpcs/{extId}', 'DELETE',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/vpcs/{extId}', 'DELETE',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def get_floating_ip(self, extId, **kwargs):  # noqa: E501
-        """Get the floating IP for this extId.
+    def get_vpc_by_id(self, extId, **kwargs):  # noqa: E501
+        """Get the VPC with the specified UUID.
 
-        >>> response = api.get_floating_ip(extId)
+        >>> response = api.get_vpc_by_id(extId)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.get_floating_ip(extId, async_req=True)
+        >>> thread = api.get_vpc_by_id(extId, async_req=True)
         >>> result = thread.get()
 
-        :param extId: ExtId of the floating IP.
+        :param extId: The UUID of the VPC.
         :type extId:
+
             :class:`str`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.FloatingIpApiResponse`.
+        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.GetVpcApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `get_floating_ip`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `get_vpc_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -308,89 +325,97 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/floating-ips/{extId}', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.FloatingIpApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/floating-ips/{extId}', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.FloatingIpApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/vpcs/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.GetVpcApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/vpcs/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.GetVpcApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def list_floating_ip(self, _page=None, _limit=None, _filter=None, _orderby=None, _expand=None, **kwargs):  # noqa: E501
-        """Get a list of floating IPs.
+    def list_vpcs(self, _page=None, _limit=None, _filter=None, _orderby=None, _select=None, **kwargs):  # noqa: E501
+        """Get the list of existing VPCs.
 
-        >>> response = api.list_floating_ip((optional) _page, (optional) _limit, (optional) _filter, (optional) _orderby, (optional) _expand)
+        >>> response = api.list_vpcs((optional) _page, (optional) _limit, (optional) _filter, (optional) _orderby, (optional) _select)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.list_floating_ip(async_req=True)
+        >>> thread = api.list_vpcs(async_req=True)
         >>> result = thread.get()
 
-        :param _page: A URL query parameter that specifies the page number of the result set.  Must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range will lead to no results being returned. 
+        :param _page: A URL query parameter that specifies the page number of the result set. It must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range might lead to no results. 
         :type _page:
+
             :class:`int`
-        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided a default value of 50 records will be returned in the result set. 
+        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided, a default value of 50 records will be returned in the result set. 
         :type _limit:
+
             :class:`int`
-        :param _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the OData V4.01 URL conventions. For example, filter '$filter=name eq 'karbon-ntnx-1.0' would filter result on cluster name karbon-ntnx1.0, filter '$filter=startswith(name, 'C')' would filter on cluster name starting with C. The filter can be applied on the following fields: - association - externalSubnetReference - floatingIp/ipv4/value - floatingIp/ipv6/value - name 
+        :param _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the [OData V4.01](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html) URL conventions. For example, filter '$filter=name eq 'karbon-ntnx-1.0' would filter the result on cluster name 'karbon-ntnx1.0', filter '$filter=startswith(name, 'C')' would filter on cluster name starting with 'C'. The filter can be applied to the following fields: - name - vpcType 
         :type _filter:
+
             :class:`str`
-        :param _orderby: A URL query parameter that allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified the resources will be sorted in ascending order by default. For example, '$orderby=templateName desc' would get all templates sorted by templateName in desc order. The orderby can be applied to the following fields: - floatingIp/ipv4/value - floatingIp/ipv6/value - name 
+        :param _orderby: A URL query parameter that allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified, the resources will be sorted in ascending order by default. For example, '$orderby=templateName desc' would get all templates sorted by templateName in descending order. The orderby can be applied to the following fields: - name 
         :type _orderby:
+
             :class:`str`
-        :param _expand: A URL query parameter that allows clients to request related resources when a resource that satisfies a particular request is retrieved. Each expand item is evaluated relative to the entity containing the property being expanded. Other query options can be applied to an expanded property by appending a semicolon-separated list of query options, enclosed in parentheses, to the property name. Allowed system query options are $filter, $select, $orderby. The following expansion keys are supported. - externalSubnet - vmNic - vpc 
-        :type _expand:
+        :param _select: A URL query parameter that allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the [OData V4.01](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html) URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e., *), then all properties on the matching resource will be returned. - description - extId - externalRoutingDomainReference - links - metadata - name - tenantId - vpcType 
+        :type _select:
+
             :class:`str`
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.FloatingIpListApiResponse`.
+        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.ListVpcsApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
 
         collection_formats = {}
@@ -402,135 +427,146 @@
             query_params.append(('$page', params['_page']))  # noqa: E501
         if '_limit' in params and params['_limit'] is not None:
             query_params.append(('$limit', params['_limit']))  # noqa: E501
         if '_filter' in params and params['_filter'] is not None:
             query_params.append(('$filter', params['_filter']))  # noqa: E501
         if '_orderby' in params and params['_orderby'] is not None:
             query_params.append(('$orderby', params['_orderby']))  # noqa: E501
-        if '_expand' in params and params['_expand'] is not None:
-            query_params.append(('$expand', params['_expand']))  # noqa: E501
+        if '_select' in params and params['_select'] is not None:
+            query_params.append(('$select', params['_select']))  # noqa: E501
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
-        all_params = set(['_page', '_limit', '_filter', '_orderby', '_expand'])
+        all_params = set(['_page', '_limit', '_filter', '_orderby', '_select'])
         all_params.update(extra_params)
         for key, val in six.iteritems(params):
             if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                 if key.lower() == 'if_match'.lower():
                     key = 'If-Match'
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/floating-ips', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.FloatingIpListApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/floating-ips', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.FloatingIpListApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/vpcs', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.ListVpcsApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/vpcs', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.ListVpcsApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def put_floating_ip(self, extId, body, **kwargs):  # noqa: E501
-        """Update the floating IP for this extId.
+    def update_vpc_by_id(self, extId, body, **kwargs):  # noqa: E501
+        """Update the specified VPC.
 
-        >>> response = api.put_floating_ip(extId, body)
+        >>> response = api.update_vpc_by_id(extId, body)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.put_floating_ip(extId, body, async_req=True)
+        >>> thread = api.update_vpc_by_id(extId, body, async_req=True)
         >>> result = thread.get()
 
-        :param extId: ExtId of the floating IP.
+        :param extId: The UUID of the VPC.
         :type extId:
+
             :class:`str`, required
-        :param body: Configure a floating IP.
+        :param body: Request schema to update the specified VPC.
         :type body:
-            :class:`~ntnx_networking_py_client.models.networking.v4.config.FloatingIp`, required
+
+            :class:`~ntnx_networking_py_client.models.networking.v4.config.Vpc`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
         :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.TaskReferenceApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `put_floating_ip`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `update_vpc_by_id`")  # noqa: E501
         # verify the required parameter 'body' is set
         if ('body' not in params or params['body'] is None):
-            raise ValueError("Missing the required parameter `body` when calling `put_floating_ip`")  # noqa: E501
+            raise ValueError("Missing the required parameter `body` when calling `update_vpc_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
             ['application/json'])  # noqa: E501
+        if 'Content-Type' in params and params.get('Content-Type') is not None:
+            header_params['Content-Type'] = params.get('Content-Type')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -543,47 +579,50 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
+        # Authentication setting
+        auth_settings = ['basicAuthScheme']  # noqa: E501
+
         body_params = None
         if 'body' in params and params['body'] is not None:
             body_params = params['body']
 
-        # Authentication setting
-        auth_settings = ['basicAuthScheme']  # noqa: E501
-
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/floating-ips/{extId}', 'PUT',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/floating-ips/{extId}', 'PUT',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/vpcs/{extId}', 'PUT',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/vpcs/{extId}', 'PUT',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api/gateway_api.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api/gateways_api.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,66 +3,67 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 from __future__ import absolute_import
 
 import re  # noqa: F401
 
 # python 2 and python 3 compatibility library
 import six
 
 from ntnx_networking_py_client.api_client import ApiClient
 
 
-class GatewayApi(object):
+class GatewaysApi(object):
     """IGNORE:
     NOTE: A placeholder for class level description
     IGNORE
     """  # noqa: E501
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
 
         self.api_client = api_client
-        self.__headers_to_skip = { 'authorization', 'cookie', 'ntnx-request-id', 'host', 'user-agent' }
+        self.__headers_to_skip = { 'authorization', 'cookie', 'host', 'user-agent' }
 
     def create_gateway(self, body, **kwargs):  # noqa: E501
         """Create network gateway
 
         >>> response = api.create_gateway(body)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
         >>> thread = api.create_gateway(body, async_req=True)
         >>> result = thread.get()
 
         :param body: Create gateway request body
         :type body:
+
             :class:`~ntnx_networking_py_client.models.networking.v4.config.Gateway`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
         :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.TaskReferenceApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'body' is set
         if ('body' not in params or params['body'] is None):
@@ -74,18 +75,22 @@
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
             ['application/json'])  # noqa: E501
+        if 'Content-Type' in params and params.get('Content-Type') is not None:
+            header_params['Content-Type'] = params.get('Content-Type')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -98,100 +103,106 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
+        # Authentication setting
+        auth_settings = ['basicAuthScheme']  # noqa: E501
+
         body_params = None
         if 'body' in params and params['body'] is not None:
             body_params = params['body']
 
-        # Authentication setting
-        auth_settings = ['basicAuthScheme']  # noqa: E501
-
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/gateways', 'POST',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/gateways', 'POST',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/gateways', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/gateways', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def delete_gateway(self, extId, **kwargs):  # noqa: E501
+    def delete_gateway_by_id(self, extId, **kwargs):  # noqa: E501
         """Delete network gateway
 
-        >>> response = api.delete_gateway(extId)
+        >>> response = api.delete_gateway_by_id(extId)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.delete_gateway(extId, async_req=True)
+        >>> thread = api.delete_gateway_by_id(extId, async_req=True)
         >>> result = thread.get()
 
         :param extId: Gateway UUID
         :type extId:
+
             :class:`str`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
         :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.TaskReferenceApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `delete_gateway`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `delete_gateway_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -204,98 +215,104 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/gateways/{extId}', 'DELETE',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/gateways/{extId}', 'DELETE',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/gateways/{extId}', 'DELETE',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/gateways/{extId}', 'DELETE',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def get_gateway(self, extId, **kwargs):  # noqa: E501
+    def get_gateway_by_id(self, extId, **kwargs):  # noqa: E501
         """Get network gateway
 
-        >>> response = api.get_gateway(extId)
+        >>> response = api.get_gateway_by_id(extId)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.get_gateway(extId, async_req=True)
+        >>> thread = api.get_gateway_by_id(extId, async_req=True)
         >>> result = thread.get()
 
         :param extId: Gateway UUID
         :type extId:
+
             :class:`str`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.GatewayApiResponse`.
+        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.GetGatewayApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `get_gateway`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `get_gateway_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -308,92 +325,101 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/gateways/{extId}', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.GatewayApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/gateways/{extId}', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.GatewayApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/gateways/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.GetGatewayApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/gateways/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.GetGatewayApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
     def list_gateways(self, _page=None, _limit=None, _filter=None, _orderby=None, _expand=None, _select=None, **kwargs):  # noqa: E501
         """List network gateways
 
         >>> response = api.list_gateways((optional) _page, (optional) _limit, (optional) _filter, (optional) _orderby, (optional) _expand, (optional) _select)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
         >>> thread = api.list_gateways(async_req=True)
         >>> result = thread.get()
 
-        :param _page: A URL query parameter that specifies the page number of the result set.  Must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range will lead to no results being returned. 
+        :param _page: A URL query parameter that specifies the page number of the result set. It must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range might lead to no results. 
         :type _page:
+
             :class:`int`
-        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided a default value of 50 records will be returned in the result set. 
+        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided, a default value of 50 records will be returned in the result set. 
         :type _limit:
+
             :class:`int`
-        :param _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the OData V4.01 URL conventions. For example, filter '$filter=name eq 'karbon-ntnx-1.0' would filter result on cluster name karbon-ntnx1.0, filter '$filter=startswith(name, 'C')' would filter on cluster name starting with C. The filter can be applied on the following fields: - cloudNetworkReference - gatewayDeviceVendor - installedSoftwareVersion - name - supportedSoftwareVersion - vmReference - vpcReference 
+        :param _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the [OData V4.01](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html) URL conventions. For example, filter '$filter=name eq 'karbon-ntnx-1.0' would filter the result on cluster name 'karbon-ntnx1.0', filter '$filter=startswith(name, 'C')' would filter on cluster name starting with 'C'. The filter can be applied to the following fields: - cloudNetworkReference - gatewayDeviceVendor - installedSoftwareVersion - name - supportedSoftwareVersion - vmReference - vpcReference 
         :type _filter:
+
             :class:`str`
-        :param _orderby: A URL query parameter that allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified the resources will be sorted in ascending order by default. For example, '$orderby=templateName desc' would get all templates sorted by templateName in desc order. The orderby can be applied to the following fields: - name 
+        :param _orderby: A URL query parameter that allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified, the resources will be sorted in ascending order by default. For example, '$orderby=templateName desc' would get all templates sorted by templateName in descending order. The orderby can be applied to the following fields: - name 
         :type _orderby:
+
             :class:`str`
-        :param _expand: A URL query parameter that allows clients to request related resources when a resource that satisfies a particular request is retrieved. Each expand item is evaluated relative to the entity containing the property being expanded. Other query options can be applied to an expanded property by appending a semicolon-separated list of query options, enclosed in parentheses, to the property name. Allowed system query options are $filter, $select, $orderby. The following expansion keys are supported. - vm - vpc 
+        :param _expand: A URL query parameter that allows clients to request related resources when a resource that satisfies a particular request is retrieved. Each expanded item is evaluated relative to the entity containing the property being expanded. Other query options can be applied to an expanded property by appending a semicolon-separated list of query options, enclosed in parentheses, to the property name. Permissible system query options are $filter, $select and $orderby. The following expansion keys are supported. - vm - vpc 
         :type _expand:
+
             :class:`str`
-        :param _select: A URL query parameter that allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the OData V4.01 URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e. *), then all properties on the matching resource will be returned. - cloudNetworkReference - deployment - description - extId - gatewayDeviceVendor - installedSoftwareVersion - links - metadata - name - services - status - supportedSoftwareVersion - tenantId - vm - vmReference - vpc - vpcReference 
+        :param _select: A URL query parameter that allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the [OData V4.01](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html) URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e., *), then all properties on the matching resource will be returned. - cloudNetworkReference - description - extId - gatewayDeviceVendor - installedSoftwareVersion - links - metadata - name - supportedSoftwareVersion - tenantId - vm - vmReference - vpc - vpcReference 
         :type _select:
+
             :class:`str`
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.GatewayListApiResponse`.
+        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.ListGatewaysApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
 
         collection_formats = {}
@@ -414,14 +440,16 @@
         if '_select' in params and params['_select'] is not None:
             query_params.append(('$select', params['_select']))  # noqa: E501
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -434,108 +462,117 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/gateways', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.GatewayListApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/gateways', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.GatewayListApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/gateways', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.ListGatewaysApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/gateways', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.ListGatewaysApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def update_gateway(self, extId, body, **kwargs):  # noqa: E501
+    def update_gateway_by_id(self, extId, body, **kwargs):  # noqa: E501
         """Update network gateway
 
-        >>> response = api.update_gateway(extId, body)
+        >>> response = api.update_gateway_by_id(extId, body)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.update_gateway(extId, body, async_req=True)
+        >>> thread = api.update_gateway_by_id(extId, body, async_req=True)
         >>> result = thread.get()
 
         :param extId: Gateway UUID
         :type extId:
+
             :class:`str`, required
         :param body: Update gateway request body
         :type body:
+
             :class:`~ntnx_networking_py_client.models.networking.v4.config.Gateway`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
         :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.TaskReferenceApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `update_gateway`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `update_gateway_by_id`")  # noqa: E501
         # verify the required parameter 'body' is set
         if ('body' not in params or params['body'] is None):
-            raise ValueError("Missing the required parameter `body` when calling `update_gateway`")  # noqa: E501
+            raise ValueError("Missing the required parameter `body` when calling `update_gateway_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
             ['application/json'])  # noqa: E501
+        if 'Content-Type' in params and params.get('Content-Type') is not None:
+            header_params['Content-Type'] = params.get('Content-Type')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -548,100 +585,106 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
+        # Authentication setting
+        auth_settings = ['basicAuthScheme']  # noqa: E501
+
         body_params = None
         if 'body' in params and params['body'] is not None:
             body_params = params['body']
 
-        # Authentication setting
-        auth_settings = ['basicAuthScheme']  # noqa: E501
-
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/gateways/{extId}', 'PUT',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/gateways/{extId}', 'PUT',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/gateways/{extId}', 'PUT',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/gateways/{extId}', 'PUT',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def upgrade_gateway(self, extId, **kwargs):  # noqa: E501
+    def upgrade_gateway_by_id(self, extId, **kwargs):  # noqa: E501
         """Upgrade network gateway
 
-        >>> response = api.upgrade_gateway(extId)
+        >>> response = api.upgrade_gateway_by_id(extId)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.upgrade_gateway(extId, async_req=True)
+        >>> thread = api.upgrade_gateway_by_id(extId, async_req=True)
         >>> result = thread.get()
 
         :param extId: Gateway UUID
         :type extId:
+
             :class:`str`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
         :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.TaskReferenceApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `upgrade_gateway`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `upgrade_gateway_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -654,45 +697,48 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/gateways/{extId}/$actions/upgrade', 'POST',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/gateways/{extId}/$actions/upgrade', 'POST',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/gateways/{extId}/$actions/upgrade', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/gateways/{extId}/$actions/upgrade', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api/ipfix_exporter_api.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api/ipfix_exporters_api.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,66 +3,67 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 from __future__ import absolute_import
 
 import re  # noqa: F401
 
 # python 2 and python 3 compatibility library
 import six
 
 from ntnx_networking_py_client.api_client import ApiClient
 
 
-class IPFIXExporterApi(object):
+class IPFIXExportersApi(object):
     """IGNORE:
     NOTE: A placeholder for class level description
     IGNORE
     """  # noqa: E501
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
 
         self.api_client = api_client
-        self.__headers_to_skip = { 'authorization', 'cookie', 'ntnx-request-id', 'host', 'user-agent' }
+        self.__headers_to_skip = { 'authorization', 'cookie', 'host', 'user-agent' }
 
     def create_ipfix_exporter(self, body, **kwargs):  # noqa: E501
         """Create an IPFIX Exporter.
 
         >>> response = api.create_ipfix_exporter(body)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
         >>> thread = api.create_ipfix_exporter(body, async_req=True)
         >>> result = thread.get()
 
         :param body: Request schema to create the IPFIX exporter.
         :type body:
+
             :class:`~ntnx_networking_py_client.models.networking.v4.config.IPFIXExporter`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
         :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.TaskReferenceApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'body' is set
         if ('body' not in params or params['body'] is None):
@@ -74,18 +75,22 @@
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
             ['application/json'])  # noqa: E501
+        if 'Content-Type' in params and params.get('Content-Type') is not None:
+            header_params['Content-Type'] = params.get('Content-Type')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -98,100 +103,106 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
+        # Authentication setting
+        auth_settings = ['basicAuthScheme']  # noqa: E501
+
         body_params = None
         if 'body' in params and params['body'] is not None:
             body_params = params['body']
 
-        # Authentication setting
-        auth_settings = ['basicAuthScheme']  # noqa: E501
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/ipfix-exporters', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/ipfix-exporters', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/ipfix-exporters', 'POST',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/ipfix-exporters', 'POST',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
-
-    def delete_ipfix_exporter(self, extId, **kwargs):  # noqa: E501
+    def delete_ipfix_exporter_by_id(self, extId, **kwargs):  # noqa: E501
         """Delete the specified IPFIX Exporter.
 
-        >>> response = api.delete_ipfix_exporter(extId)
+        >>> response = api.delete_ipfix_exporter_by_id(extId)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.delete_ipfix_exporter(extId, async_req=True)
+        >>> thread = api.delete_ipfix_exporter_by_id(extId, async_req=True)
         >>> result = thread.get()
 
         :param extId: UUID of IPFIX exporter.
         :type extId:
+
             :class:`str`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
         :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.TaskReferenceApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `delete_ipfix_exporter`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `delete_ipfix_exporter_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -204,98 +215,104 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/ipfix-exporters/{extId}', 'DELETE',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/ipfix-exporters/{extId}', 'DELETE',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/ipfix-exporters/{extId}', 'DELETE',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/ipfix-exporters/{extId}', 'DELETE',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def get_ipfix_exporter(self, extId, **kwargs):  # noqa: E501
+    def get_ipfix_exporter_by_id(self, extId, **kwargs):  # noqa: E501
         """Get the specified IPFIX Exporter.
 
-        >>> response = api.get_ipfix_exporter(extId)
+        >>> response = api.get_ipfix_exporter_by_id(extId)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.get_ipfix_exporter(extId, async_req=True)
+        >>> thread = api.get_ipfix_exporter_by_id(extId, async_req=True)
         >>> result = thread.get()
 
         :param extId: UUID of IPFIX exporter.
         :type extId:
+
             :class:`str`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.IPFIXExporterApiResponse`.
+        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.GetIPFIXExporterApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `get_ipfix_exporter`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `get_ipfix_exporter_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -308,52 +325,55 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/ipfix-exporters/{extId}', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.IPFIXExporterApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/ipfix-exporters/{extId}', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.IPFIXExporterApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/ipfix-exporters/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.GetIPFIXExporterApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/ipfix-exporters/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.GetIPFIXExporterApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
     def list_ipfix_exporters(self, **kwargs):  # noqa: E501
         """Get the list of existing IPFIX Exporters.
 
         >>> response = api.list_ipfix_exporters()
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
@@ -361,21 +381,21 @@
         >>> thread = api.list_ipfix_exporters(async_req=True)
         >>> result = thread.get()
 
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.IPFIXExporterListApiResponse`.
+        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.ListIPFIXExportersApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
 
         collection_formats = {}
@@ -384,14 +404,16 @@
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -404,108 +426,117 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/ipfix-exporters', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.IPFIXExporterListApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/ipfix-exporters', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.IPFIXExporterListApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/ipfix-exporters', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.ListIPFIXExportersApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/ipfix-exporters', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.ListIPFIXExportersApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def update_ipfix_exporter(self, extId, body, **kwargs):  # noqa: E501
+    def update_ipfix_exporter_by_id(self, extId, body, **kwargs):  # noqa: E501
         """Update the specified IPFIX Exporter.
 
-        >>> response = api.update_ipfix_exporter(extId, body)
+        >>> response = api.update_ipfix_exporter_by_id(extId, body)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.update_ipfix_exporter(extId, body, async_req=True)
+        >>> thread = api.update_ipfix_exporter_by_id(extId, body, async_req=True)
         >>> result = thread.get()
 
         :param extId: UUID of IPFIX exporter.
         :type extId:
+
             :class:`str`, required
         :param body: Request schema to update the specified IPFIX exporter.
         :type body:
+
             :class:`~ntnx_networking_py_client.models.networking.v4.config.IPFIXExporter`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
         :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.TaskReferenceApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `update_ipfix_exporter`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `update_ipfix_exporter_by_id`")  # noqa: E501
         # verify the required parameter 'body' is set
         if ('body' not in params or params['body'] is None):
-            raise ValueError("Missing the required parameter `body` when calling `update_ipfix_exporter`")  # noqa: E501
+            raise ValueError("Missing the required parameter `body` when calling `update_ipfix_exporter_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
             ['application/json'])  # noqa: E501
+        if 'Content-Type' in params and params.get('Content-Type') is not None:
+            header_params['Content-Type'] = params.get('Content-Type')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -518,47 +549,50 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
+        # Authentication setting
+        auth_settings = ['basicAuthScheme']  # noqa: E501
+
         body_params = None
         if 'body' in params and params['body'] is not None:
             body_params = params['body']
 
-        # Authentication setting
-        auth_settings = ['basicAuthScheme']  # noqa: E501
-
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/ipfix-exporters/{extId}', 'PUT',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/ipfix-exporters/{extId}', 'PUT',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/ipfix-exporters/{extId}', 'PUT',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/ipfix-exporters/{extId}', 'PUT',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api/layer2_stretch_api.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api/layer2_stretches_api.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,66 +3,67 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 from __future__ import absolute_import
 
 import re  # noqa: F401
 
 # python 2 and python 3 compatibility library
 import six
 
 from ntnx_networking_py_client.api_client import ApiClient
 
 
-class Layer2StretchApi(object):
+class Layer2StretchesApi(object):
     """IGNORE:
     NOTE: A placeholder for class level description
     IGNORE
     """  # noqa: E501
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
 
         self.api_client = api_client
-        self.__headers_to_skip = { 'authorization', 'cookie', 'ntnx-request-id', 'host', 'user-agent' }
+        self.__headers_to_skip = { 'authorization', 'cookie', 'host', 'user-agent' }
 
     def create_layer2_stretch(self, body, **kwargs):  # noqa: E501
         """Create a Layer2Stretch configuration.
 
         >>> response = api.create_layer2_stretch(body)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
         >>> thread = api.create_layer2_stretch(body, async_req=True)
         >>> result = thread.get()
 
         :param body: Request schema to create the Layer2Stretch configuration.
         :type body:
+
             :class:`~ntnx_networking_py_client.models.networking.v4.config.Layer2Stretch`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
         :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.TaskReferenceApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'body' is set
         if ('body' not in params or params['body'] is None):
@@ -74,18 +75,22 @@
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
             ['application/json'])  # noqa: E501
+        if 'Content-Type' in params and params.get('Content-Type') is not None:
+            header_params['Content-Type'] = params.get('Content-Type')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -98,100 +103,106 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
+        # Authentication setting
+        auth_settings = ['basicAuthScheme']  # noqa: E501
+
         body_params = None
         if 'body' in params and params['body'] is not None:
             body_params = params['body']
 
-        # Authentication setting
-        auth_settings = ['basicAuthScheme']  # noqa: E501
-
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/layer2-stretches', 'POST',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/layer2-stretches', 'POST',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/layer2-stretches', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/layer2-stretches', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def delete_layer2_stretch(self, extId, **kwargs):  # noqa: E501
+    def delete_layer2_stretch_by_id(self, extId, **kwargs):  # noqa: E501
         """Delete the specified Layer2Stretch configuration.
 
-        >>> response = api.delete_layer2_stretch(extId)
+        >>> response = api.delete_layer2_stretch_by_id(extId)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.delete_layer2_stretch(extId, async_req=True)
+        >>> thread = api.delete_layer2_stretch_by_id(extId, async_req=True)
         >>> result = thread.get()
 
         :param extId: The UUID of the Layer2Stretch configuration.
         :type extId:
+
             :class:`str`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
         :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.TaskReferenceApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `delete_layer2_stretch`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `delete_layer2_stretch_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -204,98 +215,104 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/layer2-stretches/{extId}', 'DELETE',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/layer2-stretches/{extId}', 'DELETE',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/layer2-stretches/{extId}', 'DELETE',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/layer2-stretches/{extId}', 'DELETE',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def get_layer2_stretch(self, extId, **kwargs):  # noqa: E501
+    def get_layer2_stretch_by_id(self, extId, **kwargs):  # noqa: E501
         """Get the Layer2Stretch configuration with the specified UUID.
 
-        >>> response = api.get_layer2_stretch(extId)
+        >>> response = api.get_layer2_stretch_by_id(extId)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.get_layer2_stretch(extId, async_req=True)
+        >>> thread = api.get_layer2_stretch_by_id(extId, async_req=True)
         >>> result = thread.get()
 
         :param extId: The UUID of the Layer2Stretch configuration.
         :type extId:
+
             :class:`str`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.Layer2StretchApiResponse`.
+        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.GetLayer2StretchApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `get_layer2_stretch`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `get_layer2_stretch_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -308,98 +325,104 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/layer2-stretches/{extId}', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.Layer2StretchApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/layer2-stretches/{extId}', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.Layer2StretchApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/layer2-stretches/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.GetLayer2StretchApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/layer2-stretches/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.GetLayer2StretchApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def get_layer2_stretch_related_entities(self, extId, **kwargs):  # noqa: E501
+    def list_layer2_stretch_related_entities_by_cluster_id(self, extId, **kwargs):  # noqa: E501
         """Get the stretch-related entities from the specified Prism Central cluster.
 
-        >>> response = api.get_layer2_stretch_related_entities(extId)
+        >>> response = api.list_layer2_stretch_related_entities_by_cluster_id(extId)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.get_layer2_stretch_related_entities(extId, async_req=True)
+        >>> thread = api.list_layer2_stretch_related_entities_by_cluster_id(extId, async_req=True)
         >>> result = thread.get()
 
         :param extId: The UUID of the Prism Central cluster to retrieve stretch-related entities.
         :type extId:
+
             :class:`str`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.Layer2StretchRelatedEntitiesApiResponse`.
+        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.ListLayer2StretchRelatedEntitiesApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `get_layer2_stretch_related_entities`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `list_layer2_stretch_related_entities_by_cluster_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -412,86 +435,93 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/clusters/{extId}/layer2-stretches/related-entities', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.Layer2StretchRelatedEntitiesApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/clusters/{extId}/layer2-stretches/related-entities', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.Layer2StretchRelatedEntitiesApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/clusters/{extId}/layer2-stretches/related-entities', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.ListLayer2StretchRelatedEntitiesApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/clusters/{extId}/layer2-stretches/related-entities', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.ListLayer2StretchRelatedEntitiesApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
     def list_layer2_stretches(self, _page=None, _limit=None, _filter=None, _orderby=None, **kwargs):  # noqa: E501
-        """Get the list of existing Layer2Stretch configurations. Requires Prism Central >= pc.2022.9.
+        """Get the list of existing Layer2Stretch configurations.
 
         >>> response = api.list_layer2_stretches((optional) _page, (optional) _limit, (optional) _filter, (optional) _orderby)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
         >>> thread = api.list_layer2_stretches(async_req=True)
         >>> result = thread.get()
 
-        :param _page: A URL query parameter that specifies the page number of the result set.  Must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range will lead to no results being returned. 
+        :param _page: A URL query parameter that specifies the page number of the result set. It must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range might lead to no results. 
         :type _page:
+
             :class:`int`
-        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided a default value of 50 records will be returned in the result set. 
+        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided, a default value of 50 records will be returned in the result set. 
         :type _limit:
+
             :class:`int`
-        :param _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the OData V4.01 URL conventions. For example, filter '$filter=name eq 'karbon-ntnx-1.0' would filter result on cluster name karbon-ntnx1.0, filter '$filter=startswith(name, 'C')' would filter on cluster name starting with C. The filter can be applied on the following fields: - name - vni 
+        :param _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the [OData V4.01](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html) URL conventions. For example, filter '$filter=name eq 'karbon-ntnx-1.0' would filter the result on cluster name 'karbon-ntnx1.0', filter '$filter=startswith(name, 'C')' would filter on cluster name starting with 'C'. The filter can be applied to the following fields: - name - vni 
         :type _filter:
+
             :class:`str`
-        :param _orderby: A URL query parameter that allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified the resources will be sorted in ascending order by default. For example, '$orderby=templateName desc' would get all templates sorted by templateName in desc order. The orderby can be applied to the following fields: - name - vni 
+        :param _orderby: A URL query parameter that allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified, the resources will be sorted in ascending order by default. For example, '$orderby=templateName desc' would get all templates sorted by templateName in descending order. The orderby can be applied to the following fields: - name - vni 
         :type _orderby:
+
             :class:`str`
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.Layer2StretchListApiResponse`.
+        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.ListLayer2StretchesApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
 
         collection_formats = {}
@@ -508,14 +538,16 @@
         if '_orderby' in params and params['_orderby'] is not None:
             query_params.append(('$orderby', params['_orderby']))  # noqa: E501
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -528,108 +560,117 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/layer2-stretches', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.Layer2StretchListApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/layer2-stretches', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.Layer2StretchListApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
 
-    def update_layer2_stretch(self, extId, body, **kwargs):  # noqa: E501
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/layer2-stretches', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.ListLayer2StretchesApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/layer2-stretches', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.ListLayer2StretchesApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
+
+    def update_layer2_stretch_by_id(self, extId, body, **kwargs):  # noqa: E501
         """Update the specified Layer2Stretch configuration.
 
-        >>> response = api.update_layer2_stretch(extId, body)
+        >>> response = api.update_layer2_stretch_by_id(extId, body)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.update_layer2_stretch(extId, body, async_req=True)
+        >>> thread = api.update_layer2_stretch_by_id(extId, body, async_req=True)
         >>> result = thread.get()
 
         :param extId: The UUID of the Layer2Stretch configuration.
         :type extId:
+
             :class:`str`, required
         :param body: Request schema to update the specified Layer2Stretch configuration.
         :type body:
+
             :class:`~ntnx_networking_py_client.models.networking.v4.config.Layer2Stretch`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
         :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.TaskReferenceApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `update_layer2_stretch`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `update_layer2_stretch_by_id`")  # noqa: E501
         # verify the required parameter 'body' is set
         if ('body' not in params or params['body'] is None):
-            raise ValueError("Missing the required parameter `body` when calling `update_layer2_stretch`")  # noqa: E501
+            raise ValueError("Missing the required parameter `body` when calling `update_layer2_stretch_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
             ['application/json'])  # noqa: E501
+        if 'Content-Type' in params and params.get('Content-Type') is not None:
+            header_params['Content-Type'] = params.get('Content-Type')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -642,47 +683,50 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
+        # Authentication setting
+        auth_settings = ['basicAuthScheme']  # noqa: E501
+
         body_params = None
         if 'body' in params and params['body'] is not None:
             body_params = params['body']
 
-        # Authentication setting
-        auth_settings = ['basicAuthScheme']  # noqa: E501
-
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/layer2-stretches/{extId}', 'PUT',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/layer2-stretches/{extId}', 'PUT',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/layer2-stretches/{extId}', 'PUT',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/layer2-stretches/{extId}', 'PUT',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api/layer2_stretch_stats_api.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api/layer2_stretch_stats_api.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,15 +3,15 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 from __future__ import absolute_import
 
 import re  # noqa: F401
@@ -29,69 +29,83 @@
     """  # noqa: E501
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
 
         self.api_client = api_client
-        self.__headers_to_skip = { 'authorization', 'cookie', 'ntnx-request-id', 'host', 'user-agent' }
+        self.__headers_to_skip = { 'authorization', 'cookie', 'host', 'user-agent' }
 
-    def get_layer2_stretch_stats(self, extId, _startTime=None, _endTime=None, _samplingInterval=None, _statType=None, _page=None, _limit=None, _select=None, **kwargs):  # noqa: E501
+    def get_layer2_stretch_stats(self, extId, _startTime, _endTime, _samplingInterval=None, _statType=None, _page=None, _limit=None, _select=None, **kwargs):  # noqa: E501
         """Get Layer2Stretch statistics
 
-        >>> response = api.get_layer2_stretch_stats(extId, (optional) _startTime, (optional) _endTime, (optional) _samplingInterval, (optional) _statType, (optional) _page, (optional) _limit, (optional) _select)
+        >>> response = api.get_layer2_stretch_stats(extId, _startTime, _endTime, (optional) _samplingInterval, (optional) _statType, (optional) _page, (optional) _limit, (optional) _select)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.get_layer2_stretch_stats(extId, async_req=True)
+        >>> thread = api.get_layer2_stretch_stats(extId, _startTime, _endTime, async_req=True)
         >>> result = thread.get()
 
         :param extId: The UUID of the Layer2Stretch configuration.
         :type extId:
+
             :class:`str`, required
         :param _startTime: The start time of the period for which stats should be reported. The value should be in extended ISO-8601 format. For example, start time of 2022-04-23T01:23:45.678+09:00 would consider all stats starting at 1:23:45.678 on the 23rd of April 2022. Details around ISO-8601 format can be found at https://www.iso.org/standard/70907.html 
         :type _startTime:
-            :class:`str`
+
+            :class:`str`, required
         :param _endTime: The end time of the period for which stats should be reported. The value should be in extended ISO-8601 format. For example, end time of 2022-04-23T013:23:45.678+09:00 would consider all stats till 13:23:45 .678 on the 23rd of April 2022. Details around ISO-8601 format can be found at https://www.iso.org/standard/70907.html 
         :type _endTime:
-            :class:`str`
-        :param _samplingInterval: The sampling interval in seconds at which statistical data should be collected For example, do you want performance statistics every 30 seconds? Every 60 seconds? 
+
+            :class:`str`, required
+        :param _samplingInterval: The sampling interval in seconds at which statistical data should be collected. For example, if you want performance statistics every 30 seconds, then provide the value as 30. 
         :type _samplingInterval:
+
             :class:`int`
         :param _statType: 
         :type _statType:
+
             :class:`common.v1.stats.DownSamplingOperator`
-        :param _page: A URL query parameter that specifies the page number of the result set.  Must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range will lead to no results being returned. 
+        :param _page: A URL query parameter that specifies the page number of the result set. It must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range might lead to no results. 
         :type _page:
+
             :class:`int`
-        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided a default value of 50 records will be returned in the result set. 
+        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided, a default value of 50 records will be returned in the result set. 
         :type _limit:
+
             :class:`int`
-        :param _select: A URL query parameter that allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the OData V4.01 URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e. *), then all properties on the matching resource will be returned. - entityUuid - extId - links - rtt - statType - tenantId - throughputRxKbps - throughputTxKbps 
+        :param _select: A URL query parameter that allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the [OData V4.01](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html) URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e., *), then all properties on the matching resource will be returned. - entityUuid - extId - links - rtt - statType - tenantId - throughputRxKbps - throughputTxKbps 
         :type _select:
+
             :class:`str`
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.stats.Layer2StretchStatsApiResponse`.
+        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.stats.GetLayer2StretchStatsApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
             raise ValueError("Missing the required parameter `extId` when calling `get_layer2_stretch_stats`")  # noqa: E501
+        # verify the required parameter '_startTime' is set
+        if ('_startTime' not in params or params['_startTime'] is None):
+            raise ValueError("Missing the required parameter `_startTime` when calling `get_layer2_stretch_stats`")  # noqa: E501
+        # verify the required parameter '_endTime' is set
+        if ('_endTime' not in params or params['_endTime'] is None):
+            raise ValueError("Missing the required parameter `_endTime` when calling `get_layer2_stretch_stats`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
@@ -111,14 +125,16 @@
         if '_select' in params and params['_select'] is not None:
             query_params.append(('$select', params['_select']))  # noqa: E501
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -131,45 +147,48 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/stats/layer2-stretches/{extId}', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.stats.Layer2StretchStatsApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/stats/layer2-stretches/{extId}', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.stats.Layer2StretchStatsApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/stats/layer2-stretches/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.stats.GetLayer2StretchStatsApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/stats/layer2-stretches/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.stats.GetLayer2StretchStatsApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api/network_controller_api.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api/network_controllers_api.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,66 +3,67 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 from __future__ import absolute_import
 
 import re  # noqa: F401
 
 # python 2 and python 3 compatibility library
 import six
 
 from ntnx_networking_py_client.api_client import ApiClient
 
 
-class NetworkControllerApi(object):
+class NetworkControllersApi(object):
     """IGNORE:
     NOTE: A placeholder for class level description
     IGNORE
     """  # noqa: E501
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
 
         self.api_client = api_client
-        self.__headers_to_skip = { 'authorization', 'cookie', 'ntnx-request-id', 'host', 'user-agent' }
+        self.__headers_to_skip = { 'authorization', 'cookie', 'host', 'user-agent' }
 
     def create_network_controller(self, body, **kwargs):  # noqa: E501
         """Create a network controller
 
         >>> response = api.create_network_controller(body)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
         >>> thread = api.create_network_controller(body, async_req=True)
         >>> result = thread.get()
 
         :param body: Network controller to create
         :type body:
+
             :class:`~ntnx_networking_py_client.models.networking.v4.config.NetworkController`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
         :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.TaskReferenceApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'body' is set
         if ('body' not in params or params['body'] is None):
@@ -74,18 +75,22 @@
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
             ['application/json'])  # noqa: E501
+        if 'Content-Type' in params and params.get('Content-Type') is not None:
+            header_params['Content-Type'] = params.get('Content-Type')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -98,100 +103,106 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
+        # Authentication setting
+        auth_settings = ['basicAuthScheme']  # noqa: E501
+
         body_params = None
         if 'body' in params and params['body'] is not None:
             body_params = params['body']
 
-        # Authentication setting
-        auth_settings = ['basicAuthScheme']  # noqa: E501
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/controllers', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/controllers', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/controllers', 'POST',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/controllers', 'POST',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
-
-    def delete_network_controller(self, extId, **kwargs):  # noqa: E501
+    def delete_network_controller_by_id(self, extId, **kwargs):  # noqa: E501
         """Delete a network controller
 
-        >>> response = api.delete_network_controller(extId)
+        >>> response = api.delete_network_controller_by_id(extId)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.delete_network_controller(extId, async_req=True)
+        >>> thread = api.delete_network_controller_by_id(extId, async_req=True)
         >>> result = thread.get()
 
         :param extId: The UUID of the network controller
         :type extId:
+
             :class:`str`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
         :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.TaskReferenceApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `delete_network_controller`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `delete_network_controller_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -204,98 +215,104 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/controllers/{extId}', 'DELETE',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/controllers/{extId}', 'DELETE',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/controllers/{extId}', 'DELETE',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/controllers/{extId}', 'DELETE',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def get_network_controller(self, extId, **kwargs):  # noqa: E501
+    def get_network_controller_by_id(self, extId, **kwargs):  # noqa: E501
         """Get the network controller with the specified UUID
 
-        >>> response = api.get_network_controller(extId)
+        >>> response = api.get_network_controller_by_id(extId)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.get_network_controller(extId, async_req=True)
+        >>> thread = api.get_network_controller_by_id(extId, async_req=True)
         >>> result = thread.get()
 
         :param extId: The UUID of the network controller
         :type extId:
+
             :class:`str`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.NetworkControllerApiResponse`.
+        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.GetNetworkControllerApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `get_network_controller`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `get_network_controller_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -308,80 +325,85 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/controllers/{extId}', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.NetworkControllerApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/controllers/{extId}', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.NetworkControllerApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/controllers/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.GetNetworkControllerApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/controllers/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.GetNetworkControllerApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
     def list_network_controllers(self, _page=None, _limit=None, **kwargs):  # noqa: E501
         """Gets the list of existing network controllers
 
         >>> response = api.list_network_controllers((optional) _page, (optional) _limit)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
         >>> thread = api.list_network_controllers(async_req=True)
         >>> result = thread.get()
 
-        :param _page: A URL query parameter that specifies the page number of the result set.  Must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range will lead to no results being returned. 
+        :param _page: A URL query parameter that specifies the page number of the result set. It must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range might lead to no results. 
         :type _page:
+
             :class:`int`
-        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided a default value of 50 records will be returned in the result set. 
+        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided, a default value of 50 records will be returned in the result set. 
         :type _limit:
+
             :class:`int`
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.NetworkControllerListApiResponse`.
+        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.ListNetworkControllersApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
 
         collection_formats = {}
@@ -394,14 +416,16 @@
         if '_limit' in params and params['_limit'] is not None:
             query_params.append(('$limit', params['_limit']))  # noqa: E501
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -414,108 +438,117 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/controllers', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.NetworkControllerListApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/controllers', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.NetworkControllerListApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/controllers', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.ListNetworkControllersApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/controllers', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.ListNetworkControllersApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def update_network_controller(self, extId, body, **kwargs):  # noqa: E501
+    def update_network_controller_by_id(self, extId, body, **kwargs):  # noqa: E501
         """Update a network controller summary
 
-        >>> response = api.update_network_controller(extId, body)
+        >>> response = api.update_network_controller_by_id(extId, body)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.update_network_controller(extId, body, async_req=True)
+        >>> thread = api.update_network_controller_by_id(extId, body, async_req=True)
         >>> result = thread.get()
 
         :param extId: The UUID of the network controller
         :type extId:
+
             :class:`str`, required
         :param body: Network controller to update
         :type body:
+
             :class:`~ntnx_networking_py_client.models.networking.v4.config.NetworkController`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
         :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.TaskReferenceApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `update_network_controller`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `update_network_controller_by_id`")  # noqa: E501
         # verify the required parameter 'body' is set
         if ('body' not in params or params['body'] is None):
-            raise ValueError("Missing the required parameter `body` when calling `update_network_controller`")  # noqa: E501
+            raise ValueError("Missing the required parameter `body` when calling `update_network_controller_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
             ['application/json'])  # noqa: E501
+        if 'Content-Type' in params and params.get('Content-Type') is not None:
+            header_params['Content-Type'] = params.get('Content-Type')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -528,47 +561,50 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
+        # Authentication setting
+        auth_settings = ['basicAuthScheme']  # noqa: E501
+
         body_params = None
         if 'body' in params and params['body'] is not None:
             body_params = params['body']
 
-        # Authentication setting
-        auth_settings = ['basicAuthScheme']  # noqa: E501
-
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/controllers/{extId}', 'PUT',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/controllers/{extId}', 'PUT',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/controllers/{extId}', 'PUT',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/controllers/{extId}', 'PUT',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api/route_table_api.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api/route_tables_api.py`

 * *Files 3% similar despite different names*

```diff
@@ -3,87 +3,90 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 from __future__ import absolute_import
 
 import re  # noqa: F401
 
 # python 2 and python 3 compatibility library
 import six
 
 from ntnx_networking_py_client.api_client import ApiClient
 
 
-class RouteTableApi(object):
+class RouteTablesApi(object):
     """IGNORE:
     NOTE: A placeholder for class level description
     IGNORE
     """  # noqa: E501
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
 
         self.api_client = api_client
-        self.__headers_to_skip = { 'authorization', 'cookie', 'ntnx-request-id', 'host', 'user-agent' }
+        self.__headers_to_skip = { 'authorization', 'cookie', 'host', 'user-agent' }
 
-    def get_route_table(self, extId, **kwargs):  # noqa: E501
+    def get_route_table_by_id(self, extId, **kwargs):  # noqa: E501
         """Get route table
 
-        >>> response = api.get_route_table(extId)
+        >>> response = api.get_route_table_by_id(extId)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.get_route_table(extId, async_req=True)
+        >>> thread = api.get_route_table_by_id(extId, async_req=True)
         >>> result = thread.get()
 
         :param extId: Route table UUID
         :type extId:
+
             :class:`str`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.RouteTableApiResponse`.
+        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.GetRouteTableApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `get_route_table`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `get_route_table_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -96,83 +99,89 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/route-tables/{extId}', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.RouteTableApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/route-tables/{extId}', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.RouteTableApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/route-tables/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.GetRouteTableApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/route-tables/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.GetRouteTableApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
     def list_route_tables(self, _page=None, _limit=None, _filter=None, **kwargs):  # noqa: E501
         """List route tables
 
         >>> response = api.list_route_tables((optional) _page, (optional) _limit, (optional) _filter)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
         >>> thread = api.list_route_tables(async_req=True)
         >>> result = thread.get()
 
-        :param _page: A URL query parameter that specifies the page number of the result set.  Must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range will lead to no results being returned. 
+        :param _page: A URL query parameter that specifies the page number of the result set. It must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range might lead to no results. 
         :type _page:
+
             :class:`int`
-        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided a default value of 50 records will be returned in the result set. 
+        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided, a default value of 50 records will be returned in the result set. 
         :type _limit:
+
             :class:`int`
-        :param _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the OData V4.01 URL conventions. For example, filter '$filter=name eq 'karbon-ntnx-1.0' would filter result on cluster name karbon-ntnx1.0, filter '$filter=startswith(name, 'C')' would filter on cluster name starting with C. The filter can be applied on the following fields: - externalRoutingDomainReference - vpcReference 
+        :param _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the [OData V4.01](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html) URL conventions. For example, filter '$filter=name eq 'karbon-ntnx-1.0' would filter the result on cluster name 'karbon-ntnx1.0', filter '$filter=startswith(name, 'C')' would filter on cluster name starting with 'C'. The filter can be applied to the following fields: - externalRoutingDomainReference - vpcReference 
         :type _filter:
+
             :class:`str`
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.RouteTableListApiResponse`.
+        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.ListRouteTablesApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
 
         collection_formats = {}
@@ -187,14 +196,16 @@
         if '_filter' in params and params['_filter'] is not None:
             query_params.append(('$filter', params['_filter']))  # noqa: E501
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -207,108 +218,117 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/route-tables', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.RouteTableListApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/route-tables', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.RouteTableListApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/route-tables', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.ListRouteTablesApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/route-tables', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.ListRouteTablesApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def update_route_table(self, extId, body, **kwargs):  # noqa: E501
+    def update_route_table_by_id(self, extId, body, **kwargs):  # noqa: E501
         """Update route table
 
-        >>> response = api.update_route_table(extId, body)
+        >>> response = api.update_route_table_by_id(extId, body)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.update_route_table(extId, body, async_req=True)
+        >>> thread = api.update_route_table_by_id(extId, body, async_req=True)
         >>> result = thread.get()
 
         :param extId: Route table UUID
         :type extId:
+
             :class:`str`, required
         :param body: Update route table request body
         :type body:
+
             :class:`~ntnx_networking_py_client.models.networking.v4.config.RouteTable`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
         :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.TaskReferenceApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `update_route_table`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `update_route_table_by_id`")  # noqa: E501
         # verify the required parameter 'body' is set
         if ('body' not in params or params['body'] is None):
-            raise ValueError("Missing the required parameter `body` when calling `update_route_table`")  # noqa: E501
+            raise ValueError("Missing the required parameter `body` when calling `update_route_table_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
             ['application/json'])  # noqa: E501
+        if 'Content-Type' in params and params.get('Content-Type') is not None:
+            header_params['Content-Type'] = params.get('Content-Type')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -321,47 +341,50 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
+        # Authentication setting
+        auth_settings = ['basicAuthScheme']  # noqa: E501
+
         body_params = None
         if 'body' in params and params['body'] is not None:
             body_params = params['body']
 
-        # Authentication setting
-        auth_settings = ['basicAuthScheme']  # noqa: E501
-
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/route-tables/{extId}', 'PUT',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/route-tables/{extId}', 'PUT',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/route-tables/{extId}', 'PUT',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/route-tables/{extId}', 'PUT',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api/routing_policy_api.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api/routing_policies_api.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,66 +3,67 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 from __future__ import absolute_import
 
 import re  # noqa: F401
 
 # python 2 and python 3 compatibility library
 import six
 
 from ntnx_networking_py_client.api_client import ApiClient
 
 
-class RoutingPolicyApi(object):
+class RoutingPoliciesApi(object):
     """IGNORE:
     NOTE: A placeholder for class level description
     IGNORE
     """  # noqa: E501
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
 
         self.api_client = api_client
-        self.__headers_to_skip = { 'authorization', 'cookie', 'ntnx-request-id', 'host', 'user-agent' }
+        self.__headers_to_skip = { 'authorization', 'cookie', 'host', 'user-agent' }
 
     def create_routing_policy(self, body, **kwargs):  # noqa: E501
         """Create a Routing Policy.
 
         >>> response = api.create_routing_policy(body)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
         >>> thread = api.create_routing_policy(body, async_req=True)
         >>> result = thread.get()
 
         :param body: Schema to configure a routing policy.
         :type body:
+
             :class:`~ntnx_networking_py_client.models.networking.v4.config.RoutingPolicy`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
         :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.TaskReferenceApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'body' is set
         if ('body' not in params or params['body'] is None):
@@ -74,18 +75,22 @@
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
             ['application/json'])  # noqa: E501
+        if 'Content-Type' in params and params.get('Content-Type') is not None:
+            header_params['Content-Type'] = params.get('Content-Type')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -98,100 +103,106 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
+        # Authentication setting
+        auth_settings = ['basicAuthScheme']  # noqa: E501
+
         body_params = None
         if 'body' in params and params['body'] is not None:
             body_params = params['body']
 
-        # Authentication setting
-        auth_settings = ['basicAuthScheme']  # noqa: E501
-
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/routing-policies', 'POST',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/routing-policies', 'POST',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/routing-policies', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/routing-policies', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def delete_routing_policy(self, extId, **kwargs):  # noqa: E501
+    def delete_routing_policy_by_id(self, extId, **kwargs):  # noqa: E501
         """Delete the Routing Policy corresponding to the extId.
 
-        >>> response = api.delete_routing_policy(extId)
+        >>> response = api.delete_routing_policy_by_id(extId)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.delete_routing_policy(extId, async_req=True)
+        >>> thread = api.delete_routing_policy_by_id(extId, async_req=True)
         >>> result = thread.get()
 
         :param extId: ExtId of the Routing Policy.
         :type extId:
+
             :class:`str`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
         :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.TaskReferenceApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `delete_routing_policy`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `delete_routing_policy_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -204,98 +215,104 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/routing-policies/{extId}', 'DELETE',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/routing-policies/{extId}', 'DELETE',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/routing-policies/{extId}', 'DELETE',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/routing-policies/{extId}', 'DELETE',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def get_routing_policy(self, extId, **kwargs):  # noqa: E501
+    def get_routing_policy_by_id(self, extId, **kwargs):  # noqa: E501
         """Get a single Routing Policy corresponding to the extId.
 
-        >>> response = api.get_routing_policy(extId)
+        >>> response = api.get_routing_policy_by_id(extId)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.get_routing_policy(extId, async_req=True)
+        >>> thread = api.get_routing_policy_by_id(extId, async_req=True)
         >>> result = thread.get()
 
         :param extId: ExtId of the Routing Policy.
         :type extId:
+
             :class:`str`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.RoutingPolicyApiResponse`.
+        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.GetRoutingPolicyApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `get_routing_policy`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `get_routing_policy_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -308,86 +325,101 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/routing-policies/{extId}', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.RoutingPolicyApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/routing-policies/{extId}', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.RoutingPolicyApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/routing-policies/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.GetRoutingPolicyApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/routing-policies/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.GetRoutingPolicyApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def list_routing_policies(self, _page=None, _limit=None, _filter=None, _orderby=None, **kwargs):  # noqa: E501
+    def list_routing_policies(self, _page=None, _limit=None, _filter=None, _orderby=None, _expand=None, _select=None, **kwargs):  # noqa: E501
         """Get a list of Routing Policies.
 
-        >>> response = api.list_routing_policies((optional) _page, (optional) _limit, (optional) _filter, (optional) _orderby)
+        >>> response = api.list_routing_policies((optional) _page, (optional) _limit, (optional) _filter, (optional) _orderby, (optional) _expand, (optional) _select)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
         >>> thread = api.list_routing_policies(async_req=True)
         >>> result = thread.get()
 
-        :param _page: A URL query parameter that specifies the page number of the result set.  Must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range will lead to no results being returned. 
+        :param _page: A URL query parameter that specifies the page number of the result set. It must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range might lead to no results. 
         :type _page:
+
             :class:`int`
-        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided a default value of 50 records will be returned in the result set. 
+        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided, a default value of 50 records will be returned in the result set. 
         :type _limit:
+
             :class:`int`
-        :param _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the OData V4.01 URL conventions. For example, filter '$filter=name eq 'karbon-ntnx-1.0' would filter result on cluster name karbon-ntnx1.0, filter '$filter=startswith(name, 'C')' would filter on cluster name starting with C. The filter can be applied on the following fields: - name - policies/policyAction/actionType - policies/policyMatch/protocolType - policies/policyMatch/source - priority - vpcExtId 
+        :param _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the [OData V4.01](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html) URL conventions. For example, filter '$filter=name eq 'karbon-ntnx-1.0' would filter the result on cluster name 'karbon-ntnx1.0', filter '$filter=startswith(name, 'C')' would filter on cluster name starting with 'C'. The filter can be applied to the following fields: - name - policies/policyAction/actionType - policies/policyMatch/protocolType - policies/policyMatch/source - priority - vpcExtId 
         :type _filter:
+
             :class:`str`
-        :param _orderby: A URL query parameter that allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified the resources will be sorted in ascending order by default. For example, '$orderby=templateName desc' would get all templates sorted by templateName in desc order. The orderby can be applied to the following fields: - name - priority 
+        :param _orderby: A URL query parameter that allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified, the resources will be sorted in ascending order by default. For example, '$orderby=templateName desc' would get all templates sorted by templateName in descending order. The orderby can be applied to the following fields: - name - priority 
         :type _orderby:
+
+            :class:`str`
+        :param _expand: A URL query parameter that allows clients to request related resources when a resource that satisfies a particular request is retrieved. Each expanded item is evaluated relative to the entity containing the property being expanded. Other query options can be applied to an expanded property by appending a semicolon-separated list of query options, enclosed in parentheses, to the property name. Permissible system query options are $filter, $select and $orderby. The following expansion keys are supported. - vpc 
+        :type _expand:
+
+            :class:`str`
+        :param _select: A URL query parameter that allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the [OData V4.01](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html) URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e., *), then all properties on the matching resource will be returned. - description - extId - links - metadata - name - policies - priority - tenantId - vpc - vpcExtId 
+        :type _select:
+
             :class:`str`
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.RoutingPolicyListApiResponse`.
+        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.ListRoutingPoliciesApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
 
         collection_formats = {}
@@ -399,133 +431,148 @@
             query_params.append(('$page', params['_page']))  # noqa: E501
         if '_limit' in params and params['_limit'] is not None:
             query_params.append(('$limit', params['_limit']))  # noqa: E501
         if '_filter' in params and params['_filter'] is not None:
             query_params.append(('$filter', params['_filter']))  # noqa: E501
         if '_orderby' in params and params['_orderby'] is not None:
             query_params.append(('$orderby', params['_orderby']))  # noqa: E501
+        if '_expand' in params and params['_expand'] is not None:
+            query_params.append(('$expand', params['_expand']))  # noqa: E501
+        if '_select' in params and params['_select'] is not None:
+            query_params.append(('$select', params['_select']))  # noqa: E501
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
-        all_params = set(['_page', '_limit', '_filter', '_orderby'])
+        all_params = set(['_page', '_limit', '_filter', '_orderby', '_expand', '_select'])
         all_params.update(extra_params)
         for key, val in six.iteritems(params):
             if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                 if key.lower() == 'if_match'.lower():
                     key = 'If-Match'
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/routing-policies', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.RoutingPolicyListApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/routing-policies', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.RoutingPolicyListApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/routing-policies', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.ListRoutingPoliciesApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/routing-policies', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.ListRoutingPoliciesApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def put_routing_policy(self, extId, body, **kwargs):  # noqa: E501
+    def update_routing_policy_by_id(self, extId, body, **kwargs):  # noqa: E501
         """Update the Routing Policy corresponding to the extId.
 
-        >>> response = api.put_routing_policy(extId, body)
+        >>> response = api.update_routing_policy_by_id(extId, body)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.put_routing_policy(extId, body, async_req=True)
+        >>> thread = api.update_routing_policy_by_id(extId, body, async_req=True)
         >>> result = thread.get()
 
         :param extId: ExtId of the Routing Policy.
         :type extId:
+
             :class:`str`, required
         :param body: Schema to configure a routing policy.
         :type body:
+
             :class:`~ntnx_networking_py_client.models.networking.v4.config.RoutingPolicy`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
         :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.TaskReferenceApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `put_routing_policy`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `update_routing_policy_by_id`")  # noqa: E501
         # verify the required parameter 'body' is set
         if ('body' not in params or params['body'] is None):
-            raise ValueError("Missing the required parameter `body` when calling `put_routing_policy`")  # noqa: E501
+            raise ValueError("Missing the required parameter `body` when calling `update_routing_policy_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
             ['application/json'])  # noqa: E501
+        if 'Content-Type' in params and params.get('Content-Type') is not None:
+            header_params['Content-Type'] = params.get('Content-Type')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -538,47 +585,50 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
+        # Authentication setting
+        auth_settings = ['basicAuthScheme']  # noqa: E501
+
         body_params = None
         if 'body' in params and params['body'] is not None:
             body_params = params['body']
 
-        # Authentication setting
-        auth_settings = ['basicAuthScheme']  # noqa: E501
-
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/routing-policies/{extId}', 'PUT',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/routing-policies/{extId}', 'PUT',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/routing-policies/{extId}', 'PUT',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/routing-policies/{extId}', 'PUT',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api/routing_policy_stats_api.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api/virtual_switch_nodes_info_api.py`

 * *Files 16% similar despite different names*

```diff
@@ -3,142 +3,141 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 from __future__ import absolute_import
 
 import re  # noqa: F401
 
 # python 2 and python 3 compatibility library
 import six
 
 from ntnx_networking_py_client.api_client import ApiClient
 
 
-class RoutingPolicyStatsApi(object):
+class VirtualSwitchNodesInfoApi(object):
     """IGNORE:
     NOTE: A placeholder for class level description
     IGNORE
     """  # noqa: E501
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
 
         self.api_client = api_client
-        self.__headers_to_skip = { 'authorization', 'cookie', 'ntnx-request-id', 'host', 'user-agent' }
+        self.__headers_to_skip = { 'authorization', 'cookie', 'host', 'user-agent' }
 
-    def clear_routing_policy_counters(self, body, **kwargs):  # noqa: E501
-        """Clear the value in packet and byte counters of all Routing Policies in the chosen VPC or particular routing policy.
+    def list_node_schedulable_status(self, X_Cluster_Id=None, **kwargs):  # noqa: E501
+        """Check whether a node in a cluster is a storage-only node or not
 
-        >>> response = api.clear_routing_policy_counters(body)
+        >>> response = api.list_node_schedulable_status((optional) X_Cluster_Id)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.clear_routing_policy_counters(body, async_req=True)
+        >>> thread = api.list_node_schedulable_status(async_req=True)
         >>> result = thread.get()
 
-        :param body: VPC UUID to reset all routing policy counters to zero.
-        :type body:
-            :class:`~ntnx_networking_py_client.models.networking.v4.stats.RoutingPolicyClearCountersSpec`, required
+        :param X_Cluster_Id: Prism Element cluster reference. This header can be optionally supplied for Virtual Switch list requests, but is deprecated for all other Virtual Switch fetch/create/update/delete requests. 
+        :type X_Cluster_Id:
+
+            :class:`str`
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.stats.TaskReferenceApiResponse`.
+        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.ListNodeSchedulableStatusesApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
-        # verify the required parameter 'body' is set
-        if ('body' not in params or params['body'] is None):
-            raise ValueError("Missing the required parameter `body` when calling `clear_routing_policy_counters`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
+        if 'X_Cluster_Id' in params and params['X_Cluster_Id'] is not None:
+            header_params['X-Cluster-Id'] = params['X_Cluster_Id']  # noqa: E501
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
-
-        # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
-        all_params = set(['body'])
+        all_params = set(['X_Cluster_Id'])
         all_params.update(extra_params)
         for key, val in six.iteritems(params):
             if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                 if key.lower() == 'if_match'.lower():
                     key = 'If-Match'
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params and params['body'] is not None:
-            body_params = params['body']
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/stats/routing-policies/$actions/clear', 'POST',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.stats.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/stats/routing-policies/$actions/clear', 'POST',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.stats.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/node-schedulable-status', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.ListNodeSchedulableStatusesApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/node-schedulable-status', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.ListNodeSchedulableStatusesApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api/subnet_api.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api/subnets_api.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,66 +3,67 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 from __future__ import absolute_import
 
 import re  # noqa: F401
 
 # python 2 and python 3 compatibility library
 import six
 
 from ntnx_networking_py_client.api_client import ApiClient
 
 
-class SubnetApi(object):
+class SubnetsApi(object):
     """IGNORE:
     NOTE: A placeholder for class level description
     IGNORE
     """  # noqa: E501
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
 
         self.api_client = api_client
-        self.__headers_to_skip = { 'authorization', 'cookie', 'ntnx-request-id', 'host', 'user-agent' }
+        self.__headers_to_skip = { 'authorization', 'cookie', 'host', 'user-agent' }
 
     def create_subnet(self, body, **kwargs):  # noqa: E501
         """Create a subnet.
 
         >>> response = api.create_subnet(body)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
         >>> thread = api.create_subnet(body, async_req=True)
         >>> result = thread.get()
 
         :param body: Request schema to create the subnet.
         :type body:
+
             :class:`~ntnx_networking_py_client.models.networking.v4.config.Subnet`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
         :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.TaskReferenceApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'body' is set
         if ('body' not in params or params['body'] is None):
@@ -74,18 +75,22 @@
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
             ['application/json'])  # noqa: E501
+        if 'Content-Type' in params and params.get('Content-Type') is not None:
+            header_params['Content-Type'] = params.get('Content-Type')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -98,100 +103,106 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
+        # Authentication setting
+        auth_settings = ['basicAuthScheme']  # noqa: E501
+
         body_params = None
         if 'body' in params and params['body'] is not None:
             body_params = params['body']
 
-        # Authentication setting
-        auth_settings = ['basicAuthScheme']  # noqa: E501
-
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/subnets', 'POST',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/subnets', 'POST',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/subnets', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/subnets', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def delete_subnet(self, extId, **kwargs):  # noqa: E501
+    def delete_subnet_by_id(self, extId, **kwargs):  # noqa: E501
         """Delete the specified subnet.
 
-        >>> response = api.delete_subnet(extId)
+        >>> response = api.delete_subnet_by_id(extId)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.delete_subnet(extId, async_req=True)
+        >>> thread = api.delete_subnet_by_id(extId, async_req=True)
         >>> result = thread.get()
 
         :param extId: The UUID of the subnet.
         :type extId:
+
             :class:`str`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
         :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.TaskReferenceApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `delete_subnet`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `delete_subnet_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -204,98 +215,104 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/subnets/{extId}', 'DELETE',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/subnets/{extId}', 'DELETE',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/subnets/{extId}', 'DELETE',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/subnets/{extId}', 'DELETE',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def get_subnet(self, extId, **kwargs):  # noqa: E501
+    def get_subnet_by_id(self, extId, **kwargs):  # noqa: E501
         """Get the subnet with the specified UUID.
 
-        >>> response = api.get_subnet(extId)
+        >>> response = api.get_subnet_by_id(extId)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.get_subnet(extId, async_req=True)
+        >>> thread = api.get_subnet_by_id(extId, async_req=True)
         >>> result = thread.get()
 
         :param extId: The UUID of the subnet.
         :type extId:
+
             :class:`str`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.SubnetApiResponse`.
+        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.GetSubnetApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `get_subnet`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `get_subnet_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -308,92 +325,101 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/subnets/{extId}', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.SubnetApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/subnets/{extId}', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.SubnetApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/subnets/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.GetSubnetApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/subnets/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.GetSubnetApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
     def list_subnets(self, _page=None, _limit=None, _filter=None, _orderby=None, _expand=None, _select=None, **kwargs):  # noqa: E501
         """Get the list of existing subnets.
 
         >>> response = api.list_subnets((optional) _page, (optional) _limit, (optional) _filter, (optional) _orderby, (optional) _expand, (optional) _select)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
         >>> thread = api.list_subnets(async_req=True)
         >>> result = thread.get()
 
-        :param _page: A URL query parameter that specifies the page number of the result set.  Must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range will lead to no results being returned. 
+        :param _page: A URL query parameter that specifies the page number of the result set. It must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range might lead to no results. 
         :type _page:
+
             :class:`int`
-        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided a default value of 50 records will be returned in the result set. 
+        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided, a default value of 50 records will be returned in the result set. 
         :type _limit:
+
             :class:`int`
-        :param _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the OData V4.01 URL conventions. For example, filter '$filter=name eq 'karbon-ntnx-1.0' would filter result on cluster name karbon-ntnx1.0, filter '$filter=startswith(name, 'C')' would filter on cluster name starting with C. The filter can be applied on the following fields: - clusterReference - isExternal - name - subnetType - vpcReference 
+        :param _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the [OData V4.01](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html) URL conventions. For example, filter '$filter=name eq 'karbon-ntnx-1.0' would filter the result on cluster name 'karbon-ntnx1.0', filter '$filter=startswith(name, 'C')' would filter on cluster name starting with 'C'. The filter can be applied to the following fields: - clusterReference - isExternal - name - subnetType - vpcReference 
         :type _filter:
+
             :class:`str`
-        :param _orderby: A URL query parameter that allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified the resources will be sorted in ascending order by default. For example, '$orderby=templateName desc' would get all templates sorted by templateName in desc order. The orderby can be applied to the following fields: - name 
+        :param _orderby: A URL query parameter that allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified, the resources will be sorted in ascending order by default. For example, '$orderby=templateName desc' would get all templates sorted by templateName in descending order. The orderby can be applied to the following fields: - name 
         :type _orderby:
+
             :class:`str`
-        :param _expand: A URL query parameter that allows clients to request related resources when a resource that satisfies a particular request is retrieved. Each expand item is evaluated relative to the entity containing the property being expanded. Other query options can be applied to an expanded property by appending a semicolon-separated list of query options, enclosed in parentheses, to the property name. Allowed system query options are $filter, $select, $orderby. The following expansion keys are supported. - virtualSwitch - vpc 
+        :param _expand: A URL query parameter that allows clients to request related resources when a resource that satisfies a particular request is retrieved. Each expanded item is evaluated relative to the entity containing the property being expanded. Other query options can be applied to an expanded property by appending a semicolon-separated list of query options, enclosed in parentheses, to the property name. Permissible system query options are $filter, $select and $orderby. The following expansion keys are supported. - virtualSwitch - vpc 
         :type _expand:
+
             :class:`str`
-        :param _select: A URL query parameter that allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the OData V4.01 URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e. *), then all properties on the matching resource will be returned. - bridgeName - clusterName - clusterReference - description - dhcpOptions - dynamicIpAddresses - extId - hypervisorType - ipConfig - ipPrefix - ipUsage - isAdvancedNetworking - isExternal - isNatEnabled - links - metadata - migrationState - name - networkFunctionChainReference - networkId - reservedIpAddresses - subnetType - tenantId - virtualSwitch - virtualSwitchReference - vpc - vpcReference 
+        :param _select: A URL query parameter that allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the [OData V4.01](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html) URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e., *), then all properties on the matching resource will be returned. - clusterName - clusterReference - extId - hypervisorType - ipPrefix - isAdvancedNetworking - isExternal - isNatEnabled - links - metadata - name - networkId - subnetType - tenantId - virtualSwitchReference - vpcReference 
         :type _select:
+
             :class:`str`
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.SubnetListApiResponse`.
+        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.ListSubnetsApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
 
         collection_formats = {}
@@ -414,14 +440,16 @@
         if '_select' in params and params['_select'] is not None:
             query_params.append(('$select', params['_select']))  # noqa: E501
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -434,108 +462,117 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/subnets', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.SubnetListApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/subnets', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.SubnetListApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/subnets', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.ListSubnetsApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/subnets', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.ListSubnetsApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def update_subnet(self, extId, body, **kwargs):  # noqa: E501
+    def update_subnet_by_id(self, extId, body, **kwargs):  # noqa: E501
         """Update the specified subnet.
 
-        >>> response = api.update_subnet(extId, body)
+        >>> response = api.update_subnet_by_id(extId, body)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.update_subnet(extId, body, async_req=True)
+        >>> thread = api.update_subnet_by_id(extId, body, async_req=True)
         >>> result = thread.get()
 
         :param extId: The UUID of the subnet.
         :type extId:
+
             :class:`str`, required
         :param body: Request schema to update the specified subnet.
         :type body:
+
             :class:`~ntnx_networking_py_client.models.networking.v4.config.Subnet`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
         :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.TaskReferenceApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `update_subnet`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `update_subnet_by_id`")  # noqa: E501
         # verify the required parameter 'body' is set
         if ('body' not in params or params['body'] is None):
-            raise ValueError("Missing the required parameter `body` when calling `update_subnet`")  # noqa: E501
+            raise ValueError("Missing the required parameter `body` when calling `update_subnet_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
             ['application/json'])  # noqa: E501
+        if 'Content-Type' in params and params.get('Content-Type') is not None:
+            header_params['Content-Type'] = params.get('Content-Type')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -548,47 +585,50 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
+        # Authentication setting
+        auth_settings = ['basicAuthScheme']  # noqa: E501
+
         body_params = None
         if 'body' in params and params['body'] is not None:
             body_params = params['body']
 
-        # Authentication setting
-        auth_settings = ['basicAuthScheme']  # noqa: E501
-
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/subnets/{extId}', 'PUT',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/subnets/{extId}', 'PUT',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/subnets/{extId}', 'PUT',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/subnets/{extId}', 'PUT',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api/subnet_reserve_unreserve_ip_api.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api/subnet_ip_reservation_api.py`

 * *Files 14% similar despite different names*

```diff
@@ -3,97 +3,103 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 from __future__ import absolute_import
 
 import re  # noqa: F401
 
 # python 2 and python 3 compatibility library
 import six
 
 from ntnx_networking_py_client.api_client import ApiClient
 
 
-class SubnetReserveUnreserveIpApi(object):
+class SubnetIPReservationApi(object):
     """IGNORE:
     NOTE: A placeholder for class level description
     IGNORE
     """  # noqa: E501
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
 
         self.api_client = api_client
-        self.__headers_to_skip = { 'authorization', 'cookie', 'ntnx-request-id', 'host', 'user-agent' }
+        self.__headers_to_skip = { 'authorization', 'cookie', 'host', 'user-agent' }
 
-    def reserve_ips(self, extId, body, **kwargs):  # noqa: E501
+    def reserve_ips_by_subnet_id(self, extId, body, **kwargs):  # noqa: E501
         """Reserve IP addresses on a subnet.
 
-        >>> response = api.reserve_ips(extId, body)
+        >>> response = api.reserve_ips_by_subnet_id(extId, body)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.reserve_ips(extId, body, async_req=True)
+        >>> thread = api.reserve_ips_by_subnet_id(extId, body, async_req=True)
         >>> result = thread.get()
 
         :param extId: The UUID of the subnet.
         :type extId:
+
             :class:`str`, required
         :param body: Request schema to reserve IP addresses on a subnet.
         :type body:
+
             :class:`~ntnx_networking_py_client.models.networking.v4.config.IpReserveSpec`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
         :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.TaskReferenceApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `reserve_ips`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `reserve_ips_by_subnet_id`")  # noqa: E501
         # verify the required parameter 'body' is set
         if ('body' not in params or params['body'] is None):
-            raise ValueError("Missing the required parameter `body` when calling `reserve_ips`")  # noqa: E501
+            raise ValueError("Missing the required parameter `body` when calling `reserve_ips_by_subnet_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
             ['application/json'])  # noqa: E501
+        if 'Content-Type' in params and params.get('Content-Type') is not None:
+            header_params['Content-Type'] = params.get('Content-Type')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -106,110 +112,119 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
+        # Authentication setting
+        auth_settings = ['basicAuthScheme']  # noqa: E501
+
         body_params = None
         if 'body' in params and params['body'] is not None:
             body_params = params['body']
 
-        # Authentication setting
-        auth_settings = ['basicAuthScheme']  # noqa: E501
-
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/subnets/{extId}/addresses/$actions/reserve', 'POST',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/subnets/{extId}/addresses/$actions/reserve', 'POST',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/subnets/{extId}/addresses/$actions/reserve', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/subnets/{extId}/addresses/$actions/reserve', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def unreserve_ips(self, extId, body, **kwargs):  # noqa: E501
+    def unreserve_ips_by_subnet_id(self, extId, body, **kwargs):  # noqa: E501
         """Unreserve IP addresses on a subnet.
 
-        >>> response = api.unreserve_ips(extId, body)
+        >>> response = api.unreserve_ips_by_subnet_id(extId, body)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.unreserve_ips(extId, body, async_req=True)
+        >>> thread = api.unreserve_ips_by_subnet_id(extId, body, async_req=True)
         >>> result = thread.get()
 
         :param extId: The UUID of the subnet.
         :type extId:
+
             :class:`str`, required
         :param body: Request schema to unreserve IP addresses on a subnet.
         :type body:
+
             :class:`~ntnx_networking_py_client.models.networking.v4.config.IpUnreserveSpec`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
         :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.TaskReferenceApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `unreserve_ips`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `unreserve_ips_by_subnet_id`")  # noqa: E501
         # verify the required parameter 'body' is set
         if ('body' not in params or params['body'] is None):
-            raise ValueError("Missing the required parameter `body` when calling `unreserve_ips`")  # noqa: E501
+            raise ValueError("Missing the required parameter `body` when calling `unreserve_ips_by_subnet_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
             ['application/json'])  # noqa: E501
+        if 'Content-Type' in params and params.get('Content-Type') is not None:
+            header_params['Content-Type'] = params.get('Content-Type')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -222,47 +237,50 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
+        # Authentication setting
+        auth_settings = ['basicAuthScheme']  # noqa: E501
+
         body_params = None
         if 'body' in params and params['body'] is not None:
             body_params = params['body']
 
-        # Authentication setting
-        auth_settings = ['basicAuthScheme']  # noqa: E501
-
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/subnets/{extId}/addresses/$actions/unreserve', 'POST',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/subnets/{extId}/addresses/$actions/unreserve', 'POST',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/subnets/{extId}/addresses/$actions/unreserve', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/subnets/{extId}/addresses/$actions/unreserve', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api/traffic_mirror_api.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api/traffic_mirrors_api.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,66 +3,67 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 from __future__ import absolute_import
 
 import re  # noqa: F401
 
 # python 2 and python 3 compatibility library
 import six
 
 from ntnx_networking_py_client.api_client import ApiClient
 
 
-class TrafficMirrorApi(object):
+class TrafficMirrorsApi(object):
     """IGNORE:
     NOTE: A placeholder for class level description
     IGNORE
     """  # noqa: E501
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
 
         self.api_client = api_client
-        self.__headers_to_skip = { 'authorization', 'cookie', 'ntnx-request-id', 'host', 'user-agent' }
+        self.__headers_to_skip = { 'authorization', 'cookie', 'host', 'user-agent' }
 
     def create_traffic_mirror(self, body, **kwargs):  # noqa: E501
         """Create Traffic mirror session.
 
         >>> response = api.create_traffic_mirror(body)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
         >>> thread = api.create_traffic_mirror(body, async_req=True)
         >>> result = thread.get()
 
         :param body: Create Traffic mirror session request body.
         :type body:
+
             :class:`~ntnx_networking_py_client.models.networking.v4.config.TrafficMirror`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
         :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.TaskReferenceApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'body' is set
         if ('body' not in params or params['body'] is None):
@@ -74,18 +75,22 @@
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
             ['application/json'])  # noqa: E501
+        if 'Content-Type' in params and params.get('Content-Type') is not None:
+            header_params['Content-Type'] = params.get('Content-Type')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -98,100 +103,106 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
+        # Authentication setting
+        auth_settings = ['basicAuthScheme']  # noqa: E501
+
         body_params = None
         if 'body' in params and params['body'] is not None:
             body_params = params['body']
 
-        # Authentication setting
-        auth_settings = ['basicAuthScheme']  # noqa: E501
-
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/traffic-mirrors', 'POST',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/traffic-mirrors', 'POST',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/traffic-mirrors', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/traffic-mirrors', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def delete_traffic_mirror(self, extId, **kwargs):  # noqa: E501
+    def delete_traffic_mirror_by_id(self, extId, **kwargs):  # noqa: E501
         """Delete Traffic mirror session.
 
-        >>> response = api.delete_traffic_mirror(extId)
+        >>> response = api.delete_traffic_mirror_by_id(extId)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.delete_traffic_mirror(extId, async_req=True)
+        >>> thread = api.delete_traffic_mirror_by_id(extId, async_req=True)
         >>> result = thread.get()
 
         :param extId: UUID of the session.
         :type extId:
+
             :class:`str`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
         :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.TaskReferenceApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `delete_traffic_mirror`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `delete_traffic_mirror_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -204,98 +215,104 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/traffic-mirrors/{extId}', 'DELETE',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/traffic-mirrors/{extId}', 'DELETE',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/traffic-mirrors/{extId}', 'DELETE',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/traffic-mirrors/{extId}', 'DELETE',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def get_traffic_mirror(self, extId, **kwargs):  # noqa: E501
+    def get_traffic_mirror_by_id(self, extId, **kwargs):  # noqa: E501
         """Get Traffic mirror session.
 
-        >>> response = api.get_traffic_mirror(extId)
+        >>> response = api.get_traffic_mirror_by_id(extId)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.get_traffic_mirror(extId, async_req=True)
+        >>> thread = api.get_traffic_mirror_by_id(extId, async_req=True)
         >>> result = thread.get()
 
         :param extId: UUID of the session.
         :type extId:
+
             :class:`str`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.TrafficMirrorApiResponse`.
+        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.GetTrafficMirrorApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `get_traffic_mirror`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `get_traffic_mirror_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -308,86 +325,93 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/traffic-mirrors/{extId}', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TrafficMirrorApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/traffic-mirrors/{extId}', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TrafficMirrorApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/traffic-mirrors/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.GetTrafficMirrorApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/traffic-mirrors/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.GetTrafficMirrorApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
     def list_traffic_mirrors(self, _page=None, _limit=None, _filter=None, _orderby=None, **kwargs):  # noqa: E501
         """List Traffic mirror sessions.
 
         >>> response = api.list_traffic_mirrors((optional) _page, (optional) _limit, (optional) _filter, (optional) _orderby)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
         >>> thread = api.list_traffic_mirrors(async_req=True)
         >>> result = thread.get()
 
-        :param _page: A URL query parameter that specifies the page number of the result set.  Must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range will lead to no results being returned. 
+        :param _page: A URL query parameter that specifies the page number of the result set. It must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range might lead to no results. 
         :type _page:
+
             :class:`int`
-        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided a default value of 50 records will be returned in the result set. 
+        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided, a default value of 50 records will be returned in the result set. 
         :type _limit:
+
             :class:`int`
-        :param _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the OData V4.01 URL conventions. For example, filter '$filter=name eq 'karbon-ntnx-1.0' would filter result on cluster name karbon-ntnx1.0, filter '$filter=startswith(name, 'C')' would filter on cluster name starting with C. The filter can be applied on the following fields: - isEnabled - name 
+        :param _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the [OData V4.01](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html) URL conventions. For example, filter '$filter=name eq 'karbon-ntnx-1.0' would filter the result on cluster name 'karbon-ntnx1.0', filter '$filter=startswith(name, 'C')' would filter on cluster name starting with 'C'. The filter can be applied to the following fields: - isEnabled - name 
         :type _filter:
+
             :class:`str`
-        :param _orderby: A URL query parameter that allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified the resources will be sorted in ascending order by default. For example, '$orderby=templateName desc' would get all templates sorted by templateName in desc order. The orderby can be applied to the following fields: - name 
+        :param _orderby: A URL query parameter that allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified, the resources will be sorted in ascending order by default. For example, '$orderby=templateName desc' would get all templates sorted by templateName in descending order. The orderby can be applied to the following fields: - name 
         :type _orderby:
+
             :class:`str`
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.TrafficMirrorListApiResponse`.
+        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.ListTrafficMirrorsApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
 
         collection_formats = {}
@@ -404,14 +428,16 @@
         if '_orderby' in params and params['_orderby'] is not None:
             query_params.append(('$orderby', params['_orderby']))  # noqa: E501
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -424,108 +450,117 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/traffic-mirrors', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TrafficMirrorListApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/traffic-mirrors', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TrafficMirrorListApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/traffic-mirrors', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.ListTrafficMirrorsApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/traffic-mirrors', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.ListTrafficMirrorsApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def update_traffic_mirror(self, extId, body, **kwargs):  # noqa: E501
+    def update_traffic_mirror_by_id(self, extId, body, **kwargs):  # noqa: E501
         """Update a Traffic mirror session for the provided UUID.
 
-        >>> response = api.update_traffic_mirror(extId, body)
+        >>> response = api.update_traffic_mirror_by_id(extId, body)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.update_traffic_mirror(extId, body, async_req=True)
+        >>> thread = api.update_traffic_mirror_by_id(extId, body, async_req=True)
         >>> result = thread.get()
 
         :param extId: UUID of the session.
         :type extId:
+
             :class:`str`, required
         :param body: Update Traffic mirror session request body.
         :type body:
+
             :class:`~ntnx_networking_py_client.models.networking.v4.config.TrafficMirror`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
         :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.TaskReferenceApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `update_traffic_mirror`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `update_traffic_mirror_by_id`")  # noqa: E501
         # verify the required parameter 'body' is set
         if ('body' not in params or params['body'] is None):
-            raise ValueError("Missing the required parameter `body` when calling `update_traffic_mirror`")  # noqa: E501
+            raise ValueError("Missing the required parameter `body` when calling `update_traffic_mirror_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
             ['application/json'])  # noqa: E501
+        if 'Content-Type' in params and params.get('Content-Type') is not None:
+            header_params['Content-Type'] = params.get('Content-Type')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -538,47 +573,50 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
+        # Authentication setting
+        auth_settings = ['basicAuthScheme']  # noqa: E501
+
         body_params = None
         if 'body' in params and params['body'] is not None:
             body_params = params['body']
 
-        # Authentication setting
-        auth_settings = ['basicAuthScheme']  # noqa: E501
-
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/traffic-mirrors/{extId}', 'PUT',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/traffic-mirrors/{extId}', 'PUT',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/traffic-mirrors/{extId}', 'PUT',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/traffic-mirrors/{extId}', 'PUT',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api/traffic_mirror_stats_api.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api/traffic_mirror_stats_api.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,15 +3,15 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 from __future__ import absolute_import
 
 import re  # noqa: F401
@@ -29,63 +29,75 @@
     """  # noqa: E501
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
 
         self.api_client = api_client
-        self.__headers_to_skip = { 'authorization', 'cookie', 'ntnx-request-id', 'host', 'user-agent' }
+        self.__headers_to_skip = { 'authorization', 'cookie', 'host', 'user-agent' }
 
-    def get_traffic_mirror_stats(self, extId, _startTime=None, _endTime=None, _samplingInterval=None, _statType=None, _select=None, **kwargs):  # noqa: E501
+    def get_traffic_mirror_stats(self, extId, _startTime, _endTime, _samplingInterval=None, _statType=None, _select=None, **kwargs):  # noqa: E501
         """Get Traffic mirror session statistics.
 
-        >>> response = api.get_traffic_mirror_stats(extId, (optional) _startTime, (optional) _endTime, (optional) _samplingInterval, (optional) _statType, (optional) _select)
+        >>> response = api.get_traffic_mirror_stats(extId, _startTime, _endTime, (optional) _samplingInterval, (optional) _statType, (optional) _select)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.get_traffic_mirror_stats(extId, async_req=True)
+        >>> thread = api.get_traffic_mirror_stats(extId, _startTime, _endTime, async_req=True)
         >>> result = thread.get()
 
         :param extId: UUID of the session.
         :type extId:
+
             :class:`str`, required
         :param _startTime: The start time of the period for which stats should be reported. The value should be in extended ISO-8601 format. For example, start time of 2022-04-23T01:23:45.678+09:00 would consider all stats starting at 1:23:45.678 on the 23rd of April 2022. Details around ISO-8601 format can be found at https://www.iso.org/standard/70907.html 
         :type _startTime:
-            :class:`str`
+
+            :class:`str`, required
         :param _endTime: The end time of the period for which stats should be reported. The value should be in extended ISO-8601 format. For example, end time of 2022-04-23T013:23:45.678+09:00 would consider all stats till 13:23:45 .678 on the 23rd of April 2022. Details around ISO-8601 format can be found at https://www.iso.org/standard/70907.html 
         :type _endTime:
-            :class:`str`
-        :param _samplingInterval: The sampling interval in seconds at which statistical data should be collected For example, do you want performance statistics every 30 seconds? Every 60 seconds? 
+
+            :class:`str`, required
+        :param _samplingInterval: The sampling interval in seconds at which statistical data should be collected. For example, if you want performance statistics every 30 seconds, then provide the value as 30. 
         :type _samplingInterval:
+
             :class:`int`
         :param _statType: 
         :type _statType:
+
             :class:`common.v1.stats.DownSamplingOperator`
-        :param _select: A URL query parameter that allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the OData V4.01 URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e. *), then all properties on the matching resource will be returned. - entityUuid - extId - links - name - statType - state - stateMessage - statsData - tenantId 
+        :param _select: A URL query parameter that allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the [OData V4.01](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html) URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e., *), then all properties on the matching resource will be returned. - entityUuid - extId - links - name - statType - state - stateMessage - statsData - tenantId 
         :type _select:
+
             :class:`str`
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.stats.TrafficMirrorStatsApiResponse`.
+        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.stats.GetTrafficMirrorStatsApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
             raise ValueError("Missing the required parameter `extId` when calling `get_traffic_mirror_stats`")  # noqa: E501
+        # verify the required parameter '_startTime' is set
+        if ('_startTime' not in params or params['_startTime'] is None):
+            raise ValueError("Missing the required parameter `_startTime` when calling `get_traffic_mirror_stats`")  # noqa: E501
+        # verify the required parameter '_endTime' is set
+        if ('_endTime' not in params or params['_endTime'] is None):
+            raise ValueError("Missing the required parameter `_endTime` when calling `get_traffic_mirror_stats`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
@@ -101,14 +113,16 @@
         if '_select' in params and params['_select'] is not None:
             query_params.append(('$select', params['_select']))  # noqa: E501
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -121,45 +135,48 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/stats/traffic-mirrors/{extId}', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.stats.TrafficMirrorStatsApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/stats/traffic-mirrors/{extId}', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.stats.TrafficMirrorStatsApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/stats/traffic-mirrors/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.stats.GetTrafficMirrorStatsApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/stats/traffic-mirrors/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.stats.GetTrafficMirrorStatsApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api/uplink_bond_api.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api/uplink_bonds_api.py`

 * *Files 3% similar despite different names*

```diff
@@ -3,87 +3,90 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 from __future__ import absolute_import
 
 import re  # noqa: F401
 
 # python 2 and python 3 compatibility library
 import six
 
 from ntnx_networking_py_client.api_client import ApiClient
 
 
-class UplinkBondApi(object):
+class UplinkBondsApi(object):
     """IGNORE:
     NOTE: A placeholder for class level description
     IGNORE
     """  # noqa: E501
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
 
         self.api_client = api_client
-        self.__headers_to_skip = { 'authorization', 'cookie', 'ntnx-request-id', 'host', 'user-agent' }
+        self.__headers_to_skip = { 'authorization', 'cookie', 'host', 'user-agent' }
 
-    def get_uplink_bond(self, extId, **kwargs):  # noqa: E501
+    def get_uplink_bond_by_id(self, extId, **kwargs):  # noqa: E501
         """Get uplink bond
 
-        >>> response = api.get_uplink_bond(extId)
+        >>> response = api.get_uplink_bond_by_id(extId)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.get_uplink_bond(extId, async_req=True)
+        >>> thread = api.get_uplink_bond_by_id(extId, async_req=True)
         >>> result = thread.get()
 
         :param extId: UUID of the bond
         :type extId:
+
             :class:`str`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.UplinkBondApiResponse`.
+        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.GetUplinkBondApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `get_uplink_bond`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `get_uplink_bond_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -96,86 +99,93 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/uplink-bonds/{extId}', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.UplinkBondApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/uplink-bonds/{extId}', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.UplinkBondApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/uplink-bonds/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.GetUplinkBondApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/uplink-bonds/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.GetUplinkBondApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
     def list_uplink_bonds(self, _page=None, _limit=None, _filter=None, _orderby=None, **kwargs):  # noqa: E501
         """List uplink bonds
 
         >>> response = api.list_uplink_bonds((optional) _page, (optional) _limit, (optional) _filter, (optional) _orderby)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
         >>> thread = api.list_uplink_bonds(async_req=True)
         >>> result = thread.get()
 
-        :param _page: A URL query parameter that specifies the page number of the result set.  Must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range will lead to no results being returned. 
+        :param _page: A URL query parameter that specifies the page number of the result set. It must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range might lead to no results. 
         :type _page:
+
             :class:`int`
-        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided a default value of 50 records will be returned in the result set. 
+        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided, a default value of 50 records will be returned in the result set. 
         :type _limit:
+
             :class:`int`
-        :param _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the OData V4.01 URL conventions. For example, filter '$filter=name eq 'karbon-ntnx-1.0' would filter result on cluster name karbon-ntnx1.0, filter '$filter=startswith(name, 'C')' would filter on cluster name starting with C. The filter can be applied on the following fields: - hostReference 
+        :param _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the [OData V4.01](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html) URL conventions. For example, filter '$filter=name eq 'karbon-ntnx-1.0' would filter the result on cluster name 'karbon-ntnx1.0', filter '$filter=startswith(name, 'C')' would filter on cluster name starting with 'C'. The filter can be applied to the following fields: - hostReference 
         :type _filter:
+
             :class:`str`
-        :param _orderby: A URL query parameter that allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified the resources will be sorted in ascending order by default. For example, '$orderby=templateName desc' would get all templates sorted by templateName in desc order. The orderby can be applied to the following fields: - name 
+        :param _orderby: A URL query parameter that allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified, the resources will be sorted in ascending order by default. For example, '$orderby=templateName desc' would get all templates sorted by templateName in descending order. The orderby can be applied to the following fields: - name 
         :type _orderby:
+
             :class:`str`
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.UplinkBondListApiResponse`.
+        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.ListUplinkBondsApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
 
         collection_formats = {}
@@ -192,14 +202,16 @@
         if '_orderby' in params and params['_orderby'] is not None:
             query_params.append(('$orderby', params['_orderby']))  # noqa: E501
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -212,45 +224,48 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/uplink-bonds', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.UplinkBondListApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/uplink-bonds', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.UplinkBondListApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/uplink-bonds', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.ListUplinkBondsApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/uplink-bonds', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.ListUplinkBondsApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api/virtual_switch_api.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api/virtual_switches_api.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,69 +3,71 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 from __future__ import absolute_import
 
 import re  # noqa: F401
 
 # python 2 and python 3 compatibility library
 import six
 
 from ntnx_networking_py_client.api_client import ApiClient
 
 
-class VirtualSwitchApi(object):
+class VirtualSwitchesApi(object):
     """IGNORE:
     NOTE: A placeholder for class level description
     IGNORE
     """  # noqa: E501
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
 
         self.api_client = api_client
-        self.__headers_to_skip = { 'authorization', 'cookie', 'ntnx-request-id', 'host', 'user-agent' }
+        self.__headers_to_skip = { 'authorization', 'cookie', 'host', 'user-agent' }
 
     def create_virtual_switch(self, body, X_Cluster_Id=None, **kwargs):  # noqa: E501
         """Create a Virtual Switch
 
         >>> response = api.create_virtual_switch(body, (optional) X_Cluster_Id)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
         >>> thread = api.create_virtual_switch(body, async_req=True)
         >>> result = thread.get()
 
         :param body: Schema to configure a virtual switch
         :type body:
+
             :class:`~ntnx_networking_py_client.models.networking.v4.config.VirtualSwitch`, required
-        :param X_Cluster_Id: Prism Element Cluster UUID
+        :param X_Cluster_Id: Prism Element cluster reference. This header can be optionally supplied for Virtual Switch list requests, but is deprecated for all other Virtual Switch fetch/create/update/delete requests. 
         :type X_Cluster_Id:
+
             :class:`str`
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
         :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.TaskReferenceApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'body' is set
         if ('body' not in params or params['body'] is None):
@@ -79,18 +81,22 @@
 
         header_params = {}
         if 'X_Cluster_Id' in params and params['X_Cluster_Id'] is not None:
             header_params['X-Cluster-Id'] = params['X_Cluster_Id']  # noqa: E501
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
             ['application/json'])  # noqa: E501
+        if 'Content-Type' in params and params.get('Content-Type') is not None:
+            header_params['Content-Type'] = params.get('Content-Type')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -103,90 +109,95 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
+        # Authentication setting
+        auth_settings = ['basicAuthScheme']  # noqa: E501
+
         body_params = None
         if 'body' in params and params['body'] is not None:
             body_params = params['body']
 
-        # Authentication setting
-        auth_settings = ['basicAuthScheme']  # noqa: E501
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/virtual-switches', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/virtual-switches', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/virtual-switches', 'POST',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/virtual-switches', 'POST',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
-
-    def delete_virtual_switch(self, extId, X_Cluster_Id=None, **kwargs):  # noqa: E501
+    def delete_virtual_switch_by_id(self, extId, X_Cluster_Id=None, **kwargs):  # noqa: E501
         """Delete a Virtual Switch
 
-        >>> response = api.delete_virtual_switch(extId, (optional) X_Cluster_Id)
+        >>> response = api.delete_virtual_switch_by_id(extId, (optional) X_Cluster_Id)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.delete_virtual_switch(extId, async_req=True)
+        >>> thread = api.delete_virtual_switch_by_id(extId, async_req=True)
         >>> result = thread.get()
 
         :param extId: UUID of Virtual Switch
         :type extId:
+
             :class:`str`, required
-        :param X_Cluster_Id: Prism Element Cluster UUID
+        :param X_Cluster_Id: Prism Element cluster reference. This header can be optionally supplied for Virtual Switch list requests, but is deprecated for all other Virtual Switch fetch/create/update/delete requests. 
         :type X_Cluster_Id:
+
             :class:`str`
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
         :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.TaskReferenceApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `delete_virtual_switch`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `delete_virtual_switch_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
@@ -194,14 +205,16 @@
 
         header_params = {}
         if 'X_Cluster_Id' in params and params['X_Cluster_Id'] is not None:
             header_params['X-Cluster-Id'] = params['X_Cluster_Id']  # noqa: E501
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -214,88 +227,93 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/virtual-switches/{extId}', 'DELETE',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/virtual-switches/{extId}', 'DELETE',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/virtual-switches/{extId}', 'DELETE',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/virtual-switches/{extId}', 'DELETE',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def get_virtual_switch(self, extId, X_Cluster_Id=None, **kwargs):  # noqa: E501
+    def get_virtual_switch_by_id(self, extId, X_Cluster_Id=None, **kwargs):  # noqa: E501
         """Get single Virtual Switch given its UUID
 
-        >>> response = api.get_virtual_switch(extId, (optional) X_Cluster_Id)
+        >>> response = api.get_virtual_switch_by_id(extId, (optional) X_Cluster_Id)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.get_virtual_switch(extId, async_req=True)
+        >>> thread = api.get_virtual_switch_by_id(extId, async_req=True)
         >>> result = thread.get()
 
         :param extId: UUID of Virtual Switch
         :type extId:
+
             :class:`str`, required
-        :param X_Cluster_Id: Prism Element Cluster UUID
+        :param X_Cluster_Id: Prism Element cluster reference. This header can be optionally supplied for Virtual Switch list requests, but is deprecated for all other Virtual Switch fetch/create/update/delete requests. 
         :type X_Cluster_Id:
+
             :class:`str`
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.VirtualSwitchApiResponse`.
+        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.GetVirtualSwitchApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `get_virtual_switch`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `get_virtual_switch_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
@@ -303,14 +321,16 @@
 
         header_params = {}
         if 'X_Cluster_Id' in params and params['X_Cluster_Id'] is not None:
             header_params['X-Cluster-Id'] = params['X_Cluster_Id']  # noqa: E501
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -323,77 +343,81 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/virtual-switches/{extId}', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.VirtualSwitchApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/virtual-switches/{extId}', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.VirtualSwitchApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/virtual-switches/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.GetVirtualSwitchApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/virtual-switches/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.GetVirtualSwitchApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
     def list_virtual_switches(self, X_Cluster_Id=None, **kwargs):  # noqa: E501
         """Get list of Virtual Switches
 
         >>> response = api.list_virtual_switches((optional) X_Cluster_Id)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
         >>> thread = api.list_virtual_switches(async_req=True)
         >>> result = thread.get()
 
-        :param X_Cluster_Id: Prism Element Cluster UUID
+        :param X_Cluster_Id: Prism Element cluster reference. This header can be optionally supplied for Virtual Switch list requests, but is deprecated for all other Virtual Switch fetch/create/update/delete requests. 
         :type X_Cluster_Id:
+
             :class:`str`
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.VirtualSwitchListApiResponse`.
+        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.ListVirtualSwitchesApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
 
         collection_formats = {}
@@ -404,14 +428,16 @@
 
         header_params = {}
         if 'X_Cluster_Id' in params and params['X_Cluster_Id'] is not None:
             header_params['X-Cluster-Id'] = params['X_Cluster_Id']  # noqa: E501
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -424,94 +450,100 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/virtual-switches', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.VirtualSwitchListApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/virtual-switches', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.VirtualSwitchListApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/virtual-switches', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.ListVirtualSwitchesApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/virtual-switches', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.ListVirtualSwitchesApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def update_virtual_switch(self, extId, body, X_Cluster_Id=None, **kwargs):  # noqa: E501
+    def update_virtual_switch_by_id(self, extId, body, X_Cluster_Id=None, **kwargs):  # noqa: E501
         """Update a Virtual Switch
 
-        >>> response = api.update_virtual_switch(extId, body, (optional) X_Cluster_Id)
+        >>> response = api.update_virtual_switch_by_id(extId, body, (optional) X_Cluster_Id)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.update_virtual_switch(extId, body, async_req=True)
+        >>> thread = api.update_virtual_switch_by_id(extId, body, async_req=True)
         >>> result = thread.get()
 
         :param extId: UUID of Virtual Switch
         :type extId:
+
             :class:`str`, required
         :param body: Schema to configure a virtual switch
         :type body:
+
             :class:`~ntnx_networking_py_client.models.networking.v4.config.VirtualSwitch`, required
-        :param X_Cluster_Id: Prism Element Cluster UUID
+        :param X_Cluster_Id: Prism Element cluster reference. This header can be optionally supplied for Virtual Switch list requests, but is deprecated for all other Virtual Switch fetch/create/update/delete requests. 
         :type X_Cluster_Id:
+
             :class:`str`
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
         :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.TaskReferenceApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `update_virtual_switch`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `update_virtual_switch_by_id`")  # noqa: E501
         # verify the required parameter 'body' is set
         if ('body' not in params or params['body'] is None):
-            raise ValueError("Missing the required parameter `body` when calling `update_virtual_switch`")  # noqa: E501
+            raise ValueError("Missing the required parameter `body` when calling `update_virtual_switch_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
@@ -519,18 +551,22 @@
 
         header_params = {}
         if 'X_Cluster_Id' in params and params['X_Cluster_Id'] is not None:
             header_params['X-Cluster-Id'] = params['X_Cluster_Id']  # noqa: E501
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
             ['application/json'])  # noqa: E501
+        if 'Content-Type' in params and params.get('Content-Type') is not None:
+            header_params['Content-Type'] = params.get('Content-Type')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -543,47 +579,50 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
+        # Authentication setting
+        auth_settings = ['basicAuthScheme']  # noqa: E501
+
         body_params = None
         if 'body' in params and params['body'] is not None:
             body_params = params['body']
 
-        # Authentication setting
-        auth_settings = ['basicAuthScheme']  # noqa: E501
-
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/virtual-switches/{extId}', 'PUT',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/virtual-switches/{extId}', 'PUT',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/virtual-switches/{extId}', 'PUT',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/virtual-switches/{extId}', 'PUT',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api/virtual_switch_node_info_api.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api/routing_policy_stats_api.py`

 * *Files 21% similar despite different names*

```diff
@@ -3,135 +3,150 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 from __future__ import absolute_import
 
 import re  # noqa: F401
 
 # python 2 and python 3 compatibility library
 import six
 
 from ntnx_networking_py_client.api_client import ApiClient
 
 
-class VirtualSwitchNodeInfoApi(object):
+class RoutingPolicyStatsApi(object):
     """IGNORE:
     NOTE: A placeholder for class level description
     IGNORE
     """  # noqa: E501
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
 
         self.api_client = api_client
-        self.__headers_to_skip = { 'authorization', 'cookie', 'ntnx-request-id', 'host', 'user-agent' }
+        self.__headers_to_skip = { 'authorization', 'cookie', 'host', 'user-agent' }
 
-    def get_node_schedulable_status(self, X_Cluster_Id=None, **kwargs):  # noqa: E501
-        """Check whether a node in a cluster is a storage-only node or not
+    def clear_routing_policy_counters(self, body, **kwargs):  # noqa: E501
+        """Clear the value in packet and byte counters of all Routing Policies in the chosen VPC or particular routing policy.
 
-        >>> response = api.get_node_schedulable_status((optional) X_Cluster_Id)
+        >>> response = api.clear_routing_policy_counters(body)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.get_node_schedulable_status(async_req=True)
+        >>> thread = api.clear_routing_policy_counters(body, async_req=True)
         >>> result = thread.get()
 
-        :param X_Cluster_Id: Prism Element Cluster UUID
-        :type X_Cluster_Id:
-            :class:`str`
+        :param body: VPC UUID to reset all routing policy counters to zero.
+        :type body:
+
+            :class:`~ntnx_networking_py_client.models.networking.v4.stats.RoutingPolicyClearCountersSpec`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.NodeSchedulableStatusApiResponse`.
+        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.stats.TaskReferenceApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
+        # verify the required parameter 'body' is set
+        if ('body' not in params or params['body'] is None):
+            raise ValueError("Missing the required parameter `body` when calling `clear_routing_policy_counters`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'X_Cluster_Id' in params and params['X_Cluster_Id'] is not None:
-            header_params['X-Cluster-Id'] = params['X_Cluster_Id']  # noqa: E501
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
+
+        # HTTP header `Content-Type`
+        header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
+            ['application/json'])  # noqa: E501
+        if 'Content-Type' in params and params.get('Content-Type') is not None:
+            header_params['Content-Type'] = params.get('Content-Type')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
-        all_params = set(['X_Cluster_Id'])
+        all_params = set(['body'])
         all_params.update(extra_params)
         for key, val in six.iteritems(params):
             if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                 if key.lower() == 'if_match'.lower():
                     key = 'If-Match'
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/node-schedulable-status', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.NodeSchedulableStatusApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/node-schedulable-status', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.NodeSchedulableStatusApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+        if 'body' in params and params['body'] is not None:
+            body_params = params['body']
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/stats/routing-policies/$actions/clear', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.stats.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/stats/routing-policies/$actions/clear', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.stats.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api/vpc_api.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api/floating_ips_api.py`

 * *Files 12% similar despite different names*

```diff
@@ -3,89 +3,94 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 from __future__ import absolute_import
 
 import re  # noqa: F401
 
 # python 2 and python 3 compatibility library
 import six
 
 from ntnx_networking_py_client.api_client import ApiClient
 
 
-class VpcApi(object):
+class FloatingIpsApi(object):
     """IGNORE:
     NOTE: A placeholder for class level description
     IGNORE
     """  # noqa: E501
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
 
         self.api_client = api_client
-        self.__headers_to_skip = { 'authorization', 'cookie', 'ntnx-request-id', 'host', 'user-agent' }
+        self.__headers_to_skip = { 'authorization', 'cookie', 'host', 'user-agent' }
 
-    def create_vpc(self, body, **kwargs):  # noqa: E501
-        """Create a VPC.
+    def create_floating_ip(self, body, **kwargs):  # noqa: E501
+        """Create a floating IP.
 
-        >>> response = api.create_vpc(body)
+        >>> response = api.create_floating_ip(body)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.create_vpc(body, async_req=True)
+        >>> thread = api.create_floating_ip(body, async_req=True)
         >>> result = thread.get()
 
-        :param body: Request schema to create the VPC.
+        :param body: Task Id corresponding to the Create Floating IP operation.
         :type body:
-            :class:`~ntnx_networking_py_client.models.networking.v4.config.Vpc`, required
+
+            :class:`~ntnx_networking_py_client.models.networking.v4.config.FloatingIp`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
         :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.TaskReferenceApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'body' is set
         if ('body' not in params or params['body'] is None):
-            raise ValueError("Missing the required parameter `body` when calling `create_vpc`")  # noqa: E501
+            raise ValueError("Missing the required parameter `body` when calling `create_floating_ip`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
             ['application/json'])  # noqa: E501
+        if 'Content-Type' in params and params.get('Content-Type') is not None:
+            header_params['Content-Type'] = params.get('Content-Type')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -98,100 +103,106 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
+        # Authentication setting
+        auth_settings = ['basicAuthScheme']  # noqa: E501
+
         body_params = None
         if 'body' in params and params['body'] is not None:
             body_params = params['body']
 
-        # Authentication setting
-        auth_settings = ['basicAuthScheme']  # noqa: E501
-
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/vpcs', 'POST',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/vpcs', 'POST',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/floating-ips', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/floating-ips', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def delete_vpc(self, extId, **kwargs):  # noqa: E501
-        """Delete the specified VPC.
+    def delete_floating_ip_by_id(self, extId, **kwargs):  # noqa: E501
+        """Delete the floating IP corresponding to the extId.
 
-        >>> response = api.delete_vpc(extId)
+        >>> response = api.delete_floating_ip_by_id(extId)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.delete_vpc(extId, async_req=True)
+        >>> thread = api.delete_floating_ip_by_id(extId, async_req=True)
         >>> result = thread.get()
 
-        :param extId: The UUID of the VPC.
+        :param extId: ExtId of the floating IP.
         :type extId:
+
             :class:`str`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
         :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.TaskReferenceApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `delete_vpc`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `delete_floating_ip_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -204,98 +215,104 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/vpcs/{extId}', 'DELETE',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/vpcs/{extId}', 'DELETE',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/floating-ips/{extId}', 'DELETE',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/floating-ips/{extId}', 'DELETE',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def get_vpc(self, extId, **kwargs):  # noqa: E501
-        """Get the VPC with the specified UUID.
+    def get_floating_ip_by_id(self, extId, **kwargs):  # noqa: E501
+        """Get the floating IP for this extId.
 
-        >>> response = api.get_vpc(extId)
+        >>> response = api.get_floating_ip_by_id(extId)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.get_vpc(extId, async_req=True)
+        >>> thread = api.get_floating_ip_by_id(extId, async_req=True)
         >>> result = thread.get()
 
-        :param extId: The UUID of the VPC.
+        :param extId: ExtId of the floating IP.
         :type extId:
+
             :class:`str`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.VpcApiResponse`.
+        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.GetFloatingIpApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `get_vpc`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `get_floating_ip_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -308,89 +325,97 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/vpcs/{extId}', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.VpcApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/vpcs/{extId}', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.VpcApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/floating-ips/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.GetFloatingIpApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/floating-ips/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.GetFloatingIpApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def list_vpcs(self, _page=None, _limit=None, _filter=None, _orderby=None, _select=None, **kwargs):  # noqa: E501
-        """Get the list of existing VPCs.
+    def list_floating_ips(self, _page=None, _limit=None, _filter=None, _orderby=None, _expand=None, **kwargs):  # noqa: E501
+        """Get a list of floating IPs.
 
-        >>> response = api.list_vpcs((optional) _page, (optional) _limit, (optional) _filter, (optional) _orderby, (optional) _select)
+        >>> response = api.list_floating_ips((optional) _page, (optional) _limit, (optional) _filter, (optional) _orderby, (optional) _expand)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.list_vpcs(async_req=True)
+        >>> thread = api.list_floating_ips(async_req=True)
         >>> result = thread.get()
 
-        :param _page: A URL query parameter that specifies the page number of the result set.  Must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range will lead to no results being returned. 
+        :param _page: A URL query parameter that specifies the page number of the result set. It must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range might lead to no results. 
         :type _page:
+
             :class:`int`
-        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided a default value of 50 records will be returned in the result set. 
+        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided, a default value of 50 records will be returned in the result set. 
         :type _limit:
+
             :class:`int`
-        :param _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the OData V4.01 URL conventions. For example, filter '$filter=name eq 'karbon-ntnx-1.0' would filter result on cluster name karbon-ntnx1.0, filter '$filter=startswith(name, 'C')' would filter on cluster name starting with C. The filter can be applied on the following fields: - name 
+        :param _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the [OData V4.01](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html) URL conventions. For example, filter '$filter=name eq 'karbon-ntnx-1.0' would filter the result on cluster name 'karbon-ntnx1.0', filter '$filter=startswith(name, 'C')' would filter on cluster name starting with 'C'. The filter can be applied to the following fields: - externalSubnetReference - floatingIp/ipv4/value - floatingIp/ipv6/value - name 
         :type _filter:
+
             :class:`str`
-        :param _orderby: A URL query parameter that allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified the resources will be sorted in ascending order by default. For example, '$orderby=templateName desc' would get all templates sorted by templateName in desc order. The orderby can be applied to the following fields: - name 
+        :param _orderby: A URL query parameter that allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified, the resources will be sorted in ascending order by default. For example, '$orderby=templateName desc' would get all templates sorted by templateName in descending order. The orderby can be applied to the following fields: - floatingIp/ipv4/value - floatingIp/ipv6/value - name 
         :type _orderby:
+
             :class:`str`
-        :param _select: A URL query parameter that allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the OData V4.01 URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e. *), then all properties on the matching resource will be returned. - commonDhcpOptions - description - extId - externalRoutingDomainReference - externalSubnets - externallyRoutablePrefixes - links - metadata - name - snatIps - tenantId 
-        :type _select:
+        :param _expand: A URL query parameter that allows clients to request related resources when a resource that satisfies a particular request is retrieved. Each expanded item is evaluated relative to the entity containing the property being expanded. Other query options can be applied to an expanded property by appending a semicolon-separated list of query options, enclosed in parentheses, to the property name. Permissible system query options are $filter, $select and $orderby. The following expansion keys are supported. - externalSubnet - vmNic - vpc 
+        :type _expand:
+
             :class:`str`
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.VpcListApiResponse`.
+        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.ListFloatingIpsApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
 
         collection_formats = {}
@@ -402,135 +427,146 @@
             query_params.append(('$page', params['_page']))  # noqa: E501
         if '_limit' in params and params['_limit'] is not None:
             query_params.append(('$limit', params['_limit']))  # noqa: E501
         if '_filter' in params and params['_filter'] is not None:
             query_params.append(('$filter', params['_filter']))  # noqa: E501
         if '_orderby' in params and params['_orderby'] is not None:
             query_params.append(('$orderby', params['_orderby']))  # noqa: E501
-        if '_select' in params and params['_select'] is not None:
-            query_params.append(('$select', params['_select']))  # noqa: E501
+        if '_expand' in params and params['_expand'] is not None:
+            query_params.append(('$expand', params['_expand']))  # noqa: E501
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
-        all_params = set(['_page', '_limit', '_filter', '_orderby', '_select'])
+        all_params = set(['_page', '_limit', '_filter', '_orderby', '_expand'])
         all_params.update(extra_params)
         for key, val in six.iteritems(params):
             if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                 if key.lower() == 'if_match'.lower():
                     key = 'If-Match'
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/vpcs', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.VpcListApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/vpcs', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.VpcListApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/floating-ips', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.ListFloatingIpsApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/floating-ips', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.ListFloatingIpsApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def update_vpc(self, extId, body, **kwargs):  # noqa: E501
-        """Update the specified VPC.
+    def update_floating_ip_by_id(self, extId, body, **kwargs):  # noqa: E501
+        """Update the floating IP for this extId.
 
-        >>> response = api.update_vpc(extId, body)
+        >>> response = api.update_floating_ip_by_id(extId, body)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.update_vpc(extId, body, async_req=True)
+        >>> thread = api.update_floating_ip_by_id(extId, body, async_req=True)
         >>> result = thread.get()
 
-        :param extId: The UUID of the VPC.
+        :param extId: ExtId of the floating IP.
         :type extId:
+
             :class:`str`, required
-        :param body: Request schema to update the specified VPC.
+        :param body: Configure a floating IP.
         :type body:
-            :class:`~ntnx_networking_py_client.models.networking.v4.config.Vpc`, required
+
+            :class:`~ntnx_networking_py_client.models.networking.v4.config.FloatingIp`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
         :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.TaskReferenceApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `update_vpc`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `update_floating_ip_by_id`")  # noqa: E501
         # verify the required parameter 'body' is set
         if ('body' not in params or params['body'] is None):
-            raise ValueError("Missing the required parameter `body` when calling `update_vpc`")  # noqa: E501
+            raise ValueError("Missing the required parameter `body` when calling `update_floating_ip_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
             ['application/json'])  # noqa: E501
+        if 'Content-Type' in params and params.get('Content-Type') is not None:
+            header_params['Content-Type'] = params.get('Content-Type')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -543,47 +579,50 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
+        # Authentication setting
+        auth_settings = ['basicAuthScheme']  # noqa: E501
+
         body_params = None
         if 'body' in params and params['body'] is not None:
             body_params = params['body']
 
-        # Authentication setting
-        auth_settings = ['basicAuthScheme']  # noqa: E501
-
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/vpcs/{extId}', 'PUT',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/vpcs/{extId}', 'PUT',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/floating-ips/{extId}', 'PUT',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/floating-ips/{extId}', 'PUT',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api/vpc_ns_stats_api.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api/vpc_ns_stats_api.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,15 +3,15 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 from __future__ import absolute_import
 
 import re  # noqa: F401
@@ -29,75 +29,90 @@
     """  # noqa: E501
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
 
         self.api_client = api_client
-        self.__headers_to_skip = { 'authorization', 'cookie', 'ntnx-request-id', 'host', 'user-agent' }
+        self.__headers_to_skip = { 'authorization', 'cookie', 'host', 'user-agent' }
 
-    def get_vpc_ns_stats(self, vpcExtId, extId, _startTime=None, _endTime=None, _samplingInterval=None, _statType=None, _page=None, _limit=None, _select=None, **kwargs):  # noqa: E501
+    def get_vpc_ns_stats(self, vpcExtId, extId, _startTime, _endTime, _samplingInterval=None, _statType=None, _page=None, _limit=None, _select=None, **kwargs):  # noqa: E501
         """Get VPC North-South statistics.
 
-        >>> response = api.get_vpc_ns_stats(vpcExtId, extId, (optional) _startTime, (optional) _endTime, (optional) _samplingInterval, (optional) _statType, (optional) _page, (optional) _limit, (optional) _select)
+        >>> response = api.get_vpc_ns_stats(vpcExtId, extId, _startTime, _endTime, (optional) _samplingInterval, (optional) _statType, (optional) _page, (optional) _limit, (optional) _select)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.get_vpc_ns_stats(vpcExtId, extId, async_req=True)
+        >>> thread = api.get_vpc_ns_stats(vpcExtId, extId, _startTime, _endTime, async_req=True)
         >>> result = thread.get()
 
         :param vpcExtId: The UUID of the VPC.
         :type vpcExtId:
+
             :class:`str`, required
         :param extId: Subnet ExtID
         :type extId:
+
             :class:`str`, required
         :param _startTime: The start time of the period for which stats should be reported. The value should be in extended ISO-8601 format. For example, start time of 2022-04-23T01:23:45.678+09:00 would consider all stats starting at 1:23:45.678 on the 23rd of April 2022. Details around ISO-8601 format can be found at https://www.iso.org/standard/70907.html 
         :type _startTime:
-            :class:`str`
+
+            :class:`str`, required
         :param _endTime: The end time of the period for which stats should be reported. The value should be in extended ISO-8601 format. For example, end time of 2022-04-23T013:23:45.678+09:00 would consider all stats till 13:23:45 .678 on the 23rd of April 2022. Details around ISO-8601 format can be found at https://www.iso.org/standard/70907.html 
         :type _endTime:
-            :class:`str`
-        :param _samplingInterval: The sampling interval in seconds at which statistical data should be collected For example, do you want performance statistics every 30 seconds? Every 60 seconds? 
+
+            :class:`str`, required
+        :param _samplingInterval: The sampling interval in seconds at which statistical data should be collected. For example, if you want performance statistics every 30 seconds, then provide the value as 30. 
         :type _samplingInterval:
+
             :class:`int`
         :param _statType: 
         :type _statType:
+
             :class:`common.v1.stats.DownSamplingOperator`
-        :param _page: A URL query parameter that specifies the page number of the result set.  Must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range will lead to no results being returned. 
+        :param _page: A URL query parameter that specifies the page number of the result set. It must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range might lead to no results. 
         :type _page:
+
             :class:`int`
-        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided a default value of 50 records will be returned in the result set. 
+        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided, a default value of 50 records will be returned in the result set. 
         :type _limit:
+
             :class:`int`
-        :param _select: A URL query parameter that allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the OData V4.01 URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e. *), then all properties on the matching resource will be returned. - entityUuid - extId - links - northSouthEgressBytesAbs - northSouthEgressBytesPerSec - northSouthEgressPacketsAbs - northSouthEgressPacketsPerSec - northSouthIngressBytesAbs - northSouthIngressBytesPerSec - northSouthIngressPacketsAbs - northSouthIngressPacketsPerSec - statType - tenantId 
+        :param _select: A URL query parameter that allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the [OData V4.01](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html) URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e., *), then all properties on the matching resource will be returned. - entityUuid - extId - links - northSouthEgressBytesAbs - northSouthEgressBytesPerSec - northSouthEgressPacketsAbs - northSouthEgressPacketsPerSec - northSouthIngressBytesAbs - northSouthIngressBytesPerSec - northSouthIngressPacketsAbs - northSouthIngressPacketsPerSec - statType - tenantId 
         :type _select:
+
             :class:`str`
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.stats.VpcNsStatsApiResponse`.
+        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.stats.GetVpcNsStatsApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'vpcExtId' is set
         if ('vpcExtId' not in params or params['vpcExtId'] is None):
             raise ValueError("Missing the required parameter `vpcExtId` when calling `get_vpc_ns_stats`")  # noqa: E501
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
             raise ValueError("Missing the required parameter `extId` when calling `get_vpc_ns_stats`")  # noqa: E501
+        # verify the required parameter '_startTime' is set
+        if ('_startTime' not in params or params['_startTime'] is None):
+            raise ValueError("Missing the required parameter `_startTime` when calling `get_vpc_ns_stats`")  # noqa: E501
+        # verify the required parameter '_endTime' is set
+        if ('_endTime' not in params or params['_endTime'] is None):
+            raise ValueError("Missing the required parameter `_endTime` when calling `get_vpc_ns_stats`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'vpcExtId' in params and params['vpcExtId'] is not None:
             path_params['vpcExtId'] = params['vpcExtId']  # noqa: E501
         if 'extId' in params and params['extId'] is not None:
@@ -119,14 +134,16 @@
         if '_select' in params and params['_select'] is not None:
             query_params.append(('$select', params['_select']))  # noqa: E501
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -139,45 +156,48 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/stats/vpc/{vpcExtId}/external-subnets/{extId}', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.stats.VpcNsStatsApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/stats/vpc/{vpcExtId}/external-subnets/{extId}', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.stats.VpcNsStatsApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/stats/vpc/{vpcExtId}/external-subnets/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.stats.GetVpcNsStatsApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/stats/vpc/{vpcExtId}/external-subnets/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.stats.GetVpcNsStatsApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api/vpc_virtual_switch_mappings_api.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api/vpc_virtual_switch_mappings_api.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,15 +3,15 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 from __future__ import absolute_import
 
 import re  # noqa: F401
@@ -29,227 +29,242 @@
     """  # noqa: E501
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
 
         self.api_client = api_client
-        self.__headers_to_skip = { 'authorization', 'cookie', 'ntnx-request-id', 'host', 'user-agent' }
+        self.__headers_to_skip = { 'authorization', 'cookie', 'host', 'user-agent' }
 
-    def get_vpc_virtual_switch_mappings(self, _page=None, _limit=None, _filter=None, **kwargs):  # noqa: E501
-        """Get the VPC for virtual switch mappings config.
+    def create_vpc_virtual_switch_mapping(self, body, **kwargs):  # noqa: E501
+        """Set VPC for virtual switch mappings traffic config.
 
-        >>> response = api.get_vpc_virtual_switch_mappings((optional) _page, (optional) _limit, (optional) _filter)
+        >>> response = api.create_vpc_virtual_switch_mapping(body)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.get_vpc_virtual_switch_mappings(async_req=True)
+        >>> thread = api.create_vpc_virtual_switch_mapping(body, async_req=True)
         >>> result = thread.get()
 
-        :param _page: A URL query parameter that specifies the page number of the result set.  Must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range will lead to no results being returned. 
-        :type _page:
-            :class:`int`
-        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided a default value of 50 records will be returned in the result set. 
-        :type _limit:
-            :class:`int`
-        :param _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the OData V4.01 URL conventions. For example, filter '$filter=name eq 'karbon-ntnx-1.0' would filter result on cluster name karbon-ntnx1.0, filter '$filter=startswith(name, 'C')' would filter on cluster name starting with C. The filter can be applied on the following fields: - clusterUuid 
-        :type _filter:
-            :class:`str`
-        :param kwargs: kwargs for the method.
+        :param body: Request body for setting VPC for virtual switch mappings traffic config.
+        :type body:
+
+                :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.VpcVirtualSwitchMappingsApiResponse`.
+        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.TaskReferenceApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
+        # verify the required parameter 'body' is set
+        if ('body' not in params or params['body'] is None):
+            raise ValueError("Missing the required parameter `body` when calling `create_vpc_virtual_switch_mapping`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
-        if '_page' in params and params['_page'] is not None:
-            query_params.append(('$page', params['_page']))  # noqa: E501
-        if '_limit' in params and params['_limit'] is not None:
-            query_params.append(('$limit', params['_limit']))  # noqa: E501
-        if '_filter' in params and params['_filter'] is not None:
-            query_params.append(('$filter', params['_filter']))  # noqa: E501
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
+
+        # HTTP header `Content-Type`
+        header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
+            ['application/json'])  # noqa: E501
+        if 'Content-Type' in params and params.get('Content-Type') is not None:
+            header_params['Content-Type'] = params.get('Content-Type')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
-        all_params = set(['_page', '_limit', '_filter'])
+        all_params = set(['body'])
         all_params.update(extra_params)
         for key, val in six.iteritems(params):
             if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                 if key.lower() == 'if_match'.lower():
                     key = 'If-Match'
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/vpc-virtual-switch-mappings', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.VpcVirtualSwitchMappingsApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/vpc-virtual-switch-mappings', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.VpcVirtualSwitchMappingsApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+        if 'body' in params and params['body'] is not None:
+            body_params = params['body']
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/vpc-virtual-switch-mappings', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/vpc-virtual-switch-mappings', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def set_vpc_virtual_switch_mappings(self, body, **kwargs):  # noqa: E501
-        """Set VPC for virtual switch mappings traffic config. Requires Prism Central >= pc.2023.1.
+    def list_vpc_virtual_switch_mappings(self, _page=None, _limit=None, _filter=None, **kwargs):  # noqa: E501
+        """Get the VPC for virtual switch mappings config.
 
-        >>> response = api.set_vpc_virtual_switch_mappings(body)
+        >>> response = api.list_vpc_virtual_switch_mappings((optional) _page, (optional) _limit, (optional) _filter)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.set_vpc_virtual_switch_mappings(body, async_req=True)
+        >>> thread = api.list_vpc_virtual_switch_mappings(async_req=True)
         >>> result = thread.get()
 
-        :param body: Request body for setting VPC for virtual switch mappings traffic config.
-        :type body:
-            list[:class:`~ntnx_networking_py_client.models.networking.v4.config.VpcVirtualSwitchMapping`], required
+        :param _page: A URL query parameter that specifies the page number of the result set. It must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range might lead to no results. 
+        :type _page:
+
+            :class:`int`
+        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided, a default value of 50 records will be returned in the result set. 
+        :type _limit:
+
+            :class:`int`
+        :param _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the [OData V4.01](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html) URL conventions. For example, filter '$filter=name eq 'karbon-ntnx-1.0' would filter the result on cluster name 'karbon-ntnx1.0', filter '$filter=startswith(name, 'C')' would filter on cluster name starting with 'C'. The filter can be applied to the following fields: - clusterUuid 
+        :type _filter:
+
+            :class:`str`
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.TaskReferenceApiResponse`.
+        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.ListVpcVirtualSwitchMappingsApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
-        # verify the required parameter 'body' is set
-        if ('body' not in params or params['body'] is None):
-            raise ValueError("Missing the required parameter `body` when calling `set_vpc_virtual_switch_mappings`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
+        if '_page' in params and params['_page'] is not None:
+            query_params.append(('$page', params['_page']))  # noqa: E501
+        if '_limit' in params and params['_limit'] is not None:
+            query_params.append(('$limit', params['_limit']))  # noqa: E501
+        if '_filter' in params and params['_filter'] is not None:
+            query_params.append(('$filter', params['_filter']))  # noqa: E501
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
-
-        # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
-        all_params = set(['body'])
+        all_params = set(['_page', '_limit', '_filter'])
         all_params.update(extra_params)
         for key, val in six.iteritems(params):
             if val is not None and key.lower() not in self.__headers_to_skip and key not in all_params:
                 if key.lower() == 'if_match'.lower():
                     key = 'If-Match'
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params and params['body'] is not None:
-            body_params = params['body']
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/vpc-virtual-switch-mappings', 'POST',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/vpc-virtual-switch-mappings', 'POST',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/vpc-virtual-switch-mappings', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.ListVpcVirtualSwitchMappingsApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/vpc-virtual-switch-mappings', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.ListVpcVirtualSwitchMappingsApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api/vpn_connection_api.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api/vpn_connections_api.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,66 +3,67 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 from __future__ import absolute_import
 
 import re  # noqa: F401
 
 # python 2 and python 3 compatibility library
 import six
 
 from ntnx_networking_py_client.api_client import ApiClient
 
 
-class VpnConnectionApi(object):
+class VpnConnectionsApi(object):
     """IGNORE:
     NOTE: A placeholder for class level description
     IGNORE
     """  # noqa: E501
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
 
         self.api_client = api_client
-        self.__headers_to_skip = { 'authorization', 'cookie', 'ntnx-request-id', 'host', 'user-agent' }
+        self.__headers_to_skip = { 'authorization', 'cookie', 'host', 'user-agent' }
 
     def create_vpn_connection(self, body, **kwargs):  # noqa: E501
         """Create a VPN connection
 
         >>> response = api.create_vpn_connection(body)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
         >>> thread = api.create_vpn_connection(body, async_req=True)
         >>> result = thread.get()
 
         :param body: Create VPN connection request body
         :type body:
+
             :class:`~ntnx_networking_py_client.models.networking.v4.config.VpnConnection`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
         :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.TaskReferenceApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'body' is set
         if ('body' not in params or params['body'] is None):
@@ -74,18 +75,22 @@
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
             ['application/json'])  # noqa: E501
+        if 'Content-Type' in params and params.get('Content-Type') is not None:
+            header_params['Content-Type'] = params.get('Content-Type')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -98,100 +103,106 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
+        # Authentication setting
+        auth_settings = ['basicAuthScheme']  # noqa: E501
+
         body_params = None
         if 'body' in params and params['body'] is not None:
             body_params = params['body']
 
-        # Authentication setting
-        auth_settings = ['basicAuthScheme']  # noqa: E501
-
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/vpn-connections', 'POST',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/vpn-connections', 'POST',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/vpn-connections', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/vpn-connections', 'POST',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def delete_vpn_connection(self, extId, **kwargs):  # noqa: E501
+    def delete_vpn_connection_by_id(self, extId, **kwargs):  # noqa: E501
         """Delete VPN connection
 
-        >>> response = api.delete_vpn_connection(extId)
+        >>> response = api.delete_vpn_connection_by_id(extId)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.delete_vpn_connection(extId, async_req=True)
+        >>> thread = api.delete_vpn_connection_by_id(extId, async_req=True)
         >>> result = thread.get()
 
         :param extId: VPN connection UUID
         :type extId:
+
             :class:`str`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
         :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.TaskReferenceApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `delete_vpn_connection`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `delete_vpn_connection_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -204,91 +215,96 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/vpn-connections/{extId}', 'DELETE',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/vpn-connections/{extId}', 'DELETE',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/vpn-connections/{extId}', 'DELETE',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/vpn-connections/{extId}', 'DELETE',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def get_vpn_appliance_config(self, vpnConnectionExtId, extId, **kwargs):  # noqa: E501
+    def get_vpn_appliance_for_vpn_connection_by_id(self, vpnConnectionExtId, extId, **kwargs):  # noqa: E501
         """Get third-party VPN appliance configuration.
 
-        >>> response = api.get_vpn_appliance_config(vpnConnectionExtId, extId)
+        >>> response = api.get_vpn_appliance_for_vpn_connection_by_id(vpnConnectionExtId, extId)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.get_vpn_appliance_config(vpnConnectionExtId, extId, async_req=True)
+        >>> thread = api.get_vpn_appliance_for_vpn_connection_by_id(vpnConnectionExtId, extId, async_req=True)
         >>> result = thread.get()
 
         :param vpnConnectionExtId: VPN connection UUID.
         :type vpnConnectionExtId:
+
             :class:`str`, required
         :param extId: Third-party VPN appliance UUID
         :type extId:
+
             :class:`str`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
         :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'vpnConnectionExtId' is set
         if ('vpnConnectionExtId' not in params or params['vpnConnectionExtId'] is None):
-            raise ValueError("Missing the required parameter `vpnConnectionExtId` when calling `get_vpn_appliance_config`")  # noqa: E501
+            raise ValueError("Missing the required parameter `vpnConnectionExtId` when calling `get_vpn_appliance_for_vpn_connection_by_id`")  # noqa: E501
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `get_vpn_appliance_config`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `get_vpn_appliance_for_vpn_connection_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'vpnConnectionExtId' in params and params['vpnConnectionExtId'] is not None:
             path_params['vpnConnectionExtId'] = params['vpnConnectionExtId']  # noqa: E501
         if 'extId' in params and params['extId'] is not None:
@@ -296,14 +312,16 @@
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['text/plain', 'application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -316,98 +334,104 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/vpn-connections/{vpnConnectionExtId}/vpn-vendor-configs/{extId}', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='str',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/vpn-connections/{vpnConnectionExtId}/vpn-vendor-configs/{extId}', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='str',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/vpn-connections/{vpnConnectionExtId}/vpn-vendor-configs/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='str',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/vpn-connections/{vpnConnectionExtId}/vpn-vendor-configs/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='str',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def get_vpn_connection(self, extId, **kwargs):  # noqa: E501
+    def get_vpn_connection_by_id(self, extId, **kwargs):  # noqa: E501
         """Get VPN connection
 
-        >>> response = api.get_vpn_connection(extId)
+        >>> response = api.get_vpn_connection_by_id(extId)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.get_vpn_connection(extId, async_req=True)
+        >>> thread = api.get_vpn_connection_by_id(extId, async_req=True)
         >>> result = thread.get()
 
         :param extId: VPN connection UUID
         :type extId:
+
             :class:`str`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.VpnConnectionApiResponse`.
+        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.GetVpnConnectionApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `get_vpn_connection`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `get_vpn_connection_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -420,91 +444,97 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/vpn-connections/{extId}', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.VpnConnectionApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/vpn-connections/{extId}', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.VpnConnectionApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/vpn-connections/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.GetVpnConnectionApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/vpn-connections/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.GetVpnConnectionApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def list_vpn_appliances(self, extId, _page=None, _limit=None, **kwargs):  # noqa: E501
+    def list_vpn_appliances_by_vpn_connection_id(self, extId, _page=None, _limit=None, **kwargs):  # noqa: E501
         """List of third-party VPN appliances for which configurations are available to download.
 
-        >>> response = api.list_vpn_appliances(extId, (optional) _page, (optional) _limit)
+        >>> response = api.list_vpn_appliances_by_vpn_connection_id(extId, (optional) _page, (optional) _limit)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.list_vpn_appliances(extId, async_req=True)
+        >>> thread = api.list_vpn_appliances_by_vpn_connection_id(extId, async_req=True)
         >>> result = thread.get()
 
         :param extId: VPN connection UUID.
         :type extId:
+
             :class:`str`, required
-        :param _page: A URL query parameter that specifies the page number of the result set.  Must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range will lead to no results being returned. 
+        :param _page: A URL query parameter that specifies the page number of the result set. It must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range might lead to no results. 
         :type _page:
+
             :class:`int`
-        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided a default value of 50 records will be returned in the result set. 
+        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided, a default value of 50 records will be returned in the result set. 
         :type _limit:
+
             :class:`int`
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.VpnVendorListApiResponse`.
+        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.ListVpnVendorConfigsApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `list_vpn_appliances`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `list_vpn_appliances_by_vpn_connection_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
@@ -514,14 +544,16 @@
         if '_limit' in params and params['_limit'] is not None:
             query_params.append(('$limit', params['_limit']))  # noqa: E501
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -534,86 +566,93 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/vpn-connections/{extId}/vpn-vendor-configs', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.VpnVendorListApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/vpn-connections/{extId}/vpn-vendor-configs', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.VpnVendorListApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/vpn-connections/{extId}/vpn-vendor-configs', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.ListVpnVendorConfigsApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/vpn-connections/{extId}/vpn-vendor-configs', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.ListVpnVendorConfigsApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
     def list_vpn_connections(self, _page=None, _limit=None, _filter=None, _orderby=None, **kwargs):  # noqa: E501
         """List the VPN connections
 
         >>> response = api.list_vpn_connections((optional) _page, (optional) _limit, (optional) _filter, (optional) _orderby)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
         >>> thread = api.list_vpn_connections(async_req=True)
         >>> result = thread.get()
 
-        :param _page: A URL query parameter that specifies the page number of the result set.  Must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range will lead to no results being returned. 
+        :param _page: A URL query parameter that specifies the page number of the result set. It must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range might lead to no results. 
         :type _page:
+
             :class:`int`
-        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided a default value of 50 records will be returned in the result set. 
+        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided, a default value of 50 records will be returned in the result set. 
         :type _limit:
+
             :class:`int`
-        :param _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the OData V4.01 URL conventions. For example, filter '$filter=name eq 'karbon-ntnx-1.0' would filter result on cluster name karbon-ntnx1.0, filter '$filter=startswith(name, 'C')' would filter on cluster name starting with C. The filter can be applied on the following fields: - dynamicRoutePriority - localGatewayReference - name - remoteGatewayReference 
+        :param _filter: A URL query parameter that allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the [OData V4.01](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html) URL conventions. For example, filter '$filter=name eq 'karbon-ntnx-1.0' would filter the result on cluster name 'karbon-ntnx1.0', filter '$filter=startswith(name, 'C')' would filter on cluster name starting with 'C'. The filter can be applied to the following fields: - dynamicRoutePriority - localGatewayReference - name - remoteGatewayReference 
         :type _filter:
+
             :class:`str`
-        :param _orderby: A URL query parameter that allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified the resources will be sorted in ascending order by default. For example, '$orderby=templateName desc' would get all templates sorted by templateName in desc order. The orderby can be applied to the following fields: - dynamicRoutePriority - name 
+        :param _orderby: A URL query parameter that allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified, the resources will be sorted in ascending order by default. For example, '$orderby=templateName desc' would get all templates sorted by templateName in descending order. The orderby can be applied to the following fields: - dynamicRoutePriority - name 
         :type _orderby:
+
             :class:`str`
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.VpnConnectionListApiResponse`.
+        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.ListVpnConnectionsApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
 
         collection_formats = {}
@@ -630,14 +669,16 @@
         if '_orderby' in params and params['_orderby'] is not None:
             query_params.append(('$orderby', params['_orderby']))  # noqa: E501
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -650,108 +691,117 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/vpn-connections', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.VpnConnectionListApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/vpn-connections', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.VpnConnectionListApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/vpn-connections', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.ListVpnConnectionsApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/vpn-connections', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.ListVpnConnectionsApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
 
-    def update_vpn_connection(self, extId, body, **kwargs):  # noqa: E501
+    def update_vpn_connection_by_id(self, extId, body, **kwargs):  # noqa: E501
         """Update VPN connection
 
-        >>> response = api.update_vpn_connection(extId, body)
+        >>> response = api.update_vpn_connection_by_id(extId, body)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.update_vpn_connection(extId, body, async_req=True)
+        >>> thread = api.update_vpn_connection_by_id(extId, body, async_req=True)
         >>> result = thread.get()
 
         :param extId: VPN connection UUID
         :type extId:
+
             :class:`str`, required
         :param body: Update VPN connection request body
         :type body:
+
             :class:`~ntnx_networking_py_client.models.networking.v4.config.VpnConnection`, required
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
         :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.config.TaskReferenceApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
-            raise ValueError("Missing the required parameter `extId` when calling `update_vpn_connection`")  # noqa: E501
+            raise ValueError("Missing the required parameter `extId` when calling `update_vpn_connection_by_id`")  # noqa: E501
         # verify the required parameter 'body' is set
         if ('body' not in params or params['body'] is None):
-            raise ValueError("Missing the required parameter `body` when calling `update_vpn_connection`")  # noqa: E501
+            raise ValueError("Missing the required parameter `body` when calling `update_vpn_connection_by_id`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
         query_params = []
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client._select_header_content_type(  # noqa: E501
             ['application/json'])  # noqa: E501
+        if 'Content-Type' in params and params.get('Content-Type') is not None:
+            header_params['Content-Type'] = params.get('Content-Type')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -764,47 +814,50 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
+        # Authentication setting
+        auth_settings = ['basicAuthScheme']  # noqa: E501
+
         body_params = None
         if 'body' in params and params['body'] is not None:
             body_params = params['body']
 
-        # Authentication setting
-        auth_settings = ['basicAuthScheme']  # noqa: E501
-
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/vpn-connections/{extId}', 'PUT',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/config/vpn-connections/{extId}', 'PUT',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/vpn-connections/{extId}', 'PUT',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/config/vpn-connections/{extId}', 'PUT',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.config.TaskReferenceApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api/vpn_connection_stats_api.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api/vpn_connection_stats_api.py`

 * *Files 11% similar despite different names*

```diff
@@ -3,15 +3,15 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 from __future__ import absolute_import
 
 import re  # noqa: F401
@@ -29,69 +29,83 @@
     """  # noqa: E501
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
 
         self.api_client = api_client
-        self.__headers_to_skip = { 'authorization', 'cookie', 'ntnx-request-id', 'host', 'user-agent' }
+        self.__headers_to_skip = { 'authorization', 'cookie', 'host', 'user-agent' }
 
-    def get_vpn_connection_stats(self, extId, _startTime=None, _endTime=None, _samplingInterval=None, _statType=None, _page=None, _limit=None, _select=None, **kwargs):  # noqa: E501
+    def get_vpn_connection_stats(self, extId, _startTime, _endTime, _samplingInterval=None, _statType=None, _page=None, _limit=None, _select=None, **kwargs):  # noqa: E501
         """Get VPN connection statistics
 
-        >>> response = api.get_vpn_connection_stats(extId, (optional) _startTime, (optional) _endTime, (optional) _samplingInterval, (optional) _statType, (optional) _page, (optional) _limit, (optional) _select)
+        >>> response = api.get_vpn_connection_stats(extId, _startTime, _endTime, (optional) _samplingInterval, (optional) _statType, (optional) _page, (optional) _limit, (optional) _select)
 
         This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async_req=True.
 
-        >>> thread = api.get_vpn_connection_stats(extId, async_req=True)
+        >>> thread = api.get_vpn_connection_stats(extId, _startTime, _endTime, async_req=True)
         >>> result = thread.get()
 
         :param extId: VPN connection UUID
         :type extId:
+
             :class:`str`, required
         :param _startTime: The start time of the period for which stats should be reported. The value should be in extended ISO-8601 format. For example, start time of 2022-04-23T01:23:45.678+09:00 would consider all stats starting at 1:23:45.678 on the 23rd of April 2022. Details around ISO-8601 format can be found at https://www.iso.org/standard/70907.html 
         :type _startTime:
-            :class:`str`
+
+            :class:`str`, required
         :param _endTime: The end time of the period for which stats should be reported. The value should be in extended ISO-8601 format. For example, end time of 2022-04-23T013:23:45.678+09:00 would consider all stats till 13:23:45 .678 on the 23rd of April 2022. Details around ISO-8601 format can be found at https://www.iso.org/standard/70907.html 
         :type _endTime:
-            :class:`str`
-        :param _samplingInterval: The sampling interval in seconds at which statistical data should be collected For example, do you want performance statistics every 30 seconds? Every 60 seconds? 
+
+            :class:`str`, required
+        :param _samplingInterval: The sampling interval in seconds at which statistical data should be collected. For example, if you want performance statistics every 30 seconds, then provide the value as 30. 
         :type _samplingInterval:
+
             :class:`int`
         :param _statType: 
         :type _statType:
+
             :class:`common.v1.stats.DownSamplingOperator`
-        :param _page: A URL query parameter that specifies the page number of the result set.  Must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range will lead to no results being returned. 
+        :param _page: A URL query parameter that specifies the page number of the result set. It must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range might lead to no results. 
         :type _page:
+
             :class:`int`
-        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided a default value of 50 records will be returned in the result set. 
+        :param _limit: A URL query parameter that specifies the total number of records returned in the result set.  Must be a positive integer between 1 and 100. Any number out of this range will lead to a validation error. If the limit is not provided, a default value of 50 records will be returned in the result set. 
         :type _limit:
+
             :class:`int`
-        :param _select: A URL query parameter that allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the OData V4.01 URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e. *), then all properties on the matching resource will be returned. - entityUuid - extId - links - statType - tenantId - throughputRxKbps - throughputTxKbps 
+        :param _select: A URL query parameter that allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the [OData V4.01](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html) URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e., *), then all properties on the matching resource will be returned. - entityUuid - extId - links - statType - tenantId - throughputRxKbps - throughputTxKbps 
         :type _select:
+
             :class:`str`
         :param kwargs: kwargs for the method.
                        The following can be passed for an asynchronous HTTP call::
 
                            async_req=True
-        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.stats.VpnConnectionStatsApiResponse`.
+        :return: An instance of class :class:`~ntnx_networking_py_client.models.networking.v4.stats.GetVpnConnectionStatsApiResponse`.
 
                  If the method is called asynchronously, returns the request thread.
         """ # noqa: E501
         kwargs['_return_http_data_only'] = True
 
-        params = locals()
+        params = dict(locals())
         for key, val in six.iteritems(params['kwargs']):
             params[key] = val
         del params['kwargs']
         del params['self']
 
         # verify the required parameter 'extId' is set
         if ('extId' not in params or params['extId'] is None):
             raise ValueError("Missing the required parameter `extId` when calling `get_vpn_connection_stats`")  # noqa: E501
+        # verify the required parameter '_startTime' is set
+        if ('_startTime' not in params or params['_startTime'] is None):
+            raise ValueError("Missing the required parameter `_startTime` when calling `get_vpn_connection_stats`")  # noqa: E501
+        # verify the required parameter '_endTime' is set
+        if ('_endTime' not in params or params['_endTime'] is None):
+            raise ValueError("Missing the required parameter `_endTime` when calling `get_vpn_connection_stats`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
         if 'extId' in params and params['extId'] is not None:
             path_params['extId'] = params['extId']  # noqa: E501
 
@@ -111,14 +125,16 @@
         if '_select' in params and params['_select'] is not None:
             query_params.append(('$select', params['_select']))  # noqa: E501
 
         header_params = {}
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client._select_header_accept(
             ['application/json'])  # noqa: E501
+        if 'Accept' in params and params.get('Accept') is not None:
+            header_params['Accept'] = params.get('Accept')
 
         # Process operation specific headers
         extra_params = []
         extra_params.append('async_req')
         extra_params.append('_return_http_data_only')
         extra_params.append('_preload_content')
         extra_params.append('_request_timeout')
@@ -131,45 +147,48 @@
                 elif key.lower() == 'if_none_match'.lower():
                     key = 'If-None-Match'
                 header_params[key] = val
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-
         # Authentication setting
         auth_settings = ['basicAuthScheme']  # noqa: E501
 
-        if kwargs.get('async_req'):
-            return self.api_client._call_api(
-                '/api/networking/v4.0.b1/stats/vpn-connections/{extId}', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.stats.VpnConnectionStatsApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-        else:
-            (data) = self.api_client._call_api(
-                '/api/networking/v4.0.b1/stats/vpn-connections/{extId}', 'GET',
-                path_params,
-                query_params,
-                header_params,
-                body=body_params,
-                post_params=form_params,
-                files=local_var_files,
-                response_type='networking.v4.stats.VpnConnectionStatsApiResponse',  # noqa: E501
-                auth_settings=auth_settings,
-                async_req=params.get('async_req'),
-                _return_http_data_only=params.get('_return_http_data_only'),
-                _preload_content=params.get('_preload_content', True),
-                _request_timeout=params.get('_request_timeout'),
-                collection_formats=collection_formats)
-            return data
+        body_params = None
+
+        try:
+            if kwargs.get('async_req'):
+                return self.api_client._call_api(
+                    '/api/networking/v4.0.b1/stats/vpn-connections/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.stats.GetVpnConnectionStatsApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+            else:
+                (data) = self.api_client._call_api(
+                    '/api/networking/v4.0.b1/stats/vpn-connections/{extId}', 'GET',
+                    path_params,
+                    query_params,
+                    header_params,
+                    body=body_params,
+                    post_params=form_params,
+                    files=local_var_files,
+                    response_type='networking.v4.stats.GetVpnConnectionStatsApiResponse',  # noqa: E501
+                    auth_settings=auth_settings,
+                    async_req=params.get('async_req'),
+                    _return_http_data_only=params.get('_return_http_data_only'),
+                    _preload_content=params.get('_preload_content', True),
+                    _request_timeout=params.get('_request_timeout'),
+                    collection_formats=collection_formats)
+                return data
+        finally:
+            pass
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api_client.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api_client.py`

 * *Files 10% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 from __future__ import absolute_import
 
 import datetime
@@ -25,14 +25,22 @@
 import uuid
 import logging
 
 # python 2 and python 3 compatibility library
 import six
 from six.moves.urllib.parse import quote
 
+from pathlib import Path
+
+
+try:
+    import urllib3
+except ImportError:
+    raise ImportError('Api client requires urllib3.')
+
 from ntnx_networking_py_client.configuration import Configuration
 import ntnx_networking_py_client.models
 from ntnx_networking_py_client import rest
 
 PY2 = sys.version_info[0] < 3
 
 logger = logging.getLogger(__name__)
@@ -57,291 +65,282 @@
         'datetime': datetime.datetime,
         'object': object,
     }
     DUPLICATE_SCHEMA_MAPPING = {
     # Populated if multiple schemas exist with the same name
         'networking.v4.config.GatewayProjection' : 'GatewayProjection',
         'OneOfnetworking.v4.config.GatewayProjectionservices' : 'GatewayProjectionservices',
+        'networking.v4.config.ListVirtualSwitchesApiResponse' : 'ListVirtualSwitchesApiResponse',
         'networking.v4.error.AppMessage' : 'AppMessage',
         'networking.v4.config.Cluster' : 'Cluster',
-        'OneOfnetworking.v4.config.IPFIXExporterListApiResponsedata' : 'IPFIXExporterListApiResponsedata',
         'networking.v4.config.BondModeType' : 'BondModeType',
-        'networking.v4.config.RouteTableApiResponse' : 'RouteTableApiResponse',
-        'OneOfnetworking.v4.config.VirtualSwitchListApiResponsedata' : 'VirtualSwitchListApiResponsedata',
+        'OneOfnetworking.v4.stats.GetTrafficMirrorStatsApiResponsedata' : 'GetTrafficMirrorStatsApiResponsedata',
+        'OneOfnetworking.v4.config.GetTrafficMirrorApiResponsedata' : 'GetTrafficMirrorApiResponsedata',
         'networking.v4.config.IPSubnet' : 'IPSubnet',
-        'networking.v4.config.Layer2StretchRelatedEntitiesApiResponse' : 'Layer2StretchRelatedEntitiesApiResponse',
         'networking.v4.config.FlowGatewayKeepAliveRequestSpec' : 'FlowGatewayKeepAliveRequestSpec',
-        'OneOfnetworking.v4.config.FlowGatewayListApiResponsedata' : 'FlowGatewayListApiResponsedata',
-        'networking.v4.config.IPFIXExporterApiResponse' : 'IPFIXExporterApiResponse',
+        'networking.v4.config.GetSubnetApiResponse' : 'GetSubnetApiResponse',
         'networking.v4.config.BgpInfo' : 'BgpInfo',
-        'OneOfnetworking.v4.config.NetworkCloudConfigApiResponsedata' : 'NetworkCloudConfigApiResponsedata',
         'networking.v4.config.VpcProjection' : 'VpcProjection',
         'prism.v4.config.TaskReference' : 'TaskReference',
         'networking.v4.config.LocalNetworkServices' : 'LocalNetworkServices',
         'networking.v4.config.AzureExternalSubnetBinding' : 'AzureExternalSubnetBinding',
         'networking.v4.config.Host' : 'Host',
         'networking.v4.config.LearnedAddress' : 'LearnedAddress',
         'networking.v4.config.ExporterProtocol' : 'ExporterProtocol',
         'networking.v4.config.VnicMigrationItem' : 'VnicMigrationItem',
         'networking.v4.config.GatewayRole' : 'GatewayRole',
         'networking.v4.config.AuthenticationAlgorithm' : 'AuthenticationAlgorithm',
         'networking.v4.config.UplinkBondVirtualSwitchInfo' : 'UplinkBondVirtualSwitchInfo',
-        'OneOfnetworking.v4.config.VpnConnectionApiResponsedata' : 'VpnConnectionApiResponsedata',
-        'networking.v4.config.FloatingIpApiResponse' : 'FloatingIpApiResponse',
-        'networking.v4.config.VpnConnectionListApiResponse' : 'VpnConnectionListApiResponse',
-        'OneOfnetworking.v4.config.TrafficMirrorListApiResponsedata' : 'TrafficMirrorListApiResponsedata',
+        'OneOfnetworking.v4.config.ListVirtualSwitchesApiResponsedata' : 'ListVirtualSwitchesApiResponsedata',
         'networking.v4.config.GatewayNic' : 'GatewayNic',
+        'OneOfnetworking.v4.stats.GetVpcNsStatsApiResponsedata' : 'GetVpcNsStatsApiResponsedata',
         'networking.v4.config.CloudSubstrate' : 'CloudSubstrate',
         'networking.v4.config.LocalVpnService' : 'LocalVpnService',
+        'networking.v4.stats.GetTrafficMirrorStatsApiResponse' : 'GetTrafficMirrorStatsApiResponse',
         'networking.v4.stats.TaskReferenceApiResponse' : 'StatsTaskReferenceApiResponse',
         'networking.v4.config.GatewayNodeReference' : 'GatewayNodeReference',
-        'OneOfnetworking.v4.config.IPFIXExporterApiResponsedata' : 'IPFIXExporterApiResponsedata',
+        'OneOfnetworking.v4.config.ListLayer2StretchesApiResponsedata' : 'ListLayer2StretchesApiResponsedata',
+        'networking.v4.config.ListTrafficMirrorsApiResponse' : 'ListTrafficMirrorsApiResponse',
         'networking.v4.config.IPv4Config' : 'IPv4Config',
         'networking.v4.config.RoutingPolicyAction' : 'RoutingPolicyAction',
-        'networking.v4.config.VpcVirtualSwitchMappingsApiResponse' : 'VpcVirtualSwitchMappingsApiResponse',
         'networking.v4.config.RerouteParam' : 'RerouteParam',
         'networking.v4.stats.VpcNsStats' : 'VpcNsStats',
         'networking.v4.config.ICMPObject' : 'ICMPObject',
-        'networking.v4.config.IPFIXExporterListApiResponse' : 'IPFIXExporterListApiResponse',
         'networking.v4.config.VmNicProjection' : 'VmNicProjection',
-        'OneOfnetworking.v4.config.GatewayApiResponsedata' : 'GatewayApiResponsedata',
+        'OneOfnetworking.v4.config.ListVpnVendorConfigsApiResponsedata' : 'ListVpnVendorConfigsApiResponsedata',
         'networking.v4.config.VpnAppliance' : 'VpnAppliance',
         'networking.v4.config.BgpSessionProjection' : 'BgpSessionProjection',
         'networking.v4.stats.StatsQueryResponseBase' : 'StatsQueryResponseBase',
-        'OneOfnetworking.v4.config.RouteTableApiResponsedata' : 'RouteTableApiResponsedata',
-        'OneOfnetworking.v4.config.FlowGatewayKeepAliveApiResponsedata' : 'FlowGatewayKeepAliveApiResponsedata',
+        'networking.v4.config.GetVpnConnectionApiResponse' : 'GetVpnConnectionApiResponse',
         'OneOfnetworking.v4.stats.TaskReferenceApiResponsedata' : 'StatsTaskReferenceApiResponsedata',
         'networking.v4.config.ClusterFlowStatus' : 'ClusterFlowStatus',
         'networking.v4.config.DpdConfig' : 'DpdConfig',
-        'OneOfnetworking.v4.config.NodeSchedulableStatusApiResponsedata' : 'NodeSchedulableStatusApiResponsedata',
+        'networking.v4.config.ListVpnVendorConfigsApiResponse' : 'ListVpnVendorConfigsApiResponse',
         'networking.v4.config.Vtep' : 'Vtep',
         'networking.v4.config.AzureExternalSubnetConfig' : 'AzureExternalSubnetConfig',
+        'networking.v4.config.GatewayInterface' : 'GatewayInterface',
+        'networking.v4.config.GetRoutingPolicyApiResponse' : 'GetRoutingPolicyApiResponse',
         'networking.v4.config.ReserveType' : 'ReserveType',
         'networking.v4.config.AddressType' : 'AddressType',
         'networking.v4.config.RemoteVtepStretchStatus' : 'RemoteVtepStretchStatus',
         'networking.v4.config.SubnetProjection' : 'SubnetProjection',
-        'OneOfnetworking.v4.config.VpcApiResponsedata' : 'VpcApiResponsedata',
         'networking.v4.config.AssignedAddress' : 'AssignedAddress',
-        'OneOfnetworking.v4.config.VpcVirtualSwitchMappingsApiResponsedata' : 'VpcVirtualSwitchMappingsApiResponsedata',
         'networking.v4.config.IbgpConfig' : 'IbgpConfig',
         'networking.v4.stats.Layer2StretchStats' : 'Layer2StretchStats',
-        'OneOfnetworking.v4.config.SubnetApiResponsedata' : 'SubnetApiResponsedata',
-        'networking.v4.config.FlowGatewayKeepAliveApiResponse' : 'FlowGatewayKeepAliveApiResponse',
-        'OneOfnetworking.v4.stats.Layer2StretchStatsApiResponsedata' : 'Layer2StretchStatsApiResponsedata',
+        'networking.v4.config.ListVpcsApiResponse' : 'ListVpcsApiResponse',
+        'OneOfnetworking.v4.config.ListFloatingIpsApiResponsedata' : 'ListFloatingIpsApiResponsedata',
         'networking.v4.config.QosConfig' : 'QosConfig',
+        'networking.v4.config.GetTrafficMirrorApiResponse' : 'GetTrafficMirrorApiResponse',
         'networking.v4.config.Layer2Stretch' : 'Layer2Stretch',
         'networking.v4.config.VpnConnection' : 'VpnConnection',
         'networking.v4.config.AuthenticationType' : 'AuthenticationType',
-        'OneOfnetworking.v4.config.AncConfigApiResponsedata' : 'AncConfigApiResponsedata',
+        'OneOfnetworking.v4.config.ListClusterCapabilitiesApiResponsedata' : 'ListClusterCapabilitiesApiResponsedata',
         'networking.v4.config.RoutingPolicyMatchCondition' : 'RoutingPolicyMatchCondition',
         'networking.v4.stats.TrafficMirrorStatsData' : 'TrafficMirrorStatsData',
         'networking.v4.config.IpUnreserveSpec' : 'IpUnreserveSpec',
         'networking.v4.error.SchemaValidationErrorMessage' : 'SchemaValidationErrorMessage',
-        'OneOfnetworking.v4.config.SubnetListApiResponsedata' : 'SubnetListApiResponsedata',
         'networking.v4.config.IPConfig' : 'IPConfig',
         'networking.v4.config.State' : 'State',
         'networking.v4.config.VpcDhcpOptions' : 'VpcDhcpOptions',
-        'networking.v4.stats.VpcNsStatsApiResponse' : 'VpcNsStatsApiResponse',
-        'OneOfnetworking.v4.config.VpnVendorListApiResponsedata' : 'VpnVendorListApiResponsedata',
         'networking.v4.config.FloatingIp' : 'FloatingIp',
         'networking.v4.config.IpsecConfig' : 'IpsecConfig',
         'networking.v4.config.AddressTypeObject' : 'AddressTypeObject',
         'networking.v4.config.Gateway' : 'Gateway',
         'networking.v4.config.Status' : 'Status',
-        'OneOfnetworking.v4.config.FloatingIpListApiResponsedata' : 'FloatingIpListApiResponsedata',
+        'OneOfnetworking.v4.config.ListRouteTablesApiResponsedata' : 'ListRouteTablesApiResponsedata',
         'networking.v4.config.VirtualSwitchProjection' : 'VirtualSwitchProjection',
         'networking.v4.config.Vpc' : 'Vpc',
         'networking.v4.error.SchemaValidationError' : 'SchemaValidationError',
-        'networking.v4.config.Layer2StretchApiResponse' : 'Layer2StretchApiResponse',
         'networking.v4.config.RemoteNetworkServices' : 'RemoteNetworkServices',
-        'OneOfnetworking.v4.config.VpcListApiResponsedata' : 'VpcListApiResponsedata',
-        'networking.v4.config.FlowGatewayListApiResponse' : 'FlowGatewayListApiResponse',
-        'OneOfnetworking.v4.config.ClusterCapabilityApiResponsedata' : 'ClusterCapabilityApiResponsedata',
         'networking.v4.config.TrafficMirror' : 'TrafficMirror',
-        'networking.v4.config.VirtualSwitchListApiResponse' : 'VirtualSwitchListApiResponse',
+        'OneOfnetworking.v4.config.GetRoutingPolicyApiResponsedata' : 'GetRoutingPolicyApiResponsedata',
         'networking.v4.stats.VpnConnectionStats' : 'VpnConnectionStats',
         'networking.v4.config.Vm' : 'Vm',
         'networking.v4.config.UnreserveType' : 'UnreserveType',
         'networking.v4.config.ClusterStatus' : 'ClusterStatus',
-        'networking.v4.stats.TrafficMirrorStatsApiResponse' : 'TrafficMirrorStatsApiResponse',
+        'OneOfnetworking.v4.config.ListSubnetsApiResponsedata' : 'ListSubnetsApiResponsedata',
+        'networking.v4.config.GetLayer2StretchApiResponse' : 'GetLayer2StretchApiResponse',
         'networking.v4.stats.RoutingPolicyClearCountersSpec' : 'RoutingPolicyClearCountersSpec',
         'networking.v4.config.ProtocolType' : 'ProtocolType',
-        'networking.v4.config.RoutingPolicyListApiResponse' : 'RoutingPolicyListApiResponse',
         'common.v1.response.ApiLink' : 'ApiLink',
         'networking.v4.config.ProtocolNumberObject' : 'ProtocolNumberObject',
-        'networking.v4.config.VpnVendorListApiResponse' : 'VpnVendorListApiResponse',
+        'OneOfnetworking.v4.config.GetVirtualSwitchApiResponsedata' : 'GetVirtualSwitchApiResponsedata',
         'networking.v4.config.ExportScope' : 'ExportScope',
         'networking.v4.config.FloatingIPv6Address' : 'FloatingIPv6Address',
-        'OneOfnetworking.v4.config.FlowGatewayApiResponsedata' : 'FlowGatewayApiResponsedata',
         'networking.v4.config.SiteParams' : 'SiteParams',
-        'OneOfnetworking.v4.config.CloudNetworkListApiResponsedata' : 'CloudNetworkListApiResponsedata',
+        'networking.v4.config.ListBgpSessionsApiResponse' : 'ListBgpSessionsApiResponse',
         'networking.v4.config.RemoteBgpService' : 'RemoteBgpService',
-        'networking.v4.config.CloudNetworkApiResponse' : 'CloudNetworkApiResponse',
-        'networking.v4.config.ClusterCapabilityApiResponse' : 'ClusterCapabilityApiResponse',
-        'OneOfnetworking.v4.config.Layer2StretchApiResponsedata' : 'Layer2StretchApiResponsedata',
+        'OneOfnetworking.v4.config.GetRouteTableApiResponsedata' : 'GetRouteTableApiResponsedata',
         'networking.v4.config.BgpConfig' : 'BgpConfig',
         'networking.v4.config.NodeSchedulableStatusProjection' : 'NodeSchedulableStatusProjection',
         'OneOfnetworking.v4.config.Gatewayservices' : 'Gatewayservices',
-        'networking.v4.config.ClusterFlowStatusApiResponse' : 'ClusterFlowStatusApiResponse',
         'networking.v4.config.UplinkBondLacpStatus' : 'UplinkBondLacpStatus',
+        'networking.v4.config.ListClusterCapabilitiesApiResponse' : 'ListClusterCapabilitiesApiResponse',
         'networking.v4.config.DpdOperation' : 'DpdOperation',
         'networking.v4.config.TrafficMirrorSourcePortDirection' : 'TrafficMirrorSourcePortDirection',
-        'networking.v4.config.VpcListApiResponse' : 'VpcListApiResponse',
         'networking.v4.config.GatewayManagementInterface' : 'GatewayManagementInterface',
         'networking.v4.config.Bridge' : 'Bridge',
         'networking.v4.config.TaskReferenceApiResponse' : 'ConfigTaskReferenceApiResponse',
-        'OneOfnetworking.v4.config.RouteTableListApiResponsedata' : 'RouteTableListApiResponsedata',
+        'OneOfnetworking.v4.config.ListUplinkBondsApiResponsedata' : 'ListUplinkBondsApiResponsedata',
         'networking.v4.config.IPv4Pool' : 'IPv4Pool',
-        'OneOfnetworking.v4.stats.VpcNsStatsApiResponsedata' : 'VpcNsStatsApiResponsedata',
         'networking.v4.config.LocalVtepService' : 'LocalVtepService',
         'networking.v4.config.Layer2StretchSubnetInfo' : 'Layer2StretchSubnetInfo',
-        'OneOfnetworking.v4.config.NetworkCloudConfigListApiResponsedata' : 'NetworkCloudConfigListApiResponsedata',
+        'OneOfnetworking.v4.config.GetSubnetApiResponsedata' : 'GetSubnetApiResponsedata',
+        'OneOfnetworking.v4.config.ListGatewaysApiResponsedata' : 'ListGatewaysApiResponsedata',
+        'networking.v4.config.VpcType' : 'VpcType',
         'networking.v4.config.RemoteBgpGateway' : 'RemoteBgpGateway',
-        'networking.v4.config.GatewayListApiResponse' : 'GatewayListApiResponse',
-        'networking.v4.config.BgpSessionListApiResponse' : 'BgpSessionListApiResponse',
+        'networking.v4.config.ListNodeSchedulableStatusesApiResponse' : 'ListNodeSchedulableStatusesApiResponse',
         'networking.v4.config.ScopeType' : 'ScopeType',
         'networking.v4.config.IPUsage' : 'IPUsage',
-        'OneOfnetworking.v4.stats.TrafficMirrorStatsApiResponsedata' : 'TrafficMirrorStatsApiResponsedata',
-        'networking.v4.config.NetworkControllerListApiResponse' : 'NetworkControllerListApiResponse',
         'common.v1.config.KVPair' : 'KVPair',
-        'networking.v4.config.SubnetListApiResponse' : 'SubnetListApiResponse',
+        'OneOfnetworking.v4.config.ListBgpSessionsApiResponsedata' : 'ListBgpSessionsApiResponsedata',
         'networking.v4.config.AzureConfig' : 'AzureConfig',
         'networking.v4.config.SubnetInfo' : 'SubnetInfo',
-        'OneOfnetworking.v4.config.GatewayListApiResponsedata' : 'GatewayListApiResponsedata',
-        'networking.v4.config.TrafficMirrorListApiResponse' : 'TrafficMirrorListApiResponse',
+        'OneOfnetworking.v4.config.GetFloatingIpApiResponsedata' : 'GetFloatingIpApiResponsedata',
         'common.v1.config.IPv4Address' : 'IPv4Address',
         'networking.v4.config.PortRange' : 'PortRange',
         'networking.v4.config.IPv6Pool' : 'IPv6Pool',
         'common.v1.stats.DownSamplingOperator' : 'DownSamplingOperator',
-        'networking.v4.config.VpcApiResponse' : 'VpcApiResponse',
         'common.v1.config.IPv6Address' : 'IPv6Address',
         'networking.v4.config.FloatingIPAddress' : 'FloatingIPAddress',
-        'networking.v4.config.VpnConnectionApiResponse' : 'VpnConnectionApiResponse',
+        'networking.v4.stats.GetVpcNsStatsApiResponse' : 'GetVpcNsStatsApiResponse',
+        'OneOfnetworking.v4.config.ListIPFIXExportersApiResponsedata' : 'ListIPFIXExportersApiResponsedata',
         'common.v1.config.Flag' : 'Flag',
-        'networking.v4.config.TrafficMirrorApiResponse' : 'TrafficMirrorApiResponse',
+        'networking.v4.config.AwsSubnetConfig' : 'AwsSubnetConfig',
+        'networking.v4.config.ListRoutingPoliciesApiResponse' : 'ListRoutingPoliciesApiResponse',
         'networking.v4.config.Layer2StretchVpnConnectionInfo' : 'Layer2StretchVpnConnectionInfo',
         'networking.v4.config.RemoteVpnService' : 'RemoteVpnService',
-        'OneOfnetworking.v4.config.UplinkBondListApiResponsedata' : 'UplinkBondListApiResponsedata',
+        'networking.v4.config.GetGatewayApiResponse' : 'GetGatewayApiResponse',
         'networking.v4.config.RoutingPolicy' : 'RoutingPolicy',
         'OneOfnetworking.v4.config.FloatingIpassociation' : 'FloatingIpassociation',
-        'OneOfnetworking.v4.config.Layer2StretchRelatedEntitiesApiResponsedata' : 'Layer2StretchRelatedEntitiesApiResponsedata',
         'networking.v4.config.Layer2StretchVtepGatewayInfo' : 'Layer2StretchVtepGatewayInfo',
-        'networking.v4.config.FlowGatewayApiResponse' : 'FlowGatewayApiResponse',
-        'networking.v4.config.RouteTableListApiResponse' : 'RouteTableListApiResponse',
+        'OneOfnetworking.v4.config.GetUplinkBondApiResponsedata' : 'GetUplinkBondApiResponsedata',
         'common.v1.config.EntityReference' : 'EntityReference',
+        'networking.v4.config.AwsExternalSubnetConfig' : 'AwsExternalSubnetConfig',
         'networking.v4.config.OspfConfig' : 'OspfConfig',
-        'OneOfnetworking.v4.config.TrafficMirrorApiResponsedata' : 'TrafficMirrorApiResponsedata',
-        'networking.v4.config.NodeSchedulableStatusApiResponse' : 'NodeSchedulableStatusApiResponse',
-        'networking.v4.config.FloatingIpListApiResponse' : 'FloatingIpListApiResponse',
+        'OneOfnetworking.v4.config.ListVpcsApiResponsedata' : 'ListVpcsApiResponsedata',
         'networking.v4.config.ReservedAddress' : 'ReservedAddress',
         'networking.v4.config.AuthorizationData' : 'AuthorizationData',
         'networking.v4.config.CloudNetwork' : 'CloudNetwork',
         'networking.v4.config.NexthopType' : 'NexthopType',
-        'networking.v4.config.CloudNetworkListApiResponse' : 'CloudNetworkListApiResponse',
+        'networking.v4.config.ListVpcVirtualSwitchMappingsApiResponse' : 'ListVpcVirtualSwitchMappingsApiResponse',
         'networking.v4.config.EncryptionAlgorithm' : 'EncryptionAlgorithm',
-        'OneOfnetworking.v4.config.RoutingPolicyListApiResponsedata' : 'RoutingPolicyListApiResponsedata',
+        'networking.v4.config.GetBgpSessionApiResponse' : 'GetBgpSessionApiResponse',
         'networking.v4.config.LayerFourProtocolObject' : 'LayerFourProtocolObject',
         'networking.v4.config.IPPoolUsage' : 'IPPoolUsage',
         'networking.v4.config.NetworkingBaseModel' : 'NetworkingBaseModel',
+        'networking.v4.stats.GetVpnConnectionStatsApiResponse' : 'GetVpnConnectionStatsApiResponse',
         'OneOfnetworking.v4.config.FloatingIpProjectionassociation' : 'FloatingIpProjectionassociation',
-        'networking.v4.config.UplinkBondListApiResponse' : 'UplinkBondListApiResponse',
+        'networking.v4.config.VnicMigrationItemSpec' : 'VnicMigrationItemSpec',
+        'OneOfnetworking.v4.config.GetNetworkControllerApiResponsedata' : 'GetNetworkControllerApiResponsedata',
+        'OneOfnetworking.v4.config.GetVpnConnectionApiResponsedata' : 'GetVpnConnectionApiResponsedata',
         'common.v1.config.Metadata' : 'Metadata',
         'networking.v4.config.IPv4Subnet' : 'IPv4Subnet',
         'networking.v4.config.UplinkBondType' : 'UplinkBondType',
-        'OneOfnetworking.v4.config.NetworkControllerListApiResponsedata' : 'NetworkControllerListApiResponsedata',
-        'networking.v4.config.NetworkCloudConfigListApiResponse' : 'NetworkCloudConfigListApiResponse',
+        'OneOfnetworking.v4.config.GetBgpSessionApiResponsedata' : 'GetBgpSessionApiResponsedata',
         'networking.v4.config.NodeSchedulableStatus' : 'NodeSchedulableStatus',
         'networking.v4.config.TrafficMirrorPortNicType' : 'TrafficMirrorPortNicType',
+        'OneOfnetworking.v4.config.ListNetworkControllersApiResponsedata' : 'ListNetworkControllersApiResponsedata',
         'networking.v4.config.ControllerStatus' : 'ControllerStatus',
         'networking.v4.config.IpReserveSpec' : 'IpReserveSpec',
+        'OneOfnetworking.v4.config.ListTrafficMirrorsApiResponsedata' : 'ListTrafficMirrorsApiResponsedata',
         'networking.v4.config.BgpSession' : 'BgpSession',
         'networking.v4.config.FlowGatewayKeepAlive' : 'FlowGatewayKeepAlive',
+        'networking.v4.config.ListLayer2StretchesApiResponse' : 'ListLayer2StretchesApiResponse',
         'networking.v4.config.VlanSubnetMigrationSpec' : 'VlanSubnetMigrationSpec',
         'networking.v4.config.DefaultVlanStack' : 'DefaultVlanStack',
         'networking.v4.config.Route' : 'Route',
+        'OneOfnetworking.v4.config.ListLayer2StretchRelatedEntitiesApiResponsedata' : 'ListLayer2StretchRelatedEntitiesApiResponsedata',
         'OneOfnetworking.v4.error.ErrorResponseerror' : 'ErrorResponseerror',
         'networking.v4.config.ExternalSubnet' : 'ExternalSubnet',
         'networking.v4.config.RouteTable' : 'RouteTable',
+        'networking.v4.config.GetNetworkControllerApiResponse' : 'GetNetworkControllerApiResponse',
         'networking.v4.config.RoutingPolicyActionType' : 'RoutingPolicyActionType',
         'networking.v4.config.RemoteVtepService' : 'RemoteVtepService',
-        'networking.v4.stats.VpnConnectionStatsApiResponse' : 'VpnConnectionStatsApiResponse',
         'common.v1.response.ApiResponseMetadata' : 'ApiResponseMetadata',
-        'networking.v4.config.NetworkCloudConfigApiResponse' : 'NetworkCloudConfigApiResponse',
         'networking.v4.config.NetworkController' : 'NetworkController',
         'networking.v4.config.RerouteFallbackAction' : 'RerouteFallbackAction',
-        'networking.v4.config.NetworkControllerApiResponse' : 'NetworkControllerApiResponse',
+        'OneOfnetworking.v4.stats.GetVpnConnectionStatsApiResponsedata' : 'GetVpnConnectionStatsApiResponsedata',
         'OneOfnetworking.v4.config.TaskReferenceApiResponsedata' : 'ConfigTaskReferenceApiResponsedata',
-        'networking.v4.config.RoutingPolicyApiResponse' : 'RoutingPolicyApiResponse',
         'networking.v4.config.PublicIpMapping' : 'PublicIpMapping',
+        'networking.v4.config.RoutingPolicyProjection' : 'RoutingPolicyProjection',
+        'networking.v4.config.ListLayer2StretchRelatedEntitiesApiResponse' : 'ListLayer2StretchRelatedEntitiesApiResponse',
         'common.v1.config.EntityType' : 'EntityType',
         'common.v1.response.ExternalizableAbstractModel' : 'ExternalizableAbstractModel',
         'networking.v4.config.VnicMigrationSpec' : 'VnicMigrationSpec',
         'networking.v4.config.VpcVirtualSwitchMapping' : 'VpcVirtualSwitchMapping',
         'common.v1.config.Message' : 'Message',
+        'networking.v4.config.GetFloatingIpApiResponse' : 'GetFloatingIpApiResponse',
         'networking.v4.config.Anc' : 'Anc',
         'networking.v4.config.IPFIXExporter' : 'IPFIXExporter',
-        'networking.v4.config.VirtualSwitchApiResponse' : 'VirtualSwitchApiResponse',
-        'OneOfnetworking.v4.config.RoutingPolicyApiResponsedata' : 'RoutingPolicyApiResponsedata',
+        'networking.v4.config.ListVpnConnectionsApiResponse' : 'ListVpnConnectionsApiResponse',
         'networking.v4.config.FlowGatewayStatus' : 'FlowGatewayStatus',
         'networking.v4.config.IPv6Subnet' : 'IPv6Subnet',
+        'networking.v4.config.ListIPFIXExportersApiResponse' : 'ListIPFIXExportersApiResponse',
         'networking.v4.config.SubnetType' : 'SubnetType',
         'networking.v4.config.LocalBgpGateway' : 'LocalBgpGateway',
         'networking.v4.config.VmNicAssociation' : 'VmNicAssociation',
         'OneOfcommon.v1.config.KVPairvalue' : 'KVPairvalue',
+        'networking.v4.config.AwsConfig' : 'AwsConfig',
+        'OneOfnetworking.v4.config.ListNodeSchedulableStatusesApiResponsedata' : 'ListNodeSchedulableStatusesApiResponsedata',
         'networking.v4.config.DhcpOptions' : 'DhcpOptions',
-        'networking.v4.config.GatewayApiResponse' : 'GatewayApiResponse',
+        'OneOfnetworking.v4.config.ListVpcVirtualSwitchMappingsApiResponsedata' : 'ListVpcVirtualSwitchMappingsApiResponsedata',
         'networking.v4.config.VmNic' : 'VmNic',
-        'OneOfnetworking.v4.config.BgpSessionListApiResponsedata' : 'BgpSessionListApiResponsedata',
+        'networking.v4.config.ListNetworkControllersApiResponse' : 'ListNetworkControllersApiResponse',
         'networking.v4.config.Address' : 'Address',
-        'networking.v4.config.UplinkBondApiResponse' : 'UplinkBondApiResponse',
         'networking.v4.config.NetworkCloudConfig' : 'NetworkCloudConfig',
         'common.v1.config.MessageSeverity' : 'MessageSeverity',
         'networking.v4.config.UplinkBond' : 'UplinkBond',
-        'OneOfnetworking.v4.stats.VpnConnectionStatsApiResponsedata' : 'VpnConnectionStatsApiResponsedata',
+        'networking.v4.config.GetVirtualSwitchApiResponse' : 'GetVirtualSwitchApiResponse',
         'networking.v4.config.VirtualSwitch' : 'VirtualSwitch',
-        'OneOfnetworking.v4.config.VirtualSwitchApiResponsedata' : 'VirtualSwitchApiResponsedata',
         'networking.v4.config.LocalBgpService' : 'LocalBgpService',
-        'OneOfnetworking.v4.config.CloudNetworkApiResponsedata' : 'CloudNetworkApiResponsedata',
         'networking.v4.config.GatewayDeployment' : 'GatewayDeployment',
-        'networking.v4.config.AncConfigApiResponse' : 'AncConfigApiResponse',
+        'networking.v4.config.ListGatewaysApiResponse' : 'ListGatewaysApiResponse',
         'networking.v4.config.FloatingIPv4Address' : 'FloatingIPv4Address',
         'networking.v4.config.BridgeProjection' : 'BridgeProjection',
+        'networking.v4.config.ListUplinkBondsApiResponse' : 'ListUplinkBondsApiResponse',
         'networking.v4.config.MigrationState' : 'MigrationState',
         'networking.v4.config.VmProjection' : 'VmProjection',
         'networking.v4.error.ErrorResponse' : 'ErrorResponse',
-        'OneOfnetworking.v4.config.VpnConnectionListApiResponsedata' : 'VpnConnectionListApiResponsedata',
+        'networking.v4.config.ListFloatingIpsApiResponse' : 'ListFloatingIpsApiResponse',
+        'OneOfnetworking.v4.config.ListVpnConnectionsApiResponsedata' : 'ListVpnConnectionsApiResponsedata',
+        'networking.v4.config.GetVpcApiResponse' : 'GetVpcApiResponse',
+        'OneOfnetworking.v4.config.GetIPFIXExporterApiResponsedata' : 'GetIPFIXExporterApiResponsedata',
+        'networking.v4.config.VpcNameProjection' : 'VpcNameProjection',
         'networking.v4.config.TrafficMirrorPort' : 'TrafficMirrorPort',
         'networking.v4.config.TrafficMirrorSourcePort' : 'TrafficMirrorSourcePort',
-        'networking.v4.config.BgpSessionApiResponse' : 'BgpSessionApiResponse',
-        'OneOfnetworking.v4.config.BgpSessionApiResponsedata' : 'BgpSessionApiResponsedata',
+        'networking.v4.config.ListRouteTablesApiResponse' : 'ListRouteTablesApiResponse',
+        'networking.v4.config.VpcName' : 'VpcName',
         'networking.v4.config.StretchConnectionType' : 'StretchConnectionType',
-        'OneOfnetworking.v4.config.UplinkBondApiResponsedata' : 'UplinkBondApiResponsedata',
+        'OneOfnetworking.v4.config.GetGatewayApiResponsedata' : 'GetGatewayApiResponsedata',
+        'networking.v4.stats.GetLayer2StretchStatsApiResponse' : 'GetLayer2StretchStatsApiResponse',
         'networking.v4.config.Layer2StretchRelatedEntities' : 'Layer2StretchRelatedEntities',
         'networking.v4.config.Subnet' : 'Subnet',
-        'OneOfnetworking.v4.config.ClusterFlowStatusApiResponsedata' : 'ClusterFlowStatusApiResponsedata',
         'networking.v4.config.PrivateIpAssociation' : 'PrivateIpAssociation',
-        'networking.v4.config.Layer2StretchListApiResponse' : 'Layer2StretchListApiResponse',
         'networking.v4.config.FlowGatewayState' : 'FlowGatewayState',
         'networking.v4.stats.TrafficMirrorStats' : 'TrafficMirrorStats',
-        'OneOfnetworking.v4.config.NetworkControllerApiResponsedata' : 'NetworkControllerApiResponsedata',
+        'OneOfnetworking.v4.config.GetVpcApiResponsedata' : 'GetVpcApiResponsedata',
+        'networking.v4.config.GetRouteTableApiResponse' : 'GetRouteTableApiResponse',
         'networking.v4.config.Capability' : 'Capability',
         'networking.v4.config.StretchStatus' : 'StretchStatus',
+        'OneOfnetworking.v4.stats.GetLayer2StretchStatsApiResponsedata' : 'GetLayer2StretchStatsApiResponsedata',
         'common.v1.config.IPAddress' : 'IPAddress',
         'common.v1.config.TenantAwareModel' : 'TenantAwareModel',
         'networking.v4.config.InternalRoutingConfig' : 'InternalRoutingConfig',
-        'networking.v4.stats.Layer2StretchStatsApiResponse' : 'Layer2StretchStatsApiResponse',
+        'OneOfnetworking.v4.config.GetLayer2StretchApiResponsedata' : 'GetLayer2StretchApiResponsedata',
         'networking.v4.stats.TrafficMirrorState' : 'TrafficMirrorState',
-        'networking.v4.config.SubnetApiResponse' : 'SubnetApiResponse',
-        'OneOfnetworking.v4.config.Layer2StretchListApiResponsedata' : 'Layer2StretchListApiResponsedata',
         'networking.v4.config.FlowGateway' : 'FlowGateway',
+        'OneOfnetworking.v4.config.ListRoutingPoliciesApiResponsedata' : 'ListRoutingPoliciesApiResponsedata',
         'networking.v4.config.ClusterCapability' : 'ClusterCapability',
         'networking.v4.config.RoutingPolicyRule' : 'RoutingPolicyRule',
         'OneOfnetworking.v4.config.RoutingPolicyMatchConditionprotocol_parameters' : 'RoutingPolicyMatchConditionprotocol_parameters',
         'networking.v4.config.FloatingIpProjection' : 'FloatingIpProjection',
-        'OneOfnetworking.v4.config.FloatingIpApiResponsedata' : 'FloatingIpApiResponsedata',
+        'networking.v4.config.GetUplinkBondApiResponse' : 'GetUplinkBondApiResponse',
+        'networking.v4.config.GetIPFIXExporterApiResponse' : 'GetIPFIXExporterApiResponse',
+        'networking.v4.config.ListSubnetsApiResponse' : 'ListSubnetsApiResponse',
         'networking.v4.config.IPv6Config' : 'IPv6Config'
     }
 
     def __init__(self, configuration=None):
         if configuration is None:
             configuration = Configuration()
         self.configuration = configuration
@@ -496,15 +495,15 @@
         # post parameters
         if post_params or files:
             post_params = self.__prepare_post_parameters(post_params, files)
             post_params = self.__sanitize_for_serialization(post_params)
             post_params = self.__parameters_to_tuples(post_params, collection_formats)
 
         # body
-        if body:
+        if body and 'application/octet-stream' not in header_params['Content-Type']:
             body = self.__sanitize_for_serialization(body)
 
         # request url
         url = config.scheme + '://' + config.host + ':' + str(config.port) + resource_path
 
         # perform request and return response
         response_data = self.request(
@@ -533,28 +532,57 @@
                 raise ntnx_networking_py_client.rest.ApiException(http_resp=response_data)
 
         if self.__refresh_cookie:
             self.__update_cookies(response_data)
 
         self.last_response = response_data
         return_data = response_data
-        if _preload_content:
-            # deserialize response data
+
+        # deserialize response data
+        try:
             if response_data.status != 204:
-                return_data = json.loads(response_data.data)
-                return_data = self.__add_header_to_reserved(response_data, return_data, "ETag")
-                if response_type is None and "$objectType" in return_data:
-                    response_type = return_data.get("$objectType")
-                if PY2:
-                    inner_response_type = response_type.encode('utf-8', 'ignore')
+                # Download a file
+                if response_data.getheader(name='Content-Type') == 'application/octet-stream':
+                    download_path = self.__deserialize_file(response_data)
+                    download_path = Path(download_path)
+
+                    # convert response type to class
+                    response_type = self.__getattr(response_type)
+                    data = {"path": download_path}
+                    data["$objectType"] = "pathlib.Path"
+                    data["$reserved"] = {}
+                    data["$unknownFields"] = {}
+                    return response_type(data=data)
                 else:
-                    inner_response_type = response_type
-                return self.deserialize(return_data, inner_response_type)
+                    if _preload_content:
+                        # Read the data from original urllib3 response
+                        response_data.data = response_data.urllib3_response.data
+                        # In the python 3, the response.data is bytes which needs to be decoded to string.
+                        if six.PY3:
+                            response_data.data = response_data.data.decode('utf-8')
+
+                        return_data = json.loads(response_data.data)
+                        return_data = self.__add_header_to_reserved(response_data, return_data, "ETag")
+                        if response_type is None and "$objectType" in return_data:
+                            response_type = return_data.get("$objectType")
+                        if PY2:
+                            inner_response_type = response_type.encode('utf-8', 'ignore')
+                        else:
+                            inner_response_type = response_type
+
+                        return self.deserialize(return_data, inner_response_type)
+                    else:
+                        return_data = response_data
             else:
-                return_data = None
+                if _preload_content:
+                    return_data = None
+        finally:
+            if 'Content-Type' in header_params and header_params['Content-Type'] == 'application/octet-stream':
+                response_data.urllib3_response.drain_conn()
+                response_data.urllib3_response.release_conn()
         if _return_http_data_only:
             return (return_data)
         else:
             return (return_data, response_data.status,
                     response_data.getheaders())
     def __sanitize_for_serialization(self, obj):
         """Builds a JSON POST object.
@@ -629,14 +657,17 @@
         :type discriminator: :class:`str`
         :return: Deserialized object
         :rtype: :class:`object`
         """  # noqa: E501
         if data is None:
             return None
         if type(klass) == str:
+            if klass == 'pathlib.Path':
+                data['path'] = Path(data['path'])
+                return data
             if klass.startswith('list['):
                 sub_kls = re.match(r'list\[(.*)\]', klass).group(1)
                 return [self.deserialize(sub_data, sub_kls)
                         for sub_data in data]
             if klass.startswith('dict('):
                 sub_kls = re.match(r'dict\(([^,]*), (.*)\)', klass).group(2)
                 return {str(k): self.deserialize(v, sub_kls)
@@ -848,19 +879,17 @@
         :type accepts: :class:`list`
         :return: If application/json is available, returns that.
             Otherwise, returns a comma separated string of all the provided Accept types
         """  # noqa: E501
 
         if not accepts:
             return
+
         accepts = [x.lower() for x in accepts]
-        if 'application/json' in accepts:
-            return 'application/json'
-        else:
-            return ', '.join(accepts)
+        return ', '.join(accepts)
 
     def _select_header_content_type(self, content_types):
         """Returns `Content-Type` based on an array of content_types provided.
 
         :param content_types: List of content-types
         :type content_types: :class:`list`
         :return: Content-Type (e.g. application/json)
@@ -945,24 +974,32 @@
 
         Saves response body into a file in a temporary folder, using the filename from the `Content-Disposition` header if provided.
 
         :param response: :class:`~ntnx_networking_py_client.rest.RESTResponse`
         :return: File path
         """
 
-        fd, path = tempfile.mkstemp(dir=self.configuration.temp_folder_path)
-        os.close(fd)
-        os.remove(path)
+        path = ''
         content_disposition = response.getheader("Content-Disposition")
         if content_disposition:
-            filename = re.search(r'filename=[\'"]?([^\'"\s]+)[\'"]?',
-                                 content_disposition).group(1)
-            path = os.path.join(os.path.dirname(path), filename)
+            filename = re.search(r'filename=[\'"]?([^\'"*]+)[\'"]?', content_disposition).group(1)
+            path = os.path.join(self.configuration.download_directory, filename)
+        else:
+            fd, path = tempfile.mkstemp(dir=self.configuration.download_directory)
+            os.close(fd)
+
+        path_tup = os.path.splitext(path)
+        timestring = datetime.datetime.now().strftime("%Y-%m-%dT%H:%M:%S.%f")[:-3]
+        path = "%s_%s%s" % (path_tup[0], timestring, path_tup[1])
+        logger.info('Writing response data to file at %s' % path)
         with open(path, "wb") as f:
-            f.write(response.data)
+            if isinstance(response.urllib3_response, urllib3.response.HTTPResponse):
+                for chunk in response.urllib3_response.stream(self.configuration.download_chunk_size):
+                    f.write(chunk)
+
         return path
 
     def __deserialize_primitive(self, data, klass):
         """Deserializes string to primitive type.
 
         :param data:
         :type data: :class:`str`
@@ -1067,15 +1104,16 @@
                                 if type(value_item) is not dict:
                                     one_of_value.append(self.deserialize(value_item, type(value_item)))
                                 else:
                                     one_of_value.append(self.deserialize(value_item, self.__getattr(value_item['$objectType'])))
                         elif type(value) is dict:
                             # OneOf of dict type can be a single response object or a map of primitive types
                             if '$objectType' in value:
-                                one_of_value = self.deserialize(value, self.__getattr(value['$objectType']))
+                                one_of_value = self.deserialize(value, value['$objectType']
+                                    if value['$objectType'] == 'pathlib.Path' else self.__getattr(value['$objectType']))
                             else:
                                 one_of_value = {}
                                 for item_key, item_value in six.iteritems(value):
                                     one_of_value[item_key] = self.deserialize(item_value, type(item_value))
                         else:
                             one_of_value = value
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/api_response.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/api_response.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import re  # noqa: F401
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/configuration.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/configuration.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,21 +3,22 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 from __future__ import absolute_import
 
+import os
 import copy
 import logging
 from logging.handlers import TimedRotatingFileHandler
 import multiprocessing
 import sys
 import urllib3
 
@@ -68,14 +69,18 @@
     :type backoff_factor: :class:`float`
     :param logger_file: (:attr:`logger_file`) File location to which logs are written to
     :type logger_file: :class:`str`
     :param connect_timeout: (:attr:`connect_timeout`) Connection timeout in milliseconds for all operations (**Default** 30000)
     :type connect_timeout: :class:`int`
     :param read_timeout: (:attr:`read_timeout`) Read timeout in milliseconds for all operations (**Default** 30000)
     :type read_timeout: :class:`int`
+    :param download_directory: (:attr:`download_directory`) Directory location on local for files to download
+    :type download_directory: :class:`str`
+    :param download_chunk_size: (:attr:`download_chunk_size`) Chunk size in bytes for files to download (**Default** 8*1024 bytes)
+    :type download_chunk_size: :class:`int`
     """  # noqa: E501
 
     def __init__(self):
 
         """Constructor"""
         self.__scheme = "https"
 
@@ -87,18 +92,20 @@
 
         # Maximum number of allowed retries for a HTTP call
         self.__max_retry_attempts = 5
 
         # Backoff factor by which the retry request is delayed with specific number of seconds.
         self.__backoff_factor = 3
 
-        self.__user_agent = 'Nutanix-ntnx_networking_py_client/4.0.1b1'
+        self.__user_agent = 'Nutanix-ntnx_networking_py_client/4.0.2b1'
 
-        # Temp file folder for downloading files
-        self.temp_folder_path = None
+        # Directory path for downloading files
+        self.__download_directory = os.path.abspath(os.getcwd())
+        # Chunk size for downloading files
+        self.__download_chunk_size = 8*1024
 
         # Authentication Settings
         # HTTP Basic Auth
         self.__username = None
         self.__password = None
 
         # API Key authentication (NOTE: SDK currently supports basic auth only)
@@ -191,14 +198,38 @@
         return self.__port
 
     @port.setter
     def port(self, value):
         self.__port = value
 
     @property
+    def download_directory(self):
+        """Directory path for downloading files (**Default** current directory).
+
+        :type: :class:`str`
+        """
+        return self.__download_directory
+
+    @download_directory.setter
+    def download_directory(self, value):
+        self.__download_directory = value
+
+    @property
+    def download_chunk_size(self):
+        """Chunk size for downloading files (**Default** 8*1024 bytes).
+
+        :type: :class:`int`
+        """
+        return self.__download_chunk_size
+
+    @download_chunk_size.setter
+    def download_chunk_size(self, value):
+        self.__download_chunk_size = value
+
+    @property
     def max_retry_attempts(self):
         """Maximum allowed retry attempts for a HTTP call in case of response status codes [408, 503, 504] (**Default** 5).
 
         :type: :class:`int`
         """
         return self.__max_retry_attempts
 
@@ -376,23 +407,19 @@
     @debug.setter
     def debug(self, value):
         self.__debug = value
         if self.__debug:
             # if debug status is True, turn on debug logging
             for _, logger in six.iteritems(self.logger):
                 logger.setLevel(logging.DEBUG)
-            # turn on httplib debug
-            httplib.HTTPConnection.debuglevel = 1
         else:
             # if debug status is False, turn off debug logging,
             # setting log level to default `logging.INFO`
             for _, logger in six.iteritems(self.logger):
                 logger.setLevel(logging.INFO)
-            # turn off httplib debug
-            httplib.HTTPConnection.debuglevel = 0
 
     @property
     def logger_format(self):
         """The log format for file or stream log handler.
 
         :type: :class:`str`
         """
@@ -487,10 +514,10 @@
 
     def to_debug_report(self):
         """Prints the information about current OS, Python, API and SDK versions for debugging purposes
         """
         return "Python SDK Debug Report:\n"\
                "OS: {env}\n"\
                "Python Version: {pyversion}\n"\
-               "Version of the API: 4.0.1-beta-1\n"\
-               "SDK Package Version: 4.0.1b1".\
+               "Version of the API: 4.0.2-beta-1\n"\
+               "SDK Package Version: 4.0.2b1".\
                format(env=sys.platform, pyversion=sys.version)
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfcommon/v1/config/KVPairvalue.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfcommon/v1/config/KVPairvalue.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
 class KVPairvalue(object):
 
     """
 
 
     """
@@ -57,33 +58,33 @@
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'OneOfcommon.v1.config.KVPairvalue'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -130,28 +131,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/AncConfigApiResponsedata.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/GetLayer2StretchApiResponsedata.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class AncConfigApiResponsedata(object):
+class GetLayer2StretchApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'networking.v4.config.Anc': 'networking.v4.config.Anc',
+        'networking.v4.config.Layer2Stretch': 'networking.v4.config.Layer2Stretch',
         'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfnetworking.v4.config.AncConfigApiResponsedata'
+        return 'OneOfnetworking.v4.config.GetLayer2StretchApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in AncConfigApiResponsedata.discriminator_value_class_map.values():
-            return list(AncConfigApiResponsedata.discriminator_value_class_map.keys())[list(AncConfigApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in GetLayer2StretchApiResponsedata.discriminator_value_class_map.values():
+            return list(GetLayer2StretchApiResponsedata.discriminator_value_class_map.keys())[list(GetLayer2StretchApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(AncConfigApiResponsedata, dict):
+        if issubclass(GetLayer2StretchApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, AncConfigApiResponsedata):
+        if not isinstance(other, GetLayer2StretchApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/BgpSessionApiResponsedata.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/GetFloatingIpApiResponsedata.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class BgpSessionApiResponsedata(object):
+class GetFloatingIpApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'networking.v4.config.BgpSession': 'networking.v4.config.BgpSession',
+        'networking.v4.config.FloatingIp': 'networking.v4.config.FloatingIp',
         'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfnetworking.v4.config.BgpSessionApiResponsedata'
+        return 'OneOfnetworking.v4.config.GetFloatingIpApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in BgpSessionApiResponsedata.discriminator_value_class_map.values():
-            return list(BgpSessionApiResponsedata.discriminator_value_class_map.keys())[list(BgpSessionApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in GetFloatingIpApiResponsedata.discriminator_value_class_map.values():
+            return list(GetFloatingIpApiResponsedata.discriminator_value_class_map.keys())[list(GetFloatingIpApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(BgpSessionApiResponsedata, dict):
+        if issubclass(GetFloatingIpApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, BgpSessionApiResponsedata):
+        if not isinstance(other, GetFloatingIpApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/BgpSessionListApiResponsedata.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListRoutingPoliciesApiResponsedata.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class BgpSessionListApiResponsedata(object):
+class ListRoutingPoliciesApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,49 +40,49 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'List<networking.v4.config.BgpSession>': 'list[networking.v4.config.BgpSession]',
+        'List<networking.v4.config.RoutingPolicy>': 'list[networking.v4.config.RoutingPolicy]',
         'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse',
-        'List<networking.v4.config.BgpSessionProjection>': 'list[networking.v4.config.BgpSessionProjection]'
+        'List<networking.v4.config.RoutingPolicyProjection>': 'list[networking.v4.config.RoutingPolicyProjection]'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfnetworking.v4.config.BgpSessionListApiResponsedata'
+        return 'OneOfnetworking.v4.config.ListRoutingPoliciesApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -115,50 +116,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in BgpSessionListApiResponsedata.discriminator_value_class_map.values():
-            return list(BgpSessionListApiResponsedata.discriminator_value_class_map.keys())[list(BgpSessionListApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in ListRoutingPoliciesApiResponsedata.discriminator_value_class_map.values():
+            return list(ListRoutingPoliciesApiResponsedata.discriminator_value_class_map.keys())[list(ListRoutingPoliciesApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(BgpSessionListApiResponsedata, dict):
+        if issubclass(ListRoutingPoliciesApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -170,15 +176,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, BgpSessionListApiResponsedata):
+        if not isinstance(other, ListRoutingPoliciesApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/CloudNetworkApiResponsedata.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListLayer2StretchesApiResponsedata.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class CloudNetworkApiResponsedata(object):
+class ListLayer2StretchesApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'networking.v4.config.CloudNetwork': 'networking.v4.config.CloudNetwork',
+        'List<networking.v4.config.Layer2Stretch>': 'list[networking.v4.config.Layer2Stretch]',
         'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfnetworking.v4.config.CloudNetworkApiResponsedata'
+        return 'OneOfnetworking.v4.config.ListLayer2StretchesApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in CloudNetworkApiResponsedata.discriminator_value_class_map.values():
-            return list(CloudNetworkApiResponsedata.discriminator_value_class_map.keys())[list(CloudNetworkApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in ListLayer2StretchesApiResponsedata.discriminator_value_class_map.values():
+            return list(ListLayer2StretchesApiResponsedata.discriminator_value_class_map.keys())[list(ListLayer2StretchesApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(CloudNetworkApiResponsedata, dict):
+        if issubclass(ListLayer2StretchesApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, CloudNetworkApiResponsedata):
+        if not isinstance(other, ListLayer2StretchesApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/CloudNetworkListApiResponsedata.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/GetRoutingPolicyApiResponsedata.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class CloudNetworkListApiResponsedata(object):
+class GetRoutingPolicyApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'List<networking.v4.config.CloudNetwork>': 'list[networking.v4.config.CloudNetwork]',
+        'networking.v4.config.RoutingPolicy': 'networking.v4.config.RoutingPolicy',
         'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfnetworking.v4.config.CloudNetworkListApiResponsedata'
+        return 'OneOfnetworking.v4.config.GetRoutingPolicyApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in CloudNetworkListApiResponsedata.discriminator_value_class_map.values():
-            return list(CloudNetworkListApiResponsedata.discriminator_value_class_map.keys())[list(CloudNetworkListApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in GetRoutingPolicyApiResponsedata.discriminator_value_class_map.values():
+            return list(GetRoutingPolicyApiResponsedata.discriminator_value_class_map.keys())[list(GetRoutingPolicyApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(CloudNetworkListApiResponsedata, dict):
+        if issubclass(GetRoutingPolicyApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, CloudNetworkListApiResponsedata):
+        if not isinstance(other, GetRoutingPolicyApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/ClusterCapabilityApiResponsedata.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/GetVpcApiResponsedata.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class ClusterCapabilityApiResponsedata(object):
+class GetVpcApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'List<networking.v4.config.ClusterCapability>': 'list[networking.v4.config.ClusterCapability]',
+        'networking.v4.config.Vpc': 'networking.v4.config.Vpc',
         'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfnetworking.v4.config.ClusterCapabilityApiResponsedata'
+        return 'OneOfnetworking.v4.config.GetVpcApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in ClusterCapabilityApiResponsedata.discriminator_value_class_map.values():
-            return list(ClusterCapabilityApiResponsedata.discriminator_value_class_map.keys())[list(ClusterCapabilityApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in GetVpcApiResponsedata.discriminator_value_class_map.values():
+            return list(GetVpcApiResponsedata.discriminator_value_class_map.keys())[list(GetVpcApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ClusterCapabilityApiResponsedata, dict):
+        if issubclass(GetVpcApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ClusterCapabilityApiResponsedata):
+        if not isinstance(other, GetVpcApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/ClusterFlowStatusApiResponsedata.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/stats/TaskReferenceApiResponsedata.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class ClusterFlowStatusApiResponsedata(object):
+class TaskReferenceApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'networking.v4.config.ClusterFlowStatus': 'networking.v4.config.ClusterFlowStatus',
+        'prism.v4.config.TaskReference': 'prism.v4.config.TaskReference',
         'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfnetworking.v4.config.ClusterFlowStatusApiResponsedata'
+        return 'OneOfnetworking.v4.stats.TaskReferenceApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in ClusterFlowStatusApiResponsedata.discriminator_value_class_map.values():
-            return list(ClusterFlowStatusApiResponsedata.discriminator_value_class_map.keys())[list(ClusterFlowStatusApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in TaskReferenceApiResponsedata.discriminator_value_class_map.values():
+            return list(TaskReferenceApiResponsedata.discriminator_value_class_map.keys())[list(TaskReferenceApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ClusterFlowStatusApiResponsedata, dict):
+        if issubclass(TaskReferenceApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ClusterFlowStatusApiResponsedata):
+        if not isinstance(other, TaskReferenceApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/FloatingIpApiResponsedata.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListIPFIXExportersApiResponsedata.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class FloatingIpApiResponsedata(object):
+class ListIPFIXExportersApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'networking.v4.config.FloatingIp': 'networking.v4.config.FloatingIp',
+        'List<networking.v4.config.IPFIXExporter>': 'list[networking.v4.config.IPFIXExporter]',
         'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfnetworking.v4.config.FloatingIpApiResponsedata'
+        return 'OneOfnetworking.v4.config.ListIPFIXExportersApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in FloatingIpApiResponsedata.discriminator_value_class_map.values():
-            return list(FloatingIpApiResponsedata.discriminator_value_class_map.keys())[list(FloatingIpApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in ListIPFIXExportersApiResponsedata.discriminator_value_class_map.values():
+            return list(ListIPFIXExportersApiResponsedata.discriminator_value_class_map.keys())[list(ListIPFIXExportersApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(FloatingIpApiResponsedata, dict):
+        if issubclass(ListIPFIXExportersApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, FloatingIpApiResponsedata):
+        if not isinstance(other, ListIPFIXExportersApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/FloatingIpListApiResponsedata.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListVpcVirtualSwitchMappingsApiResponsedata.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class FloatingIpListApiResponsedata(object):
+class ListVpcVirtualSwitchMappingsApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,49 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'List<networking.v4.config.FloatingIp>': 'list[networking.v4.config.FloatingIp]',
-        'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse',
-        'List<networking.v4.config.FloatingIpProjection>': 'list[networking.v4.config.FloatingIpProjection]'
+        'List<networking.v4.config.VpcVirtualSwitchMapping>': 'list[networking.v4.config.VpcVirtualSwitchMapping]',
+        'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfnetworking.v4.config.FloatingIpListApiResponsedata'
+        return 'OneOfnetworking.v4.config.ListVpcVirtualSwitchMappingsApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -115,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in FloatingIpListApiResponsedata.discriminator_value_class_map.values():
-            return list(FloatingIpListApiResponsedata.discriminator_value_class_map.keys())[list(FloatingIpListApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in ListVpcVirtualSwitchMappingsApiResponsedata.discriminator_value_class_map.values():
+            return list(ListVpcVirtualSwitchMappingsApiResponsedata.discriminator_value_class_map.keys())[list(ListVpcVirtualSwitchMappingsApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(FloatingIpListApiResponsedata, dict):
+        if issubclass(ListVpcVirtualSwitchMappingsApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -170,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, FloatingIpListApiResponsedata):
+        if not isinstance(other, ListVpcVirtualSwitchMappingsApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/FloatingIpProjectionassociation.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/FloatingIpassociation.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class FloatingIpProjectionassociation(object):
+class FloatingIpassociation(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -52,35 +53,35 @@
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfnetworking.v4.config.FloatingIpProjectionassociation'
+        return 'OneOfnetworking.v4.config.FloatingIpassociation'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in FloatingIpProjectionassociation.discriminator_value_class_map.values():
-            return list(FloatingIpProjectionassociation.discriminator_value_class_map.keys())[list(FloatingIpProjectionassociation.discriminator_value_class_map.values()).index(disc)]
+        if disc in FloatingIpassociation.discriminator_value_class_map.values():
+            return list(FloatingIpassociation.discriminator_value_class_map.keys())[list(FloatingIpassociation.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(FloatingIpProjectionassociation, dict):
+        if issubclass(FloatingIpassociation, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, FloatingIpProjectionassociation):
+        if not isinstance(other, FloatingIpassociation):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/FloatingIpassociation.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListNetworkControllersApiResponsedata.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class FloatingIpassociation(object):
+class ListNetworkControllersApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'networking.v4.config.VmNicAssociation': 'networking.v4.config.VmNicAssociation',
-        'networking.v4.config.PrivateIpAssociation': 'networking.v4.config.PrivateIpAssociation'
+        'List<networking.v4.config.NetworkController>': 'list[networking.v4.config.NetworkController]',
+        'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse'
     }
 
-    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$associationItemDiscriminator'
+    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfnetworking.v4.config.FloatingIpassociation'
+        return 'OneOfnetworking.v4.config.ListNetworkControllersApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in FloatingIpassociation.discriminator_value_class_map.values():
-            return list(FloatingIpassociation.discriminator_value_class_map.keys())[list(FloatingIpassociation.discriminator_value_class_map.values()).index(disc)]
+        if disc in ListNetworkControllersApiResponsedata.discriminator_value_class_map.values():
+            return list(ListNetworkControllersApiResponsedata.discriminator_value_class_map.keys())[list(ListNetworkControllersApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(FloatingIpassociation, dict):
+        if issubclass(ListNetworkControllersApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, FloatingIpassociation):
+        if not isinstance(other, ListNetworkControllersApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/FlowGatewayApiResponsedata.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListVpnVendorConfigsApiResponsedata.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class FlowGatewayApiResponsedata(object):
+class ListVpnVendorConfigsApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'networking.v4.config.FlowGateway': 'networking.v4.config.FlowGateway',
+        'List<networking.v4.config.VpnAppliance>': 'list[networking.v4.config.VpnAppliance]',
         'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfnetworking.v4.config.FlowGatewayApiResponsedata'
+        return 'OneOfnetworking.v4.config.ListVpnVendorConfigsApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in FlowGatewayApiResponsedata.discriminator_value_class_map.values():
-            return list(FlowGatewayApiResponsedata.discriminator_value_class_map.keys())[list(FlowGatewayApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in ListVpnVendorConfigsApiResponsedata.discriminator_value_class_map.values():
+            return list(ListVpnVendorConfigsApiResponsedata.discriminator_value_class_map.keys())[list(ListVpnVendorConfigsApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(FlowGatewayApiResponsedata, dict):
+        if issubclass(ListVpnVendorConfigsApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, FlowGatewayApiResponsedata):
+        if not isinstance(other, ListVpnVendorConfigsApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/FlowGatewayKeepAliveApiResponsedata.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/GetVirtualSwitchApiResponsedata.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class FlowGatewayKeepAliveApiResponsedata(object):
+class GetVirtualSwitchApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'networking.v4.config.FlowGatewayKeepAlive': 'networking.v4.config.FlowGatewayKeepAlive',
+        'networking.v4.config.VirtualSwitch': 'networking.v4.config.VirtualSwitch',
         'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfnetworking.v4.config.FlowGatewayKeepAliveApiResponsedata'
+        return 'OneOfnetworking.v4.config.GetVirtualSwitchApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in FlowGatewayKeepAliveApiResponsedata.discriminator_value_class_map.values():
-            return list(FlowGatewayKeepAliveApiResponsedata.discriminator_value_class_map.keys())[list(FlowGatewayKeepAliveApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in GetVirtualSwitchApiResponsedata.discriminator_value_class_map.values():
+            return list(GetVirtualSwitchApiResponsedata.discriminator_value_class_map.keys())[list(GetVirtualSwitchApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(FlowGatewayKeepAliveApiResponsedata, dict):
+        if issubclass(GetVirtualSwitchApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, FlowGatewayKeepAliveApiResponsedata):
+        if not isinstance(other, GetVirtualSwitchApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/FlowGatewayListApiResponsedata.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListRouteTablesApiResponsedata.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class FlowGatewayListApiResponsedata(object):
+class ListRouteTablesApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'List<networking.v4.config.FlowGateway>': 'list[networking.v4.config.FlowGateway]',
+        'List<networking.v4.config.RouteTable>': 'list[networking.v4.config.RouteTable]',
         'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfnetworking.v4.config.FlowGatewayListApiResponsedata'
+        return 'OneOfnetworking.v4.config.ListRouteTablesApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in FlowGatewayListApiResponsedata.discriminator_value_class_map.values():
-            return list(FlowGatewayListApiResponsedata.discriminator_value_class_map.keys())[list(FlowGatewayListApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in ListRouteTablesApiResponsedata.discriminator_value_class_map.values():
+            return list(ListRouteTablesApiResponsedata.discriminator_value_class_map.keys())[list(ListRouteTablesApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(FlowGatewayListApiResponsedata, dict):
+        if issubclass(ListRouteTablesApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, FlowGatewayListApiResponsedata):
+        if not isinstance(other, ListRouteTablesApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/GatewayApiResponsedata.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/error/ErrorResponseerror.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class GatewayApiResponsedata(object):
+class ErrorResponseerror(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'networking.v4.config.Gateway': 'networking.v4.config.Gateway',
-        'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse'
+        'List<networking.v4.error.AppMessage>': 'list[networking.v4.error.AppMessage]',
+        'networking.v4.error.SchemaValidationError': 'networking.v4.error.SchemaValidationError'
     }
 
-    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
+    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$errorItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfnetworking.v4.config.GatewayApiResponsedata'
+        return 'OneOfnetworking.v4.error.ErrorResponseerror'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in GatewayApiResponsedata.discriminator_value_class_map.values():
-            return list(GatewayApiResponsedata.discriminator_value_class_map.keys())[list(GatewayApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in ErrorResponseerror.discriminator_value_class_map.values():
+            return list(ErrorResponseerror.discriminator_value_class_map.keys())[list(ErrorResponseerror.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(GatewayApiResponsedata, dict):
+        if issubclass(ErrorResponseerror, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, GatewayApiResponsedata):
+        if not isinstance(other, ErrorResponseerror):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/GatewayListApiResponsedata.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListLayer2StretchRelatedEntitiesApiResponsedata.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class GatewayListApiResponsedata(object):
+class ListLayer2StretchRelatedEntitiesApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,49 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'List<networking.v4.config.Gateway>': 'list[networking.v4.config.Gateway]',
-        'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse',
-        'List<networking.v4.config.GatewayProjection>': 'list[networking.v4.config.GatewayProjection]'
+        'networking.v4.config.Layer2StretchRelatedEntities': 'networking.v4.config.Layer2StretchRelatedEntities',
+        'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfnetworking.v4.config.GatewayListApiResponsedata'
+        return 'OneOfnetworking.v4.config.ListLayer2StretchRelatedEntitiesApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -115,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in GatewayListApiResponsedata.discriminator_value_class_map.values():
-            return list(GatewayListApiResponsedata.discriminator_value_class_map.keys())[list(GatewayListApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in ListLayer2StretchRelatedEntitiesApiResponsedata.discriminator_value_class_map.values():
+            return list(ListLayer2StretchRelatedEntitiesApiResponsedata.discriminator_value_class_map.keys())[list(ListLayer2StretchRelatedEntitiesApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(GatewayListApiResponsedata, dict):
+        if issubclass(ListLayer2StretchRelatedEntitiesApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -170,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, GatewayListApiResponsedata):
+        if not isinstance(other, ListLayer2StretchRelatedEntitiesApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/GatewayProjectionservices.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/GatewayProjectionservices.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
 class GatewayProjectionservices(object):
 
     """
 
 
     """
@@ -54,33 +55,33 @@
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'OneOfnetworking.v4.config.GatewayProjectionservices'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -127,28 +128,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/Gatewayservices.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/GetTrafficMirrorApiResponsedata.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class Gatewayservices(object):
+class GetTrafficMirrorApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'networking.v4.config.LocalNetworkServices': 'networking.v4.config.LocalNetworkServices',
-        'networking.v4.config.RemoteNetworkServices': 'networking.v4.config.RemoteNetworkServices'
+        'networking.v4.config.TrafficMirror': 'networking.v4.config.TrafficMirror',
+        'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse'
     }
 
-    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$servicesItemDiscriminator'
+    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfnetworking.v4.config.Gatewayservices'
+        return 'OneOfnetworking.v4.config.GetTrafficMirrorApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in Gatewayservices.discriminator_value_class_map.values():
-            return list(Gatewayservices.discriminator_value_class_map.keys())[list(Gatewayservices.discriminator_value_class_map.values()).index(disc)]
+        if disc in GetTrafficMirrorApiResponsedata.discriminator_value_class_map.values():
+            return list(GetTrafficMirrorApiResponsedata.discriminator_value_class_map.keys())[list(GetTrafficMirrorApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(Gatewayservices, dict):
+        if issubclass(GetTrafficMirrorApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, Gatewayservices):
+        if not isinstance(other, GetTrafficMirrorApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/IPFIXExporterApiResponsedata.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/GetSubnetApiResponsedata.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class IPFIXExporterApiResponsedata(object):
+class GetSubnetApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'networking.v4.config.IPFIXExporter': 'networking.v4.config.IPFIXExporter',
+        'networking.v4.config.Subnet': 'networking.v4.config.Subnet',
         'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfnetworking.v4.config.IPFIXExporterApiResponsedata'
+        return 'OneOfnetworking.v4.config.GetSubnetApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in IPFIXExporterApiResponsedata.discriminator_value_class_map.values():
-            return list(IPFIXExporterApiResponsedata.discriminator_value_class_map.keys())[list(IPFIXExporterApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in GetSubnetApiResponsedata.discriminator_value_class_map.values():
+            return list(GetSubnetApiResponsedata.discriminator_value_class_map.keys())[list(GetSubnetApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(IPFIXExporterApiResponsedata, dict):
+        if issubclass(GetSubnetApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, IPFIXExporterApiResponsedata):
+        if not isinstance(other, GetSubnetApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/IPFIXExporterListApiResponsedata.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListNodeSchedulableStatusesApiResponsedata.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class IPFIXExporterListApiResponsedata(object):
+class ListNodeSchedulableStatusesApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,49 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'List<networking.v4.config.IPFIXExporter>': 'list[networking.v4.config.IPFIXExporter]',
-        'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse'
+        'List<networking.v4.config.NodeSchedulableStatus>': 'list[networking.v4.config.NodeSchedulableStatus]',
+        'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse',
+        'List<networking.v4.config.NodeSchedulableStatusProjection>': 'list[networking.v4.config.NodeSchedulableStatusProjection]'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfnetworking.v4.config.IPFIXExporterListApiResponsedata'
+        return 'OneOfnetworking.v4.config.ListNodeSchedulableStatusesApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +116,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in IPFIXExporterListApiResponsedata.discriminator_value_class_map.values():
-            return list(IPFIXExporterListApiResponsedata.discriminator_value_class_map.keys())[list(IPFIXExporterListApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in ListNodeSchedulableStatusesApiResponsedata.discriminator_value_class_map.values():
+            return list(ListNodeSchedulableStatusesApiResponsedata.discriminator_value_class_map.keys())[list(ListNodeSchedulableStatusesApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(IPFIXExporterListApiResponsedata, dict):
+        if issubclass(ListNodeSchedulableStatusesApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +176,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, IPFIXExporterListApiResponsedata):
+        if not isinstance(other, ListNodeSchedulableStatusesApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/Layer2StretchApiResponsedata.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/stats/GetLayer2StretchStatsApiResponsedata.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class Layer2StretchApiResponsedata(object):
+class GetLayer2StretchStatsApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'networking.v4.config.Layer2Stretch': 'networking.v4.config.Layer2Stretch',
+        'networking.v4.stats.Layer2StretchStats': 'networking.v4.stats.Layer2StretchStats',
         'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfnetworking.v4.config.Layer2StretchApiResponsedata'
+        return 'OneOfnetworking.v4.stats.GetLayer2StretchStatsApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in Layer2StretchApiResponsedata.discriminator_value_class_map.values():
-            return list(Layer2StretchApiResponsedata.discriminator_value_class_map.keys())[list(Layer2StretchApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in GetLayer2StretchStatsApiResponsedata.discriminator_value_class_map.values():
+            return list(GetLayer2StretchStatsApiResponsedata.discriminator_value_class_map.keys())[list(GetLayer2StretchStatsApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(Layer2StretchApiResponsedata, dict):
+        if issubclass(GetLayer2StretchStatsApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, Layer2StretchApiResponsedata):
+        if not isinstance(other, GetLayer2StretchStatsApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/Layer2StretchListApiResponsedata.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListVpcsApiResponsedata.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class Layer2StretchListApiResponsedata(object):
+class ListVpcsApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,49 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'List<networking.v4.config.Layer2Stretch>': 'list[networking.v4.config.Layer2Stretch]',
-        'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse'
+        'List<networking.v4.config.Vpc>': 'list[networking.v4.config.Vpc]',
+        'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse',
+        'List<networking.v4.config.VpcProjection>': 'list[networking.v4.config.VpcProjection]'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfnetworking.v4.config.Layer2StretchListApiResponsedata'
+        return 'OneOfnetworking.v4.config.ListVpcsApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +116,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in Layer2StretchListApiResponsedata.discriminator_value_class_map.values():
-            return list(Layer2StretchListApiResponsedata.discriminator_value_class_map.keys())[list(Layer2StretchListApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in ListVpcsApiResponsedata.discriminator_value_class_map.values():
+            return list(ListVpcsApiResponsedata.discriminator_value_class_map.keys())[list(ListVpcsApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(Layer2StretchListApiResponsedata, dict):
+        if issubclass(ListVpcsApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +176,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, Layer2StretchListApiResponsedata):
+        if not isinstance(other, ListVpcsApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/Layer2StretchRelatedEntitiesApiResponsedata.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/stats/GetVpcNsStatsApiResponsedata.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class Layer2StretchRelatedEntitiesApiResponsedata(object):
+class GetVpcNsStatsApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'networking.v4.config.Layer2StretchRelatedEntities': 'networking.v4.config.Layer2StretchRelatedEntities',
+        'networking.v4.stats.VpcNsStats': 'networking.v4.stats.VpcNsStats',
         'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfnetworking.v4.config.Layer2StretchRelatedEntitiesApiResponsedata'
+        return 'OneOfnetworking.v4.stats.GetVpcNsStatsApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in Layer2StretchRelatedEntitiesApiResponsedata.discriminator_value_class_map.values():
-            return list(Layer2StretchRelatedEntitiesApiResponsedata.discriminator_value_class_map.keys())[list(Layer2StretchRelatedEntitiesApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in GetVpcNsStatsApiResponsedata.discriminator_value_class_map.values():
+            return list(GetVpcNsStatsApiResponsedata.discriminator_value_class_map.keys())[list(GetVpcNsStatsApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(Layer2StretchRelatedEntitiesApiResponsedata, dict):
+        if issubclass(GetVpcNsStatsApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, Layer2StretchRelatedEntitiesApiResponsedata):
+        if not isinstance(other, GetVpcNsStatsApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/NetworkCloudConfigApiResponsedata.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListSubnetsApiResponsedata.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class NetworkCloudConfigApiResponsedata(object):
+class ListSubnetsApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,49 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'networking.v4.config.NetworkCloudConfig': 'networking.v4.config.NetworkCloudConfig',
-        'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse'
+        'List<networking.v4.config.Subnet>': 'list[networking.v4.config.Subnet]',
+        'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse',
+        'List<networking.v4.config.SubnetProjection>': 'list[networking.v4.config.SubnetProjection]'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfnetworking.v4.config.NetworkCloudConfigApiResponsedata'
+        return 'OneOfnetworking.v4.config.ListSubnetsApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +116,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in NetworkCloudConfigApiResponsedata.discriminator_value_class_map.values():
-            return list(NetworkCloudConfigApiResponsedata.discriminator_value_class_map.keys())[list(NetworkCloudConfigApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in ListSubnetsApiResponsedata.discriminator_value_class_map.values():
+            return list(ListSubnetsApiResponsedata.discriminator_value_class_map.keys())[list(ListSubnetsApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(NetworkCloudConfigApiResponsedata, dict):
+        if issubclass(ListSubnetsApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +176,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, NetworkCloudConfigApiResponsedata):
+        if not isinstance(other, ListSubnetsApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/NetworkCloudConfigListApiResponsedata.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/GetUplinkBondApiResponsedata.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class NetworkCloudConfigListApiResponsedata(object):
+class GetUplinkBondApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'List<networking.v4.config.NetworkCloudConfig>': 'list[networking.v4.config.NetworkCloudConfig]',
+        'networking.v4.config.UplinkBond': 'networking.v4.config.UplinkBond',
         'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfnetworking.v4.config.NetworkCloudConfigListApiResponsedata'
+        return 'OneOfnetworking.v4.config.GetUplinkBondApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in NetworkCloudConfigListApiResponsedata.discriminator_value_class_map.values():
-            return list(NetworkCloudConfigListApiResponsedata.discriminator_value_class_map.keys())[list(NetworkCloudConfigListApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in GetUplinkBondApiResponsedata.discriminator_value_class_map.values():
+            return list(GetUplinkBondApiResponsedata.discriminator_value_class_map.keys())[list(GetUplinkBondApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(NetworkCloudConfigListApiResponsedata, dict):
+        if issubclass(GetUplinkBondApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, NetworkCloudConfigListApiResponsedata):
+        if not isinstance(other, GetUplinkBondApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/NetworkControllerApiResponsedata.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/GetIPFIXExporterApiResponsedata.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class NetworkControllerApiResponsedata(object):
+class GetIPFIXExporterApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'networking.v4.config.NetworkController': 'networking.v4.config.NetworkController',
+        'networking.v4.config.IPFIXExporter': 'networking.v4.config.IPFIXExporter',
         'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfnetworking.v4.config.NetworkControllerApiResponsedata'
+        return 'OneOfnetworking.v4.config.GetIPFIXExporterApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in NetworkControllerApiResponsedata.discriminator_value_class_map.values():
-            return list(NetworkControllerApiResponsedata.discriminator_value_class_map.keys())[list(NetworkControllerApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in GetIPFIXExporterApiResponsedata.discriminator_value_class_map.values():
+            return list(GetIPFIXExporterApiResponsedata.discriminator_value_class_map.keys())[list(GetIPFIXExporterApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(NetworkControllerApiResponsedata, dict):
+        if issubclass(GetIPFIXExporterApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, NetworkControllerApiResponsedata):
+        if not isinstance(other, GetIPFIXExporterApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/NetworkControllerListApiResponsedata.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/GetNetworkControllerApiResponsedata.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class NetworkControllerListApiResponsedata(object):
+class GetNetworkControllerApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'List<networking.v4.config.NetworkController>': 'list[networking.v4.config.NetworkController]',
+        'networking.v4.config.NetworkController': 'networking.v4.config.NetworkController',
         'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfnetworking.v4.config.NetworkControllerListApiResponsedata'
+        return 'OneOfnetworking.v4.config.GetNetworkControllerApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in NetworkControllerListApiResponsedata.discriminator_value_class_map.values():
-            return list(NetworkControllerListApiResponsedata.discriminator_value_class_map.keys())[list(NetworkControllerListApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in GetNetworkControllerApiResponsedata.discriminator_value_class_map.values():
+            return list(GetNetworkControllerApiResponsedata.discriminator_value_class_map.keys())[list(GetNetworkControllerApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(NetworkControllerListApiResponsedata, dict):
+        if issubclass(GetNetworkControllerApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, NetworkControllerListApiResponsedata):
+        if not isinstance(other, GetNetworkControllerApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/NodeSchedulableStatusApiResponsedata.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListUplinkBondsApiResponsedata.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class NodeSchedulableStatusApiResponsedata(object):
+class ListUplinkBondsApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,49 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'List<networking.v4.config.NodeSchedulableStatus>': 'list[networking.v4.config.NodeSchedulableStatus]',
-        'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse',
-        'List<networking.v4.config.NodeSchedulableStatusProjection>': 'list[networking.v4.config.NodeSchedulableStatusProjection]'
+        'List<networking.v4.config.UplinkBond>': 'list[networking.v4.config.UplinkBond]',
+        'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfnetworking.v4.config.NodeSchedulableStatusApiResponsedata'
+        return 'OneOfnetworking.v4.config.ListUplinkBondsApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -115,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in NodeSchedulableStatusApiResponsedata.discriminator_value_class_map.values():
-            return list(NodeSchedulableStatusApiResponsedata.discriminator_value_class_map.keys())[list(NodeSchedulableStatusApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in ListUplinkBondsApiResponsedata.discriminator_value_class_map.values():
+            return list(ListUplinkBondsApiResponsedata.discriminator_value_class_map.keys())[list(ListUplinkBondsApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(NodeSchedulableStatusApiResponsedata, dict):
+        if issubclass(ListUplinkBondsApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -170,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, NodeSchedulableStatusApiResponsedata):
+        if not isinstance(other, ListUplinkBondsApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/RouteTableApiResponsedata.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/GetVpnConnectionApiResponsedata.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class RouteTableApiResponsedata(object):
+class GetVpnConnectionApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'networking.v4.config.RouteTable': 'networking.v4.config.RouteTable',
+        'networking.v4.config.VpnConnection': 'networking.v4.config.VpnConnection',
         'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfnetworking.v4.config.RouteTableApiResponsedata'
+        return 'OneOfnetworking.v4.config.GetVpnConnectionApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in RouteTableApiResponsedata.discriminator_value_class_map.values():
-            return list(RouteTableApiResponsedata.discriminator_value_class_map.keys())[list(RouteTableApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in GetVpnConnectionApiResponsedata.discriminator_value_class_map.values():
+            return list(GetVpnConnectionApiResponsedata.discriminator_value_class_map.keys())[list(GetVpnConnectionApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(RouteTableApiResponsedata, dict):
+        if issubclass(GetVpnConnectionApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, RouteTableApiResponsedata):
+        if not isinstance(other, GetVpnConnectionApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/RouteTableListApiResponsedata.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/GetRouteTableApiResponsedata.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class RouteTableListApiResponsedata(object):
+class GetRouteTableApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'List<networking.v4.config.RouteTable>': 'list[networking.v4.config.RouteTable]',
+        'networking.v4.config.RouteTable': 'networking.v4.config.RouteTable',
         'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfnetworking.v4.config.RouteTableListApiResponsedata'
+        return 'OneOfnetworking.v4.config.GetRouteTableApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in RouteTableListApiResponsedata.discriminator_value_class_map.values():
-            return list(RouteTableListApiResponsedata.discriminator_value_class_map.keys())[list(RouteTableListApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in GetRouteTableApiResponsedata.discriminator_value_class_map.values():
+            return list(GetRouteTableApiResponsedata.discriminator_value_class_map.keys())[list(GetRouteTableApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(RouteTableListApiResponsedata, dict):
+        if issubclass(GetRouteTableApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, RouteTableListApiResponsedata):
+        if not isinstance(other, GetRouteTableApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/RoutingPolicyApiResponsedata.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/GetBgpSessionApiResponsedata.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class RoutingPolicyApiResponsedata(object):
+class GetBgpSessionApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'networking.v4.config.RoutingPolicy': 'networking.v4.config.RoutingPolicy',
+        'networking.v4.config.BgpSession': 'networking.v4.config.BgpSession',
         'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfnetworking.v4.config.RoutingPolicyApiResponsedata'
+        return 'OneOfnetworking.v4.config.GetBgpSessionApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in RoutingPolicyApiResponsedata.discriminator_value_class_map.values():
-            return list(RoutingPolicyApiResponsedata.discriminator_value_class_map.keys())[list(RoutingPolicyApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in GetBgpSessionApiResponsedata.discriminator_value_class_map.values():
+            return list(GetBgpSessionApiResponsedata.discriminator_value_class_map.keys())[list(GetBgpSessionApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(RoutingPolicyApiResponsedata, dict):
+        if issubclass(GetBgpSessionApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, RoutingPolicyApiResponsedata):
+        if not isinstance(other, GetBgpSessionApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/RoutingPolicyListApiResponsedata.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListVpnConnectionsApiResponsedata.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class RoutingPolicyListApiResponsedata(object):
+class ListVpnConnectionsApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'List<networking.v4.config.RoutingPolicy>': 'list[networking.v4.config.RoutingPolicy]',
+        'List<networking.v4.config.VpnConnection>': 'list[networking.v4.config.VpnConnection]',
         'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfnetworking.v4.config.RoutingPolicyListApiResponsedata'
+        return 'OneOfnetworking.v4.config.ListVpnConnectionsApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in RoutingPolicyListApiResponsedata.discriminator_value_class_map.values():
-            return list(RoutingPolicyListApiResponsedata.discriminator_value_class_map.keys())[list(RoutingPolicyListApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in ListVpnConnectionsApiResponsedata.discriminator_value_class_map.values():
+            return list(ListVpnConnectionsApiResponsedata.discriminator_value_class_map.keys())[list(ListVpnConnectionsApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(RoutingPolicyListApiResponsedata, dict):
+        if issubclass(ListVpnConnectionsApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, RoutingPolicyListApiResponsedata):
+        if not isinstance(other, ListVpnConnectionsApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/RoutingPolicyMatchConditionprotocol_parameters.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/RoutingPolicyMatchConditionprotocol_parameters.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
 class RoutingPolicyMatchConditionprotocol_parameters(object):
 
     """
 
 
     """
@@ -55,33 +56,33 @@
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'OneOfnetworking.v4.config.RoutingPolicyMatchConditionprotocol_parameters'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -128,28 +129,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/SubnetApiResponsedata.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListGatewaysApiResponsedata.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class SubnetApiResponsedata(object):
+class ListGatewaysApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,49 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'networking.v4.config.Subnet': 'networking.v4.config.Subnet',
-        'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse'
+        'List<networking.v4.config.Gateway>': 'list[networking.v4.config.Gateway]',
+        'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse',
+        'List<networking.v4.config.GatewayProjection>': 'list[networking.v4.config.GatewayProjection]'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfnetworking.v4.config.SubnetApiResponsedata'
+        return 'OneOfnetworking.v4.config.ListGatewaysApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +116,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in SubnetApiResponsedata.discriminator_value_class_map.values():
-            return list(SubnetApiResponsedata.discriminator_value_class_map.keys())[list(SubnetApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in ListGatewaysApiResponsedata.discriminator_value_class_map.values():
+            return list(ListGatewaysApiResponsedata.discriminator_value_class_map.keys())[list(ListGatewaysApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(SubnetApiResponsedata, dict):
+        if issubclass(ListGatewaysApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +176,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, SubnetApiResponsedata):
+        if not isinstance(other, ListGatewaysApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/SubnetListApiResponsedata.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListFloatingIpsApiResponsedata.py`

 * *Files 9% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class SubnetListApiResponsedata(object):
+class ListFloatingIpsApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,49 +40,49 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'List<networking.v4.config.Subnet>': 'list[networking.v4.config.Subnet]',
+        'List<networking.v4.config.FloatingIp>': 'list[networking.v4.config.FloatingIp]',
         'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse',
-        'List<networking.v4.config.SubnetProjection>': 'list[networking.v4.config.SubnetProjection]'
+        'List<networking.v4.config.FloatingIpProjection>': 'list[networking.v4.config.FloatingIpProjection]'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfnetworking.v4.config.SubnetListApiResponsedata'
+        return 'OneOfnetworking.v4.config.ListFloatingIpsApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -115,50 +116,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in SubnetListApiResponsedata.discriminator_value_class_map.values():
-            return list(SubnetListApiResponsedata.discriminator_value_class_map.keys())[list(SubnetListApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in ListFloatingIpsApiResponsedata.discriminator_value_class_map.values():
+            return list(ListFloatingIpsApiResponsedata.discriminator_value_class_map.keys())[list(ListFloatingIpsApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(SubnetListApiResponsedata, dict):
+        if issubclass(ListFloatingIpsApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -170,15 +176,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, SubnetListApiResponsedata):
+        if not isinstance(other, ListFloatingIpsApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/TaskReferenceApiResponsedata.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/TaskReferenceApiResponsedata.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
 class TaskReferenceApiResponsedata(object):
 
     """
 
 
     """
@@ -54,33 +55,33 @@
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'OneOfnetworking.v4.config.TaskReferenceApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -127,28 +128,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/TrafficMirrorApiResponsedata.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListTrafficMirrorsApiResponsedata.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class TrafficMirrorApiResponsedata(object):
+class ListTrafficMirrorsApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'networking.v4.config.TrafficMirror': 'networking.v4.config.TrafficMirror',
+        'List<networking.v4.config.TrafficMirror>': 'list[networking.v4.config.TrafficMirror]',
         'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfnetworking.v4.config.TrafficMirrorApiResponsedata'
+        return 'OneOfnetworking.v4.config.ListTrafficMirrorsApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in TrafficMirrorApiResponsedata.discriminator_value_class_map.values():
-            return list(TrafficMirrorApiResponsedata.discriminator_value_class_map.keys())[list(TrafficMirrorApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in ListTrafficMirrorsApiResponsedata.discriminator_value_class_map.values():
+            return list(ListTrafficMirrorsApiResponsedata.discriminator_value_class_map.keys())[list(ListTrafficMirrorsApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(TrafficMirrorApiResponsedata, dict):
+        if issubclass(ListTrafficMirrorsApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, TrafficMirrorApiResponsedata):
+        if not isinstance(other, ListTrafficMirrorsApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/TrafficMirrorListApiResponsedata.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/stats/GetTrafficMirrorStatsApiResponsedata.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class TrafficMirrorListApiResponsedata(object):
+class GetTrafficMirrorStatsApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'List<networking.v4.config.TrafficMirror>': 'list[networking.v4.config.TrafficMirror]',
+        'networking.v4.stats.TrafficMirrorStats': 'networking.v4.stats.TrafficMirrorStats',
         'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfnetworking.v4.config.TrafficMirrorListApiResponsedata'
+        return 'OneOfnetworking.v4.stats.GetTrafficMirrorStatsApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in TrafficMirrorListApiResponsedata.discriminator_value_class_map.values():
-            return list(TrafficMirrorListApiResponsedata.discriminator_value_class_map.keys())[list(TrafficMirrorListApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in GetTrafficMirrorStatsApiResponsedata.discriminator_value_class_map.values():
+            return list(GetTrafficMirrorStatsApiResponsedata.discriminator_value_class_map.keys())[list(GetTrafficMirrorStatsApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(TrafficMirrorListApiResponsedata, dict):
+        if issubclass(GetTrafficMirrorStatsApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, TrafficMirrorListApiResponsedata):
+        if not isinstance(other, GetTrafficMirrorStatsApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/UplinkBondApiResponsedata.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListBgpSessionsApiResponsedata.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class UplinkBondApiResponsedata(object):
+class ListBgpSessionsApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,49 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'networking.v4.config.UplinkBond': 'networking.v4.config.UplinkBond',
-        'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse'
+        'List<networking.v4.config.BgpSession>': 'list[networking.v4.config.BgpSession]',
+        'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse',
+        'List<networking.v4.config.BgpSessionProjection>': 'list[networking.v4.config.BgpSessionProjection]'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfnetworking.v4.config.UplinkBondApiResponsedata'
+        return 'OneOfnetworking.v4.config.ListBgpSessionsApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +116,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in UplinkBondApiResponsedata.discriminator_value_class_map.values():
-            return list(UplinkBondApiResponsedata.discriminator_value_class_map.keys())[list(UplinkBondApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in ListBgpSessionsApiResponsedata.discriminator_value_class_map.values():
+            return list(ListBgpSessionsApiResponsedata.discriminator_value_class_map.keys())[list(ListBgpSessionsApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(UplinkBondApiResponsedata, dict):
+        if issubclass(ListBgpSessionsApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +176,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, UplinkBondApiResponsedata):
+        if not isinstance(other, ListBgpSessionsApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/UplinkBondListApiResponsedata.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/GetGatewayApiResponsedata.py`

 * *Files 11% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class UplinkBondListApiResponsedata(object):
+class GetGatewayApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'List<networking.v4.config.UplinkBond>': 'list[networking.v4.config.UplinkBond]',
+        'networking.v4.config.Gateway': 'networking.v4.config.Gateway',
         'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfnetworking.v4.config.UplinkBondListApiResponsedata'
+        return 'OneOfnetworking.v4.config.GetGatewayApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in UplinkBondListApiResponsedata.discriminator_value_class_map.values():
-            return list(UplinkBondListApiResponsedata.discriminator_value_class_map.keys())[list(UplinkBondListApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in GetGatewayApiResponsedata.discriminator_value_class_map.values():
+            return list(GetGatewayApiResponsedata.discriminator_value_class_map.keys())[list(GetGatewayApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(UplinkBondListApiResponsedata, dict):
+        if issubclass(GetGatewayApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, UplinkBondListApiResponsedata):
+        if not isinstance(other, GetGatewayApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/VirtualSwitchApiResponsedata.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListVirtualSwitchesApiResponsedata.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class VirtualSwitchApiResponsedata(object):
+class ListVirtualSwitchesApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,49 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'networking.v4.config.VirtualSwitch': 'networking.v4.config.VirtualSwitch',
-        'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse'
+        'List<networking.v4.config.VirtualSwitch>': 'list[networking.v4.config.VirtualSwitch]',
+        'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse',
+        'List<networking.v4.config.VirtualSwitchProjection>': 'list[networking.v4.config.VirtualSwitchProjection]'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfnetworking.v4.config.VirtualSwitchApiResponsedata'
+        return 'OneOfnetworking.v4.config.ListVirtualSwitchesApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +116,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in VirtualSwitchApiResponsedata.discriminator_value_class_map.values():
-            return list(VirtualSwitchApiResponsedata.discriminator_value_class_map.keys())[list(VirtualSwitchApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in ListVirtualSwitchesApiResponsedata.discriminator_value_class_map.values():
+            return list(ListVirtualSwitchesApiResponsedata.discriminator_value_class_map.keys())[list(ListVirtualSwitchesApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(VirtualSwitchApiResponsedata, dict):
+        if issubclass(ListVirtualSwitchesApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +176,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, VirtualSwitchApiResponsedata):
+        if not isinstance(other, ListVirtualSwitchesApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/VirtualSwitchListApiResponsedata.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/Gatewayservices.py`

 * *Files 17% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class VirtualSwitchListApiResponsedata(object):
+class Gatewayservices(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,49 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'List<networking.v4.config.VirtualSwitch>': 'list[networking.v4.config.VirtualSwitch]',
-        'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse',
-        'List<networking.v4.config.VirtualSwitchProjection>': 'list[networking.v4.config.VirtualSwitchProjection]'
+        'networking.v4.config.LocalNetworkServices': 'networking.v4.config.LocalNetworkServices',
+        'networking.v4.config.RemoteNetworkServices': 'networking.v4.config.RemoteNetworkServices'
     }
 
-    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
+    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$servicesItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfnetworking.v4.config.VirtualSwitchListApiResponsedata'
+        return 'OneOfnetworking.v4.config.Gatewayservices'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -115,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in VirtualSwitchListApiResponsedata.discriminator_value_class_map.values():
-            return list(VirtualSwitchListApiResponsedata.discriminator_value_class_map.keys())[list(VirtualSwitchListApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in Gatewayservices.discriminator_value_class_map.values():
+            return list(Gatewayservices.discriminator_value_class_map.keys())[list(Gatewayservices.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(VirtualSwitchListApiResponsedata, dict):
+        if issubclass(Gatewayservices, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -170,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, VirtualSwitchListApiResponsedata):
+        if not isinstance(other, Gatewayservices):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/VpcApiResponsedata.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListClusterCapabilitiesApiResponsedata.py`

 * *Files 14% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class VpcApiResponsedata(object):
+class ListClusterCapabilitiesApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'networking.v4.config.Vpc': 'networking.v4.config.Vpc',
+        'List<networking.v4.config.ClusterCapability>': 'list[networking.v4.config.ClusterCapability]',
         'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfnetworking.v4.config.VpcApiResponsedata'
+        return 'OneOfnetworking.v4.config.ListClusterCapabilitiesApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in VpcApiResponsedata.discriminator_value_class_map.values():
-            return list(VpcApiResponsedata.discriminator_value_class_map.keys())[list(VpcApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in ListClusterCapabilitiesApiResponsedata.discriminator_value_class_map.values():
+            return list(ListClusterCapabilitiesApiResponsedata.discriminator_value_class_map.keys())[list(ListClusterCapabilitiesApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(VpcApiResponsedata, dict):
+        if issubclass(ListClusterCapabilitiesApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, VpcApiResponsedata):
+        if not isinstance(other, ListClusterCapabilitiesApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/VpcListApiResponsedata.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/RerouteFallbackAction.py`

 * *Files 24% similar despite different names*

```diff
@@ -3,162 +3,125 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class VpcListApiResponsedata(object):
+class RerouteFallbackAction(object):
 
-    """
+    """Type of fallback action in reroute case when service VM is down.
 
 
-    """
-    """
-    IGNORE:
-    Attributes:
-      swagger_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-    IGNORE
-    """  # noqa: E501
-    swagger_types = {
-    }
-
-    attribute_map = {
-    }
-
-    discriminator_value_class_map = {
-        'EMPTY_LIST': 'list[str]',
-        'EMPTY_MAP': 'dict(str, object)',
-        'List<networking.v4.config.Vpc>': 'list[networking.v4.config.Vpc]',
-        'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse',
-        'List<networking.v4.config.VpcProjection>': 'list[networking.v4.config.VpcProjection]'
-    }
+    Allowed enum values:
 
-    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
+        - _UNKNOWN
+        - _REDACTED
+        - ALLOW: When service vm is down, reroute fallback action is "allowed".
+        - DROP: When service vm is down, reroute fallback action is "drop".
+        - PASSTHROUGH: When service vm is down, reroute fallback action is "passthrough". Next higher priority matching rule is applied.
+        - NO_ACTION: When service vm is down and reroute fallback action is "NO_ACTION". No action is taken and traffic is black-holed.
+    """
+    _UNKNOWN = "$UNKNOWN"
+    _REDACTED = "$REDACTED"
+    ALLOW = "ALLOW"
+    DROP = "DROP"
+    PASSTHROUGH = "PASSTHROUGH"
+    NO_ACTION = "NO_ACTION"
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfnetworking.v4.config.VpcListApiResponsedata'
+        return 'networking.v4.config.RerouteFallbackAction'
 
-    def _initialize_fq_object_type(self):
-        return ''
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
-    def get_real_child_model(self, discriminator):
-        """Returns the real base class specified by the discriminator"""
-        if discriminator is not None and discriminator in self.discriminator_value_class_map:
-            return self.discriminator_value_class_map.get(discriminator)
-        return None
-
-    @staticmethod
-    def get_discriminator_from_object(value):
-        """Returns the discriminator for the provided object.
-        """
-        if not value:
-            disc = 'list[str]'
-        elif hasattr(value, "_object_type"):
-            disc = value.get_object_type()
-        elif type(value) == list:
-            if hasattr(value[0], "_object_type"):
-                datatype = value[0].get_object_type()
-            else:
-                datatype = type(value[0]).__name__
-            disc = 'list[' + datatype + ']'
-        elif type(value) == dict:
-            if hasattr(next(iter(value.values())), "_object_type"):
-                datatype = next(iter(value.values())).get_object_type()
-            else:
-                datatype = type(next(iter(value.values()))).__name__
-            disc = 'dict(str, ' + datatype + ')'
-        else:
-            disc = type(value).__name__
-        if disc in VpcListApiResponsedata.discriminator_value_class_map.values():
-            return list(VpcListApiResponsedata.discriminator_value_class_map.keys())[list(VpcListApiResponsedata.discriminator_value_class_map.values()).index(disc)]
-        return None
-
-
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(VpcListApiResponsedata, dict):
+        if issubclass(RerouteFallbackAction, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -170,15 +133,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, VpcListApiResponsedata):
+        if not isinstance(other, RerouteFallbackAction):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/VpcVirtualSwitchMappingsApiResponsedata.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/GetBgpSessionApiResponse.py`

 * *Files 17% similar despite different names*

```diff
@@ -3,161 +3,213 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-
-class VpcVirtualSwitchMappingsApiResponsedata(object):
-
-    """
-
+from pathlib import Path
+import ntnx_networking_py_client.models
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.GetBgpSessionApiResponsedata import GetBgpSessionApiResponsedata  # noqa: F401,E501
+from ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class GetBgpSessionApiResponse(object):
+
+    """REST response for all response codes in API path /networking/v4.0.b1/config/bgp-sessions/{extId} Get operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
+        'metadata': 'common.v1.response.ApiResponseMetadata',
+        'data': 'OneOfnetworking.v4.config.GetBgpSessionApiResponsedata',
+        '_reserved': 'dict(str, object)',
+        '_object_type': 'str',
+        '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
+        'metadata': 'metadata',
+        'data': 'data',
+        '_reserved': '$reserved',
+        '_object_type': '$objectType',
+        '_unknown_fields': '$unknownFields',
     }
 
-    discriminator_value_class_map = {
-        'EMPTY_LIST': 'list[str]',
-        'EMPTY_MAP': 'dict(str, object)',
-        'List<networking.v4.config.VpcVirtualSwitchMapping>': 'list[networking.v4.config.VpcVirtualSwitchMapping]',
-        'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse'
-    }
-
-    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
-    def __init__(self, *args, **kwargs):  # noqa: E501
+    def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
+        self.__metadata = None
+        self.__data = None
         self.discriminator = None
+        if metadata is not None:
+            self.__metadata = metadata
+        if data is not None:
+            self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfnetworking.v4.config.VpcVirtualSwitchMappingsApiResponsedata'
+        return 'networking.v4.config.GetBgpSessionApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return ''
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
-    def get_real_child_model(self, discriminator):
-        """Returns the real base class specified by the discriminator"""
-        if discriminator is not None and discriminator in self.discriminator_value_class_map:
-            return self.discriminator_value_class_map.get(discriminator)
-        return None
-
-    @staticmethod
-    def get_discriminator_from_object(value):
-        """Returns the discriminator for the provided object.
-        """
-        if not value:
-            disc = 'list[str]'
-        elif hasattr(value, "_object_type"):
-            disc = value.get_object_type()
-        elif type(value) == list:
-            if hasattr(value[0], "_object_type"):
-                datatype = value[0].get_object_type()
-            else:
-                datatype = type(value[0]).__name__
-            disc = 'list[' + datatype + ']'
-        elif type(value) == dict:
-            if hasattr(next(iter(value.values())), "_object_type"):
-                datatype = next(iter(value.values())).get_object_type()
-            else:
-                datatype = type(next(iter(value.values()))).__name__
-            disc = 'dict(str, ' + datatype + ')'
-        else:
-            disc = type(value).__name__
-        if disc in VpcVirtualSwitchMappingsApiResponsedata.discriminator_value_class_map.values():
-            return list(VpcVirtualSwitchMappingsApiResponsedata.discriminator_value_class_map.keys())[list(VpcVirtualSwitchMappingsApiResponsedata.discriminator_value_class_map.values()).index(disc)]
-        return None
+    @property
+    def metadata(self):
+        """
+        
+
+        :type:
+            :class:`~ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata`
+        """  # noqa: E501
+        return self.__metadata
+
+    @metadata.setter
+    def metadata(self, metadata):
+
+        self.__metadata = metadata
+
+    @property
+    def data(self):
+        """
+        
+
+        :type:
+                :class:`~ntnx_networking_py_client.models.networking.v4.config.BgpSession` | 
+                :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse`
+                    """  # noqa: E501
+        return self.__data
 
+    @data.setter
+    def data(self, data):
+
+        self.__data = data
+
+    @property
+    def _reserved(self):
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
+        return self.__dollar_reserved
+
+    @property
+    def _object_type(self):
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__dollar_object_type
+
+    @property
+    def _unknown_fields(self):
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
+        return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
+            if attr_type.startswith('OneOf'):
+                type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(VpcVirtualSwitchMappingsApiResponsedata, dict):
+        if issubclass(GetBgpSessionApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, VpcVirtualSwitchMappingsApiResponsedata):
+        if not isinstance(other, GetBgpSessionApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/VpnConnectionApiResponsedata.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/stats/GetVpnConnectionStatsApiResponsedata.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class VpnConnectionApiResponsedata(object):
+class GetVpnConnectionStatsApiResponsedata(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'networking.v4.config.VpnConnection': 'networking.v4.config.VpnConnection',
+        'networking.v4.stats.VpnConnectionStats': 'networking.v4.stats.VpnConnectionStats',
         'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse'
     }
 
     ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfnetworking.v4.config.VpnConnectionApiResponsedata'
+        return 'OneOfnetworking.v4.stats.GetVpnConnectionStatsApiResponsedata'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in VpnConnectionApiResponsedata.discriminator_value_class_map.values():
-            return list(VpnConnectionApiResponsedata.discriminator_value_class_map.keys())[list(VpnConnectionApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in GetVpnConnectionStatsApiResponsedata.discriminator_value_class_map.values():
+            return list(GetVpnConnectionStatsApiResponsedata.discriminator_value_class_map.keys())[list(GetVpnConnectionStatsApiResponsedata.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(VpnConnectionApiResponsedata, dict):
+        if issubclass(GetVpnConnectionStatsApiResponsedata, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, VpnConnectionApiResponsedata):
+        if not isinstance(other, GetVpnConnectionStatsApiResponsedata):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/VpnConnectionListApiResponsedata.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/FloatingIpProjectionassociation.py`

 * *Files 13% similar despite different names*

```diff
@@ -3,27 +3,28 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class VpnConnectionListApiResponsedata(object):
+class FloatingIpProjectionassociation(object):
 
     """
 
 
     """
     """
     IGNORE:
@@ -39,48 +40,48 @@
 
     attribute_map = {
     }
 
     discriminator_value_class_map = {
         'EMPTY_LIST': 'list[str]',
         'EMPTY_MAP': 'dict(str, object)',
-        'List<networking.v4.config.VpnConnection>': 'list[networking.v4.config.VpnConnection]',
-        'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse'
+        'networking.v4.config.VmNicAssociation': 'networking.v4.config.VmNicAssociation',
+        'networking.v4.config.PrivateIpAssociation': 'networking.v4.config.PrivateIpAssociation'
     }
 
-    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
+    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$associationItemDiscriminator'
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfnetworking.v4.config.VpnConnectionListApiResponsedata'
+        return 'OneOfnetworking.v4.config.FloatingIpProjectionassociation'
 
-    def _initialize_fq_object_type(self):
+    def _initialize_object_version(self):
         return ''
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -114,50 +115,55 @@
             if hasattr(next(iter(value.values())), "_object_type"):
                 datatype = next(iter(value.values())).get_object_type()
             else:
                 datatype = type(next(iter(value.values()))).__name__
             disc = 'dict(str, ' + datatype + ')'
         else:
             disc = type(value).__name__
-        if disc in VpnConnectionListApiResponsedata.discriminator_value_class_map.values():
-            return list(VpnConnectionListApiResponsedata.discriminator_value_class_map.keys())[list(VpnConnectionListApiResponsedata.discriminator_value_class_map.values()).index(disc)]
+        if disc in FloatingIpProjectionassociation.discriminator_value_class_map.values():
+            return list(FloatingIpProjectionassociation.discriminator_value_class_map.keys())[list(FloatingIpProjectionassociation.discriminator_value_class_map.values()).index(disc)]
         return None
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(VpnConnectionListApiResponsedata, dict):
+        if issubclass(FloatingIpProjectionassociation, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +175,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, VpnConnectionListApiResponsedata):
+        if not isinstance(other, FloatingIpProjectionassociation):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/config/VpnVendorListApiResponsedata.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/TrafficMirrorSourcePortDirection.py`

 * *Files 21% similar despite different names*

```diff
@@ -3,161 +3,123 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class VpnVendorListApiResponsedata(object):
+class TrafficMirrorSourcePortDirection(object):
 
-    """
+    """Indicates the direction of traffic that the session will mirror. Allowed values are INGRESS, EGRESS and BIDIRECTIONAL.
 
 
-    """
-    """
-    IGNORE:
-    Attributes:
-      swagger_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-    IGNORE
-    """  # noqa: E501
-    swagger_types = {
-    }
-
-    attribute_map = {
-    }
-
-    discriminator_value_class_map = {
-        'EMPTY_LIST': 'list[str]',
-        'EMPTY_MAP': 'dict(str, object)',
-        'List<networking.v4.config.VpnAppliance>': 'list[networking.v4.config.VpnAppliance]',
-        'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse'
-    }
+    Allowed enum values:
 
-    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
+        - _UNKNOWN
+        - _REDACTED
+        - INGRESS: Indicates the incoming direction of traffic that the session will mirror.
+        - EGRESS: Indicates the outgoing direction of traffic that the session will mirror.
+        - BIDIRECTIONAL: Indicates the bidirectional traffic that the session will mirror.
+    """
+    _UNKNOWN = "$UNKNOWN"
+    _REDACTED = "$REDACTED"
+    INGRESS = "INGRESS"
+    EGRESS = "EGRESS"
+    BIDIRECTIONAL = "BIDIRECTIONAL"
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfnetworking.v4.config.VpnVendorListApiResponsedata'
+        return 'networking.v4.config.TrafficMirrorSourcePortDirection'
 
-    def _initialize_fq_object_type(self):
-        return ''
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
-    def get_real_child_model(self, discriminator):
-        """Returns the real base class specified by the discriminator"""
-        if discriminator is not None and discriminator in self.discriminator_value_class_map:
-            return self.discriminator_value_class_map.get(discriminator)
-        return None
-
-    @staticmethod
-    def get_discriminator_from_object(value):
-        """Returns the discriminator for the provided object.
-        """
-        if not value:
-            disc = 'list[str]'
-        elif hasattr(value, "_object_type"):
-            disc = value.get_object_type()
-        elif type(value) == list:
-            if hasattr(value[0], "_object_type"):
-                datatype = value[0].get_object_type()
-            else:
-                datatype = type(value[0]).__name__
-            disc = 'list[' + datatype + ']'
-        elif type(value) == dict:
-            if hasattr(next(iter(value.values())), "_object_type"):
-                datatype = next(iter(value.values())).get_object_type()
-            else:
-                datatype = type(next(iter(value.values()))).__name__
-            disc = 'dict(str, ' + datatype + ')'
-        else:
-            disc = type(value).__name__
-        if disc in VpnVendorListApiResponsedata.discriminator_value_class_map.values():
-            return list(VpnVendorListApiResponsedata.discriminator_value_class_map.keys())[list(VpnVendorListApiResponsedata.discriminator_value_class_map.values()).index(disc)]
-        return None
-
-
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(VpnVendorListApiResponsedata, dict):
+        if issubclass(TrafficMirrorSourcePortDirection, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +131,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, VpnVendorListApiResponsedata):
+        if not isinstance(other, TrafficMirrorSourcePortDirection):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/error/ErrorResponseerror.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/error/ErrorResponse.py`

 * *Files 15% similar despite different names*

```diff
@@ -3,161 +3,190 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
+import ntnx_networking_py_client.models
+from ntnx_networking_py_client.models.OneOfnetworking.v4.error.ErrorResponseerror import ErrorResponseerror  # noqa: F401,E501
 
-class ErrorResponseerror(object):
+class ErrorResponse(object):
 
-    """
+    """This schema is auto-generated by the Open API Dev Platform as REST response for 4xx and 5xx error responses.
 
+    :param error: (:attr:`error`) 
+    :type error: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
+        'error': 'OneOfnetworking.v4.error.ErrorResponseerror',
+        '_reserved': 'dict(str, object)',
+        '_object_type': 'str',
+        '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
+        'error': 'error',
+        '_reserved': '$reserved',
+        '_object_type': '$objectType',
+        '_unknown_fields': '$unknownFields',
     }
 
-    discriminator_value_class_map = {
-        'EMPTY_LIST': 'list[str]',
-        'EMPTY_MAP': 'dict(str, object)',
-        'List<networking.v4.error.AppMessage>': 'list[networking.v4.error.AppMessage]',
-        'networking.v4.error.SchemaValidationError': 'networking.v4.error.SchemaValidationError'
-    }
-
-    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$errorItemDiscriminator'
 
 
-    def __init__(self, *args, **kwargs):  # noqa: E501
+    def __init__(self, error=None, *args, **kwargs):  # noqa: E501
+        self.__error = None
         self.discriminator = None
+        if error is not None:
+            self.__error = error
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfnetworking.v4.error.ErrorResponseerror'
+        return 'networking.v4.error.ErrorResponse'
 
-    def _initialize_fq_object_type(self):
-        return ''
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
-    def get_real_child_model(self, discriminator):
-        """Returns the real base class specified by the discriminator"""
-        if discriminator is not None and discriminator in self.discriminator_value_class_map:
-            return self.discriminator_value_class_map.get(discriminator)
-        return None
-
-    @staticmethod
-    def get_discriminator_from_object(value):
-        """Returns the discriminator for the provided object.
+    @property
+    def error(self):
         """
-        if not value:
-            disc = 'list[str]'
-        elif hasattr(value, "_object_type"):
-            disc = value.get_object_type()
-        elif type(value) == list:
-            if hasattr(value[0], "_object_type"):
-                datatype = value[0].get_object_type()
-            else:
-                datatype = type(value[0]).__name__
-            disc = 'list[' + datatype + ']'
-        elif type(value) == dict:
-            if hasattr(next(iter(value.values())), "_object_type"):
-                datatype = next(iter(value.values())).get_object_type()
-            else:
-                datatype = type(next(iter(value.values()))).__name__
-            disc = 'dict(str, ' + datatype + ')'
-        else:
-            disc = type(value).__name__
-        if disc in ErrorResponseerror.discriminator_value_class_map.values():
-            return list(ErrorResponseerror.discriminator_value_class_map.keys())[list(ErrorResponseerror.discriminator_value_class_map.values()).index(disc)]
-        return None
+        
+
+        :type:
+                :class:`~ntnx_networking_py_client.models.networking.v4.error.AppMessage` | 
+                :class:`~ntnx_networking_py_client.models.networking.v4.error.SchemaValidationError`
+                    """  # noqa: E501
+        return self.__error
+
+    @error.setter
+    def error(self, error):
+
+        self.__error = error
+
+    @property
+    def _reserved(self):
+        """
+        
 
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
+        return self.__dollar_reserved
+
+    @property
+    def _object_type(self):
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__dollar_object_type
+
+    @property
+    def _unknown_fields(self):
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
+        return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
+            if attr_type.startswith('OneOf'):
+                type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ErrorResponseerror, dict):
+        if issubclass(ErrorResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +198,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ErrorResponseerror):
+        if not isinstance(other, ErrorResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/stats/Layer2StretchStatsApiResponsedata.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ExportScope.py`

 * *Files 20% similar despite different names*

```diff
@@ -3,161 +3,211 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
+from ntnx_networking_py_client.models.networking.v4.config.ScopeType import ScopeType  # noqa: F401,E501
 
-class Layer2StretchStatsApiResponsedata(object):
+class ExportScope(object):
 
-    """
+    """Contains the UUID and scope type information for a particular export scope.
 
+    :param uuid: (:attr:`uuid`) 
+    :type uuid: 
+    :param scope_type: (:attr:`scope_type`) 
+    :type scope_type: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
+        'uuid': 'str',
+        'scope_type': 'networking.v4.config.ScopeType',
+        '_reserved': 'dict(str, object)',
+        '_object_type': 'str',
+        '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
+        'uuid': 'uuid',
+        'scope_type': 'scopeType',
+        '_reserved': '$reserved',
+        '_object_type': '$objectType',
+        '_unknown_fields': '$unknownFields',
     }
 
-    discriminator_value_class_map = {
-        'EMPTY_LIST': 'list[str]',
-        'EMPTY_MAP': 'dict(str, object)',
-        'networking.v4.stats.Layer2StretchStats': 'networking.v4.stats.Layer2StretchStats',
-        'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse'
-    }
-
-    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
-    def __init__(self, *args, **kwargs):  # noqa: E501
+    def __init__(self, uuid=None, scope_type=None, *args, **kwargs):  # noqa: E501
+        self.__uuid = None
+        self.__scope_type = None
         self.discriminator = None
+        if uuid is not None:
+            self.__uuid = uuid
+        if scope_type is not None:
+            self.__scope_type = scope_type
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfnetworking.v4.stats.Layer2StretchStatsApiResponsedata'
+        return 'networking.v4.config.ExportScope'
 
-    def _initialize_fq_object_type(self):
-        return ''
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
-    def get_real_child_model(self, discriminator):
-        """Returns the real base class specified by the discriminator"""
-        if discriminator is not None and discriminator in self.discriminator_value_class_map:
-            return self.discriminator_value_class_map.get(discriminator)
-        return None
-
-    @staticmethod
-    def get_discriminator_from_object(value):
-        """Returns the discriminator for the provided object.
-        """
-        if not value:
-            disc = 'list[str]'
-        elif hasattr(value, "_object_type"):
-            disc = value.get_object_type()
-        elif type(value) == list:
-            if hasattr(value[0], "_object_type"):
-                datatype = value[0].get_object_type()
-            else:
-                datatype = type(value[0]).__name__
-            disc = 'list[' + datatype + ']'
-        elif type(value) == dict:
-            if hasattr(next(iter(value.values())), "_object_type"):
-                datatype = next(iter(value.values())).get_object_type()
-            else:
-                datatype = type(next(iter(value.values()))).__name__
-            disc = 'dict(str, ' + datatype + ')'
-        else:
-            disc = type(value).__name__
-        if disc in Layer2StretchStatsApiResponsedata.discriminator_value_class_map.values():
-            return list(Layer2StretchStatsApiResponsedata.discriminator_value_class_map.keys())[list(Layer2StretchStatsApiResponsedata.discriminator_value_class_map.values()).index(disc)]
-        return None
+    @property
+    def uuid(self):
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__uuid
+
+    @uuid.setter
+    def uuid(self, uuid):
+        if uuid is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', uuid):  # noqa: E501
+            raise ValueError(r"Invalid value for `uuid`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
+
+        self.__uuid = uuid
+
+    @property
+    def scope_type(self):
+        """
+        
+
+        :type:
+            :class:`~ntnx_networking_py_client.models.networking.v4.config.ScopeType`
+        """  # noqa: E501
+        return self.__scope_type
+
+    @scope_type.setter
+    def scope_type(self, scope_type):
 
+        self.__scope_type = scope_type
+
+    @property
+    def _reserved(self):
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
+        return self.__dollar_reserved
+
+    @property
+    def _object_type(self):
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__dollar_object_type
+
+    @property
+    def _unknown_fields(self):
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
+        return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(Layer2StretchStatsApiResponsedata, dict):
+        if issubclass(ExportScope, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +219,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, Layer2StretchStatsApiResponsedata):
+        if not isinstance(other, ExportScope):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/stats/TaskReferenceApiResponsedata.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/prism/v4/config/TaskReference.py`

 * *Files 14% similar despite different names*

```diff
@@ -3,161 +3,188 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class TaskReferenceApiResponsedata(object):
+class TaskReference(object):
 
-    """
+    """A reference to a task tracking an asynchronous operation. The status of the task can be queried by making a GET request to the task URI provided in the metadata section of the API response.
 
+    :param ext_id: (:attr:`ext_id`) A globally unique identifier of a task.
+    :type ext_id: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
+        'ext_id': 'str',
+        '_reserved': 'dict(str, object)',
+        '_object_type': 'str',
+        '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
+        'ext_id': 'extId',
+        '_reserved': '$reserved',
+        '_object_type': '$objectType',
+        '_unknown_fields': '$unknownFields',
     }
 
-    discriminator_value_class_map = {
-        'EMPTY_LIST': 'list[str]',
-        'EMPTY_MAP': 'dict(str, object)',
-        'prism.v4.config.TaskReference': 'prism.v4.config.TaskReference',
-        'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse'
-    }
-
-    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
-    def __init__(self, *args, **kwargs):  # noqa: E501
+    def __init__(self, ext_id=None, *args, **kwargs):  # noqa: E501
+        self.__ext_id = None
         self.discriminator = None
+        if ext_id is not None:
+            self.__ext_id = ext_id
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfnetworking.v4.stats.TaskReferenceApiResponsedata'
+        return 'prism.v4.config.TaskReference'
 
-    def _initialize_fq_object_type(self):
-        return ''
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
-    def get_real_child_model(self, discriminator):
-        """Returns the real base class specified by the discriminator"""
-        if discriminator is not None and discriminator in self.discriminator_value_class_map:
-            return self.discriminator_value_class_map.get(discriminator)
-        return None
-
-    @staticmethod
-    def get_discriminator_from_object(value):
-        """Returns the discriminator for the provided object.
+    @property
+    def ext_id(self):
         """
-        if not value:
-            disc = 'list[str]'
-        elif hasattr(value, "_object_type"):
-            disc = value.get_object_type()
-        elif type(value) == list:
-            if hasattr(value[0], "_object_type"):
-                datatype = value[0].get_object_type()
-            else:
-                datatype = type(value[0]).__name__
-            disc = 'list[' + datatype + ']'
-        elif type(value) == dict:
-            if hasattr(next(iter(value.values())), "_object_type"):
-                datatype = next(iter(value.values())).get_object_type()
-            else:
-                datatype = type(next(iter(value.values()))).__name__
-            disc = 'dict(str, ' + datatype + ')'
-        else:
-            disc = type(value).__name__
-        if disc in TaskReferenceApiResponsedata.discriminator_value_class_map.values():
-            return list(TaskReferenceApiResponsedata.discriminator_value_class_map.keys())[list(TaskReferenceApiResponsedata.discriminator_value_class_map.values()).index(disc)]
-        return None
+        A globally unique identifier of a task.
 
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__ext_id
+
+    @ext_id.setter
+    def ext_id(self, ext_id):
+        if ext_id is not None and not re.search('^[a-zA-Z0-9\/+]*={0,2}:[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}', ext_id):  # noqa: E501
+            raise ValueError(r"Invalid value for `ext_id`, must be a follow pattern or equal to `/^[a-zA-Z0-9\/+]*={0,2}:[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}/`")  # noqa: E501
+
+        self.__ext_id = ext_id
+
+    @property
+    def _reserved(self):
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
+        return self.__dollar_reserved
+
+    @property
+    def _object_type(self):
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__dollar_object_type
+
+    @property
+    def _unknown_fields(self):
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
+        return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(TaskReferenceApiResponsedata, dict):
+        if issubclass(TaskReference, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +196,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, TaskReferenceApiResponsedata):
+        if not isinstance(other, TaskReference):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/stats/TrafficMirrorStatsApiResponsedata.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/IPConfig.py`

 * *Files 21% similar despite different names*

```diff
@@ -3,161 +3,209 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-
-class TrafficMirrorStatsApiResponsedata(object):
-
-    """
-
+from pathlib import Path
+from ntnx_networking_py_client.models.networking.v4.config.IPv4Config import IPv4Config  # noqa: F401,E501
+from ntnx_networking_py_client.models.networking.v4.config.IPv6Config import IPv6Config  # noqa: F401,E501
+
+class IPConfig(object):
+
+    """IP configuration.
+
+    :param ipv4: (:attr:`ipv4`) 
+    :type ipv4: 
+    :param ipv6: (:attr:`ipv6`) 
+    :type ipv6: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
+        'ipv4': 'networking.v4.config.IPv4Config',
+        'ipv6': 'networking.v4.config.IPv6Config',
+        '_reserved': 'dict(str, object)',
+        '_object_type': 'str',
+        '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
+        'ipv4': 'ipv4',
+        'ipv6': 'ipv6',
+        '_reserved': '$reserved',
+        '_object_type': '$objectType',
+        '_unknown_fields': '$unknownFields',
     }
 
-    discriminator_value_class_map = {
-        'EMPTY_LIST': 'list[str]',
-        'EMPTY_MAP': 'dict(str, object)',
-        'networking.v4.stats.TrafficMirrorStats': 'networking.v4.stats.TrafficMirrorStats',
-        'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse'
-    }
-
-    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
-    def __init__(self, *args, **kwargs):  # noqa: E501
+    def __init__(self, ipv4=None, ipv6=None, *args, **kwargs):  # noqa: E501
+        self.__ipv4 = None
+        self.__ipv6 = None
         self.discriminator = None
+        if ipv4 is not None:
+            self.__ipv4 = ipv4
+        if ipv6 is not None:
+            self.__ipv6 = ipv6
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfnetworking.v4.stats.TrafficMirrorStatsApiResponsedata'
+        return 'networking.v4.config.IPConfig'
 
-    def _initialize_fq_object_type(self):
-        return ''
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
-    def get_real_child_model(self, discriminator):
-        """Returns the real base class specified by the discriminator"""
-        if discriminator is not None and discriminator in self.discriminator_value_class_map:
-            return self.discriminator_value_class_map.get(discriminator)
-        return None
-
-    @staticmethod
-    def get_discriminator_from_object(value):
-        """Returns the discriminator for the provided object.
-        """
-        if not value:
-            disc = 'list[str]'
-        elif hasattr(value, "_object_type"):
-            disc = value.get_object_type()
-        elif type(value) == list:
-            if hasattr(value[0], "_object_type"):
-                datatype = value[0].get_object_type()
-            else:
-                datatype = type(value[0]).__name__
-            disc = 'list[' + datatype + ']'
-        elif type(value) == dict:
-            if hasattr(next(iter(value.values())), "_object_type"):
-                datatype = next(iter(value.values())).get_object_type()
-            else:
-                datatype = type(next(iter(value.values()))).__name__
-            disc = 'dict(str, ' + datatype + ')'
-        else:
-            disc = type(value).__name__
-        if disc in TrafficMirrorStatsApiResponsedata.discriminator_value_class_map.values():
-            return list(TrafficMirrorStatsApiResponsedata.discriminator_value_class_map.keys())[list(TrafficMirrorStatsApiResponsedata.discriminator_value_class_map.values()).index(disc)]
-        return None
+    @property
+    def ipv4(self):
+        """
+        
+
+        :type:
+            :class:`~ntnx_networking_py_client.models.networking.v4.config.IPv4Config`
+        """  # noqa: E501
+        return self.__ipv4
+
+    @ipv4.setter
+    def ipv4(self, ipv4):
+
+        self.__ipv4 = ipv4
+
+    @property
+    def ipv6(self):
+        """
+        
+
+        :type:
+            :class:`~ntnx_networking_py_client.models.networking.v4.config.IPv6Config`
+        """  # noqa: E501
+        return self.__ipv6
 
+    @ipv6.setter
+    def ipv6(self, ipv6):
+
+        self.__ipv6 = ipv6
+
+    @property
+    def _reserved(self):
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
+        return self.__dollar_reserved
+
+    @property
+    def _object_type(self):
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__dollar_object_type
+
+    @property
+    def _unknown_fields(self):
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
+        return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(TrafficMirrorStatsApiResponsedata, dict):
+        if issubclass(IPConfig, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,16 +217,25 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, TrafficMirrorStatsApiResponsedata):
+        if not isinstance(other, IPConfig):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
 
+    def has_ipv4(self):
+        """Returns true if `ipv4` has non-none value"""
+        return self._ipv4 is None
+    def has_ipv6(self):
+        """Returns true if `ipv6` has non-none value"""
+        return self._ipv6 is None
+    def is_valid(self):
+        """Returns true if any one of the attributes has non-none value"""
+        return self.has_ipv4() or self.has_ipv6()
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/stats/VpcNsStatsApiResponsedata.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/FloatingIPAddress.py`

 * *Files 21% similar despite different names*

```diff
@@ -3,161 +3,209 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-
-class VpcNsStatsApiResponsedata(object):
-
-    """
-
+from pathlib import Path
+from ntnx_networking_py_client.models.networking.v4.config.FloatingIPv4Address import FloatingIPv4Address  # noqa: F401,E501
+from ntnx_networking_py_client.models.networking.v4.config.FloatingIPv6Address import FloatingIPv6Address  # noqa: F401,E501
+
+class FloatingIPAddress(object):
+
+    """Floating IP address.
+
+    :param ipv4: (:attr:`ipv4`) 
+    :type ipv4: 
+    :param ipv6: (:attr:`ipv6`) 
+    :type ipv6: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
+        'ipv4': 'networking.v4.config.FloatingIPv4Address',
+        'ipv6': 'networking.v4.config.FloatingIPv6Address',
+        '_reserved': 'dict(str, object)',
+        '_object_type': 'str',
+        '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
+        'ipv4': 'ipv4',
+        'ipv6': 'ipv6',
+        '_reserved': '$reserved',
+        '_object_type': '$objectType',
+        '_unknown_fields': '$unknownFields',
     }
 
-    discriminator_value_class_map = {
-        'EMPTY_LIST': 'list[str]',
-        'EMPTY_MAP': 'dict(str, object)',
-        'networking.v4.stats.VpcNsStats': 'networking.v4.stats.VpcNsStats',
-        'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse'
-    }
-
-    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
-    def __init__(self, *args, **kwargs):  # noqa: E501
+    def __init__(self, ipv4=None, ipv6=None, *args, **kwargs):  # noqa: E501
+        self.__ipv4 = None
+        self.__ipv6 = None
         self.discriminator = None
+        if ipv4 is not None:
+            self.__ipv4 = ipv4
+        if ipv6 is not None:
+            self.__ipv6 = ipv6
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfnetworking.v4.stats.VpcNsStatsApiResponsedata'
+        return 'networking.v4.config.FloatingIPAddress'
 
-    def _initialize_fq_object_type(self):
-        return ''
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
-    def get_real_child_model(self, discriminator):
-        """Returns the real base class specified by the discriminator"""
-        if discriminator is not None and discriminator in self.discriminator_value_class_map:
-            return self.discriminator_value_class_map.get(discriminator)
-        return None
-
-    @staticmethod
-    def get_discriminator_from_object(value):
-        """Returns the discriminator for the provided object.
-        """
-        if not value:
-            disc = 'list[str]'
-        elif hasattr(value, "_object_type"):
-            disc = value.get_object_type()
-        elif type(value) == list:
-            if hasattr(value[0], "_object_type"):
-                datatype = value[0].get_object_type()
-            else:
-                datatype = type(value[0]).__name__
-            disc = 'list[' + datatype + ']'
-        elif type(value) == dict:
-            if hasattr(next(iter(value.values())), "_object_type"):
-                datatype = next(iter(value.values())).get_object_type()
-            else:
-                datatype = type(next(iter(value.values()))).__name__
-            disc = 'dict(str, ' + datatype + ')'
-        else:
-            disc = type(value).__name__
-        if disc in VpcNsStatsApiResponsedata.discriminator_value_class_map.values():
-            return list(VpcNsStatsApiResponsedata.discriminator_value_class_map.keys())[list(VpcNsStatsApiResponsedata.discriminator_value_class_map.values()).index(disc)]
-        return None
+    @property
+    def ipv4(self):
+        """
+        
+
+        :type:
+            :class:`~ntnx_networking_py_client.models.networking.v4.config.FloatingIPv4Address`
+        """  # noqa: E501
+        return self.__ipv4
+
+    @ipv4.setter
+    def ipv4(self, ipv4):
+
+        self.__ipv4 = ipv4
+
+    @property
+    def ipv6(self):
+        """
+        
+
+        :type:
+            :class:`~ntnx_networking_py_client.models.networking.v4.config.FloatingIPv6Address`
+        """  # noqa: E501
+        return self.__ipv6
 
+    @ipv6.setter
+    def ipv6(self, ipv6):
+
+        self.__ipv6 = ipv6
+
+    @property
+    def _reserved(self):
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
+        return self.__dollar_reserved
+
+    @property
+    def _object_type(self):
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__dollar_object_type
+
+    @property
+    def _unknown_fields(self):
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
+        return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(VpcNsStatsApiResponsedata, dict):
+        if issubclass(FloatingIPAddress, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,16 +217,25 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, VpcNsStatsApiResponsedata):
+        if not isinstance(other, FloatingIPAddress):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
 
+    def has_ipv4(self):
+        """Returns true if `ipv4` has non-none value"""
+        return self._ipv4 is None
+    def has_ipv6(self):
+        """Returns true if `ipv6` has non-none value"""
+        return self._ipv6 is None
+    def is_valid(self):
+        """Returns true if any one of the attributes has non-none value"""
+        return self.has_ipv4() or self.has_ipv6()
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/OneOfnetworking/v4/stats/VpnConnectionStatsApiResponsedata.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/FlowGatewayStatus.py`

 * *Files 17% similar despite different names*

```diff
@@ -3,161 +3,209 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
+from ntnx_networking_py_client.models.networking.v4.config.FlowGatewayState import FlowGatewayState  # noqa: F401,E501
 
-class VpnConnectionStatsApiResponsedata(object):
+class FlowGatewayStatus(object):
 
-    """
+    """Status of the Atlas Flow Gateway.
 
+    :param detail: (:attr:`detail`) Status detail of the Atlas Flow Gateway.
+    :type detail: 
+    :param state: (:attr:`state`) 
+    :type state: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
+        'detail': 'str',
+        'state': 'networking.v4.config.FlowGatewayState',
+        '_reserved': 'dict(str, object)',
+        '_object_type': 'str',
+        '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
+        'detail': 'detail',
+        'state': 'state',
+        '_reserved': '$reserved',
+        '_object_type': '$objectType',
+        '_unknown_fields': '$unknownFields',
     }
 
-    discriminator_value_class_map = {
-        'EMPTY_LIST': 'list[str]',
-        'EMPTY_MAP': 'dict(str, object)',
-        'networking.v4.stats.VpnConnectionStats': 'networking.v4.stats.VpnConnectionStats',
-        'networking.v4.error.ErrorResponse': 'networking.v4.error.ErrorResponse'
-    }
-
-    ONE_OF_ITEM_DISCRIMINATOR_NAME = '$dataItemDiscriminator'
 
 
-    def __init__(self, *args, **kwargs):  # noqa: E501
+    def __init__(self, detail=None, state=None, *args, **kwargs):  # noqa: E501
+        self.__detail = None
+        self.__state = None
         self.discriminator = None
+        if detail is not None:
+            self.__detail = detail
+        if state is not None:
+            self.__state = state
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'OneOfnetworking.v4.stats.VpnConnectionStatsApiResponsedata'
+        return 'networking.v4.config.FlowGatewayStatus'
 
-    def _initialize_fq_object_type(self):
-        return ''
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
-    def get_real_child_model(self, discriminator):
-        """Returns the real base class specified by the discriminator"""
-        if discriminator is not None and discriminator in self.discriminator_value_class_map:
-            return self.discriminator_value_class_map.get(discriminator)
-        return None
-
-    @staticmethod
-    def get_discriminator_from_object(value):
-        """Returns the discriminator for the provided object.
-        """
-        if not value:
-            disc = 'list[str]'
-        elif hasattr(value, "_object_type"):
-            disc = value.get_object_type()
-        elif type(value) == list:
-            if hasattr(value[0], "_object_type"):
-                datatype = value[0].get_object_type()
-            else:
-                datatype = type(value[0]).__name__
-            disc = 'list[' + datatype + ']'
-        elif type(value) == dict:
-            if hasattr(next(iter(value.values())), "_object_type"):
-                datatype = next(iter(value.values())).get_object_type()
-            else:
-                datatype = type(next(iter(value.values()))).__name__
-            disc = 'dict(str, ' + datatype + ')'
-        else:
-            disc = type(value).__name__
-        if disc in VpnConnectionStatsApiResponsedata.discriminator_value_class_map.values():
-            return list(VpnConnectionStatsApiResponsedata.discriminator_value_class_map.keys())[list(VpnConnectionStatsApiResponsedata.discriminator_value_class_map.values()).index(disc)]
-        return None
+    @property
+    def detail(self):
+        """
+        Status detail of the Atlas Flow Gateway.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__detail
+
+    @detail.setter
+    def detail(self, detail):
+
+        self.__detail = detail
+
+    @property
+    def state(self):
+        """
+        
+
+        :type:
+            :class:`~ntnx_networking_py_client.models.networking.v4.config.FlowGatewayState`
+        """  # noqa: E501
+        return self.__state
+
+    @state.setter
+    def state(self, state):
 
+        self.__state = state
+
+    @property
+    def _reserved(self):
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
+        return self.__dollar_reserved
+
+    @property
+    def _object_type(self):
+        """
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__dollar_object_type
+
+    @property
+    def _unknown_fields(self):
+        """
+        
+
+        :type:
+            dict(str, :class:`~object`)
+        """  # noqa: E501
+        return self.__dollar_unknown_fields
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(VpnConnectionStatsApiResponsedata, dict):
+        if issubclass(FlowGatewayStatus, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -169,15 +217,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, VpnConnectionStatsApiResponsedata):
+        if not isinstance(other, FlowGatewayStatus):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/__init__.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,80 +1,100 @@
 # coding: utf-8
 
 # flake8: noqa
 
+
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 from __future__ import absolute_import
 
-# import models into model package
+# import apis into sdk package
+from ntnx_networking_py_client.api.bgp_sessions_api import BgpSessionsApi
+from ntnx_networking_py_client.api.bridges_api import BridgesApi
+from ntnx_networking_py_client.api.cluster_capabilities_api import ClusterCapabilitiesApi
+from ntnx_networking_py_client.api.floating_ips_api import FloatingIpsApi
+from ntnx_networking_py_client.api.gateways_api import GatewaysApi
+from ntnx_networking_py_client.api.ipfix_exporters_api import IPFIXExportersApi
+from ntnx_networking_py_client.api.layer2_stretch_stats_api import Layer2StretchStatsApi
+from ntnx_networking_py_client.api.layer2_stretches_api import Layer2StretchesApi
+from ntnx_networking_py_client.api.network_controllers_api import NetworkControllersApi
+from ntnx_networking_py_client.api.route_tables_api import RouteTablesApi
+from ntnx_networking_py_client.api.routing_policies_api import RoutingPoliciesApi
+from ntnx_networking_py_client.api.routing_policy_stats_api import RoutingPolicyStatsApi
+from ntnx_networking_py_client.api.subnet_ip_reservation_api import SubnetIPReservationApi
+from ntnx_networking_py_client.api.subnets_api import SubnetsApi
+from ntnx_networking_py_client.api.traffic_mirror_stats_api import TrafficMirrorStatsApi
+from ntnx_networking_py_client.api.traffic_mirrors_api import TrafficMirrorsApi
+from ntnx_networking_py_client.api.uplink_bonds_api import UplinkBondsApi
+from ntnx_networking_py_client.api.virtual_switch_nodes_info_api import VirtualSwitchNodesInfoApi
+from ntnx_networking_py_client.api.virtual_switches_api import VirtualSwitchesApi
+from ntnx_networking_py_client.api.vpc_ns_stats_api import VpcNsStatsApi
+from ntnx_networking_py_client.api.vpc_virtual_switch_mappings_api import VpcVirtualSwitchMappingsApi
+from ntnx_networking_py_client.api.vpcs_api import VpcsApi
+from ntnx_networking_py_client.api.vpn_connection_stats_api import VpnConnectionStatsApi
+from ntnx_networking_py_client.api.vpn_connections_api import VpnConnectionsApi
+# import ApiClient
+from ntnx_networking_py_client.api_client import ApiClient
+from ntnx_networking_py_client.configuration import Configuration
+# import models into sdk package
 from ntnx_networking_py_client.models.OneOfcommon.v1.config.KVPairvalue import KVPairvalue
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.AncConfigApiResponsedata import AncConfigApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.BgpSessionApiResponsedata import BgpSessionApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.BgpSessionListApiResponsedata import BgpSessionListApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.CloudNetworkApiResponsedata import CloudNetworkApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.CloudNetworkListApiResponsedata import CloudNetworkListApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ClusterCapabilityApiResponsedata import ClusterCapabilityApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ClusterFlowStatusApiResponsedata import ClusterFlowStatusApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.FloatingIpApiResponsedata import FloatingIpApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.FloatingIpListApiResponsedata import FloatingIpListApiResponsedata
 from ntnx_networking_py_client.models.OneOfnetworking.v4.config.FloatingIpProjectionassociation import FloatingIpProjectionassociation
 from ntnx_networking_py_client.models.OneOfnetworking.v4.config.FloatingIpassociation import FloatingIpassociation
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.FlowGatewayApiResponsedata import FlowGatewayApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.FlowGatewayKeepAliveApiResponsedata import FlowGatewayKeepAliveApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.FlowGatewayListApiResponsedata import FlowGatewayListApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.GatewayApiResponsedata import GatewayApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.GatewayListApiResponsedata import GatewayListApiResponsedata
 from ntnx_networking_py_client.models.OneOfnetworking.v4.config.GatewayProjectionservices import GatewayProjectionservices
 from ntnx_networking_py_client.models.OneOfnetworking.v4.config.Gatewayservices import Gatewayservices
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.IPFIXExporterApiResponsedata import IPFIXExporterApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.IPFIXExporterListApiResponsedata import IPFIXExporterListApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.Layer2StretchApiResponsedata import Layer2StretchApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.Layer2StretchListApiResponsedata import Layer2StretchListApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.Layer2StretchRelatedEntitiesApiResponsedata import Layer2StretchRelatedEntitiesApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.NetworkCloudConfigApiResponsedata import NetworkCloudConfigApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.NetworkCloudConfigListApiResponsedata import NetworkCloudConfigListApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.NetworkControllerApiResponsedata import NetworkControllerApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.NetworkControllerListApiResponsedata import NetworkControllerListApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.NodeSchedulableStatusApiResponsedata import NodeSchedulableStatusApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.RouteTableApiResponsedata import RouteTableApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.RouteTableListApiResponsedata import RouteTableListApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.RoutingPolicyApiResponsedata import RoutingPolicyApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.RoutingPolicyListApiResponsedata import RoutingPolicyListApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.GetBgpSessionApiResponsedata import GetBgpSessionApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.GetFloatingIpApiResponsedata import GetFloatingIpApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.GetGatewayApiResponsedata import GetGatewayApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.GetIPFIXExporterApiResponsedata import GetIPFIXExporterApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.GetLayer2StretchApiResponsedata import GetLayer2StretchApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.GetNetworkControllerApiResponsedata import GetNetworkControllerApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.GetRouteTableApiResponsedata import GetRouteTableApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.GetRoutingPolicyApiResponsedata import GetRoutingPolicyApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.GetSubnetApiResponsedata import GetSubnetApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.GetTrafficMirrorApiResponsedata import GetTrafficMirrorApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.GetUplinkBondApiResponsedata import GetUplinkBondApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.GetVirtualSwitchApiResponsedata import GetVirtualSwitchApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.GetVpcApiResponsedata import GetVpcApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.GetVpnConnectionApiResponsedata import GetVpnConnectionApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListBgpSessionsApiResponsedata import ListBgpSessionsApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListClusterCapabilitiesApiResponsedata import ListClusterCapabilitiesApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListFloatingIpsApiResponsedata import ListFloatingIpsApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListGatewaysApiResponsedata import ListGatewaysApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListIPFIXExportersApiResponsedata import ListIPFIXExportersApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListLayer2StretchRelatedEntitiesApiResponsedata import ListLayer2StretchRelatedEntitiesApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListLayer2StretchesApiResponsedata import ListLayer2StretchesApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListNetworkControllersApiResponsedata import ListNetworkControllersApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListNodeSchedulableStatusesApiResponsedata import ListNodeSchedulableStatusesApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListRouteTablesApiResponsedata import ListRouteTablesApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListRoutingPoliciesApiResponsedata import ListRoutingPoliciesApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListSubnetsApiResponsedata import ListSubnetsApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListTrafficMirrorsApiResponsedata import ListTrafficMirrorsApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListUplinkBondsApiResponsedata import ListUplinkBondsApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListVirtualSwitchesApiResponsedata import ListVirtualSwitchesApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListVpcVirtualSwitchMappingsApiResponsedata import ListVpcVirtualSwitchMappingsApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListVpcsApiResponsedata import ListVpcsApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListVpnConnectionsApiResponsedata import ListVpnConnectionsApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListVpnVendorConfigsApiResponsedata import ListVpnVendorConfigsApiResponsedata
 from ntnx_networking_py_client.models.OneOfnetworking.v4.config.RoutingPolicyMatchConditionprotocol_parameters import RoutingPolicyMatchConditionprotocol_parameters
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.SubnetApiResponsedata import SubnetApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.SubnetListApiResponsedata import SubnetListApiResponsedata
 from ntnx_networking_py_client.models.OneOfnetworking.v4.config.TaskReferenceApiResponsedata import TaskReferenceApiResponsedata as ConfigTaskReferenceApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.TrafficMirrorApiResponsedata import TrafficMirrorApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.TrafficMirrorListApiResponsedata import TrafficMirrorListApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.UplinkBondApiResponsedata import UplinkBondApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.UplinkBondListApiResponsedata import UplinkBondListApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.VirtualSwitchApiResponsedata import VirtualSwitchApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.VirtualSwitchListApiResponsedata import VirtualSwitchListApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.VpcApiResponsedata import VpcApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.VpcListApiResponsedata import VpcListApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.VpcVirtualSwitchMappingsApiResponsedata import VpcVirtualSwitchMappingsApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.VpnConnectionApiResponsedata import VpnConnectionApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.VpnConnectionListApiResponsedata import VpnConnectionListApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.VpnVendorListApiResponsedata import VpnVendorListApiResponsedata
 from ntnx_networking_py_client.models.OneOfnetworking.v4.error.ErrorResponseerror import ErrorResponseerror
-from ntnx_networking_py_client.models.OneOfnetworking.v4.stats.Layer2StretchStatsApiResponsedata import Layer2StretchStatsApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.stats.GetLayer2StretchStatsApiResponsedata import GetLayer2StretchStatsApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.stats.GetTrafficMirrorStatsApiResponsedata import GetTrafficMirrorStatsApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.stats.GetVpcNsStatsApiResponsedata import GetVpcNsStatsApiResponsedata
+from ntnx_networking_py_client.models.OneOfnetworking.v4.stats.GetVpnConnectionStatsApiResponsedata import GetVpnConnectionStatsApiResponsedata
 from ntnx_networking_py_client.models.OneOfnetworking.v4.stats.TaskReferenceApiResponsedata import TaskReferenceApiResponsedata as StatsTaskReferenceApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.stats.TrafficMirrorStatsApiResponsedata import TrafficMirrorStatsApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.stats.VpcNsStatsApiResponsedata import VpcNsStatsApiResponsedata
-from ntnx_networking_py_client.models.OneOfnetworking.v4.stats.VpnConnectionStatsApiResponsedata import VpnConnectionStatsApiResponsedata
 from ntnx_networking_py_client.models.common.v1.config.EntityReference import EntityReference
 from ntnx_networking_py_client.models.common.v1.config.EntityType import EntityType
 from ntnx_networking_py_client.models.common.v1.config.Flag import Flag
 from ntnx_networking_py_client.models.common.v1.config.IPAddress import IPAddress
 from ntnx_networking_py_client.models.common.v1.config.IPv4Address import IPv4Address
 from ntnx_networking_py_client.models.common.v1.config.IPv6Address import IPv6Address
 from ntnx_networking_py_client.models.common.v1.config.KVPair import KVPair
@@ -86,81 +106,83 @@
 from ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata
 from ntnx_networking_py_client.models.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel
 from ntnx_networking_py_client.models.common.v1.stats.DownSamplingOperator import DownSamplingOperator
 from ntnx_networking_py_client.models.networking.v4.config.Address import Address
 from ntnx_networking_py_client.models.networking.v4.config.AddressType import AddressType
 from ntnx_networking_py_client.models.networking.v4.config.AddressTypeObject import AddressTypeObject
 from ntnx_networking_py_client.models.networking.v4.config.Anc import Anc
-from ntnx_networking_py_client.models.networking.v4.config.AncConfigApiResponse import AncConfigApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.AssignedAddress import AssignedAddress
 from ntnx_networking_py_client.models.networking.v4.config.AuthenticationAlgorithm import AuthenticationAlgorithm
 from ntnx_networking_py_client.models.networking.v4.config.AuthenticationType import AuthenticationType
 from ntnx_networking_py_client.models.networking.v4.config.AuthorizationData import AuthorizationData
+from ntnx_networking_py_client.models.networking.v4.config.AwsConfig import AwsConfig
+from ntnx_networking_py_client.models.networking.v4.config.AwsExternalSubnetConfig import AwsExternalSubnetConfig
+from ntnx_networking_py_client.models.networking.v4.config.AwsSubnetConfig import AwsSubnetConfig
 from ntnx_networking_py_client.models.networking.v4.config.AzureConfig import AzureConfig
 from ntnx_networking_py_client.models.networking.v4.config.AzureExternalSubnetBinding import AzureExternalSubnetBinding
 from ntnx_networking_py_client.models.networking.v4.config.AzureExternalSubnetConfig import AzureExternalSubnetConfig
 from ntnx_networking_py_client.models.networking.v4.config.BgpConfig import BgpConfig
 from ntnx_networking_py_client.models.networking.v4.config.BgpInfo import BgpInfo
 from ntnx_networking_py_client.models.networking.v4.config.BgpSession import BgpSession
-from ntnx_networking_py_client.models.networking.v4.config.BgpSessionApiResponse import BgpSessionApiResponse
-from ntnx_networking_py_client.models.networking.v4.config.BgpSessionListApiResponse import BgpSessionListApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.BgpSessionProjection import BgpSessionProjection
 from ntnx_networking_py_client.models.networking.v4.config.BondModeType import BondModeType
 from ntnx_networking_py_client.models.networking.v4.config.Bridge import Bridge
 from ntnx_networking_py_client.models.networking.v4.config.BridgeProjection import BridgeProjection
 from ntnx_networking_py_client.models.networking.v4.config.Capability import Capability
 from ntnx_networking_py_client.models.networking.v4.config.CloudNetwork import CloudNetwork
-from ntnx_networking_py_client.models.networking.v4.config.CloudNetworkApiResponse import CloudNetworkApiResponse
-from ntnx_networking_py_client.models.networking.v4.config.CloudNetworkListApiResponse import CloudNetworkListApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.CloudSubstrate import CloudSubstrate
 from ntnx_networking_py_client.models.networking.v4.config.Cluster import Cluster
 from ntnx_networking_py_client.models.networking.v4.config.ClusterCapability import ClusterCapability
-from ntnx_networking_py_client.models.networking.v4.config.ClusterCapabilityApiResponse import ClusterCapabilityApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.ClusterFlowStatus import ClusterFlowStatus
-from ntnx_networking_py_client.models.networking.v4.config.ClusterFlowStatusApiResponse import ClusterFlowStatusApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.ClusterStatus import ClusterStatus
 from ntnx_networking_py_client.models.networking.v4.config.ControllerStatus import ControllerStatus
 from ntnx_networking_py_client.models.networking.v4.config.DefaultVlanStack import DefaultVlanStack
 from ntnx_networking_py_client.models.networking.v4.config.DhcpOptions import DhcpOptions
 from ntnx_networking_py_client.models.networking.v4.config.DpdConfig import DpdConfig
 from ntnx_networking_py_client.models.networking.v4.config.DpdOperation import DpdOperation
 from ntnx_networking_py_client.models.networking.v4.config.EncryptionAlgorithm import EncryptionAlgorithm
 from ntnx_networking_py_client.models.networking.v4.config.ExportScope import ExportScope
 from ntnx_networking_py_client.models.networking.v4.config.ExporterProtocol import ExporterProtocol
 from ntnx_networking_py_client.models.networking.v4.config.ExternalSubnet import ExternalSubnet
 from ntnx_networking_py_client.models.networking.v4.config.FloatingIPAddress import FloatingIPAddress
 from ntnx_networking_py_client.models.networking.v4.config.FloatingIPv4Address import FloatingIPv4Address
 from ntnx_networking_py_client.models.networking.v4.config.FloatingIPv6Address import FloatingIPv6Address
 from ntnx_networking_py_client.models.networking.v4.config.FloatingIp import FloatingIp
-from ntnx_networking_py_client.models.networking.v4.config.FloatingIpApiResponse import FloatingIpApiResponse
-from ntnx_networking_py_client.models.networking.v4.config.FloatingIpListApiResponse import FloatingIpListApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.FloatingIpProjection import FloatingIpProjection
 from ntnx_networking_py_client.models.networking.v4.config.FlowGateway import FlowGateway
-from ntnx_networking_py_client.models.networking.v4.config.FlowGatewayApiResponse import FlowGatewayApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.FlowGatewayKeepAlive import FlowGatewayKeepAlive
-from ntnx_networking_py_client.models.networking.v4.config.FlowGatewayKeepAliveApiResponse import FlowGatewayKeepAliveApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.FlowGatewayKeepAliveRequestSpec import FlowGatewayKeepAliveRequestSpec
-from ntnx_networking_py_client.models.networking.v4.config.FlowGatewayListApiResponse import FlowGatewayListApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.FlowGatewayState import FlowGatewayState
 from ntnx_networking_py_client.models.networking.v4.config.FlowGatewayStatus import FlowGatewayStatus
 from ntnx_networking_py_client.models.networking.v4.config.Gateway import Gateway
-from ntnx_networking_py_client.models.networking.v4.config.GatewayApiResponse import GatewayApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.GatewayDeployment import GatewayDeployment
-from ntnx_networking_py_client.models.networking.v4.config.GatewayListApiResponse import GatewayListApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.GatewayInterface import GatewayInterface
 from ntnx_networking_py_client.models.networking.v4.config.GatewayManagementInterface import GatewayManagementInterface
 from ntnx_networking_py_client.models.networking.v4.config.GatewayNic import GatewayNic
 from ntnx_networking_py_client.models.networking.v4.config.GatewayNodeReference import GatewayNodeReference
 from ntnx_networking_py_client.models.networking.v4.config.GatewayProjection import GatewayProjection
 from ntnx_networking_py_client.models.networking.v4.config.GatewayRole import GatewayRole
+from ntnx_networking_py_client.models.networking.v4.config.GetBgpSessionApiResponse import GetBgpSessionApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.GetFloatingIpApiResponse import GetFloatingIpApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.GetGatewayApiResponse import GetGatewayApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.GetIPFIXExporterApiResponse import GetIPFIXExporterApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.GetLayer2StretchApiResponse import GetLayer2StretchApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.GetNetworkControllerApiResponse import GetNetworkControllerApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.GetRouteTableApiResponse import GetRouteTableApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.GetRoutingPolicyApiResponse import GetRoutingPolicyApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.GetSubnetApiResponse import GetSubnetApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.GetTrafficMirrorApiResponse import GetTrafficMirrorApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.GetUplinkBondApiResponse import GetUplinkBondApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.GetVirtualSwitchApiResponse import GetVirtualSwitchApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.GetVpcApiResponse import GetVpcApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.GetVpnConnectionApiResponse import GetVpnConnectionApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.Host import Host
 from ntnx_networking_py_client.models.networking.v4.config.ICMPObject import ICMPObject
 from ntnx_networking_py_client.models.networking.v4.config.IPConfig import IPConfig
 from ntnx_networking_py_client.models.networking.v4.config.IPFIXExporter import IPFIXExporter
-from ntnx_networking_py_client.models.networking.v4.config.IPFIXExporterApiResponse import IPFIXExporterApiResponse
-from ntnx_networking_py_client.models.networking.v4.config.IPFIXExporterListApiResponse import IPFIXExporterListApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.IPPoolUsage import IPPoolUsage
 from ntnx_networking_py_client.models.networking.v4.config.IPSubnet import IPSubnet
 from ntnx_networking_py_client.models.networking.v4.config.IPUsage import IPUsage
 from ntnx_networking_py_client.models.networking.v4.config.IPv4Config import IPv4Config
 from ntnx_networking_py_client.models.networking.v4.config.IPv4Pool import IPv4Pool
 from ntnx_networking_py_client.models.networking.v4.config.IPv4Subnet import IPv4Subnet
 from ntnx_networking_py_client.models.networking.v4.config.IPv6Config import IPv6Config
@@ -168,39 +190,50 @@
 from ntnx_networking_py_client.models.networking.v4.config.IPv6Subnet import IPv6Subnet
 from ntnx_networking_py_client.models.networking.v4.config.IbgpConfig import IbgpConfig
 from ntnx_networking_py_client.models.networking.v4.config.InternalRoutingConfig import InternalRoutingConfig
 from ntnx_networking_py_client.models.networking.v4.config.IpReserveSpec import IpReserveSpec
 from ntnx_networking_py_client.models.networking.v4.config.IpUnreserveSpec import IpUnreserveSpec
 from ntnx_networking_py_client.models.networking.v4.config.IpsecConfig import IpsecConfig
 from ntnx_networking_py_client.models.networking.v4.config.Layer2Stretch import Layer2Stretch
-from ntnx_networking_py_client.models.networking.v4.config.Layer2StretchApiResponse import Layer2StretchApiResponse
-from ntnx_networking_py_client.models.networking.v4.config.Layer2StretchListApiResponse import Layer2StretchListApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.Layer2StretchRelatedEntities import Layer2StretchRelatedEntities
-from ntnx_networking_py_client.models.networking.v4.config.Layer2StretchRelatedEntitiesApiResponse import Layer2StretchRelatedEntitiesApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.Layer2StretchSubnetInfo import Layer2StretchSubnetInfo
 from ntnx_networking_py_client.models.networking.v4.config.Layer2StretchVpnConnectionInfo import Layer2StretchVpnConnectionInfo
 from ntnx_networking_py_client.models.networking.v4.config.Layer2StretchVtepGatewayInfo import Layer2StretchVtepGatewayInfo
 from ntnx_networking_py_client.models.networking.v4.config.LayerFourProtocolObject import LayerFourProtocolObject
 from ntnx_networking_py_client.models.networking.v4.config.LearnedAddress import LearnedAddress
+from ntnx_networking_py_client.models.networking.v4.config.ListBgpSessionsApiResponse import ListBgpSessionsApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.ListClusterCapabilitiesApiResponse import ListClusterCapabilitiesApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.ListFloatingIpsApiResponse import ListFloatingIpsApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.ListGatewaysApiResponse import ListGatewaysApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.ListIPFIXExportersApiResponse import ListIPFIXExportersApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.ListLayer2StretchRelatedEntitiesApiResponse import ListLayer2StretchRelatedEntitiesApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.ListLayer2StretchesApiResponse import ListLayer2StretchesApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.ListNetworkControllersApiResponse import ListNetworkControllersApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.ListNodeSchedulableStatusesApiResponse import ListNodeSchedulableStatusesApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.ListRouteTablesApiResponse import ListRouteTablesApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.ListRoutingPoliciesApiResponse import ListRoutingPoliciesApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.ListSubnetsApiResponse import ListSubnetsApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.ListTrafficMirrorsApiResponse import ListTrafficMirrorsApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.ListUplinkBondsApiResponse import ListUplinkBondsApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.ListVirtualSwitchesApiResponse import ListVirtualSwitchesApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.ListVpcVirtualSwitchMappingsApiResponse import ListVpcVirtualSwitchMappingsApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.ListVpcsApiResponse import ListVpcsApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.ListVpnConnectionsApiResponse import ListVpnConnectionsApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.ListVpnVendorConfigsApiResponse import ListVpnVendorConfigsApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.LocalBgpGateway import LocalBgpGateway
 from ntnx_networking_py_client.models.networking.v4.config.LocalBgpService import LocalBgpService
 from ntnx_networking_py_client.models.networking.v4.config.LocalNetworkServices import LocalNetworkServices
 from ntnx_networking_py_client.models.networking.v4.config.LocalVpnService import LocalVpnService
 from ntnx_networking_py_client.models.networking.v4.config.LocalVtepService import LocalVtepService
 from ntnx_networking_py_client.models.networking.v4.config.MigrationState import MigrationState
 from ntnx_networking_py_client.models.networking.v4.config.NetworkCloudConfig import NetworkCloudConfig
-from ntnx_networking_py_client.models.networking.v4.config.NetworkCloudConfigApiResponse import NetworkCloudConfigApiResponse
-from ntnx_networking_py_client.models.networking.v4.config.NetworkCloudConfigListApiResponse import NetworkCloudConfigListApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.NetworkController import NetworkController
-from ntnx_networking_py_client.models.networking.v4.config.NetworkControllerApiResponse import NetworkControllerApiResponse
-from ntnx_networking_py_client.models.networking.v4.config.NetworkControllerListApiResponse import NetworkControllerListApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.NetworkingBaseModel import NetworkingBaseModel
 from ntnx_networking_py_client.models.networking.v4.config.NexthopType import NexthopType
 from ntnx_networking_py_client.models.networking.v4.config.NodeSchedulableStatus import NodeSchedulableStatus
-from ntnx_networking_py_client.models.networking.v4.config.NodeSchedulableStatusApiResponse import NodeSchedulableStatusApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.NodeSchedulableStatusProjection import NodeSchedulableStatusProjection
 from ntnx_networking_py_client.models.networking.v4.config.OspfConfig import OspfConfig
 from ntnx_networking_py_client.models.networking.v4.config.PortRange import PortRange
 from ntnx_networking_py_client.models.networking.v4.config.PrivateIpAssociation import PrivateIpAssociation
 from ntnx_networking_py_client.models.networking.v4.config.ProtocolNumberObject import ProtocolNumberObject
 from ntnx_networking_py_client.models.networking.v4.config.ProtocolType import ProtocolType
 from ntnx_networking_py_client.models.networking.v4.config.PublicIpMapping import PublicIpMapping
@@ -213,87 +246,73 @@
 from ntnx_networking_py_client.models.networking.v4.config.RemoteVtepStretchStatus import RemoteVtepStretchStatus
 from ntnx_networking_py_client.models.networking.v4.config.RerouteFallbackAction import RerouteFallbackAction
 from ntnx_networking_py_client.models.networking.v4.config.RerouteParam import RerouteParam
 from ntnx_networking_py_client.models.networking.v4.config.ReserveType import ReserveType
 from ntnx_networking_py_client.models.networking.v4.config.ReservedAddress import ReservedAddress
 from ntnx_networking_py_client.models.networking.v4.config.Route import Route
 from ntnx_networking_py_client.models.networking.v4.config.RouteTable import RouteTable
-from ntnx_networking_py_client.models.networking.v4.config.RouteTableApiResponse import RouteTableApiResponse
-from ntnx_networking_py_client.models.networking.v4.config.RouteTableListApiResponse import RouteTableListApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.RoutingPolicy import RoutingPolicy
 from ntnx_networking_py_client.models.networking.v4.config.RoutingPolicyAction import RoutingPolicyAction
 from ntnx_networking_py_client.models.networking.v4.config.RoutingPolicyActionType import RoutingPolicyActionType
-from ntnx_networking_py_client.models.networking.v4.config.RoutingPolicyApiResponse import RoutingPolicyApiResponse
-from ntnx_networking_py_client.models.networking.v4.config.RoutingPolicyListApiResponse import RoutingPolicyListApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.RoutingPolicyMatchCondition import RoutingPolicyMatchCondition
+from ntnx_networking_py_client.models.networking.v4.config.RoutingPolicyProjection import RoutingPolicyProjection
 from ntnx_networking_py_client.models.networking.v4.config.RoutingPolicyRule import RoutingPolicyRule
 from ntnx_networking_py_client.models.networking.v4.config.ScopeType import ScopeType
 from ntnx_networking_py_client.models.networking.v4.config.SiteParams import SiteParams
 from ntnx_networking_py_client.models.networking.v4.config.State import State
 from ntnx_networking_py_client.models.networking.v4.config.Status import Status
 from ntnx_networking_py_client.models.networking.v4.config.StretchConnectionType import StretchConnectionType
 from ntnx_networking_py_client.models.networking.v4.config.StretchStatus import StretchStatus
 from ntnx_networking_py_client.models.networking.v4.config.Subnet import Subnet
-from ntnx_networking_py_client.models.networking.v4.config.SubnetApiResponse import SubnetApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.SubnetInfo import SubnetInfo
-from ntnx_networking_py_client.models.networking.v4.config.SubnetListApiResponse import SubnetListApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.SubnetProjection import SubnetProjection
 from ntnx_networking_py_client.models.networking.v4.config.SubnetType import SubnetType
 from ntnx_networking_py_client.models.networking.v4.config.TaskReferenceApiResponse import TaskReferenceApiResponse as ConfigTaskReferenceApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.TrafficMirror import TrafficMirror
-from ntnx_networking_py_client.models.networking.v4.config.TrafficMirrorApiResponse import TrafficMirrorApiResponse
-from ntnx_networking_py_client.models.networking.v4.config.TrafficMirrorListApiResponse import TrafficMirrorListApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.TrafficMirrorPort import TrafficMirrorPort
 from ntnx_networking_py_client.models.networking.v4.config.TrafficMirrorPortNicType import TrafficMirrorPortNicType
 from ntnx_networking_py_client.models.networking.v4.config.TrafficMirrorSourcePort import TrafficMirrorSourcePort
 from ntnx_networking_py_client.models.networking.v4.config.TrafficMirrorSourcePortDirection import TrafficMirrorSourcePortDirection
 from ntnx_networking_py_client.models.networking.v4.config.UnreserveType import UnreserveType
 from ntnx_networking_py_client.models.networking.v4.config.UplinkBond import UplinkBond
-from ntnx_networking_py_client.models.networking.v4.config.UplinkBondApiResponse import UplinkBondApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.UplinkBondLacpStatus import UplinkBondLacpStatus
-from ntnx_networking_py_client.models.networking.v4.config.UplinkBondListApiResponse import UplinkBondListApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.UplinkBondType import UplinkBondType
 from ntnx_networking_py_client.models.networking.v4.config.UplinkBondVirtualSwitchInfo import UplinkBondVirtualSwitchInfo
 from ntnx_networking_py_client.models.networking.v4.config.VirtualSwitch import VirtualSwitch
-from ntnx_networking_py_client.models.networking.v4.config.VirtualSwitchApiResponse import VirtualSwitchApiResponse
-from ntnx_networking_py_client.models.networking.v4.config.VirtualSwitchListApiResponse import VirtualSwitchListApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.VirtualSwitchProjection import VirtualSwitchProjection
 from ntnx_networking_py_client.models.networking.v4.config.VlanSubnetMigrationSpec import VlanSubnetMigrationSpec
 from ntnx_networking_py_client.models.networking.v4.config.Vm import Vm
 from ntnx_networking_py_client.models.networking.v4.config.VmNic import VmNic
 from ntnx_networking_py_client.models.networking.v4.config.VmNicAssociation import VmNicAssociation
 from ntnx_networking_py_client.models.networking.v4.config.VmNicProjection import VmNicProjection
 from ntnx_networking_py_client.models.networking.v4.config.VmProjection import VmProjection
 from ntnx_networking_py_client.models.networking.v4.config.VnicMigrationItem import VnicMigrationItem
+from ntnx_networking_py_client.models.networking.v4.config.VnicMigrationItemSpec import VnicMigrationItemSpec
 from ntnx_networking_py_client.models.networking.v4.config.VnicMigrationSpec import VnicMigrationSpec
 from ntnx_networking_py_client.models.networking.v4.config.Vpc import Vpc
-from ntnx_networking_py_client.models.networking.v4.config.VpcApiResponse import VpcApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.VpcDhcpOptions import VpcDhcpOptions
-from ntnx_networking_py_client.models.networking.v4.config.VpcListApiResponse import VpcListApiResponse
+from ntnx_networking_py_client.models.networking.v4.config.VpcName import VpcName
+from ntnx_networking_py_client.models.networking.v4.config.VpcNameProjection import VpcNameProjection
 from ntnx_networking_py_client.models.networking.v4.config.VpcProjection import VpcProjection
+from ntnx_networking_py_client.models.networking.v4.config.VpcType import VpcType
 from ntnx_networking_py_client.models.networking.v4.config.VpcVirtualSwitchMapping import VpcVirtualSwitchMapping
-from ntnx_networking_py_client.models.networking.v4.config.VpcVirtualSwitchMappingsApiResponse import VpcVirtualSwitchMappingsApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.VpnAppliance import VpnAppliance
 from ntnx_networking_py_client.models.networking.v4.config.VpnConnection import VpnConnection
-from ntnx_networking_py_client.models.networking.v4.config.VpnConnectionApiResponse import VpnConnectionApiResponse
-from ntnx_networking_py_client.models.networking.v4.config.VpnConnectionListApiResponse import VpnConnectionListApiResponse
-from ntnx_networking_py_client.models.networking.v4.config.VpnVendorListApiResponse import VpnVendorListApiResponse
 from ntnx_networking_py_client.models.networking.v4.config.Vtep import Vtep
 from ntnx_networking_py_client.models.networking.v4.error.AppMessage import AppMessage
 from ntnx_networking_py_client.models.networking.v4.error.ErrorResponse import ErrorResponse
 from ntnx_networking_py_client.models.networking.v4.error.SchemaValidationError import SchemaValidationError
 from ntnx_networking_py_client.models.networking.v4.error.SchemaValidationErrorMessage import SchemaValidationErrorMessage
+from ntnx_networking_py_client.models.networking.v4.stats.GetLayer2StretchStatsApiResponse import GetLayer2StretchStatsApiResponse
+from ntnx_networking_py_client.models.networking.v4.stats.GetTrafficMirrorStatsApiResponse import GetTrafficMirrorStatsApiResponse
+from ntnx_networking_py_client.models.networking.v4.stats.GetVpcNsStatsApiResponse import GetVpcNsStatsApiResponse
+from ntnx_networking_py_client.models.networking.v4.stats.GetVpnConnectionStatsApiResponse import GetVpnConnectionStatsApiResponse
 from ntnx_networking_py_client.models.networking.v4.stats.Layer2StretchStats import Layer2StretchStats
-from ntnx_networking_py_client.models.networking.v4.stats.Layer2StretchStatsApiResponse import Layer2StretchStatsApiResponse
 from ntnx_networking_py_client.models.networking.v4.stats.RoutingPolicyClearCountersSpec import RoutingPolicyClearCountersSpec
 from ntnx_networking_py_client.models.networking.v4.stats.StatsQueryResponseBase import StatsQueryResponseBase
 from ntnx_networking_py_client.models.networking.v4.stats.TaskReferenceApiResponse import TaskReferenceApiResponse as StatsTaskReferenceApiResponse
 from ntnx_networking_py_client.models.networking.v4.stats.TrafficMirrorState import TrafficMirrorState
 from ntnx_networking_py_client.models.networking.v4.stats.TrafficMirrorStats import TrafficMirrorStats
-from ntnx_networking_py_client.models.networking.v4.stats.TrafficMirrorStatsApiResponse import TrafficMirrorStatsApiResponse
 from ntnx_networking_py_client.models.networking.v4.stats.TrafficMirrorStatsData import TrafficMirrorStatsData
 from ntnx_networking_py_client.models.networking.v4.stats.VpcNsStats import VpcNsStats
-from ntnx_networking_py_client.models.networking.v4.stats.VpcNsStatsApiResponse import VpcNsStatsApiResponse
 from ntnx_networking_py_client.models.networking.v4.stats.VpnConnectionStats import VpnConnectionStats
-from ntnx_networking_py_client.models.networking.v4.stats.VpnConnectionStatsApiResponse import VpnConnectionStatsApiResponse
 from ntnx_networking_py_client.models.prism.v4.config.TaskReference import TaskReference
-from ntnx_networking_py_client.api_response import ApiResponse
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/common/v1/config/EntityReference.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/common/v1/config/EntityReference.py`

 * *Files 3% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.EntityType import EntityType  # noqa: F401,E501
 
 class EntityReference(object):
 
     """
 
     :param ext_id: (:attr:`ext_id`) 
@@ -81,33 +82,33 @@
             self.__entity_type = entity_type
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'common.v1.config.EntityReference'
 
-    def _initialize_fq_object_type(self):
-        return 'common.v1.r0.a3.config.EntityReference'
+    def _initialize_object_version(self):
+        return 'v1.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -216,28 +217,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/common/v1/config/EntityType.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/common/v1/config/EntityType.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
 class EntityType(object):
 
     """
 
 
     Allowed enum values:
@@ -81,33 +82,33 @@
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'common.v1.config.EntityType'
 
-    def _initialize_fq_object_type(self):
-        return 'common.v1.r0.a3.config.EntityType'
+    def _initialize_object_version(self):
+        return 'v1.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -122,27 +123,32 @@
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/common/v1/config/Flag.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/Vm.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,96 +3,90 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class Flag(object):
+class Vm(object):
 
-    """Many entities in the Nutanix APIs carry flags.  This object captures all the flags associated with that entity through this object.  The field that hosts this type of object must have an attribute called x-bounded-map-keys that tells which flags are actually present for that entity. 
+    """Virtual Machine properties
 
-    :param name: (:attr:`name`) 
+    :param name: (:attr:`name`) Virtual Machine name
     :type name: 
-    :param value: (:attr:`value`) 
-    :type value: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'name': 'str',
-        'value': 'bool',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'name': 'name',
-        'value': 'value',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, name=None, value=False, *args, **kwargs):  # noqa: E501
+    def __init__(self, name=None, *args, **kwargs):  # noqa: E501
         self.__name = None
-        self.__value = None
         self.discriminator = None
         if name is not None:
             self.__name = name
-        if value is not None:
-            self.__value = value
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'common.v1.config.Flag'
+        return 'networking.v4.config.Vm'
 
-    def _initialize_fq_object_type(self):
-        return 'common.v1.r0.a3.config.Flag'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -101,44 +95,28 @@
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def name(self):
         """
-        
+        Virtual Machine name
 
         :type:
 
                 :class:`~str`
         """  # noqa: E501
         return self.__name
 
     @name.setter
     def name(self, name):
 
         self.__name = name
 
     @property
-    def value(self):
-        """
-        
-
-        :type:
-
-                :class:`~bool`
-        """  # noqa: E501
-        return self.__value
-
-    @value.setter
-    def value(self, value):
-
-        self.__value = value
-
-    @property
     def _reserved(self):
         """
         
 
         :type:
             dict(str, :class:`~object`)
         """  # noqa: E501
@@ -169,37 +147,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(Flag, dict):
+        if issubclass(Vm, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -211,15 +194,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, Flag):
+        if not isinstance(other, Vm):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/common/v1/config/IPAddress.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/common/v1/config/IPAddress.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.IPv4Address import IPv4Address  # noqa: F401,E501
 from ntnx_networking_py_client.models.common.v1.config.IPv6Address import IPv6Address  # noqa: F401,E501
 
 class IPAddress(object):
 
     """An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format. 
 
@@ -68,33 +69,33 @@
             self.__ipv6 = ipv6
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'common.v1.config.IPAddress'
 
-    def _initialize_fq_object_type(self):
-        return 'common.v1.r0.a3.config.IPAddress'
+    def _initialize_object_version(self):
+        return 'v1.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -169,28 +170,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/common/v1/config/IPv4Address.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/FloatingIPv4Address.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,33 +3,34 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class IPv4Address(object):
+class FloatingIPv4Address(object):
 
     """
 
     :param value: (:attr:`value`) 
     :type value: 
-    :param prefix_length: (:attr:`prefix_length`) The prefix length of the network to which this host IPv4 address belongs.  (**Default** 32)
+    :param prefix_length: (:attr:`prefix_length`) Prefix length of the network to which this host IPv4 address belongs. (**Default** 32)
     :type prefix_length: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
@@ -64,35 +65,35 @@
             self.__value = value
         if prefix_length is not None:
             self.__prefix_length = prefix_length
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'common.v1.config.IPv4Address'
+        return 'networking.v4.config.FloatingIPv4Address'
 
-    def _initialize_fq_object_type(self):
-        return 'common.v1.r0.a3.config.IPv4Address'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -119,15 +120,15 @@
             raise ValueError(r"Invalid value for `value`, must be a follow pattern or equal to `/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/`")  # noqa: E501
 
         self.__value = value
 
     @property
     def prefix_length(self):
         """
-        The prefix length of the network to which this host IPv4 address belongs. 
+        Prefix length of the network to which this host IPv4 address belongs.
 
         :type:
 
                 :class:`~int`
         """  # noqa: E501
         return self.__prefix_length
 
@@ -175,37 +176,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(IPv4Address, dict):
+        if issubclass(FloatingIPv4Address, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -217,15 +223,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, IPv4Address):
+        if not isinstance(other, FloatingIPv4Address):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/common/v1/config/IPv6Address.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/common/v1/config/IPv6Address.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
 class IPv6Address(object):
 
     """
 
     :param value: (:attr:`value`) 
     :type value: 
@@ -66,33 +67,33 @@
             self.__prefix_length = prefix_length
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'common.v1.config.IPv6Address'
 
-    def _initialize_fq_object_type(self):
-        return 'common.v1.r0.a3.config.IPv6Address'
+    def _initialize_object_version(self):
+        return 'v1.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -175,28 +176,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/common/v1/config/KVPair.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/common/v1/config/KVPair.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_networking_py_client.models
 from ntnx_networking_py_client.models.OneOfcommon.v1.config.KVPairvalue import KVPairvalue  # noqa: F401,E501
 
 class KVPair(object):
 
     """A map describing a set of keys and their corresponding values. 
 
@@ -68,33 +69,33 @@
             self.__value = value
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'common.v1.config.KVPair'
 
-    def _initialize_fq_object_type(self):
-        return 'common.v1.r0.a3.config.KVPair'
+    def _initialize_object_version(self):
+        return 'v1.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -174,30 +175,35 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/common/v1/config/Message.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/common/v1/config/Message.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.MessageSeverity import MessageSeverity  # noqa: F401,E501
 
 class Message(object):
 
     """
 
     :param code: (:attr:`code`) A code that uniquely identifies a message. 
@@ -81,33 +82,33 @@
             self.__severity = severity
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'common.v1.config.Message'
 
-    def _initialize_fq_object_type(self):
-        return 'common.v1.r0.a3.config.Message'
+    def _initialize_object_version(self):
+        return 'v1.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -215,28 +216,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/common/v1/config/MessageSeverity.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/VpcType.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,73 +3,72 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class MessageSeverity(object):
+class VpcType(object):
 
-    """The message severity. 
+    """Type of VPC.
 
 
     Allowed enum values:
 
         - _UNKNOWN
         - _REDACTED
-        - INFO
-        - WARNING
-        - ERROR
+        - REGULAR
+        - TRANSIT
     """
     _UNKNOWN = "$UNKNOWN"
     _REDACTED = "$REDACTED"
-    INFO = "INFO"
-    WARNING = "WARNING"
-    ERROR = "ERROR"
+    REGULAR = "REGULAR"
+    TRANSIT = "TRANSIT"
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'common.v1.config.MessageSeverity'
+        return 'networking.v4.config.VpcType'
 
-    def _initialize_fq_object_type(self):
-        return 'common.v1.r0.a3.config.MessageSeverity'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -84,36 +83,41 @@
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(MessageSeverity, dict):
+        if issubclass(VpcType, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -125,15 +129,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, MessageSeverity):
+        if not isinstance(other, VpcType):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/common/v1/config/Metadata.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/common/v1/config/Metadata.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
 class Metadata(object):
 
     """Metadata associated with this resource. 
 
     :param owner_reference_id: (:attr:`owner_reference_id`) A globally unique identifier that represents the owner of this resource. 
     :type owner_reference_id: 
@@ -87,33 +88,33 @@
             self.__category_ids = category_ids
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'common.v1.config.Metadata'
 
-    def _initialize_fq_object_type(self):
-        return 'common.v1.r0.a3.config.Metadata'
+    def _initialize_object_version(self):
+        return 'v1.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -245,28 +246,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/common/v1/config/TenantAwareModel.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/common/v1/config/TenantAwareModel.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,31 +3,32 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
 class TenantAwareModel(object):
 
     """A model base class whose instances are bound to a specific tenant.  This model adds a tenantId to the base model class that it extends and is automatically set by the server. 
 
-    :param tenant_id: (:attr:`tenant_id`) A globally unique identifier that represents the tenant that owns this entity.  It is automatically assigned by the system and is immutable from an API consumer perspective (some use cases may cause this Id to change - for instance a use case may require the transfer of ownership of the entity, but these cases are handled automatically on the server). 
+    :param tenant_id: (:attr:`tenant_id`) A globally unique identifier that represents the tenant that owns this entity. The system automatically assigns it, and it and is immutable from an API consumer perspective (some use cases may cause this Id to change - For instance, a use case may require the transfer of ownership of the entity, but these cases are handled automatically on the server). 
     :type tenant_id: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
@@ -59,33 +60,33 @@
             self.__tenant_id = tenant_id
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'common.v1.config.TenantAwareModel'
 
-    def _initialize_fq_object_type(self):
-        return 'common.v1.r0.a3.config.TenantAwareModel'
+    def _initialize_object_version(self):
+        return 'v1.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -94,15 +95,15 @@
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def tenant_id(self):
         """
-        A globally unique identifier that represents the tenant that owns this entity.  It is automatically assigned by the system and is immutable from an API consumer perspective (some use cases may cause this Id to change - for instance a use case may require the transfer of ownership of the entity, but these cases are handled automatically on the server). 
+        A globally unique identifier that represents the tenant that owns this entity. The system automatically assigns it, and it and is immutable from an API consumer perspective (some use cases may cause this Id to change - For instance, a use case may require the transfer of ownership of the entity, but these cases are handled automatically on the server). 
 
         :type:
 
                 :class:`~str`
         """  # noqa: E501
         return self.__tenant_id
 
@@ -148,28 +149,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/common/v1/response/ApiLink.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/GetRoutingPolicyApiResponse.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,140 +3,143 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-
-class ApiLink(object):
-
-    """A HATEOAS style link for the response.  Each link contains a user friendly name identifying the link and an address for retrieving the particular resource. 
-
-    :param href: (:attr:`href`) The URL at which the entity described by the link can be accessed. 
-    :type href: 
-    :param rel: (:attr:`rel`) A name that identifies the relationship of the link to the object that is returned by the URL.  The unique value of \"self\" identifies the URL for the object. 
-    :type rel: 
+from pathlib import Path
+import ntnx_networking_py_client.models
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.GetRoutingPolicyApiResponsedata import GetRoutingPolicyApiResponsedata  # noqa: F401,E501
+from ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class GetRoutingPolicyApiResponse(object):
+
+    """REST response for all response codes in API path /networking/v4.0.b1/config/routing-policies/{extId} Get operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'href': 'str',
-        'rel': 'str',
+        'metadata': 'common.v1.response.ApiResponseMetadata',
+        'data': 'OneOfnetworking.v4.config.GetRoutingPolicyApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'href': 'href',
-        'rel': 'rel',
+        'metadata': 'metadata',
+        'data': 'data',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, href=None, rel=None, *args, **kwargs):  # noqa: E501
-        self.__href = None
-        self.__rel = None
+    def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
+        self.__metadata = None
+        self.__data = None
         self.discriminator = None
-        if href is not None:
-            self.__href = href
-        if rel is not None:
-            self.__rel = rel
+        if metadata is not None:
+            self.__metadata = metadata
+        if data is not None:
+            self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'common.v1.response.ApiLink'
+        return 'networking.v4.config.GetRoutingPolicyApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'common.v1.r0.a3.response.ApiLink'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def href(self):
+    def metadata(self):
         """
-        The URL at which the entity described by the link can be accessed. 
+        
 
         :type:
-
-                :class:`~str`
+            :class:`~ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata`
         """  # noqa: E501
-        return self.__href
+        return self.__metadata
 
-    @href.setter
-    def href(self, href):
+    @metadata.setter
+    def metadata(self, metadata):
 
-        self.__href = href
+        self.__metadata = metadata
 
     @property
-    def rel(self):
+    def data(self):
         """
-        A name that identifies the relationship of the link to the object that is returned by the URL.  The unique value of \"self\" identifies the URL for the object. 
+        
 
         :type:
+                :class:`~ntnx_networking_py_client.models.networking.v4.config.RoutingPolicy` | 
+                :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse`
+                    """  # noqa: E501
+        return self.__data
 
-                :class:`~str`
-        """  # noqa: E501
-        return self.__rel
-
-    @rel.setter
-    def rel(self, rel):
+    @data.setter
+    def data(self, data):
 
-        self.__rel = rel
+        self.__data = data
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -169,37 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
+            if attr_type.startswith('OneOf'):
+                type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ApiLink, dict):
+        if issubclass(GetRoutingPolicyApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -211,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ApiLink):
+        if not isinstance(other, GetRoutingPolicyApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/common/v1/response/ApiResponseMetadata.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/common/v1/response/ApiResponseMetadata.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,35 +3,36 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.Flag import Flag  # noqa: F401,E501
 from ntnx_networking_py_client.models.common.v1.config.KVPair import KVPair  # noqa: F401,E501
 from ntnx_networking_py_client.models.common.v1.config.Message import Message  # noqa: F401,E501
 from ntnx_networking_py_client.models.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
 
 class ApiResponseMetadata(object):
 
     """The metadata associated with an API response. This value is always present and minimally contains the self-link for the API request that produced this response. It also contains pagination data for the paginated requests. 
 
-    :param flags: (:attr:`flags`) An array of flags that may indicate the status of the response. For example a flag with name isPaginated and value false indicates that the response is not paginated. 
+    :param flags: (:attr:`flags`) An array of flags that may indicate the status of the response. For example, a flag with the name 'isPaginated' and value 'false', indicates that the response is not paginated. 
     :type flags: 
     :param links: (:attr:`links`) An array of HATEOAS style links for the response that may also include pagination links for list operations. 
     :type links: 
     :param total_available_results: (:attr:`total_available_results`) The total number of entities that are available on the server for this type. 
     :type total_available_results: 
     :param messages: (:attr:`messages`) Information, Warning or Error messages that might provide additional contextual information related to the operation. 
     :type messages: 
@@ -91,33 +92,33 @@
             self.__extra_info = extra_info
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'common.v1.response.ApiResponseMetadata'
 
-    def _initialize_fq_object_type(self):
-        return 'common.v1.r0.a3.response.ApiResponseMetadata'
+    def _initialize_object_version(self):
+        return 'v1.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -126,15 +127,15 @@
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def flags(self):
         """
-        An array of flags that may indicate the status of the response. For example a flag with name isPaginated and value false indicates that the response is not paginated. 
+        An array of flags that may indicate the status of the response. For example, a flag with the name 'isPaginated' and value 'false', indicates that the response is not paginated. 
 
         :type:
              list[ :class:`~ntnx_networking_py_client.models.common.v1.config.Flag` ]
         """  # noqa: E501
         return self.__flags
 
     @flags.setter
@@ -238,28 +239,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/common/v1/response/ExternalizableAbstractModel.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/common/v1/response/ExternalizableAbstractModel.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,35 +3,36 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.TenantAwareModel import TenantAwareModel  # noqa: F401,E501
 from ntnx_networking_py_client.models.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
 
 class ExternalizableAbstractModel(TenantAwareModel):
 
-    """A model that represents an object instance that is accessible through an API endpoint.  Instances of this type get an extId field that contains the globally unique identifier for that instance.  Externally accessible instances are always tenant aware and therefore extend the TenantAwareModel 
+    """A model that represents an object instance that is accessible through an API endpoint.  Instances of this type get an extId field that contains the globally unique identifier for that instance.  Externally accessible instances are always tenant aware and, therefore, extend the TenantAwareModel 
 
     :param ext_id: (:attr:`ext_id`) A globally unique identifier of an instance that is suitable for external consumption. 
     :type ext_id: 
-    :param links: (:attr:`links`) A HATEOAS style link for the response.  Each link contains a user friendly name identifying the link and an address for retrieving the particular resource. 
+    :param links: (:attr:`links`) A HATEOAS style link for the response.  Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource. 
     :type links: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
@@ -69,16 +70,16 @@
             self.__ext_id = ext_id
         if links is not None:
             self.__links = links
 
     def _initialize_object_type(self):
         return 'common.v1.response.ExternalizableAbstractModel'
 
-    def _initialize_fq_object_type(self):
-        return 'common.v1.r0.a3.response.ExternalizableAbstractModel'
+    def _initialize_object_version(self):
+        return 'v1.r0.b1'
 
 
     @property
     def ext_id(self):
         """
         A globally unique identifier of an instance that is suitable for external consumption. 
 
@@ -94,15 +95,15 @@
             raise ValueError(r"Invalid value for `ext_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
 
         self.__ext_id = ext_id
 
     @property
     def links(self):
         """
-        A HATEOAS style link for the response.  Each link contains a user friendly name identifying the link and an address for retrieving the particular resource. 
+        A HATEOAS style link for the response.  Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource. 
 
         :type:
              list[ :class:`~ntnx_networking_py_client.models.common.v1.response.ApiLink` ]
         """  # noqa: E501
         return self.__links
 
     @links.setter
@@ -114,28 +115,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/common/v1/stats/DownSamplingOperator.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/GatewayRole.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,79 +3,72 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class DownSamplingOperator(object):
+class GatewayRole(object):
 
-    """The operator to use while performing down-sampling on stats data. Allowed values are SUM, MIN, MAX, AVG, COUNT and LAST.
+    """Local gateway role (acceptor or initiator) in the connection
 
 
     Allowed enum values:
 
         - _UNKNOWN
         - _REDACTED
-        - SUM
-        - MIN
-        - MAX
-        - AVG
-        - COUNT
-        - LAST
+        - INITIATOR: Gateway role to initiate connection.
+        - ACCEPTOR: Gateway role to accept connection.
     """
     _UNKNOWN = "$UNKNOWN"
     _REDACTED = "$REDACTED"
-    SUM = "SUM"
-    MIN = "MIN"
-    MAX = "MAX"
-    AVG = "AVG"
-    COUNT = "COUNT"
-    LAST = "LAST"
+    INITIATOR = "INITIATOR"
+    ACCEPTOR = "ACCEPTOR"
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'common.v1.stats.DownSamplingOperator'
+        return 'networking.v4.config.GatewayRole'
 
-    def _initialize_fq_object_type(self):
-        return 'common.v1.r0.a3.stats.DownSamplingOperator'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -90,36 +83,41 @@
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(DownSamplingOperator, dict):
+        if issubclass(GatewayRole, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -131,15 +129,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, DownSamplingOperator):
+        if not isinstance(other, GatewayRole):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/Address.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/Address.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.IPAddress import IPAddress  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.AssignedAddress import AssignedAddress  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.ReservedAddress import ReservedAddress  # noqa: F401,E501
 
 class Address(object):
 
     """Information pertaining to an assigned or reserved IP address on a subnet.
@@ -97,33 +98,33 @@
             self.__reserved_details = reserved_details
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.Address'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.Address'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -261,28 +262,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/AddressType.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/AddressType.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
 class AddressType(object):
 
     """Address Type like \"EXTERNAL\" or \"ANY\".
 
 
     Allowed enum values:
@@ -43,33 +44,33 @@
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.AddressType'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.AddressType'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -84,27 +85,32 @@
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/AddressTypeObject.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/AddressTypeObject.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.networking.v4.config.AddressType import AddressType  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.IPSubnet import IPSubnet  # noqa: F401,E501
 
 class AddressTypeObject(object):
 
     """Address Type like \"EXTERNAL\" or \"ANY\".
 
@@ -67,33 +68,33 @@
             self.__subnet_prefix = subnet_prefix
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.AddressTypeObject'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.AddressTypeObject'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -170,28 +171,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/Anc.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/Anc.py`

 * *Files 1% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.IPAddress import IPAddress  # noqa: F401,E501
 from ntnx_networking_py_client.models.common.v1.config.Metadata import Metadata  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.NetworkingBaseModel import NetworkingBaseModel  # noqa: F401,E501
 
 class Anc(NetworkingBaseModel):
 
     """
@@ -104,16 +105,16 @@
             self.__anc_domain_name_server_list = anc_domain_name_server_list
         if excluded_clusters is not None:
             self.__excluded_clusters = excluded_clusters
 
     def _initialize_object_type(self):
         return 'networking.v4.config.Anc'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.Anc'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     @property
     def config_version(self):
         """
         Configuration version for the current ANC. It is the logical timestamp for the current V4 release and will be updated by the actual configuration version in future releases.
 
@@ -212,28 +213,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/AncConfigApiResponse.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/GetGatewayApiResponse.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_networking_py_client.models
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.AncConfigApiResponsedata import AncConfigApiResponsedata  # noqa: F401,E501
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.GetGatewayApiResponsedata import GetGatewayApiResponsedata  # noqa: F401,E501
 from ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class AncConfigApiResponse(object):
+class GetGatewayApiResponse(object):
 
-    """REST response for all response codes in API path /networking/v4.0.b1/config/anc Get operation
+    """REST response for all response codes in API path /networking/v4.0.b1/config/gateways/{extId} Get operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfnetworking.v4.config.AncConfigApiResponsedata',
+        'data': 'OneOfnetworking.v4.config.GetGatewayApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.AncConfigApiResponse'
+        return 'networking.v4.config.GetGatewayApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.AncConfigApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -122,15 +123,15 @@
 
     @property
     def data(self):
         """
         
 
         :type:
-                :class:`~ntnx_networking_py_client.models.networking.v4.config.Anc` | 
+                :class:`~ntnx_networking_py_client.models.networking.v4.config.Gateway` | 
                 :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse`
                     """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
@@ -171,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(AncConfigApiResponse, dict):
+        if issubclass(GetGatewayApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, AncConfigApiResponse):
+        if not isinstance(other, GetGatewayApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/AssignedAddress.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/AssignedAddress.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.EntityReference import EntityReference  # noqa: F401,E501
 
 class AssignedAddress(object):
 
     """Information pertaining to an assigned IP address on a subnet.
 
     :param vm_reference: (:attr:`vm_reference`) 
@@ -67,33 +68,33 @@
             self.__mac_address = mac_address
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.AssignedAddress'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.AssignedAddress'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -171,28 +172,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/AuthenticationAlgorithm.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/AuthenticationAlgorithm.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
 class AuthenticationAlgorithm(object):
 
     """Authentication algorithm.
 
 
     Allowed enum values:
@@ -47,33 +48,33 @@
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.AuthenticationAlgorithm'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.AuthenticationAlgorithm'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -88,27 +89,32 @@
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/AuthenticationType.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/AuthenticationType.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
 class AuthenticationType(object):
 
     """Authentication type.
 
 
     Allowed enum values:
@@ -41,33 +42,33 @@
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.AuthenticationType'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.AuthenticationType'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -82,27 +83,32 @@
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/AuthorizationData.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/AuthorizationData.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
 class AuthorizationData(object):
 
     """Authorization data.
 
     :param client_id: (:attr:`client_id`) Client Id.
     :type client_id: 
@@ -85,33 +86,33 @@
         self.__subscription_id = subscription_id
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.AuthorizationData'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.AuthorizationData'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -246,28 +247,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/AzureConfig.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/AzureConfig.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.networking.v4.config.AuthorizationData import AuthorizationData  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.AzureExternalSubnetConfig import AzureExternalSubnetConfig  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.BgpInfo import BgpInfo  # noqa: F401,E501
 
 class AzureConfig(object):
 
     """Azure configuration.
@@ -89,33 +90,33 @@
             self.__authorization_data = authorization_data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.AzureConfig'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.AzureConfig'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -238,28 +239,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/AzureExternalSubnetBinding.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/AzureExternalSubnetBinding.py`

 * *Files 3% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.IPAddress import IPAddress  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.IPSubnet import IPSubnet  # noqa: F401,E501
 
 class AzureExternalSubnetBinding(object):
 
     """Binding of Atlas Flow Gateway external subnet with Azure external subnet.
 
@@ -94,33 +95,33 @@
             self.__resource_group_id = resource_group_id
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.AzureExternalSubnetBinding'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.AzureExternalSubnetBinding'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -264,28 +265,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/AzureExternalSubnetConfig.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/AzureExternalSubnetConfig.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.networking.v4.config.IPConfig import IPConfig  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.PublicIpMapping import PublicIpMapping  # noqa: F401,E501
 
 class AzureExternalSubnetConfig(object):
 
     """The external subnet configuration for the Azure cloud.
 
@@ -74,33 +75,33 @@
             self.__public_ip_mapping_list = public_ip_mapping_list
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.AzureExternalSubnetConfig'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.AzureExternalSubnetConfig'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -195,28 +196,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/BgpConfig.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/BgpConfig.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
 class BgpConfig(object):
 
     """BGP configuration
 
     :param asn: (:attr:`asn`) Autonomous system number. 0 and 4294967295 are reserved.
     :type asn: 
@@ -73,33 +74,33 @@
             self.__should_redistribute_routes = should_redistribute_routes
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.BgpConfig'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.BgpConfig'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -196,28 +197,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/BgpInfo.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/BgpInfo.py`

 * *Files 9% similar despite different names*

```diff
@@ -3,36 +3,37 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.networking.v4.config.LocalBgpGateway import LocalBgpGateway  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.RemoteBgpGateway import RemoteBgpGateway  # noqa: F401,E501
 
 class BgpInfo(object):
 
     """BGP info needed for flow gateway scale out model.
 
     :param local_bgp_gateway_list: (:attr:`local_bgp_gateway_list`) 
-    :type local_bgp_gateway_list: 
+    :type local_bgp_gateway_list: required
     :param remote_bgp_gateway_list: (:attr:`remote_bgp_gateway_list`) 
-    :type remote_bgp_gateway_list: 
+    :type remote_bgp_gateway_list: required
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
@@ -58,43 +59,41 @@
 
 
 
     def __init__(self, local_bgp_gateway_list=None, remote_bgp_gateway_list=None, *args, **kwargs):  # noqa: E501
         self.__local_bgp_gateway_list = None
         self.__remote_bgp_gateway_list = None
         self.discriminator = None
-        if local_bgp_gateway_list is not None:
-            self.__local_bgp_gateway_list = local_bgp_gateway_list
-        if remote_bgp_gateway_list is not None:
-            self.__remote_bgp_gateway_list = remote_bgp_gateway_list
+        self.__local_bgp_gateway_list = local_bgp_gateway_list
+        self.__remote_bgp_gateway_list = remote_bgp_gateway_list
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.BgpInfo'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.BgpInfo'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -112,14 +111,16 @@
         :type:
              list[ :class:`~ntnx_networking_py_client.models.networking.v4.config.LocalBgpGateway` ]
         """  # noqa: E501
         return self.__local_bgp_gateway_list
 
     @local_bgp_gateway_list.setter
     def local_bgp_gateway_list(self, local_bgp_gateway_list):
+        if local_bgp_gateway_list is None:
+            raise ValueError("Invalid value for `local_bgp_gateway_list`, must not be `None`")  # noqa: E501
 
         self.__local_bgp_gateway_list = local_bgp_gateway_list
 
     @property
     def remote_bgp_gateway_list(self):
         """
         
@@ -127,14 +128,16 @@
         :type:
              list[ :class:`~ntnx_networking_py_client.models.networking.v4.config.RemoteBgpGateway` ]
         """  # noqa: E501
         return self.__remote_bgp_gateway_list
 
     @remote_bgp_gateway_list.setter
     def remote_bgp_gateway_list(self, remote_bgp_gateway_list):
+        if remote_bgp_gateway_list is None:
+            raise ValueError("Invalid value for `remote_bgp_gateway_list`, must not be `None`")  # noqa: E501
 
         self.__remote_bgp_gateway_list = remote_bgp_gateway_list
 
     @property
     def _reserved(self):
         """
         
@@ -169,28 +172,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/BgpSession.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/BgpSession.py`

 * *Files 12% similar despite different names*

```diff
@@ -3,25 +3,27 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
+from ntnx_networking_py_client.models.common.v1.config.IPAddress import IPAddress  # noqa: F401,E501
 from ntnx_networking_py_client.models.common.v1.config.Metadata import Metadata  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.Gateway import Gateway  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.NetworkingBaseModel import NetworkingBaseModel  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.Route import Route  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.Status import Status  # noqa: F401,E501
 
 class BgpSession(NetworkingBaseModel):
@@ -32,14 +34,16 @@
     :type name: required
     :param description: (:attr:`description`) BGP session description.
     :type description: 
     :param local_gateway_reference: (:attr:`local_gateway_reference`) The local BGP gateway reference.
     :type local_gateway_reference: required
     :param remote_gateway_reference: (:attr:`remote_gateway_reference`) The remote BGP gateway reference.
     :type remote_gateway_reference: required
+    :param local_gateway_interface_ip_address: (:attr:`local_gateway_interface_ip_address`) 
+    :type local_gateway_interface_ip_address: 
     :param dynamic_route_priority: (:attr:`dynamic_route_priority`) The priority assigned to routes received over this BGP session.
     :type dynamic_route_priority: 
     :param password: (:attr:`password`) BGP password
     :type password: 
     :param status: (:attr:`status`) 
     :type status: 
     :param advertised_routes: (:attr:`advertised_routes`) Advertised routes.
@@ -64,14 +68,15 @@
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'name': 'str',
         'description': 'str',
         'local_gateway_reference': 'str',
         'remote_gateway_reference': 'str',
+        'local_gateway_interface_ip_address': 'common.v1.config.IPAddress',
         'dynamic_route_priority': 'int',
         'password': 'str',
         'status': 'networking.v4.config.Status',
         'advertised_routes': 'list[networking.v4.config.Route]',
         'received_routes': 'list[networking.v4.config.Route]',
         'ignored_routes': 'list[networking.v4.config.Route]',
         'local_gateway': 'networking.v4.config.Gateway',
@@ -86,14 +91,15 @@
     }
 
     attribute_map = {
         'name': 'name',
         'description': 'description',
         'local_gateway_reference': 'localGatewayReference',
         'remote_gateway_reference': 'remoteGatewayReference',
+        'local_gateway_interface_ip_address': 'localGatewayInterfaceIpAddress',
         'dynamic_route_priority': 'dynamicRoutePriority',
         'password': 'password',
         'status': 'status',
         'advertised_routes': 'advertisedRoutes',
         'received_routes': 'receivedRoutes',
         'ignored_routes': 'ignoredRoutes',
         'local_gateway': 'localGateway',
@@ -105,34 +111,37 @@
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, name=None, description=None, local_gateway_reference=None, remote_gateway_reference=None, dynamic_route_priority=None, password=None, status=None, advertised_routes=None, received_routes=None, ignored_routes=None, local_gateway=None, remote_gateway=None, metadata=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
+    def __init__(self, name=None, description=None, local_gateway_reference=None, remote_gateway_reference=None, local_gateway_interface_ip_address=None, dynamic_route_priority=None, password=None, status=None, advertised_routes=None, received_routes=None, ignored_routes=None, local_gateway=None, remote_gateway=None, metadata=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
         NetworkingBaseModel.__init__(self, metadata, ext_id, links, tenant_id, *args, **kwargs)
         self.__name = None
         self.__description = None
         self.__local_gateway_reference = None
         self.__remote_gateway_reference = None
+        self.__local_gateway_interface_ip_address = None
         self.__dynamic_route_priority = None
         self.__password = None
         self.__status = None
         self.__advertised_routes = None
         self.__received_routes = None
         self.__ignored_routes = None
         self.__local_gateway = None
         self.__remote_gateway = None
         self.discriminator = None
         self.__name = name
         if description is not None:
             self.__description = description
         self.__local_gateway_reference = local_gateway_reference
         self.__remote_gateway_reference = remote_gateway_reference
+        if local_gateway_interface_ip_address is not None:
+            self.__local_gateway_interface_ip_address = local_gateway_interface_ip_address
         if dynamic_route_priority is not None:
             self.__dynamic_route_priority = dynamic_route_priority
         if password is not None:
             self.__password = password
         if status is not None:
             self.__status = status
         if advertised_routes is not None:
@@ -145,16 +154,16 @@
             self.__local_gateway = local_gateway
         if remote_gateway is not None:
             self.__remote_gateway = remote_gateway
 
     def _initialize_object_type(self):
         return 'networking.v4.config.BgpSession'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.BgpSession'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     @property
     def name(self):
         """
         BGP session name.
 
@@ -228,14 +237,29 @@
             raise ValueError("Invalid value for `remote_gateway_reference`, must not be `None`")  # noqa: E501
         if remote_gateway_reference is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', remote_gateway_reference):  # noqa: E501
             raise ValueError(r"Invalid value for `remote_gateway_reference`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
 
         self.__remote_gateway_reference = remote_gateway_reference
 
     @property
+    def local_gateway_interface_ip_address(self):
+        """
+        
+
+        :type:
+            :class:`~ntnx_networking_py_client.models.common.v1.config.IPAddress`
+        """  # noqa: E501
+        return self.__local_gateway_interface_ip_address
+
+    @local_gateway_interface_ip_address.setter
+    def local_gateway_interface_ip_address(self, local_gateway_interface_ip_address):
+
+        self.__local_gateway_interface_ip_address = local_gateway_interface_ip_address
+
+    @property
     def dynamic_route_priority(self):
         """
         The priority assigned to routes received over this BGP session.
 
         :type:
 
                 :class:`~int`
@@ -361,28 +385,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/BgpSessionApiResponse.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/stats/GetVpcNsStatsApiResponse.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_networking_py_client.models
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.BgpSessionApiResponsedata import BgpSessionApiResponsedata  # noqa: F401,E501
+from ntnx_networking_py_client.models.OneOfnetworking.v4.stats.GetVpcNsStatsApiResponsedata import GetVpcNsStatsApiResponsedata  # noqa: F401,E501
 from ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class BgpSessionApiResponse(object):
+class GetVpcNsStatsApiResponse(object):
 
-    """REST response for all response codes in API path /networking/v4.0.b1/config/bgp-sessions/{extId} Get operation
+    """REST response for all response codes in API path /networking/v4.0.b1/stats/vpc/{vpcExtId}/external-subnets/{extId} Get operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfnetworking.v4.config.BgpSessionApiResponsedata',
+        'data': 'OneOfnetworking.v4.stats.GetVpcNsStatsApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.BgpSessionApiResponse'
+        return 'networking.v4.stats.GetVpcNsStatsApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.BgpSessionApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -122,15 +123,15 @@
 
     @property
     def data(self):
         """
         
 
         :type:
-                :class:`~ntnx_networking_py_client.models.networking.v4.config.BgpSession` | 
+                :class:`~ntnx_networking_py_client.models.networking.v4.stats.VpcNsStats` | 
                 :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse`
                     """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
@@ -171,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(BgpSessionApiResponse, dict):
+        if issubclass(GetVpcNsStatsApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, BgpSessionApiResponse):
+        if not isinstance(other, GetVpcNsStatsApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/BgpSessionListApiResponse.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/GetLayer2StretchApiResponse.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_networking_py_client.models
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.BgpSessionListApiResponsedata import BgpSessionListApiResponsedata  # noqa: F401,E501
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.GetLayer2StretchApiResponsedata import GetLayer2StretchApiResponsedata  # noqa: F401,E501
 from ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class BgpSessionListApiResponse(object):
+class GetLayer2StretchApiResponse(object):
 
-    """REST response for all response codes in API path /networking/v4.0.b1/config/bgp-sessions Get operation
+    """REST response for all response codes in API path /networking/v4.0.b1/config/layer2-stretches/{extId} Get operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfnetworking.v4.config.BgpSessionListApiResponsedata',
+        'data': 'OneOfnetworking.v4.config.GetLayer2StretchApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.BgpSessionListApiResponse'
+        return 'networking.v4.config.GetLayer2StretchApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.BgpSessionListApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -122,17 +123,16 @@
 
     @property
     def data(self):
         """
         
 
         :type:
-                :class:`~ntnx_networking_py_client.models.networking.v4.config.BgpSession` | 
-                :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse` | 
-                :class:`~ntnx_networking_py_client.models.networking.v4.config.BgpSessionProjection`
+                :class:`~ntnx_networking_py_client.models.networking.v4.config.Layer2Stretch` | 
+                :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse`
                     """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
         self.__data = data
@@ -172,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(BgpSessionListApiResponse, dict):
+        if issubclass(GetLayer2StretchApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -216,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, BgpSessionListApiResponse):
+        if not isinstance(other, GetLayer2StretchApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/BgpSessionProjection.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/BgpSessionProjection.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,25 +3,27 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
+from ntnx_networking_py_client.models.common.v1.config.IPAddress import IPAddress  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.BgpSession import BgpSession  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.Gateway import Gateway  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.GatewayProjection import GatewayProjection  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.Route import Route  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.Status import Status  # noqa: F401,E501
 
 class BgpSessionProjection(BgpSession):
@@ -43,14 +45,15 @@
     """  # noqa: E501
     swagger_types = {
         'gateway_projection': 'networking.v4.config.GatewayProjection',
         'name': 'str',
         'description': 'str',
         'local_gateway_reference': 'str',
         'remote_gateway_reference': 'str',
+        'local_gateway_interface_ip_address': 'common.v1.config.IPAddress',
         'dynamic_route_priority': 'int',
         'password': 'str',
         'status': 'networking.v4.config.Status',
         'advertised_routes': 'list[networking.v4.config.Route]',
         'received_routes': 'list[networking.v4.config.Route]',
         'ignored_routes': 'list[networking.v4.config.Route]',
         'local_gateway': 'networking.v4.config.Gateway',
@@ -66,14 +69,15 @@
 
     attribute_map = {
         'gateway_projection': 'gatewayProjection',
         'name': 'name',
         'description': 'description',
         'local_gateway_reference': 'localGatewayReference',
         'remote_gateway_reference': 'remoteGatewayReference',
+        'local_gateway_interface_ip_address': 'localGatewayInterfaceIpAddress',
         'dynamic_route_priority': 'dynamicRoutePriority',
         'password': 'password',
         'status': 'status',
         'advertised_routes': 'advertisedRoutes',
         'received_routes': 'receivedRoutes',
         'ignored_routes': 'ignoredRoutes',
         'local_gateway': 'localGateway',
@@ -85,26 +89,26 @@
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, gateway_projection=None, name=None, description=None, local_gateway_reference=None, remote_gateway_reference=None, dynamic_route_priority=None, password=None, status=None, advertised_routes=None, received_routes=None, ignored_routes=None, local_gateway=None, remote_gateway=None, metadata=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
-        BgpSession.__init__(self, name, description, local_gateway_reference, remote_gateway_reference, dynamic_route_priority, password, status, advertised_routes, received_routes, ignored_routes, local_gateway, remote_gateway, metadata, ext_id, links, tenant_id, *args, **kwargs)
+    def __init__(self, gateway_projection=None, name=None, description=None, local_gateway_reference=None, remote_gateway_reference=None, local_gateway_interface_ip_address=None, dynamic_route_priority=None, password=None, status=None, advertised_routes=None, received_routes=None, ignored_routes=None, local_gateway=None, remote_gateway=None, metadata=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
+        BgpSession.__init__(self, name, description, local_gateway_reference, remote_gateway_reference, local_gateway_interface_ip_address, dynamic_route_priority, password, status, advertised_routes, received_routes, ignored_routes, local_gateway, remote_gateway, metadata, ext_id, links, tenant_id, *args, **kwargs)
         self.__gateway_projection = None
         self.discriminator = None
         if gateway_projection is not None:
             self.__gateway_projection = gateway_projection
 
     def _initialize_object_type(self):
         return 'networking.v4.config.BgpSessionProjection'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.BgpSessionProjection'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     @property
     def gateway_projection(self):
         """
         
 
@@ -122,28 +126,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/BondModeType.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/BondModeType.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
 class BondModeType(object):
 
     """The types of bond modes
 
 
     Allowed enum values:
@@ -45,33 +46,33 @@
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.BondModeType'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.BondModeType'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -86,27 +87,32 @@
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/Bridge.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/Bridge.py`

 * *Files 21% similar despite different names*

```diff
@@ -3,38 +3,41 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_networking_py_client.models.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
-from ntnx_networking_py_client.models.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel  # noqa: F401,E501
+from pathlib import Path
+from ntnx_networking_py_client.models.common.v1.config.Metadata import Metadata  # noqa: F401,E501
+from ntnx_networking_py_client.models.networking.v4.config.NetworkingBaseModel import NetworkingBaseModel  # noqa: F401,E501
 
-class Bridge(ExternalizableAbstractModel):
+class Bridge(NetworkingBaseModel):
 
     """Schema of bridge to migrate to a Virtual Switch
 
     :param name: (:attr:`name`) Virtual Switch name to migrate to
     :type name: required
     :param description: (:attr:`description`) Input body to migrate to a Virtual Switch
     :type description: 
     :param existing_bridge_name: (:attr:`existing_bridge_name`) Name of bridge to convert from
     :type existing_bridge_name: required
+    :param cluster_reference: (:attr:`cluster_reference`) Prism Element cluster reference. This header can be optionally supplied for Virtual Switch list requests, but is deprecated for all other Virtual Switch fetch/create/update/delete requests. 
+    :type cluster_reference: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
@@ -42,52 +45,59 @@
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'name': 'str',
         'description': 'str',
         'existing_bridge_name': 'str',
+        'cluster_reference': 'str',
+        'metadata': 'common.v1.config.Metadata',
         'ext_id': 'str',
         'links': 'list[common.v1.response.ApiLink]',
         'tenant_id': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'name': 'name',
         'description': 'description',
         'existing_bridge_name': 'existingBridgeName',
+        'cluster_reference': 'clusterReference',
+        'metadata': 'metadata',
         'ext_id': 'extId',
         'links': 'links',
         'tenant_id': 'tenantId',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, name=None, description=None, existing_bridge_name=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
-        ExternalizableAbstractModel.__init__(self, ext_id, links, tenant_id, *args, **kwargs)
+    def __init__(self, name=None, description=None, existing_bridge_name=None, cluster_reference=None, metadata=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
+        NetworkingBaseModel.__init__(self, metadata, ext_id, links, tenant_id, *args, **kwargs)
         self.__name = None
         self.__description = None
         self.__existing_bridge_name = None
+        self.__cluster_reference = None
         self.discriminator = None
         self.__name = name
         if description is not None:
             self.__description = description
         self.__existing_bridge_name = existing_bridge_name
+        if cluster_reference is not None:
+            self.__cluster_reference = cluster_reference
 
     def _initialize_object_type(self):
         return 'networking.v4.config.Bridge'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.Bridge'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     @property
     def name(self):
         """
         Virtual Switch name to migrate to
 
@@ -140,36 +150,59 @@
         if existing_bridge_name is None:
             raise ValueError("Invalid value for `existing_bridge_name`, must not be `None`")  # noqa: E501
         if existing_bridge_name is not None and len(existing_bridge_name) > 128:
             raise ValueError("Invalid value for `existing_bridge_name`, length must be less than or equal to `128`")  # noqa: E501
 
         self.__existing_bridge_name = existing_bridge_name
 
+    @property
+    def cluster_reference(self):
+        """
+        Prism Element cluster reference. This header can be optionally supplied for Virtual Switch list requests, but is deprecated for all other Virtual Switch fetch/create/update/delete requests. 
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__cluster_reference
+
+    @cluster_reference.setter
+    def cluster_reference(self, cluster_reference):
+        if cluster_reference is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', cluster_reference):  # noqa: E501
+            raise ValueError(r"Invalid value for `cluster_reference`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
+
+        self.__cluster_reference = cluster_reference
+
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/BridgeProjection.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/BridgeProjection.py`

 * *Files 16% similar despite different names*

```diff
@@ -3,42 +3,47 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.networking.v4.config.Bridge import Bridge  # noqa: F401,E501
 
 class BridgeProjection(Bridge):
 
     """
 
     :param name: (:attr:`name`) Virtual Switch name to migrate to
     :type name: required
     :param description: (:attr:`description`) Input body to migrate to a Virtual Switch
     :type description: 
     :param existing_bridge_name: (:attr:`existing_bridge_name`) Name of bridge to convert from
     :type existing_bridge_name: required
+    :param cluster_reference: (:attr:`cluster_reference`) Prism Element cluster reference. This header can be optionally supplied for Virtual Switch list requests, but is deprecated for all other Virtual Switch fetch/create/update/delete requests. 
+    :type cluster_reference: 
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
     :param ext_id: (:attr:`ext_id`) A globally unique identifier of an instance that is suitable for external consumption. 
     :type ext_id: 
-    :param links: (:attr:`links`) A HATEOAS style link for the response.  Each link contains a user friendly name identifying the link and an address for retrieving the particular resource. 
+    :param links: (:attr:`links`) A HATEOAS style link for the response.  Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource. 
     :type links: 
-    :param tenant_id: (:attr:`tenant_id`) A globally unique identifier that represents the tenant that owns this entity.  It is automatically assigned by the system and is immutable from an API consumer perspective (some use cases may cause this Id to change - for instance a use case may require the transfer of ownership of the entity, but these cases are handled automatically on the server). 
+    :param tenant_id: (:attr:`tenant_id`) A globally unique identifier that represents the tenant that owns this entity. The system automatically assigns it, and it and is immutable from an API consumer perspective (some use cases may cause this Id to change - For instance, a use case may require the transfer of ownership of the entity, but these cases are handled automatically on the server). 
     :type tenant_id: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
@@ -47,69 +52,78 @@
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'name': 'str',
         'description': 'str',
         'existing_bridge_name': 'str',
+        'cluster_reference': 'str',
+        'metadata': 'common.v1.config.Metadata',
         'ext_id': 'str',
         'links': 'list[common.v1.response.ApiLink]',
         'tenant_id': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'name': 'name',
         'description': 'description',
         'existing_bridge_name': 'existingBridgeName',
+        'cluster_reference': 'clusterReference',
+        'metadata': 'metadata',
         'ext_id': 'extId',
         'links': 'links',
         'tenant_id': 'tenantId',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, name=None, description=None, existing_bridge_name=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
-        Bridge.__init__(self, name, description, existing_bridge_name, ext_id, links, tenant_id, *args, **kwargs)
+    def __init__(self, name=None, description=None, existing_bridge_name=None, cluster_reference=None, metadata=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
+        Bridge.__init__(self, name, description, existing_bridge_name, cluster_reference, metadata, ext_id, links, tenant_id, *args, **kwargs)
         self.discriminator = None
 
     def _initialize_object_type(self):
         return 'networking.v4.config.BridgeProjection'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.BridgeProjection'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/Capability.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/Capability.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
 class Capability(object):
 
     """Capability dictionary entry with capability name and boolean value indicating support
 
     :param capability_name: (:attr:`capability_name`) Name of the capability e.g. \"SUPPORTS_PC_SPAN\"
     :type capability_name: required
@@ -64,33 +65,33 @@
         self.__is_supported = is_supported
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.Capability'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.Capability'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -171,28 +172,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/CloudNetwork.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/CloudNetwork.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.Metadata import Metadata  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.NetworkingBaseModel import NetworkingBaseModel  # noqa: F401,E501
 
 class CloudNetwork(NetworkingBaseModel):
 
     """API Schema for Cloud Network.
 
@@ -75,16 +76,16 @@
             self.__description = description
         if external_routing_domain_reference is not None:
             self.__external_routing_domain_reference = external_routing_domain_reference
 
     def _initialize_object_type(self):
         return 'networking.v4.config.CloudNetwork'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.CloudNetwork'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     @property
     def description(self):
         """
         Cloud Network annotation.
 
@@ -123,28 +124,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/CloudNetworkApiResponse.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ListSubnetsApiResponse.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_networking_py_client.models
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.CloudNetworkApiResponsedata import CloudNetworkApiResponsedata  # noqa: F401,E501
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListSubnetsApiResponsedata import ListSubnetsApiResponsedata  # noqa: F401,E501
 from ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class CloudNetworkApiResponse(object):
+class ListSubnetsApiResponse(object):
 
-    """REST response for all response codes in API path /networking/v4.0.b1/config/cloud-networks/{extId} Get operation
+    """REST response for all response codes in API path /networking/v4.0.b1/config/subnets Get operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfnetworking.v4.config.CloudNetworkApiResponsedata',
+        'data': 'OneOfnetworking.v4.config.ListSubnetsApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.CloudNetworkApiResponse'
+        return 'networking.v4.config.ListSubnetsApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.CloudNetworkApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -122,16 +123,17 @@
 
     @property
     def data(self):
         """
         
 
         :type:
-                :class:`~ntnx_networking_py_client.models.networking.v4.config.CloudNetwork` | 
-                :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse`
+                :class:`~ntnx_networking_py_client.models.networking.v4.config.Subnet` | 
+                :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse` | 
+                :class:`~ntnx_networking_py_client.models.networking.v4.config.SubnetProjection`
                     """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
         self.__data = data
@@ -171,39 +173,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(CloudNetworkApiResponse, dict):
+        if issubclass(ListSubnetsApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +222,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, CloudNetworkApiResponse):
+        if not isinstance(other, ListSubnetsApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/CloudNetworkListApiResponse.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ListLayer2StretchesApiResponse.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_networking_py_client.models
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.CloudNetworkListApiResponsedata import CloudNetworkListApiResponsedata  # noqa: F401,E501
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListLayer2StretchesApiResponsedata import ListLayer2StretchesApiResponsedata  # noqa: F401,E501
 from ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class CloudNetworkListApiResponse(object):
+class ListLayer2StretchesApiResponse(object):
 
-    """REST response for all response codes in API path /networking/v4.0.b1/config/cloud-networks Get operation
+    """REST response for all response codes in API path /networking/v4.0.b1/config/layer2-stretches Get operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfnetworking.v4.config.CloudNetworkListApiResponsedata',
+        'data': 'OneOfnetworking.v4.config.ListLayer2StretchesApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.CloudNetworkListApiResponse'
+        return 'networking.v4.config.ListLayer2StretchesApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.CloudNetworkListApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -122,15 +123,15 @@
 
     @property
     def data(self):
         """
         
 
         :type:
-                :class:`~ntnx_networking_py_client.models.networking.v4.config.CloudNetwork` | 
+                :class:`~ntnx_networking_py_client.models.networking.v4.config.Layer2Stretch` | 
                 :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse`
                     """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
@@ -171,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(CloudNetworkListApiResponse, dict):
+        if issubclass(ListLayer2StretchesApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, CloudNetworkListApiResponse):
+        if not isinstance(other, ListLayer2StretchesApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/CloudSubstrate.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/CloudSubstrate.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,69 +3,72 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
 class CloudSubstrate(object):
 
     """Cloud substrate of the network controller, for e.g. Azure.
 
 
     Allowed enum values:
 
         - _UNKNOWN
         - _REDACTED
         - AZURE: Network controller substrate is Azure.
+        - AWS: Network controller substrate is AWS.
     """
     _UNKNOWN = "$UNKNOWN"
     _REDACTED = "$REDACTED"
     AZURE = "AZURE"
+    AWS = "AWS"
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.CloudSubstrate'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.CloudSubstrate'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -80,27 +83,32 @@
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/Cluster.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/Cluster.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.IPv4Address import IPv4Address  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.Host import Host  # noqa: F401,E501
 
 class Cluster(object):
 
     """Input body to configure cluster
 
@@ -73,33 +74,33 @@
             self.__gateway_ip_address = gateway_ip_address
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.Cluster'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.Cluster'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -196,28 +197,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/ClusterCapability.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ClusterCapability.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.Metadata import Metadata  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.Capability import Capability  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.NetworkingBaseModel import NetworkingBaseModel  # noqa: F401,E501
 
 class ClusterCapability(NetworkingBaseModel):
 
     """
@@ -74,16 +75,16 @@
         self.discriminator = None
         self.__cluster_id = cluster_id
         self.__capabilities = capabilities
 
     def _initialize_object_type(self):
         return 'networking.v4.config.ClusterCapability'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.ClusterCapability'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     @property
     def cluster_id(self):
         """
         Cluster UUID whose capabilities are retrieved.
 
@@ -123,28 +124,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/ClusterCapabilityApiResponse.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ListLayer2StretchRelatedEntitiesApiResponse.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_networking_py_client.models
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ClusterCapabilityApiResponsedata import ClusterCapabilityApiResponsedata  # noqa: F401,E501
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListLayer2StretchRelatedEntitiesApiResponsedata import ListLayer2StretchRelatedEntitiesApiResponsedata  # noqa: F401,E501
 from ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class ClusterCapabilityApiResponse(object):
+class ListLayer2StretchRelatedEntitiesApiResponse(object):
 
-    """REST response for all response codes in API path /networking/v4.0.b1/config/capabilities Get operation
+    """REST response for all response codes in API path /networking/v4.0.b1/config/clusters/{extId}/layer2-stretches/related-entities Get operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfnetworking.v4.config.ClusterCapabilityApiResponsedata',
+        'data': 'OneOfnetworking.v4.config.ListLayer2StretchRelatedEntitiesApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.ClusterCapabilityApiResponse'
+        return 'networking.v4.config.ListLayer2StretchRelatedEntitiesApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.ClusterCapabilityApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -122,15 +123,15 @@
 
     @property
     def data(self):
         """
         
 
         :type:
-                :class:`~ntnx_networking_py_client.models.networking.v4.config.ClusterCapability` | 
+                :class:`~ntnx_networking_py_client.models.networking.v4.config.Layer2StretchRelatedEntities` | 
                 :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse`
                     """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
@@ -171,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ClusterCapabilityApiResponse, dict):
+        if issubclass(ListLayer2StretchRelatedEntitiesApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ClusterCapabilityApiResponse):
+        if not isinstance(other, ListLayer2StretchRelatedEntitiesApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/ClusterFlowStatus.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ClusterFlowStatus.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.networking.v4.config.ClusterStatus import ClusterStatus  # noqa: F401,E501
 
 class ClusterFlowStatus(object):
 
     """Get the Flow Networking usage of each registered Prism Element cluster.
 
     :param cluster_status_list: (:attr:`cluster_status_list`) Flow Networking usage status for every cluster.
@@ -60,33 +61,33 @@
             self.__cluster_status_list = cluster_status_list
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.ClusterFlowStatus'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.ClusterFlowStatus'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -146,28 +147,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/ClusterFlowStatusApiResponse.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ListVpnVendorConfigsApiResponse.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_networking_py_client.models
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ClusterFlowStatusApiResponsedata import ClusterFlowStatusApiResponsedata  # noqa: F401,E501
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListVpnVendorConfigsApiResponsedata import ListVpnVendorConfigsApiResponsedata  # noqa: F401,E501
 from ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class ClusterFlowStatusApiResponse(object):
+class ListVpnVendorConfigsApiResponse(object):
 
-    """REST response for all response codes in API path /networking/v4.0.b1/config/cluster-flow-status Get operation
+    """REST response for all response codes in API path /networking/v4.0.b1/config/vpn-connections/{extId}/vpn-vendor-configs Get operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfnetworking.v4.config.ClusterFlowStatusApiResponsedata',
+        'data': 'OneOfnetworking.v4.config.ListVpnVendorConfigsApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.ClusterFlowStatusApiResponse'
+        return 'networking.v4.config.ListVpnVendorConfigsApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.ClusterFlowStatusApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -122,15 +123,15 @@
 
     @property
     def data(self):
         """
         
 
         :type:
-                :class:`~ntnx_networking_py_client.models.networking.v4.config.ClusterFlowStatus` | 
+                :class:`~ntnx_networking_py_client.models.networking.v4.config.VpnAppliance` | 
                 :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse`
                     """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
@@ -171,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ClusterFlowStatusApiResponse, dict):
+        if issubclass(ListVpnVendorConfigsApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ClusterFlowStatusApiResponse):
+        if not isinstance(other, ListVpnVendorConfigsApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/ClusterStatus.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ClusterStatus.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,34 +3,35 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
 class ClusterStatus(object):
 
     """Flow Networking usage status for a Prism Element cluster.
 
     :param cluster_reference: (:attr:`cluster_reference`) UUID of respective cluster.
-    :type cluster_reference: 
+    :type cluster_reference: required
     :param has_flow_status: (:attr:`has_flow_status`) Indicates the flow status on the cluster. It is set to True if the cluster has at least one vNIC that is part of an Atlas subnet
-    :type has_flow_status: 
+    :type has_flow_status: required
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
@@ -56,43 +57,41 @@
 
 
 
     def __init__(self, cluster_reference=None, has_flow_status=None, *args, **kwargs):  # noqa: E501
         self.__cluster_reference = None
         self.__has_flow_status = None
         self.discriminator = None
-        if cluster_reference is not None:
-            self.__cluster_reference = cluster_reference
-        if has_flow_status is not None:
-            self.__has_flow_status = has_flow_status
+        self.__cluster_reference = cluster_reference
+        self.__has_flow_status = has_flow_status
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.ClusterStatus'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.ClusterStatus'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -111,14 +110,16 @@
 
                 :class:`~str`
         """  # noqa: E501
         return self.__cluster_reference
 
     @cluster_reference.setter
     def cluster_reference(self, cluster_reference):
+        if cluster_reference is None:
+            raise ValueError("Invalid value for `cluster_reference`, must not be `None`")  # noqa: E501
         if cluster_reference is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', cluster_reference):  # noqa: E501
             raise ValueError(r"Invalid value for `cluster_reference`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
 
         self.__cluster_reference = cluster_reference
 
     @property
     def has_flow_status(self):
@@ -129,14 +130,16 @@
 
                 :class:`~bool`
         """  # noqa: E501
         return self.__has_flow_status
 
     @has_flow_status.setter
     def has_flow_status(self, has_flow_status):
+        if has_flow_status is None:
+            raise ValueError("Invalid value for `has_flow_status`, must not be `None`")  # noqa: E501
 
         self.__has_flow_status = has_flow_status
 
     @property
     def _reserved(self):
         """
         
@@ -171,28 +174,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/ControllerStatus.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/State.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,73 +3,72 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class ControllerStatus(object):
+class State(object):
 
-    """Current status of the network controller.
+    """
 
 
     Allowed enum values:
 
         - _UNKNOWN
         - _REDACTED
-        - UP: Network controller healthy and status is up.
-        - DEGRADED: Network controller is unhealthy and operating in degraded state.
-        - DOWN: Network controller is down.
+        - UP: Component is up and running.
+        - DOWN: Component is not functional and down.
     """
     _UNKNOWN = "$UNKNOWN"
     _REDACTED = "$REDACTED"
     UP = "UP"
-    DEGRADED = "DEGRADED"
     DOWN = "DOWN"
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.ControllerStatus'
+        return 'networking.v4.config.State'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.ControllerStatus'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -84,36 +83,41 @@
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ControllerStatus, dict):
+        if issubclass(State, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -125,15 +129,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ControllerStatus):
+        if not isinstance(other, State):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/DefaultVlanStack.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/SubnetType.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,71 +3,72 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class DefaultVlanStack(object):
+class SubnetType(object):
 
-    """Default VLAN stack(Legacy or Advanced) to instatiate VLAN-backed subnets on if advanced networking is enabled
+    """Type of subnet.
 
 
     Allowed enum values:
 
         - _UNKNOWN
         - _REDACTED
-        - ADVANCED: Advanced networking stack.
-        - LEGACY: Legacy networking stack.
+        - OVERLAY
+        - VLAN
     """
     _UNKNOWN = "$UNKNOWN"
     _REDACTED = "$REDACTED"
-    ADVANCED = "ADVANCED"
-    LEGACY = "LEGACY"
+    OVERLAY = "OVERLAY"
+    VLAN = "VLAN"
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.DefaultVlanStack'
+        return 'networking.v4.config.SubnetType'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.DefaultVlanStack'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -82,36 +83,41 @@
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(DefaultVlanStack, dict):
+        if issubclass(SubnetType, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -123,15 +129,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, DefaultVlanStack):
+        if not isinstance(other, SubnetType):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/DhcpOptions.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/DhcpOptions.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.IPAddress import IPAddress  # noqa: F401,E501
 
 class DhcpOptions(object):
 
     """List of DHCP options to be configured.
 
     :param domain_name_servers: (:attr:`domain_name_servers`) List of Domain Name Server addresses (option 6).
@@ -95,33 +96,33 @@
             self.__ntp_servers = ntp_servers
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.DhcpOptions'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.DhcpOptions'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -261,28 +262,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/DpdConfig.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/DpdConfig.py`

 * *Files 3% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.networking.v4.config.DpdOperation import DpdOperation  # noqa: F401,E501
 
 class DpdConfig(object):
 
     """Dead peer detection configuration for the VPN connection
 
     :param operation: (:attr:`operation`) 
@@ -74,33 +75,33 @@
             self.__timeout_secs = timeout_secs
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.DpdConfig'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.DpdConfig'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -192,28 +193,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/DpdOperation.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/DefaultVlanStack.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,73 +3,72 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class DpdOperation(object):
+class DefaultVlanStack(object):
 
-    """Operation to be performed on detecting a dead peer. The default is HOLD.
+    """Default VLAN stack(Legacy or Advanced) to instatiate VLAN-backed subnets on if advanced networking is enabled
 
 
     Allowed enum values:
 
         - _UNKNOWN
         - _REDACTED
-        - RESTART: Attempt to re-negotiate the connection.
-        - CLEAR: Close the connection.
-        - HOLD: Queue traffic while waiting for the connection to be re-established.
+        - ADVANCED: Advanced networking stack.
+        - LEGACY: Legacy networking stack.
     """
     _UNKNOWN = "$UNKNOWN"
     _REDACTED = "$REDACTED"
-    RESTART = "RESTART"
-    CLEAR = "CLEAR"
-    HOLD = "HOLD"
+    ADVANCED = "ADVANCED"
+    LEGACY = "LEGACY"
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.DpdOperation'
+        return 'networking.v4.config.DefaultVlanStack'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.DpdOperation'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -84,36 +83,41 @@
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(DpdOperation, dict):
+        if issubclass(DefaultVlanStack, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -125,15 +129,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, DpdOperation):
+        if not isinstance(other, DefaultVlanStack):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/EncryptionAlgorithm.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/EncryptionAlgorithm.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,73 +3,76 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
 class EncryptionAlgorithm(object):
 
     """Encryption algorithm.
 
 
     Allowed enum values:
 
         - _UNKNOWN
         - _REDACTED
         - AES128: Encryption algorithm is aes-128.
         - AES256: Encryption algorithm is aes-256.
         - TRIPLE_DES: Encryption algorithm is triple-des.
+        - AES256GCM128: Encryption algorithm is 256 bit AES-GCM with 128 bit ICV.
     """
     _UNKNOWN = "$UNKNOWN"
     _REDACTED = "$REDACTED"
     AES128 = "AES128"
     AES256 = "AES256"
     TRIPLE_DES = "TRIPLE_DES"
+    AES256GCM128 = "AES256GCM128"
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.EncryptionAlgorithm'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.EncryptionAlgorithm'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -84,27 +87,32 @@
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/ExportScope.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ListRoutingPoliciesApiResponse.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,142 +3,144 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_networking_py_client.models.networking.v4.config.ScopeType import ScopeType  # noqa: F401,E501
-
-class ExportScope(object):
-
-    """Contains the UUID and scope type information for a particular export scope.
-
-    :param uuid: (:attr:`uuid`) 
-    :type uuid: 
-    :param scope_type: (:attr:`scope_type`) 
-    :type scope_type: 
+from pathlib import Path
+import ntnx_networking_py_client.models
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListRoutingPoliciesApiResponsedata import ListRoutingPoliciesApiResponsedata  # noqa: F401,E501
+from ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class ListRoutingPoliciesApiResponse(object):
+
+    """REST response for all response codes in API path /networking/v4.0.b1/config/routing-policies Get operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'uuid': 'str',
-        'scope_type': 'networking.v4.config.ScopeType',
+        'metadata': 'common.v1.response.ApiResponseMetadata',
+        'data': 'OneOfnetworking.v4.config.ListRoutingPoliciesApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'uuid': 'uuid',
-        'scope_type': 'scopeType',
+        'metadata': 'metadata',
+        'data': 'data',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, uuid=None, scope_type=None, *args, **kwargs):  # noqa: E501
-        self.__uuid = None
-        self.__scope_type = None
+    def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
+        self.__metadata = None
+        self.__data = None
         self.discriminator = None
-        if uuid is not None:
-            self.__uuid = uuid
-        if scope_type is not None:
-            self.__scope_type = scope_type
+        if metadata is not None:
+            self.__metadata = metadata
+        if data is not None:
+            self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.ExportScope'
+        return 'networking.v4.config.ListRoutingPoliciesApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.ExportScope'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def uuid(self):
+    def metadata(self):
         """
         
 
         :type:
-
-                :class:`~str`
+            :class:`~ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata`
         """  # noqa: E501
-        return self.__uuid
+        return self.__metadata
 
-    @uuid.setter
-    def uuid(self, uuid):
-        if uuid is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', uuid):  # noqa: E501
-            raise ValueError(r"Invalid value for `uuid`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
+    @metadata.setter
+    def metadata(self, metadata):
 
-        self.__uuid = uuid
+        self.__metadata = metadata
 
     @property
-    def scope_type(self):
+    def data(self):
         """
         
 
         :type:
-            :class:`~ntnx_networking_py_client.models.networking.v4.config.ScopeType`
-        """  # noqa: E501
-        return self.__scope_type
+                :class:`~ntnx_networking_py_client.models.networking.v4.config.RoutingPolicy` | 
+                :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse` | 
+                :class:`~ntnx_networking_py_client.models.networking.v4.config.RoutingPolicyProjection`
+                    """  # noqa: E501
+        return self.__data
 
-    @scope_type.setter
-    def scope_type(self, scope_type):
+    @data.setter
+    def data(self, data):
 
-        self.__scope_type = scope_type
+        self.__data = data
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -171,37 +173,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
+            if attr_type.startswith('OneOf'):
+                type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ExportScope, dict):
+        if issubclass(ListRoutingPoliciesApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -213,15 +222,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ExportScope):
+        if not isinstance(other, ListRoutingPoliciesApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/ExporterProtocol.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ExporterProtocol.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
 class ExporterProtocol(object):
 
     """IPFIX exporter protocol:the permissible values are TCP or UDP.
 
 
     Allowed enum values:
@@ -41,33 +42,33 @@
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.ExporterProtocol'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.ExporterProtocol'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -82,27 +83,32 @@
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/ExternalSubnet.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/GatewayManagementInterface.py`

 * *Files 15% similar despite different names*

```diff
@@ -3,111 +3,119 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.IPAddress import IPAddress  # noqa: F401,E501
-from ntnx_networking_py_client.models.networking.v4.config.GatewayNodeReference import GatewayNodeReference  # noqa: F401,E501
 
-class ExternalSubnet(object):
+class GatewayManagementInterface(object):
 
-    """Information about the external subnet, SNAT IPs and the gateway nodes.
+    """Network interface used to deliver network services and for managing the gateway. If a VPC reference is supplied then the gateway will be deployed on a dedicated subnet within the VPC. If a VPC reference is not supplied, then this interface defines the subnet on which the gateway will be deployed, and the address it will be assigned. When a VPC reference is not present, either a subnet reference or a VLAN id must be supplied, along with the address and default gateway of the subnet. A VLAN network without IPAM may be used. 
 
-    :param subnet_reference: (:attr:`subnet_reference`) External subnet reference.
-    :type subnet_reference: required
-    :param external_ips: (:attr:`external_ips`) List of IP Addresses used for SNAT, if NAT is enabled on the external subnet. If NAT is not enabled, this specifies the IP address of the VPC port connected to the external gateway.
-    :type external_ips: 
-    :param gateway_nodes: (:attr:`gateway_nodes`) List of gateway nodes that can be used for external connectivity.
-    :type gateway_nodes: 
-    :param active_gateway_node: (:attr:`active_gateway_node`) 
-    :type active_gateway_node: 
+    :param subnet_reference: (:attr:`subnet_reference`) The on-prem vlan subnet to deploy the network gateway VM on
+    :type subnet_reference: 
+    :param vlan_id: (:attr:`vlan_id`) The on-prem VLAN to deploy the gateway on
+    :type vlan_id: 
+    :param address: (:attr:`address`) 
+    :type address: 
+    :param default_gateway: (:attr:`default_gateway`) 
+    :type default_gateway: 
+    :param mtu: (:attr:`mtu`) MTU of management interface
+    :type mtu: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'subnet_reference': 'str',
-        'external_ips': 'list[common.v1.config.IPAddress]',
-        'gateway_nodes': 'list[str]',
-        'active_gateway_node': 'networking.v4.config.GatewayNodeReference',
+        'vlan_id': 'int',
+        'address': 'common.v1.config.IPAddress',
+        'default_gateway': 'common.v1.config.IPAddress',
+        'mtu': 'int',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'subnet_reference': 'subnetReference',
-        'external_ips': 'externalIps',
-        'gateway_nodes': 'gatewayNodes',
-        'active_gateway_node': 'activeGatewayNode',
+        'vlan_id': 'vlanId',
+        'address': 'address',
+        'default_gateway': 'defaultGateway',
+        'mtu': 'mtu',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, subnet_reference=None, external_ips=None, gateway_nodes=None, active_gateway_node=None, *args, **kwargs):  # noqa: E501
+    def __init__(self, subnet_reference=None, vlan_id=None, address=None, default_gateway=None, mtu=None, *args, **kwargs):  # noqa: E501
         self.__subnet_reference = None
-        self.__external_ips = None
-        self.__gateway_nodes = None
-        self.__active_gateway_node = None
+        self.__vlan_id = None
+        self.__address = None
+        self.__default_gateway = None
+        self.__mtu = None
         self.discriminator = None
-        self.__subnet_reference = subnet_reference
-        if external_ips is not None:
-            self.__external_ips = external_ips
-        if gateway_nodes is not None:
-            self.__gateway_nodes = gateway_nodes
-        if active_gateway_node is not None:
-            self.__active_gateway_node = active_gateway_node
+        if subnet_reference is not None:
+            self.__subnet_reference = subnet_reference
+        if vlan_id is not None:
+            self.__vlan_id = vlan_id
+        if address is not None:
+            self.__address = address
+        if default_gateway is not None:
+            self.__default_gateway = default_gateway
+        if mtu is not None:
+            self.__mtu = mtu
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.ExternalSubnet'
+        return 'networking.v4.config.GatewayManagementInterface'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.ExternalSubnet'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -116,75 +124,94 @@
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def subnet_reference(self):
         """
-        External subnet reference.
+        The on-prem vlan subnet to deploy the network gateway VM on
 
         :type:
 
                 :class:`~str`
         """  # noqa: E501
         return self.__subnet_reference
 
     @subnet_reference.setter
     def subnet_reference(self, subnet_reference):
-        if subnet_reference is None:
-            raise ValueError("Invalid value for `subnet_reference`, must not be `None`")  # noqa: E501
         if subnet_reference is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', subnet_reference):  # noqa: E501
             raise ValueError(r"Invalid value for `subnet_reference`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
 
         self.__subnet_reference = subnet_reference
 
     @property
-    def external_ips(self):
+    def vlan_id(self):
         """
-        List of IP Addresses used for SNAT, if NAT is enabled on the external subnet. If NAT is not enabled, this specifies the IP address of the VPC port connected to the external gateway.
+        The on-prem VLAN to deploy the gateway on
 
         :type:
-             list[ :class:`~ntnx_networking_py_client.models.common.v1.config.IPAddress` ]
+
+                :class:`~int`
         """  # noqa: E501
-        return self.__external_ips
+        return self.__vlan_id
 
-    @external_ips.setter
-    def external_ips(self, external_ips):
+    @vlan_id.setter
+    def vlan_id(self, vlan_id):
+        if vlan_id is not None and vlan_id > 4095:  # noqa: E501
+            raise ValueError("Invalid value for `vlan_id`, must be a value less than or equal to `4095`")  # noqa: E501
+        if vlan_id is not None and vlan_id < 0:  # noqa: E501
+            raise ValueError("Invalid value for `vlan_id`, must be a value greater than or equal to `0`")  # noqa: E501
 
-        self.__external_ips = external_ips
+        self.__vlan_id = vlan_id
 
     @property
-    def gateway_nodes(self):
+    def address(self):
         """
-        List of gateway nodes that can be used for external connectivity.
+        
 
         :type:
-            list[ :class:`~str` ]
+            :class:`~ntnx_networking_py_client.models.common.v1.config.IPAddress`
         """  # noqa: E501
-        return self.__gateway_nodes
+        return self.__address
 
-    @gateway_nodes.setter
-    def gateway_nodes(self, gateway_nodes):
+    @address.setter
+    def address(self, address):
 
-        self.__gateway_nodes = gateway_nodes
+        self.__address = address
 
     @property
-    def active_gateway_node(self):
+    def default_gateway(self):
         """
         
 
         :type:
-            :class:`~ntnx_networking_py_client.models.networking.v4.config.GatewayNodeReference`
+            :class:`~ntnx_networking_py_client.models.common.v1.config.IPAddress`
+        """  # noqa: E501
+        return self.__default_gateway
+
+    @default_gateway.setter
+    def default_gateway(self, default_gateway):
+
+        self.__default_gateway = default_gateway
+
+    @property
+    def mtu(self):
+        """
+        MTU of management interface
+
+        :type:
+
+                :class:`~int`
         """  # noqa: E501
-        return self.__active_gateway_node
+        return self.__mtu
 
-    @active_gateway_node.setter
-    def active_gateway_node(self, active_gateway_node):
+    @mtu.setter
+    def mtu(self, mtu):
 
-        self.__active_gateway_node = active_gateway_node
+        self.__mtu = mtu
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -217,37 +244,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ExternalSubnet, dict):
+        if issubclass(GatewayManagementInterface, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -259,15 +291,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ExternalSubnet):
+        if not isinstance(other, GatewayManagementInterface):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/FloatingIPAddress.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ListFloatingIpsApiResponse.py`

 * *Files 9% similar despite different names*

```diff
@@ -3,140 +3,144 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_networking_py_client.models.networking.v4.config.FloatingIPv4Address import FloatingIPv4Address  # noqa: F401,E501
-from ntnx_networking_py_client.models.networking.v4.config.FloatingIPv6Address import FloatingIPv6Address  # noqa: F401,E501
-
-class FloatingIPAddress(object):
-
-    """Floating IP address.
-
-    :param ipv4: (:attr:`ipv4`) 
-    :type ipv4: 
-    :param ipv6: (:attr:`ipv6`) 
-    :type ipv6: 
+from pathlib import Path
+import ntnx_networking_py_client.models
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListFloatingIpsApiResponsedata import ListFloatingIpsApiResponsedata  # noqa: F401,E501
+from ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class ListFloatingIpsApiResponse(object):
+
+    """REST response for all response codes in API path /networking/v4.0.b1/config/floating-ips Get operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'ipv4': 'networking.v4.config.FloatingIPv4Address',
-        'ipv6': 'networking.v4.config.FloatingIPv6Address',
+        'metadata': 'common.v1.response.ApiResponseMetadata',
+        'data': 'OneOfnetworking.v4.config.ListFloatingIpsApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'ipv4': 'ipv4',
-        'ipv6': 'ipv6',
+        'metadata': 'metadata',
+        'data': 'data',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, ipv4=None, ipv6=None, *args, **kwargs):  # noqa: E501
-        self.__ipv4 = None
-        self.__ipv6 = None
+    def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
+        self.__metadata = None
+        self.__data = None
         self.discriminator = None
-        if ipv4 is not None:
-            self.__ipv4 = ipv4
-        if ipv6 is not None:
-            self.__ipv6 = ipv6
+        if metadata is not None:
+            self.__metadata = metadata
+        if data is not None:
+            self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.FloatingIPAddress'
+        return 'networking.v4.config.ListFloatingIpsApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.FloatingIPAddress'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def ipv4(self):
+    def metadata(self):
         """
         
 
         :type:
-            :class:`~ntnx_networking_py_client.models.networking.v4.config.FloatingIPv4Address`
+            :class:`~ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata`
         """  # noqa: E501
-        return self.__ipv4
+        return self.__metadata
 
-    @ipv4.setter
-    def ipv4(self, ipv4):
+    @metadata.setter
+    def metadata(self, metadata):
 
-        self.__ipv4 = ipv4
+        self.__metadata = metadata
 
     @property
-    def ipv6(self):
+    def data(self):
         """
         
 
         :type:
-            :class:`~ntnx_networking_py_client.models.networking.v4.config.FloatingIPv6Address`
-        """  # noqa: E501
-        return self.__ipv6
+                :class:`~ntnx_networking_py_client.models.networking.v4.config.FloatingIp` | 
+                :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse` | 
+                :class:`~ntnx_networking_py_client.models.networking.v4.config.FloatingIpProjection`
+                    """  # noqa: E501
+        return self.__data
 
-    @ipv6.setter
-    def ipv6(self, ipv6):
+    @data.setter
+    def data(self, data):
 
-        self.__ipv6 = ipv6
+        self.__data = data
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -169,37 +173,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
+            if attr_type.startswith('OneOf'):
+                type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(FloatingIPAddress, dict):
+        if issubclass(ListFloatingIpsApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -211,25 +222,16 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, FloatingIPAddress):
+        if not isinstance(other, ListFloatingIpsApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
 
-    def has_ipv4(self):
-        """Returns true if `ipv4` has non-none value"""
-        return self._ipv4 is None
-    def has_ipv6(self):
-        """Returns true if `ipv6` has non-none value"""
-        return self._ipv6 is None
-    def is_valid(self):
-        """Returns true if any one of the attributes has non-none value"""
-        return self.has_ipv4() or self.has_ipv6()
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/FloatingIPv4Address.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/IPv4Subnet.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,140 +3,141 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
+from ntnx_networking_py_client.models.common.v1.config.IPv4Address import IPv4Address  # noqa: F401,E501
 
-class FloatingIPv4Address(object):
+class IPv4Subnet(object):
 
     """
 
-    :param value: (:attr:`value`) 
-    :type value: 
-    :param prefix_length: (:attr:`prefix_length`) Prefix length of the network to which this host IPv4 address belongs. (**Default** 32)
-    :type prefix_length: 
+    :param ip: (:attr:`ip`) 
+    :type ip: required
+    :param prefix_length: (:attr:`prefix_length`) 
+    :type prefix_length: required
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'value': 'str',
+        'ip': 'common.v1.config.IPv4Address',
         'prefix_length': 'int',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'value': 'value',
+        'ip': 'ip',
         'prefix_length': 'prefixLength',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, value=None, prefix_length=32, *args, **kwargs):  # noqa: E501
-        self.__value = None
+    def __init__(self, ip=None, prefix_length=None, *args, **kwargs):  # noqa: E501
+        self.__ip = None
         self.__prefix_length = None
         self.discriminator = None
-        if value is not None:
-            self.__value = value
-        if prefix_length is not None:
-            self.__prefix_length = prefix_length
+        self.__ip = ip
+        self.__prefix_length = prefix_length
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.FloatingIPv4Address'
+        return 'networking.v4.config.IPv4Subnet'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.FloatingIPv4Address'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def value(self):
+    def ip(self):
         """
         
 
         :type:
-
-                :class:`~str`
+            :class:`~ntnx_networking_py_client.models.common.v1.config.IPv4Address`
         """  # noqa: E501
-        return self.__value
+        return self.__ip
 
-    @value.setter
-    def value(self, value):
-        if value is not None and not re.search('^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$', value):  # noqa: E501
-            raise ValueError(r"Invalid value for `value`, must be a follow pattern or equal to `/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/`")  # noqa: E501
+    @ip.setter
+    def ip(self, ip):
+        if ip is None:
+            raise ValueError("Invalid value for `ip`, must not be `None`")  # noqa: E501
 
-        self.__value = value
+        self.__ip = ip
 
     @property
     def prefix_length(self):
         """
-        Prefix length of the network to which this host IPv4 address belongs.
+        
 
         :type:
 
                 :class:`~int`
         """  # noqa: E501
         return self.__prefix_length
 
     @prefix_length.setter
     def prefix_length(self, prefix_length):
+        if prefix_length is None:
+            raise ValueError("Invalid value for `prefix_length`, must not be `None`")  # noqa: E501
         if prefix_length is not None and prefix_length > 32:  # noqa: E501
             raise ValueError("Invalid value for `prefix_length`, must be a value less than or equal to `32`")  # noqa: E501
         if prefix_length is not None and prefix_length < 0:  # noqa: E501
             raise ValueError("Invalid value for `prefix_length`, must be a value greater than or equal to `0`")  # noqa: E501
 
         self.__prefix_length = prefix_length
 
@@ -175,37 +176,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(FloatingIPv4Address, dict):
+        if issubclass(IPv4Subnet, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -217,15 +223,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, FloatingIPv4Address):
+        if not isinstance(other, IPv4Subnet):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/FloatingIPv6Address.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/FloatingIPv6Address.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
 class FloatingIPv6Address(object):
 
     """
 
     :param value: (:attr:`value`) 
     :type value: 
@@ -66,33 +67,33 @@
             self.__prefix_length = prefix_length
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.FloatingIPv6Address'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.FloatingIPv6Address'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -175,28 +176,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/FloatingIp.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/FloatingIp.py`

 * *Files 0% similar despite different names*

```diff
@@ -3,40 +3,41 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_networking_py_client.models
 from ntnx_networking_py_client.models.OneOfnetworking.v4.config.FloatingIpassociation import FloatingIpassociation  # noqa: F401,E501
 from ntnx_networking_py_client.models.common.v1.config.Metadata import Metadata  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.FloatingIPAddress import FloatingIPAddress  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.NetworkingBaseModel import NetworkingBaseModel  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.Subnet import Subnet  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.VmNic import VmNic  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.Vpc import Vpc  # noqa: F401,E501
 
 class FloatingIp(NetworkingBaseModel):
 
     """Configure a floating IP.
 
     :param name: (:attr:`name`) Name of the floating IP.
-    :type name: 
+    :type name: required
     :param description: (:attr:`description`) Description for the Floating IP.
     :type description: 
     :param association: (:attr:`association`) Association of the Floating IP with either NIC or Private IP
     :type association: 
     :param floating_ip: (:attr:`floating_ip`) 
     :type floating_ip: 
     :param external_subnet_reference: (:attr:`external_subnet_reference`) External subnet reference for the Floating IP to be allocated in on-prem only.
@@ -128,16 +129,15 @@
         self.__floating_ip_value = None
         self.__association_status = None
         self.__vpc_reference = None
         self.__vm_nic_reference = None
         self.__vpc = None
         self.__vm_nic = None
         self.discriminator = None
-        if name is not None:
-            self.__name = name
+        self.__name = name
         if description is not None:
             self.__description = description
         if association is not None:
             self.__association = association
         if floating_ip is not None:
             self.__floating_ip = floating_ip
         if external_subnet_reference is not None:
@@ -158,16 +158,16 @@
             self.__vpc = vpc
         if vm_nic is not None:
             self.__vm_nic = vm_nic
 
     def _initialize_object_type(self):
         return 'networking.v4.config.FloatingIp'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.FloatingIp'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     @property
     def name(self):
         """
         Name of the floating IP.
 
@@ -175,14 +175,16 @@
 
                 :class:`~str`
         """  # noqa: E501
         return self.__name
 
     @name.setter
     def name(self, name):
+        if name is None:
+            raise ValueError("Invalid value for `name`, must not be `None`")  # noqa: E501
         if name is not None and len(name) > 128:
             raise ValueError("Invalid value for `name`, length must be less than or equal to `128`")  # noqa: E501
 
         self.__name = name
 
     @property
     def description(self):
@@ -384,30 +386,35 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/FloatingIpApiResponse.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/GetFloatingIpApiResponse.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,30 +3,31 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_networking_py_client.models
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.FloatingIpApiResponsedata import FloatingIpApiResponsedata  # noqa: F401,E501
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.GetFloatingIpApiResponsedata import GetFloatingIpApiResponsedata  # noqa: F401,E501
 from ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class FloatingIpApiResponse(object):
+class GetFloatingIpApiResponse(object):
 
     """REST response for all response codes in API path /networking/v4.0.b1/config/floating-ips/{extId} Get operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfnetworking.v4.config.FloatingIpApiResponsedata',
+        'data': 'OneOfnetworking.v4.config.GetFloatingIpApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.FloatingIpApiResponse'
+        return 'networking.v4.config.GetFloatingIpApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.FloatingIpApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -171,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(FloatingIpApiResponse, dict):
+        if issubclass(GetFloatingIpApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, FloatingIpApiResponse):
+        if not isinstance(other, GetFloatingIpApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/FloatingIpListApiResponse.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ListGatewaysApiResponse.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_networking_py_client.models
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.FloatingIpListApiResponsedata import FloatingIpListApiResponsedata  # noqa: F401,E501
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListGatewaysApiResponsedata import ListGatewaysApiResponsedata  # noqa: F401,E501
 from ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class FloatingIpListApiResponse(object):
+class ListGatewaysApiResponse(object):
 
-    """REST response for all response codes in API path /networking/v4.0.b1/config/floating-ips Get operation
+    """REST response for all response codes in API path /networking/v4.0.b1/config/gateways Get operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfnetworking.v4.config.FloatingIpListApiResponsedata',
+        'data': 'OneOfnetworking.v4.config.ListGatewaysApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.FloatingIpListApiResponse'
+        return 'networking.v4.config.ListGatewaysApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.FloatingIpListApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -122,17 +123,17 @@
 
     @property
     def data(self):
         """
         
 
         :type:
-                :class:`~ntnx_networking_py_client.models.networking.v4.config.FloatingIp` | 
+                :class:`~ntnx_networking_py_client.models.networking.v4.config.Gateway` | 
                 :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse` | 
-                :class:`~ntnx_networking_py_client.models.networking.v4.config.FloatingIpProjection`
+                :class:`~ntnx_networking_py_client.models.networking.v4.config.GatewayProjection`
                     """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
         self.__data = data
@@ -172,39 +173,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(FloatingIpListApiResponse, dict):
+        if issubclass(ListGatewaysApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -216,15 +222,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, FloatingIpListApiResponse):
+        if not isinstance(other, ListGatewaysApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/FloatingIpProjection.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/FloatingIpProjection.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_networking_py_client.models
 from ntnx_networking_py_client.models.OneOfnetworking.v4.config.FloatingIpProjectionassociation import FloatingIpProjectionassociation  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.FloatingIPAddress import FloatingIPAddress  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.FloatingIp import FloatingIp  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.Subnet import Subnet  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.SubnetProjection import SubnetProjection  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.VmNic import VmNic  # noqa: F401,E501
@@ -116,16 +117,16 @@
             self.__vm_nic_projection = vm_nic_projection
         if vpc_projection is not None:
             self.__vpc_projection = vpc_projection
 
     def _initialize_object_type(self):
         return 'networking.v4.config.FloatingIpProjection'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.FloatingIpProjection'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     @property
     def subnet_projection(self):
         """
         
 
@@ -173,30 +174,35 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/FlowGateway.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/FlowGateway.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.Metadata import Metadata  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.AzureExternalSubnetBinding import AzureExternalSubnetBinding  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.FlowGatewayStatus import FlowGatewayStatus  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.NetworkingBaseModel import NetworkingBaseModel  # noqa: F401,E501
 
 class FlowGateway(NetworkingBaseModel):
 
@@ -89,16 +90,16 @@
             self.__gateway_status = gateway_status
         if ovn_controller_version is not None:
             self.__ovn_controller_version = ovn_controller_version
 
     def _initialize_object_type(self):
         return 'networking.v4.config.FlowGateway'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.FlowGateway'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     @property
     def chassis_uuid(self):
         """
         Chassis UUID of the Atlas Flow Gateway.
 
@@ -171,28 +172,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/FlowGatewayApiResponse.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/GetIPFIXExporterApiResponse.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_networking_py_client.models
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.FlowGatewayApiResponsedata import FlowGatewayApiResponsedata  # noqa: F401,E501
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.GetIPFIXExporterApiResponsedata import GetIPFIXExporterApiResponsedata  # noqa: F401,E501
 from ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class FlowGatewayApiResponse(object):
+class GetIPFIXExporterApiResponse(object):
 
-    """REST response for all response codes in API path /networking/v4.0.b1/config/flow-gateways/{extId} Get operation
+    """REST response for all response codes in API path /networking/v4.0.b1/config/ipfix-exporters/{extId} Get operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfnetworking.v4.config.FlowGatewayApiResponsedata',
+        'data': 'OneOfnetworking.v4.config.GetIPFIXExporterApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.FlowGatewayApiResponse'
+        return 'networking.v4.config.GetIPFIXExporterApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.FlowGatewayApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -122,15 +123,15 @@
 
     @property
     def data(self):
         """
         
 
         :type:
-                :class:`~ntnx_networking_py_client.models.networking.v4.config.FlowGateway` | 
+                :class:`~ntnx_networking_py_client.models.networking.v4.config.IPFIXExporter` | 
                 :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse`
                     """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
@@ -171,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(FlowGatewayApiResponse, dict):
+        if issubclass(GetIPFIXExporterApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, FlowGatewayApiResponse):
+        if not isinstance(other, GetIPFIXExporterApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/FlowGatewayKeepAlive.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/FlowGatewayKeepAlive.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
 class FlowGatewayKeepAlive(object):
 
     """Response model for Flow Gateway Keepalive.
 
     :param keep_alive_response: (:attr:`keep_alive_response`) Indicates whether the keep alive request was successful or not.
     :type keep_alive_response: 
@@ -66,33 +67,33 @@
             self.__network_controller_version = network_controller_version
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.FlowGatewayKeepAlive'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.FlowGatewayKeepAlive'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -169,28 +170,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/FlowGatewayKeepAliveApiResponse.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/TaskReferenceApiResponse.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_networking_py_client.models
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.FlowGatewayKeepAliveApiResponsedata import FlowGatewayKeepAliveApiResponsedata  # noqa: F401,E501
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.TaskReferenceApiResponsedata import TaskReferenceApiResponsedata  # noqa: F401,E501
 from ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class FlowGatewayKeepAliveApiResponse(object):
+class TaskReferenceApiResponse(object):
 
-    """REST response for all response codes in API path /networking/v4.0.b1/config/flow-gateways/$actions/keep-alive Post operation
+    """REST response for all response codes in API path /networking/v4.0.b1/config/vpn-connections/{extId} Delete operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfnetworking.v4.config.FlowGatewayKeepAliveApiResponsedata',
+        'data': 'OneOfnetworking.v4.config.TaskReferenceApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.FlowGatewayKeepAliveApiResponse'
+        return 'networking.v4.config.TaskReferenceApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.FlowGatewayKeepAliveApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -122,15 +123,15 @@
 
     @property
     def data(self):
         """
         
 
         :type:
-                :class:`~ntnx_networking_py_client.models.networking.v4.config.FlowGatewayKeepAlive` | 
+                :class:`~ntnx_networking_py_client.models.prism.v4.config.TaskReference` | 
                 :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse`
                     """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
@@ -171,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
+                type = getattr(ntnx_networking_py_client.models, 'ConfigTaskReferenceApiResponse')
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(FlowGatewayKeepAliveApiResponse, dict):
+        if issubclass(TaskReferenceApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, FlowGatewayKeepAliveApiResponse):
+        if not isinstance(other, TaskReferenceApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/FlowGatewayKeepAliveRequestSpec.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/FlowGatewayKeepAliveRequestSpec.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.IPAddress import IPAddress  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.FlowGatewayStatus import FlowGatewayStatus  # noqa: F401,E501
 
 class FlowGatewayKeepAliveRequestSpec(object):
 
     """Request model for Flow Gateway Keepalive.
 
@@ -81,33 +82,33 @@
             self.__eni_primary_ip_list = eni_primary_ip_list
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.FlowGatewayKeepAliveRequestSpec'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.FlowGatewayKeepAliveRequestSpec'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -220,28 +221,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/FlowGatewayListApiResponse.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ListNetworkControllersApiResponse.py`

 * *Files 9% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_networking_py_client.models
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.FlowGatewayListApiResponsedata import FlowGatewayListApiResponsedata  # noqa: F401,E501
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListNetworkControllersApiResponsedata import ListNetworkControllersApiResponsedata  # noqa: F401,E501
 from ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class FlowGatewayListApiResponse(object):
+class ListNetworkControllersApiResponse(object):
 
-    """REST response for all response codes in API path /networking/v4.0.b1/config/flow-gateways Get operation
+    """REST response for all response codes in API path /networking/v4.0.b1/config/controllers Get operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfnetworking.v4.config.FlowGatewayListApiResponsedata',
+        'data': 'OneOfnetworking.v4.config.ListNetworkControllersApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.FlowGatewayListApiResponse'
+        return 'networking.v4.config.ListNetworkControllersApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.FlowGatewayListApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -122,15 +123,15 @@
 
     @property
     def data(self):
         """
         
 
         :type:
-                :class:`~ntnx_networking_py_client.models.networking.v4.config.FlowGateway` | 
+                :class:`~ntnx_networking_py_client.models.networking.v4.config.NetworkController` | 
                 :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse`
                     """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
@@ -171,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(FlowGatewayListApiResponse, dict):
+        if issubclass(ListNetworkControllersApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, FlowGatewayListApiResponse):
+        if not isinstance(other, ListNetworkControllersApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/FlowGatewayState.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/UplinkBondType.py`

 * *Files 11% similar despite different names*

```diff
@@ -3,75 +3,74 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class FlowGatewayState(object):
+class UplinkBondType(object):
 
-    """State of the Atlas Flow Gateway.
+    """Type of the bond (active-backup, balance-slb, or balance-tcp)
 
 
     Allowed enum values:
 
         - _UNKNOWN
         - _REDACTED
-        - HEALTHY: Flow gateway is healthy.
-        - DOWN: Flow gateway is down.
-        - PROVISIONING: Flow gateway is under provisioning.
-        - MAINTENANCE: Flow gateway in maintenance.
+        - ACTIVE_BACKUP: Uplink bond is configured as active-backup mode.
+        - BALANCE_SLB: Uplink bond is configured as balance-slb mode.
+        - BALANCE_TCP: Uplink bond is configured as balance-tcp mode.
     """
     _UNKNOWN = "$UNKNOWN"
     _REDACTED = "$REDACTED"
-    HEALTHY = "HEALTHY"
-    DOWN = "DOWN"
-    PROVISIONING = "PROVISIONING"
-    MAINTENANCE = "MAINTENANCE"
+    ACTIVE_BACKUP = "ACTIVE_BACKUP"
+    BALANCE_SLB = "BALANCE_SLB"
+    BALANCE_TCP = "BALANCE_TCP"
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.FlowGatewayState'
+        return 'networking.v4.config.UplinkBondType'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.FlowGatewayState'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -86,36 +85,41 @@
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(FlowGatewayState, dict):
+        if issubclass(UplinkBondType, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -127,15 +131,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, FlowGatewayState):
+        if not isinstance(other, UplinkBondType):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/FlowGatewayStatus.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/RemoteBgpGateway.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,140 +3,143 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_networking_py_client.models.networking.v4.config.FlowGatewayState import FlowGatewayState  # noqa: F401,E501
+from pathlib import Path
+from ntnx_networking_py_client.models.common.v1.config.IPAddress import IPAddress  # noqa: F401,E501
 
-class FlowGatewayStatus(object):
+class RemoteBgpGateway(object):
 
-    """Status of the Atlas Flow Gateway.
+    """Remote BGP gateway info needed for flow gateway scale out model.
 
-    :param detail: (:attr:`detail`) Status detail of the Atlas Flow Gateway.
-    :type detail: 
-    :param state: (:attr:`state`) 
-    :type state: 
+    :param asn: (:attr:`asn`) ASN number of the BGP gateway.
+    :type asn: required
+    :param ip_address: (:attr:`ip_address`) 
+    :type ip_address: required
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'detail': 'str',
-        'state': 'networking.v4.config.FlowGatewayState',
+        'asn': 'int',
+        'ip_address': 'common.v1.config.IPAddress',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'detail': 'detail',
-        'state': 'state',
+        'asn': 'asn',
+        'ip_address': 'ipAddress',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, detail=None, state=None, *args, **kwargs):  # noqa: E501
-        self.__detail = None
-        self.__state = None
+    def __init__(self, asn=None, ip_address=None, *args, **kwargs):  # noqa: E501
+        self.__asn = None
+        self.__ip_address = None
         self.discriminator = None
-        if detail is not None:
-            self.__detail = detail
-        if state is not None:
-            self.__state = state
+        self.__asn = asn
+        self.__ip_address = ip_address
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.FlowGatewayStatus'
+        return 'networking.v4.config.RemoteBgpGateway'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.FlowGatewayStatus'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def detail(self):
+    def asn(self):
         """
-        Status detail of the Atlas Flow Gateway.
+        ASN number of the BGP gateway.
 
         :type:
 
-                :class:`~str`
+                :class:`~int`
         """  # noqa: E501
-        return self.__detail
+        return self.__asn
 
-    @detail.setter
-    def detail(self, detail):
+    @asn.setter
+    def asn(self, asn):
+        if asn is None:
+            raise ValueError("Invalid value for `asn`, must not be `None`")  # noqa: E501
 
-        self.__detail = detail
+        self.__asn = asn
 
     @property
-    def state(self):
+    def ip_address(self):
         """
         
 
         :type:
-            :class:`~ntnx_networking_py_client.models.networking.v4.config.FlowGatewayState`
+            :class:`~ntnx_networking_py_client.models.common.v1.config.IPAddress`
         """  # noqa: E501
-        return self.__state
+        return self.__ip_address
 
-    @state.setter
-    def state(self, state):
+    @ip_address.setter
+    def ip_address(self, ip_address):
+        if ip_address is None:
+            raise ValueError("Invalid value for `ip_address`, must not be `None`")  # noqa: E501
 
-        self.__state = state
+        self.__ip_address = ip_address
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -169,37 +172,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(FlowGatewayStatus, dict):
+        if issubclass(RemoteBgpGateway, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -211,15 +219,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, FlowGatewayStatus):
+        if not isinstance(other, RemoteBgpGateway):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/Gateway.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/Gateway.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_networking_py_client.models
 from ntnx_networking_py_client.models.OneOfnetworking.v4.config.Gatewayservices import Gatewayservices  # noqa: F401,E501
 from ntnx_networking_py_client.models.common.v1.config.Metadata import Metadata  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.GatewayDeployment import GatewayDeployment  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.NetworkingBaseModel import NetworkingBaseModel  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.Status import Status  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.Vm import Vm  # noqa: F401,E501
@@ -158,16 +159,16 @@
             self.__vpc = vpc
         if vm is not None:
             self.__vm = vm
 
     def _initialize_object_type(self):
         return 'networking.v4.config.Gateway'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.Gateway'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     @property
     def name(self):
         """
         Name of the gateway
 
@@ -382,30 +383,35 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/GatewayApiResponse.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ListIPFIXExportersApiResponse.py`

 * *Files 11% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_networking_py_client.models
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.GatewayApiResponsedata import GatewayApiResponsedata  # noqa: F401,E501
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListIPFIXExportersApiResponsedata import ListIPFIXExportersApiResponsedata  # noqa: F401,E501
 from ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class GatewayApiResponse(object):
+class ListIPFIXExportersApiResponse(object):
 
-    """REST response for all response codes in API path /networking/v4.0.b1/config/gateways/{extId} Get operation
+    """REST response for all response codes in API path /networking/v4.0.b1/config/ipfix-exporters Get operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfnetworking.v4.config.GatewayApiResponsedata',
+        'data': 'OneOfnetworking.v4.config.ListIPFIXExportersApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.GatewayApiResponse'
+        return 'networking.v4.config.ListIPFIXExportersApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.GatewayApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -122,15 +123,15 @@
 
     @property
     def data(self):
         """
         
 
         :type:
-                :class:`~ntnx_networking_py_client.models.networking.v4.config.Gateway` | 
+                :class:`~ntnx_networking_py_client.models.networking.v4.config.IPFIXExporter` | 
                 :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse`
                     """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
@@ -171,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(GatewayApiResponse, dict):
+        if issubclass(ListIPFIXExportersApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, GatewayApiResponse):
+        if not isinstance(other, ListIPFIXExportersApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/GatewayDeployment.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/GatewayDeployment.py`

 * *Files 12% similar despite different names*

```diff
@@ -3,35 +3,39 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
+from ntnx_networking_py_client.models.networking.v4.config.GatewayInterface import GatewayInterface  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.GatewayManagementInterface import GatewayManagementInterface  # noqa: F401,E501
 
 class GatewayDeployment(object):
 
     """Network gateway deployment configuration
 
     :param cluster_reference: (:attr:`cluster_reference`) Cluster reference required to identify which on-prem cluster to deploy the gateway VM on 
     :type cluster_reference: 
     :param management_interface: (:attr:`management_interface`) 
     :type management_interface: 
+    :param interfaces: (:attr:`interfaces`) List of network interfaces for this gateway
+    :type interfaces: 
     :param vcenter_datastore_name: (:attr:`vcenter_datastore_name`) vCenter datastore to which the gateway disks and images will be uploaded during deployment 
     :type vcenter_datastore_name: 
 
     """
     """
     IGNORE:
     Attributes:
@@ -40,67 +44,72 @@
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'cluster_reference': 'str',
         'management_interface': 'networking.v4.config.GatewayManagementInterface',
+        'interfaces': 'list[networking.v4.config.GatewayInterface]',
         'vcenter_datastore_name': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'cluster_reference': 'clusterReference',
         'management_interface': 'managementInterface',
+        'interfaces': 'interfaces',
         'vcenter_datastore_name': 'vcenterDatastoreName',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, cluster_reference=None, management_interface=None, vcenter_datastore_name=None, *args, **kwargs):  # noqa: E501
+    def __init__(self, cluster_reference=None, management_interface=None, interfaces=None, vcenter_datastore_name=None, *args, **kwargs):  # noqa: E501
         self.__cluster_reference = None
         self.__management_interface = None
+        self.__interfaces = None
         self.__vcenter_datastore_name = None
         self.discriminator = None
         if cluster_reference is not None:
             self.__cluster_reference = cluster_reference
         if management_interface is not None:
             self.__management_interface = management_interface
+        if interfaces is not None:
+            self.__interfaces = interfaces
         if vcenter_datastore_name is not None:
             self.__vcenter_datastore_name = vcenter_datastore_name
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.GatewayDeployment'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.GatewayDeployment'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -140,14 +149,29 @@
 
     @management_interface.setter
     def management_interface(self, management_interface):
 
         self.__management_interface = management_interface
 
     @property
+    def interfaces(self):
+        """
+        List of network interfaces for this gateway
+
+        :type:
+             list[ :class:`~ntnx_networking_py_client.models.networking.v4.config.GatewayInterface` ]
+        """  # noqa: E501
+        return self.__interfaces
+
+    @interfaces.setter
+    def interfaces(self, interfaces):
+
+        self.__interfaces = interfaces
+
+    @property
     def vcenter_datastore_name(self):
         """
         vCenter datastore to which the gateway disks and images will be uploaded during deployment 
 
         :type:
 
                 :class:`~str`
@@ -194,28 +218,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/GatewayListApiResponse.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/GetNetworkControllerApiResponse.py`

 * *Files 11% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_networking_py_client.models
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.GatewayListApiResponsedata import GatewayListApiResponsedata  # noqa: F401,E501
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.GetNetworkControllerApiResponsedata import GetNetworkControllerApiResponsedata  # noqa: F401,E501
 from ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class GatewayListApiResponse(object):
+class GetNetworkControllerApiResponse(object):
 
-    """REST response for all response codes in API path /networking/v4.0.b1/config/gateways Get operation
+    """REST response for all response codes in API path /networking/v4.0.b1/config/controllers/{extId} Get operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfnetworking.v4.config.GatewayListApiResponsedata',
+        'data': 'OneOfnetworking.v4.config.GetNetworkControllerApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.GatewayListApiResponse'
+        return 'networking.v4.config.GetNetworkControllerApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.GatewayListApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -122,17 +123,16 @@
 
     @property
     def data(self):
         """
         
 
         :type:
-                :class:`~ntnx_networking_py_client.models.networking.v4.config.Gateway` | 
-                :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse` | 
-                :class:`~ntnx_networking_py_client.models.networking.v4.config.GatewayProjection`
+                :class:`~ntnx_networking_py_client.models.networking.v4.config.NetworkController` | 
+                :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse`
                     """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
         self.__data = data
@@ -172,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(GatewayListApiResponse, dict):
+        if issubclass(GetNetworkControllerApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -216,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, GatewayListApiResponse):
+        if not isinstance(other, GetNetworkControllerApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/GatewayManagementInterface.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/IPv6Config.py`

 * *Files 18% similar despite different names*

```diff
@@ -3,214 +3,187 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_networking_py_client.models.common.v1.config.IPAddress import IPAddress  # noqa: F401,E501
-
-class GatewayManagementInterface(object):
-
-    """Network interface used to deliver network services and for managing the gateway. If a VPC reference is supplied then the gateway will be deployed on a dedicated subnet within the VPC. If a VPC reference is not supplied, then this interface defines the subnet on which the gateway will be deployed, and the address it will be assigned. When a VPC reference is not present, either a subnet reference or a VLAN id must be supplied, along with the address and default gateway of the subnet. A VLAN network without IPAM may be used. 
-
-    :param subnet_reference: (:attr:`subnet_reference`) The on-prem vlan subnet to deploy the network gateway VM on
-    :type subnet_reference: 
-    :param vlan_id: (:attr:`vlan_id`) The on-prem VLAN to deploy the gateway on
-    :type vlan_id: 
-    :param address: (:attr:`address`) 
-    :type address: 
-    :param default_gateway: (:attr:`default_gateway`) 
-    :type default_gateway: 
-    :param mtu: (:attr:`mtu`) MTU of management interface
-    :type mtu: 
+from pathlib import Path
+from ntnx_networking_py_client.models.common.v1.config.IPv6Address import IPv6Address  # noqa: F401,E501
+from ntnx_networking_py_client.models.networking.v4.config.IPv6Pool import IPv6Pool  # noqa: F401,E501
+from ntnx_networking_py_client.models.networking.v4.config.IPv6Subnet import IPv6Subnet  # noqa: F401,E501
+
+class IPv6Config(object):
+
+    """IP V6 configuration.
+
+    :param ip_subnet: (:attr:`ip_subnet`) 
+    :type ip_subnet: required
+    :param default_gateway_ip: (:attr:`default_gateway_ip`) 
+    :type default_gateway_ip: 
+    :param dhcp_server_address: (:attr:`dhcp_server_address`) 
+    :type dhcp_server_address: 
+    :param pool_list: (:attr:`pool_list`) Pool of IP addresses from where IPs are allocated.
+    :type pool_list: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'subnet_reference': 'str',
-        'vlan_id': 'int',
-        'address': 'common.v1.config.IPAddress',
-        'default_gateway': 'common.v1.config.IPAddress',
-        'mtu': 'int',
+        'ip_subnet': 'networking.v4.config.IPv6Subnet',
+        'default_gateway_ip': 'common.v1.config.IPv6Address',
+        'dhcp_server_address': 'common.v1.config.IPv6Address',
+        'pool_list': 'list[networking.v4.config.IPv6Pool]',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'subnet_reference': 'subnetReference',
-        'vlan_id': 'vlanId',
-        'address': 'address',
-        'default_gateway': 'defaultGateway',
-        'mtu': 'mtu',
+        'ip_subnet': 'ipSubnet',
+        'default_gateway_ip': 'defaultGatewayIp',
+        'dhcp_server_address': 'dhcpServerAddress',
+        'pool_list': 'poolList',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, subnet_reference=None, vlan_id=None, address=None, default_gateway=None, mtu=None, *args, **kwargs):  # noqa: E501
-        self.__subnet_reference = None
-        self.__vlan_id = None
-        self.__address = None
-        self.__default_gateway = None
-        self.__mtu = None
+    def __init__(self, ip_subnet=None, default_gateway_ip=None, dhcp_server_address=None, pool_list=None, *args, **kwargs):  # noqa: E501
+        self.__ip_subnet = None
+        self.__default_gateway_ip = None
+        self.__dhcp_server_address = None
+        self.__pool_list = None
         self.discriminator = None
-        if subnet_reference is not None:
-            self.__subnet_reference = subnet_reference
-        if vlan_id is not None:
-            self.__vlan_id = vlan_id
-        if address is not None:
-            self.__address = address
-        if default_gateway is not None:
-            self.__default_gateway = default_gateway
-        if mtu is not None:
-            self.__mtu = mtu
+        self.__ip_subnet = ip_subnet
+        if default_gateway_ip is not None:
+            self.__default_gateway_ip = default_gateway_ip
+        if dhcp_server_address is not None:
+            self.__dhcp_server_address = dhcp_server_address
+        if pool_list is not None:
+            self.__pool_list = pool_list
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.GatewayManagementInterface'
+        return 'networking.v4.config.IPv6Config'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.GatewayManagementInterface'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def subnet_reference(self):
-        """
-        The on-prem vlan subnet to deploy the network gateway VM on
-
-        :type:
-
-                :class:`~str`
-        """  # noqa: E501
-        return self.__subnet_reference
-
-    @subnet_reference.setter
-    def subnet_reference(self, subnet_reference):
-        if subnet_reference is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', subnet_reference):  # noqa: E501
-            raise ValueError(r"Invalid value for `subnet_reference`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
-
-        self.__subnet_reference = subnet_reference
-
-    @property
-    def vlan_id(self):
+    def ip_subnet(self):
         """
-        The on-prem VLAN to deploy the gateway on
+        
 
         :type:
-
-                :class:`~int`
+            :class:`~ntnx_networking_py_client.models.networking.v4.config.IPv6Subnet`
         """  # noqa: E501
-        return self.__vlan_id
+        return self.__ip_subnet
 
-    @vlan_id.setter
-    def vlan_id(self, vlan_id):
-        if vlan_id is not None and vlan_id > 4095:  # noqa: E501
-            raise ValueError("Invalid value for `vlan_id`, must be a value less than or equal to `4095`")  # noqa: E501
-        if vlan_id is not None and vlan_id < 0:  # noqa: E501
-            raise ValueError("Invalid value for `vlan_id`, must be a value greater than or equal to `0`")  # noqa: E501
+    @ip_subnet.setter
+    def ip_subnet(self, ip_subnet):
+        if ip_subnet is None:
+            raise ValueError("Invalid value for `ip_subnet`, must not be `None`")  # noqa: E501
 
-        self.__vlan_id = vlan_id
+        self.__ip_subnet = ip_subnet
 
     @property
-    def address(self):
+    def default_gateway_ip(self):
         """
         
 
         :type:
-            :class:`~ntnx_networking_py_client.models.common.v1.config.IPAddress`
+            :class:`~ntnx_networking_py_client.models.common.v1.config.IPv6Address`
         """  # noqa: E501
-        return self.__address
+        return self.__default_gateway_ip
 
-    @address.setter
-    def address(self, address):
+    @default_gateway_ip.setter
+    def default_gateway_ip(self, default_gateway_ip):
 
-        self.__address = address
+        self.__default_gateway_ip = default_gateway_ip
 
     @property
-    def default_gateway(self):
+    def dhcp_server_address(self):
         """
         
 
         :type:
-            :class:`~ntnx_networking_py_client.models.common.v1.config.IPAddress`
+            :class:`~ntnx_networking_py_client.models.common.v1.config.IPv6Address`
         """  # noqa: E501
-        return self.__default_gateway
+        return self.__dhcp_server_address
 
-    @default_gateway.setter
-    def default_gateway(self, default_gateway):
+    @dhcp_server_address.setter
+    def dhcp_server_address(self, dhcp_server_address):
 
-        self.__default_gateway = default_gateway
+        self.__dhcp_server_address = dhcp_server_address
 
     @property
-    def mtu(self):
+    def pool_list(self):
         """
-        MTU of management interface
+        Pool of IP addresses from where IPs are allocated.
 
         :type:
-
-                :class:`~int`
+             list[ :class:`~ntnx_networking_py_client.models.networking.v4.config.IPv6Pool` ]
         """  # noqa: E501
-        return self.__mtu
+        return self.__pool_list
 
-    @mtu.setter
-    def mtu(self, mtu):
+    @pool_list.setter
+    def pool_list(self, pool_list):
 
-        self.__mtu = mtu
+        self.__pool_list = pool_list
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -243,37 +216,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(GatewayManagementInterface, dict):
+        if issubclass(IPv6Config, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -285,15 +263,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, GatewayManagementInterface):
+        if not isinstance(other, IPv6Config):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/GatewayNic.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/GatewayNic.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,37 +3,38 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.IPAddress import IPAddress  # noqa: F401,E501
 
 class GatewayNic(object):
 
     """Information of the VNICs attached to the local BGP gateways.
 
     :param index: (:attr:`index`) Index of the NIC.
-    :type index: 
+    :type index: required
     :param ip_address: (:attr:`ip_address`) 
-    :type ip_address: 
+    :type ip_address: required
     :param mac_address: (:attr:`mac_address`) MAC address of the NIC.
-    :type mac_address: 
+    :type mac_address: required
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
@@ -62,45 +63,42 @@
 
 
     def __init__(self, index=None, ip_address=None, mac_address=None, *args, **kwargs):  # noqa: E501
         self.__index = None
         self.__ip_address = None
         self.__mac_address = None
         self.discriminator = None
-        if index is not None:
-            self.__index = index
-        if ip_address is not None:
-            self.__ip_address = ip_address
-        if mac_address is not None:
-            self.__mac_address = mac_address
+        self.__index = index
+        self.__ip_address = ip_address
+        self.__mac_address = mac_address
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.GatewayNic'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.GatewayNic'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -119,14 +117,16 @@
 
                 :class:`~int`
         """  # noqa: E501
         return self.__index
 
     @index.setter
     def index(self, index):
+        if index is None:
+            raise ValueError("Invalid value for `index`, must not be `None`")  # noqa: E501
 
         self.__index = index
 
     @property
     def ip_address(self):
         """
         
@@ -134,14 +134,16 @@
         :type:
             :class:`~ntnx_networking_py_client.models.common.v1.config.IPAddress`
         """  # noqa: E501
         return self.__ip_address
 
     @ip_address.setter
     def ip_address(self, ip_address):
+        if ip_address is None:
+            raise ValueError("Invalid value for `ip_address`, must not be `None`")  # noqa: E501
 
         self.__ip_address = ip_address
 
     @property
     def mac_address(self):
         """
         MAC address of the NIC.
@@ -150,14 +152,16 @@
 
                 :class:`~str`
         """  # noqa: E501
         return self.__mac_address
 
     @mac_address.setter
     def mac_address(self, mac_address):
+        if mac_address is None:
+            raise ValueError("Invalid value for `mac_address`, must not be `None`")  # noqa: E501
         if mac_address is not None and not re.search('^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$', mac_address):  # noqa: E501
             raise ValueError(r"Invalid value for `mac_address`, must be a follow pattern or equal to `/^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$/`")  # noqa: E501
 
         self.__mac_address = mac_address
 
     @property
     def _reserved(self):
@@ -194,28 +198,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/GatewayNodeReference.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/GatewayNodeReference.py`

 * *Files 3% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.IPAddress import IPAddress  # noqa: F401,E501
 
 class GatewayNodeReference(object):
 
     """Reference of gateway nodes
 
     :param node_id: (:attr:`node_id`) 
@@ -67,33 +68,33 @@
             self.__node_ip_address = node_ip_address
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.GatewayNodeReference'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.GatewayNodeReference'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -171,28 +172,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/GatewayProjection.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/GatewayProjection.py`

 * *Files 3% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_networking_py_client.models
 from ntnx_networking_py_client.models.OneOfnetworking.v4.config.GatewayProjectionservices import GatewayProjectionservices  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.Gateway import Gateway  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.GatewayDeployment import GatewayDeployment  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.Status import Status  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.Vm import Vm  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.VmProjection import VmProjection  # noqa: F401,E501
@@ -108,16 +109,16 @@
             self.__vpc_projection = vpc_projection
         if vm_projection is not None:
             self.__vm_projection = vm_projection
 
     def _initialize_object_type(self):
         return 'networking.v4.config.GatewayProjection'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.GatewayProjection'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     @property
     def vpc_projection(self):
         """
         
 
@@ -150,30 +151,35 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/GatewayRole.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/StretchConnectionType.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,71 +3,72 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class GatewayRole(object):
+class StretchConnectionType(object):
 
-    """Local gateway role (acceptor or initiator) in the connection
+    """Type of the connection used for stretching the subnet. The default is VPN.
 
 
     Allowed enum values:
 
         - _UNKNOWN
         - _REDACTED
-        - INITIATOR: Gateway role to initiate connection.
-        - ACCEPTOR: Gateway role to accept connection.
+        - VPN: VPN connection is used for stretching the subnet.
+        - VXLAN: VXLAN connection is used for stretching the subnet.
     """
     _UNKNOWN = "$UNKNOWN"
     _REDACTED = "$REDACTED"
-    INITIATOR = "INITIATOR"
-    ACCEPTOR = "ACCEPTOR"
+    VPN = "VPN"
+    VXLAN = "VXLAN"
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.GatewayRole'
+        return 'networking.v4.config.StretchConnectionType'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.GatewayRole'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -82,36 +83,41 @@
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(GatewayRole, dict):
+        if issubclass(StretchConnectionType, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -123,15 +129,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, GatewayRole):
+        if not isinstance(other, StretchConnectionType):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/Host.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/Host.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.networking.v4.config.IPv4Subnet import IPv4Subnet  # noqa: F401,E501
 
 class Host(object):
 
     """Input body to configure hosts
 
     :param ext_id: (:attr:`ext_id`) Reference to the host
@@ -86,33 +87,33 @@
             self.__route_table = route_table
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.Host'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.Host'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -243,28 +244,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/ICMPObject.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ICMPObject.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
 class ICMPObject(object):
 
     """ICMP parameters to be matched in routing policy.
 
     :param icmp_type: (:attr:`icmp_type`) 
     :type icmp_type: 
@@ -66,33 +67,33 @@
             self.__icmp_code = icmp_code
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.ICMPObject'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.ICMPObject'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -177,28 +178,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/IPConfig.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ListUplinkBondsApiResponse.py`

 * *Files 12% similar despite different names*

```diff
@@ -3,140 +3,143 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_networking_py_client.models.networking.v4.config.IPv4Config import IPv4Config  # noqa: F401,E501
-from ntnx_networking_py_client.models.networking.v4.config.IPv6Config import IPv6Config  # noqa: F401,E501
-
-class IPConfig(object):
-
-    """IP configuration.
-
-    :param ipv4: (:attr:`ipv4`) 
-    :type ipv4: 
-    :param ipv6: (:attr:`ipv6`) 
-    :type ipv6: 
+from pathlib import Path
+import ntnx_networking_py_client.models
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListUplinkBondsApiResponsedata import ListUplinkBondsApiResponsedata  # noqa: F401,E501
+from ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class ListUplinkBondsApiResponse(object):
+
+    """REST response for all response codes in API path /networking/v4.0.b1/config/uplink-bonds Get operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'ipv4': 'networking.v4.config.IPv4Config',
-        'ipv6': 'networking.v4.config.IPv6Config',
+        'metadata': 'common.v1.response.ApiResponseMetadata',
+        'data': 'OneOfnetworking.v4.config.ListUplinkBondsApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'ipv4': 'ipv4',
-        'ipv6': 'ipv6',
+        'metadata': 'metadata',
+        'data': 'data',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, ipv4=None, ipv6=None, *args, **kwargs):  # noqa: E501
-        self.__ipv4 = None
-        self.__ipv6 = None
+    def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
+        self.__metadata = None
+        self.__data = None
         self.discriminator = None
-        if ipv4 is not None:
-            self.__ipv4 = ipv4
-        if ipv6 is not None:
-            self.__ipv6 = ipv6
+        if metadata is not None:
+            self.__metadata = metadata
+        if data is not None:
+            self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.IPConfig'
+        return 'networking.v4.config.ListUplinkBondsApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.IPConfig'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def ipv4(self):
+    def metadata(self):
         """
         
 
         :type:
-            :class:`~ntnx_networking_py_client.models.networking.v4.config.IPv4Config`
+            :class:`~ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata`
         """  # noqa: E501
-        return self.__ipv4
+        return self.__metadata
 
-    @ipv4.setter
-    def ipv4(self, ipv4):
+    @metadata.setter
+    def metadata(self, metadata):
 
-        self.__ipv4 = ipv4
+        self.__metadata = metadata
 
     @property
-    def ipv6(self):
+    def data(self):
         """
         
 
         :type:
-            :class:`~ntnx_networking_py_client.models.networking.v4.config.IPv6Config`
-        """  # noqa: E501
-        return self.__ipv6
+                :class:`~ntnx_networking_py_client.models.networking.v4.config.UplinkBond` | 
+                :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse`
+                    """  # noqa: E501
+        return self.__data
 
-    @ipv6.setter
-    def ipv6(self, ipv6):
+    @data.setter
+    def data(self, data):
 
-        self.__ipv6 = ipv6
+        self.__data = data
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -169,37 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
+            if attr_type.startswith('OneOf'):
+                type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(IPConfig, dict):
+        if issubclass(ListUplinkBondsApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -211,25 +221,16 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, IPConfig):
+        if not isinstance(other, ListUplinkBondsApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
 
-    def has_ipv4(self):
-        """Returns true if `ipv4` has non-none value"""
-        return self._ipv4 is None
-    def has_ipv6(self):
-        """Returns true if `ipv6` has non-none value"""
-        return self._ipv6 is None
-    def is_valid(self):
-        """Returns true if any one of the attributes has non-none value"""
-        return self.has_ipv4() or self.has_ipv6()
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/IPFIXExporter.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/IPFIXExporter.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.Metadata import Metadata  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.ExportScope import ExportScope  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.ExporterProtocol import ExporterProtocol  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.NetworkingBaseModel import NetworkingBaseModel  # noqa: F401,E501
 
 class IPFIXExporter(NetworkingBaseModel):
 
@@ -107,16 +108,16 @@
         self.__export_scopes = export_scopes
         if description is not None:
             self.__description = description
 
     def _initialize_object_type(self):
         return 'networking.v4.config.IPFIXExporter'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.IPFIXExporter'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     @property
     def name(self):
         """
         Name of the IPFIX Exporter.
 
@@ -243,28 +244,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/IPFIXExporterApiResponse.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/GetSubnetApiResponse.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_networking_py_client.models
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.IPFIXExporterApiResponsedata import IPFIXExporterApiResponsedata  # noqa: F401,E501
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.GetSubnetApiResponsedata import GetSubnetApiResponsedata  # noqa: F401,E501
 from ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class IPFIXExporterApiResponse(object):
+class GetSubnetApiResponse(object):
 
-    """REST response for all response codes in API path /networking/v4.0.b1/config/ipfix-exporters/{extId} Get operation
+    """REST response for all response codes in API path /networking/v4.0.b1/config/subnets/{extId} Get operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfnetworking.v4.config.IPFIXExporterApiResponsedata',
+        'data': 'OneOfnetworking.v4.config.GetSubnetApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.IPFIXExporterApiResponse'
+        return 'networking.v4.config.GetSubnetApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.IPFIXExporterApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -122,15 +123,15 @@
 
     @property
     def data(self):
         """
         
 
         :type:
-                :class:`~ntnx_networking_py_client.models.networking.v4.config.IPFIXExporter` | 
+                :class:`~ntnx_networking_py_client.models.networking.v4.config.Subnet` | 
                 :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse`
                     """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
@@ -171,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(IPFIXExporterApiResponse, dict):
+        if issubclass(GetSubnetApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, IPFIXExporterApiResponse):
+        if not isinstance(other, GetSubnetApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/IPFIXExporterListApiResponse.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/GetVpcApiResponse.py`

 * *Files 15% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_networking_py_client.models
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.IPFIXExporterListApiResponsedata import IPFIXExporterListApiResponsedata  # noqa: F401,E501
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.GetVpcApiResponsedata import GetVpcApiResponsedata  # noqa: F401,E501
 from ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class IPFIXExporterListApiResponse(object):
+class GetVpcApiResponse(object):
 
-    """REST response for all response codes in API path /networking/v4.0.b1/config/ipfix-exporters Get operation
+    """REST response for all response codes in API path /networking/v4.0.b1/config/vpcs/{extId} Get operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfnetworking.v4.config.IPFIXExporterListApiResponsedata',
+        'data': 'OneOfnetworking.v4.config.GetVpcApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.IPFIXExporterListApiResponse'
+        return 'networking.v4.config.GetVpcApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.IPFIXExporterListApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -122,15 +123,15 @@
 
     @property
     def data(self):
         """
         
 
         :type:
-                :class:`~ntnx_networking_py_client.models.networking.v4.config.IPFIXExporter` | 
+                :class:`~ntnx_networking_py_client.models.networking.v4.config.Vpc` | 
                 :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse`
                     """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
@@ -171,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(IPFIXExporterListApiResponse, dict):
+        if issubclass(GetVpcApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, IPFIXExporterListApiResponse):
+        if not isinstance(other, GetVpcApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/IPPoolUsage.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/IPPoolUsage.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.networking.v4.config.IPv4Pool import IPv4Pool  # noqa: F401,E501
 
 class IPPoolUsage(object):
 
     """IP pool Usage.
 
     :param num_free_i_ps: (:attr:`num_free_i_ps`) Number of free IPs.
@@ -74,33 +75,33 @@
             self.__range = range
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.IPPoolUsage'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.IPPoolUsage'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -196,28 +197,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/IPSubnet.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/IPSubnet.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.networking.v4.config.IPv4Subnet import IPv4Subnet  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.IPv6Subnet import IPv6Subnet  # noqa: F401,E501
 
 class IPSubnet(object):
 
     """
 
@@ -68,33 +69,33 @@
             self.__ipv6 = ipv6
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.IPSubnet'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.IPSubnet'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -169,28 +170,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/IPUsage.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/IPUsage.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.networking.v4.config.IPPoolUsage import IPPoolUsage  # noqa: F401,E501
 
 class IPUsage(object):
 
     """IP usage statistics.
 
     :param num_macs: (:attr:`num_macs`) Number of MAC addresses.
@@ -81,33 +82,33 @@
             self.__ip_pool_usages = ip_pool_usages
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.IPUsage'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.IPUsage'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -221,28 +222,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/IPv4Config.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/IPv4Config.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.IPv4Address import IPv4Address  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.IPv4Pool import IPv4Pool  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.IPv4Subnet import IPv4Subnet  # noqa: F401,E501
 
 class IPv4Config(object):
 
     """IP V4 configuration.
@@ -82,33 +83,33 @@
             self.__pool_list = pool_list
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.IPv4Config'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.IPv4Config'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -215,28 +216,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/IPv4Pool.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/IPv4Pool.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.IPv4Address import IPv4Address  # noqa: F401,E501
 
 class IPv4Pool(object):
 
     """Start/end IP address range.
 
     :param start_ip: (:attr:`start_ip`) 
@@ -65,33 +66,33 @@
         self.__end_ip = end_ip
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.IPv4Pool'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.IPv4Pool'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -170,28 +171,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/IPv4Subnet.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/IPv6Subnet.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,28 +3,29 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_networking_py_client.models.common.v1.config.IPv4Address import IPv4Address  # noqa: F401,E501
+from pathlib import Path
+from ntnx_networking_py_client.models.common.v1.config.IPv6Address import IPv6Address  # noqa: F401,E501
 
-class IPv4Subnet(object):
+class IPv6Subnet(object):
 
     """
 
     :param ip: (:attr:`ip`) 
     :type ip: required
     :param prefix_length: (:attr:`prefix_length`) 
     :type prefix_length: required
@@ -36,15 +37,15 @@
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'ip': 'common.v1.config.IPv4Address',
+        'ip': 'common.v1.config.IPv6Address',
         'prefix_length': 'int',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
@@ -63,35 +64,35 @@
         self.discriminator = None
         self.__ip = ip
         self.__prefix_length = prefix_length
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.IPv4Subnet'
+        return 'networking.v4.config.IPv6Subnet'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.IPv4Subnet'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -103,15 +104,15 @@
 
     @property
     def ip(self):
         """
         
 
         :type:
-            :class:`~ntnx_networking_py_client.models.common.v1.config.IPv4Address`
+            :class:`~ntnx_networking_py_client.models.common.v1.config.IPv6Address`
         """  # noqa: E501
         return self.__ip
 
     @ip.setter
     def ip(self, ip):
         if ip is None:
             raise ValueError("Invalid value for `ip`, must not be `None`")  # noqa: E501
@@ -129,16 +130,16 @@
         """  # noqa: E501
         return self.__prefix_length
 
     @prefix_length.setter
     def prefix_length(self, prefix_length):
         if prefix_length is None:
             raise ValueError("Invalid value for `prefix_length`, must not be `None`")  # noqa: E501
-        if prefix_length is not None and prefix_length > 32:  # noqa: E501
-            raise ValueError("Invalid value for `prefix_length`, must be a value less than or equal to `32`")  # noqa: E501
+        if prefix_length is not None and prefix_length > 128:  # noqa: E501
+            raise ValueError("Invalid value for `prefix_length`, must be a value less than or equal to `128`")  # noqa: E501
         if prefix_length is not None and prefix_length < 0:  # noqa: E501
             raise ValueError("Invalid value for `prefix_length`, must be a value greater than or equal to `0`")  # noqa: E501
 
         self.__prefix_length = prefix_length
 
     @property
     def _reserved(self):
@@ -175,37 +176,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(IPv4Subnet, dict):
+        if issubclass(IPv6Subnet, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -217,15 +223,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, IPv4Subnet):
+        if not isinstance(other, IPv6Subnet):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/IPv6Config.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ListBgpSessionsApiResponse.py`

 * *Files 13% similar despite different names*

```diff
@@ -3,186 +3,144 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_networking_py_client.models.common.v1.config.IPv6Address import IPv6Address  # noqa: F401,E501
-from ntnx_networking_py_client.models.networking.v4.config.IPv6Pool import IPv6Pool  # noqa: F401,E501
-from ntnx_networking_py_client.models.networking.v4.config.IPv6Subnet import IPv6Subnet  # noqa: F401,E501
-
-class IPv6Config(object):
-
-    """IP V6 configuration.
-
-    :param ip_subnet: (:attr:`ip_subnet`) 
-    :type ip_subnet: required
-    :param default_gateway_ip: (:attr:`default_gateway_ip`) 
-    :type default_gateway_ip: 
-    :param dhcp_server_address: (:attr:`dhcp_server_address`) 
-    :type dhcp_server_address: 
-    :param pool_list: (:attr:`pool_list`) Pool of IP addresses from where IPs are allocated.
-    :type pool_list: 
+from pathlib import Path
+import ntnx_networking_py_client.models
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListBgpSessionsApiResponsedata import ListBgpSessionsApiResponsedata  # noqa: F401,E501
+from ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class ListBgpSessionsApiResponse(object):
+
+    """REST response for all response codes in API path /networking/v4.0.b1/config/bgp-sessions Get operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'ip_subnet': 'networking.v4.config.IPv6Subnet',
-        'default_gateway_ip': 'common.v1.config.IPv6Address',
-        'dhcp_server_address': 'common.v1.config.IPv6Address',
-        'pool_list': 'list[networking.v4.config.IPv6Pool]',
+        'metadata': 'common.v1.response.ApiResponseMetadata',
+        'data': 'OneOfnetworking.v4.config.ListBgpSessionsApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'ip_subnet': 'ipSubnet',
-        'default_gateway_ip': 'defaultGatewayIp',
-        'dhcp_server_address': 'dhcpServerAddress',
-        'pool_list': 'poolList',
+        'metadata': 'metadata',
+        'data': 'data',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, ip_subnet=None, default_gateway_ip=None, dhcp_server_address=None, pool_list=None, *args, **kwargs):  # noqa: E501
-        self.__ip_subnet = None
-        self.__default_gateway_ip = None
-        self.__dhcp_server_address = None
-        self.__pool_list = None
+    def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
+        self.__metadata = None
+        self.__data = None
         self.discriminator = None
-        self.__ip_subnet = ip_subnet
-        if default_gateway_ip is not None:
-            self.__default_gateway_ip = default_gateway_ip
-        if dhcp_server_address is not None:
-            self.__dhcp_server_address = dhcp_server_address
-        if pool_list is not None:
-            self.__pool_list = pool_list
+        if metadata is not None:
+            self.__metadata = metadata
+        if data is not None:
+            self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.IPv6Config'
+        return 'networking.v4.config.ListBgpSessionsApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.IPv6Config'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def ip_subnet(self):
+    def metadata(self):
         """
         
 
         :type:
-            :class:`~ntnx_networking_py_client.models.networking.v4.config.IPv6Subnet`
+            :class:`~ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata`
         """  # noqa: E501
-        return self.__ip_subnet
+        return self.__metadata
 
-    @ip_subnet.setter
-    def ip_subnet(self, ip_subnet):
-        if ip_subnet is None:
-            raise ValueError("Invalid value for `ip_subnet`, must not be `None`")  # noqa: E501
+    @metadata.setter
+    def metadata(self, metadata):
 
-        self.__ip_subnet = ip_subnet
+        self.__metadata = metadata
 
     @property
-    def default_gateway_ip(self):
+    def data(self):
         """
         
 
         :type:
-            :class:`~ntnx_networking_py_client.models.common.v1.config.IPv6Address`
-        """  # noqa: E501
-        return self.__default_gateway_ip
-
-    @default_gateway_ip.setter
-    def default_gateway_ip(self, default_gateway_ip):
-
-        self.__default_gateway_ip = default_gateway_ip
-
-    @property
-    def dhcp_server_address(self):
-        """
-        
-
-        :type:
-            :class:`~ntnx_networking_py_client.models.common.v1.config.IPv6Address`
-        """  # noqa: E501
-        return self.__dhcp_server_address
+                :class:`~ntnx_networking_py_client.models.networking.v4.config.BgpSession` | 
+                :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse` | 
+                :class:`~ntnx_networking_py_client.models.networking.v4.config.BgpSessionProjection`
+                    """  # noqa: E501
+        return self.__data
 
-    @dhcp_server_address.setter
-    def dhcp_server_address(self, dhcp_server_address):
+    @data.setter
+    def data(self, data):
 
-        self.__dhcp_server_address = dhcp_server_address
-
-    @property
-    def pool_list(self):
-        """
-        Pool of IP addresses from where IPs are allocated.
-
-        :type:
-             list[ :class:`~ntnx_networking_py_client.models.networking.v4.config.IPv6Pool` ]
-        """  # noqa: E501
-        return self.__pool_list
-
-    @pool_list.setter
-    def pool_list(self, pool_list):
-
-        self.__pool_list = pool_list
+        self.__data = data
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -215,37 +173,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
+            if attr_type.startswith('OneOf'):
+                type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(IPv6Config, dict):
+        if issubclass(ListBgpSessionsApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -257,15 +222,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, IPv6Config):
+        if not isinstance(other, ListBgpSessionsApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/IPv6Pool.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/IPv6Pool.py`

 * *Files 11% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.IPv6Address import IPv6Address  # noqa: F401,E501
 
 class IPv6Pool(object):
 
     """Start/end IP address range.
 
     :param start_ip: (:attr:`start_ip`) 
@@ -65,33 +66,33 @@
         self.__end_ip = end_ip
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.IPv6Pool'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.IPv6Pool'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -170,28 +171,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/IPv6Subnet.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/VpcDhcpOptions.py`

 * *Files 14% similar despite different names*

```diff
@@ -3,146 +3,118 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_networking_py_client.models.common.v1.config.IPv6Address import IPv6Address  # noqa: F401,E501
+from pathlib import Path
+from ntnx_networking_py_client.models.common.v1.config.IPAddress import IPAddress  # noqa: F401,E501
 
-class IPv6Subnet(object):
+class VpcDhcpOptions(object):
 
-    """
+    """List of DHCP options to be configured.
 
-    :param ip: (:attr:`ip`) 
-    :type ip: required
-    :param prefix_length: (:attr:`prefix_length`) 
-    :type prefix_length: required
+    :param domain_name_servers: (:attr:`domain_name_servers`) List of Domain Name Server addresses (option 6).
+    :type domain_name_servers: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'ip': 'common.v1.config.IPv6Address',
-        'prefix_length': 'int',
+        'domain_name_servers': 'list[common.v1.config.IPAddress]',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'ip': 'ip',
-        'prefix_length': 'prefixLength',
+        'domain_name_servers': 'domainNameServers',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, ip=None, prefix_length=None, *args, **kwargs):  # noqa: E501
-        self.__ip = None
-        self.__prefix_length = None
+    def __init__(self, domain_name_servers=None, *args, **kwargs):  # noqa: E501
+        self.__domain_name_servers = None
         self.discriminator = None
-        self.__ip = ip
-        self.__prefix_length = prefix_length
+        if domain_name_servers is not None:
+            self.__domain_name_servers = domain_name_servers
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.IPv6Subnet'
+        return 'networking.v4.config.VpcDhcpOptions'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.IPv6Subnet'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def ip(self):
-        """
-        
-
-        :type:
-            :class:`~ntnx_networking_py_client.models.common.v1.config.IPv6Address`
-        """  # noqa: E501
-        return self.__ip
-
-    @ip.setter
-    def ip(self, ip):
-        if ip is None:
-            raise ValueError("Invalid value for `ip`, must not be `None`")  # noqa: E501
-
-        self.__ip = ip
-
-    @property
-    def prefix_length(self):
+    def domain_name_servers(self):
         """
-        
+        List of Domain Name Server addresses (option 6).
 
         :type:
-
-                :class:`~int`
+             list[ :class:`~ntnx_networking_py_client.models.common.v1.config.IPAddress` ]
         """  # noqa: E501
-        return self.__prefix_length
+        return self.__domain_name_servers
 
-    @prefix_length.setter
-    def prefix_length(self, prefix_length):
-        if prefix_length is None:
-            raise ValueError("Invalid value for `prefix_length`, must not be `None`")  # noqa: E501
-        if prefix_length is not None and prefix_length > 128:  # noqa: E501
-            raise ValueError("Invalid value for `prefix_length`, must be a value less than or equal to `128`")  # noqa: E501
-        if prefix_length is not None and prefix_length < 0:  # noqa: E501
-            raise ValueError("Invalid value for `prefix_length`, must be a value greater than or equal to `0`")  # noqa: E501
+    @domain_name_servers.setter
+    def domain_name_servers(self, domain_name_servers):
 
-        self.__prefix_length = prefix_length
+        self.__domain_name_servers = domain_name_servers
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -175,37 +147,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(IPv6Subnet, dict):
+        if issubclass(VpcDhcpOptions, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -217,15 +194,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, IPv6Subnet):
+        if not isinstance(other, VpcDhcpOptions):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/IbgpConfig.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/IbgpConfig.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.IPAddress import IPAddress  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.BgpConfig import BgpConfig  # noqa: F401,E501
 
 class IbgpConfig(BgpConfig):
 
     """Internal BGP configuration
 
@@ -66,16 +67,16 @@
         self.discriminator = None
         if peer_ip is not None:
             self.__peer_ip = peer_ip
 
     def _initialize_object_type(self):
         return 'networking.v4.config.IbgpConfig'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.IbgpConfig'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     @property
     def peer_ip(self):
         """
         
 
@@ -93,28 +94,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/InternalRoutingConfig.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/InternalRoutingConfig.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.networking.v4.config.IPSubnet import IPSubnet  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.IbgpConfig import IbgpConfig  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.OspfConfig import OspfConfig  # noqa: F401,E501
 
 class InternalRoutingConfig(object):
 
     """Describes the routing protocol configuration spec needed by this gateway to peer and learn routes from internal routers using either iBGP or OSPF. 
@@ -76,33 +77,33 @@
             self.__local_prefix_list = local_prefix_list
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.InternalRoutingConfig'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.InternalRoutingConfig'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -192,28 +193,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/IpReserveSpec.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/IpReserveSpec.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.IPAddress import IPAddress  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.ReserveType import ReserveType  # noqa: F401,E501
 
 class IpReserveSpec(object):
 
     """Input required to reserve IP addresses on a subnet.
 
@@ -88,33 +89,33 @@
             self.__client_context = client_context
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.IpReserveSpec'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.IpReserveSpec'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -238,28 +239,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/IpUnreserveSpec.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/IpUnreserveSpec.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.IPAddress import IPAddress  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.UnreserveType import UnreserveType  # noqa: F401,E501
 
 class IpUnreserveSpec(object):
 
     """Input required to unreserve IP addresses on a subnet.
 
@@ -88,33 +89,33 @@
         self.__unreserve_type = unreserve_type
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.IpUnreserveSpec'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.IpUnreserveSpec'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -238,28 +239,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/IpsecConfig.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/IpsecConfig.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.IPAddress import IPAddress  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.AuthenticationAlgorithm import AuthenticationAlgorithm  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.EncryptionAlgorithm import EncryptionAlgorithm  # noqa: F401,E501
 
 class IpsecConfig(object):
 
     """IPSec configuration
@@ -138,33 +139,33 @@
             self.__ipsec_authentication_algorithm = ipsec_authentication_algorithm
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.IpsecConfig'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.IpsecConfig'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -397,28 +398,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/Layer2Stretch.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/Layer2Stretch.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.Metadata import Metadata  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.NetworkingBaseModel import NetworkingBaseModel  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.RemoteVtepStretchStatus import RemoteVtepStretchStatus  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.SiteParams import SiteParams  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.StretchConnectionType import StretchConnectionType  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.StretchStatus import StretchStatus  # noqa: F401,E501
 
@@ -127,16 +128,16 @@
             self.__mtu = mtu
         if vni is not None:
             self.__vni = vni
 
     def _initialize_object_type(self):
         return 'networking.v4.config.Layer2Stretch'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.Layer2Stretch'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     @property
     def name(self):
         """
         Layer2 stretch configuration name.
 
@@ -290,28 +291,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/Layer2StretchApiResponse.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/stats/GetLayer2StretchStatsApiResponse.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_networking_py_client.models
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.Layer2StretchApiResponsedata import Layer2StretchApiResponsedata  # noqa: F401,E501
+from ntnx_networking_py_client.models.OneOfnetworking.v4.stats.GetLayer2StretchStatsApiResponsedata import GetLayer2StretchStatsApiResponsedata  # noqa: F401,E501
 from ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class Layer2StretchApiResponse(object):
+class GetLayer2StretchStatsApiResponse(object):
 
-    """REST response for all response codes in API path /networking/v4.0.b1/config/layer2-stretches/{extId} Get operation
+    """REST response for all response codes in API path /networking/v4.0.b1/stats/layer2-stretches/{extId} Get operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfnetworking.v4.config.Layer2StretchApiResponsedata',
+        'data': 'OneOfnetworking.v4.stats.GetLayer2StretchStatsApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.Layer2StretchApiResponse'
+        return 'networking.v4.stats.GetLayer2StretchStatsApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.Layer2StretchApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -122,15 +123,15 @@
 
     @property
     def data(self):
         """
         
 
         :type:
-                :class:`~ntnx_networking_py_client.models.networking.v4.config.Layer2Stretch` | 
+                :class:`~ntnx_networking_py_client.models.networking.v4.stats.Layer2StretchStats` | 
                 :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse`
                     """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
@@ -171,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(Layer2StretchApiResponse, dict):
+        if issubclass(GetLayer2StretchStatsApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, Layer2StretchApiResponse):
+        if not isinstance(other, GetLayer2StretchStatsApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/Layer2StretchListApiResponse.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/stats/TaskReferenceApiResponse.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_networking_py_client.models
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.Layer2StretchListApiResponsedata import Layer2StretchListApiResponsedata  # noqa: F401,E501
+from ntnx_networking_py_client.models.OneOfnetworking.v4.stats.TaskReferenceApiResponsedata import TaskReferenceApiResponsedata  # noqa: F401,E501
 from ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class Layer2StretchListApiResponse(object):
+class TaskReferenceApiResponse(object):
 
-    """REST response for all response codes in API path /networking/v4.0.b1/config/layer2-stretches Get operation
+    """REST response for all response codes in API path /networking/v4.0.b1/stats/routing-policies/$actions/clear Post operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfnetworking.v4.config.Layer2StretchListApiResponsedata',
+        'data': 'OneOfnetworking.v4.stats.TaskReferenceApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.Layer2StretchListApiResponse'
+        return 'networking.v4.stats.TaskReferenceApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.Layer2StretchListApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -122,15 +123,15 @@
 
     @property
     def data(self):
         """
         
 
         :type:
-                :class:`~ntnx_networking_py_client.models.networking.v4.config.Layer2Stretch` | 
+                :class:`~ntnx_networking_py_client.models.prism.v4.config.TaskReference` | 
                 :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse`
                     """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
@@ -171,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
+                type = getattr(ntnx_networking_py_client.models, 'StatsTaskReferenceApiResponse')
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(Layer2StretchListApiResponse, dict):
+        if issubclass(TaskReferenceApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, Layer2StretchListApiResponse):
+        if not isinstance(other, TaskReferenceApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/Layer2StretchRelatedEntities.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/Layer2StretchRelatedEntities.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.networking.v4.config.Layer2StretchSubnetInfo import Layer2StretchSubnetInfo  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.Layer2StretchVpnConnectionInfo import Layer2StretchVpnConnectionInfo  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.Layer2StretchVtepGatewayInfo import Layer2StretchVtepGatewayInfo  # noqa: F401,E501
 
 class Layer2StretchRelatedEntities(object):
 
     """Layer2 stretch-related entities retrieved from the specified Prism Central cluster.
@@ -76,33 +77,33 @@
             self.__vtep_gateways = vtep_gateways
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.Layer2StretchRelatedEntities'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.Layer2StretchRelatedEntities'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -192,28 +193,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/Layer2StretchRelatedEntitiesApiResponse.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ListNodeSchedulableStatusesApiResponse.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_networking_py_client.models
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.Layer2StretchRelatedEntitiesApiResponsedata import Layer2StretchRelatedEntitiesApiResponsedata  # noqa: F401,E501
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListNodeSchedulableStatusesApiResponsedata import ListNodeSchedulableStatusesApiResponsedata  # noqa: F401,E501
 from ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class Layer2StretchRelatedEntitiesApiResponse(object):
+class ListNodeSchedulableStatusesApiResponse(object):
 
-    """REST response for all response codes in API path /networking/v4.0.b1/config/clusters/{extId}/layer2-stretches/related-entities Get operation
+    """REST response for all response codes in API path /networking/v4.0.b1/config/node-schedulable-status Get operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfnetworking.v4.config.Layer2StretchRelatedEntitiesApiResponsedata',
+        'data': 'OneOfnetworking.v4.config.ListNodeSchedulableStatusesApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.Layer2StretchRelatedEntitiesApiResponse'
+        return 'networking.v4.config.ListNodeSchedulableStatusesApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.Layer2StretchRelatedEntitiesApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -122,16 +123,17 @@
 
     @property
     def data(self):
         """
         
 
         :type:
-                :class:`~ntnx_networking_py_client.models.networking.v4.config.Layer2StretchRelatedEntities` | 
-                :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse`
+                :class:`~ntnx_networking_py_client.models.networking.v4.config.NodeSchedulableStatus` | 
+                :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse` | 
+                :class:`~ntnx_networking_py_client.models.networking.v4.config.NodeSchedulableStatusProjection`
                     """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
         self.__data = data
@@ -171,39 +173,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(Layer2StretchRelatedEntitiesApiResponse, dict):
+        if issubclass(ListNodeSchedulableStatusesApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +222,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, Layer2StretchRelatedEntitiesApiResponse):
+        if not isinstance(other, ListNodeSchedulableStatusesApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/Layer2StretchSubnetInfo.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/Layer2StretchSubnetInfo.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.EntityReference import EntityReference  # noqa: F401,E501
 from ntnx_networking_py_client.models.common.v1.config.IPAddress import IPAddress  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.IPSubnet import IPSubnet  # noqa: F401,E501
 
 class Layer2StretchSubnetInfo(object):
 
     """Information about a subnet from the specified Prism Central cluster.
@@ -97,33 +98,33 @@
             self.__cluster_reference = cluster_reference
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.Layer2StretchSubnetInfo'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.Layer2StretchSubnetInfo'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -259,28 +260,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/Layer2StretchVpnConnectionInfo.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/Layer2StretchVpnConnectionInfo.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.EntityReference import EntityReference  # noqa: F401,E501
 from ntnx_networking_py_client.models.common.v1.config.IPAddress import IPAddress  # noqa: F401,E501
 
 class Layer2StretchVpnConnectionInfo(object):
 
     """Information about a VPN connection from the specified Prism Central cluster.
 
@@ -89,33 +90,33 @@
             self.__vpc_reference = vpc_reference
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.Layer2StretchVpnConnectionInfo'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.Layer2StretchVpnConnectionInfo'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -235,28 +236,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/Layer2StretchVtepGatewayInfo.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/Layer2StretchVtepGatewayInfo.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.EntityReference import EntityReference  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.Vtep import Vtep  # noqa: F401,E501
 
 class Layer2StretchVtepGatewayInfo(object):
 
     """Information about a VTEP gateway.
 
@@ -103,33 +104,33 @@
             self.__vpc_reference = vpc_reference
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.Layer2StretchVtepGatewayInfo'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.Layer2StretchVtepGatewayInfo'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -285,28 +286,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/LayerFourProtocolObject.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/LayerFourProtocolObject.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.networking.v4.config.PortRange import PortRange  # noqa: F401,E501
 
 class LayerFourProtocolObject(object):
 
     """L4 TCP/UDP protocol parameters to be matched in routing policy.
 
     :param source_port_ranges: (:attr:`source_port_ranges`) 
@@ -67,33 +68,33 @@
             self.__destination_port_ranges = destination_port_ranges
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.LayerFourProtocolObject'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.LayerFourProtocolObject'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -168,28 +169,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/LearnedAddress.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/LearnedAddress.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.EntityReference import EntityReference  # noqa: F401,E501
 
 class LearnedAddress(object):
 
     """Information pertaining to a learned IP address on a subnet.
 
     :param vm_reference: (:attr:`vm_reference`) 
@@ -74,33 +75,33 @@
             self.__last_seen = last_seen
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.LearnedAddress'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.LearnedAddress'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -194,28 +195,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/LocalBgpGateway.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/LocalBgpGateway.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,37 +3,38 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.networking.v4.config.GatewayNic import GatewayNic  # noqa: F401,E501
 
 class LocalBgpGateway(object):
 
     """Local BGP gateway info needed for flow gateway scale out model.
 
     :param asn: (:attr:`asn`) ASN number of the BGP gateway.
-    :type asn: 
+    :type asn: required
     :param vnic_list: (:attr:`vnic_list`) 
-    :type vnic_list: 
+    :type vnic_list: required
     :param vnic_ip_prefix_length: (:attr:`vnic_ip_prefix_length`) Prefix length of the VNIC IP addresses of the local BGP gateways.
-    :type vnic_ip_prefix_length: 
+    :type vnic_ip_prefix_length: required
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
@@ -62,45 +63,42 @@
 
 
     def __init__(self, asn=None, vnic_list=None, vnic_ip_prefix_length=None, *args, **kwargs):  # noqa: E501
         self.__asn = None
         self.__vnic_list = None
         self.__vnic_ip_prefix_length = None
         self.discriminator = None
-        if asn is not None:
-            self.__asn = asn
-        if vnic_list is not None:
-            self.__vnic_list = vnic_list
-        if vnic_ip_prefix_length is not None:
-            self.__vnic_ip_prefix_length = vnic_ip_prefix_length
+        self.__asn = asn
+        self.__vnic_list = vnic_list
+        self.__vnic_ip_prefix_length = vnic_ip_prefix_length
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.LocalBgpGateway'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.LocalBgpGateway'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -119,14 +117,16 @@
 
                 :class:`~int`
         """  # noqa: E501
         return self.__asn
 
     @asn.setter
     def asn(self, asn):
+        if asn is None:
+            raise ValueError("Invalid value for `asn`, must not be `None`")  # noqa: E501
 
         self.__asn = asn
 
     @property
     def vnic_list(self):
         """
         
@@ -134,14 +134,16 @@
         :type:
              list[ :class:`~ntnx_networking_py_client.models.networking.v4.config.GatewayNic` ]
         """  # noqa: E501
         return self.__vnic_list
 
     @vnic_list.setter
     def vnic_list(self, vnic_list):
+        if vnic_list is None:
+            raise ValueError("Invalid value for `vnic_list`, must not be `None`")  # noqa: E501
 
         self.__vnic_list = vnic_list
 
     @property
     def vnic_ip_prefix_length(self):
         """
         Prefix length of the VNIC IP addresses of the local BGP gateways.
@@ -150,14 +152,16 @@
 
                 :class:`~int`
         """  # noqa: E501
         return self.__vnic_ip_prefix_length
 
     @vnic_ip_prefix_length.setter
     def vnic_ip_prefix_length(self, vnic_ip_prefix_length):
+        if vnic_ip_prefix_length is None:
+            raise ValueError("Invalid value for `vnic_ip_prefix_length`, must not be `None`")  # noqa: E501
 
         self.__vnic_ip_prefix_length = vnic_ip_prefix_length
 
     @property
     def _reserved(self):
         """
         
@@ -192,28 +196,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/LocalBgpService.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/LocalBgpService.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,31 +3,32 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
 class LocalBgpService(object):
 
     """BGP service hosted on this local gateway.
 
-    :param vpc_reference: (:attr:`vpc_reference`) Reference to the VPC that this network gateway serves as its BGP speaker.
+    :param vpc_reference: (:attr:`vpc_reference`) Reference to the VPC that this network gateway serves as its BGP speaker. Note that this BGP gateway will not service a regular VPC sitting behind a Transit VPC. 
     :type vpc_reference: 
     :param asn: (:attr:`asn`) Autonomous system number. 0 and 4294967295 are reserved.
     :type asn: required
 
     """
     """
     IGNORE:
@@ -65,33 +66,33 @@
         self.__asn = asn
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.LocalBgpService'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.LocalBgpService'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -100,15 +101,15 @@
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def vpc_reference(self):
         """
-        Reference to the VPC that this network gateway serves as its BGP speaker.
+        Reference to the VPC that this network gateway serves as its BGP speaker. Note that this BGP gateway will not service a regular VPC sitting behind a Transit VPC. 
 
         :type:
 
                 :class:`~str`
         """  # noqa: E501
         return self.__vpc_reference
 
@@ -176,28 +177,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/LocalNetworkServices.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/RemoteNetworkServices.py`

 * *Files 14% similar despite different names*

```diff
@@ -3,186 +3,164 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_networking_py_client.models.common.v1.config.IPAddress import IPAddress  # noqa: F401,E501
-from ntnx_networking_py_client.models.networking.v4.config.LocalBgpService import LocalBgpService  # noqa: F401,E501
-from ntnx_networking_py_client.models.networking.v4.config.LocalVpnService import LocalVpnService  # noqa: F401,E501
-from ntnx_networking_py_client.models.networking.v4.config.LocalVtepService import LocalVtepService  # noqa: F401,E501
-
-class LocalNetworkServices(object):
-
-    """Services of this local gateway
-
-    :param service_address: (:attr:`service_address`) 
-    :type service_address: 
-    :param local_vpn_service: (:attr:`local_vpn_service`) 
-    :type local_vpn_service: 
-    :param local_vtep_service: (:attr:`local_vtep_service`) 
-    :type local_vtep_service: 
-    :param local_bgp_service: (:attr:`local_bgp_service`) 
-    :type local_bgp_service: 
+from pathlib import Path
+from ntnx_networking_py_client.models.networking.v4.config.RemoteBgpService import RemoteBgpService  # noqa: F401,E501
+from ntnx_networking_py_client.models.networking.v4.config.RemoteVpnService import RemoteVpnService  # noqa: F401,E501
+from ntnx_networking_py_client.models.networking.v4.config.RemoteVtepService import RemoteVtepService  # noqa: F401,E501
+
+class RemoteNetworkServices(object):
+
+    """Services of this remote gateway
+
+    :param remote_vpn_service: (:attr:`remote_vpn_service`) 
+    :type remote_vpn_service: 
+    :param remote_vtep_service: (:attr:`remote_vtep_service`) 
+    :type remote_vtep_service: 
+    :param remote_bgp_service: (:attr:`remote_bgp_service`) 
+    :type remote_bgp_service: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'service_address': 'common.v1.config.IPAddress',
-        'local_vpn_service': 'networking.v4.config.LocalVpnService',
-        'local_vtep_service': 'networking.v4.config.LocalVtepService',
-        'local_bgp_service': 'networking.v4.config.LocalBgpService',
+        'remote_vpn_service': 'networking.v4.config.RemoteVpnService',
+        'remote_vtep_service': 'networking.v4.config.RemoteVtepService',
+        'remote_bgp_service': 'networking.v4.config.RemoteBgpService',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'service_address': 'serviceAddress',
-        'local_vpn_service': 'localVpnService',
-        'local_vtep_service': 'localVtepService',
-        'local_bgp_service': 'localBgpService',
+        'remote_vpn_service': 'remoteVpnService',
+        'remote_vtep_service': 'remoteVtepService',
+        'remote_bgp_service': 'remoteBgpService',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, service_address=None, local_vpn_service=None, local_vtep_service=None, local_bgp_service=None, *args, **kwargs):  # noqa: E501
-        self.__service_address = None
-        self.__local_vpn_service = None
-        self.__local_vtep_service = None
-        self.__local_bgp_service = None
+    def __init__(self, remote_vpn_service=None, remote_vtep_service=None, remote_bgp_service=None, *args, **kwargs):  # noqa: E501
+        self.__remote_vpn_service = None
+        self.__remote_vtep_service = None
+        self.__remote_bgp_service = None
         self.discriminator = None
-        if service_address is not None:
-            self.__service_address = service_address
-        if local_vpn_service is not None:
-            self.__local_vpn_service = local_vpn_service
-        if local_vtep_service is not None:
-            self.__local_vtep_service = local_vtep_service
-        if local_bgp_service is not None:
-            self.__local_bgp_service = local_bgp_service
+        if remote_vpn_service is not None:
+            self.__remote_vpn_service = remote_vpn_service
+        if remote_vtep_service is not None:
+            self.__remote_vtep_service = remote_vtep_service
+        if remote_bgp_service is not None:
+            self.__remote_bgp_service = remote_bgp_service
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.LocalNetworkServices'
+        return 'networking.v4.config.RemoteNetworkServices'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.LocalNetworkServices'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def service_address(self):
+    def remote_vpn_service(self):
         """
         
 
         :type:
-            :class:`~ntnx_networking_py_client.models.common.v1.config.IPAddress`
+            :class:`~ntnx_networking_py_client.models.networking.v4.config.RemoteVpnService`
         """  # noqa: E501
-        return self.__service_address
+        return self.__remote_vpn_service
 
-    @service_address.setter
-    def service_address(self, service_address):
+    @remote_vpn_service.setter
+    def remote_vpn_service(self, remote_vpn_service):
 
-        self.__service_address = service_address
+        self.__remote_vpn_service = remote_vpn_service
 
     @property
-    def local_vpn_service(self):
+    def remote_vtep_service(self):
         """
         
 
         :type:
-            :class:`~ntnx_networking_py_client.models.networking.v4.config.LocalVpnService`
+            :class:`~ntnx_networking_py_client.models.networking.v4.config.RemoteVtepService`
         """  # noqa: E501
-        return self.__local_vpn_service
+        return self.__remote_vtep_service
 
-    @local_vpn_service.setter
-    def local_vpn_service(self, local_vpn_service):
+    @remote_vtep_service.setter
+    def remote_vtep_service(self, remote_vtep_service):
 
-        self.__local_vpn_service = local_vpn_service
+        self.__remote_vtep_service = remote_vtep_service
 
     @property
-    def local_vtep_service(self):
+    def remote_bgp_service(self):
         """
         
 
         :type:
-            :class:`~ntnx_networking_py_client.models.networking.v4.config.LocalVtepService`
+            :class:`~ntnx_networking_py_client.models.networking.v4.config.RemoteBgpService`
         """  # noqa: E501
-        return self.__local_vtep_service
+        return self.__remote_bgp_service
 
-    @local_vtep_service.setter
-    def local_vtep_service(self, local_vtep_service):
+    @remote_bgp_service.setter
+    def remote_bgp_service(self, remote_bgp_service):
 
-        self.__local_vtep_service = local_vtep_service
-
-    @property
-    def local_bgp_service(self):
-        """
-        
-
-        :type:
-            :class:`~ntnx_networking_py_client.models.networking.v4.config.LocalBgpService`
-        """  # noqa: E501
-        return self.__local_bgp_service
-
-    @local_bgp_service.setter
-    def local_bgp_service(self, local_bgp_service):
-
-        self.__local_bgp_service = local_bgp_service
+        self.__remote_bgp_service = remote_bgp_service
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -215,37 +193,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(LocalNetworkServices, dict):
+        if issubclass(RemoteNetworkServices, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -257,15 +240,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, LocalNetworkServices):
+        if not isinstance(other, RemoteNetworkServices):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/LocalVpnService.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/LocalVpnService.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.networking.v4.config.BgpConfig import BgpConfig  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.InternalRoutingConfig import InternalRoutingConfig  # noqa: F401,E501
 
 class LocalVpnService(object):
 
     """VPN service hosted on this local gateway
 
@@ -68,33 +69,33 @@
             self.__peer_igp_config = peer_igp_config
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.LocalVpnService'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.LocalVpnService'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -169,28 +170,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/LocalVtepService.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/LocalVtepService.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
 class LocalVtepService(object):
 
     """VTEP service hosted on this local gateway
 
     :param vxlan_port: (:attr:`vxlan_port`) VXLAN port
     :type vxlan_port: required
@@ -58,33 +59,33 @@
         self.__vxlan_port = vxlan_port
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.LocalVtepService'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.LocalVtepService'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -151,28 +152,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/MigrationState.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/MigrationState.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
 class MigrationState(object):
 
     """Migration state of the subnet. This field is read-only.
 
 
     Allowed enum values:
@@ -41,33 +42,33 @@
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.MigrationState'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.MigrationState'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -82,27 +83,32 @@
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/NetworkCloudConfig.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/NetworkingBaseModel.py`

 * *Files 18% similar despite different names*

```diff
@@ -3,131 +3,134 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.Metadata import Metadata  # noqa: F401,E501
-from ntnx_networking_py_client.models.networking.v4.config.AzureConfig import AzureConfig  # noqa: F401,E501
-from ntnx_networking_py_client.models.networking.v4.config.NetworkingBaseModel import NetworkingBaseModel  # noqa: F401,E501
+from ntnx_networking_py_client.models.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
+from ntnx_networking_py_client.models.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel  # noqa: F401,E501
 
-class NetworkCloudConfig(NetworkingBaseModel):
+class NetworkingBaseModel(ExternalizableAbstractModel):
 
-    """
+    """Networking common base object
 
-    :param azure_config: (:attr:`azure_config`) 
-    :type azure_config: required
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'azure_config': 'networking.v4.config.AzureConfig',
         'metadata': 'common.v1.config.Metadata',
         'ext_id': 'str',
         'links': 'list[common.v1.response.ApiLink]',
         'tenant_id': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'azure_config': 'azureConfig',
         'metadata': 'metadata',
         'ext_id': 'extId',
         'links': 'links',
         'tenant_id': 'tenantId',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, azure_config=None, metadata=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
-        NetworkingBaseModel.__init__(self, metadata, ext_id, links, tenant_id, *args, **kwargs)
-        self.__azure_config = None
+    def __init__(self, metadata=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
+        ExternalizableAbstractModel.__init__(self, ext_id, links, tenant_id, *args, **kwargs)
+        self.__metadata = None
         self.discriminator = None
-        self.__azure_config = azure_config
+        if metadata is not None:
+            self.__metadata = metadata
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.NetworkCloudConfig'
+        return 'networking.v4.config.NetworkingBaseModel'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.NetworkCloudConfig'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     @property
-    def azure_config(self):
+    def metadata(self):
         """
         
 
         :type:
-            :class:`~ntnx_networking_py_client.models.networking.v4.config.AzureConfig`
+            :class:`~ntnx_networking_py_client.models.common.v1.config.Metadata`
         """  # noqa: E501
-        return self.__azure_config
+        return self.__metadata
 
-    @azure_config.setter
-    def azure_config(self, azure_config):
-        if azure_config is None:
-            raise ValueError("Invalid value for `azure_config`, must not be `None`")  # noqa: E501
+    @metadata.setter
+    def metadata(self, metadata):
 
-        self.__azure_config = azure_config
+        self.__metadata = metadata
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(NetworkCloudConfig, dict):
+        if issubclass(NetworkingBaseModel, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -139,15 +142,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, NetworkCloudConfig):
+        if not isinstance(other, NetworkingBaseModel):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/NetworkCloudConfigApiResponse.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/GetUplinkBondApiResponse.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_networking_py_client.models
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.NetworkCloudConfigApiResponsedata import NetworkCloudConfigApiResponsedata  # noqa: F401,E501
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.GetUplinkBondApiResponsedata import GetUplinkBondApiResponsedata  # noqa: F401,E501
 from ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class NetworkCloudConfigApiResponse(object):
+class GetUplinkBondApiResponse(object):
 
-    """REST response for all response codes in API path /networking/v4.0.b1/config/network-clouds/{extId} Get operation
+    """REST response for all response codes in API path /networking/v4.0.b1/config/uplink-bonds/{extId} Get operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfnetworking.v4.config.NetworkCloudConfigApiResponsedata',
+        'data': 'OneOfnetworking.v4.config.GetUplinkBondApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.NetworkCloudConfigApiResponse'
+        return 'networking.v4.config.GetUplinkBondApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.NetworkCloudConfigApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -122,15 +123,15 @@
 
     @property
     def data(self):
         """
         
 
         :type:
-                :class:`~ntnx_networking_py_client.models.networking.v4.config.NetworkCloudConfig` | 
+                :class:`~ntnx_networking_py_client.models.networking.v4.config.UplinkBond` | 
                 :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse`
                     """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
@@ -171,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(NetworkCloudConfigApiResponse, dict):
+        if issubclass(GetUplinkBondApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, NetworkCloudConfigApiResponse):
+        if not isinstance(other, GetUplinkBondApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/NetworkCloudConfigListApiResponse.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/GetVirtualSwitchApiResponse.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_networking_py_client.models
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.NetworkCloudConfigListApiResponsedata import NetworkCloudConfigListApiResponsedata  # noqa: F401,E501
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.GetVirtualSwitchApiResponsedata import GetVirtualSwitchApiResponsedata  # noqa: F401,E501
 from ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class NetworkCloudConfigListApiResponse(object):
+class GetVirtualSwitchApiResponse(object):
 
-    """REST response for all response codes in API path /networking/v4.0.b1/config/network-clouds Get operation
+    """REST response for all response codes in API path /networking/v4.0.b1/config/virtual-switches/{extId} Get operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfnetworking.v4.config.NetworkCloudConfigListApiResponsedata',
+        'data': 'OneOfnetworking.v4.config.GetVirtualSwitchApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.NetworkCloudConfigListApiResponse'
+        return 'networking.v4.config.GetVirtualSwitchApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.NetworkCloudConfigListApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -122,15 +123,15 @@
 
     @property
     def data(self):
         """
         
 
         :type:
-                :class:`~ntnx_networking_py_client.models.networking.v4.config.NetworkCloudConfig` | 
+                :class:`~ntnx_networking_py_client.models.networking.v4.config.VirtualSwitch` | 
                 :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse`
                     """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
@@ -171,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(NetworkCloudConfigListApiResponse, dict):
+        if issubclass(GetVirtualSwitchApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, NetworkCloudConfigListApiResponse):
+        if not isinstance(other, GetVirtualSwitchApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/NetworkController.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/NetworkController.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.Metadata import Metadata  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.CloudSubstrate import CloudSubstrate  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.ControllerStatus import ControllerStatus  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.DefaultVlanStack import DefaultVlanStack  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.NetworkingBaseModel import NetworkingBaseModel  # noqa: F401,E501
 
 class NetworkController(NetworkingBaseModel):
@@ -106,16 +107,16 @@
             self.__cloud_substrate = cloud_substrate
         if default_vlan_stack is not None:
             self.__default_vlan_stack = default_vlan_stack
 
     def _initialize_object_type(self):
         return 'networking.v4.config.NetworkController'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.NetworkController'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     @property
     def controller_status(self):
         """
         
 
@@ -211,28 +212,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/NetworkControllerApiResponse.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ListRouteTablesApiResponse.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_networking_py_client.models
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.NetworkControllerApiResponsedata import NetworkControllerApiResponsedata  # noqa: F401,E501
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListRouteTablesApiResponsedata import ListRouteTablesApiResponsedata  # noqa: F401,E501
 from ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class NetworkControllerApiResponse(object):
+class ListRouteTablesApiResponse(object):
 
-    """REST response for all response codes in API path /networking/v4.0.b1/config/controllers/{extId} Get operation
+    """REST response for all response codes in API path /networking/v4.0.b1/config/route-tables Get operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfnetworking.v4.config.NetworkControllerApiResponsedata',
+        'data': 'OneOfnetworking.v4.config.ListRouteTablesApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.NetworkControllerApiResponse'
+        return 'networking.v4.config.ListRouteTablesApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.NetworkControllerApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -122,15 +123,15 @@
 
     @property
     def data(self):
         """
         
 
         :type:
-                :class:`~ntnx_networking_py_client.models.networking.v4.config.NetworkController` | 
+                :class:`~ntnx_networking_py_client.models.networking.v4.config.RouteTable` | 
                 :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse`
                     """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
@@ -171,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(NetworkControllerApiResponse, dict):
+        if issubclass(ListRouteTablesApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, NetworkControllerApiResponse):
+        if not isinstance(other, ListRouteTablesApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/NetworkControllerListApiResponse.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ListVirtualSwitchesApiResponse.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_networking_py_client.models
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.NetworkControllerListApiResponsedata import NetworkControllerListApiResponsedata  # noqa: F401,E501
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListVirtualSwitchesApiResponsedata import ListVirtualSwitchesApiResponsedata  # noqa: F401,E501
 from ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class NetworkControllerListApiResponse(object):
+class ListVirtualSwitchesApiResponse(object):
 
-    """REST response for all response codes in API path /networking/v4.0.b1/config/controllers Get operation
+    """REST response for all response codes in API path /networking/v4.0.b1/config/virtual-switches Get operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfnetworking.v4.config.NetworkControllerListApiResponsedata',
+        'data': 'OneOfnetworking.v4.config.ListVirtualSwitchesApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.NetworkControllerListApiResponse'
+        return 'networking.v4.config.ListVirtualSwitchesApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.NetworkControllerListApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -122,16 +123,17 @@
 
     @property
     def data(self):
         """
         
 
         :type:
-                :class:`~ntnx_networking_py_client.models.networking.v4.config.NetworkController` | 
-                :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse`
+                :class:`~ntnx_networking_py_client.models.networking.v4.config.VirtualSwitch` | 
+                :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse` | 
+                :class:`~ntnx_networking_py_client.models.networking.v4.config.VirtualSwitchProjection`
                     """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
         self.__data = data
@@ -171,39 +173,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(NetworkControllerListApiResponse, dict):
+        if issubclass(ListVirtualSwitchesApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +222,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, NetworkControllerListApiResponse):
+        if not isinstance(other, ListVirtualSwitchesApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/NetworkingBaseModel.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/NodeSchedulableStatusProjection.py`

 * *Files 16% similar despite different names*

```diff
@@ -3,128 +3,112 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_networking_py_client.models.common.v1.config.Metadata import Metadata  # noqa: F401,E501
-from ntnx_networking_py_client.models.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
-from ntnx_networking_py_client.models.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel  # noqa: F401,E501
+from pathlib import Path
+from ntnx_networking_py_client.models.networking.v4.config.NodeSchedulableStatus import NodeSchedulableStatus  # noqa: F401,E501
 
-class NetworkingBaseModel(ExternalizableAbstractModel):
+class NodeSchedulableStatusProjection(NodeSchedulableStatus):
 
-    """Networking common base object
+    """
 
-    :param metadata: (:attr:`metadata`) 
-    :type metadata: 
+    :param ext_id: (:attr:`ext_id`) DocRef(ExtIdProp)
+    :type ext_id: required
+    :param is_never_schedulable: (:attr:`is_never_schedulable`) The boolean value to indicate whether or not node is a storage only node
+    :type is_never_schedulable: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'metadata': 'common.v1.config.Metadata',
         'ext_id': 'str',
-        'links': 'list[common.v1.response.ApiLink]',
-        'tenant_id': 'str',
+        'is_never_schedulable': 'bool',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'metadata': 'metadata',
         'ext_id': 'extId',
-        'links': 'links',
-        'tenant_id': 'tenantId',
+        'is_never_schedulable': 'isNeverSchedulable',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, metadata=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
-        ExternalizableAbstractModel.__init__(self, ext_id, links, tenant_id, *args, **kwargs)
-        self.__metadata = None
+    def __init__(self, ext_id=None, is_never_schedulable=None, *args, **kwargs):  # noqa: E501
+        NodeSchedulableStatus.__init__(self, ext_id, is_never_schedulable, *args, **kwargs)
         self.discriminator = None
-        if metadata is not None:
-            self.__metadata = metadata
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.NetworkingBaseModel'
-
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.NetworkingBaseModel'
-
+        return 'networking.v4.config.NodeSchedulableStatusProjection'
 
-    @property
-    def metadata(self):
-        """
-        
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
-        :type:
-            :class:`~ntnx_networking_py_client.models.common.v1.config.Metadata`
-        """  # noqa: E501
-        return self.__metadata
-
-    @metadata.setter
-    def metadata(self, metadata):
-
-        self.__metadata = metadata
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(NetworkingBaseModel, dict):
+        if issubclass(NodeSchedulableStatusProjection, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -136,15 +120,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, NetworkingBaseModel):
+        if not isinstance(other, NodeSchedulableStatusProjection):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/NexthopType.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ProtocolType.py`

 * *Files 9% similar despite different names*

```diff
@@ -3,77 +3,78 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class NexthopType(object):
+class ProtocolType(object):
 
-    """Next hop type.
+    """Routing Policy IP protocol type.
 
 
     Allowed enum values:
 
         - _UNKNOWN
         - _REDACTED
-        - IP_ADDRESS: Next hop is an IP address.
-        - DIRECT_CONNECT_VIF: Next hop is a direct connect VIF.
-        - INTERNAL_SUBNET: Next hop is an internal subnet.
-        - EXTERNAL_SUBNET: Next hop is an external subnet.
-        - VPN_CONNECTION: Next hop is a VPN connection.
+        - ANY: Routing policy protocol type is Any.
+        - ICMP: Routing policy protocol type is ICMP.
+        - TCP: Routing policy protocol type is TCP.
+        - UDP: Routing policy protocol type is UDP.
+        - PROTOCOL_NUMBER: Specify routing policy L4 protocol number.
     """
     _UNKNOWN = "$UNKNOWN"
     _REDACTED = "$REDACTED"
-    IP_ADDRESS = "IP_ADDRESS"
-    DIRECT_CONNECT_VIF = "DIRECT_CONNECT_VIF"
-    INTERNAL_SUBNET = "INTERNAL_SUBNET"
-    EXTERNAL_SUBNET = "EXTERNAL_SUBNET"
-    VPN_CONNECTION = "VPN_CONNECTION"
+    ANY = "ANY"
+    ICMP = "ICMP"
+    TCP = "TCP"
+    UDP = "UDP"
+    PROTOCOL_NUMBER = "PROTOCOL_NUMBER"
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.NexthopType'
+        return 'networking.v4.config.ProtocolType'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.NexthopType'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -88,36 +89,41 @@
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(NexthopType, dict):
+        if issubclass(ProtocolType, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -129,15 +135,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, NexthopType):
+        if not isinstance(other, ProtocolType):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/NodeSchedulableStatus.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/NodeSchedulableStatus.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,29 +3,30 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
 class NodeSchedulableStatus(object):
 
-    """Array of node UUIDs and boolean pairs, indicating whether the nodes are storage-only. Requires Prism Central >= pc.2022.9.
+    """Array of node UUIDs and boolean pairs, indicating whether the nodes are storage-only.
 
     :param ext_id: (:attr:`ext_id`) DocRef(ExtIdProp)
     :type ext_id: required
     :param is_never_schedulable: (:attr:`is_never_schedulable`) The boolean value to indicate whether or not node is a storage only node
     :type is_never_schedulable: 
 
     """
@@ -65,33 +66,33 @@
             self.__is_never_schedulable = is_never_schedulable
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.NodeSchedulableStatus'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.NodeSchedulableStatus'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -172,28 +173,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/NodeSchedulableStatusApiResponse.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/stats/GetTrafficMirrorStatsApiResponse.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_networking_py_client.models
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.NodeSchedulableStatusApiResponsedata import NodeSchedulableStatusApiResponsedata  # noqa: F401,E501
+from ntnx_networking_py_client.models.OneOfnetworking.v4.stats.GetTrafficMirrorStatsApiResponsedata import GetTrafficMirrorStatsApiResponsedata  # noqa: F401,E501
 from ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class NodeSchedulableStatusApiResponse(object):
+class GetTrafficMirrorStatsApiResponse(object):
 
-    """REST response for all response codes in API path /networking/v4.0.b1/config/node-schedulable-status Get operation
+    """REST response for all response codes in API path /networking/v4.0.b1/stats/traffic-mirrors/{extId} Get operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfnetworking.v4.config.NodeSchedulableStatusApiResponsedata',
+        'data': 'OneOfnetworking.v4.stats.GetTrafficMirrorStatsApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.NodeSchedulableStatusApiResponse'
+        return 'networking.v4.stats.GetTrafficMirrorStatsApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.NodeSchedulableStatusApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -122,17 +123,16 @@
 
     @property
     def data(self):
         """
         
 
         :type:
-                :class:`~ntnx_networking_py_client.models.networking.v4.config.NodeSchedulableStatus` | 
-                :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse` | 
-                :class:`~ntnx_networking_py_client.models.networking.v4.config.NodeSchedulableStatusProjection`
+                :class:`~ntnx_networking_py_client.models.networking.v4.stats.TrafficMirrorStats` | 
+                :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse`
                     """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
         self.__data = data
@@ -172,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(NodeSchedulableStatusApiResponse, dict):
+        if issubclass(GetTrafficMirrorStatsApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -216,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, NodeSchedulableStatusApiResponse):
+        if not isinstance(other, GetTrafficMirrorStatsApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/NodeSchedulableStatusProjection.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/VpcNameProjection.py`

 * *Files 16% similar despite different names*

```diff
@@ -3,106 +3,108 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_networking_py_client.models.networking.v4.config.NodeSchedulableStatus import NodeSchedulableStatus  # noqa: F401,E501
+from pathlib import Path
+from ntnx_networking_py_client.models.networking.v4.config.VpcName import VpcName  # noqa: F401,E501
 
-class NodeSchedulableStatusProjection(NodeSchedulableStatus):
+class VpcNameProjection(VpcName):
 
     """
 
-    :param ext_id: (:attr:`ext_id`) DocRef(ExtIdProp)
-    :type ext_id: required
-    :param is_never_schedulable: (:attr:`is_never_schedulable`) The boolean value to indicate whether or not node is a storage only node
-    :type is_never_schedulable: 
+    :param name: (:attr:`name`) VPC name
+    :type name: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'ext_id': 'str',
-        'is_never_schedulable': 'bool',
+        'name': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'ext_id': 'extId',
-        'is_never_schedulable': 'isNeverSchedulable',
+        'name': 'name',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, ext_id=None, is_never_schedulable=None, *args, **kwargs):  # noqa: E501
-        NodeSchedulableStatus.__init__(self, ext_id, is_never_schedulable, *args, **kwargs)
+    def __init__(self, name=None, *args, **kwargs):  # noqa: E501
+        VpcName.__init__(self, name, *args, **kwargs)
         self.discriminator = None
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.NodeSchedulableStatusProjection'
+        return 'networking.v4.config.VpcNameProjection'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.NodeSchedulableStatusProjection'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(NodeSchedulableStatusProjection, dict):
+        if issubclass(VpcNameProjection, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -114,15 +116,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, NodeSchedulableStatusProjection):
+        if not isinstance(other, VpcNameProjection):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/OspfConfig.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/OspfConfig.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.networking.v4.config.AuthenticationType import AuthenticationType  # noqa: F401,E501
 
 class OspfConfig(object):
 
     """OSPF configuration for route peering with internal routers.
 
     :param area_id: (:attr:`area_id`) OSPF area id of this gateway.
@@ -74,33 +75,33 @@
             self.__password = password
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.OspfConfig'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.OspfConfig'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -194,28 +195,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/PortRange.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/PortRange.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
 class PortRange(object):
 
     """Range of TCP/UDP ports.
 
     :param start_port: (:attr:`start_port`) 
     :type start_port: required
@@ -64,33 +65,33 @@
         self.__end_port = end_port
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.PortRange'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.PortRange'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -179,28 +180,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/PrivateIpAssociation.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/PrivateIpAssociation.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.IPAddress import IPAddress  # noqa: F401,E501
 
 class PrivateIpAssociation(object):
 
     """Private IP and VPC to which the floating IP is associated.
 
     :param private_ip: (:attr:`private_ip`) 
@@ -65,33 +66,33 @@
         self.__vpc_reference = vpc_reference
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.PrivateIpAssociation'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.PrivateIpAssociation'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -173,28 +174,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/ProtocolNumberObject.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ProtocolNumberObject.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
 class ProtocolNumberObject(object):
 
     """
 
     :param protocol_number: (:attr:`protocol_number`) 
     :type protocol_number: required
@@ -58,33 +59,33 @@
         self.__protocol_number = protocol_number
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.ProtocolNumberObject'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.ProtocolNumberObject'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -151,28 +152,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/ProtocolType.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/common/v1/config/MessageSeverity.py`

 * *Files 9% similar despite different names*

```diff
@@ -3,77 +3,77 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class ProtocolType(object):
+class MessageSeverity(object):
 
-    """Routing Policy IP protocol type.
+    """The message severity. 
 
 
     Allowed enum values:
 
         - _UNKNOWN
         - _REDACTED
-        - ANY: Routing policy protocol type is Any.
-        - ICMP: Routing policy protocol type is ICMP.
-        - TCP: Routing policy protocol type is TCP.
-        - UDP: Routing policy protocol type is UDP.
-        - PROTOCOL_NUMBER: Specify routing policy L4 protocol number.
+        - INFO: Information about successful completion.
+
+        - WARNING: Warning indicating future error.
+
+        - ERROR: Error indicating failed completion.
+
     """
     _UNKNOWN = "$UNKNOWN"
     _REDACTED = "$REDACTED"
-    ANY = "ANY"
-    ICMP = "ICMP"
-    TCP = "TCP"
-    UDP = "UDP"
-    PROTOCOL_NUMBER = "PROTOCOL_NUMBER"
+    INFO = "INFO"
+    WARNING = "WARNING"
+    ERROR = "ERROR"
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.ProtocolType'
+        return 'common.v1.config.MessageSeverity'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.ProtocolType'
+    def _initialize_object_version(self):
+        return 'v1.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -88,36 +88,41 @@
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ProtocolType, dict):
+        if issubclass(MessageSeverity, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -129,15 +134,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ProtocolType):
+        if not isinstance(other, MessageSeverity):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/PublicIpMapping.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/PublicIpMapping.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.IPAddress import IPAddress  # noqa: F401,E501
 
 class PublicIpMapping(object):
 
     """
 
     :param private_ip: (:attr:`private_ip`) 
@@ -65,33 +66,33 @@
         self.__public_ip = public_ip
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.PublicIpMapping'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.PublicIpMapping'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -170,28 +171,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/QosConfig.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/QosConfig.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
 class QosConfig(object):
 
     """Quality of Service configuration for the VPN IPSec tunnel
 
     :param ingress_limit_mbps: (:attr:`ingress_limit_mbps`) Ingress traffic limit (Mbps)
     :type ingress_limit_mbps: 
@@ -66,33 +67,33 @@
             self.__egress_limit_mbps = egress_limit_mbps
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.QosConfig'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.QosConfig'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -169,28 +170,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/RemoteBgpGateway.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/VmNic.py`

 * *Files 11% similar despite different names*

```diff
@@ -3,140 +3,118 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_networking_py_client.models.common.v1.config.IPAddress import IPAddress  # noqa: F401,E501
+from pathlib import Path
 
-class RemoteBgpGateway(object):
+class VmNic(object):
 
-    """Remote BGP gateway info needed for flow gateway scale out model.
+    """Virtal NIC for projections
 
-    :param asn: (:attr:`asn`) ASN number of the BGP gateway.
-    :type asn: 
-    :param ip_address: (:attr:`ip_address`) 
-    :type ip_address: 
+    :param private_ip: (:attr:`private_ip`) Private IP value in string
+    :type private_ip: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'asn': 'int',
-        'ip_address': 'common.v1.config.IPAddress',
+        'private_ip': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'asn': 'asn',
-        'ip_address': 'ipAddress',
+        'private_ip': 'privateIp',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, asn=None, ip_address=None, *args, **kwargs):  # noqa: E501
-        self.__asn = None
-        self.__ip_address = None
+    def __init__(self, private_ip=None, *args, **kwargs):  # noqa: E501
+        self.__private_ip = None
         self.discriminator = None
-        if asn is not None:
-            self.__asn = asn
-        if ip_address is not None:
-            self.__ip_address = ip_address
+        if private_ip is not None:
+            self.__private_ip = private_ip
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.RemoteBgpGateway'
+        return 'networking.v4.config.VmNic'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.RemoteBgpGateway'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def asn(self):
+    def private_ip(self):
         """
-        ASN number of the BGP gateway.
+        Private IP value in string
 
         :type:
 
-                :class:`~int`
-        """  # noqa: E501
-        return self.__asn
-
-    @asn.setter
-    def asn(self, asn):
-
-        self.__asn = asn
-
-    @property
-    def ip_address(self):
-        """
-        
-
-        :type:
-            :class:`~ntnx_networking_py_client.models.common.v1.config.IPAddress`
+                :class:`~str`
         """  # noqa: E501
-        return self.__ip_address
+        return self.__private_ip
 
-    @ip_address.setter
-    def ip_address(self, ip_address):
+    @private_ip.setter
+    def private_ip(self, private_ip):
 
-        self.__ip_address = ip_address
+        self.__private_ip = private_ip
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -169,37 +147,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(RemoteBgpGateway, dict):
+        if issubclass(VmNic, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -211,15 +194,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, RemoteBgpGateway):
+        if not isinstance(other, VmNic):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/RemoteBgpService.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/RemoteBgpService.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.IPAddress import IPAddress  # noqa: F401,E501
 
 class RemoteBgpService(object):
 
     """BGP service hosted on this remote gateway.
 
     :param address: (:attr:`address`) 
@@ -65,33 +66,33 @@
         self.__asn = asn
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.RemoteBgpService'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.RemoteBgpService'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -175,28 +176,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/RemoteNetworkServices.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/RoutingPolicyRule.py`

 * *Files 25% similar despite different names*

```diff
@@ -3,163 +3,166 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_networking_py_client.models.networking.v4.config.RemoteBgpService import RemoteBgpService  # noqa: F401,E501
-from ntnx_networking_py_client.models.networking.v4.config.RemoteVpnService import RemoteVpnService  # noqa: F401,E501
-from ntnx_networking_py_client.models.networking.v4.config.RemoteVtepService import RemoteVtepService  # noqa: F401,E501
-
-class RemoteNetworkServices(object):
-
-    """Services of this remote gateway
-
-    :param remote_vpn_service: (:attr:`remote_vpn_service`) 
-    :type remote_vpn_service: 
-    :param remote_vtep_service: (:attr:`remote_vtep_service`) 
-    :type remote_vtep_service: 
-    :param remote_bgp_service: (:attr:`remote_bgp_service`) 
-    :type remote_bgp_service: 
+from pathlib import Path
+from ntnx_networking_py_client.models.networking.v4.config.RoutingPolicyAction import RoutingPolicyAction  # noqa: F401,E501
+from ntnx_networking_py_client.models.networking.v4.config.RoutingPolicyMatchCondition import RoutingPolicyMatchCondition  # noqa: F401,E501
+
+class RoutingPolicyRule(object):
+
+    """Policy indicating the match rule and the action.
+
+    :param policy_match: (:attr:`policy_match`) 
+    :type policy_match: required
+    :param policy_action: (:attr:`policy_action`) 
+    :type policy_action: required
+    :param is_bidirectional: (:attr:`is_bidirectional`) If True, policies in the reverse direction will be installed with the same action but source and destination will be swapped. (**Default** False)
+    :type is_bidirectional: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'remote_vpn_service': 'networking.v4.config.RemoteVpnService',
-        'remote_vtep_service': 'networking.v4.config.RemoteVtepService',
-        'remote_bgp_service': 'networking.v4.config.RemoteBgpService',
+        'policy_match': 'networking.v4.config.RoutingPolicyMatchCondition',
+        'policy_action': 'networking.v4.config.RoutingPolicyAction',
+        'is_bidirectional': 'bool',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'remote_vpn_service': 'remoteVpnService',
-        'remote_vtep_service': 'remoteVtepService',
-        'remote_bgp_service': 'remoteBgpService',
+        'policy_match': 'policyMatch',
+        'policy_action': 'policyAction',
+        'is_bidirectional': 'isBidirectional',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, remote_vpn_service=None, remote_vtep_service=None, remote_bgp_service=None, *args, **kwargs):  # noqa: E501
-        self.__remote_vpn_service = None
-        self.__remote_vtep_service = None
-        self.__remote_bgp_service = None
+    def __init__(self, policy_match=None, policy_action=None, is_bidirectional=False, *args, **kwargs):  # noqa: E501
+        self.__policy_match = None
+        self.__policy_action = None
+        self.__is_bidirectional = None
         self.discriminator = None
-        if remote_vpn_service is not None:
-            self.__remote_vpn_service = remote_vpn_service
-        if remote_vtep_service is not None:
-            self.__remote_vtep_service = remote_vtep_service
-        if remote_bgp_service is not None:
-            self.__remote_bgp_service = remote_bgp_service
+        self.__policy_match = policy_match
+        self.__policy_action = policy_action
+        if is_bidirectional is not None:
+            self.__is_bidirectional = is_bidirectional
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.RemoteNetworkServices'
+        return 'networking.v4.config.RoutingPolicyRule'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.RemoteNetworkServices'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def remote_vpn_service(self):
+    def policy_match(self):
         """
         
 
         :type:
-            :class:`~ntnx_networking_py_client.models.networking.v4.config.RemoteVpnService`
+            :class:`~ntnx_networking_py_client.models.networking.v4.config.RoutingPolicyMatchCondition`
         """  # noqa: E501
-        return self.__remote_vpn_service
+        return self.__policy_match
 
-    @remote_vpn_service.setter
-    def remote_vpn_service(self, remote_vpn_service):
+    @policy_match.setter
+    def policy_match(self, policy_match):
+        if policy_match is None:
+            raise ValueError("Invalid value for `policy_match`, must not be `None`")  # noqa: E501
 
-        self.__remote_vpn_service = remote_vpn_service
+        self.__policy_match = policy_match
 
     @property
-    def remote_vtep_service(self):
+    def policy_action(self):
         """
         
 
         :type:
-            :class:`~ntnx_networking_py_client.models.networking.v4.config.RemoteVtepService`
+            :class:`~ntnx_networking_py_client.models.networking.v4.config.RoutingPolicyAction`
         """  # noqa: E501
-        return self.__remote_vtep_service
+        return self.__policy_action
 
-    @remote_vtep_service.setter
-    def remote_vtep_service(self, remote_vtep_service):
+    @policy_action.setter
+    def policy_action(self, policy_action):
+        if policy_action is None:
+            raise ValueError("Invalid value for `policy_action`, must not be `None`")  # noqa: E501
 
-        self.__remote_vtep_service = remote_vtep_service
+        self.__policy_action = policy_action
 
     @property
-    def remote_bgp_service(self):
+    def is_bidirectional(self):
         """
-        
+        If True, policies in the reverse direction will be installed with the same action but source and destination will be swapped.
 
         :type:
-            :class:`~ntnx_networking_py_client.models.networking.v4.config.RemoteBgpService`
+
+                :class:`~bool`
         """  # noqa: E501
-        return self.__remote_bgp_service
+        return self.__is_bidirectional
 
-    @remote_bgp_service.setter
-    def remote_bgp_service(self, remote_bgp_service):
+    @is_bidirectional.setter
+    def is_bidirectional(self, is_bidirectional):
 
-        self.__remote_bgp_service = remote_bgp_service
+        self.__is_bidirectional = is_bidirectional
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -192,37 +195,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(RemoteNetworkServices, dict):
+        if issubclass(RoutingPolicyRule, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -234,15 +242,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, RemoteNetworkServices):
+        if not isinstance(other, RoutingPolicyRule):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/RemoteVpnService.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/RemoteVpnService.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.IPAddress import IPAddress  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.BgpConfig import BgpConfig  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.InternalRoutingConfig import InternalRoutingConfig  # noqa: F401,E501
 
 class RemoteVpnService(object):
 
     """VPN service hosted on this remote gateway
@@ -83,33 +84,33 @@
             self.__should_install_xi_route = should_install_xi_route
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.RemoteVpnService'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.RemoteVpnService'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -215,28 +216,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/RemoteVtepService.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ListClusterCapabilitiesApiResponse.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,144 +3,143 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_networking_py_client.models.networking.v4.config.Vtep import Vtep  # noqa: F401,E501
-
-class RemoteVtepService(object):
-
-    """VTEP service hosted on this remote gateway
-
-    :param vxlan_port: (:attr:`vxlan_port`) VXLAN port (**Default** 4789)
-    :type vxlan_port: 
-    :param vteps: (:attr:`vteps`) Remote VXLAN Tunnel Endpoints configuration
-    :type vteps: 
+from pathlib import Path
+import ntnx_networking_py_client.models
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListClusterCapabilitiesApiResponsedata import ListClusterCapabilitiesApiResponsedata  # noqa: F401,E501
+from ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class ListClusterCapabilitiesApiResponse(object):
+
+    """REST response for all response codes in API path /networking/v4.0.b1/config/capabilities Get operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'vxlan_port': 'int',
-        'vteps': 'list[networking.v4.config.Vtep]',
+        'metadata': 'common.v1.response.ApiResponseMetadata',
+        'data': 'OneOfnetworking.v4.config.ListClusterCapabilitiesApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'vxlan_port': 'vxlanPort',
-        'vteps': 'vteps',
+        'metadata': 'metadata',
+        'data': 'data',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, vxlan_port=4789, vteps=None, *args, **kwargs):  # noqa: E501
-        self.__vxlan_port = None
-        self.__vteps = None
+    def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
+        self.__metadata = None
+        self.__data = None
         self.discriminator = None
-        if vxlan_port is not None:
-            self.__vxlan_port = vxlan_port
-        if vteps is not None:
-            self.__vteps = vteps
+        if metadata is not None:
+            self.__metadata = metadata
+        if data is not None:
+            self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.RemoteVtepService'
+        return 'networking.v4.config.ListClusterCapabilitiesApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.RemoteVtepService'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def vxlan_port(self):
+    def metadata(self):
         """
-        VXLAN port
+        
 
         :type:
-
-                :class:`~int`
+            :class:`~ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata`
         """  # noqa: E501
-        return self.__vxlan_port
+        return self.__metadata
 
-    @vxlan_port.setter
-    def vxlan_port(self, vxlan_port):
-        if vxlan_port is not None and vxlan_port > 49151:  # noqa: E501
-            raise ValueError("Invalid value for `vxlan_port`, must be a value less than or equal to `49151`")  # noqa: E501
-        if vxlan_port is not None and vxlan_port < 1:  # noqa: E501
-            raise ValueError("Invalid value for `vxlan_port`, must be a value greater than or equal to `1`")  # noqa: E501
+    @metadata.setter
+    def metadata(self, metadata):
 
-        self.__vxlan_port = vxlan_port
+        self.__metadata = metadata
 
     @property
-    def vteps(self):
+    def data(self):
         """
-        Remote VXLAN Tunnel Endpoints configuration
+        
 
         :type:
-             list[ :class:`~ntnx_networking_py_client.models.networking.v4.config.Vtep` ]
-        """  # noqa: E501
-        return self.__vteps
+                :class:`~ntnx_networking_py_client.models.networking.v4.config.ClusterCapability` | 
+                :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse`
+                    """  # noqa: E501
+        return self.__data
 
-    @vteps.setter
-    def vteps(self, vteps):
+    @data.setter
+    def data(self, data):
 
-        self.__vteps = vteps
+        self.__data = data
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -173,37 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
+            if attr_type.startswith('OneOf'):
+                type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(RemoteVtepService, dict):
+        if issubclass(ListClusterCapabilitiesApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, RemoteVtepService):
+        if not isinstance(other, ListClusterCapabilitiesApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/RemoteVtepStretchStatus.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/RemoteVtepStretchStatus.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.IPAddress import IPAddress  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.StretchStatus import StretchStatus  # noqa: F401,E501
 
 class RemoteVtepStretchStatus(object):
 
     """Status of each VTEP. Applicable only when connectionType is VXLAN.
 
@@ -75,33 +76,33 @@
             self.__learned_mac_addresses = learned_mac_addresses
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.RemoteVtepStretchStatus'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.RemoteVtepStretchStatus'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -191,28 +192,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/RerouteFallbackAction.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/UnreserveType.py`

 * *Files 20% similar despite different names*

```diff
@@ -3,75 +3,74 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class RerouteFallbackAction(object):
+class UnreserveType(object):
 
-    """Type of fallback action in reroute case when service VM is down.
+    """Type of IP Address unreservation.
 
 
     Allowed enum values:
 
         - _UNKNOWN
         - _REDACTED
-        - ALLOW: When service vm is down, reroute fallback action is "allowed".
-        - DROP: When service vm is down, reroute fallback action is "drop".
-        - PASSTHROUGH: When service vm is down, reroute fallback action is "passthrough". Next higher priority matching rule is applied.
-        - NO_ACTION: When service vm is down and reroute fallback action is "NO_ACTION". No action is taken and traffic is black-holed.
+        - IP_ADDRESS_LIST: Unreserve IP address based on the given IP address list.
+        - IP_ADDRESS_RANGE: Unreserve IP address based on the given IP range.
+        - CONTEXT: Unreserve IP address based on the given context.
     """
     _UNKNOWN = "$UNKNOWN"
     _REDACTED = "$REDACTED"
-    ALLOW = "ALLOW"
-    DROP = "DROP"
-    PASSTHROUGH = "PASSTHROUGH"
-    NO_ACTION = "NO_ACTION"
+    IP_ADDRESS_LIST = "IP_ADDRESS_LIST"
+    IP_ADDRESS_RANGE = "IP_ADDRESS_RANGE"
+    CONTEXT = "CONTEXT"
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.RerouteFallbackAction'
+        return 'networking.v4.config.UnreserveType'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.RerouteFallbackAction'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -86,36 +85,41 @@
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(RerouteFallbackAction, dict):
+        if issubclass(UnreserveType, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -127,15 +131,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, RerouteFallbackAction):
+        if not isinstance(other, UnreserveType):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/RerouteParam.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/common/v1/config/Flag.py`

 * *Files 12% similar despite different names*

```diff
@@ -3,141 +3,141 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_networking_py_client.models.common.v1.config.IPAddress import IPAddress  # noqa: F401,E501
-from ntnx_networking_py_client.models.networking.v4.config.RerouteFallbackAction import RerouteFallbackAction  # noqa: F401,E501
+from pathlib import Path
 
-class RerouteParam(object):
+class Flag(object):
 
-    """Parameters for the reroute action which includes the reroute service IP and the fallback action when the service IP is down.
+    """Many entities in the Nutanix APIs carry flags.  This object captures all the flags associated with that entity through this object.  The field that hosts this type of object must have an attribute called x-bounded-map-keys that tells which flags are actually present for that entity. 
 
-    :param service_ip: (:attr:`service_ip`) 
-    :type service_ip: required
-    :param reroute_fallback_action: (:attr:`reroute_fallback_action`) 
-    :type reroute_fallback_action: 
+    :param name: (:attr:`name`) 
+    :type name: 
+    :param value: (:attr:`value`) 
+    :type value: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'service_ip': 'common.v1.config.IPAddress',
-        'reroute_fallback_action': 'networking.v4.config.RerouteFallbackAction',
+        'name': 'str',
+        'value': 'bool',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'service_ip': 'serviceIp',
-        'reroute_fallback_action': 'rerouteFallbackAction',
+        'name': 'name',
+        'value': 'value',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, service_ip=None, reroute_fallback_action=None, *args, **kwargs):  # noqa: E501
-        self.__service_ip = None
-        self.__reroute_fallback_action = None
+    def __init__(self, name=None, value=False, *args, **kwargs):  # noqa: E501
+        self.__name = None
+        self.__value = None
         self.discriminator = None
-        self.__service_ip = service_ip
-        if reroute_fallback_action is not None:
-            self.__reroute_fallback_action = reroute_fallback_action
+        if name is not None:
+            self.__name = name
+        if value is not None:
+            self.__value = value
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.RerouteParam'
+        return 'common.v1.config.Flag'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.RerouteParam'
+    def _initialize_object_version(self):
+        return 'v1.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def service_ip(self):
+    def name(self):
         """
         
 
         :type:
-            :class:`~ntnx_networking_py_client.models.common.v1.config.IPAddress`
+
+                :class:`~str`
         """  # noqa: E501
-        return self.__service_ip
+        return self.__name
 
-    @service_ip.setter
-    def service_ip(self, service_ip):
-        if service_ip is None:
-            raise ValueError("Invalid value for `service_ip`, must not be `None`")  # noqa: E501
+    @name.setter
+    def name(self, name):
 
-        self.__service_ip = service_ip
+        self.__name = name
 
     @property
-    def reroute_fallback_action(self):
+    def value(self):
         """
         
 
         :type:
-            :class:`~ntnx_networking_py_client.models.networking.v4.config.RerouteFallbackAction`
+
+                :class:`~bool`
         """  # noqa: E501
-        return self.__reroute_fallback_action
+        return self.__value
 
-    @reroute_fallback_action.setter
-    def reroute_fallback_action(self, reroute_fallback_action):
+    @value.setter
+    def value(self, value):
 
-        self.__reroute_fallback_action = reroute_fallback_action
+        self.__value = value
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -170,37 +170,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(RerouteParam, dict):
+        if issubclass(Flag, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -212,15 +217,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, RerouteParam):
+        if not isinstance(other, Flag):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/ReserveType.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ReserveType.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
 class ReserveType(object):
 
     """Type of IP Address reservation.
 
 
     Allowed enum values:
@@ -43,33 +44,33 @@
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.ReserveType'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.ReserveType'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -84,27 +85,32 @@
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/ReservedAddress.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ReservedAddress.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
 class ReservedAddress(object):
 
     """Information pertaining to a reserved IP address on a subnet.
 
     :param client_context: (:attr:`client_context`) Optional context a client wishes to associate with a reservation of IP addresses.
     :type client_context: 
@@ -59,33 +60,33 @@
             self.__client_context = client_context
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.ReservedAddress'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.ReservedAddress'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -146,28 +147,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/Route.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/Route.py`

 * *Files 3% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.IPAddress import IPAddress  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.IPSubnet import IPSubnet  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.NexthopType import NexthopType  # noqa: F401,E501
 
 class Route(object):
 
     """Route.
@@ -109,33 +110,33 @@
             self.__source = source
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.Route'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.Route'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -311,28 +312,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/RouteTable.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/RouteTable.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.Metadata import Metadata  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.NetworkingBaseModel import NetworkingBaseModel  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.Route import Route  # noqa: F401,E501
 
 class RouteTable(NetworkingBaseModel):
 
     """Route table
@@ -97,16 +98,16 @@
             self.__dynamic_routes = dynamic_routes
         if local_routes is not None:
             self.__local_routes = local_routes
 
     def _initialize_object_type(self):
         return 'networking.v4.config.RouteTable'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.RouteTable'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     @property
     def vpc_reference(self):
         """
         VPC
 
@@ -190,28 +191,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/RouteTableApiResponse.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/GetRouteTableApiResponse.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,30 +3,31 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_networking_py_client.models
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.RouteTableApiResponsedata import RouteTableApiResponsedata  # noqa: F401,E501
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.GetRouteTableApiResponsedata import GetRouteTableApiResponsedata  # noqa: F401,E501
 from ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class RouteTableApiResponse(object):
+class GetRouteTableApiResponse(object):
 
     """REST response for all response codes in API path /networking/v4.0.b1/config/route-tables/{extId} Get operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfnetworking.v4.config.RouteTableApiResponsedata',
+        'data': 'OneOfnetworking.v4.config.GetRouteTableApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.RouteTableApiResponse'
+        return 'networking.v4.config.GetRouteTableApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.RouteTableApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -171,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(RouteTableApiResponse, dict):
+        if issubclass(GetRouteTableApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, RouteTableApiResponse):
+        if not isinstance(other, GetRouteTableApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/RouteTableListApiResponse.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ListVpcVirtualSwitchMappingsApiResponse.py`

 * *Files 12% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_networking_py_client.models
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.RouteTableListApiResponsedata import RouteTableListApiResponsedata  # noqa: F401,E501
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListVpcVirtualSwitchMappingsApiResponsedata import ListVpcVirtualSwitchMappingsApiResponsedata  # noqa: F401,E501
 from ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class RouteTableListApiResponse(object):
+class ListVpcVirtualSwitchMappingsApiResponse(object):
 
-    """REST response for all response codes in API path /networking/v4.0.b1/config/route-tables Get operation
+    """REST response for all response codes in API path /networking/v4.0.b1/config/vpc-virtual-switch-mappings Get operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfnetworking.v4.config.RouteTableListApiResponsedata',
+        'data': 'OneOfnetworking.v4.config.ListVpcVirtualSwitchMappingsApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.RouteTableListApiResponse'
+        return 'networking.v4.config.ListVpcVirtualSwitchMappingsApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.RouteTableListApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -122,15 +123,15 @@
 
     @property
     def data(self):
         """
         
 
         :type:
-                :class:`~ntnx_networking_py_client.models.networking.v4.config.RouteTable` | 
+                :class:`~ntnx_networking_py_client.models.networking.v4.config.VpcVirtualSwitchMapping` | 
                 :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse`
                     """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
@@ -171,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(RouteTableListApiResponse, dict):
+        if issubclass(ListVpcVirtualSwitchMappingsApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, RouteTableListApiResponse):
+        if not isinstance(other, ListVpcVirtualSwitchMappingsApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/RoutingPolicy.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/RoutingPolicy.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,28 +3,30 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.Metadata import Metadata  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.NetworkingBaseModel import NetworkingBaseModel  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.RoutingPolicyRule import RoutingPolicyRule  # noqa: F401,E501
+from ntnx_networking_py_client.models.networking.v4.config.VpcName import VpcName  # noqa: F401,E501
 
 class RoutingPolicy(NetworkingBaseModel):
 
     """Schema to configure a routing policy.
 
     :param name: (:attr:`name`) Name of the routing policy.
     :type name: required
@@ -32,14 +34,16 @@
     :type description: 
     :param priority: (:attr:`priority`) Priority of the routing policy.
     :type priority: required
     :param policies: (:attr:`policies`) 
     :type policies: required
     :param vpc_ext_id: (:attr:`vpc_ext_id`) ExtId of the VPC extId to which the routing policy belongs.
     :type vpc_ext_id: required
+    :param vpc: (:attr:`vpc`) 
+    :type vpc: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
@@ -49,14 +53,15 @@
     """  # noqa: E501
     swagger_types = {
         'name': 'str',
         'description': 'str',
         'priority': 'int',
         'policies': 'list[networking.v4.config.RoutingPolicyRule]',
         'vpc_ext_id': 'str',
+        'vpc': 'networking.v4.config.VpcName',
         'metadata': 'common.v1.config.Metadata',
         'ext_id': 'str',
         'links': 'list[common.v1.response.ApiLink]',
         'tenant_id': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
@@ -64,45 +69,49 @@
 
     attribute_map = {
         'name': 'name',
         'description': 'description',
         'priority': 'priority',
         'policies': 'policies',
         'vpc_ext_id': 'vpcExtId',
+        'vpc': 'vpc',
         'metadata': 'metadata',
         'ext_id': 'extId',
         'links': 'links',
         'tenant_id': 'tenantId',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, name=None, description=None, priority=None, policies=None, vpc_ext_id=None, metadata=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
+    def __init__(self, name=None, description=None, priority=None, policies=None, vpc_ext_id=None, vpc=None, metadata=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
         NetworkingBaseModel.__init__(self, metadata, ext_id, links, tenant_id, *args, **kwargs)
         self.__name = None
         self.__description = None
         self.__priority = None
         self.__policies = None
         self.__vpc_ext_id = None
+        self.__vpc = None
         self.discriminator = None
         self.__name = name
         if description is not None:
             self.__description = description
         self.__priority = priority
         self.__policies = policies
         self.__vpc_ext_id = vpc_ext_id
+        if vpc is not None:
+            self.__vpc = vpc
 
     def _initialize_object_type(self):
         return 'networking.v4.config.RoutingPolicy'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.RoutingPolicy'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     @property
     def name(self):
         """
         Name of the routing policy.
 
@@ -194,36 +203,56 @@
         if vpc_ext_id is None:
             raise ValueError("Invalid value for `vpc_ext_id`, must not be `None`")  # noqa: E501
         if vpc_ext_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', vpc_ext_id):  # noqa: E501
             raise ValueError(r"Invalid value for `vpc_ext_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
 
         self.__vpc_ext_id = vpc_ext_id
 
+    @property
+    def vpc(self):
+        """
+        
+
+        :type:
+            :class:`~ntnx_networking_py_client.models.networking.v4.config.VpcName`
+        """  # noqa: E501
+        return self.__vpc
+
+    @vpc.setter
+    def vpc(self, vpc):
+
+        self.__vpc = vpc
+
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/RoutingPolicyAction.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ListVpcsApiResponse.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,141 +3,144 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_networking_py_client.models.networking.v4.config.RerouteParam import RerouteParam  # noqa: F401,E501
-from ntnx_networking_py_client.models.networking.v4.config.RoutingPolicyActionType import RoutingPolicyActionType  # noqa: F401,E501
-
-class RoutingPolicyAction(object):
-
-    """The action to be taken on the traffic matching the routing policy.
-
-    :param action_type: (:attr:`action_type`) 
-    :type action_type: required
-    :param reroute_params: (:attr:`reroute_params`) 
-    :type reroute_params: 
+from pathlib import Path
+import ntnx_networking_py_client.models
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListVpcsApiResponsedata import ListVpcsApiResponsedata  # noqa: F401,E501
+from ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
+
+class ListVpcsApiResponse(object):
+
+    """REST response for all response codes in API path /networking/v4.0.b1/config/vpcs Get operation
+
+    :param metadata: (:attr:`metadata`) 
+    :type metadata: 
+    :param data: (:attr:`data`) 
+    :type data: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'action_type': 'networking.v4.config.RoutingPolicyActionType',
-        'reroute_params': 'list[networking.v4.config.RerouteParam]',
+        'metadata': 'common.v1.response.ApiResponseMetadata',
+        'data': 'OneOfnetworking.v4.config.ListVpcsApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'action_type': 'actionType',
-        'reroute_params': 'rerouteParams',
+        'metadata': 'metadata',
+        'data': 'data',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, action_type=None, reroute_params=None, *args, **kwargs):  # noqa: E501
-        self.__action_type = None
-        self.__reroute_params = None
+    def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
+        self.__metadata = None
+        self.__data = None
         self.discriminator = None
-        self.__action_type = action_type
-        if reroute_params is not None:
-            self.__reroute_params = reroute_params
+        if metadata is not None:
+            self.__metadata = metadata
+        if data is not None:
+            self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.RoutingPolicyAction'
+        return 'networking.v4.config.ListVpcsApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.RoutingPolicyAction'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def action_type(self):
+    def metadata(self):
         """
         
 
         :type:
-            :class:`~ntnx_networking_py_client.models.networking.v4.config.RoutingPolicyActionType`
+            :class:`~ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata`
         """  # noqa: E501
-        return self.__action_type
+        return self.__metadata
 
-    @action_type.setter
-    def action_type(self, action_type):
-        if action_type is None:
-            raise ValueError("Invalid value for `action_type`, must not be `None`")  # noqa: E501
+    @metadata.setter
+    def metadata(self, metadata):
 
-        self.__action_type = action_type
+        self.__metadata = metadata
 
     @property
-    def reroute_params(self):
+    def data(self):
         """
         
 
         :type:
-             list[ :class:`~ntnx_networking_py_client.models.networking.v4.config.RerouteParam` ]
-        """  # noqa: E501
-        return self.__reroute_params
+                :class:`~ntnx_networking_py_client.models.networking.v4.config.Vpc` | 
+                :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse` | 
+                :class:`~ntnx_networking_py_client.models.networking.v4.config.VpcProjection`
+                    """  # noqa: E501
+        return self.__data
 
-    @reroute_params.setter
-    def reroute_params(self, reroute_params):
+    @data.setter
+    def data(self, data):
 
-        self.__reroute_params = reroute_params
+        self.__data = data
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -170,37 +173,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
+            if attr_type.startswith('OneOf'):
+                type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(RoutingPolicyAction, dict):
+        if issubclass(ListVpcsApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -212,15 +222,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, RoutingPolicyAction):
+        if not isinstance(other, ListVpcsApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/RoutingPolicyActionType.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/TrafficMirrorPortNicType.py`

 * *Files 9% similar despite different names*

```diff
@@ -3,73 +3,72 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class RoutingPolicyActionType(object):
+class TrafficMirrorPortNicType(object):
 
-    """Routing policy action type.
+    """Port NIC type for the Traffic mirror session. Allowed values are HOST_NIC and VIRTUAL_NIC.
 
 
     Allowed enum values:
 
         - _UNKNOWN
         - _REDACTED
-        - PERMIT: Routing policy action type is permit/allow
-        - DENY: Routing policy action type is deny/drop
-        - REROUTE: Routing policy action type is reroute and need to specify service IP to which traffic is rerouted
+        - HOST_NIC: Traffic mirror port is a host NIC.
+        - VIRTUAL_NIC: Traffic mirror port is a virtual NIC.
     """
     _UNKNOWN = "$UNKNOWN"
     _REDACTED = "$REDACTED"
-    PERMIT = "PERMIT"
-    DENY = "DENY"
-    REROUTE = "REROUTE"
+    HOST_NIC = "HOST_NIC"
+    VIRTUAL_NIC = "VIRTUAL_NIC"
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.RoutingPolicyActionType'
+        return 'networking.v4.config.TrafficMirrorPortNicType'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.RoutingPolicyActionType'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -84,36 +83,41 @@
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(RoutingPolicyActionType, dict):
+        if issubclass(TrafficMirrorPortNicType, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -125,15 +129,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, RoutingPolicyActionType):
+        if not isinstance(other, TrafficMirrorPortNicType):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/RoutingPolicyApiResponse.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ListTrafficMirrorsApiResponse.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_networking_py_client.models
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.RoutingPolicyApiResponsedata import RoutingPolicyApiResponsedata  # noqa: F401,E501
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListTrafficMirrorsApiResponsedata import ListTrafficMirrorsApiResponsedata  # noqa: F401,E501
 from ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class RoutingPolicyApiResponse(object):
+class ListTrafficMirrorsApiResponse(object):
 
-    """REST response for all response codes in API path /networking/v4.0.b1/config/routing-policies/{extId} Get operation
+    """REST response for all response codes in API path /networking/v4.0.b1/config/traffic-mirrors Get operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfnetworking.v4.config.RoutingPolicyApiResponsedata',
+        'data': 'OneOfnetworking.v4.config.ListTrafficMirrorsApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.RoutingPolicyApiResponse'
+        return 'networking.v4.config.ListTrafficMirrorsApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.RoutingPolicyApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -122,15 +123,15 @@
 
     @property
     def data(self):
         """
         
 
         :type:
-                :class:`~ntnx_networking_py_client.models.networking.v4.config.RoutingPolicy` | 
+                :class:`~ntnx_networking_py_client.models.networking.v4.config.TrafficMirror` | 
                 :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse`
                     """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
@@ -171,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(RoutingPolicyApiResponse, dict):
+        if issubclass(ListTrafficMirrorsApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, RoutingPolicyApiResponse):
+        if not isinstance(other, ListTrafficMirrorsApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/RoutingPolicyListApiResponse.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/GetTrafficMirrorApiResponse.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_networking_py_client.models
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.RoutingPolicyListApiResponsedata import RoutingPolicyListApiResponsedata  # noqa: F401,E501
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.GetTrafficMirrorApiResponsedata import GetTrafficMirrorApiResponsedata  # noqa: F401,E501
 from ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class RoutingPolicyListApiResponse(object):
+class GetTrafficMirrorApiResponse(object):
 
-    """REST response for all response codes in API path /networking/v4.0.b1/config/routing-policies Get operation
+    """REST response for all response codes in API path /networking/v4.0.b1/config/traffic-mirrors/{extId} Get operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfnetworking.v4.config.RoutingPolicyListApiResponsedata',
+        'data': 'OneOfnetworking.v4.config.GetTrafficMirrorApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.RoutingPolicyListApiResponse'
+        return 'networking.v4.config.GetTrafficMirrorApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.RoutingPolicyListApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -122,15 +123,15 @@
 
     @property
     def data(self):
         """
         
 
         :type:
-                :class:`~ntnx_networking_py_client.models.networking.v4.config.RoutingPolicy` | 
+                :class:`~ntnx_networking_py_client.models.networking.v4.config.TrafficMirror` | 
                 :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse`
                     """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
@@ -171,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(RoutingPolicyListApiResponse, dict):
+        if issubclass(GetTrafficMirrorApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, RoutingPolicyListApiResponse):
+        if not isinstance(other, GetTrafficMirrorApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/RoutingPolicyMatchCondition.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/RoutingPolicyMatchCondition.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_networking_py_client.models
 from ntnx_networking_py_client.models.OneOfnetworking.v4.config.RoutingPolicyMatchConditionprotocol_parameters import RoutingPolicyMatchConditionprotocol_parameters  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.AddressTypeObject import AddressTypeObject  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.ProtocolType import ProtocolType  # noqa: F401,E501
 
 class RoutingPolicyMatchCondition(object):
 
@@ -81,33 +82,33 @@
             self.__protocol_parameters = protocol_parameters
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.RoutingPolicyMatchCondition'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.RoutingPolicyMatchCondition'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -220,30 +221,35 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/RoutingPolicyRule.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/RoutingPolicyAction.py`

 * *Files 15% similar despite different names*

```diff
@@ -3,165 +3,165 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_networking_py_client.models.networking.v4.config.RoutingPolicyAction import RoutingPolicyAction  # noqa: F401,E501
-from ntnx_networking_py_client.models.networking.v4.config.RoutingPolicyMatchCondition import RoutingPolicyMatchCondition  # noqa: F401,E501
-
-class RoutingPolicyRule(object):
-
-    """Policy indicating the match rule and the action.
-
-    :param policy_match: (:attr:`policy_match`) 
-    :type policy_match: required
-    :param policy_action: (:attr:`policy_action`) 
-    :type policy_action: required
-    :param is_bidirectional: (:attr:`is_bidirectional`) If True, policies in the reverse direction will be installed with the same action but source and destination will be swapped. (**Default** False)
-    :type is_bidirectional: 
+from pathlib import Path
+from ntnx_networking_py_client.models.common.v1.config.IPAddress import IPAddress  # noqa: F401,E501
+from ntnx_networking_py_client.models.networking.v4.config.RerouteParam import RerouteParam  # noqa: F401,E501
+from ntnx_networking_py_client.models.networking.v4.config.RoutingPolicyActionType import RoutingPolicyActionType  # noqa: F401,E501
+
+class RoutingPolicyAction(object):
+
+    """The action to be taken on the traffic matching the routing policy.
+
+    :param action_type: (:attr:`action_type`) 
+    :type action_type: required
+    :param reroute_params: (:attr:`reroute_params`) 
+    :type reroute_params: 
+    :param nexthop_ip_address: (:attr:`nexthop_ip_address`) 
+    :type nexthop_ip_address: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'policy_match': 'networking.v4.config.RoutingPolicyMatchCondition',
-        'policy_action': 'networking.v4.config.RoutingPolicyAction',
-        'is_bidirectional': 'bool',
+        'action_type': 'networking.v4.config.RoutingPolicyActionType',
+        'reroute_params': 'list[networking.v4.config.RerouteParam]',
+        'nexthop_ip_address': 'common.v1.config.IPAddress',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'policy_match': 'policyMatch',
-        'policy_action': 'policyAction',
-        'is_bidirectional': 'isBidirectional',
+        'action_type': 'actionType',
+        'reroute_params': 'rerouteParams',
+        'nexthop_ip_address': 'nexthopIpAddress',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, policy_match=None, policy_action=None, is_bidirectional=False, *args, **kwargs):  # noqa: E501
-        self.__policy_match = None
-        self.__policy_action = None
-        self.__is_bidirectional = None
+    def __init__(self, action_type=None, reroute_params=None, nexthop_ip_address=None, *args, **kwargs):  # noqa: E501
+        self.__action_type = None
+        self.__reroute_params = None
+        self.__nexthop_ip_address = None
         self.discriminator = None
-        self.__policy_match = policy_match
-        self.__policy_action = policy_action
-        if is_bidirectional is not None:
-            self.__is_bidirectional = is_bidirectional
+        self.__action_type = action_type
+        if reroute_params is not None:
+            self.__reroute_params = reroute_params
+        if nexthop_ip_address is not None:
+            self.__nexthop_ip_address = nexthop_ip_address
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.RoutingPolicyRule'
+        return 'networking.v4.config.RoutingPolicyAction'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.RoutingPolicyRule'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def policy_match(self):
+    def action_type(self):
         """
         
 
         :type:
-            :class:`~ntnx_networking_py_client.models.networking.v4.config.RoutingPolicyMatchCondition`
+            :class:`~ntnx_networking_py_client.models.networking.v4.config.RoutingPolicyActionType`
         """  # noqa: E501
-        return self.__policy_match
+        return self.__action_type
 
-    @policy_match.setter
-    def policy_match(self, policy_match):
-        if policy_match is None:
-            raise ValueError("Invalid value for `policy_match`, must not be `None`")  # noqa: E501
+    @action_type.setter
+    def action_type(self, action_type):
+        if action_type is None:
+            raise ValueError("Invalid value for `action_type`, must not be `None`")  # noqa: E501
 
-        self.__policy_match = policy_match
+        self.__action_type = action_type
 
     @property
-    def policy_action(self):
+    def reroute_params(self):
         """
         
 
         :type:
-            :class:`~ntnx_networking_py_client.models.networking.v4.config.RoutingPolicyAction`
+             list[ :class:`~ntnx_networking_py_client.models.networking.v4.config.RerouteParam` ]
         """  # noqa: E501
-        return self.__policy_action
+        return self.__reroute_params
 
-    @policy_action.setter
-    def policy_action(self, policy_action):
-        if policy_action is None:
-            raise ValueError("Invalid value for `policy_action`, must not be `None`")  # noqa: E501
+    @reroute_params.setter
+    def reroute_params(self, reroute_params):
 
-        self.__policy_action = policy_action
+        self.__reroute_params = reroute_params
 
     @property
-    def is_bidirectional(self):
+    def nexthop_ip_address(self):
         """
-        If True, policies in the reverse direction will be installed with the same action but source and destination will be swapped.
+        
 
         :type:
-
-                :class:`~bool`
+            :class:`~ntnx_networking_py_client.models.common.v1.config.IPAddress`
         """  # noqa: E501
-        return self.__is_bidirectional
+        return self.__nexthop_ip_address
 
-    @is_bidirectional.setter
-    def is_bidirectional(self, is_bidirectional):
+    @nexthop_ip_address.setter
+    def nexthop_ip_address(self, nexthop_ip_address):
 
-        self.__is_bidirectional = is_bidirectional
+        self.__nexthop_ip_address = nexthop_ip_address
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -194,37 +194,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(RoutingPolicyRule, dict):
+        if issubclass(RoutingPolicyAction, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -236,15 +241,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, RoutingPolicyRule):
+        if not isinstance(other, RoutingPolicyAction):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/ScopeType.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ScopeType.py`

 * *Files 9% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
 class ScopeType(object):
 
     """Scope type:the permissible values are PC or PE.
 
 
     Allowed enum values:
@@ -41,33 +42,33 @@
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.ScopeType'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.ScopeType'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -82,27 +83,32 @@
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/SiteParams.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/SiteParams.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.IPAddress import IPAddress  # noqa: F401,E501
 
 class SiteParams(object):
 
     """Site-specific stretch configuration parameters.
 
     :param pc_cluster_reference: (:attr:`pc_cluster_reference`) Prism Central cluster reference.
@@ -95,33 +96,33 @@
             self.__default_gateway_ip_address = default_gateway_ip_address
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.SiteParams'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.SiteParams'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -265,28 +266,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/State.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/NexthopType.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,71 +3,78 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class State(object):
+class NexthopType(object):
 
-    """
+    """Next hop type.
 
 
     Allowed enum values:
 
         - _UNKNOWN
         - _REDACTED
-        - UP: Component is up and running.
-        - DOWN: Component is not functional and down.
+        - IP_ADDRESS: Next hop is an IP address.
+        - DIRECT_CONNECT_VIF: Next hop is a direct connect VIF.
+        - INTERNAL_SUBNET: Next hop is an internal subnet.
+        - EXTERNAL_SUBNET: Next hop is an external subnet.
+        - VPN_CONNECTION: Next hop is a VPN connection.
     """
     _UNKNOWN = "$UNKNOWN"
     _REDACTED = "$REDACTED"
-    UP = "UP"
-    DOWN = "DOWN"
+    IP_ADDRESS = "IP_ADDRESS"
+    DIRECT_CONNECT_VIF = "DIRECT_CONNECT_VIF"
+    INTERNAL_SUBNET = "INTERNAL_SUBNET"
+    EXTERNAL_SUBNET = "EXTERNAL_SUBNET"
+    VPN_CONNECTION = "VPN_CONNECTION"
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.State'
+        return 'networking.v4.config.NexthopType'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.State'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -82,36 +89,41 @@
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(State, dict):
+        if issubclass(NexthopType, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -123,15 +135,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, State):
+        if not isinstance(other, NexthopType):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/Status.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/VpcName.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,140 +3,118 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_networking_py_client.models.networking.v4.config.State import State  # noqa: F401,E501
+from pathlib import Path
 
-class Status(object):
+class VpcName(object):
 
-    """Up/Down status of component and message.
+    """VPC name for projections
 
-    :param message: (:attr:`message`) 
-    :type message: 
-    :param state: (:attr:`state`) 
-    :type state: 
+    :param name: (:attr:`name`) VPC name
+    :type name: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'message': 'str',
-        'state': 'networking.v4.config.State',
+        'name': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'message': 'message',
-        'state': 'state',
+        'name': 'name',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, message=None, state=None, *args, **kwargs):  # noqa: E501
-        self.__message = None
-        self.__state = None
+    def __init__(self, name=None, *args, **kwargs):  # noqa: E501
+        self.__name = None
         self.discriminator = None
-        if message is not None:
-            self.__message = message
-        if state is not None:
-            self.__state = state
+        if name is not None:
+            self.__name = name
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.Status'
+        return 'networking.v4.config.VpcName'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.Status'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def message(self):
+    def name(self):
         """
-        
+        VPC name
 
         :type:
 
                 :class:`~str`
         """  # noqa: E501
-        return self.__message
-
-    @message.setter
-    def message(self, message):
-
-        self.__message = message
-
-    @property
-    def state(self):
-        """
-        
-
-        :type:
-            :class:`~ntnx_networking_py_client.models.networking.v4.config.State`
-        """  # noqa: E501
-        return self.__state
+        return self.__name
 
-    @state.setter
-    def state(self, state):
+    @name.setter
+    def name(self, name):
 
-        self.__state = state
+        self.__name = name
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -169,37 +147,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(Status, dict):
+        if issubclass(VpcName, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -211,15 +194,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, Status):
+        if not isinstance(other, VpcName):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/StretchConnectionType.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ControllerStatus.py`

 * *Files 15% similar despite different names*

```diff
@@ -3,71 +3,74 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class StretchConnectionType(object):
+class ControllerStatus(object):
 
-    """Type of the connection used for stretching the subnet. The default is VPN.
+    """Current status of the network controller.
 
 
     Allowed enum values:
 
         - _UNKNOWN
         - _REDACTED
-        - VPN: VPN connection is used for stretching the subnet.
-        - VXLAN: VXLAN connection is used for stretching the subnet.
+        - UP: Network controller healthy and status is up.
+        - DEGRADED: Network controller is unhealthy and operating in degraded state.
+        - DOWN: Network controller is down.
     """
     _UNKNOWN = "$UNKNOWN"
     _REDACTED = "$REDACTED"
-    VPN = "VPN"
-    VXLAN = "VXLAN"
+    UP = "UP"
+    DEGRADED = "DEGRADED"
+    DOWN = "DOWN"
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.StretchConnectionType'
+        return 'networking.v4.config.ControllerStatus'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.StretchConnectionType'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -82,36 +85,41 @@
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(StretchConnectionType, dict):
+        if issubclass(ControllerStatus, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -123,15 +131,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, StretchConnectionType):
+        if not isinstance(other, ControllerStatus):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/StretchStatus.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/StretchStatus.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.networking.v4.config.State import State  # noqa: F401,E501
 
 class StretchStatus(object):
 
     """Current status of the Layer2 extension among subnets.
 
     :param detail: (:attr:`detail`) Detailed text describing the runtime status of this stretch configuration.
@@ -81,33 +82,33 @@
             self.__round_trip_time_millis = round_trip_time_millis
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.StretchStatus'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.StretchStatus'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -214,28 +215,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/Subnet.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/Subnet.py`

 * *Files 1% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.IPAddress import IPAddress  # noqa: F401,E501
 from ntnx_networking_py_client.models.common.v1.config.Metadata import Metadata  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.DhcpOptions import DhcpOptions  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.IPConfig import IPConfig  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.IPUsage import IPUsage  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.MigrationState import MigrationState  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.NetworkingBaseModel import NetworkingBaseModel  # noqa: F401,E501
@@ -228,16 +229,16 @@
             self.__ip_usage = ip_usage
         if migration_state is not None:
             self.__migration_state = migration_state
 
     def _initialize_object_type(self):
         return 'networking.v4.config.Subnet'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.Subnet'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     @property
     def name(self):
         """
         Name of the subnet.
 
@@ -621,28 +622,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/SubnetApiResponse.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/ListVpnConnectionsApiResponse.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_networking_py_client.models
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.SubnetApiResponsedata import SubnetApiResponsedata  # noqa: F401,E501
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.ListVpnConnectionsApiResponsedata import ListVpnConnectionsApiResponsedata  # noqa: F401,E501
 from ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class SubnetApiResponse(object):
+class ListVpnConnectionsApiResponse(object):
 
-    """REST response for all response codes in API path /networking/v4.0.b1/config/subnets/{extId} Get operation
+    """REST response for all response codes in API path /networking/v4.0.b1/config/vpn-connections Get operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfnetworking.v4.config.SubnetApiResponsedata',
+        'data': 'OneOfnetworking.v4.config.ListVpnConnectionsApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.SubnetApiResponse'
+        return 'networking.v4.config.ListVpnConnectionsApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.SubnetApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -122,15 +123,15 @@
 
     @property
     def data(self):
         """
         
 
         :type:
-                :class:`~ntnx_networking_py_client.models.networking.v4.config.Subnet` | 
+                :class:`~ntnx_networking_py_client.models.networking.v4.config.VpnConnection` | 
                 :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse`
                     """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
@@ -171,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(SubnetApiResponse, dict):
+        if issubclass(ListVpnConnectionsApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, SubnetApiResponse):
+        if not isinstance(other, ListVpnConnectionsApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/SubnetInfo.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/SubnetInfo.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
 class SubnetInfo(object):
 
     """
 
     :param subnet_uuid: (:attr:`subnet_uuid`) UUID of the subnet to be migrated.
     :type subnet_uuid: required
@@ -58,33 +59,33 @@
         self.__subnet_uuid = subnet_uuid
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.SubnetInfo'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.SubnetInfo'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -149,28 +150,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/SubnetListApiResponse.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/GetVpnConnectionApiResponse.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_networking_py_client.models
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.SubnetListApiResponsedata import SubnetListApiResponsedata  # noqa: F401,E501
+from ntnx_networking_py_client.models.OneOfnetworking.v4.config.GetVpnConnectionApiResponsedata import GetVpnConnectionApiResponsedata  # noqa: F401,E501
 from ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class SubnetListApiResponse(object):
+class GetVpnConnectionApiResponse(object):
 
-    """REST response for all response codes in API path /networking/v4.0.b1/config/subnets Get operation
+    """REST response for all response codes in API path /networking/v4.0.b1/config/vpn-connections/{extId} Get operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfnetworking.v4.config.SubnetListApiResponsedata',
+        'data': 'OneOfnetworking.v4.config.GetVpnConnectionApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.SubnetListApiResponse'
+        return 'networking.v4.config.GetVpnConnectionApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.SubnetListApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -122,17 +123,16 @@
 
     @property
     def data(self):
         """
         
 
         :type:
-                :class:`~ntnx_networking_py_client.models.networking.v4.config.Subnet` | 
-                :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse` | 
-                :class:`~ntnx_networking_py_client.models.networking.v4.config.SubnetProjection`
+                :class:`~ntnx_networking_py_client.models.networking.v4.config.VpnConnection` | 
+                :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse`
                     """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
         self.__data = data
@@ -172,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
                 type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(SubnetListApiResponse, dict):
+        if issubclass(GetVpnConnectionApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -216,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, SubnetListApiResponse):
+        if not isinstance(other, GetVpnConnectionApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/SubnetProjection.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/SubnetProjection.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.IPAddress import IPAddress  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.DhcpOptions import DhcpOptions  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.IPConfig import IPConfig  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.IPUsage import IPUsage  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.MigrationState import MigrationState  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.Subnet import Subnet  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.SubnetType import SubnetType  # noqa: F401,E501
@@ -130,16 +131,16 @@
             self.__virtual_switch_projection = virtual_switch_projection
         if vpc_projection is not None:
             self.__vpc_projection = vpc_projection
 
     def _initialize_object_type(self):
         return 'networking.v4.config.SubnetProjection'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.SubnetProjection'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     @property
     def virtual_switch_projection(self):
         """
         
 
@@ -172,28 +173,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/SubnetType.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/UplinkBondLacpStatus.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,71 +3,74 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class SubnetType(object):
+class UplinkBondLacpStatus(object):
 
-    """Type of subnet.
+    """LACP status of the bond (configured, negotiated, or off)
 
 
     Allowed enum values:
 
         - _UNKNOWN
         - _REDACTED
-        - OVERLAY
-        - VLAN
+        - CONFIGURED: Uplink bond LACP is configured.
+        - NEGOTIATED: Uplink bond LACP is under negotiation.
+        - NIL: LACP is not configured ("off") for uplink bond.
     """
     _UNKNOWN = "$UNKNOWN"
     _REDACTED = "$REDACTED"
-    OVERLAY = "OVERLAY"
-    VLAN = "VLAN"
+    CONFIGURED = "CONFIGURED"
+    NEGOTIATED = "NEGOTIATED"
+    NIL = "NIL"
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.SubnetType'
+        return 'networking.v4.config.UplinkBondLacpStatus'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.SubnetType'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -82,36 +85,41 @@
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(SubnetType, dict):
+        if issubclass(UplinkBondLacpStatus, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -123,15 +131,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, SubnetType):
+        if not isinstance(other, UplinkBondLacpStatus):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/TaskReferenceApiResponse.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/stats/GetVpnConnectionStatsApiResponse.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 import ntnx_networking_py_client.models
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.TaskReferenceApiResponsedata import TaskReferenceApiResponsedata  # noqa: F401,E501
+from ntnx_networking_py_client.models.OneOfnetworking.v4.stats.GetVpnConnectionStatsApiResponsedata import GetVpnConnectionStatsApiResponsedata  # noqa: F401,E501
 from ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
 
-class TaskReferenceApiResponse(object):
+class GetVpnConnectionStatsApiResponse(object):
 
-    """REST response for all response codes in API path /networking/v4.0.b1/config/vpn-connections/{extId} Delete operation
+    """REST response for all response codes in API path /networking/v4.0.b1/stats/vpn-connections/{extId} Get operation
 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param data: (:attr:`data`) 
     :type data: 
 
     """
@@ -39,15 +40,15 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfnetworking.v4.config.TaskReferenceApiResponsedata',
+        'data': 'OneOfnetworking.v4.stats.GetVpnConnectionStatsApiResponsedata',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'metadata': 'metadata',
@@ -67,35 +68,35 @@
             self.__metadata = metadata
         if data is not None:
             self.__data = data
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.TaskReferenceApiResponse'
+        return 'networking.v4.stats.GetVpnConnectionStatsApiResponse'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.TaskReferenceApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -122,15 +123,15 @@
 
     @property
     def data(self):
         """
         
 
         :type:
-                :class:`~ntnx_networking_py_client.models.prism.v4.config.TaskReference` | 
+                :class:`~ntnx_networking_py_client.models.networking.v4.stats.VpnConnectionStats` | 
                 :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse`
                     """  # noqa: E501
         return self.__data
 
     @data.setter
     def data(self, data):
 
@@ -171,39 +172,44 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_networking_py_client.models, 'ConfigTaskReferenceApiResponse')
+                type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(TaskReferenceApiResponse, dict):
+        if issubclass(GetVpnConnectionStatsApiResponse, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, TaskReferenceApiResponse):
+        if not isinstance(other, GetVpnConnectionStatsApiResponse):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/TrafficMirror.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/TrafficMirror.py`

 * *Files 13% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.Metadata import Metadata  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.NetworkingBaseModel import NetworkingBaseModel  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.TrafficMirrorPort import TrafficMirrorPort  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.TrafficMirrorSourcePort import TrafficMirrorSourcePort  # noqa: F401,E501
 
 class TrafficMirror(NetworkingBaseModel):
 
@@ -37,14 +38,16 @@
     :type destination_list: 
     :param is_enabled: (:attr:`is_enabled`) Indicates whether the port mirroring session is enabled or not. (**Default** True)
     :type is_enabled: 
     :param cluster_reference_list: (:attr:`cluster_reference_list`) List of cluster UUIDs that are configured for this session. Currently, only 1 cluster is allowed to participate in a session.
     :type cluster_reference_list: 
     :param host_reference_list: (:attr:`host_reference_list`) List of host UUIDs that are configured for this session. Currently, only 1 host is allowed to participate in a session.
     :type host_reference_list: 
+    :param virtual_switch_reference: (:attr:`virtual_switch_reference`) Traffic mirror virtual switch reference to use for Remote SPAN.
+    :type virtual_switch_reference: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
@@ -56,14 +59,15 @@
         'name': 'str',
         'description': 'str',
         'source_list': 'list[networking.v4.config.TrafficMirrorSourcePort]',
         'destination_list': 'list[networking.v4.config.TrafficMirrorPort]',
         'is_enabled': 'bool',
         'cluster_reference_list': 'list[str]',
         'host_reference_list': 'list[str]',
+        'virtual_switch_reference': 'str',
         'metadata': 'common.v1.config.Metadata',
         'ext_id': 'str',
         'links': 'list[common.v1.response.ApiLink]',
         'tenant_id': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
@@ -73,34 +77,36 @@
         'name': 'name',
         'description': 'description',
         'source_list': 'sourceList',
         'destination_list': 'destinationList',
         'is_enabled': 'isEnabled',
         'cluster_reference_list': 'clusterReferenceList',
         'host_reference_list': 'hostReferenceList',
+        'virtual_switch_reference': 'virtualSwitchReference',
         'metadata': 'metadata',
         'ext_id': 'extId',
         'links': 'links',
         'tenant_id': 'tenantId',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, name=None, description=None, source_list=None, destination_list=None, is_enabled=True, cluster_reference_list=None, host_reference_list=None, metadata=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
+    def __init__(self, name=None, description=None, source_list=None, destination_list=None, is_enabled=True, cluster_reference_list=None, host_reference_list=None, virtual_switch_reference=None, metadata=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
         NetworkingBaseModel.__init__(self, metadata, ext_id, links, tenant_id, *args, **kwargs)
         self.__name = None
         self.__description = None
         self.__source_list = None
         self.__destination_list = None
         self.__is_enabled = None
         self.__cluster_reference_list = None
         self.__host_reference_list = None
+        self.__virtual_switch_reference = None
         self.discriminator = None
         if name is not None:
             self.__name = name
         if description is not None:
             self.__description = description
         if source_list is not None:
             self.__source_list = source_list
@@ -108,20 +114,22 @@
             self.__destination_list = destination_list
         if is_enabled is not None:
             self.__is_enabled = is_enabled
         if cluster_reference_list is not None:
             self.__cluster_reference_list = cluster_reference_list
         if host_reference_list is not None:
             self.__host_reference_list = host_reference_list
+        if virtual_switch_reference is not None:
+            self.__virtual_switch_reference = virtual_switch_reference
 
     def _initialize_object_type(self):
         return 'networking.v4.config.TrafficMirror'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.TrafficMirror'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     @property
     def name(self):
         """
         Name of the session.
 
@@ -226,36 +234,59 @@
         return self.__host_reference_list
 
     @host_reference_list.setter
     def host_reference_list(self, host_reference_list):
 
         self.__host_reference_list = host_reference_list
 
+    @property
+    def virtual_switch_reference(self):
+        """
+        Traffic mirror virtual switch reference to use for Remote SPAN.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__virtual_switch_reference
+
+    @virtual_switch_reference.setter
+    def virtual_switch_reference(self, virtual_switch_reference):
+        if virtual_switch_reference is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', virtual_switch_reference):  # noqa: E501
+            raise ValueError(r"Invalid value for `virtual_switch_reference`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
+
+        self.__virtual_switch_reference = virtual_switch_reference
+
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/TrafficMirrorApiResponse.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/common/v1/config/IPv4Address.py`

 * *Files 17% similar despite different names*

```diff
@@ -3,142 +3,147 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_networking_py_client.models
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.TrafficMirrorApiResponsedata import TrafficMirrorApiResponsedata  # noqa: F401,E501
-from ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
-
-class TrafficMirrorApiResponse(object):
-
-    """REST response for all response codes in API path /networking/v4.0.b1/config/traffic-mirrors/{extId} Get operation
-
-    :param metadata: (:attr:`metadata`) 
-    :type metadata: 
-    :param data: (:attr:`data`) 
-    :type data: 
+from pathlib import Path
+
+class IPv4Address(object):
+
+    """
+
+    :param value: (:attr:`value`) 
+    :type value: 
+    :param prefix_length: (:attr:`prefix_length`) The prefix length of the network to which this host IPv4 address belongs.  (**Default** 32)
+    :type prefix_length: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfnetworking.v4.config.TrafficMirrorApiResponsedata',
+        'value': 'str',
+        'prefix_length': 'int',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'metadata': 'metadata',
-        'data': 'data',
+        'value': 'value',
+        'prefix_length': 'prefixLength',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        self.__metadata = None
-        self.__data = None
+    def __init__(self, value=None, prefix_length=32, *args, **kwargs):  # noqa: E501
+        self.__value = None
+        self.__prefix_length = None
         self.discriminator = None
-        if metadata is not None:
-            self.__metadata = metadata
-        if data is not None:
-            self.__data = data
+        if value is not None:
+            self.__value = value
+        if prefix_length is not None:
+            self.__prefix_length = prefix_length
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.TrafficMirrorApiResponse'
+        return 'common.v1.config.IPv4Address'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.TrafficMirrorApiResponse'
+    def _initialize_object_version(self):
+        return 'v1.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def metadata(self):
+    def value(self):
         """
         
 
         :type:
-            :class:`~ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata`
+
+                :class:`~str`
         """  # noqa: E501
-        return self.__metadata
+        return self.__value
 
-    @metadata.setter
-    def metadata(self, metadata):
+    @value.setter
+    def value(self, value):
+        if value is not None and not re.search('^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$', value):  # noqa: E501
+            raise ValueError(r"Invalid value for `value`, must be a follow pattern or equal to `/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/`")  # noqa: E501
 
-        self.__metadata = metadata
+        self.__value = value
 
     @property
-    def data(self):
+    def prefix_length(self):
         """
-        
+        The prefix length of the network to which this host IPv4 address belongs. 
 
         :type:
-                :class:`~ntnx_networking_py_client.models.networking.v4.config.TrafficMirror` | 
-                :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse`
-                    """  # noqa: E501
-        return self.__data
 
-    @data.setter
-    def data(self, data):
+                :class:`~int`
+        """  # noqa: E501
+        return self.__prefix_length
+
+    @prefix_length.setter
+    def prefix_length(self, prefix_length):
+        if prefix_length is not None and prefix_length > 32:  # noqa: E501
+            raise ValueError("Invalid value for `prefix_length`, must be a value less than or equal to `32`")  # noqa: E501
+        if prefix_length is not None and prefix_length < 0:  # noqa: E501
+            raise ValueError("Invalid value for `prefix_length`, must be a value greater than or equal to `0`")  # noqa: E501
 
-        self.__data = data
+        self.__prefix_length = prefix_length
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -171,39 +176,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
-            if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(TrafficMirrorApiResponse, dict):
+        if issubclass(IPv4Address, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +223,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, TrafficMirrorApiResponse):
+        if not isinstance(other, IPv4Address):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/TrafficMirrorListApiResponse.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/TrafficMirrorPort.py`

 * *Files 18% similar despite different names*

```diff
@@ -3,142 +3,168 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_networking_py_client.models
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.TrafficMirrorListApiResponsedata import TrafficMirrorListApiResponsedata  # noqa: F401,E501
-from ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
-
-class TrafficMirrorListApiResponse(object):
-
-    """REST response for all response codes in API path /networking/v4.0.b1/config/traffic-mirrors Get operation
-
-    :param metadata: (:attr:`metadata`) 
-    :type metadata: 
-    :param data: (:attr:`data`) 
-    :type data: 
+from pathlib import Path
+from ntnx_networking_py_client.models.networking.v4.config.TrafficMirrorPortNicType import TrafficMirrorPortNicType  # noqa: F401,E501
+
+class TrafficMirrorPort(object):
+
+    """Traffic mirror session port description.
+
+    :param nic_type: (:attr:`nic_type`) 
+    :type nic_type: required
+    :param nic_uuid: (:attr:`nic_uuid`) UUID of the NIC that this port belongs to.
+    :type nic_uuid: required
+    :param is_up: (:attr:`is_up`) Indicates whether the port is up.
+    :type is_up: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfnetworking.v4.config.TrafficMirrorListApiResponsedata',
+        'nic_type': 'networking.v4.config.TrafficMirrorPortNicType',
+        'nic_uuid': 'str',
+        'is_up': 'bool',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'metadata': 'metadata',
-        'data': 'data',
+        'nic_type': 'nicType',
+        'nic_uuid': 'nicUuid',
+        'is_up': 'isUp',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        self.__metadata = None
-        self.__data = None
+    def __init__(self, nic_type=None, nic_uuid=None, is_up=None, *args, **kwargs):  # noqa: E501
+        self.__nic_type = None
+        self.__nic_uuid = None
+        self.__is_up = None
         self.discriminator = None
-        if metadata is not None:
-            self.__metadata = metadata
-        if data is not None:
-            self.__data = data
+        self.__nic_type = nic_type
+        self.__nic_uuid = nic_uuid
+        if is_up is not None:
+            self.__is_up = is_up
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.TrafficMirrorListApiResponse'
+        return 'networking.v4.config.TrafficMirrorPort'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.TrafficMirrorListApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def metadata(self):
+    def nic_type(self):
         """
         
 
         :type:
-            :class:`~ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata`
+            :class:`~ntnx_networking_py_client.models.networking.v4.config.TrafficMirrorPortNicType`
         """  # noqa: E501
-        return self.__metadata
+        return self.__nic_type
 
-    @metadata.setter
-    def metadata(self, metadata):
+    @nic_type.setter
+    def nic_type(self, nic_type):
+        if nic_type is None:
+            raise ValueError("Invalid value for `nic_type`, must not be `None`")  # noqa: E501
 
-        self.__metadata = metadata
+        self.__nic_type = nic_type
 
     @property
-    def data(self):
+    def nic_uuid(self):
         """
-        
+        UUID of the NIC that this port belongs to.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__nic_uuid
+
+    @nic_uuid.setter
+    def nic_uuid(self, nic_uuid):
+        if nic_uuid is None:
+            raise ValueError("Invalid value for `nic_uuid`, must not be `None`")  # noqa: E501
+        if nic_uuid is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', nic_uuid):  # noqa: E501
+            raise ValueError(r"Invalid value for `nic_uuid`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
+
+        self.__nic_uuid = nic_uuid
+
+    @property
+    def is_up(self):
+        """
+        Indicates whether the port is up.
 
         :type:
-                :class:`~ntnx_networking_py_client.models.networking.v4.config.TrafficMirror` | 
-                :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse`
-                    """  # noqa: E501
-        return self.__data
 
-    @data.setter
-    def data(self, data):
+                :class:`~bool`
+        """  # noqa: E501
+        return self.__is_up
+
+    @is_up.setter
+    def is_up(self, is_up):
 
-        self.__data = data
+        self.__is_up = is_up
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -171,39 +197,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
-            if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(TrafficMirrorListApiResponse, dict):
+        if issubclass(TrafficMirrorPort, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +244,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, TrafficMirrorListApiResponse):
+        if not isinstance(other, TrafficMirrorPort):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/TrafficMirrorPort.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/RemoteVtepService.py`

 * *Files 12% similar despite different names*

```diff
@@ -3,167 +3,145 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_networking_py_client.models.networking.v4.config.TrafficMirrorPortNicType import TrafficMirrorPortNicType  # noqa: F401,E501
+from pathlib import Path
+from ntnx_networking_py_client.models.networking.v4.config.Vtep import Vtep  # noqa: F401,E501
 
-class TrafficMirrorPort(object):
+class RemoteVtepService(object):
 
-    """Traffic mirror session port description.
+    """VTEP service hosted on this remote gateway
 
-    :param nic_type: (:attr:`nic_type`) 
-    :type nic_type: required
-    :param nic_uuid: (:attr:`nic_uuid`) UUID of the NIC that this port belongs to.
-    :type nic_uuid: required
-    :param is_up: (:attr:`is_up`) Indicates whether the port is up. (**Default** True)
-    :type is_up: 
+    :param vxlan_port: (:attr:`vxlan_port`) VXLAN port (**Default** 4789)
+    :type vxlan_port: 
+    :param vteps: (:attr:`vteps`) Remote VXLAN Tunnel Endpoints configuration
+    :type vteps: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'nic_type': 'networking.v4.config.TrafficMirrorPortNicType',
-        'nic_uuid': 'str',
-        'is_up': 'bool',
+        'vxlan_port': 'int',
+        'vteps': 'list[networking.v4.config.Vtep]',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'nic_type': 'nicType',
-        'nic_uuid': 'nicUuid',
-        'is_up': 'isUp',
+        'vxlan_port': 'vxlanPort',
+        'vteps': 'vteps',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, nic_type=None, nic_uuid=None, is_up=True, *args, **kwargs):  # noqa: E501
-        self.__nic_type = None
-        self.__nic_uuid = None
-        self.__is_up = None
+    def __init__(self, vxlan_port=4789, vteps=None, *args, **kwargs):  # noqa: E501
+        self.__vxlan_port = None
+        self.__vteps = None
         self.discriminator = None
-        self.__nic_type = nic_type
-        self.__nic_uuid = nic_uuid
-        if is_up is not None:
-            self.__is_up = is_up
+        if vxlan_port is not None:
+            self.__vxlan_port = vxlan_port
+        if vteps is not None:
+            self.__vteps = vteps
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.TrafficMirrorPort'
+        return 'networking.v4.config.RemoteVtepService'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.TrafficMirrorPort'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def nic_type(self):
+    def vxlan_port(self):
         """
-        
+        VXLAN port
 
         :type:
-            :class:`~ntnx_networking_py_client.models.networking.v4.config.TrafficMirrorPortNicType`
-        """  # noqa: E501
-        return self.__nic_type
-
-    @nic_type.setter
-    def nic_type(self, nic_type):
-        if nic_type is None:
-            raise ValueError("Invalid value for `nic_type`, must not be `None`")  # noqa: E501
-
-        self.__nic_type = nic_type
-
-    @property
-    def nic_uuid(self):
-        """
-        UUID of the NIC that this port belongs to.
 
-        :type:
-
-                :class:`~str`
+                :class:`~int`
         """  # noqa: E501
-        return self.__nic_uuid
+        return self.__vxlan_port
 
-    @nic_uuid.setter
-    def nic_uuid(self, nic_uuid):
-        if nic_uuid is None:
-            raise ValueError("Invalid value for `nic_uuid`, must not be `None`")  # noqa: E501
-        if nic_uuid is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', nic_uuid):  # noqa: E501
-            raise ValueError(r"Invalid value for `nic_uuid`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
+    @vxlan_port.setter
+    def vxlan_port(self, vxlan_port):
+        if vxlan_port is not None and vxlan_port > 49151:  # noqa: E501
+            raise ValueError("Invalid value for `vxlan_port`, must be a value less than or equal to `49151`")  # noqa: E501
+        if vxlan_port is not None and vxlan_port < 1:  # noqa: E501
+            raise ValueError("Invalid value for `vxlan_port`, must be a value greater than or equal to `1`")  # noqa: E501
 
-        self.__nic_uuid = nic_uuid
+        self.__vxlan_port = vxlan_port
 
     @property
-    def is_up(self):
+    def vteps(self):
         """
-        Indicates whether the port is up.
+        Remote VXLAN Tunnel Endpoints configuration
 
         :type:
-
-                :class:`~bool`
+             list[ :class:`~ntnx_networking_py_client.models.networking.v4.config.Vtep` ]
         """  # noqa: E501
-        return self.__is_up
+        return self.__vteps
 
-    @is_up.setter
-    def is_up(self, is_up):
+    @vteps.setter
+    def vteps(self, vteps):
 
-        self.__is_up = is_up
+        self.__vteps = vteps
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -196,37 +174,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(TrafficMirrorPort, dict):
+        if issubclass(RemoteVtepService, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -238,15 +221,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, TrafficMirrorPort):
+        if not isinstance(other, RemoteVtepService):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/TrafficMirrorPortNicType.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/FlowGatewayState.py`

 * *Files 11% similar despite different names*

```diff
@@ -3,71 +3,76 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class TrafficMirrorPortNicType(object):
+class FlowGatewayState(object):
 
-    """Port NIC type for the Traffic mirror session. Allowed values are HOST_NIC and VIRTUAL_NIC.
+    """State of the Atlas Flow Gateway.
 
 
     Allowed enum values:
 
         - _UNKNOWN
         - _REDACTED
-        - HOST_NIC: Traffic mirror port is a host NIC.
-        - VIRTUAL_NIC: Traffic mirror port is a virtual NIC.
+        - HEALTHY: Flow gateway is healthy.
+        - DOWN: Flow gateway is down.
+        - PROVISIONING: Flow gateway is under provisioning.
+        - MAINTENANCE: Flow gateway in maintenance.
     """
     _UNKNOWN = "$UNKNOWN"
     _REDACTED = "$REDACTED"
-    HOST_NIC = "HOST_NIC"
-    VIRTUAL_NIC = "VIRTUAL_NIC"
+    HEALTHY = "HEALTHY"
+    DOWN = "DOWN"
+    PROVISIONING = "PROVISIONING"
+    MAINTENANCE = "MAINTENANCE"
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.TrafficMirrorPortNicType'
+        return 'networking.v4.config.FlowGatewayState'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.TrafficMirrorPortNicType'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -82,36 +87,41 @@
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(TrafficMirrorPortNicType, dict):
+        if issubclass(FlowGatewayState, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -123,15 +133,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, TrafficMirrorPortNicType):
+        if not isinstance(other, FlowGatewayState):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/TrafficMirrorSourcePort.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/TrafficMirrorSourcePort.py`

 * *Files 9% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.networking.v4.config.TrafficMirrorPort import TrafficMirrorPort  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.TrafficMirrorPortNicType import TrafficMirrorPortNicType  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.TrafficMirrorSourcePortDirection import TrafficMirrorSourcePortDirection  # noqa: F401,E501
 
 class TrafficMirrorSourcePort(TrafficMirrorPort):
 
     """Traffic mirror session source port to mirror traffic from.
@@ -57,25 +58,25 @@
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, direction=None, nic_type=None, nic_uuid=None, is_up=True, *args, **kwargs):  # noqa: E501
+    def __init__(self, direction=None, nic_type=None, nic_uuid=None, is_up=None, *args, **kwargs):  # noqa: E501
         TrafficMirrorPort.__init__(self, nic_type, nic_uuid, is_up, *args, **kwargs)
         self.__direction = None
         self.discriminator = None
         self.__direction = direction
 
     def _initialize_object_type(self):
         return 'networking.v4.config.TrafficMirrorSourcePort'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.TrafficMirrorSourcePort'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     @property
     def direction(self):
         """
         
 
@@ -95,28 +96,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/TrafficMirrorSourcePortDirection.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/stats/TrafficMirrorState.py`

 * *Files 12% similar despite different names*

```diff
@@ -3,73 +3,74 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class TrafficMirrorSourcePortDirection(object):
+class TrafficMirrorState(object):
 
-    """Indicates the direction of traffic that the session will mirror. Allowed values are INGRESS, EGRESS and BIDIRECTIONAL.
+    """Traffic mirror state value.
 
 
     Allowed enum values:
 
         - _UNKNOWN
         - _REDACTED
-        - INGRESS: Indicates the incoming direction of traffic that the session will mirror.
-        - EGRESS: Indicates the outgoing direction of traffic that the session will mirror.
-        - BIDIRECTIONAL: Indicates the bidirectional traffic that the session will mirror.
+        - ACTIVE: Traffic mirror session is active.
+        - ERROR: Traffic mirror session is in error status.
+        - DISABLED: Traffic mirror session is disabled.
     """
     _UNKNOWN = "$UNKNOWN"
     _REDACTED = "$REDACTED"
-    INGRESS = "INGRESS"
-    EGRESS = "EGRESS"
-    BIDIRECTIONAL = "BIDIRECTIONAL"
+    ACTIVE = "ACTIVE"
+    ERROR = "ERROR"
+    DISABLED = "DISABLED"
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.TrafficMirrorSourcePortDirection'
+        return 'networking.v4.stats.TrafficMirrorState'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.TrafficMirrorSourcePortDirection'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -84,36 +85,41 @@
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(TrafficMirrorSourcePortDirection, dict):
+        if issubclass(TrafficMirrorState, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -125,15 +131,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, TrafficMirrorSourcePortDirection):
+        if not isinstance(other, TrafficMirrorState):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/UnreserveType.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/DpdOperation.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,73 +3,74 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class UnreserveType(object):
+class DpdOperation(object):
 
-    """Type of IP Address unreservation.
+    """Operation to be performed on detecting a dead peer. The default is HOLD.
 
 
     Allowed enum values:
 
         - _UNKNOWN
         - _REDACTED
-        - IP_ADDRESS_LIST: Unreserve IP address based on the given IP address list.
-        - IP_ADDRESS_RANGE: Unreserve IP address based on the given IP range.
-        - CONTEXT: Unreserve IP address based on the given context.
+        - RESTART: Attempt to re-negotiate the connection.
+        - CLEAR: Close the connection.
+        - HOLD: Queue traffic while waiting for the connection to be re-established.
     """
     _UNKNOWN = "$UNKNOWN"
     _REDACTED = "$REDACTED"
-    IP_ADDRESS_LIST = "IP_ADDRESS_LIST"
-    IP_ADDRESS_RANGE = "IP_ADDRESS_RANGE"
-    CONTEXT = "CONTEXT"
+    RESTART = "RESTART"
+    CLEAR = "CLEAR"
+    HOLD = "HOLD"
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.UnreserveType'
+        return 'networking.v4.config.DpdOperation'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.UnreserveType'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -84,36 +85,41 @@
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(UnreserveType, dict):
+        if issubclass(DpdOperation, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -125,15 +131,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, UnreserveType):
+        if not isinstance(other, DpdOperation):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/UplinkBond.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/UplinkBond.py`

 * *Files 3% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.Metadata import Metadata  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.NetworkingBaseModel import NetworkingBaseModel  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.UplinkBondLacpStatus import UplinkBondLacpStatus  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.UplinkBondType import UplinkBondType  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.UplinkBondVirtualSwitchInfo import UplinkBondVirtualSwitchInfo  # noqa: F401,E501
 
 class UplinkBond(NetworkingBaseModel):
@@ -113,16 +114,16 @@
             self.__host_reference = host_reference
         if virtual_switch_info is not None:
             self.__virtual_switch_info = virtual_switch_info
 
     def _initialize_object_type(self):
         return 'networking.v4.config.UplinkBond'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.UplinkBond'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     @property
     def name(self):
         """
         Name of the bond
 
@@ -237,28 +238,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/UplinkBondApiResponse.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/AwsConfig.py`

 * *Files 18% similar despite different names*

```diff
@@ -3,142 +3,119 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_networking_py_client.models
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.UplinkBondApiResponsedata import UplinkBondApiResponsedata  # noqa: F401,E501
-from ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
-
-class UplinkBondApiResponse(object):
-
-    """REST response for all response codes in API path /networking/v4.0.b1/config/uplink-bonds/{extId} Get operation
-
-    :param metadata: (:attr:`metadata`) 
-    :type metadata: 
-    :param data: (:attr:`data`) 
-    :type data: 
+from pathlib import Path
+from ntnx_networking_py_client.models.networking.v4.config.AwsExternalSubnetConfig import AwsExternalSubnetConfig  # noqa: F401,E501
+
+class AwsConfig(object):
+
+    """AWS configuration.
+
+    :param external_subnet_config_list: (:attr:`external_subnet_config_list`) The external subnet configuration list for the AWS cloud.
+    :type external_subnet_config_list: required
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfnetworking.v4.config.UplinkBondApiResponsedata',
+        'external_subnet_config_list': 'list[networking.v4.config.AwsExternalSubnetConfig]',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'metadata': 'metadata',
-        'data': 'data',
+        'external_subnet_config_list': 'externalSubnetConfigList',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        self.__metadata = None
-        self.__data = None
+    def __init__(self, external_subnet_config_list=None, *args, **kwargs):  # noqa: E501
+        self.__external_subnet_config_list = None
         self.discriminator = None
-        if metadata is not None:
-            self.__metadata = metadata
-        if data is not None:
-            self.__data = data
+        self.__external_subnet_config_list = external_subnet_config_list
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.UplinkBondApiResponse'
+        return 'networking.v4.config.AwsConfig'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.UplinkBondApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def metadata(self):
+    def external_subnet_config_list(self):
         """
-        
+        The external subnet configuration list for the AWS cloud.
 
         :type:
-            :class:`~ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata`
+             list[ :class:`~ntnx_networking_py_client.models.networking.v4.config.AwsExternalSubnetConfig` ]
         """  # noqa: E501
-        return self.__metadata
-
-    @metadata.setter
-    def metadata(self, metadata):
-
-        self.__metadata = metadata
-
-    @property
-    def data(self):
-        """
-        
+        return self.__external_subnet_config_list
 
-        :type:
-                :class:`~ntnx_networking_py_client.models.networking.v4.config.UplinkBond` | 
-                :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse`
-                    """  # noqa: E501
-        return self.__data
+    @external_subnet_config_list.setter
+    def external_subnet_config_list(self, external_subnet_config_list):
+        if external_subnet_config_list is None:
+            raise ValueError("Invalid value for `external_subnet_config_list`, must not be `None`")  # noqa: E501
 
-    @data.setter
-    def data(self, data):
-
-        self.__data = data
+        self.__external_subnet_config_list = external_subnet_config_list
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -171,39 +148,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
-            if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(UplinkBondApiResponse, dict):
+        if issubclass(AwsConfig, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +195,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, UplinkBondApiResponse):
+        if not isinstance(other, AwsConfig):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/UplinkBondLacpStatus.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/common/v1/stats/DownSamplingOperator.py`

 * *Files 9% similar despite different names*

```diff
@@ -3,73 +3,85 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class UplinkBondLacpStatus(object):
+class DownSamplingOperator(object):
 
-    """LACP status of the bond (configured, negotiated, or off)
+    """The operator to use while performing down-sampling on stats data. Allowed values are SUM, MIN, MAX, AVG, COUNT and LAST. 
 
 
     Allowed enum values:
 
         - _UNKNOWN
         - _REDACTED
-        - CONFIGURED: Uplink bond LACP is configured.
-        - NEGOTIATED: Uplink bond LACP is under negotiation.
-        - NIL: LACP is not configured for uplink bond.
+        - SUM: Aggregation with sum of all values.
+
+        - MIN: Aggregation containing lowest of all values.
+
+        - MAX: Aggregation containing highest of all values.
+
+        - AVG: Aggregation indicating mean or average of all values.
+
+        - COUNT: Aggregation containing total count of values.
+
+        - LAST: Aggregation containing only the last recorded value.
     """
     _UNKNOWN = "$UNKNOWN"
     _REDACTED = "$REDACTED"
-    CONFIGURED = "CONFIGURED"
-    NEGOTIATED = "NEGOTIATED"
-    NIL = "NIL"
+    SUM = "SUM"
+    MIN = "MIN"
+    MAX = "MAX"
+    AVG = "AVG"
+    COUNT = "COUNT"
+    LAST = "LAST"
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.UplinkBondLacpStatus'
+        return 'common.v1.stats.DownSamplingOperator'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.UplinkBondLacpStatus'
+    def _initialize_object_version(self):
+        return 'v1.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -84,36 +96,41 @@
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(UplinkBondLacpStatus, dict):
+        if issubclass(DownSamplingOperator, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -125,15 +142,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, UplinkBondLacpStatus):
+        if not isinstance(other, DownSamplingOperator):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/UplinkBondListApiResponse.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/Status.py`

 * *Files 17% similar despite different names*

```diff
@@ -3,142 +3,141 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_networking_py_client.models
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.UplinkBondListApiResponsedata import UplinkBondListApiResponsedata  # noqa: F401,E501
-from ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
-
-class UplinkBondListApiResponse(object):
-
-    """REST response for all response codes in API path /networking/v4.0.b1/config/uplink-bonds Get operation
-
-    :param metadata: (:attr:`metadata`) 
-    :type metadata: 
-    :param data: (:attr:`data`) 
-    :type data: 
+from pathlib import Path
+from ntnx_networking_py_client.models.networking.v4.config.State import State  # noqa: F401,E501
+
+class Status(object):
+
+    """Up/Down status of component and message.
+
+    :param message: (:attr:`message`) 
+    :type message: 
+    :param state: (:attr:`state`) 
+    :type state: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfnetworking.v4.config.UplinkBondListApiResponsedata',
+        'message': 'str',
+        'state': 'networking.v4.config.State',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'metadata': 'metadata',
-        'data': 'data',
+        'message': 'message',
+        'state': 'state',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        self.__metadata = None
-        self.__data = None
+    def __init__(self, message=None, state=None, *args, **kwargs):  # noqa: E501
+        self.__message = None
+        self.__state = None
         self.discriminator = None
-        if metadata is not None:
-            self.__metadata = metadata
-        if data is not None:
-            self.__data = data
+        if message is not None:
+            self.__message = message
+        if state is not None:
+            self.__state = state
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.UplinkBondListApiResponse'
+        return 'networking.v4.config.Status'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.UplinkBondListApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def metadata(self):
+    def message(self):
         """
         
 
         :type:
-            :class:`~ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata`
+
+                :class:`~str`
         """  # noqa: E501
-        return self.__metadata
+        return self.__message
 
-    @metadata.setter
-    def metadata(self, metadata):
+    @message.setter
+    def message(self, message):
 
-        self.__metadata = metadata
+        self.__message = message
 
     @property
-    def data(self):
+    def state(self):
         """
         
 
         :type:
-                :class:`~ntnx_networking_py_client.models.networking.v4.config.UplinkBond` | 
-                :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse`
-                    """  # noqa: E501
-        return self.__data
+            :class:`~ntnx_networking_py_client.models.networking.v4.config.State`
+        """  # noqa: E501
+        return self.__state
 
-    @data.setter
-    def data(self, data):
+    @state.setter
+    def state(self, state):
 
-        self.__data = data
+        self.__state = state
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -171,39 +170,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
-            if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(UplinkBondListApiResponse, dict):
+        if issubclass(Status, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +217,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, UplinkBondListApiResponse):
+        if not isinstance(other, Status):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/UplinkBondType.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/RoutingPolicyActionType.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,73 +3,76 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
-class UplinkBondType(object):
+class RoutingPolicyActionType(object):
 
-    """Type of the bond (active-backup, balance-slb, or balance-tcp)
+    """Routing policy action type.
 
 
     Allowed enum values:
 
         - _UNKNOWN
         - _REDACTED
-        - ACTIVE_BACKUP: Uplink bond is configured as active-backup mode.
-        - BALANCE_SLB: Uplink bond is configured as balance-slb mode.
-        - BALANCE_TCP: Uplink bond is configured as balance-tcp mode.
+        - PERMIT: Routing policy action type is permit/allow
+        - DENY: Routing policy action type is deny/drop
+        - REROUTE: Routing policy action type is reroute and need to specify service IP to which traffic is rerouted
+        - FORWARD: Routing policy action type is forward
     """
     _UNKNOWN = "$UNKNOWN"
     _REDACTED = "$REDACTED"
-    ACTIVE_BACKUP = "ACTIVE_BACKUP"
-    BALANCE_SLB = "BALANCE_SLB"
-    BALANCE_TCP = "BALANCE_TCP"
+    PERMIT = "PERMIT"
+    DENY = "DENY"
+    REROUTE = "REROUTE"
+    FORWARD = "FORWARD"
 
 
     def __init__(self, *args, **kwargs):  # noqa: E501
         self.discriminator = None
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.UplinkBondType'
+        return 'networking.v4.config.RoutingPolicyActionType'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.UplinkBondType'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -84,36 +87,41 @@
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
 
-        for attr, attr_type in six.iteritems(self.swagger_types):
+        for attr in vars(self):
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(UplinkBondType, dict):
+        if issubclass(RoutingPolicyActionType, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -125,15 +133,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, UplinkBondType):
+        if not isinstance(other, RoutingPolicyActionType):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/UplinkBondVirtualSwitchInfo.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/UplinkBondVirtualSwitchInfo.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
 class UplinkBondVirtualSwitchInfo(object):
 
     """Virtual Switch info associated with bond (if any)
 
     :param reference: (:attr:`reference`) UUID of the Virtual Switch this bond is a part of
     :type reference: 
@@ -66,33 +67,33 @@
             self.__name = name
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.UplinkBondVirtualSwitchInfo'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.UplinkBondVirtualSwitchInfo'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -171,28 +172,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/VirtualSwitch.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/VirtualSwitch.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.Metadata import Metadata  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.BondModeType import BondModeType  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.Cluster import Cluster  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.NetworkingBaseModel import NetworkingBaseModel  # noqa: F401,E501
 
 class VirtualSwitch(NetworkingBaseModel):
 
@@ -116,16 +117,16 @@
             self.__mtu = mtu
         self.__bond_mode = bond_mode
         self.__clusters = clusters
 
     def _initialize_object_type(self):
         return 'networking.v4.config.VirtualSwitch'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.VirtualSwitch'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     @property
     def name(self):
         """
         User-visible Virtual Switch name
 
@@ -264,28 +265,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/VirtualSwitchApiResponse.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/common/v1/response/ApiLink.py`

 * *Files 19% similar despite different names*

```diff
@@ -3,142 +3,141 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_networking_py_client.models
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.VirtualSwitchApiResponsedata import VirtualSwitchApiResponsedata  # noqa: F401,E501
-from ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
-
-class VirtualSwitchApiResponse(object):
-
-    """REST response for all response codes in API path /networking/v4.0.b1/config/virtual-switches/{extId} Get operation
-
-    :param metadata: (:attr:`metadata`) 
-    :type metadata: 
-    :param data: (:attr:`data`) 
-    :type data: 
+from pathlib import Path
+
+class ApiLink(object):
+
+    """A HATEOAS style link for the response.  Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource. 
+
+    :param href: (:attr:`href`) The URL at which the entity described by the link can be accessed. 
+    :type href: 
+    :param rel: (:attr:`rel`) A name that identifies the relationship of the link to the object that is returned by the URL.  The unique value of \"self\" identifies the URL for the object. 
+    :type rel: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfnetworking.v4.config.VirtualSwitchApiResponsedata',
+        'href': 'str',
+        'rel': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'metadata': 'metadata',
-        'data': 'data',
+        'href': 'href',
+        'rel': 'rel',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        self.__metadata = None
-        self.__data = None
+    def __init__(self, href=None, rel=None, *args, **kwargs):  # noqa: E501
+        self.__href = None
+        self.__rel = None
         self.discriminator = None
-        if metadata is not None:
-            self.__metadata = metadata
-        if data is not None:
-            self.__data = data
+        if href is not None:
+            self.__href = href
+        if rel is not None:
+            self.__rel = rel
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.VirtualSwitchApiResponse'
+        return 'common.v1.response.ApiLink'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.VirtualSwitchApiResponse'
+    def _initialize_object_version(self):
+        return 'v1.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def metadata(self):
+    def href(self):
         """
-        
+        The URL at which the entity described by the link can be accessed. 
 
         :type:
-            :class:`~ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata`
+
+                :class:`~str`
         """  # noqa: E501
-        return self.__metadata
+        return self.__href
 
-    @metadata.setter
-    def metadata(self, metadata):
+    @href.setter
+    def href(self, href):
 
-        self.__metadata = metadata
+        self.__href = href
 
     @property
-    def data(self):
+    def rel(self):
         """
-        
+        A name that identifies the relationship of the link to the object that is returned by the URL.  The unique value of \"self\" identifies the URL for the object. 
 
         :type:
-                :class:`~ntnx_networking_py_client.models.networking.v4.config.VirtualSwitch` | 
-                :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse`
-                    """  # noqa: E501
-        return self.__data
 
-    @data.setter
-    def data(self, data):
+                :class:`~str`
+        """  # noqa: E501
+        return self.__rel
+
+    @rel.setter
+    def rel(self, rel):
 
-        self.__data = data
+        self.__rel = rel
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -171,39 +170,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
-            if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(VirtualSwitchApiResponse, dict):
+        if issubclass(ApiLink, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +217,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, VirtualSwitchApiResponse):
+        if not isinstance(other, ApiLink):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/VirtualSwitchListApiResponse.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/stats/TrafficMirrorStatsData.py`

 * *Files 17% similar despite different names*

```diff
@@ -3,143 +3,143 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_networking_py_client.models
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.VirtualSwitchListApiResponsedata import VirtualSwitchListApiResponsedata  # noqa: F401,E501
-from ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
-
-class VirtualSwitchListApiResponse(object):
-
-    """REST response for all response codes in API path /networking/v4.0.b1/config/virtual-switches Get operation
-
-    :param metadata: (:attr:`metadata`) 
-    :type metadata: 
-    :param data: (:attr:`data`) 
-    :type data: 
+from pathlib import Path
+
+class TrafficMirrorStatsData(object):
+
+    """Traffic mirror stats data values.
+
+    :param transmit_packet_count: (:attr:`transmit_packet_count`) Traffic mirror number of packets transmitted.
+    :type transmit_packet_count: required
+    :param transmit_byte_count: (:attr:`transmit_byte_count`) Traffic mirror bytes transmitted.
+    :type transmit_byte_count: required
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfnetworking.v4.config.VirtualSwitchListApiResponsedata',
+        'transmit_packet_count': 'int',
+        'transmit_byte_count': 'int',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'metadata': 'metadata',
-        'data': 'data',
+        'transmit_packet_count': 'transmitPacketCount',
+        'transmit_byte_count': 'transmitByteCount',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        self.__metadata = None
-        self.__data = None
+    def __init__(self, transmit_packet_count=None, transmit_byte_count=None, *args, **kwargs):  # noqa: E501
+        self.__transmit_packet_count = None
+        self.__transmit_byte_count = None
         self.discriminator = None
-        if metadata is not None:
-            self.__metadata = metadata
-        if data is not None:
-            self.__data = data
+        self.__transmit_packet_count = transmit_packet_count
+        self.__transmit_byte_count = transmit_byte_count
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.VirtualSwitchListApiResponse'
+        return 'networking.v4.stats.TrafficMirrorStatsData'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.VirtualSwitchListApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def metadata(self):
+    def transmit_packet_count(self):
         """
-        
+        Traffic mirror number of packets transmitted.
 
         :type:
-            :class:`~ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata`
+
+                :class:`~int`
         """  # noqa: E501
-        return self.__metadata
+        return self.__transmit_packet_count
 
-    @metadata.setter
-    def metadata(self, metadata):
+    @transmit_packet_count.setter
+    def transmit_packet_count(self, transmit_packet_count):
+        if transmit_packet_count is None:
+            raise ValueError("Invalid value for `transmit_packet_count`, must not be `None`")  # noqa: E501
 
-        self.__metadata = metadata
+        self.__transmit_packet_count = transmit_packet_count
 
     @property
-    def data(self):
+    def transmit_byte_count(self):
         """
-        
+        Traffic mirror bytes transmitted.
 
         :type:
-                :class:`~ntnx_networking_py_client.models.networking.v4.config.VirtualSwitch` | 
-                :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse` | 
-                :class:`~ntnx_networking_py_client.models.networking.v4.config.VirtualSwitchProjection`
-                    """  # noqa: E501
-        return self.__data
 
-    @data.setter
-    def data(self, data):
+                :class:`~int`
+        """  # noqa: E501
+        return self.__transmit_byte_count
+
+    @transmit_byte_count.setter
+    def transmit_byte_count(self, transmit_byte_count):
+        if transmit_byte_count is None:
+            raise ValueError("Invalid value for `transmit_byte_count`, must not be `None`")  # noqa: E501
 
-        self.__data = data
+        self.__transmit_byte_count = transmit_byte_count
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -172,39 +172,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
-            if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(VirtualSwitchListApiResponse, dict):
+        if issubclass(TrafficMirrorStatsData, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -216,15 +219,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, VirtualSwitchListApiResponse):
+        if not isinstance(other, TrafficMirrorStatsData):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/VirtualSwitchProjection.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/VirtualSwitchProjection.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.networking.v4.config.BondModeType import BondModeType  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.Cluster import Cluster  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.VirtualSwitch import VirtualSwitch  # noqa: F401,E501
 
 class VirtualSwitchProjection(VirtualSwitch):
 
     """
@@ -42,17 +43,17 @@
     :type bond_mode: required
     :param clusters: (:attr:`clusters`) Cluster configuration list
     :type clusters: required
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param ext_id: (:attr:`ext_id`) A globally unique identifier of an instance that is suitable for external consumption. 
     :type ext_id: 
-    :param links: (:attr:`links`) A HATEOAS style link for the response.  Each link contains a user friendly name identifying the link and an address for retrieving the particular resource. 
+    :param links: (:attr:`links`) A HATEOAS style link for the response.  Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource. 
     :type links: 
-    :param tenant_id: (:attr:`tenant_id`) A globally unique identifier that represents the tenant that owns this entity.  It is automatically assigned by the system and is immutable from an API consumer perspective (some use cases may cause this Id to change - for instance a use case may require the transfer of ownership of the entity, but these cases are handled automatically on the server). 
+    :param tenant_id: (:attr:`tenant_id`) A globally unique identifier that represents the tenant that owns this entity. The system automatically assigns it, and it and is immutable from an API consumer perspective (some use cases may cause this Id to change - For instance, a use case may require the transfer of ownership of the entity, but these cases are handled automatically on the server). 
     :type tenant_id: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
@@ -102,40 +103,45 @@
     def __init__(self, name=None, description=None, is_default=False, is_quick_mode=False, has_deployment_error=None, mtu=None, bond_mode=None, clusters=None, metadata=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
         VirtualSwitch.__init__(self, name, description, is_default, is_quick_mode, has_deployment_error, mtu, bond_mode, clusters, metadata, ext_id, links, tenant_id, *args, **kwargs)
         self.discriminator = None
 
     def _initialize_object_type(self):
         return 'networking.v4.config.VirtualSwitchProjection'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.VirtualSwitchProjection'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/VlanSubnetMigrationSpec.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/VlanSubnetMigrationSpec.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,32 +3,33 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.networking.v4.config.SubnetInfo import SubnetInfo  # noqa: F401,E501
 
 class VlanSubnetMigrationSpec(object):
 
     """Schema for VLAN subnet migration.
 
-    :param subnets: (:attr:`subnets`) Information on the VLAN Subnet that need to be migrated.
+    :param subnets: (:attr:`subnets`) VLAN subnet details that need to be migrated.
     :type subnets: required
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
@@ -59,33 +60,33 @@
         self.__subnets = subnets
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.VlanSubnetMigrationSpec'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.VlanSubnetMigrationSpec'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -94,15 +95,15 @@
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def subnets(self):
         """
-        Information on the VLAN Subnet that need to be migrated.
+        VLAN subnet details that need to be migrated.
 
         :type:
              list[ :class:`~ntnx_networking_py_client.models.networking.v4.config.SubnetInfo` ]
         """  # noqa: E501
         return self.__subnets
 
     @subnets.setter
@@ -147,28 +148,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/Vm.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/Vtep.py`

 * *Files 16% similar despite different names*

```diff
@@ -3,117 +3,118 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
+from ntnx_networking_py_client.models.common.v1.config.IPAddress import IPAddress  # noqa: F401,E501
 
-class Vm(object):
+class Vtep(object):
 
-    """Virtual Machine properties
+    """VXLAN Tunnel Endpoint
 
-    :param name: (:attr:`name`) Virtual Machine name
-    :type name: 
+    :param address: (:attr:`address`) 
+    :type address: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'name': 'str',
+        'address': 'common.v1.config.IPAddress',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'name': 'name',
+        'address': 'address',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, name=None, *args, **kwargs):  # noqa: E501
-        self.__name = None
+    def __init__(self, address=None, *args, **kwargs):  # noqa: E501
+        self.__address = None
         self.discriminator = None
-        if name is not None:
-            self.__name = name
+        if address is not None:
+            self.__address = address
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.Vm'
+        return 'networking.v4.config.Vtep'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.Vm'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def name(self):
+    def address(self):
         """
-        Virtual Machine name
+        
 
         :type:
-
-                :class:`~str`
+            :class:`~ntnx_networking_py_client.models.common.v1.config.IPAddress`
         """  # noqa: E501
-        return self.__name
+        return self.__address
 
-    @name.setter
-    def name(self, name):
+    @address.setter
+    def address(self, address):
 
-        self.__name = name
+        self.__address = address
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -146,37 +147,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(Vm, dict):
+        if issubclass(Vtep, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -188,15 +194,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, Vm):
+        if not isinstance(other, Vtep):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/VmNic.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/VnicMigrationSpec.py`

 * *Files 14% similar despite different names*

```diff
@@ -3,117 +3,119 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
+from ntnx_networking_py_client.models.networking.v4.config.VnicMigrationItem import VnicMigrationItem  # noqa: F401,E501
 
-class VmNic(object):
+class VnicMigrationSpec(object):
 
-    """Virtal NIC for projections
+    """Schema for subnet migration.
 
-    :param private_ip: (:attr:`private_ip`) Private IP value in string
-    :type private_ip: 
+    :param vnic_migration_input: (:attr:`vnic_migration_input`) Input for subnet migration.
+    :type vnic_migration_input: required
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'private_ip': 'str',
+        'vnic_migration_input': 'list[networking.v4.config.VnicMigrationItem]',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'private_ip': 'privateIp',
+        'vnic_migration_input': 'vnicMigrationInput',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, private_ip=None, *args, **kwargs):  # noqa: E501
-        self.__private_ip = None
+    def __init__(self, vnic_migration_input=None, *args, **kwargs):  # noqa: E501
+        self.__vnic_migration_input = None
         self.discriminator = None
-        if private_ip is not None:
-            self.__private_ip = private_ip
+        self.__vnic_migration_input = vnic_migration_input
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.VmNic'
+        return 'networking.v4.config.VnicMigrationSpec'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.VmNic'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def private_ip(self):
+    def vnic_migration_input(self):
         """
-        Private IP value in string
+        Input for subnet migration.
 
         :type:
-
-                :class:`~str`
+             list[ :class:`~ntnx_networking_py_client.models.networking.v4.config.VnicMigrationItem` ]
         """  # noqa: E501
-        return self.__private_ip
+        return self.__vnic_migration_input
 
-    @private_ip.setter
-    def private_ip(self, private_ip):
+    @vnic_migration_input.setter
+    def vnic_migration_input(self, vnic_migration_input):
+        if vnic_migration_input is None:
+            raise ValueError("Invalid value for `vnic_migration_input`, must not be `None`")  # noqa: E501
 
-        self.__private_ip = private_ip
+        self.__vnic_migration_input = vnic_migration_input
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -146,37 +148,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(VmNic, dict):
+        if issubclass(VnicMigrationSpec, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -188,15 +195,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, VmNic):
+        if not isinstance(other, VnicMigrationSpec):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/VmNicAssociation.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/VmNicAssociation.py`

 * *Files 3% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 
 class VmNicAssociation(object):
 
     """VM NIC and VPC to which the VM NIC subnet belongs.
 
     :param vm_nic_reference: (:attr:`vm_nic_reference`) VM NIC reference.
     :type vm_nic_reference: required
@@ -65,33 +66,33 @@
             self.__vpc_reference = vpc_reference
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.VmNicAssociation'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.VmNicAssociation'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -174,28 +175,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/VmNicProjection.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/VmNicProjection.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.networking.v4.config.VmNic import VmNic  # noqa: F401,E501
 
 class VmNicProjection(VmNic):
 
     """
 
     :param private_ip: (:attr:`private_ip`) Private IP value in string
@@ -56,40 +57,45 @@
     def __init__(self, private_ip=None, *args, **kwargs):  # noqa: E501
         VmNic.__init__(self, private_ip, *args, **kwargs)
         self.discriminator = None
 
     def _initialize_object_type(self):
         return 'networking.v4.config.VmNicProjection'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.VmNicProjection'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/VmProjection.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/VmProjection.py`

 * *Files 17% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.networking.v4.config.Vm import Vm  # noqa: F401,E501
 
 class VmProjection(Vm):
 
     """
 
     :param name: (:attr:`name`) Virtual Machine name
@@ -56,40 +57,45 @@
     def __init__(self, name=None, *args, **kwargs):  # noqa: E501
         Vm.__init__(self, name, *args, **kwargs)
         self.discriminator = None
 
     def _initialize_object_type(self):
         return 'networking.v4.config.VmProjection'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.VmProjection'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/VnicMigrationItem.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/VnicMigrationItem.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.IPAddress import IPAddress  # noqa: F401,E501
 
 class VnicMigrationItem(object):
 
     """
 
     :param nic_uuid: (:attr:`nic_uuid`) UUID of NIC to be migrated.
@@ -72,33 +73,33 @@
             self.__requested_ip_addresses = requested_ip_addresses
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.config.VnicMigrationItem'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.VnicMigrationItem'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -198,28 +199,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/VnicMigrationSpec.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/stats/RoutingPolicyClearCountersSpec.py`

 * *Files 20% similar despite different names*

```diff
@@ -3,118 +3,142 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_networking_py_client.models.networking.v4.config.VnicMigrationItem import VnicMigrationItem  # noqa: F401,E501
+from pathlib import Path
 
-class VnicMigrationSpec(object):
+class RoutingPolicyClearCountersSpec(object):
 
-    """Schema for subnet migration.
+    """VPC UUID to reset all routing policy counters to zero.
 
-    :param vnic_migration_input: (:attr:`vnic_migration_input`) Input for subnet migration.
-    :type vnic_migration_input: required
+    :param vpc_ext_id: (:attr:`vpc_ext_id`) 
+    :type vpc_ext_id: required
+    :param routing_policy_ext_id: (:attr:`routing_policy_ext_id`) 
+    :type routing_policy_ext_id: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'vnic_migration_input': 'list[networking.v4.config.VnicMigrationItem]',
+        'vpc_ext_id': 'str',
+        'routing_policy_ext_id': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'vnic_migration_input': 'vnicMigrationInput',
+        'vpc_ext_id': 'vpcExtId',
+        'routing_policy_ext_id': 'routingPolicyExtId',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, vnic_migration_input=None, *args, **kwargs):  # noqa: E501
-        self.__vnic_migration_input = None
+    def __init__(self, vpc_ext_id=None, routing_policy_ext_id=None, *args, **kwargs):  # noqa: E501
+        self.__vpc_ext_id = None
+        self.__routing_policy_ext_id = None
         self.discriminator = None
-        self.__vnic_migration_input = vnic_migration_input
+        self.__vpc_ext_id = vpc_ext_id
+        if routing_policy_ext_id is not None:
+            self.__routing_policy_ext_id = routing_policy_ext_id
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.VnicMigrationSpec'
+        return 'networking.v4.stats.RoutingPolicyClearCountersSpec'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.VnicMigrationSpec'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def vnic_migration_input(self):
+    def vpc_ext_id(self):
         """
-        Input for subnet migration.
+        
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__vpc_ext_id
+
+    @vpc_ext_id.setter
+    def vpc_ext_id(self, vpc_ext_id):
+        if vpc_ext_id is None:
+            raise ValueError("Invalid value for `vpc_ext_id`, must not be `None`")  # noqa: E501
+
+        self.__vpc_ext_id = vpc_ext_id
+
+    @property
+    def routing_policy_ext_id(self):
+        """
+        
 
         :type:
-             list[ :class:`~ntnx_networking_py_client.models.networking.v4.config.VnicMigrationItem` ]
+
+                :class:`~str`
         """  # noqa: E501
-        return self.__vnic_migration_input
+        return self.__routing_policy_ext_id
 
-    @vnic_migration_input.setter
-    def vnic_migration_input(self, vnic_migration_input):
-        if vnic_migration_input is None:
-            raise ValueError("Invalid value for `vnic_migration_input`, must not be `None`")  # noqa: E501
+    @routing_policy_ext_id.setter
+    def routing_policy_ext_id(self, routing_policy_ext_id):
 
-        self.__vnic_migration_input = vnic_migration_input
+        self.__routing_policy_ext_id = routing_policy_ext_id
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -147,37 +171,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(VnicMigrationSpec, dict):
+        if issubclass(RoutingPolicyClearCountersSpec, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -189,15 +218,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, VnicMigrationSpec):
+        if not isinstance(other, RoutingPolicyClearCountersSpec):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/Vpc.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/Vpc.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,40 +3,44 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.IPAddress import IPAddress  # noqa: F401,E501
 from ntnx_networking_py_client.models.common.v1.config.Metadata import Metadata  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.ExternalSubnet import ExternalSubnet  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.IPSubnet import IPSubnet  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.NetworkingBaseModel import NetworkingBaseModel  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.VpcDhcpOptions import VpcDhcpOptions  # noqa: F401,E501
+from ntnx_networking_py_client.models.networking.v4.config.VpcType import VpcType  # noqa: F401,E501
 
 class Vpc(NetworkingBaseModel):
 
     """
 
     :param name: (:attr:`name`) Name of the VPC.
     :type name: required
     :param description: (:attr:`description`) Description of the VPC.
     :type description: 
+    :param vpc_type: (:attr:`vpc_type`) 
+    :type vpc_type: 
     :param common_dhcp_options: (:attr:`common_dhcp_options`) 
     :type common_dhcp_options: 
     :param snat_ips: (:attr:`snat_ips`) List of IP Addresses used for SNAT.
     :type snat_ips: 
     :param external_subnets: (:attr:`external_subnets`) List of external subnets that the VPC is attached to.
     :type external_subnets: 
     :param external_routing_domain_reference: (:attr:`external_routing_domain_reference`) External routing domain associated with this route table
@@ -53,14 +57,15 @@
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'name': 'str',
         'description': 'str',
+        'vpc_type': 'networking.v4.config.VpcType',
         'common_dhcp_options': 'networking.v4.config.VpcDhcpOptions',
         'snat_ips': 'list[common.v1.config.IPAddress]',
         'external_subnets': 'list[networking.v4.config.ExternalSubnet]',
         'external_routing_domain_reference': 'str',
         'externally_routable_prefixes': 'list[networking.v4.config.IPSubnet]',
         'metadata': 'common.v1.config.Metadata',
         'ext_id': 'str',
@@ -70,14 +75,15 @@
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'name': 'name',
         'description': 'description',
+        'vpc_type': 'vpcType',
         'common_dhcp_options': 'commonDhcpOptions',
         'snat_ips': 'snatIps',
         'external_subnets': 'externalSubnets',
         'external_routing_domain_reference': 'externalRoutingDomainReference',
         'externally_routable_prefixes': 'externallyRoutablePrefixes',
         'metadata': 'metadata',
         'ext_id': 'extId',
@@ -86,43 +92,46 @@
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, name=None, description=None, common_dhcp_options=None, snat_ips=None, external_subnets=None, external_routing_domain_reference=None, externally_routable_prefixes=None, metadata=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
+    def __init__(self, name=None, description=None, vpc_type=None, common_dhcp_options=None, snat_ips=None, external_subnets=None, external_routing_domain_reference=None, externally_routable_prefixes=None, metadata=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
         NetworkingBaseModel.__init__(self, metadata, ext_id, links, tenant_id, *args, **kwargs)
         self.__name = None
         self.__description = None
+        self.__vpc_type = None
         self.__common_dhcp_options = None
         self.__snat_ips = None
         self.__external_subnets = None
         self.__external_routing_domain_reference = None
         self.__externally_routable_prefixes = None
         self.discriminator = None
         self.__name = name
         if description is not None:
             self.__description = description
+        if vpc_type is not None:
+            self.__vpc_type = vpc_type
         if common_dhcp_options is not None:
             self.__common_dhcp_options = common_dhcp_options
         if snat_ips is not None:
             self.__snat_ips = snat_ips
         if external_subnets is not None:
             self.__external_subnets = external_subnets
         if external_routing_domain_reference is not None:
             self.__external_routing_domain_reference = external_routing_domain_reference
         if externally_routable_prefixes is not None:
             self.__externally_routable_prefixes = externally_routable_prefixes
 
     def _initialize_object_type(self):
         return 'networking.v4.config.Vpc'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.Vpc'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     @property
     def name(self):
         """
         Name of the VPC.
 
@@ -156,14 +165,29 @@
     def description(self, description):
         if description is not None and len(description) > 1000:
             raise ValueError("Invalid value for `description`, length must be less than or equal to `1000`")  # noqa: E501
 
         self.__description = description
 
     @property
+    def vpc_type(self):
+        """
+        
+
+        :type:
+            :class:`~ntnx_networking_py_client.models.networking.v4.config.VpcType`
+        """  # noqa: E501
+        return self.__vpc_type
+
+    @vpc_type.setter
+    def vpc_type(self, vpc_type):
+
+        self.__vpc_type = vpc_type
+
+    @property
     def common_dhcp_options(self):
         """
         
 
         :type:
             :class:`~ntnx_networking_py_client.models.networking.v4.config.VpcDhcpOptions`
         """  # noqa: E501
@@ -241,28 +265,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/VpcApiResponse.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/AwsExternalSubnetConfig.py`

 * *Files 15% similar despite different names*

```diff
@@ -3,142 +3,144 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_networking_py_client.models
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.VpcApiResponsedata import VpcApiResponsedata  # noqa: F401,E501
-from ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
-
-class VpcApiResponse(object):
-
-    """REST response for all response codes in API path /networking/v4.0.b1/config/vpcs/{extId} Get operation
-
-    :param metadata: (:attr:`metadata`) 
-    :type metadata: 
-    :param data: (:attr:`data`) 
-    :type data: 
+from pathlib import Path
+from ntnx_networking_py_client.models.networking.v4.config.AwsSubnetConfig import AwsSubnetConfig  # noqa: F401,E501
+
+class AwsExternalSubnetConfig(object):
+
+    """The external subnet configuration for the AWS cloud.
+
+    :param aws_subnet_config: (:attr:`aws_subnet_config`) 
+    :type aws_subnet_config: required
+    :param cluster_reference: (:attr:`cluster_reference`) Cluster
+    :type cluster_reference: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfnetworking.v4.config.VpcApiResponsedata',
+        'aws_subnet_config': 'networking.v4.config.AwsSubnetConfig',
+        'cluster_reference': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'metadata': 'metadata',
-        'data': 'data',
+        'aws_subnet_config': 'awsSubnetConfig',
+        'cluster_reference': 'clusterReference',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        self.__metadata = None
-        self.__data = None
+    def __init__(self, aws_subnet_config=None, cluster_reference=None, *args, **kwargs):  # noqa: E501
+        self.__aws_subnet_config = None
+        self.__cluster_reference = None
         self.discriminator = None
-        if metadata is not None:
-            self.__metadata = metadata
-        if data is not None:
-            self.__data = data
+        self.__aws_subnet_config = aws_subnet_config
+        if cluster_reference is not None:
+            self.__cluster_reference = cluster_reference
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.VpcApiResponse'
+        return 'networking.v4.config.AwsExternalSubnetConfig'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.VpcApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def metadata(self):
+    def aws_subnet_config(self):
         """
         
 
         :type:
-            :class:`~ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata`
+            :class:`~ntnx_networking_py_client.models.networking.v4.config.AwsSubnetConfig`
         """  # noqa: E501
-        return self.__metadata
+        return self.__aws_subnet_config
 
-    @metadata.setter
-    def metadata(self, metadata):
+    @aws_subnet_config.setter
+    def aws_subnet_config(self, aws_subnet_config):
+        if aws_subnet_config is None:
+            raise ValueError("Invalid value for `aws_subnet_config`, must not be `None`")  # noqa: E501
 
-        self.__metadata = metadata
+        self.__aws_subnet_config = aws_subnet_config
 
     @property
-    def data(self):
+    def cluster_reference(self):
         """
-        
+        Cluster
 
         :type:
-                :class:`~ntnx_networking_py_client.models.networking.v4.config.Vpc` | 
-                :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse`
-                    """  # noqa: E501
-        return self.__data
 
-    @data.setter
-    def data(self, data):
+                :class:`~str`
+        """  # noqa: E501
+        return self.__cluster_reference
+
+    @cluster_reference.setter
+    def cluster_reference(self, cluster_reference):
+        if cluster_reference is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', cluster_reference):  # noqa: E501
+            raise ValueError(r"Invalid value for `cluster_reference`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
 
-        self.__data = data
+        self.__cluster_reference = cluster_reference
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -171,39 +173,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
-            if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(VpcApiResponse, dict):
+        if issubclass(AwsExternalSubnetConfig, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +220,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, VpcApiResponse):
+        if not isinstance(other, AwsExternalSubnetConfig):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/VpcDhcpOptions.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/stats/Layer2StretchStats.py`

 * *Files 25% similar despite different names*

```diff
@@ -3,180 +3,181 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-from ntnx_networking_py_client.models.common.v1.config.IPAddress import IPAddress  # noqa: F401,E501
-
-class VpcDhcpOptions(object):
-
-    """List of DHCP options to be configured.
-
-    :param domain_name_servers: (:attr:`domain_name_servers`) List of Domain Name Server addresses (option 6).
-    :type domain_name_servers: 
+from pathlib import Path
+from ntnx_networking_py_client.models.common.v1.stats.DownSamplingOperator import DownSamplingOperator  # noqa: F401,E501
+from ntnx_networking_py_client.models.networking.v4.stats.StatsQueryResponseBase import StatsQueryResponseBase  # noqa: F401,E501
+
+class Layer2StretchStats(StatsQueryResponseBase):
+
+    """Layer2 stretch statistics description
+
+    :param throughput_rx_kbps: (:attr:`throughput_rx_kbps`) VPN connection string array of ingress kilobits per second values
+    :type throughput_rx_kbps: 
+    :param throughput_tx_kbps: (:attr:`throughput_tx_kbps`) VPN connection string array of egress kilobits per second values
+    :type throughput_tx_kbps: 
+    :param rtt: (:attr:`rtt`) Layer2Stretch string array of round-trip-time.
+    :type rtt: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'domain_name_servers': 'list[common.v1.config.IPAddress]',
+        'throughput_rx_kbps': 'list[str]',
+        'throughput_tx_kbps': 'list[str]',
+        'rtt': 'list[str]',
+        'entity_uuid': 'str',
+        'stat_type': 'common.v1.stats.DownSamplingOperator',
+        'ext_id': 'str',
+        'links': 'list[common.v1.response.ApiLink]',
+        'tenant_id': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'domain_name_servers': 'domainNameServers',
+        'throughput_rx_kbps': 'throughputRxKbps',
+        'throughput_tx_kbps': 'throughputTxKbps',
+        'rtt': 'rtt',
+        'entity_uuid': 'entityUuid',
+        'stat_type': 'statType',
+        'ext_id': 'extId',
+        'links': 'links',
+        'tenant_id': 'tenantId',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, domain_name_servers=None, *args, **kwargs):  # noqa: E501
-        self.__domain_name_servers = None
+    def __init__(self, throughput_rx_kbps=None, throughput_tx_kbps=None, rtt=None, entity_uuid=None, stat_type=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
+        StatsQueryResponseBase.__init__(self, entity_uuid, stat_type, ext_id, links, tenant_id, *args, **kwargs)
+        self.__throughput_rx_kbps = None
+        self.__throughput_tx_kbps = None
+        self.__rtt = None
         self.discriminator = None
-        if domain_name_servers is not None:
-            self.__domain_name_servers = domain_name_servers
-        # populate hidden vars if not empty
-        self._populate_hidden_vars(kwargs)
+        if throughput_rx_kbps is not None:
+            self.__throughput_rx_kbps = throughput_rx_kbps
+        if throughput_tx_kbps is not None:
+            self.__throughput_tx_kbps = throughput_tx_kbps
+        if rtt is not None:
+            self.__rtt = rtt
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.VpcDhcpOptions'
-
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.VpcDhcpOptions'
-
-    def _populate_hidden_vars(self, kwargs):
-        if "_reserved" in kwargs and kwargs["_reserved"] is not None:
-            self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
-            self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
-        else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
-        if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
-            self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
-            self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
-        else :
-            self.__dollar_unknown_fields = {}
-        if "_object_type" in kwargs and kwargs["_object_type"] is not None:
-            self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
-            self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
-        else:
-            self.__dollar_object_type = self._initialize_object_type()
+        return 'networking.v4.stats.Layer2StretchStats'
 
-    def get_object_type(self):
-        return self.__dollar_object_type
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
-    def get_reserved(self):
-        return self.__dollar_reserved
-
-    def get_unknown_fields(self):
-        return self.__dollar_unknown_fields
 
     @property
-    def domain_name_servers(self):
+    def throughput_rx_kbps(self):
         """
-        List of Domain Name Server addresses (option 6).
+        VPN connection string array of ingress kilobits per second values
 
         :type:
-             list[ :class:`~ntnx_networking_py_client.models.common.v1.config.IPAddress` ]
+            list[ :class:`~str` ]
         """  # noqa: E501
-        return self.__domain_name_servers
+        return self.__throughput_rx_kbps
 
-    @domain_name_servers.setter
-    def domain_name_servers(self, domain_name_servers):
+    @throughput_rx_kbps.setter
+    def throughput_rx_kbps(self, throughput_rx_kbps):
 
-        self.__domain_name_servers = domain_name_servers
+        self.__throughput_rx_kbps = throughput_rx_kbps
 
     @property
-    def _reserved(self):
+    def throughput_tx_kbps(self):
         """
-        
+        VPN connection string array of egress kilobits per second values
 
         :type:
-            dict(str, :class:`~object`)
+            list[ :class:`~str` ]
         """  # noqa: E501
-        return self.__dollar_reserved
-
-    @property
-    def _object_type(self):
-        """
-        
+        return self.__throughput_tx_kbps
 
-        :type:
+    @throughput_tx_kbps.setter
+    def throughput_tx_kbps(self, throughput_tx_kbps):
 
-                :class:`~str`
-        """  # noqa: E501
-        return self.__dollar_object_type
+        self.__throughput_tx_kbps = throughput_tx_kbps
 
     @property
-    def _unknown_fields(self):
+    def rtt(self):
         """
-        
+        Layer2Stretch string array of round-trip-time.
 
         :type:
-            dict(str, :class:`~object`)
+            list[ :class:`~str` ]
         """  # noqa: E501
-        return self.__dollar_unknown_fields
+        return self.__rtt
+
+    @rtt.setter
+    def rtt(self, rtt):
+
+        self.__rtt = rtt
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(VpcDhcpOptions, dict):
+        if issubclass(Layer2StretchStats, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -188,15 +189,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, VpcDhcpOptions):
+        if not isinstance(other, Layer2StretchStats):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/VpcListApiResponse.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/error/SchemaValidationErrorMessage.py`

 * *Files 22% similar despite different names*

```diff
@@ -3,143 +3,164 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_networking_py_client.models
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.VpcListApiResponsedata import VpcListApiResponsedata  # noqa: F401,E501
-from ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
-
-class VpcListApiResponse(object):
-
-    """REST response for all response codes in API path /networking/v4.0.b1/config/vpcs Get operation
-
-    :param metadata: (:attr:`metadata`) 
-    :type metadata: 
-    :param data: (:attr:`data`) 
-    :type data: 
+from pathlib import Path
+
+class SchemaValidationErrorMessage(object):
+
+    """This schema is generated from SchemaValidationErrorMessage.java
+
+    :param location: (:attr:`location`) The part of the request that failed validation. Validation can fail for path, query parameters, and request body.
+    :type location: 
+    :param message: (:attr:`message`) The detailed message for the validation error.
+    :type message: 
+    :param attribute_path: (:attr:`attribute_path`) The path of the attribute that failed validation in the schema.
+    :type attribute_path: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfnetworking.v4.config.VpcListApiResponsedata',
+        'location': 'str',
+        'message': 'str',
+        'attribute_path': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'metadata': 'metadata',
-        'data': 'data',
+        'location': 'location',
+        'message': 'message',
+        'attribute_path': 'attributePath',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        self.__metadata = None
-        self.__data = None
+    def __init__(self, location=None, message=None, attribute_path=None, *args, **kwargs):  # noqa: E501
+        self.__location = None
+        self.__message = None
+        self.__attribute_path = None
         self.discriminator = None
-        if metadata is not None:
-            self.__metadata = metadata
-        if data is not None:
-            self.__data = data
+        if location is not None:
+            self.__location = location
+        if message is not None:
+            self.__message = message
+        if attribute_path is not None:
+            self.__attribute_path = attribute_path
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.VpcListApiResponse'
+        return 'networking.v4.error.SchemaValidationErrorMessage'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.VpcListApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def metadata(self):
+    def location(self):
         """
-        
+        The part of the request that failed validation. Validation can fail for path, query parameters, and request body.
 
         :type:
-            :class:`~ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata`
+
+                :class:`~str`
         """  # noqa: E501
-        return self.__metadata
+        return self.__location
 
-    @metadata.setter
-    def metadata(self, metadata):
+    @location.setter
+    def location(self, location):
 
-        self.__metadata = metadata
+        self.__location = location
 
     @property
-    def data(self):
+    def message(self):
         """
-        
+        The detailed message for the validation error.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__message
+
+    @message.setter
+    def message(self, message):
+
+        self.__message = message
+
+    @property
+    def attribute_path(self):
+        """
+        The path of the attribute that failed validation in the schema.
 
         :type:
-                :class:`~ntnx_networking_py_client.models.networking.v4.config.Vpc` | 
-                :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse` | 
-                :class:`~ntnx_networking_py_client.models.networking.v4.config.VpcProjection`
-                    """  # noqa: E501
-        return self.__data
 
-    @data.setter
-    def data(self, data):
+                :class:`~str`
+        """  # noqa: E501
+        return self.__attribute_path
+
+    @attribute_path.setter
+    def attribute_path(self, attribute_path):
 
-        self.__data = data
+        self.__attribute_path = attribute_path
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -172,39 +193,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
-            if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(VpcListApiResponse, dict):
+        if issubclass(SchemaValidationErrorMessage, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -216,15 +240,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, VpcListApiResponse):
+        if not isinstance(other, SchemaValidationErrorMessage):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/VpcProjection.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/VpcProjection.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,56 +3,60 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.IPAddress import IPAddress  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.ExternalSubnet import ExternalSubnet  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.IPSubnet import IPSubnet  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.Vpc import Vpc  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.VpcDhcpOptions import VpcDhcpOptions  # noqa: F401,E501
+from ntnx_networking_py_client.models.networking.v4.config.VpcType import VpcType  # noqa: F401,E501
 
 class VpcProjection(Vpc):
 
     """
 
     :param name: (:attr:`name`) Name of the VPC.
     :type name: required
     :param description: (:attr:`description`) Description of the VPC.
     :type description: 
+    :param vpc_type: (:attr:`vpc_type`) 
+    :type vpc_type: 
     :param common_dhcp_options: (:attr:`common_dhcp_options`) 
     :type common_dhcp_options: 
     :param snat_ips: (:attr:`snat_ips`) List of IP Addresses used for SNAT.
     :type snat_ips: 
     :param external_subnets: (:attr:`external_subnets`) List of external subnets that the VPC is attached to.
     :type external_subnets: 
     :param external_routing_domain_reference: (:attr:`external_routing_domain_reference`) External routing domain associated with this route table
     :type external_routing_domain_reference: 
     :param externally_routable_prefixes: (:attr:`externally_routable_prefixes`) CIDR blocks from the VPC which can talk externally without performing NAT. This is applicable when connecting to external subnets which have disabled NAT.
     :type externally_routable_prefixes: 
     :param metadata: (:attr:`metadata`) 
     :type metadata: 
     :param ext_id: (:attr:`ext_id`) A globally unique identifier of an instance that is suitable for external consumption. 
     :type ext_id: 
-    :param links: (:attr:`links`) A HATEOAS style link for the response.  Each link contains a user friendly name identifying the link and an address for retrieving the particular resource. 
+    :param links: (:attr:`links`) A HATEOAS style link for the response.  Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource. 
     :type links: 
-    :param tenant_id: (:attr:`tenant_id`) A globally unique identifier that represents the tenant that owns this entity.  It is automatically assigned by the system and is immutable from an API consumer perspective (some use cases may cause this Id to change - for instance a use case may require the transfer of ownership of the entity, but these cases are handled automatically on the server). 
+    :param tenant_id: (:attr:`tenant_id`) A globally unique identifier that represents the tenant that owns this entity. The system automatically assigns it, and it and is immutable from an API consumer perspective (some use cases may cause this Id to change - For instance, a use case may require the transfer of ownership of the entity, but these cases are handled automatically on the server). 
     :type tenant_id: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
@@ -60,14 +64,15 @@
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'name': 'str',
         'description': 'str',
+        'vpc_type': 'networking.v4.config.VpcType',
         'common_dhcp_options': 'networking.v4.config.VpcDhcpOptions',
         'snat_ips': 'list[common.v1.config.IPAddress]',
         'external_subnets': 'list[networking.v4.config.ExternalSubnet]',
         'external_routing_domain_reference': 'str',
         'externally_routable_prefixes': 'list[networking.v4.config.IPSubnet]',
         'metadata': 'common.v1.config.Metadata',
         'ext_id': 'str',
@@ -77,14 +82,15 @@
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'name': 'name',
         'description': 'description',
+        'vpc_type': 'vpcType',
         'common_dhcp_options': 'commonDhcpOptions',
         'snat_ips': 'snatIps',
         'external_subnets': 'externalSubnets',
         'external_routing_domain_reference': 'externalRoutingDomainReference',
         'externally_routable_prefixes': 'externallyRoutablePrefixes',
         'metadata': 'metadata',
         'ext_id': 'extId',
@@ -93,47 +99,52 @@
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, name=None, description=None, common_dhcp_options=None, snat_ips=None, external_subnets=None, external_routing_domain_reference=None, externally_routable_prefixes=None, metadata=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
-        Vpc.__init__(self, name, description, common_dhcp_options, snat_ips, external_subnets, external_routing_domain_reference, externally_routable_prefixes, metadata, ext_id, links, tenant_id, *args, **kwargs)
+    def __init__(self, name=None, description=None, vpc_type=None, common_dhcp_options=None, snat_ips=None, external_subnets=None, external_routing_domain_reference=None, externally_routable_prefixes=None, metadata=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
+        Vpc.__init__(self, name, description, vpc_type, common_dhcp_options, snat_ips, external_subnets, external_routing_domain_reference, externally_routable_prefixes, metadata, ext_id, links, tenant_id, *args, **kwargs)
         self.discriminator = None
 
     def _initialize_object_type(self):
         return 'networking.v4.config.VpcProjection'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.VpcProjection'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/VpcVirtualSwitchMapping.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/VpcVirtualSwitchMapping.py`

 * *Files 9% similar despite different names*

```diff
@@ -3,36 +3,37 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.Metadata import Metadata  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.NetworkingBaseModel import NetworkingBaseModel  # noqa: F401,E501
 
 class VpcVirtualSwitchMapping(NetworkingBaseModel):
 
     """
 
     :param cluster_uuid: (:attr:`cluster_uuid`) UUID of the cluster.
-    :type cluster_uuid: 
+    :type cluster_uuid: required
     :param virtual_switch_uuid: (:attr:`virtual_switch_uuid`) UUID of the virtual switch.
-    :type virtual_switch_uuid: 
+    :type virtual_switch_uuid: required
     :param is_all_traffic_permitted: (:attr:`is_all_traffic_permitted`) Whether to permit all traffic through virtual switch or only the ICMP and statistics collection requests.
     :type is_all_traffic_permitted: 
 
     """
     """
     IGNORE:
     Attributes:
@@ -72,26 +73,24 @@
 
     def __init__(self, cluster_uuid=None, virtual_switch_uuid=None, is_all_traffic_permitted=None, metadata=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
         NetworkingBaseModel.__init__(self, metadata, ext_id, links, tenant_id, *args, **kwargs)
         self.__cluster_uuid = None
         self.__virtual_switch_uuid = None
         self.__is_all_traffic_permitted = None
         self.discriminator = None
-        if cluster_uuid is not None:
-            self.__cluster_uuid = cluster_uuid
-        if virtual_switch_uuid is not None:
-            self.__virtual_switch_uuid = virtual_switch_uuid
+        self.__cluster_uuid = cluster_uuid
+        self.__virtual_switch_uuid = virtual_switch_uuid
         if is_all_traffic_permitted is not None:
             self.__is_all_traffic_permitted = is_all_traffic_permitted
 
     def _initialize_object_type(self):
         return 'networking.v4.config.VpcVirtualSwitchMapping'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.VpcVirtualSwitchMapping'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     @property
     def cluster_uuid(self):
         """
         UUID of the cluster.
 
@@ -99,14 +98,16 @@
 
                 :class:`~str`
         """  # noqa: E501
         return self.__cluster_uuid
 
     @cluster_uuid.setter
     def cluster_uuid(self, cluster_uuid):
+        if cluster_uuid is None:
+            raise ValueError("Invalid value for `cluster_uuid`, must not be `None`")  # noqa: E501
         if cluster_uuid is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', cluster_uuid):  # noqa: E501
             raise ValueError(r"Invalid value for `cluster_uuid`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
 
         self.__cluster_uuid = cluster_uuid
 
     @property
     def virtual_switch_uuid(self):
@@ -117,14 +118,16 @@
 
                 :class:`~str`
         """  # noqa: E501
         return self.__virtual_switch_uuid
 
     @virtual_switch_uuid.setter
     def virtual_switch_uuid(self, virtual_switch_uuid):
+        if virtual_switch_uuid is None:
+            raise ValueError("Invalid value for `virtual_switch_uuid`, must not be `None`")  # noqa: E501
         if virtual_switch_uuid is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', virtual_switch_uuid):  # noqa: E501
             raise ValueError(r"Invalid value for `virtual_switch_uuid`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
 
         self.__virtual_switch_uuid = virtual_switch_uuid
 
     @property
     def is_all_traffic_permitted(self):
@@ -146,28 +149,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/VpcVirtualSwitchMappingsApiResponse.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/RerouteParam.py`

 * *Files 25% similar despite different names*

```diff
@@ -3,142 +3,185 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_networking_py_client.models
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.VpcVirtualSwitchMappingsApiResponsedata import VpcVirtualSwitchMappingsApiResponsedata  # noqa: F401,E501
-from ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
-
-class VpcVirtualSwitchMappingsApiResponse(object):
-
-    """REST response for all response codes in API path /networking/v4.0.b1/config/vpc-virtual-switch-mappings Get operation
-
-    :param metadata: (:attr:`metadata`) 
-    :type metadata: 
-    :param data: (:attr:`data`) 
-    :type data: 
+from pathlib import Path
+from ntnx_networking_py_client.models.common.v1.config.IPAddress import IPAddress  # noqa: F401,E501
+from ntnx_networking_py_client.models.networking.v4.config.RerouteFallbackAction import RerouteFallbackAction  # noqa: F401,E501
+
+class RerouteParam(object):
+
+    """Parameters for the reroute action which includes the reroute service IP and the fallback action when the service IP is down.
+
+    :param service_ip: (:attr:`service_ip`) 
+    :type service_ip: 
+    :param reroute_fallback_action: (:attr:`reroute_fallback_action`) 
+    :type reroute_fallback_action: 
+    :param ingress_service_ip: (:attr:`ingress_service_ip`) 
+    :type ingress_service_ip: 
+    :param egress_service_ip: (:attr:`egress_service_ip`) 
+    :type egress_service_ip: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfnetworking.v4.config.VpcVirtualSwitchMappingsApiResponsedata',
+        'service_ip': 'common.v1.config.IPAddress',
+        'reroute_fallback_action': 'networking.v4.config.RerouteFallbackAction',
+        'ingress_service_ip': 'common.v1.config.IPAddress',
+        'egress_service_ip': 'common.v1.config.IPAddress',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'metadata': 'metadata',
-        'data': 'data',
+        'service_ip': 'serviceIp',
+        'reroute_fallback_action': 'rerouteFallbackAction',
+        'ingress_service_ip': 'ingressServiceIp',
+        'egress_service_ip': 'egressServiceIp',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        self.__metadata = None
-        self.__data = None
+    def __init__(self, service_ip=None, reroute_fallback_action=None, ingress_service_ip=None, egress_service_ip=None, *args, **kwargs):  # noqa: E501
+        self.__service_ip = None
+        self.__reroute_fallback_action = None
+        self.__ingress_service_ip = None
+        self.__egress_service_ip = None
         self.discriminator = None
-        if metadata is not None:
-            self.__metadata = metadata
-        if data is not None:
-            self.__data = data
+        if service_ip is not None:
+            self.__service_ip = service_ip
+        if reroute_fallback_action is not None:
+            self.__reroute_fallback_action = reroute_fallback_action
+        if ingress_service_ip is not None:
+            self.__ingress_service_ip = ingress_service_ip
+        if egress_service_ip is not None:
+            self.__egress_service_ip = egress_service_ip
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.VpcVirtualSwitchMappingsApiResponse'
+        return 'networking.v4.config.RerouteParam'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.VpcVirtualSwitchMappingsApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def metadata(self):
+    def service_ip(self):
         """
         
 
         :type:
-            :class:`~ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata`
+            :class:`~ntnx_networking_py_client.models.common.v1.config.IPAddress`
         """  # noqa: E501
-        return self.__metadata
+        return self.__service_ip
 
-    @metadata.setter
-    def metadata(self, metadata):
+    @service_ip.setter
+    def service_ip(self, service_ip):
 
-        self.__metadata = metadata
+        self.__service_ip = service_ip
 
     @property
-    def data(self):
+    def reroute_fallback_action(self):
         """
         
 
         :type:
-                :class:`~ntnx_networking_py_client.models.networking.v4.config.VpcVirtualSwitchMapping` | 
-                :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse`
-                    """  # noqa: E501
-        return self.__data
+            :class:`~ntnx_networking_py_client.models.networking.v4.config.RerouteFallbackAction`
+        """  # noqa: E501
+        return self.__reroute_fallback_action
 
-    @data.setter
-    def data(self, data):
+    @reroute_fallback_action.setter
+    def reroute_fallback_action(self, reroute_fallback_action):
 
-        self.__data = data
+        self.__reroute_fallback_action = reroute_fallback_action
+
+    @property
+    def ingress_service_ip(self):
+        """
+        
+
+        :type:
+            :class:`~ntnx_networking_py_client.models.common.v1.config.IPAddress`
+        """  # noqa: E501
+        return self.__ingress_service_ip
+
+    @ingress_service_ip.setter
+    def ingress_service_ip(self, ingress_service_ip):
+
+        self.__ingress_service_ip = ingress_service_ip
+
+    @property
+    def egress_service_ip(self):
+        """
+        
+
+        :type:
+            :class:`~ntnx_networking_py_client.models.common.v1.config.IPAddress`
+        """  # noqa: E501
+        return self.__egress_service_ip
+
+    @egress_service_ip.setter
+    def egress_service_ip(self, egress_service_ip):
+
+        self.__egress_service_ip = egress_service_ip
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -171,39 +214,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
-            if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(VpcVirtualSwitchMappingsApiResponse, dict):
+        if issubclass(RerouteParam, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +261,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, VpcVirtualSwitchMappingsApiResponse):
+        if not isinstance(other, RerouteParam):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/VpnAppliance.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/VpnAppliance.py`

 * *Files 11% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.Metadata import Metadata  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.NetworkingBaseModel import NetworkingBaseModel  # noqa: F401,E501
 
 class VpnAppliance(NetworkingBaseModel):
 
     """Third-party VPN appliance.
 
@@ -75,16 +76,16 @@
             self.__name = name
         if version is not None:
             self.__version = version
 
     def _initialize_object_type(self):
         return 'networking.v4.config.VpnAppliance'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.VpnAppliance'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     @property
     def name(self):
         """
         VPN appliance name.
 
@@ -121,28 +122,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/VpnConnection.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/VpnConnection.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,40 +3,41 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.Metadata import Metadata  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.DpdConfig import DpdConfig  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.GatewayRole import GatewayRole  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.IPSubnet import IPSubnet  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.IpsecConfig import IpsecConfig  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.NetworkingBaseModel import NetworkingBaseModel  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.QosConfig import QosConfig  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.config.Status import Status  # noqa: F401,E501
 
 class VpnConnection(NetworkingBaseModel):
 
     """VPN connection
 
     :param name: (:attr:`name`) VPN connection name
-    :type name: 
+    :type name: required
     :param description: (:attr:`description`) VPN connection description
     :type description: 
     :param local_gateway_reference: (:attr:`local_gateway_reference`) The local VPN gateway reference
     :type local_gateway_reference: required
     :param remote_gateway_reference: (:attr:`remote_gateway_reference`) The remote VPN gateway reference
     :type remote_gateway_reference: required
     :param ipsec_config: (:attr:`ipsec_config`) 
@@ -128,16 +129,15 @@
         self.__local_gateway_role = None
         self.__dynamic_route_priority = None
         self.__advertised_prefixes = None
         self.__learned_prefixes = None
         self.__ipsec_tunnel_status = None
         self.__ebgp_status = None
         self.discriminator = None
-        if name is not None:
-            self.__name = name
+        self.__name = name
         if description is not None:
             self.__description = description
         self.__local_gateway_reference = local_gateway_reference
         self.__remote_gateway_reference = remote_gateway_reference
         self.__ipsec_config = ipsec_config
         if dpd_config is not None:
             self.__dpd_config = dpd_config
@@ -154,16 +154,16 @@
             self.__ipsec_tunnel_status = ipsec_tunnel_status
         if ebgp_status is not None:
             self.__ebgp_status = ebgp_status
 
     def _initialize_object_type(self):
         return 'networking.v4.config.VpnConnection'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.VpnConnection'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     @property
     def name(self):
         """
         VPN connection name
 
@@ -171,14 +171,16 @@
 
                 :class:`~str`
         """  # noqa: E501
         return self.__name
 
     @name.setter
     def name(self, name):
+        if name is None:
+            raise ValueError("Invalid value for `name`, must not be `None`")  # noqa: E501
         if name is not None and len(name) > 128:
             raise ValueError("Invalid value for `name`, length must be less than or equal to `128`")  # noqa: E501
 
         self.__name = name
 
     @property
     def description(self):
@@ -386,28 +388,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/VpnConnectionApiResponse.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/GatewayInterface.py`

 * *Files 27% similar despite different names*

```diff
@@ -3,142 +3,213 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_networking_py_client.models
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.VpnConnectionApiResponsedata import VpnConnectionApiResponsedata  # noqa: F401,E501
-from ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
-
-class VpnConnectionApiResponse(object):
-
-    """REST response for all response codes in API path /networking/v4.0.b1/config/vpn-connections/{extId} Get operation
-
-    :param metadata: (:attr:`metadata`) 
-    :type metadata: 
-    :param data: (:attr:`data`) 
-    :type data: 
+from pathlib import Path
+from ntnx_networking_py_client.models.common.v1.config.IPAddress import IPAddress  # noqa: F401,E501
+
+class GatewayInterface(object):
+
+    """Network interface used to deliver network services. If the client  supplies a VPC reference, but does not specify a VPC subnet, the gateway will be deployed on an auto-configured dedicated subnet  within the VPC. If the client specifies a VPC subnet, the gateway  will be deployed on that subnet. If the gateway is deployed on a VLAN subnet, with or without IPAM, then statically-allocated IP addresses on that subnet must be provided for each interface. 
+
+    :param subnet_reference: (:attr:`subnet_reference`) The VLAN subnet to deploy this network gateway VM on
+    :type subnet_reference: 
+    :param ip_address: (:attr:`ip_address`) 
+    :type ip_address: 
+    :param default_gateway_address: (:attr:`default_gateway_address`) 
+    :type default_gateway_address: 
+    :param mac_address: (:attr:`mac_address`) MAC address of this gateway interface
+    :type mac_address: 
+    :param mtu: (:attr:`mtu`) MTU of this gateway interface
+    :type mtu: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfnetworking.v4.config.VpnConnectionApiResponsedata',
+        'subnet_reference': 'str',
+        'ip_address': 'common.v1.config.IPAddress',
+        'default_gateway_address': 'common.v1.config.IPAddress',
+        'mac_address': 'str',
+        'mtu': 'int',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'metadata': 'metadata',
-        'data': 'data',
+        'subnet_reference': 'subnetReference',
+        'ip_address': 'ipAddress',
+        'default_gateway_address': 'defaultGatewayAddress',
+        'mac_address': 'macAddress',
+        'mtu': 'mtu',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        self.__metadata = None
-        self.__data = None
+    def __init__(self, subnet_reference=None, ip_address=None, default_gateway_address=None, mac_address=None, mtu=None, *args, **kwargs):  # noqa: E501
+        self.__subnet_reference = None
+        self.__ip_address = None
+        self.__default_gateway_address = None
+        self.__mac_address = None
+        self.__mtu = None
         self.discriminator = None
-        if metadata is not None:
-            self.__metadata = metadata
-        if data is not None:
-            self.__data = data
+        if subnet_reference is not None:
+            self.__subnet_reference = subnet_reference
+        if ip_address is not None:
+            self.__ip_address = ip_address
+        if default_gateway_address is not None:
+            self.__default_gateway_address = default_gateway_address
+        if mac_address is not None:
+            self.__mac_address = mac_address
+        if mtu is not None:
+            self.__mtu = mtu
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.VpnConnectionApiResponse'
+        return 'networking.v4.config.GatewayInterface'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.VpnConnectionApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def metadata(self):
+    def subnet_reference(self):
+        """
+        The VLAN subnet to deploy this network gateway VM on
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__subnet_reference
+
+    @subnet_reference.setter
+    def subnet_reference(self, subnet_reference):
+        if subnet_reference is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', subnet_reference):  # noqa: E501
+            raise ValueError(r"Invalid value for `subnet_reference`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
+
+        self.__subnet_reference = subnet_reference
+
+    @property
+    def ip_address(self):
         """
         
 
         :type:
-            :class:`~ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata`
+            :class:`~ntnx_networking_py_client.models.common.v1.config.IPAddress`
         """  # noqa: E501
-        return self.__metadata
+        return self.__ip_address
 
-    @metadata.setter
-    def metadata(self, metadata):
+    @ip_address.setter
+    def ip_address(self, ip_address):
 
-        self.__metadata = metadata
+        self.__ip_address = ip_address
 
     @property
-    def data(self):
+    def default_gateway_address(self):
         """
         
 
         :type:
-                :class:`~ntnx_networking_py_client.models.networking.v4.config.VpnConnection` | 
-                :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse`
-                    """  # noqa: E501
-        return self.__data
+            :class:`~ntnx_networking_py_client.models.common.v1.config.IPAddress`
+        """  # noqa: E501
+        return self.__default_gateway_address
 
-    @data.setter
-    def data(self, data):
+    @default_gateway_address.setter
+    def default_gateway_address(self, default_gateway_address):
 
-        self.__data = data
+        self.__default_gateway_address = default_gateway_address
+
+    @property
+    def mac_address(self):
+        """
+        MAC address of this gateway interface
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__mac_address
+
+    @mac_address.setter
+    def mac_address(self, mac_address):
+        if mac_address is not None and not re.search('^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$', mac_address):  # noqa: E501
+            raise ValueError(r"Invalid value for `mac_address`, must be a follow pattern or equal to `/^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$/`")  # noqa: E501
+
+        self.__mac_address = mac_address
+
+    @property
+    def mtu(self):
+        """
+        MTU of this gateway interface
+
+        :type:
+
+                :class:`~int`
+        """  # noqa: E501
+        return self.__mtu
+
+    @mtu.setter
+    def mtu(self, mtu):
+
+        self.__mtu = mtu
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -171,39 +242,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
-            if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(VpnConnectionApiResponse, dict):
+        if issubclass(GatewayInterface, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +289,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, VpnConnectionApiResponse):
+        if not isinstance(other, GatewayInterface):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/config/VpnConnectionListApiResponse.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/error/SchemaValidationError.py`

 * *Files 27% similar despite different names*

```diff
@@ -3,142 +3,210 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_networking_py_client.models
-from ntnx_networking_py_client.models.OneOfnetworking.v4.config.VpnConnectionListApiResponsedata import VpnConnectionListApiResponsedata  # noqa: F401,E501
-from ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata import ApiResponseMetadata  # noqa: F401,E501
-
-class VpnConnectionListApiResponse(object):
-
-    """REST response for all response codes in API path /networking/v4.0.b1/config/vpn-connections Get operation
-
-    :param metadata: (:attr:`metadata`) 
-    :type metadata: 
-    :param data: (:attr:`data`) 
-    :type data: 
+from pathlib import Path
+from ntnx_networking_py_client.models.networking.v4.error.SchemaValidationErrorMessage import SchemaValidationErrorMessage  # noqa: F401,E501
+
+class SchemaValidationError(object):
+
+    """This schema is generated from SchemaValidationError.java
+
+    :param timestamp: (:attr:`timestamp`) Timestamp of the response.
+    :type timestamp: 
+    :param status_code: (:attr:`status_code`) The HTTP status code of the response.
+    :type status_code: 
+    :param error: (:attr:`error`) The generic error message for the response.
+    :type error: 
+    :param path: (:attr:`path`) API path on which the request was made.
+    :type path: 
+    :param validation_error_messages: (:attr:`validation_error_messages`) List of validation error messages
+    :type validation_error_messages: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'metadata': 'common.v1.response.ApiResponseMetadata',
-        'data': 'OneOfnetworking.v4.config.VpnConnectionListApiResponsedata',
+        'timestamp': 'str',
+        'status_code': 'int',
+        'error': 'str',
+        'path': 'str',
+        'validation_error_messages': 'list[networking.v4.error.SchemaValidationErrorMessage]',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'metadata': 'metadata',
-        'data': 'data',
+        'timestamp': 'timestamp',
+        'status_code': 'statusCode',
+        'error': 'error',
+        'path': 'path',
+        'validation_error_messages': 'validationErrorMessages',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, metadata=None, data=None, *args, **kwargs):  # noqa: E501
-        self.__metadata = None
-        self.__data = None
+    def __init__(self, timestamp=None, status_code=None, error=None, path=None, validation_error_messages=None, *args, **kwargs):  # noqa: E501
+        self.__timestamp = None
+        self.__status_code = None
+        self.__error = None
+        self.__path = None
+        self.__validation_error_messages = None
         self.discriminator = None
-        if metadata is not None:
-            self.__metadata = metadata
-        if data is not None:
-            self.__data = data
+        if timestamp is not None:
+            self.__timestamp = timestamp
+        if status_code is not None:
+            self.__status_code = status_code
+        if error is not None:
+            self.__error = error
+        if path is not None:
+            self.__path = path
+        if validation_error_messages is not None:
+            self.__validation_error_messages = validation_error_messages
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
-        return 'networking.v4.config.VpnConnectionListApiResponse'
+        return 'networking.v4.error.SchemaValidationError'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.config.VpnConnectionListApiResponse'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
     def get_reserved(self):
         return self.__dollar_reserved
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
-    def metadata(self):
+    def timestamp(self):
         """
-        
+        Timestamp of the response.
 
         :type:
-            :class:`~ntnx_networking_py_client.models.common.v1.response.ApiResponseMetadata`
+
+                :class:`~str`
         """  # noqa: E501
-        return self.__metadata
+        return self.__timestamp
 
-    @metadata.setter
-    def metadata(self, metadata):
+    @timestamp.setter
+    def timestamp(self, timestamp):
 
-        self.__metadata = metadata
+        self.__timestamp = timestamp
 
     @property
-    def data(self):
+    def status_code(self):
         """
-        
+        The HTTP status code of the response.
+
+        :type:
+
+                :class:`~int`
+        """  # noqa: E501
+        return self.__status_code
+
+    @status_code.setter
+    def status_code(self, status_code):
+
+        self.__status_code = status_code
+
+    @property
+    def error(self):
+        """
+        The generic error message for the response.
 
         :type:
-                :class:`~ntnx_networking_py_client.models.networking.v4.config.VpnConnection` | 
-                :class:`~ntnx_networking_py_client.models.networking.v4.error.ErrorResponse`
-                    """  # noqa: E501
-        return self.__data
 
-    @data.setter
-    def data(self, data):
+                :class:`~str`
+        """  # noqa: E501
+        return self.__error
 
-        self.__data = data
+    @error.setter
+    def error(self, error):
+
+        self.__error = error
+
+    @property
+    def path(self):
+        """
+        API path on which the request was made.
+
+        :type:
+
+                :class:`~str`
+        """  # noqa: E501
+        return self.__path
+
+    @path.setter
+    def path(self, path):
+
+        self.__path = path
+
+    @property
+    def validation_error_messages(self):
+        """
+        List of validation error messages
+
+        :type:
+             list[ :class:`~ntnx_networking_py_client.models.networking.v4.error.SchemaValidationErrorMessage` ]
+        """  # noqa: E501
+        return self.__validation_error_messages
+
+    @validation_error_messages.setter
+    def validation_error_messages(self, validation_error_messages):
+
+        self.__validation_error_messages = validation_error_messages
 
     @property
     def _reserved(self):
         """
         
 
         :type:
@@ -171,39 +239,42 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
-            if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(VpnConnectionListApiResponse, dict):
+        if issubclass(SchemaValidationError, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -215,15 +286,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, VpnConnectionListApiResponse):
+        if not isinstance(other, SchemaValidationError):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/error/AppMessage.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/error/AppMessage.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,42 +3,43 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.config.MessageSeverity import MessageSeverity  # noqa: F401,E501
 
 class AppMessage(object):
 
-    """This schema is generated from AppMessage.java
+    """Message with associated severity describing status of the current operation.
 
-    :param message: (:attr:`message`) 
+    :param message: (:attr:`message`) The message string.
     :type message: 
     :param severity: (:attr:`severity`) 
     :type severity: 
-    :param code: (:attr:`code`) 
+    :param code: (:attr:`code`) The code associated with this message.This string is typically prefixed by the namespace the endpoint belongs to. For example: VMM-40000
     :type code: 
-    :param locale: (:attr:`locale`) The locale for the message description. (**Default** 'en_US')
+    :param locale: (:attr:`locale`) Locale for this message. The default locale would be 'en-US'. (**Default** 'en_US')
     :type locale: 
-    :param error_group: (:attr:`error_group`) 
+    :param error_group: (:attr:`error_group`) The error group associated with this message of severity ERROR.
     :type error_group: 
-    :param arguments_map: (:attr:`arguments_map`) 
+    :param arguments_map: (:attr:`arguments_map`) The map of argument name to value.
     :type arguments_map: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
@@ -95,33 +96,33 @@
             self.__arguments_map = arguments_map
         # populate hidden vars if not empty
         self._populate_hidden_vars(kwargs)
 
     def _initialize_object_type(self):
         return 'networking.v4.error.AppMessage'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.error.AppMessage'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
     def _populate_hidden_vars(self, kwargs):
         if "_reserved" in kwargs and kwargs["_reserved"] is not None:
             self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
+        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
             self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
         else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
+            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
         if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
             self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
+        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
             self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
         else :
             self.__dollar_unknown_fields = {}
         if "_object_type" in kwargs and kwargs["_object_type"] is not None:
             self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
+        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
             self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
         else:
             self.__dollar_object_type = self._initialize_object_type()
 
     def get_object_type(self):
         return self.__dollar_object_type
 
@@ -130,15 +131,15 @@
 
     def get_unknown_fields(self):
         return self.__dollar_unknown_fields
 
     @property
     def message(self):
         """
-        
+        The message string.
 
         :type:
 
                 :class:`~str`
         """  # noqa: E501
         return self.__message
 
@@ -161,15 +162,15 @@
     def severity(self, severity):
 
         self.__severity = severity
 
     @property
     def code(self):
         """
-        
+        The code associated with this message.This string is typically prefixed by the namespace the endpoint belongs to. For example: VMM-40000
 
         :type:
 
                 :class:`~str`
         """  # noqa: E501
         return self.__code
 
@@ -177,15 +178,15 @@
     def code(self, code):
 
         self.__code = code
 
     @property
     def locale(self):
         """
-        The locale for the message description.
+        Locale for this message. The default locale would be 'en-US'.
 
         :type:
 
                 :class:`~str`
         """  # noqa: E501
         return self.__locale
 
@@ -193,15 +194,15 @@
     def locale(self, locale):
 
         self.__locale = locale
 
     @property
     def error_group(self):
         """
-        
+        The error group associated with this message of severity ERROR.
 
         :type:
 
                 :class:`~str`
         """  # noqa: E501
         return self.__error_group
 
@@ -209,15 +210,15 @@
     def error_group(self, error_group):
 
         self.__error_group = error_group
 
     @property
     def arguments_map(self):
         """
-        
+        The map of argument name to value.
 
         :type:
             dict(str, :class:`~str`)
         """  # noqa: E501
         return self.__arguments_map
 
     @arguments_map.setter
@@ -260,28 +261,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/error/ErrorResponse.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/config/VnicMigrationItemSpec.py`

 * *Files 25% similar despite different names*

```diff
@@ -3,184 +3,161 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
-import ntnx_networking_py_client.models
-from ntnx_networking_py_client.models.OneOfnetworking.v4.error.ErrorResponseerror import ErrorResponseerror  # noqa: F401,E501
+from pathlib import Path
+from ntnx_networking_py_client.models.common.v1.config.IPAddress import IPAddress  # noqa: F401,E501
+from ntnx_networking_py_client.models.common.v1.config.Metadata import Metadata  # noqa: F401,E501
+from ntnx_networking_py_client.models.networking.v4.config.NetworkingBaseModel import NetworkingBaseModel  # noqa: F401,E501
 
-class ErrorResponse(object):
+class VnicMigrationItemSpec(NetworkingBaseModel):
 
-    """This schema is auto-generated by the Open API Dev Platform as REST response for 4xx and 5xx error responses.
+    """
 
-    :param error: (:attr:`error`) 
-    :type error: 
+    :param network_uuid: (:attr:`network_uuid`) NIC network UUID for the destination subnet.
+    :type network_uuid: 
+    :param requested_ip_addresses: (:attr:`requested_ip_addresses`) 
+    :type requested_ip_addresses: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
-        'error': 'OneOfnetworking.v4.error.ErrorResponseerror',
+        'network_uuid': 'str',
+        'requested_ip_addresses': 'list[common.v1.config.IPAddress]',
+        'metadata': 'common.v1.config.Metadata',
+        'ext_id': 'str',
+        'links': 'list[common.v1.response.ApiLink]',
+        'tenant_id': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
-        'error': 'error',
+        'network_uuid': 'networkUuid',
+        'requested_ip_addresses': 'requestedIpAddresses',
+        'metadata': 'metadata',
+        'ext_id': 'extId',
+        'links': 'links',
+        'tenant_id': 'tenantId',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, error=None, *args, **kwargs):  # noqa: E501
-        self.__error = None
+    def __init__(self, network_uuid=None, requested_ip_addresses=None, metadata=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
+        NetworkingBaseModel.__init__(self, metadata, ext_id, links, tenant_id, *args, **kwargs)
+        self.__network_uuid = None
+        self.__requested_ip_addresses = None
         self.discriminator = None
-        if error is not None:
-            self.__error = error
-        # populate hidden vars if not empty
-        self._populate_hidden_vars(kwargs)
+        if network_uuid is not None:
+            self.__network_uuid = network_uuid
+        if requested_ip_addresses is not None:
+            self.__requested_ip_addresses = requested_ip_addresses
 
     def _initialize_object_type(self):
-        return 'networking.v4.error.ErrorResponse'
-
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.error.ErrorResponse'
-
-    def _populate_hidden_vars(self, kwargs):
-        if "_reserved" in kwargs and kwargs["_reserved"] is not None:
-            self.__dollar_reserved = kwargs["_reserved"]
-        elif "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
-            self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
-        else :
-            self.__dollar_reserved = {"$fqObjectType": self._initialize_fq_object_type()}
-        if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
-            self.__dollar_unknown_fields = kwargs["_unknown_fields"]
-        elif "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
-            self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
-        else :
-            self.__dollar_unknown_fields = {}
-        if "_object_type" in kwargs and kwargs["_object_type"] is not None:
-            self.__dollar_object_type = kwargs["_object_type"]
-        elif "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
-            self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
-        else:
-            self.__dollar_object_type = self._initialize_object_type()
+        return 'networking.v4.config.VnicMigrationItemSpec'
 
-    def get_object_type(self):
-        return self.__dollar_object_type
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
-    def get_reserved(self):
-        return self.__dollar_reserved
-
-    def get_unknown_fields(self):
-        return self.__dollar_unknown_fields
 
     @property
-    def error(self):
+    def network_uuid(self):
         """
-        
+        NIC network UUID for the destination subnet.
 
         :type:
-                :class:`~ntnx_networking_py_client.models.networking.v4.error.AppMessage` | 
-                :class:`~ntnx_networking_py_client.models.networking.v4.error.SchemaValidationError`
-                    """  # noqa: E501
-        return self.__error
-
-    @error.setter
-    def error(self, error):
 
-        self.__error = error
+                :class:`~str`
+        """  # noqa: E501
+        return self.__network_uuid
 
-    @property
-    def _reserved(self):
-        """
-        
+    @network_uuid.setter
+    def network_uuid(self, network_uuid):
+        if network_uuid is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', network_uuid):  # noqa: E501
+            raise ValueError(r"Invalid value for `network_uuid`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501
 
-        :type:
-            dict(str, :class:`~object`)
-        """  # noqa: E501
-        return self.__dollar_reserved
+        self.__network_uuid = network_uuid
 
     @property
-    def _object_type(self):
+    def requested_ip_addresses(self):
         """
         
 
         :type:
-
-                :class:`~str`
+             list[ :class:`~ntnx_networking_py_client.models.common.v1.config.IPAddress` ]
         """  # noqa: E501
-        return self.__dollar_object_type
+        return self.__requested_ip_addresses
 
-    @property
-    def _unknown_fields(self):
-        """
-        
+    @requested_ip_addresses.setter
+    def requested_ip_addresses(self, requested_ip_addresses):
 
-        :type:
-            dict(str, :class:`~object`)
-        """  # noqa: E501
-        return self.__dollar_unknown_fields
+        self.__requested_ip_addresses = requested_ip_addresses
 
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
-            if attr_type.startswith('OneOf'):
-                type = getattr(ntnx_networking_py_client.models, attr_type.split('.')[-1])
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(ErrorResponse, dict):
+        if issubclass(VnicMigrationItemSpec, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -192,15 +169,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ErrorResponse):
+        if not isinstance(other, VnicMigrationItemSpec):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/stats/Layer2StretchStats.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/stats/VpnConnectionStats.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,175 +3,159 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.stats.DownSamplingOperator import DownSamplingOperator  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.stats.StatsQueryResponseBase import StatsQueryResponseBase  # noqa: F401,E501
 
-class Layer2StretchStats(StatsQueryResponseBase):
+class VpnConnectionStats(StatsQueryResponseBase):
 
-    """Layer2 stretch statistics description
+    """VPN connection statistics description
 
-    :param throughput_rx_kbps: (:attr:`throughput_rx_kbps`) VPN connection string array of RX BPS values
+    :param throughput_rx_kbps: (:attr:`throughput_rx_kbps`) VPN connection string array of ingress kilobits per second values
     :type throughput_rx_kbps: 
-    :param throughput_tx_kbps: (:attr:`throughput_tx_kbps`) VPN connection string array of TX BPS values
+    :param throughput_tx_kbps: (:attr:`throughput_tx_kbps`) VPN connection string array of egress kilobits per second values
     :type throughput_tx_kbps: 
-    :param rtt: (:attr:`rtt`) Layer2Stretch string array of round-trip-time.
-    :type rtt: 
 
     """
     """
     IGNORE:
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     IGNORE
     """  # noqa: E501
     swagger_types = {
         'throughput_rx_kbps': 'list[str]',
         'throughput_tx_kbps': 'list[str]',
-        'rtt': 'list[str]',
         'entity_uuid': 'str',
         'stat_type': 'common.v1.stats.DownSamplingOperator',
         'ext_id': 'str',
         'links': 'list[common.v1.response.ApiLink]',
         'tenant_id': 'str',
         '_reserved': 'dict(str, object)',
         '_object_type': 'str',
         '_unknown_fields': 'dict(str, object)',
     }
 
     attribute_map = {
         'throughput_rx_kbps': 'throughputRxKbps',
         'throughput_tx_kbps': 'throughputTxKbps',
-        'rtt': 'rtt',
         'entity_uuid': 'entityUuid',
         'stat_type': 'statType',
         'ext_id': 'extId',
         'links': 'links',
         'tenant_id': 'tenantId',
         '_reserved': '$reserved',
         '_object_type': '$objectType',
         '_unknown_fields': '$unknownFields',
     }
 
 
 
-    def __init__(self, throughput_rx_kbps=None, throughput_tx_kbps=None, rtt=None, entity_uuid=None, stat_type=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
+    def __init__(self, throughput_rx_kbps=None, throughput_tx_kbps=None, entity_uuid=None, stat_type=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
         StatsQueryResponseBase.__init__(self, entity_uuid, stat_type, ext_id, links, tenant_id, *args, **kwargs)
         self.__throughput_rx_kbps = None
         self.__throughput_tx_kbps = None
-        self.__rtt = None
         self.discriminator = None
         if throughput_rx_kbps is not None:
             self.__throughput_rx_kbps = throughput_rx_kbps
         if throughput_tx_kbps is not None:
             self.__throughput_tx_kbps = throughput_tx_kbps
-        if rtt is not None:
-            self.__rtt = rtt
 
     def _initialize_object_type(self):
-        return 'networking.v4.stats.Layer2StretchStats'
+        return 'networking.v4.stats.VpnConnectionStats'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.stats.Layer2StretchStats'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     @property
     def throughput_rx_kbps(self):
         """
-        VPN connection string array of RX BPS values
+        VPN connection string array of ingress kilobits per second values
 
         :type:
             list[ :class:`~str` ]
         """  # noqa: E501
         return self.__throughput_rx_kbps
 
     @throughput_rx_kbps.setter
     def throughput_rx_kbps(self, throughput_rx_kbps):
 
         self.__throughput_rx_kbps = throughput_rx_kbps
 
     @property
     def throughput_tx_kbps(self):
         """
-        VPN connection string array of TX BPS values
+        VPN connection string array of egress kilobits per second values
 
         :type:
             list[ :class:`~str` ]
         """  # noqa: E501
         return self.__throughput_tx_kbps
 
     @throughput_tx_kbps.setter
     def throughput_tx_kbps(self, throughput_tx_kbps):
 
         self.__throughput_tx_kbps = throughput_tx_kbps
 
-    @property
-    def rtt(self):
-        """
-        Layer2Stretch string array of round-trip-time.
-
-        :type:
-            list[ :class:`~str` ]
-        """  # noqa: E501
-        return self.__rtt
-
-    @rtt.setter
-    def rtt(self, rtt):
-
-        self.__rtt = rtt
-
     def _to_dict(self, sanitize):
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
                     result[attr] = value
-        if issubclass(Layer2StretchStats, dict):
+        if issubclass(VpnConnectionStats, dict):
             for key, value in six.iteritems(self):
                 result[key] = value
 
         return result
 
     def to_dict(self):
         """Returns the model properties as a dictionary"""
@@ -183,15 +167,15 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, Layer2StretchStats):
+        if not isinstance(other, VpnConnectionStats):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
         return not self == other
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/stats/StatsQueryResponseBase.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/stats/StatsQueryResponseBase.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
 from ntnx_networking_py_client.models.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel  # noqa: F401,E501
 from ntnx_networking_py_client.models.common.v1.stats.DownSamplingOperator import DownSamplingOperator  # noqa: F401,E501
 
 class StatsQueryResponseBase(ExternalizableAbstractModel):
 
     """Response of statistics query.
@@ -74,16 +75,16 @@
             self.__entity_uuid = entity_uuid
         if stat_type is not None:
             self.__stat_type = stat_type
 
     def _initialize_object_type(self):
         return 'networking.v4.stats.StatsQueryResponseBase'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.stats.StatsQueryResponseBase'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     @property
     def entity_uuid(self):
         """
         UUID of queried entity.
 
@@ -119,28 +120,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/stats/TrafficMirrorStats.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/stats/TrafficMirrorStats.py`

 * *Files 3% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.stats.DownSamplingOperator import DownSamplingOperator  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.stats.StatsQueryResponseBase import StatsQueryResponseBase  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.stats.TrafficMirrorState import TrafficMirrorState  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.stats.TrafficMirrorStatsData import TrafficMirrorStatsData  # noqa: F401,E501
 
 class TrafficMirrorStats(StatsQueryResponseBase):
 
@@ -93,16 +94,16 @@
             self.__state = state
         if state_message is not None:
             self.__state_message = state_message
 
     def _initialize_object_type(self):
         return 'networking.v4.stats.TrafficMirrorStats'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.stats.TrafficMirrorStats'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     @property
     def stats_data(self):
         """
         
 
@@ -167,28 +168,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/models/networking/v4/stats/VpcNsStats.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/models/networking/v4/stats/VpcNsStats.py`

 * *Files 0% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import pprint
 import json
 import ast
 import re  # noqa: F401
 
 import six
+from pathlib import Path
 from ntnx_networking_py_client.models.common.v1.stats.DownSamplingOperator import DownSamplingOperator  # noqa: F401,E501
 from ntnx_networking_py_client.models.networking.v4.stats.StatsQueryResponseBase import StatsQueryResponseBase  # noqa: F401,E501
 
 class VpcNsStats(StatsQueryResponseBase):
 
     """VPC North-South statistics description
 
@@ -119,16 +120,16 @@
             self.__north_south_ingress_packets_abs = north_south_ingress_packets_abs
         if north_south_egress_packets_abs is not None:
             self.__north_south_egress_packets_abs = north_south_egress_packets_abs
 
     def _initialize_object_type(self):
         return 'networking.v4.stats.VpcNsStats'
 
-    def _initialize_fq_object_type(self):
-        return 'networking.v4.r0.b1.stats.VpcNsStats'
+    def _initialize_object_version(self):
+        return 'v4.r0.b1'
 
 
     @property
     def north_south_ingress_bytes_per_sec(self):
         """
         VPC North-South string array of ingress BPS values
 
@@ -251,28 +252,33 @@
         """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
 
         :param sanitize: A flag to omit None properties if set to True
         :type sanitize: bool
         """
 
         result = {}
-
         for attr, attr_type in six.iteritems(self.swagger_types):
+        
             value = getattr(self, attr)
             if isinstance(value, list):
                 result[attr] = list(map(
                     lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                     value
                 ))
             elif hasattr(value, "_to_dict"):
                 result[attr] = value._to_dict(sanitize)
+            elif isinstance(value, Path):
+                result[attr] = str(value)
             elif isinstance(value, dict):
                 result[attr] = dict(map(
-                    lambda item: (item[0], item[1]._to_dict(sanitize))
-                    if hasattr(item[1], "_to_dict") else item,
+                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
+                    else (
+                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
+                        else item
+                    ),
                     six.iteritems(value)
                 ))
             else:
                 if sanitize:
                     if value is not None:
                         result[attr] = value
                 else:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client/rest.py` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client/rest.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,15 +3,15 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 from __future__ import absolute_import
 
 import io
@@ -37,15 +37,15 @@
 
 class RESTResponse(io.IOBase):
 
     def __init__(self, resp):
         self.urllib3_response = resp
         self.status = resp.status
         self.reason = resp.reason
-        self.data = resp.data
+        self.data = None
 
     def getheaders(self):
         """Returns a dictionary of the response headers."""
         return self.urllib3_response.getheaders()
 
     def getheader(self, name, default=None):
         """Returns a given response header."""
@@ -180,14 +180,16 @@
             if isinstance(_request_timeout, (int, float) if six.PY3 else (int, long, float)):  # noqa: E501,F821
                 timeout = urllib3.Timeout(total=_request_timeout)
             elif (isinstance(_request_timeout, list) and len(_request_timeout) == 2):
                 timeout = urllib3.Timeout(connect=_request_timeout[0], read=_request_timeout[1])
 
         if 'Content-Type' not in headers:
             headers['Content-Type'] = 'application/json'
+        if 'Accept' in headers and headers['Accept'] == 'application/octet-stream':
+            _preload_content = False
 
         # Print log statements
         logger.info("%s %s", method, url + '?' + urlencode(query_params) if query_params else url)
         # Print debug logs, if enabled
         if self.__configuration.debug:
             logger.debug("Request Headers:")
             for key, value in six.iteritems(headers):
@@ -221,31 +223,37 @@
                         preload_content=_preload_content,
                         timeout=timeout,
                         headers=headers)
                 elif headers['Content-Type'] == 'multipart/form-data':
                     # must del headers['Content-Type'], or the correct
                     # Content-Type which generated by urllib3 will be
                     # overwritten.
+                    content_type_header = headers['Content-Type']
                     del headers['Content-Type']
                     r = self.pool_manager.request(
                         method, url,
                         fields=post_params,
                         encode_multipart=True,
                         preload_content=_preload_content,
                         timeout=timeout,
                         headers=headers)
+                    headers['Content-Type'] = content_type_header
                 # Pass a `string` parameter directly in the body to support
                 # other content types than Json when `body` argument is
                 # provided in serialized form
-                elif isinstance(body, str):
+                elif isinstance(body, str) or headers['Content-Type'] == 'application/octet-stream':
                     request_body = body
+                    preload = _preload_content
+                    if headers['Content-Type'] == 'application/octet-stream':
+                        preload = False
+
                     r = self.pool_manager.request(
                         method, url,
                         body=request_body,
-                        preload_content=_preload_content,
+                        preload_content=preload,
                         timeout=timeout,
                         headers=headers)
                 else:
                     # Cannot generate the request from given parameters
                     msg = """Cannot prepare a request message for provided
                              arguments. Please check that your arguments match
                              declared content type."""
@@ -260,30 +268,27 @@
         except urllib3.exceptions.SSLError as e:
             msg = "{0}\n{1}".format(type(e).__name__, str(e))
             raise ApiException(status=0, reason=msg)
         except Exception as e:
             logger.error(str(e))
             raise
 
-        if _preload_content:
+        if r.getheader(name='Content-Type') == 'application/octet-stream' or _preload_content :
             r = RESTResponse(r)
 
-            # In the python 3, the response.data is bytes.
-            # we need to decode it to string.
-            if six.PY3:
-                r.data = r.data.decode('utf8')
-
         # Print log statements
         logger.info("Response Status: %s %s", r.status, r.reason)
         # Print debug logs, if enabled
         if self.__configuration.debug:
             logger.debug("Response Headers:")
             for key, value in six.iteritems(r.getheaders()):
                 logger.debug("%s: %s", key, value)
-            logger.debug("Response Body: %s", r.data)
+
+            if _preload_content and r.getheader("Content-Type", "application/json") != "application/octet-stream":
+                logger.debug("Response Body: %s", r.urllib3_response.data)
 
         if not 200 <= r.status <= 299 and not 401 == r.status:
             raise ApiException(http_resp=r)
 
         return r
 
     def GET(self, url, headers=None, query_params=None, _preload_content=True,
@@ -354,15 +359,16 @@
 
 class ApiException(Exception):
 
     def __init__(self, status=None, reason=None, http_resp=None):
         if http_resp:
             self.status = http_resp.status
             self.reason = http_resp.reason
-            self.body = http_resp.data
+            self.body = (http_resp.urllib3_response.data.decode('utf8') if hasattr(http_resp, 'urllib3_response')
+                        else http_resp.data.decode('utf8'))
             self.headers = http_resp.getheaders()
         else:
             self.status = status
             self.reason = reason
             self.body = None
             self.headers = None
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client.egg-info/PKG-INFO` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client.egg-info/PKG-INFO`

 * *Files 3% similar despite different names*

```diff
@@ -1,37 +1,37 @@
 Metadata-Version: 2.1
 Name: ntnx-networking-py-client
-Version: 4.0.1b1
+Version: 4.0.2b1
 Summary: Nutanix Networking Versioned APIs
 Home-page: 
 Author-email: sdk@nutanix.com
 Keywords: Nutanix,v4,SDK,Nutanix Networking Versioned APIs
 Description-Content-Type: text/markdown
 License-File: LICENSE.txt
 Requires-Dist: urllib3~=1.26
 Requires-Dist: six~=1.16
-Requires-Dist: certifi==2020.4.5.1
+Requires-Dist: certifi<=2023.11.17,>=2020.4.5.1
 Requires-Dist: python-dateutil~=2.8
 Requires-Dist: pysocks~=1.7
 
 # Python Client For Nutanix Networking Versioned APIs
 
 The Python client for Nutanix Networking Versioned APIs is designed for Python client application developers offering them simple and flexible access to APIs that manage networking configuration on Nutanix clusters, including AHV and advanced networking.
 ## Features
 - Invoke Nutanix APIs with a simple interface.
 - Handle Authentication seamlessly.
 - Reduce boilerplate code implementation.
 - Use standard methods for installation.
 
 ## Version
 - API version: v4.0.b1
-- Package version: 4.0.1b1
+- Package version: 4.0.2b1
 
 ## Requirements.
-Python 3.6, 3.7, and 3.8 are fully supported and tested.
+Python 3.6, 3.7, 3.8 and 3.9 are fully supported and tested.
 
 
 ## Installation & Usage
 
 ### Installing in a virtual environment
 [virtualenv](https://virtualenv.pypa.io/en/latest/) is a tool to create isolated Python environments. The basic problem it addresses is one of dependencies and versions, and indirectly permissions. virtualenv can help you install this client without needing system install permissions. It creates an environment that has its own installation directories without sharing libraries with other virtualenv environments or the system installation.
 
@@ -85,14 +85,15 @@
 | debug     | Runs the client in debug mode if specified                                       | No       | False        |
 | verify_ssl| Verify SSL certificate of cluster the client will connect to                     | No       | True         |
 | max_retry_attempts| Maximum number of retry attempts while connecting to the cluster         | No       | 5            |
 | backoff_factor| A backoff factor to apply between attempts after the second try.             | No       | 3            |
 | logger_file | File location to which debug logs are written to                               | No       | N/A          |
 | connect_timeout | Connection timeout in milliseconds for all operations                      | No       | 30000        |
 | read_timeout | Read timeout in milliseconds for all operations                               | No       | 30000        |
+| download_directory| Directory where downloaded files will be stored in                       | No       | Current Working Directory|
 
 
 ### Sample Configuration
 ```python
 config = Configuration()
 config.host = '10.19.50.27' # IPv4/IPv6 address or FQDN of the cluster
 config.port = 9440 # Port to which to connect to
@@ -142,66 +143,66 @@
 ```
 
 ## Usage
 
 ### Invoking an operation
 ```python
 # Initialize the API
-flow_gateway_api_instance = FlowGatewayApi(api_client=client) # client configured in previous step
+flow_gateways_api_instance = FlowGatewaysApi(api_client=client) # client configured in previous step
 extId = 'extId_example' # UUID.
 
 # Get the Atlas Flow Gateway with the specified UUID.
 try:
-    api_response = flow_gateway_api_instance.get_atlas_flow_gateway(extId)
+    api_response = flow_gateways_api_instance.get_flow_gateway_by_id(extId)
 except ApiException as e:
 ```
 
 ### Setting headers for individual operations
 Headers can be configured globally on the python client using the [method to set default headers](#additional-headers). However, sometimes headers need to be set on an individual operation basis. Nutanix APIs require that concurrent updates are protected using [ETag headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag).
 
 ```python
 # Initialize the API
-flow_gateway_api_instance = FlowGatewayApi(api_client=client) # client configured in previous step
+flow_gateways_api_instance = FlowGatewaysApi(api_client=client) # client configured in previous step
 extId = 'extId_example' # UUID.
 
 # Get the Atlas Flow Gateway with the specified UUID.
 try:
-    api_response = flow_gateway_api_instance.get_atlas_flow_gateway(extId)
+    api_response = flow_gateways_api_instance.get_flow_gateway_by_id(extId)
 except ApiException as e:
 
 # Extract E-Tag Header
 etag_value = ApiClient.get_etag(api_response)
 
 # Update the specified Atlas Flow Gateway.
 try:
     # The body parameter in the following operation is received from the previous GET request's response which needs to be updated.
-    api_response = flow_gateway_api_instance.update_atlas_flow_gateway(body, extId, if_match=etag_value) # Use the extracted etag value
+    api_response = flow_gateways_api_instance.update_flow_gateway_by_id(body, extId, if_match=etag_value) # Use the extracted etag value
 except ApiException as e:
 ```
 
 ### List Operations
 List Operations for Nutanix APIs support pagination, filtering, sorting and projections. The table below details the parameters that can be used to set the options for pagination etc.
 
 | Parameter | Description
 |-----------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
 | _page     | specifies the page number of the result set. Must be a positive integer between 0 and the maximum number of pages that are available for that resource. Any number out of this range will lead to no results being returned.|
 | _limit    | specifies the total number of records returned in the result set. Must be a positive integer between 0 and 100. Any number out of this range will lead to a validation error. If the limit is not provided a default value of 50 records will be returned in the result set|
 | _filter   | allows clients to filter a collection of resources. The expression specified with $filter is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response. Expression specified with the $filter must conform to the [OData V4.01 URL](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part2-url-conventions.html#sec_SystemQueryOptionfilter) conventions. |
 | _orderby  | allows clients to specify the sort criteria for the returned list of objects. Resources can be sorted in ascending order using asc or descending order using desc. If asc or desc are not specified the resources will be sorted in ascending order by default. For example, 'orderby=templateName desc' would get all templates sorted by templateName in desc order. |
-| _select   | allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the OData V4.01 URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e. *), then all properties on the matching resource will be returned. |
-| _expand   | allows clients to request related resources when a resource that satisfies a particular request is retrieved. Each expand item is evaluated relative to the entity containing the property being expanded. Other query options can be applied to an expanded property by appending a semicolon-separated list of query options, enclosed in parentheses, to the property name. Allowed system query options are $filter,$select, $orderby. |
+| _select   | allows clients to request a specific set of properties for each entity or complex type. Expression specified with the $select must conform to the OData V4.01 URL conventions. If a $select expression consists of a single select item that is an asterisk (i.e., *), then all properties on the matching resource will be returned. |
+| _expand   | allows clients to request related resources when a resource that satisfies a particular request is retrieved. Each expanded item is evaluated relative to the entity containing the property being expanded. Other query options can be applied to an expanded property by appending a semicolon-separated list of query options, enclosed in parentheses, to the property name. Permissible system query options are $filter,$select and $orderby. |
 
 ```python
 # Initialize the API
-bgp_session_api_instance = BgpSessionApi(api_client=client) # client configured in previous step
+bgp_sessions_api_instance = BgpSessionsApi(api_client=client) # client configured in previous step
 extId = 'extId_example' # UUID.
 
 # List BGP sessions request.
 try:
-    api_response = bgp_session_api_instance.list_bgp_sessions(
+    api_response = bgp_sessions_api_instance.list_bgp_sessions(
 	                   _page=page, # if page parameter is present
 	                   _limit=limit, # if limit parameter is present
 	                   _filter=_filter, # if filter parameter is present
 	                   _orderby=_orderby, # if orderby parameter is present
 	                   _select=select, # if select parameter is present
 	                   _expand=expand) # if expand parameter is present
 except ApiException as e:
```

### Comparing `ntnx-networking-py-client-4.0.1b1/ntnx_networking_py_client.egg-info/SOURCES.txt` & `ntnx_networking_py_client-4.0.2b1/ntnx_networking_py_client.egg-info/SOURCES.txt`

 * *Files 5% similar despite different names*

```diff
@@ -8,101 +8,92 @@
 ntnx_networking_py_client/rest.py
 ntnx_networking_py_client.egg-info/PKG-INFO
 ntnx_networking_py_client.egg-info/SOURCES.txt
 ntnx_networking_py_client.egg-info/dependency_links.txt
 ntnx_networking_py_client.egg-info/requires.txt
 ntnx_networking_py_client.egg-info/top_level.txt
 ntnx_networking_py_client/api/__init__.py
-ntnx_networking_py_client/api/bgp_session_api.py
-ntnx_networking_py_client/api/bridge_api.py
-ntnx_networking_py_client/api/cluster_capability_api.py
-ntnx_networking_py_client/api/floating_ip_api.py
-ntnx_networking_py_client/api/gateway_api.py
-ntnx_networking_py_client/api/ipfix_exporter_api.py
-ntnx_networking_py_client/api/layer2_stretch_api.py
+ntnx_networking_py_client/api/bgp_sessions_api.py
+ntnx_networking_py_client/api/bridges_api.py
+ntnx_networking_py_client/api/cluster_capabilities_api.py
+ntnx_networking_py_client/api/floating_ips_api.py
+ntnx_networking_py_client/api/gateways_api.py
+ntnx_networking_py_client/api/ipfix_exporters_api.py
 ntnx_networking_py_client/api/layer2_stretch_stats_api.py
-ntnx_networking_py_client/api/network_controller_api.py
-ntnx_networking_py_client/api/route_table_api.py
-ntnx_networking_py_client/api/routing_policy_api.py
+ntnx_networking_py_client/api/layer2_stretches_api.py
+ntnx_networking_py_client/api/network_controllers_api.py
+ntnx_networking_py_client/api/route_tables_api.py
+ntnx_networking_py_client/api/routing_policies_api.py
 ntnx_networking_py_client/api/routing_policy_stats_api.py
-ntnx_networking_py_client/api/subnet_api.py
-ntnx_networking_py_client/api/subnet_reserve_unreserve_ip_api.py
-ntnx_networking_py_client/api/traffic_mirror_api.py
+ntnx_networking_py_client/api/subnet_ip_reservation_api.py
+ntnx_networking_py_client/api/subnets_api.py
 ntnx_networking_py_client/api/traffic_mirror_stats_api.py
-ntnx_networking_py_client/api/uplink_bond_api.py
-ntnx_networking_py_client/api/virtual_switch_api.py
-ntnx_networking_py_client/api/virtual_switch_node_info_api.py
-ntnx_networking_py_client/api/vpc_api.py
+ntnx_networking_py_client/api/traffic_mirrors_api.py
+ntnx_networking_py_client/api/uplink_bonds_api.py
+ntnx_networking_py_client/api/virtual_switch_nodes_info_api.py
+ntnx_networking_py_client/api/virtual_switches_api.py
 ntnx_networking_py_client/api/vpc_ns_stats_api.py
 ntnx_networking_py_client/api/vpc_virtual_switch_mappings_api.py
-ntnx_networking_py_client/api/vpn_connection_api.py
+ntnx_networking_py_client/api/vpcs_api.py
 ntnx_networking_py_client/api/vpn_connection_stats_api.py
+ntnx_networking_py_client/api/vpn_connections_api.py
 ntnx_networking_py_client/models/__init__.py
 ntnx_networking_py_client/models/OneOfcommon/__init__.py
 ntnx_networking_py_client/models/OneOfcommon/v1/__init__.py
 ntnx_networking_py_client/models/OneOfcommon/v1/config/KVPairvalue.py
 ntnx_networking_py_client/models/OneOfcommon/v1/config/__init__.py
 ntnx_networking_py_client/models/OneOfnetworking/__init__.py
 ntnx_networking_py_client/models/OneOfnetworking/v4/__init__.py
-ntnx_networking_py_client/models/OneOfnetworking/v4/config/AncConfigApiResponsedata.py
-ntnx_networking_py_client/models/OneOfnetworking/v4/config/BgpSessionApiResponsedata.py
-ntnx_networking_py_client/models/OneOfnetworking/v4/config/BgpSessionListApiResponsedata.py
-ntnx_networking_py_client/models/OneOfnetworking/v4/config/CloudNetworkApiResponsedata.py
-ntnx_networking_py_client/models/OneOfnetworking/v4/config/CloudNetworkListApiResponsedata.py
-ntnx_networking_py_client/models/OneOfnetworking/v4/config/ClusterCapabilityApiResponsedata.py
-ntnx_networking_py_client/models/OneOfnetworking/v4/config/ClusterFlowStatusApiResponsedata.py
-ntnx_networking_py_client/models/OneOfnetworking/v4/config/FloatingIpApiResponsedata.py
-ntnx_networking_py_client/models/OneOfnetworking/v4/config/FloatingIpListApiResponsedata.py
 ntnx_networking_py_client/models/OneOfnetworking/v4/config/FloatingIpProjectionassociation.py
 ntnx_networking_py_client/models/OneOfnetworking/v4/config/FloatingIpassociation.py
-ntnx_networking_py_client/models/OneOfnetworking/v4/config/FlowGatewayApiResponsedata.py
-ntnx_networking_py_client/models/OneOfnetworking/v4/config/FlowGatewayKeepAliveApiResponsedata.py
-ntnx_networking_py_client/models/OneOfnetworking/v4/config/FlowGatewayListApiResponsedata.py
-ntnx_networking_py_client/models/OneOfnetworking/v4/config/GatewayApiResponsedata.py
-ntnx_networking_py_client/models/OneOfnetworking/v4/config/GatewayListApiResponsedata.py
 ntnx_networking_py_client/models/OneOfnetworking/v4/config/GatewayProjectionservices.py
 ntnx_networking_py_client/models/OneOfnetworking/v4/config/Gatewayservices.py
-ntnx_networking_py_client/models/OneOfnetworking/v4/config/IPFIXExporterApiResponsedata.py
-ntnx_networking_py_client/models/OneOfnetworking/v4/config/IPFIXExporterListApiResponsedata.py
-ntnx_networking_py_client/models/OneOfnetworking/v4/config/Layer2StretchApiResponsedata.py
-ntnx_networking_py_client/models/OneOfnetworking/v4/config/Layer2StretchListApiResponsedata.py
-ntnx_networking_py_client/models/OneOfnetworking/v4/config/Layer2StretchRelatedEntitiesApiResponsedata.py
-ntnx_networking_py_client/models/OneOfnetworking/v4/config/NetworkCloudConfigApiResponsedata.py
-ntnx_networking_py_client/models/OneOfnetworking/v4/config/NetworkCloudConfigListApiResponsedata.py
-ntnx_networking_py_client/models/OneOfnetworking/v4/config/NetworkControllerApiResponsedata.py
-ntnx_networking_py_client/models/OneOfnetworking/v4/config/NetworkControllerListApiResponsedata.py
-ntnx_networking_py_client/models/OneOfnetworking/v4/config/NodeSchedulableStatusApiResponsedata.py
-ntnx_networking_py_client/models/OneOfnetworking/v4/config/RouteTableApiResponsedata.py
-ntnx_networking_py_client/models/OneOfnetworking/v4/config/RouteTableListApiResponsedata.py
-ntnx_networking_py_client/models/OneOfnetworking/v4/config/RoutingPolicyApiResponsedata.py
-ntnx_networking_py_client/models/OneOfnetworking/v4/config/RoutingPolicyListApiResponsedata.py
+ntnx_networking_py_client/models/OneOfnetworking/v4/config/GetBgpSessionApiResponsedata.py
+ntnx_networking_py_client/models/OneOfnetworking/v4/config/GetFloatingIpApiResponsedata.py
+ntnx_networking_py_client/models/OneOfnetworking/v4/config/GetGatewayApiResponsedata.py
+ntnx_networking_py_client/models/OneOfnetworking/v4/config/GetIPFIXExporterApiResponsedata.py
+ntnx_networking_py_client/models/OneOfnetworking/v4/config/GetLayer2StretchApiResponsedata.py
+ntnx_networking_py_client/models/OneOfnetworking/v4/config/GetNetworkControllerApiResponsedata.py
+ntnx_networking_py_client/models/OneOfnetworking/v4/config/GetRouteTableApiResponsedata.py
+ntnx_networking_py_client/models/OneOfnetworking/v4/config/GetRoutingPolicyApiResponsedata.py
+ntnx_networking_py_client/models/OneOfnetworking/v4/config/GetSubnetApiResponsedata.py
+ntnx_networking_py_client/models/OneOfnetworking/v4/config/GetTrafficMirrorApiResponsedata.py
+ntnx_networking_py_client/models/OneOfnetworking/v4/config/GetUplinkBondApiResponsedata.py
+ntnx_networking_py_client/models/OneOfnetworking/v4/config/GetVirtualSwitchApiResponsedata.py
+ntnx_networking_py_client/models/OneOfnetworking/v4/config/GetVpcApiResponsedata.py
+ntnx_networking_py_client/models/OneOfnetworking/v4/config/GetVpnConnectionApiResponsedata.py
+ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListBgpSessionsApiResponsedata.py
+ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListClusterCapabilitiesApiResponsedata.py
+ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListFloatingIpsApiResponsedata.py
+ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListGatewaysApiResponsedata.py
+ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListIPFIXExportersApiResponsedata.py
+ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListLayer2StretchRelatedEntitiesApiResponsedata.py
+ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListLayer2StretchesApiResponsedata.py
+ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListNetworkControllersApiResponsedata.py
+ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListNodeSchedulableStatusesApiResponsedata.py
+ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListRouteTablesApiResponsedata.py
+ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListRoutingPoliciesApiResponsedata.py
+ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListSubnetsApiResponsedata.py
+ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListTrafficMirrorsApiResponsedata.py
+ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListUplinkBondsApiResponsedata.py
+ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListVirtualSwitchesApiResponsedata.py
+ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListVpcVirtualSwitchMappingsApiResponsedata.py
+ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListVpcsApiResponsedata.py
+ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListVpnConnectionsApiResponsedata.py
+ntnx_networking_py_client/models/OneOfnetworking/v4/config/ListVpnVendorConfigsApiResponsedata.py
 ntnx_networking_py_client/models/OneOfnetworking/v4/config/RoutingPolicyMatchConditionprotocol_parameters.py
-ntnx_networking_py_client/models/OneOfnetworking/v4/config/SubnetApiResponsedata.py
-ntnx_networking_py_client/models/OneOfnetworking/v4/config/SubnetListApiResponsedata.py
 ntnx_networking_py_client/models/OneOfnetworking/v4/config/TaskReferenceApiResponsedata.py
-ntnx_networking_py_client/models/OneOfnetworking/v4/config/TrafficMirrorApiResponsedata.py
-ntnx_networking_py_client/models/OneOfnetworking/v4/config/TrafficMirrorListApiResponsedata.py
-ntnx_networking_py_client/models/OneOfnetworking/v4/config/UplinkBondApiResponsedata.py
-ntnx_networking_py_client/models/OneOfnetworking/v4/config/UplinkBondListApiResponsedata.py
-ntnx_networking_py_client/models/OneOfnetworking/v4/config/VirtualSwitchApiResponsedata.py
-ntnx_networking_py_client/models/OneOfnetworking/v4/config/VirtualSwitchListApiResponsedata.py
-ntnx_networking_py_client/models/OneOfnetworking/v4/config/VpcApiResponsedata.py
-ntnx_networking_py_client/models/OneOfnetworking/v4/config/VpcListApiResponsedata.py
-ntnx_networking_py_client/models/OneOfnetworking/v4/config/VpcVirtualSwitchMappingsApiResponsedata.py
-ntnx_networking_py_client/models/OneOfnetworking/v4/config/VpnConnectionApiResponsedata.py
-ntnx_networking_py_client/models/OneOfnetworking/v4/config/VpnConnectionListApiResponsedata.py
-ntnx_networking_py_client/models/OneOfnetworking/v4/config/VpnVendorListApiResponsedata.py
 ntnx_networking_py_client/models/OneOfnetworking/v4/config/__init__.py
 ntnx_networking_py_client/models/OneOfnetworking/v4/error/ErrorResponseerror.py
 ntnx_networking_py_client/models/OneOfnetworking/v4/error/__init__.py
-ntnx_networking_py_client/models/OneOfnetworking/v4/stats/Layer2StretchStatsApiResponsedata.py
+ntnx_networking_py_client/models/OneOfnetworking/v4/stats/GetLayer2StretchStatsApiResponsedata.py
+ntnx_networking_py_client/models/OneOfnetworking/v4/stats/GetTrafficMirrorStatsApiResponsedata.py
+ntnx_networking_py_client/models/OneOfnetworking/v4/stats/GetVpcNsStatsApiResponsedata.py
+ntnx_networking_py_client/models/OneOfnetworking/v4/stats/GetVpnConnectionStatsApiResponsedata.py
 ntnx_networking_py_client/models/OneOfnetworking/v4/stats/TaskReferenceApiResponsedata.py
-ntnx_networking_py_client/models/OneOfnetworking/v4/stats/TrafficMirrorStatsApiResponsedata.py
-ntnx_networking_py_client/models/OneOfnetworking/v4/stats/VpcNsStatsApiResponsedata.py
-ntnx_networking_py_client/models/OneOfnetworking/v4/stats/VpnConnectionStatsApiResponsedata.py
 ntnx_networking_py_client/models/OneOfnetworking/v4/stats/__init__.py
 ntnx_networking_py_client/models/common/__init__.py
 ntnx_networking_py_client/models/common/v1/__init__.py
 ntnx_networking_py_client/models/common/v1/config/EntityReference.py
 ntnx_networking_py_client/models/common/v1/config/EntityType.py
 ntnx_networking_py_client/models/common/v1/config/Flag.py
 ntnx_networking_py_client/models/common/v1/config/IPAddress.py
@@ -122,81 +113,83 @@
 ntnx_networking_py_client/models/common/v1/stats/__init__.py
 ntnx_networking_py_client/models/networking/__init__.py
 ntnx_networking_py_client/models/networking/v4/__init__.py
 ntnx_networking_py_client/models/networking/v4/config/Address.py
 ntnx_networking_py_client/models/networking/v4/config/AddressType.py
 ntnx_networking_py_client/models/networking/v4/config/AddressTypeObject.py
 ntnx_networking_py_client/models/networking/v4/config/Anc.py
-ntnx_networking_py_client/models/networking/v4/config/AncConfigApiResponse.py
 ntnx_networking_py_client/models/networking/v4/config/AssignedAddress.py
 ntnx_networking_py_client/models/networking/v4/config/AuthenticationAlgorithm.py
 ntnx_networking_py_client/models/networking/v4/config/AuthenticationType.py
 ntnx_networking_py_client/models/networking/v4/config/AuthorizationData.py
+ntnx_networking_py_client/models/networking/v4/config/AwsConfig.py
+ntnx_networking_py_client/models/networking/v4/config/AwsExternalSubnetConfig.py
+ntnx_networking_py_client/models/networking/v4/config/AwsSubnetConfig.py
 ntnx_networking_py_client/models/networking/v4/config/AzureConfig.py
 ntnx_networking_py_client/models/networking/v4/config/AzureExternalSubnetBinding.py
 ntnx_networking_py_client/models/networking/v4/config/AzureExternalSubnetConfig.py
 ntnx_networking_py_client/models/networking/v4/config/BgpConfig.py
 ntnx_networking_py_client/models/networking/v4/config/BgpInfo.py
 ntnx_networking_py_client/models/networking/v4/config/BgpSession.py
-ntnx_networking_py_client/models/networking/v4/config/BgpSessionApiResponse.py
-ntnx_networking_py_client/models/networking/v4/config/BgpSessionListApiResponse.py
 ntnx_networking_py_client/models/networking/v4/config/BgpSessionProjection.py
 ntnx_networking_py_client/models/networking/v4/config/BondModeType.py
 ntnx_networking_py_client/models/networking/v4/config/Bridge.py
 ntnx_networking_py_client/models/networking/v4/config/BridgeProjection.py
 ntnx_networking_py_client/models/networking/v4/config/Capability.py
 ntnx_networking_py_client/models/networking/v4/config/CloudNetwork.py
-ntnx_networking_py_client/models/networking/v4/config/CloudNetworkApiResponse.py
-ntnx_networking_py_client/models/networking/v4/config/CloudNetworkListApiResponse.py
 ntnx_networking_py_client/models/networking/v4/config/CloudSubstrate.py
 ntnx_networking_py_client/models/networking/v4/config/Cluster.py
 ntnx_networking_py_client/models/networking/v4/config/ClusterCapability.py
-ntnx_networking_py_client/models/networking/v4/config/ClusterCapabilityApiResponse.py
 ntnx_networking_py_client/models/networking/v4/config/ClusterFlowStatus.py
-ntnx_networking_py_client/models/networking/v4/config/ClusterFlowStatusApiResponse.py
 ntnx_networking_py_client/models/networking/v4/config/ClusterStatus.py
 ntnx_networking_py_client/models/networking/v4/config/ControllerStatus.py
 ntnx_networking_py_client/models/networking/v4/config/DefaultVlanStack.py
 ntnx_networking_py_client/models/networking/v4/config/DhcpOptions.py
 ntnx_networking_py_client/models/networking/v4/config/DpdConfig.py
 ntnx_networking_py_client/models/networking/v4/config/DpdOperation.py
 ntnx_networking_py_client/models/networking/v4/config/EncryptionAlgorithm.py
 ntnx_networking_py_client/models/networking/v4/config/ExportScope.py
 ntnx_networking_py_client/models/networking/v4/config/ExporterProtocol.py
 ntnx_networking_py_client/models/networking/v4/config/ExternalSubnet.py
 ntnx_networking_py_client/models/networking/v4/config/FloatingIPAddress.py
 ntnx_networking_py_client/models/networking/v4/config/FloatingIPv4Address.py
 ntnx_networking_py_client/models/networking/v4/config/FloatingIPv6Address.py
 ntnx_networking_py_client/models/networking/v4/config/FloatingIp.py
-ntnx_networking_py_client/models/networking/v4/config/FloatingIpApiResponse.py
-ntnx_networking_py_client/models/networking/v4/config/FloatingIpListApiResponse.py
 ntnx_networking_py_client/models/networking/v4/config/FloatingIpProjection.py
 ntnx_networking_py_client/models/networking/v4/config/FlowGateway.py
-ntnx_networking_py_client/models/networking/v4/config/FlowGatewayApiResponse.py
 ntnx_networking_py_client/models/networking/v4/config/FlowGatewayKeepAlive.py
-ntnx_networking_py_client/models/networking/v4/config/FlowGatewayKeepAliveApiResponse.py
 ntnx_networking_py_client/models/networking/v4/config/FlowGatewayKeepAliveRequestSpec.py
-ntnx_networking_py_client/models/networking/v4/config/FlowGatewayListApiResponse.py
 ntnx_networking_py_client/models/networking/v4/config/FlowGatewayState.py
 ntnx_networking_py_client/models/networking/v4/config/FlowGatewayStatus.py
 ntnx_networking_py_client/models/networking/v4/config/Gateway.py
-ntnx_networking_py_client/models/networking/v4/config/GatewayApiResponse.py
 ntnx_networking_py_client/models/networking/v4/config/GatewayDeployment.py
-ntnx_networking_py_client/models/networking/v4/config/GatewayListApiResponse.py
+ntnx_networking_py_client/models/networking/v4/config/GatewayInterface.py
 ntnx_networking_py_client/models/networking/v4/config/GatewayManagementInterface.py
 ntnx_networking_py_client/models/networking/v4/config/GatewayNic.py
 ntnx_networking_py_client/models/networking/v4/config/GatewayNodeReference.py
 ntnx_networking_py_client/models/networking/v4/config/GatewayProjection.py
 ntnx_networking_py_client/models/networking/v4/config/GatewayRole.py
+ntnx_networking_py_client/models/networking/v4/config/GetBgpSessionApiResponse.py
+ntnx_networking_py_client/models/networking/v4/config/GetFloatingIpApiResponse.py
+ntnx_networking_py_client/models/networking/v4/config/GetGatewayApiResponse.py
+ntnx_networking_py_client/models/networking/v4/config/GetIPFIXExporterApiResponse.py
+ntnx_networking_py_client/models/networking/v4/config/GetLayer2StretchApiResponse.py
+ntnx_networking_py_client/models/networking/v4/config/GetNetworkControllerApiResponse.py
+ntnx_networking_py_client/models/networking/v4/config/GetRouteTableApiResponse.py
+ntnx_networking_py_client/models/networking/v4/config/GetRoutingPolicyApiResponse.py
+ntnx_networking_py_client/models/networking/v4/config/GetSubnetApiResponse.py
+ntnx_networking_py_client/models/networking/v4/config/GetTrafficMirrorApiResponse.py
+ntnx_networking_py_client/models/networking/v4/config/GetUplinkBondApiResponse.py
+ntnx_networking_py_client/models/networking/v4/config/GetVirtualSwitchApiResponse.py
+ntnx_networking_py_client/models/networking/v4/config/GetVpcApiResponse.py
+ntnx_networking_py_client/models/networking/v4/config/GetVpnConnectionApiResponse.py
 ntnx_networking_py_client/models/networking/v4/config/Host.py
 ntnx_networking_py_client/models/networking/v4/config/ICMPObject.py
 ntnx_networking_py_client/models/networking/v4/config/IPConfig.py
 ntnx_networking_py_client/models/networking/v4/config/IPFIXExporter.py
-ntnx_networking_py_client/models/networking/v4/config/IPFIXExporterApiResponse.py
-ntnx_networking_py_client/models/networking/v4/config/IPFIXExporterListApiResponse.py
 ntnx_networking_py_client/models/networking/v4/config/IPPoolUsage.py
 ntnx_networking_py_client/models/networking/v4/config/IPSubnet.py
 ntnx_networking_py_client/models/networking/v4/config/IPUsage.py
 ntnx_networking_py_client/models/networking/v4/config/IPv4Config.py
 ntnx_networking_py_client/models/networking/v4/config/IPv4Pool.py
 ntnx_networking_py_client/models/networking/v4/config/IPv4Subnet.py
 ntnx_networking_py_client/models/networking/v4/config/IPv6Config.py
@@ -204,39 +197,50 @@
 ntnx_networking_py_client/models/networking/v4/config/IPv6Subnet.py
 ntnx_networking_py_client/models/networking/v4/config/IbgpConfig.py
 ntnx_networking_py_client/models/networking/v4/config/InternalRoutingConfig.py
 ntnx_networking_py_client/models/networking/v4/config/IpReserveSpec.py
 ntnx_networking_py_client/models/networking/v4/config/IpUnreserveSpec.py
 ntnx_networking_py_client/models/networking/v4/config/IpsecConfig.py
 ntnx_networking_py_client/models/networking/v4/config/Layer2Stretch.py
-ntnx_networking_py_client/models/networking/v4/config/Layer2StretchApiResponse.py
-ntnx_networking_py_client/models/networking/v4/config/Layer2StretchListApiResponse.py
 ntnx_networking_py_client/models/networking/v4/config/Layer2StretchRelatedEntities.py
-ntnx_networking_py_client/models/networking/v4/config/Layer2StretchRelatedEntitiesApiResponse.py
 ntnx_networking_py_client/models/networking/v4/config/Layer2StretchSubnetInfo.py
 ntnx_networking_py_client/models/networking/v4/config/Layer2StretchVpnConnectionInfo.py
 ntnx_networking_py_client/models/networking/v4/config/Layer2StretchVtepGatewayInfo.py
 ntnx_networking_py_client/models/networking/v4/config/LayerFourProtocolObject.py
 ntnx_networking_py_client/models/networking/v4/config/LearnedAddress.py
+ntnx_networking_py_client/models/networking/v4/config/ListBgpSessionsApiResponse.py
+ntnx_networking_py_client/models/networking/v4/config/ListClusterCapabilitiesApiResponse.py
+ntnx_networking_py_client/models/networking/v4/config/ListFloatingIpsApiResponse.py
+ntnx_networking_py_client/models/networking/v4/config/ListGatewaysApiResponse.py
+ntnx_networking_py_client/models/networking/v4/config/ListIPFIXExportersApiResponse.py
+ntnx_networking_py_client/models/networking/v4/config/ListLayer2StretchRelatedEntitiesApiResponse.py
+ntnx_networking_py_client/models/networking/v4/config/ListLayer2StretchesApiResponse.py
+ntnx_networking_py_client/models/networking/v4/config/ListNetworkControllersApiResponse.py
+ntnx_networking_py_client/models/networking/v4/config/ListNodeSchedulableStatusesApiResponse.py
+ntnx_networking_py_client/models/networking/v4/config/ListRouteTablesApiResponse.py
+ntnx_networking_py_client/models/networking/v4/config/ListRoutingPoliciesApiResponse.py
+ntnx_networking_py_client/models/networking/v4/config/ListSubnetsApiResponse.py
+ntnx_networking_py_client/models/networking/v4/config/ListTrafficMirrorsApiResponse.py
+ntnx_networking_py_client/models/networking/v4/config/ListUplinkBondsApiResponse.py
+ntnx_networking_py_client/models/networking/v4/config/ListVirtualSwitchesApiResponse.py
+ntnx_networking_py_client/models/networking/v4/config/ListVpcVirtualSwitchMappingsApiResponse.py
+ntnx_networking_py_client/models/networking/v4/config/ListVpcsApiResponse.py
+ntnx_networking_py_client/models/networking/v4/config/ListVpnConnectionsApiResponse.py
+ntnx_networking_py_client/models/networking/v4/config/ListVpnVendorConfigsApiResponse.py
 ntnx_networking_py_client/models/networking/v4/config/LocalBgpGateway.py
 ntnx_networking_py_client/models/networking/v4/config/LocalBgpService.py
 ntnx_networking_py_client/models/networking/v4/config/LocalNetworkServices.py
 ntnx_networking_py_client/models/networking/v4/config/LocalVpnService.py
 ntnx_networking_py_client/models/networking/v4/config/LocalVtepService.py
 ntnx_networking_py_client/models/networking/v4/config/MigrationState.py
 ntnx_networking_py_client/models/networking/v4/config/NetworkCloudConfig.py
-ntnx_networking_py_client/models/networking/v4/config/NetworkCloudConfigApiResponse.py
-ntnx_networking_py_client/models/networking/v4/config/NetworkCloudConfigListApiResponse.py
 ntnx_networking_py_client/models/networking/v4/config/NetworkController.py
-ntnx_networking_py_client/models/networking/v4/config/NetworkControllerApiResponse.py
-ntnx_networking_py_client/models/networking/v4/config/NetworkControllerListApiResponse.py
 ntnx_networking_py_client/models/networking/v4/config/NetworkingBaseModel.py
 ntnx_networking_py_client/models/networking/v4/config/NexthopType.py
 ntnx_networking_py_client/models/networking/v4/config/NodeSchedulableStatus.py
-ntnx_networking_py_client/models/networking/v4/config/NodeSchedulableStatusApiResponse.py
 ntnx_networking_py_client/models/networking/v4/config/NodeSchedulableStatusProjection.py
 ntnx_networking_py_client/models/networking/v4/config/OspfConfig.py
 ntnx_networking_py_client/models/networking/v4/config/PortRange.py
 ntnx_networking_py_client/models/networking/v4/config/PrivateIpAssociation.py
 ntnx_networking_py_client/models/networking/v4/config/ProtocolNumberObject.py
 ntnx_networking_py_client/models/networking/v4/config/ProtocolType.py
 ntnx_networking_py_client/models/networking/v4/config/PublicIpMapping.py
@@ -249,92 +253,79 @@
 ntnx_networking_py_client/models/networking/v4/config/RemoteVtepStretchStatus.py
 ntnx_networking_py_client/models/networking/v4/config/RerouteFallbackAction.py
 ntnx_networking_py_client/models/networking/v4/config/RerouteParam.py
 ntnx_networking_py_client/models/networking/v4/config/ReserveType.py
 ntnx_networking_py_client/models/networking/v4/config/ReservedAddress.py
 ntnx_networking_py_client/models/networking/v4/config/Route.py
 ntnx_networking_py_client/models/networking/v4/config/RouteTable.py
-ntnx_networking_py_client/models/networking/v4/config/RouteTableApiResponse.py
-ntnx_networking_py_client/models/networking/v4/config/RouteTableListApiResponse.py
 ntnx_networking_py_client/models/networking/v4/config/RoutingPolicy.py
 ntnx_networking_py_client/models/networking/v4/config/RoutingPolicyAction.py
 ntnx_networking_py_client/models/networking/v4/config/RoutingPolicyActionType.py
-ntnx_networking_py_client/models/networking/v4/config/RoutingPolicyApiResponse.py
-ntnx_networking_py_client/models/networking/v4/config/RoutingPolicyListApiResponse.py
 ntnx_networking_py_client/models/networking/v4/config/RoutingPolicyMatchCondition.py
+ntnx_networking_py_client/models/networking/v4/config/RoutingPolicyProjection.py
 ntnx_networking_py_client/models/networking/v4/config/RoutingPolicyRule.py
 ntnx_networking_py_client/models/networking/v4/config/ScopeType.py
 ntnx_networking_py_client/models/networking/v4/config/SiteParams.py
 ntnx_networking_py_client/models/networking/v4/config/State.py
 ntnx_networking_py_client/models/networking/v4/config/Status.py
 ntnx_networking_py_client/models/networking/v4/config/StretchConnectionType.py
 ntnx_networking_py_client/models/networking/v4/config/StretchStatus.py
 ntnx_networking_py_client/models/networking/v4/config/Subnet.py
-ntnx_networking_py_client/models/networking/v4/config/SubnetApiResponse.py
 ntnx_networking_py_client/models/networking/v4/config/SubnetInfo.py
-ntnx_networking_py_client/models/networking/v4/config/SubnetListApiResponse.py
 ntnx_networking_py_client/models/networking/v4/config/SubnetProjection.py
 ntnx_networking_py_client/models/networking/v4/config/SubnetType.py
 ntnx_networking_py_client/models/networking/v4/config/TaskReferenceApiResponse.py
 ntnx_networking_py_client/models/networking/v4/config/TrafficMirror.py
-ntnx_networking_py_client/models/networking/v4/config/TrafficMirrorApiResponse.py
-ntnx_networking_py_client/models/networking/v4/config/TrafficMirrorListApiResponse.py
 ntnx_networking_py_client/models/networking/v4/config/TrafficMirrorPort.py
 ntnx_networking_py_client/models/networking/v4/config/TrafficMirrorPortNicType.py
 ntnx_networking_py_client/models/networking/v4/config/TrafficMirrorSourcePort.py
 ntnx_networking_py_client/models/networking/v4/config/TrafficMirrorSourcePortDirection.py
 ntnx_networking_py_client/models/networking/v4/config/UnreserveType.py
 ntnx_networking_py_client/models/networking/v4/config/UplinkBond.py
-ntnx_networking_py_client/models/networking/v4/config/UplinkBondApiResponse.py
 ntnx_networking_py_client/models/networking/v4/config/UplinkBondLacpStatus.py
-ntnx_networking_py_client/models/networking/v4/config/UplinkBondListApiResponse.py
 ntnx_networking_py_client/models/networking/v4/config/UplinkBondType.py
 ntnx_networking_py_client/models/networking/v4/config/UplinkBondVirtualSwitchInfo.py
 ntnx_networking_py_client/models/networking/v4/config/VirtualSwitch.py
-ntnx_networking_py_client/models/networking/v4/config/VirtualSwitchApiResponse.py
-ntnx_networking_py_client/models/networking/v4/config/VirtualSwitchListApiResponse.py
 ntnx_networking_py_client/models/networking/v4/config/VirtualSwitchProjection.py
 ntnx_networking_py_client/models/networking/v4/config/VlanSubnetMigrationSpec.py
 ntnx_networking_py_client/models/networking/v4/config/Vm.py
 ntnx_networking_py_client/models/networking/v4/config/VmNic.py
 ntnx_networking_py_client/models/networking/v4/config/VmNicAssociation.py
 ntnx_networking_py_client/models/networking/v4/config/VmNicProjection.py
 ntnx_networking_py_client/models/networking/v4/config/VmProjection.py
 ntnx_networking_py_client/models/networking/v4/config/VnicMigrationItem.py
+ntnx_networking_py_client/models/networking/v4/config/VnicMigrationItemSpec.py
 ntnx_networking_py_client/models/networking/v4/config/VnicMigrationSpec.py
 ntnx_networking_py_client/models/networking/v4/config/Vpc.py
-ntnx_networking_py_client/models/networking/v4/config/VpcApiResponse.py
 ntnx_networking_py_client/models/networking/v4/config/VpcDhcpOptions.py
-ntnx_networking_py_client/models/networking/v4/config/VpcListApiResponse.py
+ntnx_networking_py_client/models/networking/v4/config/VpcName.py
+ntnx_networking_py_client/models/networking/v4/config/VpcNameProjection.py
 ntnx_networking_py_client/models/networking/v4/config/VpcProjection.py
+ntnx_networking_py_client/models/networking/v4/config/VpcType.py
 ntnx_networking_py_client/models/networking/v4/config/VpcVirtualSwitchMapping.py
-ntnx_networking_py_client/models/networking/v4/config/VpcVirtualSwitchMappingsApiResponse.py
 ntnx_networking_py_client/models/networking/v4/config/VpnAppliance.py
 ntnx_networking_py_client/models/networking/v4/config/VpnConnection.py
-ntnx_networking_py_client/models/networking/v4/config/VpnConnectionApiResponse.py
-ntnx_networking_py_client/models/networking/v4/config/VpnConnectionListApiResponse.py
-ntnx_networking_py_client/models/networking/v4/config/VpnVendorListApiResponse.py
 ntnx_networking_py_client/models/networking/v4/config/Vtep.py
 ntnx_networking_py_client/models/networking/v4/config/__init__.py
 ntnx_networking_py_client/models/networking/v4/error/AppMessage.py
 ntnx_networking_py_client/models/networking/v4/error/ErrorResponse.py
 ntnx_networking_py_client/models/networking/v4/error/SchemaValidationError.py
 ntnx_networking_py_client/models/networking/v4/error/SchemaValidationErrorMessage.py
 ntnx_networking_py_client/models/networking/v4/error/__init__.py
+ntnx_networking_py_client/models/networking/v4/stats/GetLayer2StretchStatsApiResponse.py
+ntnx_networking_py_client/models/networking/v4/stats/GetTrafficMirrorStatsApiResponse.py
+ntnx_networking_py_client/models/networking/v4/stats/GetVpcNsStatsApiResponse.py
+ntnx_networking_py_client/models/networking/v4/stats/GetVpnConnectionStatsApiResponse.py
 ntnx_networking_py_client/models/networking/v4/stats/Layer2StretchStats.py
-ntnx_networking_py_client/models/networking/v4/stats/Layer2StretchStatsApiResponse.py
 ntnx_networking_py_client/models/networking/v4/stats/RoutingPolicyClearCountersSpec.py
 ntnx_networking_py_client/models/networking/v4/stats/StatsQueryResponseBase.py
 ntnx_networking_py_client/models/networking/v4/stats/TaskReferenceApiResponse.py
 ntnx_networking_py_client/models/networking/v4/stats/TrafficMirrorState.py
 ntnx_networking_py_client/models/networking/v4/stats/TrafficMirrorStats.py
-ntnx_networking_py_client/models/networking/v4/stats/TrafficMirrorStatsApiResponse.py
 ntnx_networking_py_client/models/networking/v4/stats/TrafficMirrorStatsData.py
 ntnx_networking_py_client/models/networking/v4/stats/VpcNsStats.py
-ntnx_networking_py_client/models/networking/v4/stats/VpcNsStatsApiResponse.py
 ntnx_networking_py_client/models/networking/v4/stats/VpnConnectionStats.py
-ntnx_networking_py_client/models/networking/v4/stats/VpnConnectionStatsApiResponse.py
 ntnx_networking_py_client/models/networking/v4/stats/__init__.py
 ntnx_networking_py_client/models/prism/__init__.py
 ntnx_networking_py_client/models/prism/v4/__init__.py
 ntnx_networking_py_client/models/prism/v4/config/TaskReference.py
 ntnx_networking_py_client/models/prism/v4/config/__init__.py
```

### Comparing `ntnx-networking-py-client-4.0.1b1/setup.py` & `ntnx_networking_py_client-4.0.2b1/setup.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,33 +3,33 @@
 
 """
 IGNORE:
     Nutanix Networking Versioned APIs
 
     Manage networking configuration on Nutanix clusters, including AHV and advanced networking.  # noqa: E501
 
-    OpenAPI spec version: 4.0.1-beta-1
+    OpenAPI spec version: 4.0.2-beta-1
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 IGNORE
 """
 import io
 import os
 from setuptools import setup, find_packages  # noqa: H301
 
 NAME = "ntnx-networking-py-client"
-VERSION = "4.0.1b1"
+VERSION = "4.0.2b1"
 # To install the library, run the following
 #
 # python setup.py install
 #
 # prerequisite: setuptools
 # http://pypi.python.org/pypi/setuptools
 
-REQUIRES = ["urllib3 ~= 1.26", "six ~= 1.16", "certifi == 2020.4.5.1", "python-dateutil ~= 2.8", "pysocks ~= 1.7"]
+REQUIRES = ["urllib3 ~= 1.26", "six ~= 1.16", "certifi >=2020.4.5.1,<=2023.11.17", "python-dateutil ~= 2.8", "pysocks ~= 1.7"]
 
 package_root_path = os.path.abspath(os.path.dirname(__file__))
 readme_file_path = os.path.join(package_root_path, "README.md")
 with io.open(readme_file_path, encoding="utf-8") as readme_file:
     readme = readme_file.read()
 
 setup(
```

