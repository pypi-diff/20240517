# Comparing `tmp/typedb_driver-2.28.2rc0-py39-none-win_amd64.whl.zip` & `tmp/typedb_driver-2.28.2rc1-py39-none-macosx_11_0_arm64.whl.zip`

## zipinfo {}

```diff
@@ -1,92 +1,92 @@
-Zip file size: 3776687 bytes, number of entries: 90
--rw-rw-rw-  2.0 fat        0 b- defN 24-May-17 11:51 typedb/__init__.py
--rw-rw-rw-  2.0 fat     4525 b- defN 24-May-17 11:51 typedb/driver.py
--rw-rw-rw-  2.0 fat 11001344 b- defN 24-May-17 11:51 typedb/native_driver_python.pyd
--rw-rw-rw-  2.0 fat    58352 b- defN 24-May-17 11:51 typedb/native_driver_wrapper.py
--rw-rw-rw-  2.0 fat        0 b- defN 24-May-17 11:51 typedb/api/__init__.py
--rw-rw-rw-  2.0 fat        0 b- defN 24-May-17 11:51 typedb/api/answer/__init__.py
--rw-rw-rw-  2.0 fat     6141 b- defN 24-May-17 11:51 typedb/api/answer/concept_map.py
--rw-rw-rw-  2.0 fat     1706 b- defN 24-May-17 11:51 typedb/api/answer/concept_map_group.py
--rw-rw-rw-  2.0 fat     1677 b- defN 24-May-17 11:51 typedb/api/answer/value_group.py
--rw-rw-rw-  2.0 fat        0 b- defN 24-May-17 11:51 typedb/api/concept/__init__.py
--rw-rw-rw-  2.0 fat     7977 b- defN 24-May-17 11:51 typedb/api/concept/concept.py
--rw-rw-rw-  2.0 fat     6658 b- defN 24-May-17 11:51 typedb/api/concept/concept_manager.py
--rw-rw-rw-  2.0 fat        0 b- defN 24-May-17 11:51 typedb/api/concept/thing/__init__.py
--rw-rw-rw-  2.0 fat     6728 b- defN 24-May-17 11:51 typedb/api/concept/thing/attribute.py
--rw-rw-rw-  2.0 fat     2107 b- defN 24-May-17 11:51 typedb/api/concept/thing/entity.py
--rw-rw-rw-  2.0 fat     4857 b- defN 24-May-17 11:51 typedb/api/concept/thing/relation.py
--rw-rw-rw-  2.0 fat     6525 b- defN 24-May-17 11:51 typedb/api/concept/thing/thing.py
--rw-rw-rw-  2.0 fat        0 b- defN 24-May-17 11:51 typedb/api/concept/type/__init__.py
--rw-rw-rw-  2.0 fat     2937 b- defN 24-May-17 11:51 typedb/api/concept/type/annotation.py
--rw-rw-rw-  2.0 fat    11023 b- defN 24-May-17 11:51 typedb/api/concept/type/attribute_type.py
--rw-rw-rw-  2.0 fat     4303 b- defN 24-May-17 11:51 typedb/api/concept/type/entity_type.py
--rw-rw-rw-  2.0 fat     7571 b- defN 24-May-17 11:51 typedb/api/concept/type/relation_type.py
--rw-rw-rw-  2.0 fat     6647 b- defN 24-May-17 11:51 typedb/api/concept/type/role_type.py
--rw-rw-rw-  2.0 fat    11534 b- defN 24-May-17 11:51 typedb/api/concept/type/thing_type.py
--rw-rw-rw-  2.0 fat     4578 b- defN 24-May-17 11:51 typedb/api/concept/type/type.py
--rw-rw-rw-  2.0 fat        0 b- defN 24-May-17 11:51 typedb/api/concept/value/__init__.py
--rw-rw-rw-  2.0 fat     7033 b- defN 24-May-17 11:51 typedb/api/concept/value/value.py
--rw-rw-rw-  2.0 fat        0 b- defN 24-May-17 11:51 typedb/api/connection/__init__.py
--rw-rw-rw-  2.0 fat     2476 b- defN 24-May-17 11:51 typedb/api/connection/credential.py
--rw-rw-rw-  2.0 fat     5646 b- defN 24-May-17 11:51 typedb/api/connection/database.py
--rw-rw-rw-  2.0 fat     3483 b- defN 24-May-17 11:51 typedb/api/connection/driver.py
--rw-rw-rw-  2.0 fat    10093 b- defN 24-May-17 11:51 typedb/api/connection/options.py
--rw-rw-rw-  2.0 fat     4386 b- defN 24-May-17 11:51 typedb/api/connection/session.py
--rw-rw-rw-  2.0 fat     4303 b- defN 24-May-17 11:51 typedb/api/connection/transaction.py
--rw-rw-rw-  2.0 fat        0 b- defN 24-May-17 11:51 typedb/api/logic/__init__.py
--rw-rw-rw-  2.0 fat     2791 b- defN 24-May-17 11:51 typedb/api/logic/explanation.py
--rw-rw-rw-  2.0 fat     2346 b- defN 24-May-17 11:51 typedb/api/logic/logic_manager.py
--rw-rw-rw-  2.0 fat     3004 b- defN 24-May-17 11:51 typedb/api/logic/rule.py
--rw-rw-rw-  2.0 fat        0 b- defN 24-May-17 11:51 typedb/api/query/__init__.py
--rw-rw-rw-  2.0 fat     6674 b- defN 24-May-17 11:51 typedb/api/query/query_manager.py
--rw-rw-rw-  2.0 fat        0 b- defN 24-May-17 11:51 typedb/api/user/__init__.py
--rw-rw-rw-  2.0 fat     3910 b- defN 24-May-17 11:51 typedb/api/user/user.py
--rw-rw-rw-  2.0 fat        0 b- defN 24-May-17 11:51 typedb/common/__init__.py
--rw-rw-rw-  2.0 fat     6305 b- defN 24-May-17 11:51 typedb/common/exception.py
--rw-rw-rw-  2.0 fat     1452 b- defN 24-May-17 11:51 typedb/common/iterator_wrapper.py
--rw-rw-rw-  2.0 fat     2889 b- defN 24-May-17 11:51 typedb/common/label.py
--rw-rw-rw-  2.0 fat     1458 b- defN 24-May-17 11:51 typedb/common/native_wrapper.py
--rw-rw-rw-  2.0 fat     1945 b- defN 24-May-17 11:51 typedb/common/promise.py
--rw-rw-rw-  2.0 fat     1254 b- defN 24-May-17 11:51 typedb/common/transitivity.py
--rw-rw-rw-  2.0 fat        0 b- defN 24-May-17 11:51 typedb/concept/__init__.py
--rw-rw-rw-  2.0 fat     1854 b- defN 24-May-17 11:51 typedb/concept/concept.py
--rw-rw-rw-  2.0 fat     6438 b- defN 24-May-17 11:51 typedb/concept/concept_factory.py
--rw-rw-rw-  2.0 fat     5961 b- defN 24-May-17 11:51 typedb/concept/concept_manager.py
--rw-rw-rw-  2.0 fat        0 b- defN 24-May-17 11:51 typedb/concept/answer/__init__.py
--rw-rw-rw-  2.0 fat     8160 b- defN 24-May-17 11:51 typedb/concept/answer/concept_map.py
--rw-rw-rw-  2.0 fat     2875 b- defN 24-May-17 11:51 typedb/concept/answer/concept_map_group.py
--rw-rw-rw-  2.0 fat     2529 b- defN 24-May-17 11:51 typedb/concept/answer/value_group.py
--rw-rw-rw-  2.0 fat        0 b- defN 24-May-17 11:51 typedb/concept/thing/__init__.py
--rw-rw-rw-  2.0 fat     3735 b- defN 24-May-17 11:51 typedb/concept/thing/attribute.py
--rw-rw-rw-  2.0 fat     1327 b- defN 24-May-17 11:51 typedb/concept/thing/entity.py
--rw-rw-rw-  2.0 fat     4388 b- defN 24-May-17 11:51 typedb/concept/thing/relation.py
--rw-rw-rw-  2.0 fat     5596 b- defN 24-May-17 11:51 typedb/concept/thing/thing.py
--rw-rw-rw-  2.0 fat        0 b- defN 24-May-17 11:51 typedb/concept/type/__init__.py
--rw-rw-rw-  2.0 fat     7897 b- defN 24-May-17 11:51 typedb/concept/type/attribute_type.py
--rw-rw-rw-  2.0 fat     4080 b- defN 24-May-17 11:51 typedb/concept/type/entity_type.py
--rw-rw-rw-  2.0 fat     6289 b- defN 24-May-17 11:51 typedb/concept/type/relation_type.py
--rw-rw-rw-  2.0 fat     6910 b- defN 24-May-17 11:51 typedb/concept/type/role_type.py
--rw-rw-rw-  2.0 fat     9846 b- defN 24-May-17 11:51 typedb/concept/type/thing_type.py
--rw-rw-rw-  2.0 fat     2089 b- defN 24-May-17 11:51 typedb/concept/type/type.py
--rw-rw-rw-  2.0 fat        0 b- defN 24-May-17 11:51 typedb/concept/value/__init__.py
--rw-rw-rw-  2.0 fat     4442 b- defN 24-May-17 11:51 typedb/concept/value/value.py
--rw-rw-rw-  2.0 fat        0 b- defN 24-May-17 11:51 typedb/connection/__init__.py
--rw-rw-rw-  2.0 fat     4519 b- defN 24-May-17 11:51 typedb/connection/database.py
--rw-rw-rw-  2.0 fat     3106 b- defN 24-May-17 11:51 typedb/connection/database_manager.py
--rw-rw-rw-  2.0 fat     4125 b- defN 24-May-17 11:51 typedb/connection/driver.py
--rw-rw-rw-  2.0 fat     3751 b- defN 24-May-17 11:51 typedb/connection/session.py
--rw-rw-rw-  2.0 fat     4666 b- defN 24-May-17 11:51 typedb/connection/transaction.py
--rw-rw-rw-  2.0 fat        0 b- defN 24-May-17 11:51 typedb/logic/__init__.py
--rw-rw-rw-  2.0 fat     3241 b- defN 24-May-17 11:51 typedb/logic/explanation.py
--rw-rw-rw-  2.0 fat     2827 b- defN 24-May-17 11:51 typedb/logic/logic_manager.py
--rw-rw-rw-  2.0 fat     3256 b- defN 24-May-17 11:51 typedb/logic/rule.py
--rw-rw-rw-  2.0 fat        0 b- defN 24-May-17 11:51 typedb/query/__init__.py
--rw-rw-rw-  2.0 fat     8437 b- defN 24-May-17 11:51 typedb/query/query_manager.py
--rw-rw-rw-  2.0 fat        0 b- defN 24-May-17 11:51 typedb/user/__init__.py
--rw-rw-rw-  2.0 fat     2232 b- defN 24-May-17 11:51 typedb/user/user.py
--rw-rw-rw-  2.0 fat     3622 b- defN 24-May-17 11:51 typedb/user/user_manager.py
--rw-rw-rw-  2.0 fat     1597 b- defN 24-May-17 11:51 typedb_driver-2.28.2rc0.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 24-May-17 11:51 typedb_driver-2.28.2rc0.dist-info/WHEEL
--rw-rw-rw-  2.0 fat       12 b- defN 24-May-17 11:51 typedb_driver-2.28.2rc0.dist-info/top_level.txt
-?rw-rw-r--  2.0 fat     7834 b- defN 24-May-17 11:51 typedb_driver-2.28.2rc0.dist-info/RECORD
-90 files, 11366371 bytes uncompressed, 3764191 bytes compressed:  66.9%
+Zip file size: 6908138 bytes, number of entries: 90
+-rw-r--r--  2.0 unx        0 b- defN 24-May-17 14:41 typedb/__init__.py
+-rw-r--r--  2.0 unx     4441 b- defN 24-May-17 14:41 typedb/driver.py
+-rwxr-xr-x  2.0 unx 21118924 b- defN 24-May-17 14:41 typedb/native_driver_python.so
+-rw-r--r--  2.0 unx    56958 b- defN 24-May-17 14:41 typedb/native_driver_wrapper.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-17 14:41 typedb/api/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-17 14:41 typedb/api/answer/__init__.py
+-rw-r--r--  2.0 unx     5900 b- defN 24-May-17 14:41 typedb/api/answer/concept_map.py
+-rw-r--r--  2.0 unx     1645 b- defN 24-May-17 14:41 typedb/api/answer/concept_map_group.py
+-rw-r--r--  2.0 unx     1616 b- defN 24-May-17 14:41 typedb/api/answer/value_group.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-17 14:41 typedb/api/concept/__init__.py
+-rw-r--r--  2.0 unx     7629 b- defN 24-May-17 14:41 typedb/api/concept/concept.py
+-rw-r--r--  2.0 unx     6411 b- defN 24-May-17 14:41 typedb/api/concept/concept_manager.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-17 14:41 typedb/api/concept/thing/__init__.py
+-rw-r--r--  2.0 unx     6437 b- defN 24-May-17 14:41 typedb/api/concept/thing/attribute.py
+-rw-r--r--  2.0 unx     2028 b- defN 24-May-17 14:41 typedb/api/concept/thing/entity.py
+-rw-r--r--  2.0 unx     4690 b- defN 24-May-17 14:41 typedb/api/concept/thing/relation.py
+-rw-r--r--  2.0 unx     6282 b- defN 24-May-17 14:41 typedb/api/concept/thing/thing.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-17 14:41 typedb/api/concept/type/__init__.py
+-rw-r--r--  2.0 unx     2833 b- defN 24-May-17 14:41 typedb/api/concept/type/annotation.py
+-rw-r--r--  2.0 unx    10665 b- defN 24-May-17 14:41 typedb/api/concept/type/attribute_type.py
+-rw-r--r--  2.0 unx     4157 b- defN 24-May-17 14:41 typedb/api/concept/type/entity_type.py
+-rw-r--r--  2.0 unx     7331 b- defN 24-May-17 14:41 typedb/api/concept/type/relation_type.py
+-rw-r--r--  2.0 unx     6418 b- defN 24-May-17 14:41 typedb/api/concept/type/role_type.py
+-rw-r--r--  2.0 unx    11167 b- defN 24-May-17 14:41 typedb/api/concept/type/thing_type.py
+-rw-r--r--  2.0 unx     4399 b- defN 24-May-17 14:41 typedb/api/concept/type/type.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-17 14:41 typedb/api/concept/value/__init__.py
+-rw-r--r--  2.0 unx     6733 b- defN 24-May-17 14:41 typedb/api/concept/value/value.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-17 14:41 typedb/api/connection/__init__.py
+-rw-r--r--  2.0 unx     2424 b- defN 24-May-17 14:41 typedb/api/connection/credential.py
+-rw-r--r--  2.0 unx     5385 b- defN 24-May-17 14:41 typedb/api/connection/database.py
+-rw-r--r--  2.0 unx     3363 b- defN 24-May-17 14:41 typedb/api/connection/driver.py
+-rw-r--r--  2.0 unx     9872 b- defN 24-May-17 14:41 typedb/api/connection/options.py
+-rw-r--r--  2.0 unx     4214 b- defN 24-May-17 14:41 typedb/api/connection/session.py
+-rw-r--r--  2.0 unx     4126 b- defN 24-May-17 14:41 typedb/api/connection/transaction.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-17 14:41 typedb/api/logic/__init__.py
+-rw-r--r--  2.0 unx     2683 b- defN 24-May-17 14:41 typedb/api/logic/explanation.py
+-rw-r--r--  2.0 unx     2266 b- defN 24-May-17 14:41 typedb/api/logic/logic_manager.py
+-rw-r--r--  2.0 unx     2898 b- defN 24-May-17 14:41 typedb/api/logic/rule.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-17 14:41 typedb/api/query/__init__.py
+-rw-r--r--  2.0 unx     6450 b- defN 24-May-17 14:41 typedb/api/query/query_manager.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-17 14:41 typedb/api/user/__init__.py
+-rw-r--r--  2.0 unx     3754 b- defN 24-May-17 14:41 typedb/api/user/user.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-17 14:41 typedb/common/__init__.py
+-rw-r--r--  2.0 unx     6143 b- defN 24-May-17 14:41 typedb/common/exception.py
+-rw-r--r--  2.0 unx     1413 b- defN 24-May-17 14:41 typedb/common/iterator_wrapper.py
+-rw-r--r--  2.0 unx     2797 b- defN 24-May-17 14:41 typedb/common/label.py
+-rw-r--r--  2.0 unx     1415 b- defN 24-May-17 14:41 typedb/common/native_wrapper.py
+-rw-r--r--  2.0 unx     1881 b- defN 24-May-17 14:41 typedb/common/promise.py
+-rw-r--r--  2.0 unx     1218 b- defN 24-May-17 14:41 typedb/common/transitivity.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-17 14:41 typedb/concept/__init__.py
+-rw-r--r--  2.0 unx     1806 b- defN 24-May-17 14:41 typedb/concept/concept.py
+-rw-r--r--  2.0 unx     6283 b- defN 24-May-17 14:41 typedb/concept/concept_factory.py
+-rw-r--r--  2.0 unx     5840 b- defN 24-May-17 14:41 typedb/concept/concept_manager.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-17 14:41 typedb/concept/answer/__init__.py
+-rw-r--r--  2.0 unx     7980 b- defN 24-May-17 14:41 typedb/concept/answer/concept_map.py
+-rw-r--r--  2.0 unx     2808 b- defN 24-May-17 14:41 typedb/concept/answer/concept_map_group.py
+-rw-r--r--  2.0 unx     2465 b- defN 24-May-17 14:41 typedb/concept/answer/value_group.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-17 14:41 typedb/concept/thing/__init__.py
+-rw-r--r--  2.0 unx     3641 b- defN 24-May-17 14:41 typedb/concept/thing/attribute.py
+-rw-r--r--  2.0 unx     1292 b- defN 24-May-17 14:41 typedb/concept/thing/entity.py
+-rw-r--r--  2.0 unx     4297 b- defN 24-May-17 14:41 typedb/concept/thing/relation.py
+-rw-r--r--  2.0 unx     5471 b- defN 24-May-17 14:41 typedb/concept/thing/thing.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-17 14:41 typedb/concept/type/__init__.py
+-rw-r--r--  2.0 unx     7724 b- defN 24-May-17 14:41 typedb/concept/type/attribute_type.py
+-rw-r--r--  2.0 unx     3993 b- defN 24-May-17 14:41 typedb/concept/type/entity_type.py
+-rw-r--r--  2.0 unx     6159 b- defN 24-May-17 14:41 typedb/concept/type/relation_type.py
+-rw-r--r--  2.0 unx     6754 b- defN 24-May-17 14:41 typedb/concept/type/role_type.py
+-rw-r--r--  2.0 unx     9628 b- defN 24-May-17 14:41 typedb/concept/type/thing_type.py
+-rw-r--r--  2.0 unx     2030 b- defN 24-May-17 14:41 typedb/concept/type/type.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-17 14:41 typedb/concept/value/__init__.py
+-rw-r--r--  2.0 unx     4311 b- defN 24-May-17 14:41 typedb/concept/value/value.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-17 14:41 typedb/connection/__init__.py
+-rw-r--r--  2.0 unx     4401 b- defN 24-May-17 14:41 typedb/connection/database.py
+-rw-r--r--  2.0 unx     3032 b- defN 24-May-17 14:41 typedb/connection/database_manager.py
+-rw-r--r--  2.0 unx     4028 b- defN 24-May-17 14:41 typedb/connection/driver.py
+-rw-r--r--  2.0 unx     3656 b- defN 24-May-17 14:41 typedb/connection/session.py
+-rw-r--r--  2.0 unx     4547 b- defN 24-May-17 14:41 typedb/connection/transaction.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-17 14:41 typedb/logic/__init__.py
+-rw-r--r--  2.0 unx     3164 b- defN 24-May-17 14:41 typedb/logic/explanation.py
+-rw-r--r--  2.0 unx     2761 b- defN 24-May-17 14:41 typedb/logic/logic_manager.py
+-rw-r--r--  2.0 unx     3170 b- defN 24-May-17 14:41 typedb/logic/rule.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-17 14:41 typedb/query/__init__.py
+-rw-r--r--  2.0 unx     8247 b- defN 24-May-17 14:41 typedb/query/query_manager.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-17 14:41 typedb/user/__init__.py
+-rw-r--r--  2.0 unx     2177 b- defN 24-May-17 14:41 typedb/user/user.py
+-rw-r--r--  2.0 unx     3534 b- defN 24-May-17 14:41 typedb/user/user_manager.py
+-rw-r--r--  2.0 unx     1553 b- defN 24-May-17 14:41 typedb_driver-2.28.2rc1.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 24-May-17 14:41 typedb_driver-2.28.2rc1.dist-info/WHEEL
+-rw-r--r--  2.0 unx       12 b- defN 24-May-17 14:41 typedb_driver-2.28.2rc1.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     7832 b- defN 24-May-17 14:41 typedb_driver-2.28.2rc1.dist-info/RECORD
+90 files, 21473654 bytes uncompressed, 6895644 bytes compressed:  67.9%
```

## zipnote {}

```diff
@@ -1,14 +1,14 @@
 Filename: typedb/__init__.py
 Comment: 
 
 Filename: typedb/driver.py
 Comment: 
 
-Filename: typedb/native_driver_python.pyd
+Filename: typedb/native_driver_python.so
 Comment: 
 
 Filename: typedb/native_driver_wrapper.py
 Comment: 
 
 Filename: typedb/api/__init__.py
 Comment: 
@@ -252,20 +252,20 @@
 
 Filename: typedb/user/user.py
 Comment: 
 
 Filename: typedb/user/user_manager.py
 Comment: 
 
-Filename: typedb_driver-2.28.2rc0.dist-info/METADATA
+Filename: typedb_driver-2.28.2rc1.dist-info/METADATA
 Comment: 
 
-Filename: typedb_driver-2.28.2rc0.dist-info/WHEEL
+Filename: typedb_driver-2.28.2rc1.dist-info/WHEEL
 Comment: 
 
-Filename: typedb_driver-2.28.2rc0.dist-info/top_level.txt
+Filename: typedb_driver-2.28.2rc1.dist-info/top_level.txt
 Comment: 
 
-Filename: typedb_driver-2.28.2rc0.dist-info/RECORD
+Filename: typedb_driver-2.28.2rc1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## typedb/driver.py

 * *Ordering differences only*

```diff
@@ -1,84 +1,84 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from collections.abc import Mapping as ABCMapping
-from typing import Iterable, Mapping, Union
-
-from typedb.api.answer.concept_map import *  # noqa # pylint: disable=unused-import
-from typedb.api.answer.concept_map_group import *  # noqa # pylint: disable=unused-import
-from typedb.api.answer.value_group import *  # noqa # pylint: disable=unused-import
-from typedb.api.concept.concept import *  # noqa # pylint: disable=unused-import
-from typedb.api.concept.concept_manager import *  # noqa # pylint: disable=unused-import
-from typedb.api.concept.thing.attribute import *  # noqa # pylint: disable=unused-import
-from typedb.api.concept.thing.entity import *  # noqa # pylint: disable=unused-import
-from typedb.api.concept.thing.relation import *  # noqa # pylint: disable=unused-import
-from typedb.api.concept.thing.thing import *  # noqa # pylint: disable=unused-import
-from typedb.api.concept.type.annotation import *  # noqa # pylint: disable=unused-import
-from typedb.api.concept.type.attribute_type import *  # noqa # pylint: disable=unused-import
-from typedb.api.concept.type.entity_type import *  # noqa # pylint: disable=unused-import
-from typedb.api.concept.type.relation_type import *  # noqa # pylint: disable=unused-import
-from typedb.api.concept.type.role_type import *  # noqa # pylint: disable=unused-import
-from typedb.api.concept.type.thing_type import *  # noqa # pylint: disable=unused-import
-from typedb.api.concept.type.type import *  # noqa # pylint: disable=unused-import
-from typedb.api.concept.value import *  # noqa # pylint: disable=unused-import
-from typedb.api.connection.driver import *
-from typedb.api.connection.credential import *
-from typedb.api.connection.database import *  # noqa # pylint: disable=unused-import
-from typedb.api.connection.options import *  # noqa # pylint: disable=unused-import
-from typedb.api.connection.session import *  # noqa # pylint: disable=unused-import
-from typedb.api.connection.transaction import *  # noqa # pylint: disable=unused-import
-from typedb.api.logic.explanation import *  # noqa # pylint: disable=unused-import
-from typedb.api.logic.logic_manager import *  # noqa # pylint: disable=unused-import
-from typedb.api.logic.rule import *  # noqa # pylint: disable=unused-import
-from typedb.api.query.query_manager import *  # noqa # pylint: disable=unused-import
-from typedb.api.user.user import *  # noqa # pylint: disable=unused-import
-from typedb.common.exception import *  # noqa # pylint: disable=unused-import
-from typedb.common.label import *  # noqa # pylint: disable=unused-import
-from typedb.common.transitivity import *  # noqa # pylint: disable=unused-import
-from typedb.connection.driver import _Driver
-
-# Repackaging these symbols allows them to be imported from "typedb.driver"
-
-
-class TypeDB:
-    DEFAULT_ADDRESS = "localhost:1729"
-
-    @staticmethod
-    def core_driver(address: str) -> TypeDBDriver:
-        """
-        Creates a connection to TypeDB.
-
-        :param address: Address of the TypeDB server.
-        :return:
-        """
-        return _Driver([address])
-
-    @staticmethod
-    def cloud_driver(addresses: Union[Mapping[str, str], Iterable[str], str], credential: TypeDBCredential) -> TypeDBDriver:
-        """
-        Creates a connection to TypeDB Cloud, authenticating with the provided credentials.
-
-        :param addresses:
-        :param credential:
-        :return:
-        """
-        if isinstance(addresses, str):
-            return _Driver([addresses], credential)
-        elif isinstance(addresses, ABCMapping):
-            return _Driver(dict(addresses), credential)
-        else:
-            return _Driver(list(addresses), credential)
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from collections.abc import Mapping as ABCMapping
+from typing import Iterable, Mapping, Union
+
+from typedb.api.answer.concept_map import *  # noqa # pylint: disable=unused-import
+from typedb.api.answer.concept_map_group import *  # noqa # pylint: disable=unused-import
+from typedb.api.answer.value_group import *  # noqa # pylint: disable=unused-import
+from typedb.api.concept.concept import *  # noqa # pylint: disable=unused-import
+from typedb.api.concept.concept_manager import *  # noqa # pylint: disable=unused-import
+from typedb.api.concept.thing.attribute import *  # noqa # pylint: disable=unused-import
+from typedb.api.concept.thing.entity import *  # noqa # pylint: disable=unused-import
+from typedb.api.concept.thing.relation import *  # noqa # pylint: disable=unused-import
+from typedb.api.concept.thing.thing import *  # noqa # pylint: disable=unused-import
+from typedb.api.concept.type.annotation import *  # noqa # pylint: disable=unused-import
+from typedb.api.concept.type.attribute_type import *  # noqa # pylint: disable=unused-import
+from typedb.api.concept.type.entity_type import *  # noqa # pylint: disable=unused-import
+from typedb.api.concept.type.relation_type import *  # noqa # pylint: disable=unused-import
+from typedb.api.concept.type.role_type import *  # noqa # pylint: disable=unused-import
+from typedb.api.concept.type.thing_type import *  # noqa # pylint: disable=unused-import
+from typedb.api.concept.type.type import *  # noqa # pylint: disable=unused-import
+from typedb.api.concept.value import *  # noqa # pylint: disable=unused-import
+from typedb.api.connection.driver import *
+from typedb.api.connection.credential import *
+from typedb.api.connection.database import *  # noqa # pylint: disable=unused-import
+from typedb.api.connection.options import *  # noqa # pylint: disable=unused-import
+from typedb.api.connection.session import *  # noqa # pylint: disable=unused-import
+from typedb.api.connection.transaction import *  # noqa # pylint: disable=unused-import
+from typedb.api.logic.explanation import *  # noqa # pylint: disable=unused-import
+from typedb.api.logic.logic_manager import *  # noqa # pylint: disable=unused-import
+from typedb.api.logic.rule import *  # noqa # pylint: disable=unused-import
+from typedb.api.query.query_manager import *  # noqa # pylint: disable=unused-import
+from typedb.api.user.user import *  # noqa # pylint: disable=unused-import
+from typedb.common.exception import *  # noqa # pylint: disable=unused-import
+from typedb.common.label import *  # noqa # pylint: disable=unused-import
+from typedb.common.transitivity import *  # noqa # pylint: disable=unused-import
+from typedb.connection.driver import _Driver
+
+# Repackaging these symbols allows them to be imported from "typedb.driver"
+
+
+class TypeDB:
+    DEFAULT_ADDRESS = "localhost:1729"
+
+    @staticmethod
+    def core_driver(address: str) -> TypeDBDriver:
+        """
+        Creates a connection to TypeDB.
+
+        :param address: Address of the TypeDB server.
+        :return:
+        """
+        return _Driver([address])
+
+    @staticmethod
+    def cloud_driver(addresses: Union[Mapping[str, str], Iterable[str], str], credential: TypeDBCredential) -> TypeDBDriver:
+        """
+        Creates a connection to TypeDB Cloud, authenticating with the provided credentials.
+
+        :param addresses:
+        :param credential:
+        :return:
+        """
+        if isinstance(addresses, str):
+            return _Driver([addresses], credential)
+        elif isinstance(addresses, ABCMapping):
+            return _Driver(dict(addresses), credential)
+        else:
+            return _Driver(list(addresses), credential)
```

## typedb/native_driver_wrapper.py

 * *Ordering differences only*

```diff
@@ -1,1394 +1,1394 @@
-# This file was automatically generated by SWIG (https://www.swig.org).
-# Version 4.1.1
-#
-# Do not make changes to this file unless you know what you are doing - modify
-# the SWIG interface file instead.
-
-from sys import version_info as _swig_python_version_info
-# Import the low-level C/C++ module
-if __package__ or "." in __name__:
-    from . import native_driver_python
-else:
-    import native_driver_python
-
-try:
-    import builtins as __builtin__
-except ImportError:
-    import __builtin__
-
-def _swig_repr(self):
-    try:
-        strthis = "proxy of " + self.this.__repr__()
-    except __builtin__.Exception:
-        strthis = ""
-    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)
-
-
-def _swig_setattr_nondynamic_instance_variable(set):
-    def set_instance_attr(self, name, value):
-        if name == "this":
-            set(self, name, value)
-        elif name == "thisown":
-            self.this.own(value)
-        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
-            set(self, name, value)
-        else:
-            raise AttributeError("You cannot add instance attributes to %s" % self)
-    return set_instance_attr
-
-
-def _swig_setattr_nondynamic_class_variable(set):
-    def set_class_attr(cls, name, value):
-        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
-            set(cls, name, value)
-        else:
-            raise AttributeError("You cannot add class attributes to %s" % cls)
-    return set_class_attr
-
-
-def _swig_add_metaclass(metaclass):
-    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
-    def wrapper(cls):
-        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
-    return wrapper
-
-
-class _SwigNonDynamicMeta(type):
-    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
-    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)
-
-
-import weakref
-
-
-TypeDBDriverExceptionNative = native_driver_python.TypeDBDriverExceptionNative
-
-native_driver_python.init_logging()
-
-class Error(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined")
-    __repr__ = _swig_repr
-    __swig_destroy__ = native_driver_python.delete_Error
-
-# Register Error in native_driver_python:
-native_driver_python.Error_swigregister(Error)
-class SchemaException(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined")
-    __repr__ = _swig_repr
-    __swig_destroy__ = native_driver_python.delete_SchemaException
-
-# Register SchemaException in native_driver_python:
-native_driver_python.SchemaException_swigregister(SchemaException)
-class SchemaExceptionIterator(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined")
-    __repr__ = _swig_repr
-    __swig_destroy__ = native_driver_python.delete_SchemaExceptionIterator
-
-# Register SchemaExceptionIterator in native_driver_python:
-native_driver_python.SchemaExceptionIterator_swigregister(SchemaExceptionIterator)
-class Credential(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined")
-    __repr__ = _swig_repr
-    __swig_destroy__ = native_driver_python.delete_Credential
-
-# Register Credential in native_driver_python:
-native_driver_python.Credential_swigregister(Credential)
-class Options(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined")
-    __repr__ = _swig_repr
-    __swig_destroy__ = native_driver_python.delete_Options
-
-# Register Options in native_driver_python:
-native_driver_python.Options_swigregister(Options)
-class Connection(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined")
-    __repr__ = _swig_repr
-    __swig_destroy__ = native_driver_python.delete_Connection
-
-# Register Connection in native_driver_python:
-native_driver_python.Connection_swigregister(Connection)
-class Session(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined")
-    __repr__ = _swig_repr
-    __swig_destroy__ = native_driver_python.delete_Session
-
-# Register Session in native_driver_python:
-native_driver_python.Session_swigregister(Session)
-class Transaction(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined")
-    __repr__ = _swig_repr
-    __swig_destroy__ = native_driver_python.delete_Transaction
-
-# Register Transaction in native_driver_python:
-native_driver_python.Transaction_swigregister(Transaction)
-class DatabaseManager(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined")
-    __repr__ = _swig_repr
-    __swig_destroy__ = native_driver_python.delete_DatabaseManager
-
-# Register DatabaseManager in native_driver_python:
-native_driver_python.DatabaseManager_swigregister(DatabaseManager)
-class Database(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined")
-    __repr__ = _swig_repr
-    __swig_destroy__ = native_driver_python.delete_Database
-
-# Register Database in native_driver_python:
-native_driver_python.Database_swigregister(Database)
-class DatabaseIterator(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined")
-    __repr__ = _swig_repr
-    __swig_destroy__ = native_driver_python.delete_DatabaseIterator
-
-# Register DatabaseIterator in native_driver_python:
-native_driver_python.DatabaseIterator_swigregister(DatabaseIterator)
-class ReplicaInfo(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined")
-    __repr__ = _swig_repr
-    __swig_destroy__ = native_driver_python.delete_ReplicaInfo
-
-# Register ReplicaInfo in native_driver_python:
-native_driver_python.ReplicaInfo_swigregister(ReplicaInfo)
-class ReplicaInfoIterator(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined")
-    __repr__ = _swig_repr
-    __swig_destroy__ = native_driver_python.delete_ReplicaInfoIterator
-
-# Register ReplicaInfoIterator in native_driver_python:
-native_driver_python.ReplicaInfoIterator_swigregister(ReplicaInfoIterator)
-class UserManager(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined")
-    __repr__ = _swig_repr
-    __swig_destroy__ = native_driver_python.delete_UserManager
-
-# Register UserManager in native_driver_python:
-native_driver_python.UserManager_swigregister(UserManager)
-class User(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined")
-    __repr__ = _swig_repr
-    __swig_destroy__ = native_driver_python.delete_User
-
-# Register User in native_driver_python:
-native_driver_python.User_swigregister(User)
-class UserIterator(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined")
-    __repr__ = _swig_repr
-    __swig_destroy__ = native_driver_python.delete_UserIterator
-
-# Register UserIterator in native_driver_python:
-native_driver_python.UserIterator_swigregister(UserIterator)
-class Concept(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined")
-    __repr__ = _swig_repr
-    __swig_destroy__ = native_driver_python.delete_Concept
-
-# Register Concept in native_driver_python:
-native_driver_python.Concept_swigregister(Concept)
-class ConceptIterator(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined")
-    __repr__ = _swig_repr
-    __swig_destroy__ = native_driver_python.delete_ConceptIterator
-
-# Register ConceptIterator in native_driver_python:
-native_driver_python.ConceptIterator_swigregister(ConceptIterator)
-class Annotation(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined")
-    __repr__ = _swig_repr
-    __swig_destroy__ = native_driver_python.delete_Annotation
-
-# Register Annotation in native_driver_python:
-native_driver_python.Annotation_swigregister(Annotation)
-class RolePlayer(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined")
-    __repr__ = _swig_repr
-    __swig_destroy__ = native_driver_python.delete_RolePlayer
-
-# Register RolePlayer in native_driver_python:
-native_driver_python.RolePlayer_swigregister(RolePlayer)
-class RolePlayerIterator(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined")
-    __repr__ = _swig_repr
-    __swig_destroy__ = native_driver_python.delete_RolePlayerIterator
-
-# Register RolePlayerIterator in native_driver_python:
-native_driver_python.RolePlayerIterator_swigregister(RolePlayerIterator)
-class ConceptMap(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined")
-    __repr__ = _swig_repr
-    __swig_destroy__ = native_driver_python.delete_ConceptMap
-
-# Register ConceptMap in native_driver_python:
-native_driver_python.ConceptMap_swigregister(ConceptMap)
-class ConceptMapIterator(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined")
-    __repr__ = _swig_repr
-    __swig_destroy__ = native_driver_python.delete_ConceptMapIterator
-
-# Register ConceptMapIterator in native_driver_python:
-native_driver_python.ConceptMapIterator_swigregister(ConceptMapIterator)
-class Explainables(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined")
-    __repr__ = _swig_repr
-    __swig_destroy__ = native_driver_python.delete_Explainables
-
-# Register Explainables in native_driver_python:
-native_driver_python.Explainables_swigregister(Explainables)
-class Explainable(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined")
-    __repr__ = _swig_repr
-    __swig_destroy__ = native_driver_python.delete_Explainable
-
-# Register Explainable in native_driver_python:
-native_driver_python.Explainable_swigregister(Explainable)
-class ConceptMapGroup(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined")
-    __repr__ = _swig_repr
-    __swig_destroy__ = native_driver_python.delete_ConceptMapGroup
-
-# Register ConceptMapGroup in native_driver_python:
-native_driver_python.ConceptMapGroup_swigregister(ConceptMapGroup)
-class ConceptMapGroupIterator(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined")
-    __repr__ = _swig_repr
-    __swig_destroy__ = native_driver_python.delete_ConceptMapGroupIterator
-
-# Register ConceptMapGroupIterator in native_driver_python:
-native_driver_python.ConceptMapGroupIterator_swigregister(ConceptMapGroupIterator)
-class StringIterator(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined")
-    __repr__ = _swig_repr
-    __swig_destroy__ = native_driver_python.delete_StringIterator
-
-# Register StringIterator in native_driver_python:
-native_driver_python.StringIterator_swigregister(StringIterator)
-class StringPairIterator(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined")
-    __repr__ = _swig_repr
-    __swig_destroy__ = native_driver_python.delete_StringPairIterator
-
-# Register StringPairIterator in native_driver_python:
-native_driver_python.StringPairIterator_swigregister(StringPairIterator)
-class ValueGroup(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined")
-    __repr__ = _swig_repr
-    __swig_destroy__ = native_driver_python.delete_ValueGroup
-
-# Register ValueGroup in native_driver_python:
-native_driver_python.ValueGroup_swigregister(ValueGroup)
-class ValueGroupIterator(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined")
-    __repr__ = _swig_repr
-    __swig_destroy__ = native_driver_python.delete_ValueGroupIterator
-
-# Register ValueGroupIterator in native_driver_python:
-native_driver_python.ValueGroupIterator_swigregister(ValueGroupIterator)
-class Explanation(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined")
-    __repr__ = _swig_repr
-    __swig_destroy__ = native_driver_python.delete_Explanation
-
-# Register Explanation in native_driver_python:
-native_driver_python.Explanation_swigregister(Explanation)
-class ExplanationIterator(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined")
-    __repr__ = _swig_repr
-    __swig_destroy__ = native_driver_python.delete_ExplanationIterator
-
-# Register ExplanationIterator in native_driver_python:
-native_driver_python.ExplanationIterator_swigregister(ExplanationIterator)
-class Rule(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined")
-    __repr__ = _swig_repr
-    __swig_destroy__ = native_driver_python.delete_Rule
-
-# Register Rule in native_driver_python:
-native_driver_python.Rule_swigregister(Rule)
-class RuleIterator(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined")
-    __repr__ = _swig_repr
-    __swig_destroy__ = native_driver_python.delete_RuleIterator
-
-# Register RuleIterator in native_driver_python:
-native_driver_python.RuleIterator_swigregister(RuleIterator)
-class BoolPromise(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined")
-    __repr__ = _swig_repr
-    __swig_destroy__ = native_driver_python.delete_BoolPromise
-
-# Register BoolPromise in native_driver_python:
-native_driver_python.BoolPromise_swigregister(BoolPromise)
-class ConceptPromise(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined")
-    __repr__ = _swig_repr
-    __swig_destroy__ = native_driver_python.delete_ConceptPromise
-
-# Register ConceptPromise in native_driver_python:
-native_driver_python.ConceptPromise_swigregister(ConceptPromise)
-class RulePromise(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined")
-    __repr__ = _swig_repr
-    __swig_destroy__ = native_driver_python.delete_RulePromise
-
-# Register RulePromise in native_driver_python:
-native_driver_python.RulePromise_swigregister(RulePromise)
-class StringPromise(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined")
-    __repr__ = _swig_repr
-    __swig_destroy__ = native_driver_python.delete_StringPromise
-
-# Register StringPromise in native_driver_python:
-native_driver_python.StringPromise_swigregister(StringPromise)
-class VoidPromise(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined")
-    __repr__ = _swig_repr
-    __swig_destroy__ = native_driver_python.delete_VoidPromise
-
-# Register VoidPromise in native_driver_python:
-native_driver_python.VoidPromise_swigregister(VoidPromise)
-class SessionCallbackDirector(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self):
-        if self.__class__ == SessionCallbackDirector:
-            _self = None
-        else:
-            _self = self
-        native_driver_python.SessionCallbackDirector_swiginit(self, native_driver_python.new_SessionCallbackDirector(_self, ))
-    __swig_destroy__ = native_driver_python.delete_SessionCallbackDirector
-
-    def callback(self):
-        return native_driver_python.SessionCallbackDirector_callback(self)
-    def __disown__(self):
-        self.this.disown()
-        native_driver_python.disown_SessionCallbackDirector(self)
-        return weakref.proxy(self)
-
-# Register SessionCallbackDirector in native_driver_python:
-native_driver_python.SessionCallbackDirector_swigregister(SessionCallbackDirector)
-
-def session_callback_register(handler):
-    return native_driver_python.session_callback_register(handler)
-
-def session_callback_execute(ID):
-    return native_driver_python.session_callback_execute(ID)
-
-def session_callback_erase(ID):
-    return native_driver_python.session_callback_erase(ID)
-
-def session_on_close(session, handler):
-    return native_driver_python.session_on_close(session, handler)
-
-def session_on_reopen(session, handler):
-    return native_driver_python.session_on_reopen(session, handler)
-class TransactionCallbackDirector(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self):
-        if self.__class__ == TransactionCallbackDirector:
-            _self = None
-        else:
-            _self = self
-        native_driver_python.TransactionCallbackDirector_swiginit(self, native_driver_python.new_TransactionCallbackDirector(_self, ))
-    __swig_destroy__ = native_driver_python.delete_TransactionCallbackDirector
-
-    def callback(self, arg0):
-        return native_driver_python.TransactionCallbackDirector_callback(self, arg0)
-    def __disown__(self):
-        self.this.disown()
-        native_driver_python.disown_TransactionCallbackDirector(self)
-        return weakref.proxy(self)
-
-# Register TransactionCallbackDirector in native_driver_python:
-native_driver_python.TransactionCallbackDirector_swigregister(TransactionCallbackDirector)
-cvar = native_driver_python.cvar
-
-
-def transaction_on_close(transaction, handler):
-    return native_driver_python.transaction_on_close(transaction, handler)
-Data = native_driver_python.Data
-Schema = native_driver_python.Schema
-Read = native_driver_python.Read
-Write = native_driver_python.Write
-Explicit = native_driver_python.Explicit
-Transitive = native_driver_python.Transitive
-Object = native_driver_python.Object
-Boolean = native_driver_python.Boolean
-Long = native_driver_python.Long
-Double = native_driver_python.Double
-String = native_driver_python.String
-DateTime = native_driver_python.DateTime
-class StringPair(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined")
-    __repr__ = _swig_repr
-    _0 = property(native_driver_python.StringPair__0_get, native_driver_python.StringPair__0_set)
-    _1 = property(native_driver_python.StringPair__1_get, native_driver_python.StringPair__1_set)
-    __swig_destroy__ = native_driver_python.delete_StringPair
-
-# Register StringPair in native_driver_python:
-native_driver_python.StringPair_swigregister(StringPair)
-
-def concept_map_get_variables(concept_map):
-    return native_driver_python.concept_map_get_variables(concept_map)
-
-def concept_map_get_values(concept_map):
-    return native_driver_python.concept_map_get_values(concept_map)
-
-def concept_map_get(concept_map, var):
-    return native_driver_python.concept_map_get(concept_map, var)
-
-def concept_map_get_explainables(concept_map):
-    return native_driver_python.concept_map_get_explainables(concept_map)
-
-def concept_map_equals(lhs, rhs):
-    return native_driver_python.concept_map_equals(lhs, rhs)
-
-def concept_map_to_string(concept_map):
-    return native_driver_python.concept_map_to_string(concept_map)
-
-def explainables_equals(lhs, rhs):
-    return native_driver_python.explainables_equals(lhs, rhs)
-
-def explainables_to_string(explainables):
-    return native_driver_python.explainables_to_string(explainables)
-
-def explainables_get_relation(explainables, var):
-    return native_driver_python.explainables_get_relation(explainables, var)
-
-def explainables_get_attribute(explainables, var):
-    return native_driver_python.explainables_get_attribute(explainables, var)
-
-def explainables_get_ownership(explainables, owner, attribute):
-    return native_driver_python.explainables_get_ownership(explainables, owner, attribute)
-
-def explainables_get_relations_keys(explainables):
-    return native_driver_python.explainables_get_relations_keys(explainables)
-
-def explainables_get_attributes_keys(explainables):
-    return native_driver_python.explainables_get_attributes_keys(explainables)
-
-def explainables_get_ownerships_keys(explainables):
-    return native_driver_python.explainables_get_ownerships_keys(explainables)
-
-def explainable_get_id(explainable):
-    return native_driver_python.explainable_get_id(explainable)
-
-def explainable_get_conjunction(explainable):
-    return native_driver_python.explainable_get_conjunction(explainable)
-
-def explanation_equals(lhs, rhs):
-    return native_driver_python.explanation_equals(lhs, rhs)
-
-def explanation_to_string(explanation):
-    return native_driver_python.explanation_to_string(explanation)
-
-def explanation_get_rule(explanation):
-    return native_driver_python.explanation_get_rule(explanation)
-
-def explanation_get_conclusion(explanation):
-    return native_driver_python.explanation_get_conclusion(explanation)
-
-def explanation_get_condition(explanation):
-    return native_driver_python.explanation_get_condition(explanation)
-
-def explanation_get_mapped_variables(explanation):
-    return native_driver_python.explanation_get_mapped_variables(explanation)
-
-def explanation_get_mapping(explanation, var):
-    return native_driver_python.explanation_get_mapping(explanation, var)
-
-def concept_map_group_get_owner(concept_map_group):
-    return native_driver_python.concept_map_group_get_owner(concept_map_group)
-
-def concept_map_group_get_concept_maps(concept_map_group):
-    return native_driver_python.concept_map_group_get_concept_maps(concept_map_group)
-
-def concept_map_group_to_string(concept_map_group):
-    return native_driver_python.concept_map_group_to_string(concept_map_group)
-
-def concept_map_group_equals(lhs, rhs):
-    return native_driver_python.concept_map_group_equals(lhs, rhs)
-
-def value_group_to_string(value_group):
-    return native_driver_python.value_group_to_string(value_group)
-
-def value_group_equals(lhs, rhs):
-    return native_driver_python.value_group_equals(lhs, rhs)
-
-def value_group_get_owner(value_group):
-    return native_driver_python.value_group_get_owner(value_group)
-
-def value_group_get_value(value_group):
-    return native_driver_python.value_group_get_value(value_group)
-
-def string_iterator_next(it):
-    return native_driver_python.string_iterator_next(it)
-
-def string_pair_drop(string_pair):
-    return native_driver_python.string_pair_drop(string_pair)
-
-def string_pair_iterator_next(it):
-    return native_driver_python.string_pair_iterator_next(it)
-
-def concept_promise_resolve(promise):
-    return native_driver_python.concept_promise_resolve(promise)
-
-def concept_iterator_next(it):
-    return native_driver_python.concept_iterator_next(it)
-
-def role_player_iterator_next(it):
-    return native_driver_python.role_player_iterator_next(it)
-
-def role_player_get_role_type(role_player):
-    return native_driver_python.role_player_get_role_type(role_player)
-
-def role_player_get_player(role_player):
-    return native_driver_python.role_player_get_player(role_player)
-
-def value_new_boolean(bool_):
-    return native_driver_python.value_new_boolean(bool_)
-
-def value_new_long(long_):
-    return native_driver_python.value_new_long(long_)
-
-def value_new_double(double_):
-    return native_driver_python.value_new_double(double_)
-
-def value_new_string(string):
-    return native_driver_python.value_new_string(string)
-
-def value_new_date_time_from_millis(millis):
-    return native_driver_python.value_new_date_time_from_millis(millis)
-
-def value_is_boolean(value):
-    return native_driver_python.value_is_boolean(value)
-
-def value_is_long(value):
-    return native_driver_python.value_is_long(value)
-
-def value_is_double(value):
-    return native_driver_python.value_is_double(value)
-
-def value_is_string(value):
-    return native_driver_python.value_is_string(value)
-
-def value_is_date_time(value):
-    return native_driver_python.value_is_date_time(value)
-
-def value_get_boolean(value):
-    return native_driver_python.value_get_boolean(value)
-
-def value_get_long(value):
-    return native_driver_python.value_get_long(value)
-
-def value_get_double(value):
-    return native_driver_python.value_get_double(value)
-
-def value_get_string(value):
-    return native_driver_python.value_get_string(value)
-
-def value_get_date_time_as_millis(value):
-    return native_driver_python.value_get_date_time_as_millis(value)
-
-def annotation_new_key():
-    return native_driver_python.annotation_new_key()
-
-def annotation_new_unique():
-    return native_driver_python.annotation_new_unique()
-
-def annotation_to_string(annotation):
-    return native_driver_python.annotation_to_string(annotation)
-
-def annotation_equals(lhs, rhs):
-    return native_driver_python.annotation_equals(lhs, rhs)
-
-def annotation_is_key(annotation):
-    return native_driver_python.annotation_is_key(annotation)
-
-def annotation_is_unique(annotation):
-    return native_driver_python.annotation_is_unique(annotation)
-
-def concept_equals(lhs, rhs):
-    return native_driver_python.concept_equals(lhs, rhs)
-
-def concept_is_entity(concept):
-    return native_driver_python.concept_is_entity(concept)
-
-def concept_is_relation(concept):
-    return native_driver_python.concept_is_relation(concept)
-
-def concept_is_attribute(concept):
-    return native_driver_python.concept_is_attribute(concept)
-
-def concept_is_value(concept):
-    return native_driver_python.concept_is_value(concept)
-
-def concept_is_root_thing_type(concept):
-    return native_driver_python.concept_is_root_thing_type(concept)
-
-def concept_is_entity_type(concept):
-    return native_driver_python.concept_is_entity_type(concept)
-
-def concept_is_relation_type(concept):
-    return native_driver_python.concept_is_relation_type(concept)
-
-def concept_is_attribute_type(concept):
-    return native_driver_python.concept_is_attribute_type(concept)
-
-def concept_is_role_type(concept):
-    return native_driver_python.concept_is_role_type(concept)
-
-def concept_to_string(concept):
-    return native_driver_python.concept_to_string(concept)
-
-def concepts_get_root_entity_type():
-    return native_driver_python.concepts_get_root_entity_type()
-
-def concepts_get_root_relation_type():
-    return native_driver_python.concepts_get_root_relation_type()
-
-def concepts_get_root_attribute_type():
-    return native_driver_python.concepts_get_root_attribute_type()
-
-def concepts_get_entity_type(transaction, label):
-    return native_driver_python.concepts_get_entity_type(transaction, label)
-
-def concepts_get_relation_type(transaction, label):
-    return native_driver_python.concepts_get_relation_type(transaction, label)
-
-def concepts_get_attribute_type(transaction, label):
-    return native_driver_python.concepts_get_attribute_type(transaction, label)
-
-def concepts_put_entity_type(transaction, label):
-    return native_driver_python.concepts_put_entity_type(transaction, label)
-
-def concepts_put_relation_type(transaction, label):
-    return native_driver_python.concepts_put_relation_type(transaction, label)
-
-def concepts_put_attribute_type(transaction, label, value_type):
-    return native_driver_python.concepts_put_attribute_type(transaction, label, value_type)
-
-def concepts_get_entity(transaction, iid):
-    return native_driver_python.concepts_get_entity(transaction, iid)
-
-def concepts_get_relation(transaction, iid):
-    return native_driver_python.concepts_get_relation(transaction, iid)
-
-def concepts_get_attribute(transaction, iid):
-    return native_driver_python.concepts_get_attribute(transaction, iid)
-
-def schema_exception_iterator_next(it):
-    return native_driver_python.schema_exception_iterator_next(it)
-
-def schema_exception_code(schema_exception):
-    return native_driver_python.schema_exception_code(schema_exception)
-
-def schema_exception_message(schema_exception):
-    return native_driver_python.schema_exception_message(schema_exception)
-
-def concepts_get_schema_exceptions(transaction):
-    return native_driver_python.concepts_get_schema_exceptions(transaction)
-
-def thing_get_iid(thing):
-    return native_driver_python.thing_get_iid(thing)
-
-def thing_get_is_inferred(thing):
-    return native_driver_python.thing_get_is_inferred(thing)
-
-def entity_get_type(entity):
-    return native_driver_python.entity_get_type(entity)
-
-def relation_get_type(relation):
-    return native_driver_python.relation_get_type(relation)
-
-def attribute_get_type(attribute):
-    return native_driver_python.attribute_get_type(attribute)
-
-def attribute_get_value(attribute):
-    return native_driver_python.attribute_get_value(attribute)
-
-def thing_delete(transaction, thing):
-    return native_driver_python.thing_delete(transaction, thing)
-
-def thing_is_deleted(transaction, thing):
-    return native_driver_python.thing_is_deleted(transaction, thing)
-
-def thing_get_has(transaction, thing, attribute_types, annotations):
-    return native_driver_python.thing_get_has(transaction, thing, attribute_types, annotations)
-
-def thing_set_has(transaction, thing, attribute):
-    return native_driver_python.thing_set_has(transaction, thing, attribute)
-
-def thing_unset_has(transaction, thing, attribute):
-    return native_driver_python.thing_unset_has(transaction, thing, attribute)
-
-def thing_get_relations(transaction, thing, role_types):
-    return native_driver_python.thing_get_relations(transaction, thing, role_types)
-
-def thing_get_playing(transaction, thing):
-    return native_driver_python.thing_get_playing(transaction, thing)
-
-def relation_add_role_player(transaction, relation, role_type, player):
-    return native_driver_python.relation_add_role_player(transaction, relation, role_type, player)
-
-def relation_remove_role_player(transaction, relation, role_type, player):
-    return native_driver_python.relation_remove_role_player(transaction, relation, role_type, player)
-
-def relation_get_players_by_role_type(transaction, relation, role_types):
-    return native_driver_python.relation_get_players_by_role_type(transaction, relation, role_types)
-
-def relation_get_role_players(transaction, relation):
-    return native_driver_python.relation_get_role_players(transaction, relation)
-
-def relation_get_relating(transaction, relation):
-    return native_driver_python.relation_get_relating(transaction, relation)
-
-def attribute_get_owners(transaction, attribute, thing_type):
-    return native_driver_python.attribute_get_owners(transaction, attribute, thing_type)
-
-def thing_type_is_root(thing_type):
-    return native_driver_python.thing_type_is_root(thing_type)
-
-def thing_type_is_abstract(thing_type):
-    return native_driver_python.thing_type_is_abstract(thing_type)
-
-def thing_type_get_label(thing_type):
-    return native_driver_python.thing_type_get_label(thing_type)
-
-def thing_type_is_deleted(transaction, thing_type):
-    return native_driver_python.thing_type_is_deleted(transaction, thing_type)
-
-def thing_type_delete(transaction, thing_type):
-    return native_driver_python.thing_type_delete(transaction, thing_type)
-
-def thing_type_set_label(transaction, thing_type, new_label):
-    return native_driver_python.thing_type_set_label(transaction, thing_type, new_label)
-
-def thing_type_set_abstract(transaction, thing_type):
-    return native_driver_python.thing_type_set_abstract(transaction, thing_type)
-
-def thing_type_unset_abstract(transaction, thing_type):
-    return native_driver_python.thing_type_unset_abstract(transaction, thing_type)
-
-def thing_type_get_owns(transaction, thing_type, value_type, transitivity, annotations):
-    return native_driver_python.thing_type_get_owns(transaction, thing_type, value_type, transitivity, annotations)
-
-def thing_type_get_owns_overridden(transaction, thing_type, overridden_attribute_type):
-    return native_driver_python.thing_type_get_owns_overridden(transaction, thing_type, overridden_attribute_type)
-
-def thing_type_set_owns(transaction, thing_type, attribute_type, overridden_attribute_type, annotations):
-    return native_driver_python.thing_type_set_owns(transaction, thing_type, attribute_type, overridden_attribute_type, annotations)
-
-def thing_type_unset_owns(transaction, thing_type, attribute_type):
-    return native_driver_python.thing_type_unset_owns(transaction, thing_type, attribute_type)
-
-def thing_type_get_plays(transaction, thing_type, transitivity):
-    return native_driver_python.thing_type_get_plays(transaction, thing_type, transitivity)
-
-def thing_type_get_plays_overridden(transaction, thing_type, overridden_role_type):
-    return native_driver_python.thing_type_get_plays_overridden(transaction, thing_type, overridden_role_type)
-
-def thing_type_set_plays(transaction, thing_type, role_type, overridden_role_type):
-    return native_driver_python.thing_type_set_plays(transaction, thing_type, role_type, overridden_role_type)
-
-def thing_type_unset_plays(transaction, thing_type, role_type):
-    return native_driver_python.thing_type_unset_plays(transaction, thing_type, role_type)
-
-def thing_type_get_syntax(transaction, thing_type):
-    return native_driver_python.thing_type_get_syntax(transaction, thing_type)
-
-def entity_type_create(transaction, entity_type):
-    return native_driver_python.entity_type_create(transaction, entity_type)
-
-def entity_type_get_supertype(transaction, entity_type):
-    return native_driver_python.entity_type_get_supertype(transaction, entity_type)
-
-def entity_type_set_supertype(transaction, entity_type, supertype):
-    return native_driver_python.entity_type_set_supertype(transaction, entity_type, supertype)
-
-def entity_type_get_supertypes(transaction, entity_type):
-    return native_driver_python.entity_type_get_supertypes(transaction, entity_type)
-
-def entity_type_get_subtypes(transaction, entity_type, transitivity):
-    return native_driver_python.entity_type_get_subtypes(transaction, entity_type, transitivity)
-
-def entity_type_get_instances(transaction, entity_type, transitivity):
-    return native_driver_python.entity_type_get_instances(transaction, entity_type, transitivity)
-
-def relation_type_create(transaction, relation_type):
-    return native_driver_python.relation_type_create(transaction, relation_type)
-
-def relation_type_get_supertype(transaction, relation_type):
-    return native_driver_python.relation_type_get_supertype(transaction, relation_type)
-
-def relation_type_set_supertype(transaction, relation_type, supertype):
-    return native_driver_python.relation_type_set_supertype(transaction, relation_type, supertype)
-
-def relation_type_get_supertypes(transaction, relation_type):
-    return native_driver_python.relation_type_get_supertypes(transaction, relation_type)
-
-def relation_type_get_subtypes(transaction, relation_type, transitivity):
-    return native_driver_python.relation_type_get_subtypes(transaction, relation_type, transitivity)
-
-def relation_type_get_instances(transaction, relation_type, transitivity):
-    return native_driver_python.relation_type_get_instances(transaction, relation_type, transitivity)
-
-def relation_type_get_relates(transaction, relation_type, transitivity):
-    return native_driver_python.relation_type_get_relates(transaction, relation_type, transitivity)
-
-def relation_type_get_relates_for_role_label(transaction, relation_type, role_label):
-    return native_driver_python.relation_type_get_relates_for_role_label(transaction, relation_type, role_label)
-
-def relation_type_get_relates_overridden(transaction, relation_type, overridden_role_label):
-    return native_driver_python.relation_type_get_relates_overridden(transaction, relation_type, overridden_role_label)
-
-def relation_type_set_relates(transaction, relation_type, role_label, overridden_role_label):
-    return native_driver_python.relation_type_set_relates(transaction, relation_type, role_label, overridden_role_label)
-
-def relation_type_unset_relates(transaction, relation_type, role_label):
-    return native_driver_python.relation_type_unset_relates(transaction, relation_type, role_label)
-
-def attribute_type_get_value_type(attribute_type):
-    return native_driver_python.attribute_type_get_value_type(attribute_type)
-
-def attribute_type_put(transaction, attribute_type, value):
-    return native_driver_python.attribute_type_put(transaction, attribute_type, value)
-
-def attribute_type_get(transaction, attribute_type, value):
-    return native_driver_python.attribute_type_get(transaction, attribute_type, value)
-
-def attribute_type_get_supertype(transaction, attribute_type):
-    return native_driver_python.attribute_type_get_supertype(transaction, attribute_type)
-
-def attribute_type_set_supertype(transaction, attribute_type, supertype):
-    return native_driver_python.attribute_type_set_supertype(transaction, attribute_type, supertype)
-
-def attribute_type_get_supertypes(transaction, attribute_type):
-    return native_driver_python.attribute_type_get_supertypes(transaction, attribute_type)
-
-def attribute_type_get_subtypes(transaction, attribute_type, transitivity):
-    return native_driver_python.attribute_type_get_subtypes(transaction, attribute_type, transitivity)
-
-def attribute_type_get_subtypes_with_value_type(transaction, attribute_type, value_type, transitivity):
-    return native_driver_python.attribute_type_get_subtypes_with_value_type(transaction, attribute_type, value_type, transitivity)
-
-def attribute_type_get_instances(transaction, attribute_type, transitivity):
-    return native_driver_python.attribute_type_get_instances(transaction, attribute_type, transitivity)
-
-def attribute_type_get_regex(transaction, attribute_type):
-    return native_driver_python.attribute_type_get_regex(transaction, attribute_type)
-
-def attribute_type_set_regex(transaction, attribute_type, regex):
-    return native_driver_python.attribute_type_set_regex(transaction, attribute_type, regex)
-
-def attribute_type_unset_regex(transaction, attribute_type):
-    return native_driver_python.attribute_type_unset_regex(transaction, attribute_type)
-
-def attribute_type_get_owners(transaction, attribute_type, transitivity, annotations):
-    return native_driver_python.attribute_type_get_owners(transaction, attribute_type, transitivity, annotations)
-
-def role_type_is_root(role_type):
-    return native_driver_python.role_type_is_root(role_type)
-
-def role_type_is_abstract(role_type):
-    return native_driver_python.role_type_is_abstract(role_type)
-
-def role_type_is_deleted(transaction, role_type):
-    return native_driver_python.role_type_is_deleted(transaction, role_type)
-
-def role_type_get_relation_type(transaction, role_type):
-    return native_driver_python.role_type_get_relation_type(transaction, role_type)
-
-def role_type_delete(transaction, role_type):
-    return native_driver_python.role_type_delete(transaction, role_type)
-
-def role_type_get_scope(role_type):
-    return native_driver_python.role_type_get_scope(role_type)
-
-def role_type_get_name(role_type):
-    return native_driver_python.role_type_get_name(role_type)
-
-def role_type_set_label(transaction, role_type, new_label):
-    return native_driver_python.role_type_set_label(transaction, role_type, new_label)
-
-def role_type_get_supertype(transaction, role_type):
-    return native_driver_python.role_type_get_supertype(transaction, role_type)
-
-def role_type_get_supertypes(transaction, role_type):
-    return native_driver_python.role_type_get_supertypes(transaction, role_type)
-
-def role_type_get_subtypes(transaction, role_type, transitivity):
-    return native_driver_python.role_type_get_subtypes(transaction, role_type, transitivity)
-
-def role_type_get_relation_types(transaction, role_type):
-    return native_driver_python.role_type_get_relation_types(transaction, role_type)
-
-def role_type_get_player_types(transaction, role_type, transitivity):
-    return native_driver_python.role_type_get_player_types(transaction, role_type, transitivity)
-
-def role_type_get_relation_instances(transaction, role_type, transitivity):
-    return native_driver_python.role_type_get_relation_instances(transaction, role_type, transitivity)
-
-def role_type_get_player_instances(transaction, role_type, transitivity):
-    return native_driver_python.role_type_get_player_instances(transaction, role_type, transitivity)
-
-def connection_open_core(address):
-    return native_driver_python.connection_open_core(address)
-
-def connection_open_cloud(addresses, credential):
-    return native_driver_python.connection_open_cloud(addresses, credential)
-
-def connection_open_cloud_translated(advertised_addresses, translated_addresses, credential):
-    return native_driver_python.connection_open_cloud_translated(advertised_addresses, translated_addresses, credential)
-
-def connection_is_open(connection):
-    return native_driver_python.connection_is_open(connection)
-
-def connection_force_close(connection):
-    return native_driver_python.connection_force_close(connection)
-
-def credential_new(username, password, tls_root_ca, with_tls):
-    return native_driver_python.credential_new(username, password, tls_root_ca, with_tls)
-
-def database_get_name(database):
-    return native_driver_python.database_get_name(database)
-
-def database_delete(database):
-    return native_driver_python.database_delete(database)
-
-def database_schema(database):
-    return native_driver_python.database_schema(database)
-
-def database_type_schema(database):
-    return native_driver_python.database_type_schema(database)
-
-def database_rule_schema(database):
-    return native_driver_python.database_rule_schema(database)
-
-def replica_info_iterator_next(it):
-    return native_driver_python.replica_info_iterator_next(it)
-
-def database_get_replicas_info(database):
-    return native_driver_python.database_get_replicas_info(database)
-
-def database_get_primary_replica_info(database):
-    return native_driver_python.database_get_primary_replica_info(database)
-
-def database_get_preferred_replica_info(database):
-    return native_driver_python.database_get_preferred_replica_info(database)
-
-def replica_info_get_server(replica_info):
-    return native_driver_python.replica_info_get_server(replica_info)
-
-def replica_info_is_primary(replica_info):
-    return native_driver_python.replica_info_is_primary(replica_info)
-
-def replica_info_is_preferred(replica_info):
-    return native_driver_python.replica_info_is_preferred(replica_info)
-
-def replica_info_get_term(replica_info):
-    return native_driver_python.replica_info_get_term(replica_info)
-
-def database_manager_new(connection):
-    return native_driver_python.database_manager_new(connection)
-
-def database_iterator_next(it):
-    return native_driver_python.database_iterator_next(it)
-
-def databases_all(databases):
-    return native_driver_python.databases_all(databases)
-
-def databases_create(databases, name):
-    return native_driver_python.databases_create(databases, name)
-
-def databases_contains(databases, name):
-    return native_driver_python.databases_contains(databases, name)
-
-def databases_get(databases, name):
-    return native_driver_python.databases_get(databases, name)
-
-def init_logging():
-    return native_driver_python.init_logging()
-
-def check_error():
-    return native_driver_python.check_error()
-
-def get_last_error():
-    return native_driver_python.get_last_error()
-
-def error_code(error):
-    return native_driver_python.error_code(error)
-
-def error_message(error):
-    return native_driver_python.error_message(error)
-
-def rule_to_string(rule):
-    return native_driver_python.rule_to_string(rule)
-
-def rule_get_label(rule):
-    return native_driver_python.rule_get_label(rule)
-
-def rule_get_when(rule):
-    return native_driver_python.rule_get_when(rule)
-
-def rule_get_then(rule):
-    return native_driver_python.rule_get_then(rule)
-
-def rule_set_label(transaction, rule, new_label):
-    return native_driver_python.rule_set_label(transaction, rule, new_label)
-
-def rule_delete(transaction, rule):
-    return native_driver_python.rule_delete(transaction, rule)
-
-def rule_is_deleted(transaction, rule):
-    return native_driver_python.rule_is_deleted(transaction, rule)
-
-def rule_promise_resolve(promise):
-    return native_driver_python.rule_promise_resolve(promise)
-
-def logic_manager_put_rule(transaction, label, when, then):
-    return native_driver_python.logic_manager_put_rule(transaction, label, when, then)
-
-def logic_manager_get_rule(transaction, label):
-    return native_driver_python.logic_manager_get_rule(transaction, label)
-
-def rule_iterator_next(it):
-    return native_driver_python.rule_iterator_next(it)
-
-def logic_manager_get_rules(transaction):
-    return native_driver_python.logic_manager_get_rules(transaction)
-
-def options_new():
-    return native_driver_python.options_new()
-
-def options_set_infer(options, infer):
-    return native_driver_python.options_set_infer(options, infer)
-
-def options_set_trace_inference(options, trace_inference):
-    return native_driver_python.options_set_trace_inference(options, trace_inference)
-
-def options_set_explain(options, explain):
-    return native_driver_python.options_set_explain(options, explain)
-
-def options_set_parallel(options, parallel):
-    return native_driver_python.options_set_parallel(options, parallel)
-
-def options_set_prefetch(options, prefetch):
-    return native_driver_python.options_set_prefetch(options, prefetch)
-
-def options_set_prefetch_size(options, prefetch_size):
-    return native_driver_python.options_set_prefetch_size(options, prefetch_size)
-
-def options_set_session_idle_timeout_millis(options, timeout_millis):
-    return native_driver_python.options_set_session_idle_timeout_millis(options, timeout_millis)
-
-def options_set_transaction_timeout_millis(options, timeout_millis):
-    return native_driver_python.options_set_transaction_timeout_millis(options, timeout_millis)
-
-def options_set_schema_lock_acquire_timeout_millis(options, timeout_millis):
-    return native_driver_python.options_set_schema_lock_acquire_timeout_millis(options, timeout_millis)
-
-def options_set_read_any_replica(options, read_any_replica):
-    return native_driver_python.options_set_read_any_replica(options, read_any_replica)
-
-def options_get_infer(options):
-    return native_driver_python.options_get_infer(options)
-
-def options_get_trace_inference(options):
-    return native_driver_python.options_get_trace_inference(options)
-
-def options_get_explain(options):
-    return native_driver_python.options_get_explain(options)
-
-def options_get_parallel(options):
-    return native_driver_python.options_get_parallel(options)
-
-def options_get_prefetch(options):
-    return native_driver_python.options_get_prefetch(options)
-
-def options_get_prefetch_size(options):
-    return native_driver_python.options_get_prefetch_size(options)
-
-def options_get_session_idle_timeout_millis(options):
-    return native_driver_python.options_get_session_idle_timeout_millis(options)
-
-def options_get_transaction_timeout_millis(options):
-    return native_driver_python.options_get_transaction_timeout_millis(options)
-
-def options_get_schema_lock_acquire_timeout_millis(options):
-    return native_driver_python.options_get_schema_lock_acquire_timeout_millis(options)
-
-def options_get_read_any_replica(options):
-    return native_driver_python.options_get_read_any_replica(options)
-
-def options_has_infer(options):
-    return native_driver_python.options_has_infer(options)
-
-def options_has_trace_inference(options):
-    return native_driver_python.options_has_trace_inference(options)
-
-def options_has_explain(options):
-    return native_driver_python.options_has_explain(options)
-
-def options_has_parallel(options):
-    return native_driver_python.options_has_parallel(options)
-
-def options_has_prefetch(options):
-    return native_driver_python.options_has_prefetch(options)
-
-def options_has_prefetch_size(options):
-    return native_driver_python.options_has_prefetch_size(options)
-
-def options_has_session_idle_timeout_millis(options):
-    return native_driver_python.options_has_session_idle_timeout_millis(options)
-
-def options_has_transaction_timeout_millis(options):
-    return native_driver_python.options_has_transaction_timeout_millis(options)
-
-def options_has_schema_lock_acquire_timeout_millis(options):
-    return native_driver_python.options_has_schema_lock_acquire_timeout_millis(options)
-
-def options_has_read_any_replica(options):
-    return native_driver_python.options_has_read_any_replica(options)
-
-def void_promise_resolve(promise):
-    return native_driver_python.void_promise_resolve(promise)
-
-def bool_promise_resolve(promise):
-    return native_driver_python.bool_promise_resolve(promise)
-
-def string_promise_resolve(promise):
-    return native_driver_python.string_promise_resolve(promise)
-
-def query_define(transaction, query, options):
-    return native_driver_python.query_define(transaction, query, options)
-
-def query_undefine(transaction, query, options):
-    return native_driver_python.query_undefine(transaction, query, options)
-
-def query_delete(transaction, query, options):
-    return native_driver_python.query_delete(transaction, query, options)
-
-def concept_map_iterator_next(it):
-    return native_driver_python.concept_map_iterator_next(it)
-
-def query_get(transaction, query, options):
-    return native_driver_python.query_get(transaction, query, options)
-
-def query_fetch(transaction, query, options):
-    return native_driver_python.query_fetch(transaction, query, options)
-
-def query_insert(transaction, query, options):
-    return native_driver_python.query_insert(transaction, query, options)
-
-def query_update(transaction, query, options):
-    return native_driver_python.query_update(transaction, query, options)
-
-def query_get_aggregate(transaction, query, options):
-    return native_driver_python.query_get_aggregate(transaction, query, options)
-
-def concept_map_group_iterator_next(it):
-    return native_driver_python.concept_map_group_iterator_next(it)
-
-def query_get_group(transaction, query, options):
-    return native_driver_python.query_get_group(transaction, query, options)
-
-def value_group_iterator_next(it):
-    return native_driver_python.value_group_iterator_next(it)
-
-def query_get_group_aggregate(transaction, query, options):
-    return native_driver_python.query_get_group_aggregate(transaction, query, options)
-
-def explanation_iterator_next(it):
-    return native_driver_python.explanation_iterator_next(it)
-
-def query_explain(transaction, explainable, options):
-    return native_driver_python.query_explain(transaction, explainable, options)
-
-def session_new(databases, database_name, session_type, options):
-    return native_driver_python.session_new(databases, database_name, session_type, options)
-
-def session_get_database_name(session):
-    return native_driver_python.session_get_database_name(session)
-
-def session_is_open(session):
-    return native_driver_python.session_is_open(session)
-
-def session_force_close(session):
-    return native_driver_python.session_force_close(session)
-
-def transaction_new(session, type_, options):
-    return native_driver_python.transaction_new(session, type_, options)
-
-def transaction_force_close(txn):
-    return native_driver_python.transaction_force_close(txn)
-
-def transaction_commit(txn):
-    return native_driver_python.transaction_commit(txn)
-
-def transaction_rollback(txn):
-    return native_driver_python.transaction_rollback(txn)
-
-def transaction_is_open(txn):
-    return native_driver_python.transaction_is_open(txn)
-
-def user_get_username(user):
-    return native_driver_python.user_get_username(user)
-
-def user_get_password_expiry_seconds(user):
-    return native_driver_python.user_get_password_expiry_seconds(user)
-
-def user_password_update(user, user_manager, password_old, password_new):
-    return native_driver_python.user_password_update(user, user_manager, password_old, password_new)
-
-def user_manager_new(connection):
-    return native_driver_python.user_manager_new(connection)
-
-def users_current_user(user_manager):
-    return native_driver_python.users_current_user(user_manager)
-
-def user_iterator_next(it):
-    return native_driver_python.user_iterator_next(it)
-
-def users_all(user_manager):
-    return native_driver_python.users_all(user_manager)
-
-def users_contains(user_manager, username):
-    return native_driver_python.users_contains(user_manager, username)
-
-def users_create(user_manager, username, password):
-    return native_driver_python.users_create(user_manager, username, password)
-
-def users_delete(user_manager, username):
-    return native_driver_python.users_delete(user_manager, username)
-
-def users_get(user_manager, username):
-    return native_driver_python.users_get(user_manager, username)
-
-def users_set_password(user_manager, username, password):
-    return native_driver_python.users_set_password(user_manager, username, password)
-
+# This file was automatically generated by SWIG (https://www.swig.org).
+# Version 4.1.1
+#
+# Do not make changes to this file unless you know what you are doing - modify
+# the SWIG interface file instead.
+
+from sys import version_info as _swig_python_version_info
+# Import the low-level C/C++ module
+if __package__ or "." in __name__:
+    from . import native_driver_python
+else:
+    import native_driver_python
+
+try:
+    import builtins as __builtin__
+except ImportError:
+    import __builtin__
+
+def _swig_repr(self):
+    try:
+        strthis = "proxy of " + self.this.__repr__()
+    except __builtin__.Exception:
+        strthis = ""
+    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)
+
+
+def _swig_setattr_nondynamic_instance_variable(set):
+    def set_instance_attr(self, name, value):
+        if name == "this":
+            set(self, name, value)
+        elif name == "thisown":
+            self.this.own(value)
+        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
+            set(self, name, value)
+        else:
+            raise AttributeError("You cannot add instance attributes to %s" % self)
+    return set_instance_attr
+
+
+def _swig_setattr_nondynamic_class_variable(set):
+    def set_class_attr(cls, name, value):
+        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
+            set(cls, name, value)
+        else:
+            raise AttributeError("You cannot add class attributes to %s" % cls)
+    return set_class_attr
+
+
+def _swig_add_metaclass(metaclass):
+    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
+    def wrapper(cls):
+        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
+    return wrapper
+
+
+class _SwigNonDynamicMeta(type):
+    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
+    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)
+
+
+import weakref
+
+
+TypeDBDriverExceptionNative = native_driver_python.TypeDBDriverExceptionNative
+
+native_driver_python.init_logging()
+
+class Error(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined")
+    __repr__ = _swig_repr
+    __swig_destroy__ = native_driver_python.delete_Error
+
+# Register Error in native_driver_python:
+native_driver_python.Error_swigregister(Error)
+class SchemaException(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined")
+    __repr__ = _swig_repr
+    __swig_destroy__ = native_driver_python.delete_SchemaException
+
+# Register SchemaException in native_driver_python:
+native_driver_python.SchemaException_swigregister(SchemaException)
+class SchemaExceptionIterator(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined")
+    __repr__ = _swig_repr
+    __swig_destroy__ = native_driver_python.delete_SchemaExceptionIterator
+
+# Register SchemaExceptionIterator in native_driver_python:
+native_driver_python.SchemaExceptionIterator_swigregister(SchemaExceptionIterator)
+class Credential(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined")
+    __repr__ = _swig_repr
+    __swig_destroy__ = native_driver_python.delete_Credential
+
+# Register Credential in native_driver_python:
+native_driver_python.Credential_swigregister(Credential)
+class Options(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined")
+    __repr__ = _swig_repr
+    __swig_destroy__ = native_driver_python.delete_Options
+
+# Register Options in native_driver_python:
+native_driver_python.Options_swigregister(Options)
+class Connection(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined")
+    __repr__ = _swig_repr
+    __swig_destroy__ = native_driver_python.delete_Connection
+
+# Register Connection in native_driver_python:
+native_driver_python.Connection_swigregister(Connection)
+class Session(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined")
+    __repr__ = _swig_repr
+    __swig_destroy__ = native_driver_python.delete_Session
+
+# Register Session in native_driver_python:
+native_driver_python.Session_swigregister(Session)
+class Transaction(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined")
+    __repr__ = _swig_repr
+    __swig_destroy__ = native_driver_python.delete_Transaction
+
+# Register Transaction in native_driver_python:
+native_driver_python.Transaction_swigregister(Transaction)
+class DatabaseManager(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined")
+    __repr__ = _swig_repr
+    __swig_destroy__ = native_driver_python.delete_DatabaseManager
+
+# Register DatabaseManager in native_driver_python:
+native_driver_python.DatabaseManager_swigregister(DatabaseManager)
+class Database(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined")
+    __repr__ = _swig_repr
+    __swig_destroy__ = native_driver_python.delete_Database
+
+# Register Database in native_driver_python:
+native_driver_python.Database_swigregister(Database)
+class DatabaseIterator(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined")
+    __repr__ = _swig_repr
+    __swig_destroy__ = native_driver_python.delete_DatabaseIterator
+
+# Register DatabaseIterator in native_driver_python:
+native_driver_python.DatabaseIterator_swigregister(DatabaseIterator)
+class ReplicaInfo(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined")
+    __repr__ = _swig_repr
+    __swig_destroy__ = native_driver_python.delete_ReplicaInfo
+
+# Register ReplicaInfo in native_driver_python:
+native_driver_python.ReplicaInfo_swigregister(ReplicaInfo)
+class ReplicaInfoIterator(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined")
+    __repr__ = _swig_repr
+    __swig_destroy__ = native_driver_python.delete_ReplicaInfoIterator
+
+# Register ReplicaInfoIterator in native_driver_python:
+native_driver_python.ReplicaInfoIterator_swigregister(ReplicaInfoIterator)
+class UserManager(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined")
+    __repr__ = _swig_repr
+    __swig_destroy__ = native_driver_python.delete_UserManager
+
+# Register UserManager in native_driver_python:
+native_driver_python.UserManager_swigregister(UserManager)
+class User(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined")
+    __repr__ = _swig_repr
+    __swig_destroy__ = native_driver_python.delete_User
+
+# Register User in native_driver_python:
+native_driver_python.User_swigregister(User)
+class UserIterator(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined")
+    __repr__ = _swig_repr
+    __swig_destroy__ = native_driver_python.delete_UserIterator
+
+# Register UserIterator in native_driver_python:
+native_driver_python.UserIterator_swigregister(UserIterator)
+class Concept(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined")
+    __repr__ = _swig_repr
+    __swig_destroy__ = native_driver_python.delete_Concept
+
+# Register Concept in native_driver_python:
+native_driver_python.Concept_swigregister(Concept)
+class ConceptIterator(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined")
+    __repr__ = _swig_repr
+    __swig_destroy__ = native_driver_python.delete_ConceptIterator
+
+# Register ConceptIterator in native_driver_python:
+native_driver_python.ConceptIterator_swigregister(ConceptIterator)
+class Annotation(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined")
+    __repr__ = _swig_repr
+    __swig_destroy__ = native_driver_python.delete_Annotation
+
+# Register Annotation in native_driver_python:
+native_driver_python.Annotation_swigregister(Annotation)
+class RolePlayer(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined")
+    __repr__ = _swig_repr
+    __swig_destroy__ = native_driver_python.delete_RolePlayer
+
+# Register RolePlayer in native_driver_python:
+native_driver_python.RolePlayer_swigregister(RolePlayer)
+class RolePlayerIterator(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined")
+    __repr__ = _swig_repr
+    __swig_destroy__ = native_driver_python.delete_RolePlayerIterator
+
+# Register RolePlayerIterator in native_driver_python:
+native_driver_python.RolePlayerIterator_swigregister(RolePlayerIterator)
+class ConceptMap(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined")
+    __repr__ = _swig_repr
+    __swig_destroy__ = native_driver_python.delete_ConceptMap
+
+# Register ConceptMap in native_driver_python:
+native_driver_python.ConceptMap_swigregister(ConceptMap)
+class ConceptMapIterator(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined")
+    __repr__ = _swig_repr
+    __swig_destroy__ = native_driver_python.delete_ConceptMapIterator
+
+# Register ConceptMapIterator in native_driver_python:
+native_driver_python.ConceptMapIterator_swigregister(ConceptMapIterator)
+class Explainables(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined")
+    __repr__ = _swig_repr
+    __swig_destroy__ = native_driver_python.delete_Explainables
+
+# Register Explainables in native_driver_python:
+native_driver_python.Explainables_swigregister(Explainables)
+class Explainable(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined")
+    __repr__ = _swig_repr
+    __swig_destroy__ = native_driver_python.delete_Explainable
+
+# Register Explainable in native_driver_python:
+native_driver_python.Explainable_swigregister(Explainable)
+class ConceptMapGroup(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined")
+    __repr__ = _swig_repr
+    __swig_destroy__ = native_driver_python.delete_ConceptMapGroup
+
+# Register ConceptMapGroup in native_driver_python:
+native_driver_python.ConceptMapGroup_swigregister(ConceptMapGroup)
+class ConceptMapGroupIterator(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined")
+    __repr__ = _swig_repr
+    __swig_destroy__ = native_driver_python.delete_ConceptMapGroupIterator
+
+# Register ConceptMapGroupIterator in native_driver_python:
+native_driver_python.ConceptMapGroupIterator_swigregister(ConceptMapGroupIterator)
+class StringIterator(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined")
+    __repr__ = _swig_repr
+    __swig_destroy__ = native_driver_python.delete_StringIterator
+
+# Register StringIterator in native_driver_python:
+native_driver_python.StringIterator_swigregister(StringIterator)
+class StringPairIterator(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined")
+    __repr__ = _swig_repr
+    __swig_destroy__ = native_driver_python.delete_StringPairIterator
+
+# Register StringPairIterator in native_driver_python:
+native_driver_python.StringPairIterator_swigregister(StringPairIterator)
+class ValueGroup(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined")
+    __repr__ = _swig_repr
+    __swig_destroy__ = native_driver_python.delete_ValueGroup
+
+# Register ValueGroup in native_driver_python:
+native_driver_python.ValueGroup_swigregister(ValueGroup)
+class ValueGroupIterator(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined")
+    __repr__ = _swig_repr
+    __swig_destroy__ = native_driver_python.delete_ValueGroupIterator
+
+# Register ValueGroupIterator in native_driver_python:
+native_driver_python.ValueGroupIterator_swigregister(ValueGroupIterator)
+class Explanation(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined")
+    __repr__ = _swig_repr
+    __swig_destroy__ = native_driver_python.delete_Explanation
+
+# Register Explanation in native_driver_python:
+native_driver_python.Explanation_swigregister(Explanation)
+class ExplanationIterator(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined")
+    __repr__ = _swig_repr
+    __swig_destroy__ = native_driver_python.delete_ExplanationIterator
+
+# Register ExplanationIterator in native_driver_python:
+native_driver_python.ExplanationIterator_swigregister(ExplanationIterator)
+class Rule(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined")
+    __repr__ = _swig_repr
+    __swig_destroy__ = native_driver_python.delete_Rule
+
+# Register Rule in native_driver_python:
+native_driver_python.Rule_swigregister(Rule)
+class RuleIterator(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined")
+    __repr__ = _swig_repr
+    __swig_destroy__ = native_driver_python.delete_RuleIterator
+
+# Register RuleIterator in native_driver_python:
+native_driver_python.RuleIterator_swigregister(RuleIterator)
+class BoolPromise(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined")
+    __repr__ = _swig_repr
+    __swig_destroy__ = native_driver_python.delete_BoolPromise
+
+# Register BoolPromise in native_driver_python:
+native_driver_python.BoolPromise_swigregister(BoolPromise)
+class ConceptPromise(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined")
+    __repr__ = _swig_repr
+    __swig_destroy__ = native_driver_python.delete_ConceptPromise
+
+# Register ConceptPromise in native_driver_python:
+native_driver_python.ConceptPromise_swigregister(ConceptPromise)
+class RulePromise(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined")
+    __repr__ = _swig_repr
+    __swig_destroy__ = native_driver_python.delete_RulePromise
+
+# Register RulePromise in native_driver_python:
+native_driver_python.RulePromise_swigregister(RulePromise)
+class StringPromise(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined")
+    __repr__ = _swig_repr
+    __swig_destroy__ = native_driver_python.delete_StringPromise
+
+# Register StringPromise in native_driver_python:
+native_driver_python.StringPromise_swigregister(StringPromise)
+class VoidPromise(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined")
+    __repr__ = _swig_repr
+    __swig_destroy__ = native_driver_python.delete_VoidPromise
+
+# Register VoidPromise in native_driver_python:
+native_driver_python.VoidPromise_swigregister(VoidPromise)
+class SessionCallbackDirector(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self):
+        if self.__class__ == SessionCallbackDirector:
+            _self = None
+        else:
+            _self = self
+        native_driver_python.SessionCallbackDirector_swiginit(self, native_driver_python.new_SessionCallbackDirector(_self, ))
+    __swig_destroy__ = native_driver_python.delete_SessionCallbackDirector
+
+    def callback(self):
+        return native_driver_python.SessionCallbackDirector_callback(self)
+    def __disown__(self):
+        self.this.disown()
+        native_driver_python.disown_SessionCallbackDirector(self)
+        return weakref.proxy(self)
+
+# Register SessionCallbackDirector in native_driver_python:
+native_driver_python.SessionCallbackDirector_swigregister(SessionCallbackDirector)
+
+def session_callback_register(handler):
+    return native_driver_python.session_callback_register(handler)
+
+def session_callback_execute(ID):
+    return native_driver_python.session_callback_execute(ID)
+
+def session_callback_erase(ID):
+    return native_driver_python.session_callback_erase(ID)
+
+def session_on_close(session, handler):
+    return native_driver_python.session_on_close(session, handler)
+
+def session_on_reopen(session, handler):
+    return native_driver_python.session_on_reopen(session, handler)
+class TransactionCallbackDirector(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self):
+        if self.__class__ == TransactionCallbackDirector:
+            _self = None
+        else:
+            _self = self
+        native_driver_python.TransactionCallbackDirector_swiginit(self, native_driver_python.new_TransactionCallbackDirector(_self, ))
+    __swig_destroy__ = native_driver_python.delete_TransactionCallbackDirector
+
+    def callback(self, arg0):
+        return native_driver_python.TransactionCallbackDirector_callback(self, arg0)
+    def __disown__(self):
+        self.this.disown()
+        native_driver_python.disown_TransactionCallbackDirector(self)
+        return weakref.proxy(self)
+
+# Register TransactionCallbackDirector in native_driver_python:
+native_driver_python.TransactionCallbackDirector_swigregister(TransactionCallbackDirector)
+cvar = native_driver_python.cvar
+
+
+def transaction_on_close(transaction, handler):
+    return native_driver_python.transaction_on_close(transaction, handler)
+Data = native_driver_python.Data
+Schema = native_driver_python.Schema
+Read = native_driver_python.Read
+Write = native_driver_python.Write
+Explicit = native_driver_python.Explicit
+Transitive = native_driver_python.Transitive
+Object = native_driver_python.Object
+Boolean = native_driver_python.Boolean
+Long = native_driver_python.Long
+Double = native_driver_python.Double
+String = native_driver_python.String
+DateTime = native_driver_python.DateTime
+class StringPair(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined")
+    __repr__ = _swig_repr
+    _0 = property(native_driver_python.StringPair__0_get, native_driver_python.StringPair__0_set)
+    _1 = property(native_driver_python.StringPair__1_get, native_driver_python.StringPair__1_set)
+    __swig_destroy__ = native_driver_python.delete_StringPair
+
+# Register StringPair in native_driver_python:
+native_driver_python.StringPair_swigregister(StringPair)
+
+def concept_map_get_variables(concept_map):
+    return native_driver_python.concept_map_get_variables(concept_map)
+
+def concept_map_get_values(concept_map):
+    return native_driver_python.concept_map_get_values(concept_map)
+
+def concept_map_get(concept_map, var):
+    return native_driver_python.concept_map_get(concept_map, var)
+
+def concept_map_get_explainables(concept_map):
+    return native_driver_python.concept_map_get_explainables(concept_map)
+
+def concept_map_equals(lhs, rhs):
+    return native_driver_python.concept_map_equals(lhs, rhs)
+
+def concept_map_to_string(concept_map):
+    return native_driver_python.concept_map_to_string(concept_map)
+
+def explainables_equals(lhs, rhs):
+    return native_driver_python.explainables_equals(lhs, rhs)
+
+def explainables_to_string(explainables):
+    return native_driver_python.explainables_to_string(explainables)
+
+def explainables_get_relation(explainables, var):
+    return native_driver_python.explainables_get_relation(explainables, var)
+
+def explainables_get_attribute(explainables, var):
+    return native_driver_python.explainables_get_attribute(explainables, var)
+
+def explainables_get_ownership(explainables, owner, attribute):
+    return native_driver_python.explainables_get_ownership(explainables, owner, attribute)
+
+def explainables_get_relations_keys(explainables):
+    return native_driver_python.explainables_get_relations_keys(explainables)
+
+def explainables_get_attributes_keys(explainables):
+    return native_driver_python.explainables_get_attributes_keys(explainables)
+
+def explainables_get_ownerships_keys(explainables):
+    return native_driver_python.explainables_get_ownerships_keys(explainables)
+
+def explainable_get_id(explainable):
+    return native_driver_python.explainable_get_id(explainable)
+
+def explainable_get_conjunction(explainable):
+    return native_driver_python.explainable_get_conjunction(explainable)
+
+def explanation_equals(lhs, rhs):
+    return native_driver_python.explanation_equals(lhs, rhs)
+
+def explanation_to_string(explanation):
+    return native_driver_python.explanation_to_string(explanation)
+
+def explanation_get_rule(explanation):
+    return native_driver_python.explanation_get_rule(explanation)
+
+def explanation_get_conclusion(explanation):
+    return native_driver_python.explanation_get_conclusion(explanation)
+
+def explanation_get_condition(explanation):
+    return native_driver_python.explanation_get_condition(explanation)
+
+def explanation_get_mapped_variables(explanation):
+    return native_driver_python.explanation_get_mapped_variables(explanation)
+
+def explanation_get_mapping(explanation, var):
+    return native_driver_python.explanation_get_mapping(explanation, var)
+
+def concept_map_group_get_owner(concept_map_group):
+    return native_driver_python.concept_map_group_get_owner(concept_map_group)
+
+def concept_map_group_get_concept_maps(concept_map_group):
+    return native_driver_python.concept_map_group_get_concept_maps(concept_map_group)
+
+def concept_map_group_to_string(concept_map_group):
+    return native_driver_python.concept_map_group_to_string(concept_map_group)
+
+def concept_map_group_equals(lhs, rhs):
+    return native_driver_python.concept_map_group_equals(lhs, rhs)
+
+def value_group_to_string(value_group):
+    return native_driver_python.value_group_to_string(value_group)
+
+def value_group_equals(lhs, rhs):
+    return native_driver_python.value_group_equals(lhs, rhs)
+
+def value_group_get_owner(value_group):
+    return native_driver_python.value_group_get_owner(value_group)
+
+def value_group_get_value(value_group):
+    return native_driver_python.value_group_get_value(value_group)
+
+def string_iterator_next(it):
+    return native_driver_python.string_iterator_next(it)
+
+def string_pair_drop(string_pair):
+    return native_driver_python.string_pair_drop(string_pair)
+
+def string_pair_iterator_next(it):
+    return native_driver_python.string_pair_iterator_next(it)
+
+def concept_promise_resolve(promise):
+    return native_driver_python.concept_promise_resolve(promise)
+
+def concept_iterator_next(it):
+    return native_driver_python.concept_iterator_next(it)
+
+def role_player_iterator_next(it):
+    return native_driver_python.role_player_iterator_next(it)
+
+def role_player_get_role_type(role_player):
+    return native_driver_python.role_player_get_role_type(role_player)
+
+def role_player_get_player(role_player):
+    return native_driver_python.role_player_get_player(role_player)
+
+def value_new_boolean(bool_):
+    return native_driver_python.value_new_boolean(bool_)
+
+def value_new_long(long_):
+    return native_driver_python.value_new_long(long_)
+
+def value_new_double(double_):
+    return native_driver_python.value_new_double(double_)
+
+def value_new_string(string):
+    return native_driver_python.value_new_string(string)
+
+def value_new_date_time_from_millis(millis):
+    return native_driver_python.value_new_date_time_from_millis(millis)
+
+def value_is_boolean(value):
+    return native_driver_python.value_is_boolean(value)
+
+def value_is_long(value):
+    return native_driver_python.value_is_long(value)
+
+def value_is_double(value):
+    return native_driver_python.value_is_double(value)
+
+def value_is_string(value):
+    return native_driver_python.value_is_string(value)
+
+def value_is_date_time(value):
+    return native_driver_python.value_is_date_time(value)
+
+def value_get_boolean(value):
+    return native_driver_python.value_get_boolean(value)
+
+def value_get_long(value):
+    return native_driver_python.value_get_long(value)
+
+def value_get_double(value):
+    return native_driver_python.value_get_double(value)
+
+def value_get_string(value):
+    return native_driver_python.value_get_string(value)
+
+def value_get_date_time_as_millis(value):
+    return native_driver_python.value_get_date_time_as_millis(value)
+
+def annotation_new_key():
+    return native_driver_python.annotation_new_key()
+
+def annotation_new_unique():
+    return native_driver_python.annotation_new_unique()
+
+def annotation_to_string(annotation):
+    return native_driver_python.annotation_to_string(annotation)
+
+def annotation_equals(lhs, rhs):
+    return native_driver_python.annotation_equals(lhs, rhs)
+
+def annotation_is_key(annotation):
+    return native_driver_python.annotation_is_key(annotation)
+
+def annotation_is_unique(annotation):
+    return native_driver_python.annotation_is_unique(annotation)
+
+def concept_equals(lhs, rhs):
+    return native_driver_python.concept_equals(lhs, rhs)
+
+def concept_is_entity(concept):
+    return native_driver_python.concept_is_entity(concept)
+
+def concept_is_relation(concept):
+    return native_driver_python.concept_is_relation(concept)
+
+def concept_is_attribute(concept):
+    return native_driver_python.concept_is_attribute(concept)
+
+def concept_is_value(concept):
+    return native_driver_python.concept_is_value(concept)
+
+def concept_is_root_thing_type(concept):
+    return native_driver_python.concept_is_root_thing_type(concept)
+
+def concept_is_entity_type(concept):
+    return native_driver_python.concept_is_entity_type(concept)
+
+def concept_is_relation_type(concept):
+    return native_driver_python.concept_is_relation_type(concept)
+
+def concept_is_attribute_type(concept):
+    return native_driver_python.concept_is_attribute_type(concept)
+
+def concept_is_role_type(concept):
+    return native_driver_python.concept_is_role_type(concept)
+
+def concept_to_string(concept):
+    return native_driver_python.concept_to_string(concept)
+
+def concepts_get_root_entity_type():
+    return native_driver_python.concepts_get_root_entity_type()
+
+def concepts_get_root_relation_type():
+    return native_driver_python.concepts_get_root_relation_type()
+
+def concepts_get_root_attribute_type():
+    return native_driver_python.concepts_get_root_attribute_type()
+
+def concepts_get_entity_type(transaction, label):
+    return native_driver_python.concepts_get_entity_type(transaction, label)
+
+def concepts_get_relation_type(transaction, label):
+    return native_driver_python.concepts_get_relation_type(transaction, label)
+
+def concepts_get_attribute_type(transaction, label):
+    return native_driver_python.concepts_get_attribute_type(transaction, label)
+
+def concepts_put_entity_type(transaction, label):
+    return native_driver_python.concepts_put_entity_type(transaction, label)
+
+def concepts_put_relation_type(transaction, label):
+    return native_driver_python.concepts_put_relation_type(transaction, label)
+
+def concepts_put_attribute_type(transaction, label, value_type):
+    return native_driver_python.concepts_put_attribute_type(transaction, label, value_type)
+
+def concepts_get_entity(transaction, iid):
+    return native_driver_python.concepts_get_entity(transaction, iid)
+
+def concepts_get_relation(transaction, iid):
+    return native_driver_python.concepts_get_relation(transaction, iid)
+
+def concepts_get_attribute(transaction, iid):
+    return native_driver_python.concepts_get_attribute(transaction, iid)
+
+def schema_exception_iterator_next(it):
+    return native_driver_python.schema_exception_iterator_next(it)
+
+def schema_exception_code(schema_exception):
+    return native_driver_python.schema_exception_code(schema_exception)
+
+def schema_exception_message(schema_exception):
+    return native_driver_python.schema_exception_message(schema_exception)
+
+def concepts_get_schema_exceptions(transaction):
+    return native_driver_python.concepts_get_schema_exceptions(transaction)
+
+def thing_get_iid(thing):
+    return native_driver_python.thing_get_iid(thing)
+
+def thing_get_is_inferred(thing):
+    return native_driver_python.thing_get_is_inferred(thing)
+
+def entity_get_type(entity):
+    return native_driver_python.entity_get_type(entity)
+
+def relation_get_type(relation):
+    return native_driver_python.relation_get_type(relation)
+
+def attribute_get_type(attribute):
+    return native_driver_python.attribute_get_type(attribute)
+
+def attribute_get_value(attribute):
+    return native_driver_python.attribute_get_value(attribute)
+
+def thing_delete(transaction, thing):
+    return native_driver_python.thing_delete(transaction, thing)
+
+def thing_is_deleted(transaction, thing):
+    return native_driver_python.thing_is_deleted(transaction, thing)
+
+def thing_get_has(transaction, thing, attribute_types, annotations):
+    return native_driver_python.thing_get_has(transaction, thing, attribute_types, annotations)
+
+def thing_set_has(transaction, thing, attribute):
+    return native_driver_python.thing_set_has(transaction, thing, attribute)
+
+def thing_unset_has(transaction, thing, attribute):
+    return native_driver_python.thing_unset_has(transaction, thing, attribute)
+
+def thing_get_relations(transaction, thing, role_types):
+    return native_driver_python.thing_get_relations(transaction, thing, role_types)
+
+def thing_get_playing(transaction, thing):
+    return native_driver_python.thing_get_playing(transaction, thing)
+
+def relation_add_role_player(transaction, relation, role_type, player):
+    return native_driver_python.relation_add_role_player(transaction, relation, role_type, player)
+
+def relation_remove_role_player(transaction, relation, role_type, player):
+    return native_driver_python.relation_remove_role_player(transaction, relation, role_type, player)
+
+def relation_get_players_by_role_type(transaction, relation, role_types):
+    return native_driver_python.relation_get_players_by_role_type(transaction, relation, role_types)
+
+def relation_get_role_players(transaction, relation):
+    return native_driver_python.relation_get_role_players(transaction, relation)
+
+def relation_get_relating(transaction, relation):
+    return native_driver_python.relation_get_relating(transaction, relation)
+
+def attribute_get_owners(transaction, attribute, thing_type):
+    return native_driver_python.attribute_get_owners(transaction, attribute, thing_type)
+
+def thing_type_is_root(thing_type):
+    return native_driver_python.thing_type_is_root(thing_type)
+
+def thing_type_is_abstract(thing_type):
+    return native_driver_python.thing_type_is_abstract(thing_type)
+
+def thing_type_get_label(thing_type):
+    return native_driver_python.thing_type_get_label(thing_type)
+
+def thing_type_is_deleted(transaction, thing_type):
+    return native_driver_python.thing_type_is_deleted(transaction, thing_type)
+
+def thing_type_delete(transaction, thing_type):
+    return native_driver_python.thing_type_delete(transaction, thing_type)
+
+def thing_type_set_label(transaction, thing_type, new_label):
+    return native_driver_python.thing_type_set_label(transaction, thing_type, new_label)
+
+def thing_type_set_abstract(transaction, thing_type):
+    return native_driver_python.thing_type_set_abstract(transaction, thing_type)
+
+def thing_type_unset_abstract(transaction, thing_type):
+    return native_driver_python.thing_type_unset_abstract(transaction, thing_type)
+
+def thing_type_get_owns(transaction, thing_type, value_type, transitivity, annotations):
+    return native_driver_python.thing_type_get_owns(transaction, thing_type, value_type, transitivity, annotations)
+
+def thing_type_get_owns_overridden(transaction, thing_type, overridden_attribute_type):
+    return native_driver_python.thing_type_get_owns_overridden(transaction, thing_type, overridden_attribute_type)
+
+def thing_type_set_owns(transaction, thing_type, attribute_type, overridden_attribute_type, annotations):
+    return native_driver_python.thing_type_set_owns(transaction, thing_type, attribute_type, overridden_attribute_type, annotations)
+
+def thing_type_unset_owns(transaction, thing_type, attribute_type):
+    return native_driver_python.thing_type_unset_owns(transaction, thing_type, attribute_type)
+
+def thing_type_get_plays(transaction, thing_type, transitivity):
+    return native_driver_python.thing_type_get_plays(transaction, thing_type, transitivity)
+
+def thing_type_get_plays_overridden(transaction, thing_type, overridden_role_type):
+    return native_driver_python.thing_type_get_plays_overridden(transaction, thing_type, overridden_role_type)
+
+def thing_type_set_plays(transaction, thing_type, role_type, overridden_role_type):
+    return native_driver_python.thing_type_set_plays(transaction, thing_type, role_type, overridden_role_type)
+
+def thing_type_unset_plays(transaction, thing_type, role_type):
+    return native_driver_python.thing_type_unset_plays(transaction, thing_type, role_type)
+
+def thing_type_get_syntax(transaction, thing_type):
+    return native_driver_python.thing_type_get_syntax(transaction, thing_type)
+
+def entity_type_create(transaction, entity_type):
+    return native_driver_python.entity_type_create(transaction, entity_type)
+
+def entity_type_get_supertype(transaction, entity_type):
+    return native_driver_python.entity_type_get_supertype(transaction, entity_type)
+
+def entity_type_set_supertype(transaction, entity_type, supertype):
+    return native_driver_python.entity_type_set_supertype(transaction, entity_type, supertype)
+
+def entity_type_get_supertypes(transaction, entity_type):
+    return native_driver_python.entity_type_get_supertypes(transaction, entity_type)
+
+def entity_type_get_subtypes(transaction, entity_type, transitivity):
+    return native_driver_python.entity_type_get_subtypes(transaction, entity_type, transitivity)
+
+def entity_type_get_instances(transaction, entity_type, transitivity):
+    return native_driver_python.entity_type_get_instances(transaction, entity_type, transitivity)
+
+def relation_type_create(transaction, relation_type):
+    return native_driver_python.relation_type_create(transaction, relation_type)
+
+def relation_type_get_supertype(transaction, relation_type):
+    return native_driver_python.relation_type_get_supertype(transaction, relation_type)
+
+def relation_type_set_supertype(transaction, relation_type, supertype):
+    return native_driver_python.relation_type_set_supertype(transaction, relation_type, supertype)
+
+def relation_type_get_supertypes(transaction, relation_type):
+    return native_driver_python.relation_type_get_supertypes(transaction, relation_type)
+
+def relation_type_get_subtypes(transaction, relation_type, transitivity):
+    return native_driver_python.relation_type_get_subtypes(transaction, relation_type, transitivity)
+
+def relation_type_get_instances(transaction, relation_type, transitivity):
+    return native_driver_python.relation_type_get_instances(transaction, relation_type, transitivity)
+
+def relation_type_get_relates(transaction, relation_type, transitivity):
+    return native_driver_python.relation_type_get_relates(transaction, relation_type, transitivity)
+
+def relation_type_get_relates_for_role_label(transaction, relation_type, role_label):
+    return native_driver_python.relation_type_get_relates_for_role_label(transaction, relation_type, role_label)
+
+def relation_type_get_relates_overridden(transaction, relation_type, overridden_role_label):
+    return native_driver_python.relation_type_get_relates_overridden(transaction, relation_type, overridden_role_label)
+
+def relation_type_set_relates(transaction, relation_type, role_label, overridden_role_label):
+    return native_driver_python.relation_type_set_relates(transaction, relation_type, role_label, overridden_role_label)
+
+def relation_type_unset_relates(transaction, relation_type, role_label):
+    return native_driver_python.relation_type_unset_relates(transaction, relation_type, role_label)
+
+def attribute_type_get_value_type(attribute_type):
+    return native_driver_python.attribute_type_get_value_type(attribute_type)
+
+def attribute_type_put(transaction, attribute_type, value):
+    return native_driver_python.attribute_type_put(transaction, attribute_type, value)
+
+def attribute_type_get(transaction, attribute_type, value):
+    return native_driver_python.attribute_type_get(transaction, attribute_type, value)
+
+def attribute_type_get_supertype(transaction, attribute_type):
+    return native_driver_python.attribute_type_get_supertype(transaction, attribute_type)
+
+def attribute_type_set_supertype(transaction, attribute_type, supertype):
+    return native_driver_python.attribute_type_set_supertype(transaction, attribute_type, supertype)
+
+def attribute_type_get_supertypes(transaction, attribute_type):
+    return native_driver_python.attribute_type_get_supertypes(transaction, attribute_type)
+
+def attribute_type_get_subtypes(transaction, attribute_type, transitivity):
+    return native_driver_python.attribute_type_get_subtypes(transaction, attribute_type, transitivity)
+
+def attribute_type_get_subtypes_with_value_type(transaction, attribute_type, value_type, transitivity):
+    return native_driver_python.attribute_type_get_subtypes_with_value_type(transaction, attribute_type, value_type, transitivity)
+
+def attribute_type_get_instances(transaction, attribute_type, transitivity):
+    return native_driver_python.attribute_type_get_instances(transaction, attribute_type, transitivity)
+
+def attribute_type_get_regex(transaction, attribute_type):
+    return native_driver_python.attribute_type_get_regex(transaction, attribute_type)
+
+def attribute_type_set_regex(transaction, attribute_type, regex):
+    return native_driver_python.attribute_type_set_regex(transaction, attribute_type, regex)
+
+def attribute_type_unset_regex(transaction, attribute_type):
+    return native_driver_python.attribute_type_unset_regex(transaction, attribute_type)
+
+def attribute_type_get_owners(transaction, attribute_type, transitivity, annotations):
+    return native_driver_python.attribute_type_get_owners(transaction, attribute_type, transitivity, annotations)
+
+def role_type_is_root(role_type):
+    return native_driver_python.role_type_is_root(role_type)
+
+def role_type_is_abstract(role_type):
+    return native_driver_python.role_type_is_abstract(role_type)
+
+def role_type_is_deleted(transaction, role_type):
+    return native_driver_python.role_type_is_deleted(transaction, role_type)
+
+def role_type_get_relation_type(transaction, role_type):
+    return native_driver_python.role_type_get_relation_type(transaction, role_type)
+
+def role_type_delete(transaction, role_type):
+    return native_driver_python.role_type_delete(transaction, role_type)
+
+def role_type_get_scope(role_type):
+    return native_driver_python.role_type_get_scope(role_type)
+
+def role_type_get_name(role_type):
+    return native_driver_python.role_type_get_name(role_type)
+
+def role_type_set_label(transaction, role_type, new_label):
+    return native_driver_python.role_type_set_label(transaction, role_type, new_label)
+
+def role_type_get_supertype(transaction, role_type):
+    return native_driver_python.role_type_get_supertype(transaction, role_type)
+
+def role_type_get_supertypes(transaction, role_type):
+    return native_driver_python.role_type_get_supertypes(transaction, role_type)
+
+def role_type_get_subtypes(transaction, role_type, transitivity):
+    return native_driver_python.role_type_get_subtypes(transaction, role_type, transitivity)
+
+def role_type_get_relation_types(transaction, role_type):
+    return native_driver_python.role_type_get_relation_types(transaction, role_type)
+
+def role_type_get_player_types(transaction, role_type, transitivity):
+    return native_driver_python.role_type_get_player_types(transaction, role_type, transitivity)
+
+def role_type_get_relation_instances(transaction, role_type, transitivity):
+    return native_driver_python.role_type_get_relation_instances(transaction, role_type, transitivity)
+
+def role_type_get_player_instances(transaction, role_type, transitivity):
+    return native_driver_python.role_type_get_player_instances(transaction, role_type, transitivity)
+
+def connection_open_core(address):
+    return native_driver_python.connection_open_core(address)
+
+def connection_open_cloud(addresses, credential):
+    return native_driver_python.connection_open_cloud(addresses, credential)
+
+def connection_open_cloud_translated(advertised_addresses, translated_addresses, credential):
+    return native_driver_python.connection_open_cloud_translated(advertised_addresses, translated_addresses, credential)
+
+def connection_is_open(connection):
+    return native_driver_python.connection_is_open(connection)
+
+def connection_force_close(connection):
+    return native_driver_python.connection_force_close(connection)
+
+def credential_new(username, password, tls_root_ca, with_tls):
+    return native_driver_python.credential_new(username, password, tls_root_ca, with_tls)
+
+def database_get_name(database):
+    return native_driver_python.database_get_name(database)
+
+def database_delete(database):
+    return native_driver_python.database_delete(database)
+
+def database_schema(database):
+    return native_driver_python.database_schema(database)
+
+def database_type_schema(database):
+    return native_driver_python.database_type_schema(database)
+
+def database_rule_schema(database):
+    return native_driver_python.database_rule_schema(database)
+
+def replica_info_iterator_next(it):
+    return native_driver_python.replica_info_iterator_next(it)
+
+def database_get_replicas_info(database):
+    return native_driver_python.database_get_replicas_info(database)
+
+def database_get_primary_replica_info(database):
+    return native_driver_python.database_get_primary_replica_info(database)
+
+def database_get_preferred_replica_info(database):
+    return native_driver_python.database_get_preferred_replica_info(database)
+
+def replica_info_get_server(replica_info):
+    return native_driver_python.replica_info_get_server(replica_info)
+
+def replica_info_is_primary(replica_info):
+    return native_driver_python.replica_info_is_primary(replica_info)
+
+def replica_info_is_preferred(replica_info):
+    return native_driver_python.replica_info_is_preferred(replica_info)
+
+def replica_info_get_term(replica_info):
+    return native_driver_python.replica_info_get_term(replica_info)
+
+def database_manager_new(connection):
+    return native_driver_python.database_manager_new(connection)
+
+def database_iterator_next(it):
+    return native_driver_python.database_iterator_next(it)
+
+def databases_all(databases):
+    return native_driver_python.databases_all(databases)
+
+def databases_create(databases, name):
+    return native_driver_python.databases_create(databases, name)
+
+def databases_contains(databases, name):
+    return native_driver_python.databases_contains(databases, name)
+
+def databases_get(databases, name):
+    return native_driver_python.databases_get(databases, name)
+
+def init_logging():
+    return native_driver_python.init_logging()
+
+def check_error():
+    return native_driver_python.check_error()
+
+def get_last_error():
+    return native_driver_python.get_last_error()
+
+def error_code(error):
+    return native_driver_python.error_code(error)
+
+def error_message(error):
+    return native_driver_python.error_message(error)
+
+def rule_to_string(rule):
+    return native_driver_python.rule_to_string(rule)
+
+def rule_get_label(rule):
+    return native_driver_python.rule_get_label(rule)
+
+def rule_get_when(rule):
+    return native_driver_python.rule_get_when(rule)
+
+def rule_get_then(rule):
+    return native_driver_python.rule_get_then(rule)
+
+def rule_set_label(transaction, rule, new_label):
+    return native_driver_python.rule_set_label(transaction, rule, new_label)
+
+def rule_delete(transaction, rule):
+    return native_driver_python.rule_delete(transaction, rule)
+
+def rule_is_deleted(transaction, rule):
+    return native_driver_python.rule_is_deleted(transaction, rule)
+
+def rule_promise_resolve(promise):
+    return native_driver_python.rule_promise_resolve(promise)
+
+def logic_manager_put_rule(transaction, label, when, then):
+    return native_driver_python.logic_manager_put_rule(transaction, label, when, then)
+
+def logic_manager_get_rule(transaction, label):
+    return native_driver_python.logic_manager_get_rule(transaction, label)
+
+def rule_iterator_next(it):
+    return native_driver_python.rule_iterator_next(it)
+
+def logic_manager_get_rules(transaction):
+    return native_driver_python.logic_manager_get_rules(transaction)
+
+def options_new():
+    return native_driver_python.options_new()
+
+def options_set_infer(options, infer):
+    return native_driver_python.options_set_infer(options, infer)
+
+def options_set_trace_inference(options, trace_inference):
+    return native_driver_python.options_set_trace_inference(options, trace_inference)
+
+def options_set_explain(options, explain):
+    return native_driver_python.options_set_explain(options, explain)
+
+def options_set_parallel(options, parallel):
+    return native_driver_python.options_set_parallel(options, parallel)
+
+def options_set_prefetch(options, prefetch):
+    return native_driver_python.options_set_prefetch(options, prefetch)
+
+def options_set_prefetch_size(options, prefetch_size):
+    return native_driver_python.options_set_prefetch_size(options, prefetch_size)
+
+def options_set_session_idle_timeout_millis(options, timeout_millis):
+    return native_driver_python.options_set_session_idle_timeout_millis(options, timeout_millis)
+
+def options_set_transaction_timeout_millis(options, timeout_millis):
+    return native_driver_python.options_set_transaction_timeout_millis(options, timeout_millis)
+
+def options_set_schema_lock_acquire_timeout_millis(options, timeout_millis):
+    return native_driver_python.options_set_schema_lock_acquire_timeout_millis(options, timeout_millis)
+
+def options_set_read_any_replica(options, read_any_replica):
+    return native_driver_python.options_set_read_any_replica(options, read_any_replica)
+
+def options_get_infer(options):
+    return native_driver_python.options_get_infer(options)
+
+def options_get_trace_inference(options):
+    return native_driver_python.options_get_trace_inference(options)
+
+def options_get_explain(options):
+    return native_driver_python.options_get_explain(options)
+
+def options_get_parallel(options):
+    return native_driver_python.options_get_parallel(options)
+
+def options_get_prefetch(options):
+    return native_driver_python.options_get_prefetch(options)
+
+def options_get_prefetch_size(options):
+    return native_driver_python.options_get_prefetch_size(options)
+
+def options_get_session_idle_timeout_millis(options):
+    return native_driver_python.options_get_session_idle_timeout_millis(options)
+
+def options_get_transaction_timeout_millis(options):
+    return native_driver_python.options_get_transaction_timeout_millis(options)
+
+def options_get_schema_lock_acquire_timeout_millis(options):
+    return native_driver_python.options_get_schema_lock_acquire_timeout_millis(options)
+
+def options_get_read_any_replica(options):
+    return native_driver_python.options_get_read_any_replica(options)
+
+def options_has_infer(options):
+    return native_driver_python.options_has_infer(options)
+
+def options_has_trace_inference(options):
+    return native_driver_python.options_has_trace_inference(options)
+
+def options_has_explain(options):
+    return native_driver_python.options_has_explain(options)
+
+def options_has_parallel(options):
+    return native_driver_python.options_has_parallel(options)
+
+def options_has_prefetch(options):
+    return native_driver_python.options_has_prefetch(options)
+
+def options_has_prefetch_size(options):
+    return native_driver_python.options_has_prefetch_size(options)
+
+def options_has_session_idle_timeout_millis(options):
+    return native_driver_python.options_has_session_idle_timeout_millis(options)
+
+def options_has_transaction_timeout_millis(options):
+    return native_driver_python.options_has_transaction_timeout_millis(options)
+
+def options_has_schema_lock_acquire_timeout_millis(options):
+    return native_driver_python.options_has_schema_lock_acquire_timeout_millis(options)
+
+def options_has_read_any_replica(options):
+    return native_driver_python.options_has_read_any_replica(options)
+
+def void_promise_resolve(promise):
+    return native_driver_python.void_promise_resolve(promise)
+
+def bool_promise_resolve(promise):
+    return native_driver_python.bool_promise_resolve(promise)
+
+def string_promise_resolve(promise):
+    return native_driver_python.string_promise_resolve(promise)
+
+def query_define(transaction, query, options):
+    return native_driver_python.query_define(transaction, query, options)
+
+def query_undefine(transaction, query, options):
+    return native_driver_python.query_undefine(transaction, query, options)
+
+def query_delete(transaction, query, options):
+    return native_driver_python.query_delete(transaction, query, options)
+
+def concept_map_iterator_next(it):
+    return native_driver_python.concept_map_iterator_next(it)
+
+def query_get(transaction, query, options):
+    return native_driver_python.query_get(transaction, query, options)
+
+def query_fetch(transaction, query, options):
+    return native_driver_python.query_fetch(transaction, query, options)
+
+def query_insert(transaction, query, options):
+    return native_driver_python.query_insert(transaction, query, options)
+
+def query_update(transaction, query, options):
+    return native_driver_python.query_update(transaction, query, options)
+
+def query_get_aggregate(transaction, query, options):
+    return native_driver_python.query_get_aggregate(transaction, query, options)
+
+def concept_map_group_iterator_next(it):
+    return native_driver_python.concept_map_group_iterator_next(it)
+
+def query_get_group(transaction, query, options):
+    return native_driver_python.query_get_group(transaction, query, options)
+
+def value_group_iterator_next(it):
+    return native_driver_python.value_group_iterator_next(it)
+
+def query_get_group_aggregate(transaction, query, options):
+    return native_driver_python.query_get_group_aggregate(transaction, query, options)
+
+def explanation_iterator_next(it):
+    return native_driver_python.explanation_iterator_next(it)
+
+def query_explain(transaction, explainable, options):
+    return native_driver_python.query_explain(transaction, explainable, options)
+
+def session_new(databases, database_name, session_type, options):
+    return native_driver_python.session_new(databases, database_name, session_type, options)
+
+def session_get_database_name(session):
+    return native_driver_python.session_get_database_name(session)
+
+def session_is_open(session):
+    return native_driver_python.session_is_open(session)
+
+def session_force_close(session):
+    return native_driver_python.session_force_close(session)
+
+def transaction_new(session, type_, options):
+    return native_driver_python.transaction_new(session, type_, options)
+
+def transaction_force_close(txn):
+    return native_driver_python.transaction_force_close(txn)
+
+def transaction_commit(txn):
+    return native_driver_python.transaction_commit(txn)
+
+def transaction_rollback(txn):
+    return native_driver_python.transaction_rollback(txn)
+
+def transaction_is_open(txn):
+    return native_driver_python.transaction_is_open(txn)
+
+def user_get_username(user):
+    return native_driver_python.user_get_username(user)
+
+def user_get_password_expiry_seconds(user):
+    return native_driver_python.user_get_password_expiry_seconds(user)
+
+def user_password_update(user, user_manager, password_old, password_new):
+    return native_driver_python.user_password_update(user, user_manager, password_old, password_new)
+
+def user_manager_new(connection):
+    return native_driver_python.user_manager_new(connection)
+
+def users_current_user(user_manager):
+    return native_driver_python.users_current_user(user_manager)
+
+def user_iterator_next(it):
+    return native_driver_python.user_iterator_next(it)
+
+def users_all(user_manager):
+    return native_driver_python.users_all(user_manager)
+
+def users_contains(user_manager, username):
+    return native_driver_python.users_contains(user_manager, username)
+
+def users_create(user_manager, username, password):
+    return native_driver_python.users_create(user_manager, username, password)
+
+def users_delete(user_manager, username):
+    return native_driver_python.users_delete(user_manager, username)
+
+def users_get(user_manager, username):
+    return native_driver_python.users_get(user_manager, username)
+
+def users_set_password(user_manager, username, password):
+    return native_driver_python.users_set_password(user_manager, username, password)
+
```

## typedb/api/answer/concept_map.py

 * *Ordering differences only*

```diff
@@ -1,241 +1,241 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from abc import ABC, abstractmethod
-from typing import Mapping, Iterator, TYPE_CHECKING
-
-if TYPE_CHECKING:
-    from typedb.api.concept.concept import Concept
-
-
-class ConceptMap(ABC):
-    """
-    Contains a mapping of variables to concepts.
-    """
-
-    @abstractmethod
-    def variables(self) -> Iterator[str]:
-        """
-        Produces an iterator over all variables in this ``ConceptMap``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-          concept_map.variables()
-        """
-        pass
-
-    @abstractmethod
-    def concepts(self) -> Iterator[Concept]:
-        """
-        Produces an iterator over all concepts in this ``ConceptMap``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-          concept_map.concepts()
-        """
-        pass
-
-    @abstractmethod
-    def map(self) -> Mapping[str, Concept]:
-        """
-        Returns the inner ``Mapping`` where keys are query variables, and values are concepts.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-          concept_map.concepts()
-        """
-        pass
-
-    @abstractmethod
-    def get(self, variable: str) -> Concept:
-        """
-        Retrieves a concept for a given variable name.
-
-        :param variable: The string representation of a variable
-        :return:
-
-        Examples
-        --------
-        ::
-
-          concept_map.get(variable)
-        """
-        pass
-
-    @abstractmethod
-    def explainables(self) -> Explainables:
-        """
-        Gets the ``Explainables`` object for this ``ConceptMap``, exposing
-        which of the concepts in this ``ConceptMap`` are explainable.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-          concept_map.explainables()
-        """
-        pass
-
-    class Explainables(ABC):
-        """
-        Contains explainable objects.
-        """
-
-        @abstractmethod
-        def relation(self, variable: str) -> ConceptMap.Explainable:
-            """
-            Retrieves the explainable relation with the given variable name.
-
-            :param variable: The string representation of a variable
-            :return:
-
-            Examples
-            --------
-            ::
-
-               concept_map.explainables().relation(variable)
-            """
-            pass
-
-        @abstractmethod
-        def attribute(self, variable: str) -> ConceptMap.Explainable:
-            """
-            Retrieves the explainable attribute with the given variable name.
-
-            :param variable: The string representation of a variable
-            :return:
-
-            Examples
-            --------
-            ::
-
-               concept_map.explainables().attribute(variable)
-            """
-            pass
-
-        @abstractmethod
-        def ownership(self, owner: str, attribute: str) -> ConceptMap.Explainable:
-            """
-            Retrieves the explainable attribute ownership with the pair of (owner, attribute) variable names.
-
-            :param owner: The string representation of the owner variable
-            :param attribute: The string representation of the attribute variable
-            :return:
-
-            Examples
-            --------
-            ::
-
-               concept_map.explainables().ownership(owner, attribute)
-            """
-            pass
-
-        @abstractmethod
-        def relations(self) -> Mapping[str, ConceptMap.Explainable]:
-            """
-            Retrieves all of this ``ConceptMap``s explainable relations.
-
-            :return:
-
-            Examples
-            --------
-            ::
-
-               concept_map.explainables().relations()
-            """
-            pass
-
-        @abstractmethod
-        def attributes(self) -> Mapping[str, ConceptMap.Explainable]:
-            """
-            Retrieves all of this ``ConceptMap``s explainable attributes.
-
-            :return:
-
-            Examples
-            --------
-            ::
-
-               concept_map.explainables().attributes()
-            """
-            pass
-
-        @abstractmethod
-        def ownerships(self) -> Mapping[tuple[str, str], ConceptMap.Explainable]:
-            """
-            Retrieves all of this ``ConceptMap``s explainable ownerships.
-
-            :return:
-
-            Examples
-            --------
-            ::
-
-               concept_map.explainables().ownerships()
-            """
-            pass
-
-    class Explainable(ABC):
-        """
-        Contains an explainable object.
-        """
-
-        @abstractmethod
-        def conjunction(self) -> str:
-            """
-            Retrieves the subquery of the original query that is actually being explained.
-
-            :return:
-
-            Examples
-            --------
-            ::
-
-               explainable.conjunction()
-            """
-            pass
-
-        @abstractmethod
-        def id(self) -> int:
-            """
-            Retrieves the unique ID that identifies this ``Explainable``.
-
-            :return:
-
-            Examples
-            --------
-            ::
-
-               explainable.id()
-            """
-            pass
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from abc import ABC, abstractmethod
+from typing import Mapping, Iterator, TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from typedb.api.concept.concept import Concept
+
+
+class ConceptMap(ABC):
+    """
+    Contains a mapping of variables to concepts.
+    """
+
+    @abstractmethod
+    def variables(self) -> Iterator[str]:
+        """
+        Produces an iterator over all variables in this ``ConceptMap``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+          concept_map.variables()
+        """
+        pass
+
+    @abstractmethod
+    def concepts(self) -> Iterator[Concept]:
+        """
+        Produces an iterator over all concepts in this ``ConceptMap``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+          concept_map.concepts()
+        """
+        pass
+
+    @abstractmethod
+    def map(self) -> Mapping[str, Concept]:
+        """
+        Returns the inner ``Mapping`` where keys are query variables, and values are concepts.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+          concept_map.concepts()
+        """
+        pass
+
+    @abstractmethod
+    def get(self, variable: str) -> Concept:
+        """
+        Retrieves a concept for a given variable name.
+
+        :param variable: The string representation of a variable
+        :return:
+
+        Examples
+        --------
+        ::
+
+          concept_map.get(variable)
+        """
+        pass
+
+    @abstractmethod
+    def explainables(self) -> Explainables:
+        """
+        Gets the ``Explainables`` object for this ``ConceptMap``, exposing
+        which of the concepts in this ``ConceptMap`` are explainable.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+          concept_map.explainables()
+        """
+        pass
+
+    class Explainables(ABC):
+        """
+        Contains explainable objects.
+        """
+
+        @abstractmethod
+        def relation(self, variable: str) -> ConceptMap.Explainable:
+            """
+            Retrieves the explainable relation with the given variable name.
+
+            :param variable: The string representation of a variable
+            :return:
+
+            Examples
+            --------
+            ::
+
+               concept_map.explainables().relation(variable)
+            """
+            pass
+
+        @abstractmethod
+        def attribute(self, variable: str) -> ConceptMap.Explainable:
+            """
+            Retrieves the explainable attribute with the given variable name.
+
+            :param variable: The string representation of a variable
+            :return:
+
+            Examples
+            --------
+            ::
+
+               concept_map.explainables().attribute(variable)
+            """
+            pass
+
+        @abstractmethod
+        def ownership(self, owner: str, attribute: str) -> ConceptMap.Explainable:
+            """
+            Retrieves the explainable attribute ownership with the pair of (owner, attribute) variable names.
+
+            :param owner: The string representation of the owner variable
+            :param attribute: The string representation of the attribute variable
+            :return:
+
+            Examples
+            --------
+            ::
+
+               concept_map.explainables().ownership(owner, attribute)
+            """
+            pass
+
+        @abstractmethod
+        def relations(self) -> Mapping[str, ConceptMap.Explainable]:
+            """
+            Retrieves all of this ``ConceptMap``s explainable relations.
+
+            :return:
+
+            Examples
+            --------
+            ::
+
+               concept_map.explainables().relations()
+            """
+            pass
+
+        @abstractmethod
+        def attributes(self) -> Mapping[str, ConceptMap.Explainable]:
+            """
+            Retrieves all of this ``ConceptMap``s explainable attributes.
+
+            :return:
+
+            Examples
+            --------
+            ::
+
+               concept_map.explainables().attributes()
+            """
+            pass
+
+        @abstractmethod
+        def ownerships(self) -> Mapping[tuple[str, str], ConceptMap.Explainable]:
+            """
+            Retrieves all of this ``ConceptMap``s explainable ownerships.
+
+            :return:
+
+            Examples
+            --------
+            ::
+
+               concept_map.explainables().ownerships()
+            """
+            pass
+
+    class Explainable(ABC):
+        """
+        Contains an explainable object.
+        """
+
+        @abstractmethod
+        def conjunction(self) -> str:
+            """
+            Retrieves the subquery of the original query that is actually being explained.
+
+            :return:
+
+            Examples
+            --------
+            ::
+
+               explainable.conjunction()
+            """
+            pass
+
+        @abstractmethod
+        def id(self) -> int:
+            """
+            Retrieves the unique ID that identifies this ``Explainable``.
+
+            :return:
+
+            Examples
+            --------
+            ::
+
+               explainable.id()
+            """
+            pass
```

## typedb/api/answer/concept_map_group.py

 * *Ordering differences only*

```diff
@@ -1,61 +1,61 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from abc import ABC, abstractmethod
-from typing import Iterator, TYPE_CHECKING
-
-if TYPE_CHECKING:
-    from typedb.api.answer.concept_map import ConceptMap
-    from typedb.api.concept.concept import Concept
-
-
-class ConceptMapGroup(ABC):
-    """
-    Contains an element of the group query result.
-    """
-
-    @abstractmethod
-    def owner(self) -> Concept:
-        """
-        Retrieves the concept that is the group owner.
-
-        :return:
-
-        Examples:
-        ---------
-        ::
-
-            concept_map_group.owner()
-        """
-        pass
-
-    @abstractmethod
-    def concept_maps(self) -> Iterator[ConceptMap]:
-        """
-        Retrieves the ConceptMaps of the group.
-
-        :return:
-
-        Examples:
-        ---------
-        ::
-
-            concept_map_group.concept_maps()
-        """
-        pass
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from abc import ABC, abstractmethod
+from typing import Iterator, TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from typedb.api.answer.concept_map import ConceptMap
+    from typedb.api.concept.concept import Concept
+
+
+class ConceptMapGroup(ABC):
+    """
+    Contains an element of the group query result.
+    """
+
+    @abstractmethod
+    def owner(self) -> Concept:
+        """
+        Retrieves the concept that is the group owner.
+
+        :return:
+
+        Examples:
+        ---------
+        ::
+
+            concept_map_group.owner()
+        """
+        pass
+
+    @abstractmethod
+    def concept_maps(self) -> Iterator[ConceptMap]:
+        """
+        Retrieves the ConceptMaps of the group.
+
+        :return:
+
+        Examples:
+        ---------
+        ::
+
+            concept_map_group.concept_maps()
+        """
+        pass
```

## typedb/api/answer/value_group.py

 * *Ordering differences only*

```diff
@@ -1,61 +1,61 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from abc import ABC, abstractmethod
-from typing import TYPE_CHECKING, Optional
-
-if TYPE_CHECKING:
-    from typedb.api.concept.concept import Concept
-    from typedb.api.concept.value.value import Value
-
-
-class ValueGroup(ABC):
-    """
-    Contains an element of the group aggregate query result.
-    """
-
-    @abstractmethod
-    def owner(self) -> Concept:
-        """
-        Retrieves the concept that is the group owner.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            value_group.owner()
-        """
-        pass
-
-    @abstractmethod
-    def value(self) -> Optional[Value]:
-        """
-        Retrieves the ``Value`` answer of the group.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            value_group.value()
-        """
-        pass
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from abc import ABC, abstractmethod
+from typing import TYPE_CHECKING, Optional
+
+if TYPE_CHECKING:
+    from typedb.api.concept.concept import Concept
+    from typedb.api.concept.value.value import Value
+
+
+class ValueGroup(ABC):
+    """
+    Contains an element of the group aggregate query result.
+    """
+
+    @abstractmethod
+    def owner(self) -> Concept:
+        """
+        Retrieves the concept that is the group owner.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            value_group.owner()
+        """
+        pass
+
+    @abstractmethod
+    def value(self) -> Optional[Value]:
+        """
+        Retrieves the ``Value`` answer of the group.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            value_group.value()
+        """
+        pass
```

## typedb/api/concept/concept.py

 * *Ordering differences only*

```diff
@@ -1,348 +1,348 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from abc import ABC, abstractmethod
-from datetime import datetime
-from typing import Mapping, Union, TYPE_CHECKING
-
-from typedb.common.exception import TypeDBDriverException, INVALID_CONCEPT_CASTING
-
-if TYPE_CHECKING:
-    from typedb.api.concept.thing.attribute import Attribute
-    from typedb.api.concept.thing.entity import Entity
-    from typedb.api.concept.thing.relation import Relation
-    from typedb.api.concept.thing.thing import Thing
-    from typedb.api.concept.type.attribute_type import AttributeType
-    from typedb.api.concept.type.entity_type import EntityType
-    from typedb.api.concept.type.relation_type import RelationType
-    from typedb.api.concept.type.role_type import RoleType
-    from typedb.api.concept.type.thing_type import ThingType
-    from typedb.api.concept.type.type import Type
-    from typedb.api.concept.value.value import Value
-
-
-class Concept(ABC):
-
-    def is_type(self) -> bool:
-        """
-        Checks if the concept is a ``Type``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            concept.is_type()
-        """
-        return False
-
-    def is_thing_type(self) -> bool:
-        """
-        Checks if the concept is a ``ThingType``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            concept.is_thing_type()
-        """
-        return False
-
-    def is_entity_type(self) -> bool:
-        """
-        Checks if the concept is an ``EntityType``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            concept.is_entity_type()
-        """
-        return False
-
-    def is_attribute_type(self) -> bool:
-        """
-        Checks if the concept is an ``AttributeType``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            concept.is_attribute_type()
-        """
-        return False
-
-    def is_relation_type(self) -> bool:
-        """
-        Checks if the concept is a ``RelationType``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            concept.is_relation_type()
-        """
-        return False
-
-    def is_role_type(self) -> bool:
-        """
-        Checks if the concept is a ``RoleType``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            concept.is_role_type()
-        """
-        return False
-
-    def is_thing(self) -> bool:
-        """
-        Checks if the concept is a ``Thing``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            concept.is_thing()
-        """
-        return False
-
-    def is_entity(self) -> bool:
-        """
-        Checks if the concept is an ``Entity``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            concept.is_entity()
-        """
-        return False
-
-    def is_attribute(self) -> bool:
-        """
-        Checks if the concept is an ``Attribute``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            concept.is_attribute()
-        """
-        return False
-
-    def is_relation(self) -> bool:
-        """
-        Checks if the concept is a ``Relation``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            concept.is_relation()
-        """
-        return False
-
-    def is_value(self) -> bool:
-        """
-        Checks if the concept is a ``Value``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            concept.is_value()
-        """
-        return False
-
-    def as_type(self) -> Type:
-        """
-        Casts the concept to ``Type``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            concept.as_type()
-        """
-        raise TypeDBDriverException(INVALID_CONCEPT_CASTING, (self.__class__.__name__, "Type"))
-
-    def as_thing_type(self) -> ThingType:
-        """
-        Casts the concept to ``ThingType``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            concept.as_thing_type()
-        """
-        raise TypeDBDriverException(INVALID_CONCEPT_CASTING, (self.__class__.__name__, "ThingType"))
-
-    def as_entity_type(self) -> EntityType:
-        """
-        Casts the concept to ``EntityType``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            concept.as_entity_type()
-        """
-        raise TypeDBDriverException(INVALID_CONCEPT_CASTING, (self.__class__.__name__, "EntityType"))
-
-    def as_attribute_type(self) -> AttributeType:
-        """
-        Casts the concept to ``AttributeType``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            concept.as_attribute_type()
-        """
-        raise TypeDBDriverException(INVALID_CONCEPT_CASTING, (self.__class__.__name__, "AttributeType"))
-
-    def as_relation_type(self) -> RelationType:
-        """
-        Casts the concept to ``RelationType``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            concept.as_relation_type()
-        """
-        raise TypeDBDriverException(INVALID_CONCEPT_CASTING, (self.__class__.__name__, "RelationType"))
-
-    def as_role_type(self) -> RoleType:
-        """
-        Casts the concept to ``RoleType``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            concept.as_role_type()
-        """
-        raise TypeDBDriverException(INVALID_CONCEPT_CASTING, (self.__class__.__name__, "RoleType"))
-
-    def as_thing(self) -> Thing:
-        """
-        Casts the concept to ``Thing``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            concept.as_thing()
-        """
-        raise TypeDBDriverException(INVALID_CONCEPT_CASTING, (self.__class__.__name__, "Thing"))
-
-    def as_entity(self) -> Entity:
-        """
-        Casts the concept to ``Entity``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            concept.as_entity()
-        """
-        raise TypeDBDriverException(INVALID_CONCEPT_CASTING, (self.__class__.__name__, "Entity"))
-
-    def as_attribute(self) -> Attribute:
-        """
-        Casts the concept to ``Attribute``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            concept.as_attribute()
-        """
-        raise TypeDBDriverException(INVALID_CONCEPT_CASTING, (self.__class__.__name__, "Attribute"))
-
-    def as_relation(self) -> Relation:
-        """
-        Casts the concept to ``Relation``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            concept.as_relation()
-        """
-        raise TypeDBDriverException(INVALID_CONCEPT_CASTING, (self.__class__.__name__, "Relation"))
-
-    def as_value(self) -> Value:
-        """
-        Casts the concept to ``Value``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            concept.as_value()
-        """
-        raise TypeDBDriverException(INVALID_CONCEPT_CASTING, (self.__class__.__name__, "Value"))
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from abc import ABC, abstractmethod
+from datetime import datetime
+from typing import Mapping, Union, TYPE_CHECKING
+
+from typedb.common.exception import TypeDBDriverException, INVALID_CONCEPT_CASTING
+
+if TYPE_CHECKING:
+    from typedb.api.concept.thing.attribute import Attribute
+    from typedb.api.concept.thing.entity import Entity
+    from typedb.api.concept.thing.relation import Relation
+    from typedb.api.concept.thing.thing import Thing
+    from typedb.api.concept.type.attribute_type import AttributeType
+    from typedb.api.concept.type.entity_type import EntityType
+    from typedb.api.concept.type.relation_type import RelationType
+    from typedb.api.concept.type.role_type import RoleType
+    from typedb.api.concept.type.thing_type import ThingType
+    from typedb.api.concept.type.type import Type
+    from typedb.api.concept.value.value import Value
+
+
+class Concept(ABC):
+
+    def is_type(self) -> bool:
+        """
+        Checks if the concept is a ``Type``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            concept.is_type()
+        """
+        return False
+
+    def is_thing_type(self) -> bool:
+        """
+        Checks if the concept is a ``ThingType``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            concept.is_thing_type()
+        """
+        return False
+
+    def is_entity_type(self) -> bool:
+        """
+        Checks if the concept is an ``EntityType``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            concept.is_entity_type()
+        """
+        return False
+
+    def is_attribute_type(self) -> bool:
+        """
+        Checks if the concept is an ``AttributeType``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            concept.is_attribute_type()
+        """
+        return False
+
+    def is_relation_type(self) -> bool:
+        """
+        Checks if the concept is a ``RelationType``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            concept.is_relation_type()
+        """
+        return False
+
+    def is_role_type(self) -> bool:
+        """
+        Checks if the concept is a ``RoleType``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            concept.is_role_type()
+        """
+        return False
+
+    def is_thing(self) -> bool:
+        """
+        Checks if the concept is a ``Thing``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            concept.is_thing()
+        """
+        return False
+
+    def is_entity(self) -> bool:
+        """
+        Checks if the concept is an ``Entity``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            concept.is_entity()
+        """
+        return False
+
+    def is_attribute(self) -> bool:
+        """
+        Checks if the concept is an ``Attribute``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            concept.is_attribute()
+        """
+        return False
+
+    def is_relation(self) -> bool:
+        """
+        Checks if the concept is a ``Relation``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            concept.is_relation()
+        """
+        return False
+
+    def is_value(self) -> bool:
+        """
+        Checks if the concept is a ``Value``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            concept.is_value()
+        """
+        return False
+
+    def as_type(self) -> Type:
+        """
+        Casts the concept to ``Type``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            concept.as_type()
+        """
+        raise TypeDBDriverException(INVALID_CONCEPT_CASTING, (self.__class__.__name__, "Type"))
+
+    def as_thing_type(self) -> ThingType:
+        """
+        Casts the concept to ``ThingType``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            concept.as_thing_type()
+        """
+        raise TypeDBDriverException(INVALID_CONCEPT_CASTING, (self.__class__.__name__, "ThingType"))
+
+    def as_entity_type(self) -> EntityType:
+        """
+        Casts the concept to ``EntityType``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            concept.as_entity_type()
+        """
+        raise TypeDBDriverException(INVALID_CONCEPT_CASTING, (self.__class__.__name__, "EntityType"))
+
+    def as_attribute_type(self) -> AttributeType:
+        """
+        Casts the concept to ``AttributeType``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            concept.as_attribute_type()
+        """
+        raise TypeDBDriverException(INVALID_CONCEPT_CASTING, (self.__class__.__name__, "AttributeType"))
+
+    def as_relation_type(self) -> RelationType:
+        """
+        Casts the concept to ``RelationType``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            concept.as_relation_type()
+        """
+        raise TypeDBDriverException(INVALID_CONCEPT_CASTING, (self.__class__.__name__, "RelationType"))
+
+    def as_role_type(self) -> RoleType:
+        """
+        Casts the concept to ``RoleType``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            concept.as_role_type()
+        """
+        raise TypeDBDriverException(INVALID_CONCEPT_CASTING, (self.__class__.__name__, "RoleType"))
+
+    def as_thing(self) -> Thing:
+        """
+        Casts the concept to ``Thing``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            concept.as_thing()
+        """
+        raise TypeDBDriverException(INVALID_CONCEPT_CASTING, (self.__class__.__name__, "Thing"))
+
+    def as_entity(self) -> Entity:
+        """
+        Casts the concept to ``Entity``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            concept.as_entity()
+        """
+        raise TypeDBDriverException(INVALID_CONCEPT_CASTING, (self.__class__.__name__, "Entity"))
+
+    def as_attribute(self) -> Attribute:
+        """
+        Casts the concept to ``Attribute``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            concept.as_attribute()
+        """
+        raise TypeDBDriverException(INVALID_CONCEPT_CASTING, (self.__class__.__name__, "Attribute"))
+
+    def as_relation(self) -> Relation:
+        """
+        Casts the concept to ``Relation``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            concept.as_relation()
+        """
+        raise TypeDBDriverException(INVALID_CONCEPT_CASTING, (self.__class__.__name__, "Relation"))
+
+    def as_value(self) -> Value:
+        """
+        Casts the concept to ``Value``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            concept.as_value()
+        """
+        raise TypeDBDriverException(INVALID_CONCEPT_CASTING, (self.__class__.__name__, "Value"))
```

## typedb/api/concept/concept_manager.py

 * *Ordering differences only*

```diff
@@ -1,247 +1,247 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from abc import ABC, abstractmethod
-from typing import TYPE_CHECKING
-
-if TYPE_CHECKING:
-    from typedb.api.concept.thing.attribute import Attribute
-    from typedb.api.concept.thing.entity import Entity
-    from typedb.api.concept.thing.relation import Relation
-    from typedb.api.concept.type.attribute_type import AttributeType
-    from typedb.api.concept.type.entity_type import EntityType
-    from typedb.api.concept.type.relation_type import RelationType
-    from typedb.api.concept.value.value import ValueType
-    from typedb.common.exception import TypeDBException
-    from typedb.common.promise import Promise
-
-
-class ConceptManager(ABC):
-    """
-    Provides access for all Concept API methods.
-    """
-
-    @abstractmethod
-    def get_root_entity_type(self) -> EntityType:
-        """
-        Retrieves the root ``EntityType``, "entity".
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            transaction.concepts.get_root_entity_type()
-        """
-        pass
-
-    @abstractmethod
-    def get_root_relation_type(self) -> RelationType:
-        """
-        Retrieve the root ``RelationType``, "relation".
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            transaction.concepts.get_root_relation_type()
-        """
-        pass
-
-    @abstractmethod
-    def get_root_attribute_type(self) -> AttributeType:
-        """
-        Retrieve the root ``AttributeType``, "attribute".
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            transaction.concepts.get_root_attribute_type()
-        """
-        pass
-
-    @abstractmethod
-    def get_entity_type(self, label: str) -> Promise[EntityType]:
-        """
-        Retrieves an ``EntityType`` by its label.
-
-        :param label: The label of the ``EntityType`` to retrieve
-        :return:
-
-        Examples
-        --------
-        ::
-
-            transaction.concepts.get_entity_type(label).resolve()
-        """
-        pass
-
-    @abstractmethod
-    def get_relation_type(self, label: str) -> Promise[RelationType]:
-        """
-        Retrieves a ``RelationType`` by its label.
-
-        :param label: The label of the ``RelationType`` to retrieve
-        :return:
-
-        Examples
-        --------
-        ::
-
-            transaction.concepts.get_relation_type(label).resolve()
-        """
-        pass
-
-    @abstractmethod
-    def get_attribute_type(self, label: str) -> Promise[AttributeType]:
-        """
-        Retrieves an ``AttributeType`` by its label.
-
-        :param label: The label of the ``AttributeType`` to retrieve
-        :return:
-
-        Examples
-        --------
-        ::
-
-            transaction.concepts.get_attribute_type(label).resolve()
-        """
-        pass
-
-    @abstractmethod
-    def put_entity_type(self, label: str) -> Promise[EntityType]:
-        """
-        Creates a new ``EntityType`` if none exists with the given label,
-        otherwise retrieves the existing one.
-
-        :param label: The label of the ``EntityType`` to create or retrieve
-        :return:
-
-        Examples
-        --------
-        ::
-
-            transaction.concepts.put_entity_type(label).resolve()
-        """
-        pass
-
-    @abstractmethod
-    def put_relation_type(self, label: str) -> Promise[RelationType]:
-        """
-        Creates a new ``RelationType`` if none exists with the given label,
-        otherwise retrieves the existing one.
-
-        :param label: The label of the ``RelationType`` to create or retrieve
-        :return:
-
-        Examples
-        --------
-        ::
-
-            transaction.concepts.put_relation_type(label).resolve()
-        """
-        pass
-
-    @abstractmethod
-    def put_attribute_type(self, label: str, value_type: ValueType) -> Promise[AttributeType]:
-        """
-        Creates a new ``AttributeType`` if none exists with the given label,
-        or retrieves the existing one.
-
-        :param label: The label of the ``AttributeType`` to create or retrieve
-        :param value_type: The value type of the ``AttributeType`` to create
-            or retrieve.
-        :return:
-
-        Examples
-        --------
-        ::
-
-            transaction.concepts.put_attribute_type(label, value_type).resolve()
-        """
-        pass
-
-    @abstractmethod
-    def get_entity(self, iid: str) -> Promise[Entity]:
-        """
-        Retrieves an ``Entity`` by its iid.
-
-        :param iid: The iid of the ``Entity`` to retrieve
-        :return:
-
-        Examples
-        --------
-        ::
-
-            transaction.concepts.get_entity(iid).resolve()
-        """
-        pass
-
-    @abstractmethod
-    def get_relation(self, iid: str) -> Promise[Relation]:
-        """
-        Retrieves a ``Relation`` by its iid.
-
-        :param iid: The iid of the ``Relation`` to retrieve
-        :return:
-
-        Examples
-        --------
-        ::
-
-            transaction.concepts.get_relation(iid).resolve()
-        """
-        pass
-
-    @abstractmethod
-    def get_attribute(self, iid: str) -> Promise[Attribute]:
-        """
-        Retrieves an ``Attribute`` by its iid.
-
-        :param iid: The iid of the ``Attribute`` to retrieve
-        :return:
-
-        Examples
-        --------
-        ::
-
-            transaction.concepts.get_attribute(iid).resolve()
-        """
-        pass
-
-    @abstractmethod
-    def get_schema_exception(self) -> list[TypeDBException]:
-        """
-        Retrieves a list of all schema exceptions for the current transaction.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            transaction.concepts.get_schema_exception()
-        """
-        pass
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from abc import ABC, abstractmethod
+from typing import TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from typedb.api.concept.thing.attribute import Attribute
+    from typedb.api.concept.thing.entity import Entity
+    from typedb.api.concept.thing.relation import Relation
+    from typedb.api.concept.type.attribute_type import AttributeType
+    from typedb.api.concept.type.entity_type import EntityType
+    from typedb.api.concept.type.relation_type import RelationType
+    from typedb.api.concept.value.value import ValueType
+    from typedb.common.exception import TypeDBException
+    from typedb.common.promise import Promise
+
+
+class ConceptManager(ABC):
+    """
+    Provides access for all Concept API methods.
+    """
+
+    @abstractmethod
+    def get_root_entity_type(self) -> EntityType:
+        """
+        Retrieves the root ``EntityType``, "entity".
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            transaction.concepts.get_root_entity_type()
+        """
+        pass
+
+    @abstractmethod
+    def get_root_relation_type(self) -> RelationType:
+        """
+        Retrieve the root ``RelationType``, "relation".
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            transaction.concepts.get_root_relation_type()
+        """
+        pass
+
+    @abstractmethod
+    def get_root_attribute_type(self) -> AttributeType:
+        """
+        Retrieve the root ``AttributeType``, "attribute".
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            transaction.concepts.get_root_attribute_type()
+        """
+        pass
+
+    @abstractmethod
+    def get_entity_type(self, label: str) -> Promise[EntityType]:
+        """
+        Retrieves an ``EntityType`` by its label.
+
+        :param label: The label of the ``EntityType`` to retrieve
+        :return:
+
+        Examples
+        --------
+        ::
+
+            transaction.concepts.get_entity_type(label).resolve()
+        """
+        pass
+
+    @abstractmethod
+    def get_relation_type(self, label: str) -> Promise[RelationType]:
+        """
+        Retrieves a ``RelationType`` by its label.
+
+        :param label: The label of the ``RelationType`` to retrieve
+        :return:
+
+        Examples
+        --------
+        ::
+
+            transaction.concepts.get_relation_type(label).resolve()
+        """
+        pass
+
+    @abstractmethod
+    def get_attribute_type(self, label: str) -> Promise[AttributeType]:
+        """
+        Retrieves an ``AttributeType`` by its label.
+
+        :param label: The label of the ``AttributeType`` to retrieve
+        :return:
+
+        Examples
+        --------
+        ::
+
+            transaction.concepts.get_attribute_type(label).resolve()
+        """
+        pass
+
+    @abstractmethod
+    def put_entity_type(self, label: str) -> Promise[EntityType]:
+        """
+        Creates a new ``EntityType`` if none exists with the given label,
+        otherwise retrieves the existing one.
+
+        :param label: The label of the ``EntityType`` to create or retrieve
+        :return:
+
+        Examples
+        --------
+        ::
+
+            transaction.concepts.put_entity_type(label).resolve()
+        """
+        pass
+
+    @abstractmethod
+    def put_relation_type(self, label: str) -> Promise[RelationType]:
+        """
+        Creates a new ``RelationType`` if none exists with the given label,
+        otherwise retrieves the existing one.
+
+        :param label: The label of the ``RelationType`` to create or retrieve
+        :return:
+
+        Examples
+        --------
+        ::
+
+            transaction.concepts.put_relation_type(label).resolve()
+        """
+        pass
+
+    @abstractmethod
+    def put_attribute_type(self, label: str, value_type: ValueType) -> Promise[AttributeType]:
+        """
+        Creates a new ``AttributeType`` if none exists with the given label,
+        or retrieves the existing one.
+
+        :param label: The label of the ``AttributeType`` to create or retrieve
+        :param value_type: The value type of the ``AttributeType`` to create
+            or retrieve.
+        :return:
+
+        Examples
+        --------
+        ::
+
+            transaction.concepts.put_attribute_type(label, value_type).resolve()
+        """
+        pass
+
+    @abstractmethod
+    def get_entity(self, iid: str) -> Promise[Entity]:
+        """
+        Retrieves an ``Entity`` by its iid.
+
+        :param iid: The iid of the ``Entity`` to retrieve
+        :return:
+
+        Examples
+        --------
+        ::
+
+            transaction.concepts.get_entity(iid).resolve()
+        """
+        pass
+
+    @abstractmethod
+    def get_relation(self, iid: str) -> Promise[Relation]:
+        """
+        Retrieves a ``Relation`` by its iid.
+
+        :param iid: The iid of the ``Relation`` to retrieve
+        :return:
+
+        Examples
+        --------
+        ::
+
+            transaction.concepts.get_relation(iid).resolve()
+        """
+        pass
+
+    @abstractmethod
+    def get_attribute(self, iid: str) -> Promise[Attribute]:
+        """
+        Retrieves an ``Attribute`` by its iid.
+
+        :param iid: The iid of the ``Attribute`` to retrieve
+        :return:
+
+        Examples
+        --------
+        ::
+
+            transaction.concepts.get_attribute(iid).resolve()
+        """
+        pass
+
+    @abstractmethod
+    def get_schema_exception(self) -> list[TypeDBException]:
+        """
+        Retrieves a list of all schema exceptions for the current transaction.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            transaction.concepts.get_schema_exception()
+        """
+        pass
```

## typedb/api/concept/thing/attribute.py

 * *Ordering differences only*

```diff
@@ -1,291 +1,291 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from abc import ABC, abstractmethod
-from typing import TYPE_CHECKING, Iterator, Mapping, Union, Optional
-
-from typedb.api.concept.thing.thing import Thing
-
-if TYPE_CHECKING:
-    from datetime import datetime
-    from typedb.api.concept.value.value import ValueType
-    from typedb.api.concept.type.attribute_type import AttributeType
-    from typedb.api.concept.type.thing_type import ThingType
-    from typedb.api.connection.transaction import TypeDBTransaction
-
-
-class Attribute(Thing, ABC):
-    """
-    Attribute is an instance of the attribute type and has a value.
-    This value is fixed and unique for every given instance of the
-    attribute type.
-
-    Attributes can be uniquely addressed by their type and value.
-    """
-
-    @abstractmethod
-    def get_type(self) -> AttributeType:
-        """
-        Retrieves the type which this ``Attribute`` belongs to.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            attribute.get_type()
-        """
-        pass
-
-    @abstractmethod
-    def get_value(self) -> Union[bool, int, float, str, datetime]:
-        """
-        Retrieves the value which the ``Attribute`` instance holds.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            attribute.get_value()
-        """
-        pass
-
-    @abstractmethod
-    def get_value_type(self) -> ValueType:
-        """
-        Retrieves the type of the value which the ``Attribute`` instance holds.
-
-        :return:
-        Examples
-        --------
-        ::
-
-            attribute.get_value_type()
-        """
-        pass
-
-    def is_attribute(self) -> bool:
-        """
-        Checks if the concept is an ``Attribute``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            attribute.is_attribute()
-        """
-        return True
-
-    def as_attribute(self) -> Attribute:
-        """
-        Casts the concept to ``Attribute``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            attribute.as_attribute()
-        """
-        return self
-
-    @abstractmethod
-    def is_boolean(self) -> bool:
-        """
-        Returns ``True`` if the attribute value is of type ``boolean``.
-        Otherwise, returns ``False``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            attribute.is_boolean()
-        """
-        pass
-
-    @abstractmethod
-    def is_long(self) -> bool:
-        """
-        Returns ``True`` if the attribute value is of type ``long``.
-        Otherwise, returns ``False``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            attribute.is_long()
-        """
-        pass
-
-    @abstractmethod
-    def is_double(self) -> bool:
-        """
-        Returns ``True`` if the attribute value is of type ``double``.
-        Otherwise, returns ``False``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            attribute.is_double()
-        """
-        pass
-
-    @abstractmethod
-    def is_string(self) -> bool:
-        """
-        Returns ``True`` if the attribute value is of type ``string``.
-        Otherwise, returns ``False``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            attribute.is_string()
-        """
-        pass
-
-    @abstractmethod
-    def is_datetime(self) -> bool:
-        """
-        Returns ``True`` if the attribute value is of type ``datetime``.
-        Otherwise, returns ``False``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            attribute.is_datetime()
-        """
-        pass
-
-    @abstractmethod
-    def as_boolean(self) -> bool:
-        """
-        Returns a ``boolean`` value of the attribute. If the value has
-        another type, raises an exception.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            attribute.as_boolean()
-        """
-        pass
-
-    @abstractmethod
-    def as_long(self) -> int:
-        """
-        Returns a ``long`` value of the attribute. If the value has
-        another type, raises an exception.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            attribute.as_long()
-        """
-        pass
-
-    @abstractmethod
-    def as_double(self) -> float:
-        """
-        Returns a ``double`` value of the attribute. If the value has
-        another type, raises an exception.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            attribute.as_boolean()
-        """
-        pass
-
-    @abstractmethod
-    def as_string(self) -> str:
-        """
-        Returns a ``string`` value of the attribute. If the value has
-        another type, raises an exception.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            attribute.as_boolean()
-        """
-        pass
-
-    @abstractmethod
-    def as_datetime(self) -> datetime:
-        """
-        Returns a ``datetime`` value of the attribute. If the value has
-        another type, raises an exception.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            attribute.as_boolean()
-        """
-        pass
-
-    @abstractmethod
-    def get_owners(self, transaction: TypeDBTransaction, owner_type: Optional[ThingType] = None) -> Iterator[Thing]:
-        """
-        Retrieves the instances that own this ``Attribute``.
-
-        :param transaction: The current transaction
-        :param owner_type: If specified, filter results for only owners
-            of the given type
-        :return:
-
-        Examples
-        --------
-        ::
-
-             attribute.get_owners(transaction)
-            attribute.get_owners(transaction, owner_type)
-        """
-        pass
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from abc import ABC, abstractmethod
+from typing import TYPE_CHECKING, Iterator, Mapping, Union, Optional
+
+from typedb.api.concept.thing.thing import Thing
+
+if TYPE_CHECKING:
+    from datetime import datetime
+    from typedb.api.concept.value.value import ValueType
+    from typedb.api.concept.type.attribute_type import AttributeType
+    from typedb.api.concept.type.thing_type import ThingType
+    from typedb.api.connection.transaction import TypeDBTransaction
+
+
+class Attribute(Thing, ABC):
+    """
+    Attribute is an instance of the attribute type and has a value.
+    This value is fixed and unique for every given instance of the
+    attribute type.
+
+    Attributes can be uniquely addressed by their type and value.
+    """
+
+    @abstractmethod
+    def get_type(self) -> AttributeType:
+        """
+        Retrieves the type which this ``Attribute`` belongs to.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            attribute.get_type()
+        """
+        pass
+
+    @abstractmethod
+    def get_value(self) -> Union[bool, int, float, str, datetime]:
+        """
+        Retrieves the value which the ``Attribute`` instance holds.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            attribute.get_value()
+        """
+        pass
+
+    @abstractmethod
+    def get_value_type(self) -> ValueType:
+        """
+        Retrieves the type of the value which the ``Attribute`` instance holds.
+
+        :return:
+        Examples
+        --------
+        ::
+
+            attribute.get_value_type()
+        """
+        pass
+
+    def is_attribute(self) -> bool:
+        """
+        Checks if the concept is an ``Attribute``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            attribute.is_attribute()
+        """
+        return True
+
+    def as_attribute(self) -> Attribute:
+        """
+        Casts the concept to ``Attribute``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            attribute.as_attribute()
+        """
+        return self
+
+    @abstractmethod
+    def is_boolean(self) -> bool:
+        """
+        Returns ``True`` if the attribute value is of type ``boolean``.
+        Otherwise, returns ``False``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            attribute.is_boolean()
+        """
+        pass
+
+    @abstractmethod
+    def is_long(self) -> bool:
+        """
+        Returns ``True`` if the attribute value is of type ``long``.
+        Otherwise, returns ``False``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            attribute.is_long()
+        """
+        pass
+
+    @abstractmethod
+    def is_double(self) -> bool:
+        """
+        Returns ``True`` if the attribute value is of type ``double``.
+        Otherwise, returns ``False``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            attribute.is_double()
+        """
+        pass
+
+    @abstractmethod
+    def is_string(self) -> bool:
+        """
+        Returns ``True`` if the attribute value is of type ``string``.
+        Otherwise, returns ``False``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            attribute.is_string()
+        """
+        pass
+
+    @abstractmethod
+    def is_datetime(self) -> bool:
+        """
+        Returns ``True`` if the attribute value is of type ``datetime``.
+        Otherwise, returns ``False``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            attribute.is_datetime()
+        """
+        pass
+
+    @abstractmethod
+    def as_boolean(self) -> bool:
+        """
+        Returns a ``boolean`` value of the attribute. If the value has
+        another type, raises an exception.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            attribute.as_boolean()
+        """
+        pass
+
+    @abstractmethod
+    def as_long(self) -> int:
+        """
+        Returns a ``long`` value of the attribute. If the value has
+        another type, raises an exception.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            attribute.as_long()
+        """
+        pass
+
+    @abstractmethod
+    def as_double(self) -> float:
+        """
+        Returns a ``double`` value of the attribute. If the value has
+        another type, raises an exception.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            attribute.as_boolean()
+        """
+        pass
+
+    @abstractmethod
+    def as_string(self) -> str:
+        """
+        Returns a ``string`` value of the attribute. If the value has
+        another type, raises an exception.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            attribute.as_boolean()
+        """
+        pass
+
+    @abstractmethod
+    def as_datetime(self) -> datetime:
+        """
+        Returns a ``datetime`` value of the attribute. If the value has
+        another type, raises an exception.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            attribute.as_boolean()
+        """
+        pass
+
+    @abstractmethod
+    def get_owners(self, transaction: TypeDBTransaction, owner_type: Optional[ThingType] = None) -> Iterator[Thing]:
+        """
+        Retrieves the instances that own this ``Attribute``.
+
+        :param transaction: The current transaction
+        :param owner_type: If specified, filter results for only owners
+            of the given type
+        :return:
+
+        Examples
+        --------
+        ::
+
+             attribute.get_owners(transaction)
+            attribute.get_owners(transaction, owner_type)
+        """
+        pass
```

## typedb/api/concept/thing/entity.py

 * *Ordering differences only*

```diff
@@ -1,79 +1,79 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from abc import ABC, abstractmethod
-from typing import TYPE_CHECKING
-
-from typedb.api.concept.thing.thing import Thing
-
-if TYPE_CHECKING:
-    from typedb.api.concept.type.entity_type import EntityType
-
-
-class Entity(Thing, ABC):
-    """
-    Instance of data of an entity type, representing a standalone object
-    that exists in the data model independently.
-
-    Entity does not have a value. It is usually addressed by its ownership
-    over attribute instances and/or roles played in relation instances.
-    """
-
-    def is_entity(self) -> bool:
-        """
-        Checks if the concept is an ``Entity``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            entity.is_entity()
-        """
-        return True
-
-    def as_entity(self) -> Entity:
-        """
-        Casts the concept to ``Entity``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            entity.as_entity()
-        """
-        return self
-
-    @abstractmethod
-    def get_type(self) -> EntityType:
-        """
-        Retrieves the type which this ``Entity`` belongs to.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            entity.get_type()
-        """
-        pass
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from abc import ABC, abstractmethod
+from typing import TYPE_CHECKING
+
+from typedb.api.concept.thing.thing import Thing
+
+if TYPE_CHECKING:
+    from typedb.api.concept.type.entity_type import EntityType
+
+
+class Entity(Thing, ABC):
+    """
+    Instance of data of an entity type, representing a standalone object
+    that exists in the data model independently.
+
+    Entity does not have a value. It is usually addressed by its ownership
+    over attribute instances and/or roles played in relation instances.
+    """
+
+    def is_entity(self) -> bool:
+        """
+        Checks if the concept is an ``Entity``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            entity.is_entity()
+        """
+        return True
+
+    def as_entity(self) -> Entity:
+        """
+        Casts the concept to ``Entity``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            entity.as_entity()
+        """
+        return self
+
+    @abstractmethod
+    def get_type(self) -> EntityType:
+        """
+        Retrieves the type which this ``Entity`` belongs to.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            entity.get_type()
+        """
+        pass
```

## typedb/api/concept/thing/relation.py

 * *Ordering differences only*

```diff
@@ -1,167 +1,167 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from abc import ABC, abstractmethod
-from typing import TYPE_CHECKING, Iterator
-
-from typedb.api.concept.thing.thing import Thing
-
-if TYPE_CHECKING:
-    from typedb.api.concept.type.role_type import RoleType
-    from typedb.api.concept.type.relation_type import RelationType
-    from typedb.api.connection.transaction import TypeDBTransaction
-    from typedb.common.promise import Promise
-
-
-class Relation(Thing, ABC):
-    """
-    Relation is an instance of a relation type and can be uniquely addressed
-    by a combination of its type, owned attributes and role players.
-    """
-
-    def is_relation(self) -> bool:
-        """
-        Checks if the concept is a ``Relation``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            relation.is_relation()
-        """
-        return True
-
-    def as_relation(self) -> Relation:
-        """
-        Casts the concept to ``Relation``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            relation.as_relation()
-        """
-        return self
-
-    @abstractmethod
-    def get_type(self) -> RelationType:
-        """
-        Retrieves the type which this ``Relation`` belongs to.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            relation.get_type()
-        """
-        pass
-
-    @abstractmethod
-    def add_player(self, transaction: TypeDBTransaction, role_type: RoleType, player: Thing) -> Promise[None]:
-        """
-        Adds a new role player to play the given role in this ``Relation``.
-
-        :param transaction: The current transaction
-        :param role_type: The role to be played by the ``player``
-        :param player: The thing to play the role
-        :return:
-
-        Examples
-        --------
-        ::
-
-            relation.add_player(transaction, role_type, player).resolve()
-        """
-        pass
-
-    @abstractmethod
-    def remove_player(self, transaction: TypeDBTransaction, role_type: RoleType, player: Thing) -> Promise[None]:
-        """
-        Removes the association of the given instance that plays the given role in this ``Relation``.
-
-        :param transaction: The current transaction
-        :param role_type: The role to no longer be played by the thing in this ``Relation``
-        :param player: The instance to no longer play the role in this ``Relation``
-        :return:
-
-        Examples
-        --------
-        ::
-
-            relation.remove_player(transaction, role_type, player).resolve()
-        """
-        pass
-
-    @abstractmethod
-    def get_players_by_role_type(self, transaction: TypeDBTransaction, *role_types: RoleType) -> Iterator[Thing]:
-        """
-        Retrieves all role players of this ``Relation``, optionally
-        filtered by given role types.
-
-        :param transaction: The current transaction
-        :param role_types: 0 or more role types
-        :return:
-
-        Examples
-        --------
-        ::
-
-            relation.get_players_by_role_type(transaction)
-            relation.get_players_by_role_type(transaction, role_type1, role_type2)
-        """
-        pass
-
-    @abstractmethod
-    def get_players(self, transaction: TypeDBTransaction) -> dict[RoleType, list[Thing]]:
-        """
-        Retrieves a mapping of all instances involved in the ``Relation``
-        and the role each play.
-
-        :param transaction: The current transaction
-        :return:
-
-        Examples
-        --------
-        ::
-
-            relation.get_players(transaction)
-        """
-        pass
-
-    @abstractmethod
-    def get_relating(self, transaction: TypeDBTransaction) -> Iterator[RoleType]:
-        """
-        Retrieves all role types currently played in this ``Relation``.
-
-        :param transaction: The current transaction
-        :return:
-
-        Examples
-        --------
-        ::
-
-            relation.get_relating(transaction)
-        """
-        pass
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from abc import ABC, abstractmethod
+from typing import TYPE_CHECKING, Iterator
+
+from typedb.api.concept.thing.thing import Thing
+
+if TYPE_CHECKING:
+    from typedb.api.concept.type.role_type import RoleType
+    from typedb.api.concept.type.relation_type import RelationType
+    from typedb.api.connection.transaction import TypeDBTransaction
+    from typedb.common.promise import Promise
+
+
+class Relation(Thing, ABC):
+    """
+    Relation is an instance of a relation type and can be uniquely addressed
+    by a combination of its type, owned attributes and role players.
+    """
+
+    def is_relation(self) -> bool:
+        """
+        Checks if the concept is a ``Relation``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            relation.is_relation()
+        """
+        return True
+
+    def as_relation(self) -> Relation:
+        """
+        Casts the concept to ``Relation``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            relation.as_relation()
+        """
+        return self
+
+    @abstractmethod
+    def get_type(self) -> RelationType:
+        """
+        Retrieves the type which this ``Relation`` belongs to.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            relation.get_type()
+        """
+        pass
+
+    @abstractmethod
+    def add_player(self, transaction: TypeDBTransaction, role_type: RoleType, player: Thing) -> Promise[None]:
+        """
+        Adds a new role player to play the given role in this ``Relation``.
+
+        :param transaction: The current transaction
+        :param role_type: The role to be played by the ``player``
+        :param player: The thing to play the role
+        :return:
+
+        Examples
+        --------
+        ::
+
+            relation.add_player(transaction, role_type, player).resolve()
+        """
+        pass
+
+    @abstractmethod
+    def remove_player(self, transaction: TypeDBTransaction, role_type: RoleType, player: Thing) -> Promise[None]:
+        """
+        Removes the association of the given instance that plays the given role in this ``Relation``.
+
+        :param transaction: The current transaction
+        :param role_type: The role to no longer be played by the thing in this ``Relation``
+        :param player: The instance to no longer play the role in this ``Relation``
+        :return:
+
+        Examples
+        --------
+        ::
+
+            relation.remove_player(transaction, role_type, player).resolve()
+        """
+        pass
+
+    @abstractmethod
+    def get_players_by_role_type(self, transaction: TypeDBTransaction, *role_types: RoleType) -> Iterator[Thing]:
+        """
+        Retrieves all role players of this ``Relation``, optionally
+        filtered by given role types.
+
+        :param transaction: The current transaction
+        :param role_types: 0 or more role types
+        :return:
+
+        Examples
+        --------
+        ::
+
+            relation.get_players_by_role_type(transaction)
+            relation.get_players_by_role_type(transaction, role_type1, role_type2)
+        """
+        pass
+
+    @abstractmethod
+    def get_players(self, transaction: TypeDBTransaction) -> dict[RoleType, list[Thing]]:
+        """
+        Retrieves a mapping of all instances involved in the ``Relation``
+        and the role each play.
+
+        :param transaction: The current transaction
+        :return:
+
+        Examples
+        --------
+        ::
+
+            relation.get_players(transaction)
+        """
+        pass
+
+    @abstractmethod
+    def get_relating(self, transaction: TypeDBTransaction) -> Iterator[RoleType]:
+        """
+        Retrieves all role types currently played in this ``Relation``.
+
+        :param transaction: The current transaction
+        :return:
+
+        Examples
+        --------
+        ::
+
+            relation.get_relating(transaction)
+        """
+        pass
```

## typedb/api/concept/thing/thing.py

 * *Ordering differences only*

```diff
@@ -1,243 +1,243 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from abc import ABC, abstractmethod
-from typing import TYPE_CHECKING, Iterator, Mapping
-
-from typedb.api.concept.concept import Concept
-
-if TYPE_CHECKING:
-    from typedb.api.concept.thing.attribute import Attribute
-    from typedb.api.concept.thing.relation import Relation
-    from typedb.api.concept.type.attribute_type import AttributeType
-    from typedb.api.concept.type.role_type import RoleType
-    from typedb.api.concept.type.thing_type import ThingType
-    from typedb.api.concept.type.annotation import Annotation
-    from typedb.api.connection.transaction import TypeDBTransaction
-    from typedb.common.promise import Promise
-
-
-class Thing(Concept, ABC):
-    @abstractmethod
-    def get_iid(self) -> str:
-        """
-        Retrieves the unique id of the ``Thing``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            thing.get_iid()
-        """
-        pass
-
-    @abstractmethod
-    def get_type(self) -> ThingType:
-        """
-        Retrieves the type which this ``Thing`` belongs to.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            thing.get_type()
-        """
-        pass
-
-    @abstractmethod
-    def is_inferred(self) -> bool:
-        """
-        Checks if this ``Thing`` is inferred by a [Reasoning Rule].
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            thing.is_inferred()
-        """
-        pass
-
-    def is_thing(self) -> bool:
-        """
-        Checks if the concept is a ``Thing``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            thing.is_thing()
-        """
-        return True
-
-    def as_thing(self) -> Thing:
-        """
-        Casts the concept to ``Thing``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            thing.as_thing()
-        """
-        return self
-
-    @abstractmethod
-    def set_has(self, transaction: TypeDBTransaction, attribute: Attribute) -> Promise[None]:
-        """
-        Assigns an ``Attribute`` to be owned by this ``Thing``.
-
-        :param transaction: The current transaction
-        :param attribute: The ``Attribute`` to be owned by this ``Thing``.
-        :return:
-
-        Examples
-        --------
-        ::
-
-            thing.set_has(transaction, attribute).resolve()
-        """
-        pass
-
-    @abstractmethod
-    def unset_has(self, transaction: TypeDBTransaction, attribute: Attribute) -> Promise[None]:
-        """
-        Unassigns an ``Attribute`` from this ``Thing``.
-
-        :param transaction: The current transaction
-        :param attribute: The ``Attribute`` to be disowned from this ``Thing``.
-        :return:
-
-        Examples
-        --------
-        ::
-
-            thing.unset_has(transaction, attribute).resolve()
-        """
-        pass
-
-    @abstractmethod
-    def get_has(
-        self,
-        transaction: TypeDBTransaction,
-        attribute_type: AttributeType = None,
-        attribute_types: list[AttributeType] = None,
-        annotations: set[Annotation] = frozenset()
-    ) -> Iterator[Attribute]:
-        """
-        Retrieves the ``Attribute``\ s that this ``Thing`` owns.
-        Optionally, filtered by an ``AttributeType`` or a list of
-        ``AttributeType``\ s.
-        Optionally, filtered by ``Annotation``\ s.
-
-        :param transaction: The current transaction
-        :param attribute_type: The ``AttributeType`` to filter
-            the attributes by
-        :param attribute_types: The ``AttributeType``\ s to filter
-            the attributes by
-        :param annotations: Only retrieve attributes with all given
-            ``Annotation``\ s
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            thing.get_has(transaction)
-           thing.get_has(transaction, attribute_type=attribute_type,
-                         annotations=set(Annotation.key()))
-        """
-        pass
-
-    @abstractmethod
-    def get_relations(self, transaction: TypeDBTransaction, *role_types: RoleType) -> Iterator[Relation]:
-        """
-        Retrieves all the ``Relation``\ s which this ``Thing`` plays a role in,
-        optionally filtered by one or more given roles.
-
-        :param transaction: The current transaction
-        :param role_types: 0 or more role types to filter the relations by.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            thing.get_relations(transaction, role_types)
-        """
-        pass
-
-    @abstractmethod
-    def get_playing(self, transaction: TypeDBTransaction) -> Iterator[RoleType]:
-        """
-        Retrieves the roles that this ``Thing`` is currently playing.
-
-        :param transaction: The current transaction
-        :return:
-
-        Examples
-        --------
-        ::
-
-            thing.get_playing(transaction)
-        """
-        pass
-
-    @abstractmethod
-    def delete(self, transaction: TypeDBTransaction) -> Promise[None]:
-        """
-        Deletes this ``Thing``.
-
-        :param transaction: The current transaction
-        :return:
-
-        Examples
-        --------
-        ::
-
-            thing.delete(transaction).resolve()
-        """
-        pass
-
-    @abstractmethod
-    def is_deleted(self, transaction: TypeDBTransaction) -> Promise[bool]:
-        """
-        Checks if this ``Thing`` is deleted.
-
-        :param transaction: The current transaction
-        :return:
-
-        Examples
-        --------
-        ::
-
-            thing.is_deleted(transaction).resolve()
-        """
-        pass
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from abc import ABC, abstractmethod
+from typing import TYPE_CHECKING, Iterator, Mapping
+
+from typedb.api.concept.concept import Concept
+
+if TYPE_CHECKING:
+    from typedb.api.concept.thing.attribute import Attribute
+    from typedb.api.concept.thing.relation import Relation
+    from typedb.api.concept.type.attribute_type import AttributeType
+    from typedb.api.concept.type.role_type import RoleType
+    from typedb.api.concept.type.thing_type import ThingType
+    from typedb.api.concept.type.annotation import Annotation
+    from typedb.api.connection.transaction import TypeDBTransaction
+    from typedb.common.promise import Promise
+
+
+class Thing(Concept, ABC):
+    @abstractmethod
+    def get_iid(self) -> str:
+        """
+        Retrieves the unique id of the ``Thing``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            thing.get_iid()
+        """
+        pass
+
+    @abstractmethod
+    def get_type(self) -> ThingType:
+        """
+        Retrieves the type which this ``Thing`` belongs to.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            thing.get_type()
+        """
+        pass
+
+    @abstractmethod
+    def is_inferred(self) -> bool:
+        """
+        Checks if this ``Thing`` is inferred by a [Reasoning Rule].
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            thing.is_inferred()
+        """
+        pass
+
+    def is_thing(self) -> bool:
+        """
+        Checks if the concept is a ``Thing``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            thing.is_thing()
+        """
+        return True
+
+    def as_thing(self) -> Thing:
+        """
+        Casts the concept to ``Thing``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            thing.as_thing()
+        """
+        return self
+
+    @abstractmethod
+    def set_has(self, transaction: TypeDBTransaction, attribute: Attribute) -> Promise[None]:
+        """
+        Assigns an ``Attribute`` to be owned by this ``Thing``.
+
+        :param transaction: The current transaction
+        :param attribute: The ``Attribute`` to be owned by this ``Thing``.
+        :return:
+
+        Examples
+        --------
+        ::
+
+            thing.set_has(transaction, attribute).resolve()
+        """
+        pass
+
+    @abstractmethod
+    def unset_has(self, transaction: TypeDBTransaction, attribute: Attribute) -> Promise[None]:
+        """
+        Unassigns an ``Attribute`` from this ``Thing``.
+
+        :param transaction: The current transaction
+        :param attribute: The ``Attribute`` to be disowned from this ``Thing``.
+        :return:
+
+        Examples
+        --------
+        ::
+
+            thing.unset_has(transaction, attribute).resolve()
+        """
+        pass
+
+    @abstractmethod
+    def get_has(
+        self,
+        transaction: TypeDBTransaction,
+        attribute_type: AttributeType = None,
+        attribute_types: list[AttributeType] = None,
+        annotations: set[Annotation] = frozenset()
+    ) -> Iterator[Attribute]:
+        """
+        Retrieves the ``Attribute``\ s that this ``Thing`` owns.
+        Optionally, filtered by an ``AttributeType`` or a list of
+        ``AttributeType``\ s.
+        Optionally, filtered by ``Annotation``\ s.
+
+        :param transaction: The current transaction
+        :param attribute_type: The ``AttributeType`` to filter
+            the attributes by
+        :param attribute_types: The ``AttributeType``\ s to filter
+            the attributes by
+        :param annotations: Only retrieve attributes with all given
+            ``Annotation``\ s
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            thing.get_has(transaction)
+           thing.get_has(transaction, attribute_type=attribute_type,
+                         annotations=set(Annotation.key()))
+        """
+        pass
+
+    @abstractmethod
+    def get_relations(self, transaction: TypeDBTransaction, *role_types: RoleType) -> Iterator[Relation]:
+        """
+        Retrieves all the ``Relation``\ s which this ``Thing`` plays a role in,
+        optionally filtered by one or more given roles.
+
+        :param transaction: The current transaction
+        :param role_types: 0 or more role types to filter the relations by.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            thing.get_relations(transaction, role_types)
+        """
+        pass
+
+    @abstractmethod
+    def get_playing(self, transaction: TypeDBTransaction) -> Iterator[RoleType]:
+        """
+        Retrieves the roles that this ``Thing`` is currently playing.
+
+        :param transaction: The current transaction
+        :return:
+
+        Examples
+        --------
+        ::
+
+            thing.get_playing(transaction)
+        """
+        pass
+
+    @abstractmethod
+    def delete(self, transaction: TypeDBTransaction) -> Promise[None]:
+        """
+        Deletes this ``Thing``.
+
+        :param transaction: The current transaction
+        :return:
+
+        Examples
+        --------
+        ::
+
+            thing.delete(transaction).resolve()
+        """
+        pass
+
+    @abstractmethod
+    def is_deleted(self, transaction: TypeDBTransaction) -> Promise[bool]:
+        """
+        Checks if this ``Thing`` is deleted.
+
+        :param transaction: The current transaction
+        :return:
+
+        Examples
+        --------
+        ::
+
+            thing.is_deleted(transaction).resolve()
+        """
+        pass
```

## typedb/api/concept/type/annotation.py

 * *Ordering differences only*

```diff
@@ -1,104 +1,104 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from typedb.native_driver_wrapper import Annotation as NativeAnnotation, annotation_new_key, annotation_new_unique, \
-    annotation_is_key, annotation_is_unique, annotation_to_string, annotation_equals
-
-
-class Annotation:
-
-    def __init__(self, annotation: NativeAnnotation):
-        self._native_object = annotation
-
-    @property
-    def native_object(self) -> NativeAnnotation:
-        return self._native_object
-
-    @staticmethod
-    def key() -> Annotation:
-        """
-        Produces a ``@key`` annotation.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            Annotation.key()
-        """
-        return Annotation(annotation_new_key())
-
-    @staticmethod
-    def unique() -> Annotation:
-        """
-        Produces a ``@unique`` annotation.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            Annotation.unique()
-        """
-        return Annotation(annotation_new_unique())
-
-    def is_key(self) -> bool:
-        """
-        Checks if this ``Annotation`` is a ``@key`` annotation.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            annotation.is_key()
-        """
-        return annotation_is_key(self.native_object)
-
-    def is_unique(self) -> bool:
-        """
-        Checks if this ``Annotation`` is a ``@unique`` annotation.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            annotation.is_unique()
-        """
-        return annotation_is_unique(self.native_object)
-
-    def __str__(self):
-        return annotation_to_string(self.native_object)
-
-    def __repr__(self):
-        return f"Annotation({self.native_object})"
-
-    def __hash__(self):
-        return hash((self.is_key(), self.is_unique()))
-
-    def __eq__(self, other):
-        return isinstance(other, Annotation) \
-            and isinstance(self.native_object, NativeAnnotation) \
-            and isinstance(other.native_object, NativeAnnotation) \
-            and annotation_equals(self.native_object, other.native_object)
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from typedb.native_driver_wrapper import Annotation as NativeAnnotation, annotation_new_key, annotation_new_unique, \
+    annotation_is_key, annotation_is_unique, annotation_to_string, annotation_equals
+
+
+class Annotation:
+
+    def __init__(self, annotation: NativeAnnotation):
+        self._native_object = annotation
+
+    @property
+    def native_object(self) -> NativeAnnotation:
+        return self._native_object
+
+    @staticmethod
+    def key() -> Annotation:
+        """
+        Produces a ``@key`` annotation.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            Annotation.key()
+        """
+        return Annotation(annotation_new_key())
+
+    @staticmethod
+    def unique() -> Annotation:
+        """
+        Produces a ``@unique`` annotation.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            Annotation.unique()
+        """
+        return Annotation(annotation_new_unique())
+
+    def is_key(self) -> bool:
+        """
+        Checks if this ``Annotation`` is a ``@key`` annotation.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            annotation.is_key()
+        """
+        return annotation_is_key(self.native_object)
+
+    def is_unique(self) -> bool:
+        """
+        Checks if this ``Annotation`` is a ``@unique`` annotation.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            annotation.is_unique()
+        """
+        return annotation_is_unique(self.native_object)
+
+    def __str__(self):
+        return annotation_to_string(self.native_object)
+
+    def __repr__(self):
+        return f"Annotation({self.native_object})"
+
+    def __hash__(self):
+        return hash((self.is_key(), self.is_unique()))
+
+    def __eq__(self, other):
+        return isinstance(other, Annotation) \
+            and isinstance(self.native_object, NativeAnnotation) \
+            and isinstance(other.native_object, NativeAnnotation) \
+            and annotation_equals(self.native_object, other.native_object)
```

## typedb/api/concept/type/attribute_type.py

 * *Ordering differences only*

```diff
@@ -1,358 +1,358 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from abc import ABC, abstractmethod
-from datetime import datetime
-from typing import Optional, TYPE_CHECKING, Iterator, Union
-
-from typedb.api.concept.type.thing_type import ThingType
-from typedb.api.concept.value.value import ValueType
-from typedb.common.transitivity import Transitivity
-
-if TYPE_CHECKING:
-    from typedb.api.concept.value.value import Value
-    from typedb.api.concept.type.annotation import Annotation
-    from typedb.api.concept.thing.attribute import Attribute
-    from typedb.api.connection.transaction import TypeDBTransaction
-    from typedb.common.promise import Promise
-
-
-class AttributeType(ThingType, ABC):
-    """
-    Attribute types represent properties that other types can own.
-
-    Attribute types have a value type. This value type is fixed and unique
-    for every given instance of the attribute type.
-
-    Other types can own an attribute type. That means that instances of these
-    other types can own an instance of this attribute type.
-    This usually means that an object in our domain has a property
-    with the matching value.
-
-    Multiple types can own the same attribute type, and different instances
-    of the same type or different types can share ownership of the same
-    attribute instance.
-    """
-
-    def get_value_type(self) -> ValueType:
-        """
-        Retrieves the ``ValueType`` of this ``AttributeType``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            attribute_type.get_value_type()
-        """
-        return ValueType.OBJECT
-
-    def as_attribute_type(self) -> AttributeType:
-        """
-        Casts the concept to ``AttributeType``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            attribute.as_attribute_type()
-        """
-        return self
-
-    def is_attribute_type(self) -> bool:
-        """
-        Checks if the concept is an ``AttributeType``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            attribute.is_attribute_type()
-        """
-        return True
-
-    def is_boolean(self) -> bool:
-        """
-        Returns ``True`` if the value for attributes of this type is
-        of type ``boolean``. Otherwise, returns ``False``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            attribute_type.is_boolean()
-        """
-        return self.get_value_type() == ValueType.BOOLEAN
-
-    def is_long(self) -> bool:
-        """
-        Returns ``True`` if the value for attributes of this type is
-        of type ``long``. Otherwise, returns ``False``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            attribute_type.is_long()
-        """
-        return self.get_value_type() == ValueType.LONG
-
-    def is_double(self) -> bool:
-        """
-        Returns ``True`` if the value for attributes of this type is
-        of type ``double``. Otherwise, returns ``False``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            attribute_type.is_double()
-        """
-        return self.get_value_type() == ValueType.DOUBLE
-
-    def is_string(self) -> bool:
-        """
-        Returns ``True`` if the value for attributes of this type is
-        of type ``string``. Otherwise, returns ``False``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            attribute_type.is_string()
-        """
-        return self.get_value_type() == ValueType.STRING
-
-    def is_datetime(self) -> bool:
-        """
-        Returns ``True`` if the value for attributes of this type is
-        of type ``datetime``. Otherwise, returns ``False``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            attribute_type.is_datetime()
-        """
-        return self.get_value_type() == ValueType.DATETIME
-
-    @abstractmethod
-    def put(self, transaction: TypeDBTransaction, value: Union[Value, bool, int, float, str, datetime]) -> Promise[Attribute]:
-        '''
-        Adds and returns an ``Attribute`` of this ``AttributeType`` with the given value.
-
-        :param transaction: The current transaction
-        :param value: New ``Attribute``'s value (datetime values are treated as timezone naive, with tzinfo being ignored)
-        :return:
-
-        Examples
-        --------
-        ::
-
-            attribute = attribute_type.put(transaction, value).resolve()
-        '''
-        pass
-
-    @abstractmethod
-    def get(self, transaction: TypeDBTransaction, value: Union[Value, bool, int, float, str,
-                                                               datetime]) -> Promise[Optional[Attribute]]:
-        '''
-        Retrieves an ``Attribute`` of this ``AttributeType`` with the given value
-        if such ``Attribute`` exists. Otherwise, returns ``None``.
-
-        :param transaction: The current transaction
-        :param value: ``Attribute``'s value
-        :return:
-
-        Examples
-        --------
-        ::
-
-            attribute = attribute_type.get(transaction, value).resolve()
-        '''
-        pass
-
-    @abstractmethod
-    def get_regex(self, transaction: TypeDBTransaction) -> Promise[str]:
-        """
-        Retrieves the regular expression that is defined
-        for this ``AttributeType``.
-
-        :param transaction: The current transaction
-        :return:
-
-        Examples
-        --------
-        ::
-
-            attribute_type.get_regex(transaction).resolve()
-        """
-        pass
-
-    @abstractmethod
-    def set_regex(self, transaction: TypeDBTransaction, regex: str) -> Promise[None]:
-        """
-        Sets a regular expression as a constraint for this ``AttributeType``.
-        ``Values`` of all ``Attribute``\ s of this type (inserted earlier
-        or later) should match this regex.
-
-        Can only be applied for ``AttributeType``\ s with a ``string``
-        value type.
-
-        :param transaction: The current transaction
-        :param regex: Regular expression
-        :return:
-
-        Examples
-        --------
-        ::
-
-            attribute_type.set_regex(transaction, regex).resolve()
-        """
-        pass
-
-    @abstractmethod
-    def unset_regex(self, transaction: TypeDBTransaction) -> Promise[None]:
-        """
-        Removes the regular expression that is defined
-        for this ``AttributeType``.
-
-        :param transaction: The current transaction
-        :return:
-
-        Examples
-        --------
-        ::
-
-            attribute_type.unset_regex(transaction).resolve()
-        """
-        pass
-
-    @abstractmethod
-    def set_supertype(self, transaction: TypeDBTransaction, super_attribute_type: AttributeType) -> Promise[None]:
-        """
-        Sets the supplied ``AttributeType`` as the supertype of
-        the current ``AttributeType``.
-
-        :param transaction: The current transaction
-        :param super_attribute_type: The ``AttributeType`` to set as
-            the supertype of this ``AttributeType``
-        :return:
-
-        Examples
-        --------
-        ::
-
-            attribute_type.set_supertype(transaction, super_attribute_type).resolve()
-        """
-        pass
-
-    @abstractmethod
-    def get_subtypes_with_value_type(
-        self,
-        transaction: TypeDBTransaction,
-        value_type: ValueType,
-        transitivity: Transitivity = Transitivity.TRANSITIVE
-    ) -> Iterator[AttributeType]:
-        """
-        Retrieves all direct and indirect (or direct only) subtypes
-        of this ``AttributeType`` with given ``ValueType``.
-
-        :param transaction: The current transaction
-        :param value_type: ``ValueType`` for retrieving subtypes
-        :param transitivity: ``Transitivity.TRANSITIVE`` for direct
-            and indirect subtypes, ``Transitivity.EXPLICIT`` for direct
-            subtypes only
-        :return:
-
-        Examples
-        --------
-        ::
-
-            attribute_type.get_subtypes_with_value_type(transaction, value_type)
-            attribute_type.get_subtypes_with_value_type(transaction, value_type,
-                                                        Transitivity.EXPLICIT)
-        """
-        pass
-
-    @abstractmethod
-    def get_instances(self,
-                      transaction: TypeDBTransaction,
-                      transitivity: Transitivity = Transitivity.TRANSITIVE) -> Iterator[Attribute]:
-        """
-        Retrieves all direct and indirect (or direct only) ``Attributes``
-        that are instances of this ``AttributeType``.
-
-        :param transaction: The current transaction
-        :param transitivity: ``Transitivity.TRANSITIVE`` for direct
-            and indirect subtypes, ``Transitivity.EXPLICIT`` for direct
-            subtypes only
-        :return:
-
-        Examples
-        --------
-        ::
-
-            attribute_type.get_instances(transaction)
-            attribute_type.get_instances(transaction, Transitivity.EXPLICIT)
-        """
-        pass
-
-    @abstractmethod
-    def get_owners(
-        self,
-        transaction: TypeDBTransaction,
-        annotations: Optional[set[Annotation]] = None,
-        transitivity: Transitivity = Transitivity.TRANSITIVE
-    ) -> Iterator[ThingType]:
-        """
-        Retrieve all ``Things`` that own an attribute of this ``AttributeType``.
-        Optionally, filtered by ``Annotation``\ s.
-
-        :param transaction: The current transaction
-        :param annotations: Only retrieve ``ThingTypes`` that have an attribute
-            of this ``AttributeType`` with all given ``Annotation``\ s
-        :param transitivity: ``Transitivity.TRANSITIVE`` for direct
-            and inherited ownership, ``Transitivity.EXPLICIT`` for direct
-            ownership only
-        :return:
-
-        Examples
-        --------
-        ::
-
-            attribute_type.get_owners(transaction)
-            attribute_type.get_owners(transaction, annotations=Annotation.unique(), transitivity=Transitivity.EXPLICIT)
-        """
-        pass
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from abc import ABC, abstractmethod
+from datetime import datetime
+from typing import Optional, TYPE_CHECKING, Iterator, Union
+
+from typedb.api.concept.type.thing_type import ThingType
+from typedb.api.concept.value.value import ValueType
+from typedb.common.transitivity import Transitivity
+
+if TYPE_CHECKING:
+    from typedb.api.concept.value.value import Value
+    from typedb.api.concept.type.annotation import Annotation
+    from typedb.api.concept.thing.attribute import Attribute
+    from typedb.api.connection.transaction import TypeDBTransaction
+    from typedb.common.promise import Promise
+
+
+class AttributeType(ThingType, ABC):
+    """
+    Attribute types represent properties that other types can own.
+
+    Attribute types have a value type. This value type is fixed and unique
+    for every given instance of the attribute type.
+
+    Other types can own an attribute type. That means that instances of these
+    other types can own an instance of this attribute type.
+    This usually means that an object in our domain has a property
+    with the matching value.
+
+    Multiple types can own the same attribute type, and different instances
+    of the same type or different types can share ownership of the same
+    attribute instance.
+    """
+
+    def get_value_type(self) -> ValueType:
+        """
+        Retrieves the ``ValueType`` of this ``AttributeType``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            attribute_type.get_value_type()
+        """
+        return ValueType.OBJECT
+
+    def as_attribute_type(self) -> AttributeType:
+        """
+        Casts the concept to ``AttributeType``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            attribute.as_attribute_type()
+        """
+        return self
+
+    def is_attribute_type(self) -> bool:
+        """
+        Checks if the concept is an ``AttributeType``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            attribute.is_attribute_type()
+        """
+        return True
+
+    def is_boolean(self) -> bool:
+        """
+        Returns ``True`` if the value for attributes of this type is
+        of type ``boolean``. Otherwise, returns ``False``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            attribute_type.is_boolean()
+        """
+        return self.get_value_type() == ValueType.BOOLEAN
+
+    def is_long(self) -> bool:
+        """
+        Returns ``True`` if the value for attributes of this type is
+        of type ``long``. Otherwise, returns ``False``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            attribute_type.is_long()
+        """
+        return self.get_value_type() == ValueType.LONG
+
+    def is_double(self) -> bool:
+        """
+        Returns ``True`` if the value for attributes of this type is
+        of type ``double``. Otherwise, returns ``False``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            attribute_type.is_double()
+        """
+        return self.get_value_type() == ValueType.DOUBLE
+
+    def is_string(self) -> bool:
+        """
+        Returns ``True`` if the value for attributes of this type is
+        of type ``string``. Otherwise, returns ``False``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            attribute_type.is_string()
+        """
+        return self.get_value_type() == ValueType.STRING
+
+    def is_datetime(self) -> bool:
+        """
+        Returns ``True`` if the value for attributes of this type is
+        of type ``datetime``. Otherwise, returns ``False``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            attribute_type.is_datetime()
+        """
+        return self.get_value_type() == ValueType.DATETIME
+
+    @abstractmethod
+    def put(self, transaction: TypeDBTransaction, value: Union[Value, bool, int, float, str, datetime]) -> Promise[Attribute]:
+        '''
+        Adds and returns an ``Attribute`` of this ``AttributeType`` with the given value.
+
+        :param transaction: The current transaction
+        :param value: New ``Attribute``'s value (datetime values are treated as timezone naive, with tzinfo being ignored)
+        :return:
+
+        Examples
+        --------
+        ::
+
+            attribute = attribute_type.put(transaction, value).resolve()
+        '''
+        pass
+
+    @abstractmethod
+    def get(self, transaction: TypeDBTransaction, value: Union[Value, bool, int, float, str,
+                                                               datetime]) -> Promise[Optional[Attribute]]:
+        '''
+        Retrieves an ``Attribute`` of this ``AttributeType`` with the given value
+        if such ``Attribute`` exists. Otherwise, returns ``None``.
+
+        :param transaction: The current transaction
+        :param value: ``Attribute``'s value
+        :return:
+
+        Examples
+        --------
+        ::
+
+            attribute = attribute_type.get(transaction, value).resolve()
+        '''
+        pass
+
+    @abstractmethod
+    def get_regex(self, transaction: TypeDBTransaction) -> Promise[str]:
+        """
+        Retrieves the regular expression that is defined
+        for this ``AttributeType``.
+
+        :param transaction: The current transaction
+        :return:
+
+        Examples
+        --------
+        ::
+
+            attribute_type.get_regex(transaction).resolve()
+        """
+        pass
+
+    @abstractmethod
+    def set_regex(self, transaction: TypeDBTransaction, regex: str) -> Promise[None]:
+        """
+        Sets a regular expression as a constraint for this ``AttributeType``.
+        ``Values`` of all ``Attribute``\ s of this type (inserted earlier
+        or later) should match this regex.
+
+        Can only be applied for ``AttributeType``\ s with a ``string``
+        value type.
+
+        :param transaction: The current transaction
+        :param regex: Regular expression
+        :return:
+
+        Examples
+        --------
+        ::
+
+            attribute_type.set_regex(transaction, regex).resolve()
+        """
+        pass
+
+    @abstractmethod
+    def unset_regex(self, transaction: TypeDBTransaction) -> Promise[None]:
+        """
+        Removes the regular expression that is defined
+        for this ``AttributeType``.
+
+        :param transaction: The current transaction
+        :return:
+
+        Examples
+        --------
+        ::
+
+            attribute_type.unset_regex(transaction).resolve()
+        """
+        pass
+
+    @abstractmethod
+    def set_supertype(self, transaction: TypeDBTransaction, super_attribute_type: AttributeType) -> Promise[None]:
+        """
+        Sets the supplied ``AttributeType`` as the supertype of
+        the current ``AttributeType``.
+
+        :param transaction: The current transaction
+        :param super_attribute_type: The ``AttributeType`` to set as
+            the supertype of this ``AttributeType``
+        :return:
+
+        Examples
+        --------
+        ::
+
+            attribute_type.set_supertype(transaction, super_attribute_type).resolve()
+        """
+        pass
+
+    @abstractmethod
+    def get_subtypes_with_value_type(
+        self,
+        transaction: TypeDBTransaction,
+        value_type: ValueType,
+        transitivity: Transitivity = Transitivity.TRANSITIVE
+    ) -> Iterator[AttributeType]:
+        """
+        Retrieves all direct and indirect (or direct only) subtypes
+        of this ``AttributeType`` with given ``ValueType``.
+
+        :param transaction: The current transaction
+        :param value_type: ``ValueType`` for retrieving subtypes
+        :param transitivity: ``Transitivity.TRANSITIVE`` for direct
+            and indirect subtypes, ``Transitivity.EXPLICIT`` for direct
+            subtypes only
+        :return:
+
+        Examples
+        --------
+        ::
+
+            attribute_type.get_subtypes_with_value_type(transaction, value_type)
+            attribute_type.get_subtypes_with_value_type(transaction, value_type,
+                                                        Transitivity.EXPLICIT)
+        """
+        pass
+
+    @abstractmethod
+    def get_instances(self,
+                      transaction: TypeDBTransaction,
+                      transitivity: Transitivity = Transitivity.TRANSITIVE) -> Iterator[Attribute]:
+        """
+        Retrieves all direct and indirect (or direct only) ``Attributes``
+        that are instances of this ``AttributeType``.
+
+        :param transaction: The current transaction
+        :param transitivity: ``Transitivity.TRANSITIVE`` for direct
+            and indirect subtypes, ``Transitivity.EXPLICIT`` for direct
+            subtypes only
+        :return:
+
+        Examples
+        --------
+        ::
+
+            attribute_type.get_instances(transaction)
+            attribute_type.get_instances(transaction, Transitivity.EXPLICIT)
+        """
+        pass
+
+    @abstractmethod
+    def get_owners(
+        self,
+        transaction: TypeDBTransaction,
+        annotations: Optional[set[Annotation]] = None,
+        transitivity: Transitivity = Transitivity.TRANSITIVE
+    ) -> Iterator[ThingType]:
+        """
+        Retrieve all ``Things`` that own an attribute of this ``AttributeType``.
+        Optionally, filtered by ``Annotation``\ s.
+
+        :param transaction: The current transaction
+        :param annotations: Only retrieve ``ThingTypes`` that have an attribute
+            of this ``AttributeType`` with all given ``Annotation``\ s
+        :param transitivity: ``Transitivity.TRANSITIVE`` for direct
+            and inherited ownership, ``Transitivity.EXPLICIT`` for direct
+            ownership only
+        :return:
+
+        Examples
+        --------
+        ::
+
+            attribute_type.get_owners(transaction)
+            attribute_type.get_owners(transaction, annotations=Annotation.unique(), transitivity=Transitivity.EXPLICIT)
+        """
+        pass
```

## typedb/api/concept/type/entity_type.py

 * *Ordering differences only*

```diff
@@ -1,146 +1,146 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from abc import ABC, abstractmethod
-from typing import TYPE_CHECKING, Iterator
-
-from typedb.api.concept.type.thing_type import ThingType
-from typedb.common.transitivity import Transitivity
-
-if TYPE_CHECKING:
-    from typedb.api.concept.thing.entity import Entity
-    from typedb.api.connection.transaction import TypeDBTransaction
-    from typedb.common.promise import Promise
-
-
-class EntityType(ThingType, ABC):
-    """
-    Entity types represent the classification of independent objects
-    in the data model of the business domain.
-    """
-
-    def is_entity_type(self) -> bool:
-        """
-        Checks if the concept is an ``EntityType``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            entity_type.is_entity_type()
-        """
-        return True
-
-    def as_entity_type(self) -> EntityType:
-        """
-        Casts the concept to ``EntityType``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            entity_type.as_entity_type()
-        """
-        return self
-
-    @abstractmethod
-    def create(self, transaction: TypeDBTransaction) -> Promise[Entity]:
-        """
-        Creates and returns a new instance of this ``EntityType``.
-
-        :param transaction: The current transaction
-        :return:
-
-        Examples
-        --------
-        ::
-
-            entity_type.create(transaction).resolve()
-        """
-        pass
-
-    @abstractmethod
-    def get_subtypes(
-        self,
-        transaction: TypeDBTransaction,
-        transitivity: Transitivity = Transitivity.TRANSITIVE,
-    ) -> Iterator[EntityType]:
-        """
-        Retrieves all direct and indirect (or direct only) subtypes of the
-        ``EntityType``.
-
-        :param transaction: The current transaction
-        :param transitivity: ``Transitivity.TRANSITIVE`` for direct
-            and indirect subtypes, ``Transitivity.EXPLICIT`` for direct
-            subtypes only
-        :return:
-
-        Examples
-        --------
-        ::
-
-            entity_type.get_subtypes(transaction, transitivity)
-        """
-        pass
-
-    @abstractmethod
-    def get_instances(
-        self,
-        transaction: TypeDBTransaction,
-        transitivity: Transitivity = Transitivity.TRANSITIVE,
-    ) -> Iterator[Entity]:
-        """
-        Retrieves all direct and indirect (or direct only) ``Entity`` objects
-        that are instances of this ``EntityType``.
-
-        :param transaction: The current transaction
-        :param transitivity: ``Transitivity.TRANSITIVE`` for direct
-            and indirect instances, ``Transitivity.EXPLICIT`` for direct
-            instances only
-        :return:
-
-        Examples
-        --------
-        ::
-
-            entity_type.get_instances(transaction, transitivity)
-        """
-        pass
-
-    @abstractmethod
-    def set_supertype(self, transaction: TypeDBTransaction, super_entity_type: EntityType) -> Promise[None]:
-        """
-        Sets the supplied ``EntityType`` as the supertype of the current ``EntityType``.
-
-        :param transaction: The current transaction
-        :param super_entity_type: The ``EntityType`` to set as the supertype of
-            this ``EntityType``
-        :return:
-
-        Examples
-        --------
-        ::
-
-            entity_type.set_supertype(transaction, super_entity_type).resolve()
-        """
-        pass
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from abc import ABC, abstractmethod
+from typing import TYPE_CHECKING, Iterator
+
+from typedb.api.concept.type.thing_type import ThingType
+from typedb.common.transitivity import Transitivity
+
+if TYPE_CHECKING:
+    from typedb.api.concept.thing.entity import Entity
+    from typedb.api.connection.transaction import TypeDBTransaction
+    from typedb.common.promise import Promise
+
+
+class EntityType(ThingType, ABC):
+    """
+    Entity types represent the classification of independent objects
+    in the data model of the business domain.
+    """
+
+    def is_entity_type(self) -> bool:
+        """
+        Checks if the concept is an ``EntityType``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            entity_type.is_entity_type()
+        """
+        return True
+
+    def as_entity_type(self) -> EntityType:
+        """
+        Casts the concept to ``EntityType``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            entity_type.as_entity_type()
+        """
+        return self
+
+    @abstractmethod
+    def create(self, transaction: TypeDBTransaction) -> Promise[Entity]:
+        """
+        Creates and returns a new instance of this ``EntityType``.
+
+        :param transaction: The current transaction
+        :return:
+
+        Examples
+        --------
+        ::
+
+            entity_type.create(transaction).resolve()
+        """
+        pass
+
+    @abstractmethod
+    def get_subtypes(
+        self,
+        transaction: TypeDBTransaction,
+        transitivity: Transitivity = Transitivity.TRANSITIVE,
+    ) -> Iterator[EntityType]:
+        """
+        Retrieves all direct and indirect (or direct only) subtypes of the
+        ``EntityType``.
+
+        :param transaction: The current transaction
+        :param transitivity: ``Transitivity.TRANSITIVE`` for direct
+            and indirect subtypes, ``Transitivity.EXPLICIT`` for direct
+            subtypes only
+        :return:
+
+        Examples
+        --------
+        ::
+
+            entity_type.get_subtypes(transaction, transitivity)
+        """
+        pass
+
+    @abstractmethod
+    def get_instances(
+        self,
+        transaction: TypeDBTransaction,
+        transitivity: Transitivity = Transitivity.TRANSITIVE,
+    ) -> Iterator[Entity]:
+        """
+        Retrieves all direct and indirect (or direct only) ``Entity`` objects
+        that are instances of this ``EntityType``.
+
+        :param transaction: The current transaction
+        :param transitivity: ``Transitivity.TRANSITIVE`` for direct
+            and indirect instances, ``Transitivity.EXPLICIT`` for direct
+            instances only
+        :return:
+
+        Examples
+        --------
+        ::
+
+            entity_type.get_instances(transaction, transitivity)
+        """
+        pass
+
+    @abstractmethod
+    def set_supertype(self, transaction: TypeDBTransaction, super_entity_type: EntityType) -> Promise[None]:
+        """
+        Sets the supplied ``EntityType`` as the supertype of the current ``EntityType``.
+
+        :param transaction: The current transaction
+        :param super_entity_type: The ``EntityType`` to set as the supertype of
+            this ``EntityType``
+        :return:
+
+        Examples
+        --------
+        ::
+
+            entity_type.set_supertype(transaction, super_entity_type).resolve()
+        """
+        pass
```

## typedb/api/concept/type/relation_type.py

 * *Ordering differences only*

```diff
@@ -1,240 +1,240 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from abc import ABC, abstractmethod
-from typing import TYPE_CHECKING, Iterator, Union, Optional
-
-from typedb.api.concept.type.thing_type import ThingType
-from typedb.common.transitivity import Transitivity
-
-if TYPE_CHECKING:
-    from typedb.api.concept.thing.relation import Relation
-    from typedb.api.concept.type.role_type import RoleType
-    from typedb.api.connection.transaction import TypeDBTransaction
-    from typedb.common.promise import Promise
-
-
-class RelationType(ThingType, ABC):
-    """
-    Relation types (or subtypes of the relation root type) represent relationships
-    between types. Relation types have roles.
-
-    Other types can play roles in relations if its mentioned in their definition.
-
-    A relation type must specify at least one role.
-    """
-
-    def is_relation_type(self) -> bool:
-        """
-        Checks if the concept is a ``RelationType``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            relation_type.is_relation_type()
-        """
-        return True
-
-    def as_relation_type(self) -> RelationType:
-        """
-        Casts the concept to ``RelationType``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            relation_type.as_relation_type()
-        """
-        return self
-
-    @abstractmethod
-    def create(self, transaction: TypeDBTransaction) -> Promise[Relation]:
-        """
-        Creates and returns an instance of this ``RelationType``.
-
-        :param transaction: The current transaction
-        :return:
-
-        Examples
-        --------
-        ::
-
-            relation_type.create(transaction).resolve()
-        """
-        pass
-
-    @abstractmethod
-    def get_instances(
-        self,
-        transaction: TypeDBTransaction,
-        transitivity: Transitivity = Transitivity.TRANSITIVE,
-    ) -> Iterator[Relation]:
-        """
-        Retrieves all direct and indirect (or direct only) ``Relation``\ s
-        that are instances of this ``RelationType``.
-
-        :param transaction: The current transaction
-        :param transitivity: ``Transitivity.TRANSITIVE`` for direct
-            and indirect instances, ``Transitivity.EXPLICIT`` for direct
-            relates only
-        :return:
-
-        Examples
-        --------
-        ::
-
-            relation_type.get_instances(transaction, transitivity)
-        """
-        pass
-
-    @abstractmethod
-    def get_relates(
-        self,
-        transaction: TypeDBTransaction,
-        role_label: Optional[str] = None,
-        transitivity: Transitivity = Transitivity.TRANSITIVE,
-    ) -> Union[Promise[Optional[RoleType]], Iterator[RoleType]]:
-        """
-        Retrieves roles that this ``RelationType`` relates to directly
-        or via inheritance. If ``role_label`` is given, returns
-        a corresponding ``RoleType`` or ``None``.
-
-        :param transaction: The current transaction
-        :param role_label: Label of the role we wish to retrieve (optional)
-        :param transitivity: ``Transitivity.TRANSITIVE`` for direct
-            and inherited relates, ``Transitivity.EXPLICIT`` for direct
-            relates only
-        :return:
-
-        Examples
-        --------
-        ::
-
-            relation_type.get_relates(transaction, role_label, transitivity).resolve()
-            relation_type.get_relates(transaction, transitivity)
-        """
-        pass
-
-    @abstractmethod
-    def get_relates_overridden(self, transaction: TypeDBTransaction, role_label: str) -> Promise[Optional[RoleType]]:
-        """
-        Retrieves a ``RoleType`` that is overridden by the role with
-        the ``role_label``.
-
-        :param transaction: The current transaction
-        :param role_label: Label of the role that overrides an inherited role
-        :return:
-
-        Examples
-        --------
-        ::
-
-            relation_type.get_relates_overridden(transaction, role_label).resolve()
-        """
-        pass
-
-    @abstractmethod
-    def set_relates(
-        self,
-        transaction: TypeDBTransaction,
-        role_label: str,
-        overridden_label: Optional[str] = None,
-    ) -> Promise[None]:
-        """
-        Sets the new role that this ``RelationType`` relates to.
-        If we are setting an overriding type this way, we have to also pass
-        the overridden type as a second argument.
-
-        :param transaction: The current transaction
-        :param role_label: The new role for the ``RelationType`` to relate to
-        :param overridden_label: The label being overridden, if applicable
-        :return:
-
-        Examples
-        --------
-        ::
-
-            relation_type.set_relates(transaction, role_label).resolve()
-            relation_type.set_relates(transaction, role_label, overridden_label).resolve()
-        """
-        pass
-
-    @abstractmethod
-    def unset_relates(self, transaction: TypeDBTransaction, role_label: str) -> Promise[None]:
-        """
-        Disallows this ``RelationType`` from relating to the given role.
-
-        :param transaction: The current transaction
-        :param role_label: The role to not relate to the relation type.
-        :return:
-
-        Examples
-        --------
-        ::
-
-            relation_type.unset_relates(transaction, role_label).resolve()
-        """
-        pass
-
-    @abstractmethod
-    def get_subtypes(
-        self,
-        transaction: TypeDBTransaction,
-        transitivity: Transitivity = Transitivity.TRANSITIVE,
-    ) -> Iterator[RelationType]:
-        """
-        Retrieves all direct and indirect (or direct only) subtypes
-        of the ``RelationType``.
-
-        :param transaction: The current transaction
-        :param transitivity: ``Transitivity.TRANSITIVE`` for direct
-            and indirect subtypes, ``Transitivity.EXPLICIT`` for direct
-            subtypes only
-        :return:
-
-        Examples
-        --------
-        ::
-
-            relation_type.get_subtypes(transaction, transitivity)
-        """
-        pass
-
-    @abstractmethod
-    def set_supertype(self, transaction: TypeDBTransaction, super_relation_type: RelationType) -> Promise[None]:
-        """
-        Sets the supplied ``RelationType`` as the supertype of the current ``RelationType``.
-
-        :param transaction: The current transaction
-        :param super_relation_type: The ``RelationType`` to set as the supertype
-            of this ``RelationType``
-        :return:
-
-        Examples
-        --------
-        ::
-
-            relation_type.set_supertype(transaction, super_relation_type).resolve()
-        """
-        pass
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from abc import ABC, abstractmethod
+from typing import TYPE_CHECKING, Iterator, Union, Optional
+
+from typedb.api.concept.type.thing_type import ThingType
+from typedb.common.transitivity import Transitivity
+
+if TYPE_CHECKING:
+    from typedb.api.concept.thing.relation import Relation
+    from typedb.api.concept.type.role_type import RoleType
+    from typedb.api.connection.transaction import TypeDBTransaction
+    from typedb.common.promise import Promise
+
+
+class RelationType(ThingType, ABC):
+    """
+    Relation types (or subtypes of the relation root type) represent relationships
+    between types. Relation types have roles.
+
+    Other types can play roles in relations if its mentioned in their definition.
+
+    A relation type must specify at least one role.
+    """
+
+    def is_relation_type(self) -> bool:
+        """
+        Checks if the concept is a ``RelationType``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            relation_type.is_relation_type()
+        """
+        return True
+
+    def as_relation_type(self) -> RelationType:
+        """
+        Casts the concept to ``RelationType``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            relation_type.as_relation_type()
+        """
+        return self
+
+    @abstractmethod
+    def create(self, transaction: TypeDBTransaction) -> Promise[Relation]:
+        """
+        Creates and returns an instance of this ``RelationType``.
+
+        :param transaction: The current transaction
+        :return:
+
+        Examples
+        --------
+        ::
+
+            relation_type.create(transaction).resolve()
+        """
+        pass
+
+    @abstractmethod
+    def get_instances(
+        self,
+        transaction: TypeDBTransaction,
+        transitivity: Transitivity = Transitivity.TRANSITIVE,
+    ) -> Iterator[Relation]:
+        """
+        Retrieves all direct and indirect (or direct only) ``Relation``\ s
+        that are instances of this ``RelationType``.
+
+        :param transaction: The current transaction
+        :param transitivity: ``Transitivity.TRANSITIVE`` for direct
+            and indirect instances, ``Transitivity.EXPLICIT`` for direct
+            relates only
+        :return:
+
+        Examples
+        --------
+        ::
+
+            relation_type.get_instances(transaction, transitivity)
+        """
+        pass
+
+    @abstractmethod
+    def get_relates(
+        self,
+        transaction: TypeDBTransaction,
+        role_label: Optional[str] = None,
+        transitivity: Transitivity = Transitivity.TRANSITIVE,
+    ) -> Union[Promise[Optional[RoleType]], Iterator[RoleType]]:
+        """
+        Retrieves roles that this ``RelationType`` relates to directly
+        or via inheritance. If ``role_label`` is given, returns
+        a corresponding ``RoleType`` or ``None``.
+
+        :param transaction: The current transaction
+        :param role_label: Label of the role we wish to retrieve (optional)
+        :param transitivity: ``Transitivity.TRANSITIVE`` for direct
+            and inherited relates, ``Transitivity.EXPLICIT`` for direct
+            relates only
+        :return:
+
+        Examples
+        --------
+        ::
+
+            relation_type.get_relates(transaction, role_label, transitivity).resolve()
+            relation_type.get_relates(transaction, transitivity)
+        """
+        pass
+
+    @abstractmethod
+    def get_relates_overridden(self, transaction: TypeDBTransaction, role_label: str) -> Promise[Optional[RoleType]]:
+        """
+        Retrieves a ``RoleType`` that is overridden by the role with
+        the ``role_label``.
+
+        :param transaction: The current transaction
+        :param role_label: Label of the role that overrides an inherited role
+        :return:
+
+        Examples
+        --------
+        ::
+
+            relation_type.get_relates_overridden(transaction, role_label).resolve()
+        """
+        pass
+
+    @abstractmethod
+    def set_relates(
+        self,
+        transaction: TypeDBTransaction,
+        role_label: str,
+        overridden_label: Optional[str] = None,
+    ) -> Promise[None]:
+        """
+        Sets the new role that this ``RelationType`` relates to.
+        If we are setting an overriding type this way, we have to also pass
+        the overridden type as a second argument.
+
+        :param transaction: The current transaction
+        :param role_label: The new role for the ``RelationType`` to relate to
+        :param overridden_label: The label being overridden, if applicable
+        :return:
+
+        Examples
+        --------
+        ::
+
+            relation_type.set_relates(transaction, role_label).resolve()
+            relation_type.set_relates(transaction, role_label, overridden_label).resolve()
+        """
+        pass
+
+    @abstractmethod
+    def unset_relates(self, transaction: TypeDBTransaction, role_label: str) -> Promise[None]:
+        """
+        Disallows this ``RelationType`` from relating to the given role.
+
+        :param transaction: The current transaction
+        :param role_label: The role to not relate to the relation type.
+        :return:
+
+        Examples
+        --------
+        ::
+
+            relation_type.unset_relates(transaction, role_label).resolve()
+        """
+        pass
+
+    @abstractmethod
+    def get_subtypes(
+        self,
+        transaction: TypeDBTransaction,
+        transitivity: Transitivity = Transitivity.TRANSITIVE,
+    ) -> Iterator[RelationType]:
+        """
+        Retrieves all direct and indirect (or direct only) subtypes
+        of the ``RelationType``.
+
+        :param transaction: The current transaction
+        :param transitivity: ``Transitivity.TRANSITIVE`` for direct
+            and indirect subtypes, ``Transitivity.EXPLICIT`` for direct
+            subtypes only
+        :return:
+
+        Examples
+        --------
+        ::
+
+            relation_type.get_subtypes(transaction, transitivity)
+        """
+        pass
+
+    @abstractmethod
+    def set_supertype(self, transaction: TypeDBTransaction, super_relation_type: RelationType) -> Promise[None]:
+        """
+        Sets the supplied ``RelationType`` as the supertype of the current ``RelationType``.
+
+        :param transaction: The current transaction
+        :param super_relation_type: The ``RelationType`` to set as the supertype
+            of this ``RelationType``
+        :return:
+
+        Examples
+        --------
+        ::
+
+            relation_type.set_supertype(transaction, super_relation_type).resolve()
+        """
+        pass
```

## typedb/api/concept/type/role_type.py

 * *Ordering differences only*

```diff
@@ -1,229 +1,229 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from abc import ABC, abstractmethod
-from typing import TYPE_CHECKING, Iterator, Optional
-
-from typedb.api.concept.type.type import Type
-from typedb.common.transitivity import Transitivity
-
-if TYPE_CHECKING:
-    from typedb.api.concept.thing.thing import Thing
-    from typedb.api.concept.thing.relation import Relation
-    from typedb.api.concept.type.relation_type import RelationType
-    from typedb.api.concept.type.thing_type import ThingType
-    from typedb.api.connection.transaction import TypeDBTransaction
-    from typedb.common.promise import Promise
-
-
-class RoleType(Type, ABC):
-    """
-    Roles are special internal types used by relations. We can not create
-    an instance of a role in a database. But we can set an instance
-    of another type (role player) to play a role in a particular instance
-    of a relation type.
-
-    Roles allow a schema to enforce logical constraints on types
-    of role players.
-    """
-
-    def is_role_type(self) -> bool:
-        """
-        Checks if the concept is a ``RoleType``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            role_type.is_role_type()
-        """
-        return True
-
-    def as_role_type(self) -> RoleType:
-        """
-        Casts the concept to ``RoleType``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            role_type.as_role_type()
-        """
-        return self
-
-    @abstractmethod
-    def get_supertype(self, transaction: TypeDBTransaction) -> Promise[Optional[RoleType]]:
-        """
-        Retrieves the most immediate supertype of the ``RoleType``.
-
-        :param transaction: The current transaction
-        :return:
-
-        Examples
-        --------
-        ::
-
-            role_type.get_supertype(transaction).resolve()
-        """
-        pass
-
-    @abstractmethod
-    def get_supertypes(self, transaction: TypeDBTransaction) -> Iterator[RoleType]:
-        """
-        Retrieves all supertypes of the ``RoleType``.
-
-        :param transaction: The current transaction
-        :return:
-
-        Examples
-        --------
-        ::
-
-            role_type.get_supertypes(transaction)
-        """
-        pass
-
-    @abstractmethod
-    def get_subtypes(
-        self,
-        transaction: TypeDBTransaction,
-        transitivity: Transitivity = Transitivity.TRANSITIVE,
-    ) -> Iterator[RoleType]:
-        """
-        Retrieves all direct and indirect (or direct only) subtypes of the ``RoleType``.
-
-        :param transaction: The current transaction
-        :param transitivity: ``Transitivity.TRANSITIVE`` for direct
-            and indirect subtypes, ``Transitivity.EXPLICIT`` for direct
-            subtypes only
-        :return:
-
-        Examples
-        --------
-        ::
-
-            role_type.get_subtypes(transaction, transitivity)
-        """
-        pass
-
-    @abstractmethod
-    def get_relation_type(self, transaction: TypeDBTransaction) -> Promise[RelationType]:
-        """
-        Retrieves the ``RelationType`` that this role is directly related to.
-
-        :param transaction: The current transaction
-        :return:
-
-        Examples
-        --------
-        ::
-
-            role_type.get_relation_type(transaction).resolve()
-        """
-        pass
-
-    @abstractmethod
-    def get_relation_types(self, transaction: TypeDBTransaction) -> Iterator[RelationType]:
-        """
-        Retrieves ``RelationType``\ s that this role is related to
-        (directly or indirectly).
-
-        :param transaction: The current transaction
-        :return:
-
-        Examples
-        --------
-        ::
-
-            role_type.get_relation_types(transaction)
-        """
-        pass
-
-    @abstractmethod
-    def get_player_types(
-        self,
-        transaction: TypeDBTransaction,
-        transitivity: Transitivity = Transitivity.TRANSITIVE,
-    ) -> Iterator[ThingType]:
-        """
-        Retrieves the ``ThingType``\ s whose instances play this role.
-
-        :param transaction: The current transaction
-        :param transitivity: ``Transitivity.TRANSITIVE`` for direct
-            and indirect playing, ``Transitivity.EXPLICIT`` for direct
-            playing only
-        :return:
-
-        Examples
-        --------
-        ::
-
-            role_type.get_player_types(transaction, transitivity)
-        """
-        pass
-
-    @abstractmethod
-    def get_relation_instances(
-        self,
-        transaction: TypeDBTransaction,
-        transitivity: Transitivity = Transitivity.TRANSITIVE,
-    ) -> Iterator[Relation]:
-        """
-        Retrieves the ``Relation`` instances that this role is related to.
-
-        :param transaction: The current transaction
-        :param transitivity: ``Transitivity.TRANSITIVE`` for direct
-            and indirect relation, ``Transitivity.EXPLICIT`` for direct
-            relation only
-        :return:
-
-        Examples
-        --------
-        ::
-
-            role_type.get_relation_instances(transaction, transitivity)
-        """
-        pass
-
-    @abstractmethod
-    def get_player_instances(
-        self,
-        transaction: TypeDBTransaction,
-        transitivity: Transitivity = Transitivity.TRANSITIVE,
-    ) -> Iterator[Thing]:
-        """
-        Retrieves the ``Thing`` instances that play this role.
-
-        :param transaction: The current transaction
-        :param transitivity: ``Transitivity.TRANSITIVE`` for direct
-            and indirect playing, ``Transitivity.EXPLICIT`` for direct
-            playing only
-        :return:
-
-        Examples
-        --------
-        ::
-
-            role_type.get_player_instances(transaction, transitivity)
-        """
-        pass
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from abc import ABC, abstractmethod
+from typing import TYPE_CHECKING, Iterator, Optional
+
+from typedb.api.concept.type.type import Type
+from typedb.common.transitivity import Transitivity
+
+if TYPE_CHECKING:
+    from typedb.api.concept.thing.thing import Thing
+    from typedb.api.concept.thing.relation import Relation
+    from typedb.api.concept.type.relation_type import RelationType
+    from typedb.api.concept.type.thing_type import ThingType
+    from typedb.api.connection.transaction import TypeDBTransaction
+    from typedb.common.promise import Promise
+
+
+class RoleType(Type, ABC):
+    """
+    Roles are special internal types used by relations. We can not create
+    an instance of a role in a database. But we can set an instance
+    of another type (role player) to play a role in a particular instance
+    of a relation type.
+
+    Roles allow a schema to enforce logical constraints on types
+    of role players.
+    """
+
+    def is_role_type(self) -> bool:
+        """
+        Checks if the concept is a ``RoleType``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            role_type.is_role_type()
+        """
+        return True
+
+    def as_role_type(self) -> RoleType:
+        """
+        Casts the concept to ``RoleType``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            role_type.as_role_type()
+        """
+        return self
+
+    @abstractmethod
+    def get_supertype(self, transaction: TypeDBTransaction) -> Promise[Optional[RoleType]]:
+        """
+        Retrieves the most immediate supertype of the ``RoleType``.
+
+        :param transaction: The current transaction
+        :return:
+
+        Examples
+        --------
+        ::
+
+            role_type.get_supertype(transaction).resolve()
+        """
+        pass
+
+    @abstractmethod
+    def get_supertypes(self, transaction: TypeDBTransaction) -> Iterator[RoleType]:
+        """
+        Retrieves all supertypes of the ``RoleType``.
+
+        :param transaction: The current transaction
+        :return:
+
+        Examples
+        --------
+        ::
+
+            role_type.get_supertypes(transaction)
+        """
+        pass
+
+    @abstractmethod
+    def get_subtypes(
+        self,
+        transaction: TypeDBTransaction,
+        transitivity: Transitivity = Transitivity.TRANSITIVE,
+    ) -> Iterator[RoleType]:
+        """
+        Retrieves all direct and indirect (or direct only) subtypes of the ``RoleType``.
+
+        :param transaction: The current transaction
+        :param transitivity: ``Transitivity.TRANSITIVE`` for direct
+            and indirect subtypes, ``Transitivity.EXPLICIT`` for direct
+            subtypes only
+        :return:
+
+        Examples
+        --------
+        ::
+
+            role_type.get_subtypes(transaction, transitivity)
+        """
+        pass
+
+    @abstractmethod
+    def get_relation_type(self, transaction: TypeDBTransaction) -> Promise[RelationType]:
+        """
+        Retrieves the ``RelationType`` that this role is directly related to.
+
+        :param transaction: The current transaction
+        :return:
+
+        Examples
+        --------
+        ::
+
+            role_type.get_relation_type(transaction).resolve()
+        """
+        pass
+
+    @abstractmethod
+    def get_relation_types(self, transaction: TypeDBTransaction) -> Iterator[RelationType]:
+        """
+        Retrieves ``RelationType``\ s that this role is related to
+        (directly or indirectly).
+
+        :param transaction: The current transaction
+        :return:
+
+        Examples
+        --------
+        ::
+
+            role_type.get_relation_types(transaction)
+        """
+        pass
+
+    @abstractmethod
+    def get_player_types(
+        self,
+        transaction: TypeDBTransaction,
+        transitivity: Transitivity = Transitivity.TRANSITIVE,
+    ) -> Iterator[ThingType]:
+        """
+        Retrieves the ``ThingType``\ s whose instances play this role.
+
+        :param transaction: The current transaction
+        :param transitivity: ``Transitivity.TRANSITIVE`` for direct
+            and indirect playing, ``Transitivity.EXPLICIT`` for direct
+            playing only
+        :return:
+
+        Examples
+        --------
+        ::
+
+            role_type.get_player_types(transaction, transitivity)
+        """
+        pass
+
+    @abstractmethod
+    def get_relation_instances(
+        self,
+        transaction: TypeDBTransaction,
+        transitivity: Transitivity = Transitivity.TRANSITIVE,
+    ) -> Iterator[Relation]:
+        """
+        Retrieves the ``Relation`` instances that this role is related to.
+
+        :param transaction: The current transaction
+        :param transitivity: ``Transitivity.TRANSITIVE`` for direct
+            and indirect relation, ``Transitivity.EXPLICIT`` for direct
+            relation only
+        :return:
+
+        Examples
+        --------
+        ::
+
+            role_type.get_relation_instances(transaction, transitivity)
+        """
+        pass
+
+    @abstractmethod
+    def get_player_instances(
+        self,
+        transaction: TypeDBTransaction,
+        transitivity: Transitivity = Transitivity.TRANSITIVE,
+    ) -> Iterator[Thing]:
+        """
+        Retrieves the ``Thing`` instances that play this role.
+
+        :param transaction: The current transaction
+        :param transitivity: ``Transitivity.TRANSITIVE`` for direct
+            and indirect playing, ``Transitivity.EXPLICIT`` for direct
+            playing only
+        :return:
+
+        Examples
+        --------
+        ::
+
+            role_type.get_player_instances(transaction, transitivity)
+        """
+        pass
```

## typedb/api/concept/type/thing_type.py

 * *Ordering differences only*

```diff
@@ -1,367 +1,367 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from abc import ABC, abstractmethod
-from typing import TYPE_CHECKING, Iterator, Optional
-
-from typedb.api.concept.type.type import Type
-from typedb.common.transitivity import Transitivity
-
-if TYPE_CHECKING:
-    from typedb.api.concept.type.annotation import Annotation
-    from typedb.api.concept.thing.thing import Thing
-    from typedb.api.concept.type.role_type import RoleType
-    from typedb.api.concept.value.value import ValueType
-    from typedb.api.concept.type.attribute_type import AttributeType
-    from typedb.api.connection.transaction import TypeDBTransaction
-    from typedb.common.promise import Promise
-
-
-class ThingType(Type, ABC):
-    def is_thing_type(self) -> bool:
-        """
-        Checks if the concept is a ``ThingType``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-             thing_type.is_thing_type()
-        """
-        return True
-
-    @abstractmethod
-    def get_supertype(self, transaction: TypeDBTransaction) -> Promise[Optional[ThingType]]:
-        """
-        Retrieves the most immediate supertype of the ``ThingType``.
-
-        :param transaction: The current transaction
-        :return:
-
-        Examples
-        --------
-        ::
-
-            thing_type.get_supertype(transaction).resolve()
-        """
-        pass
-
-    @abstractmethod
-    def get_supertypes(self, transaction: TypeDBTransaction) -> Iterator[ThingType]:
-        """
-        Retrieves all supertypes of the ``ThingType``.
-
-        :param transaction: The current transaction
-        :return:
-
-        Examples
-        --------
-        ::
-
-            thing_type.get_supertypes(transaction)
-        """
-        pass
-
-    @abstractmethod
-    def get_subtypes(
-        self,
-        transaction: TypeDBTransaction,
-        transitivity: Transitivity = Transitivity.TRANSITIVE,
-    ) -> Iterator[ThingType]:
-        """
-        Retrieves all direct and indirect (or direct only) subtypes of the ``ThingType``.
-
-        :param transaction: The current transaction
-        :param transitivity: ``Transitivity.TRANSITIVE`` for direct
-            and indirect subtypes, ``Transitivity.EXPLICIT`` for direct
-            subtypes only
-        :return:
-
-        Examples
-        --------
-        ::
-
-            thing_type.get_subtypes(transaction)
-            thing_type.get_subtypes(transaction, Transitivity.EXPLICIT)
-        """
-        pass
-
-    @abstractmethod
-    def get_instances(
-        self,
-        transaction: TypeDBTransaction,
-        transitivity: Transitivity = Transitivity.TRANSITIVE,
-    ) -> Iterator[Thing]:
-        """
-        Retrieves all direct and indirect (or direct only) ``Thing`` objects
-        that are instances of this ``ThingType``.
-
-        :param transaction: The current transaction
-        :param transitivity: ``Transitivity.TRANSITIVE`` for direct
-            and indirect instances, ``Transitivity.EXPLICIT`` for direct
-            instances only
-        :return:
-
-        Examples
-        --------
-        ::
-
-            thing_type.get_instances(transaction)
-            thing_type.get_instances(transaction, Transitivity.EXPLICIT)
-        """
-        pass
-
-    @abstractmethod
-    def set_abstract(self, transaction: TypeDBTransaction) -> Promise[None]:
-        """
-        Set a ``ThingType`` to be abstract, meaning it cannot have instances.
-
-        :param transaction: The current transaction
-        :return:
-
-        Examples
-        --------
-        ::
-
-            thing_type.set_abstract(transaction).resolve()
-        """
-        pass
-
-    @abstractmethod
-    def unset_abstract(self, transaction: TypeDBTransaction) -> Promise[None]:
-        """
-        Set a ``ThingType`` to be non-abstract, meaning it can have instances.
-
-        :param transaction: The current transaction
-        :return:
-
-        Examples
-        --------
-        ::
-
-            thing_type.unset_abstract(transaction).resolve()
-        """
-        pass
-
-    @abstractmethod
-    def set_plays(
-        self,
-        transaction: TypeDBTransaction,
-        role_type: RoleType,
-        overriden_type: Optional[RoleType] = None,
-    ) -> Promise[None]:
-        """
-        Allows the instances of this ``ThingType`` to play the given role.
-
-        :param transaction: The current transaction
-        :param role_type: The role to be played by the instances of this type
-        :param overriden_type: The role type that this role overrides,
-            if applicable
-        :return:
-
-        Examples
-        --------
-        ::
-
-            thing_type.set_plays(transaction, role_type).resolve()
-            thing_type.set_plays(transaction, role_type, overridden_type).resolve()
-        """
-        pass
-
-    @abstractmethod
-    def unset_plays(self, transaction: TypeDBTransaction, role_type: RoleType) -> Promise[None]:
-        """
-        Disallows the instances of this ``ThingType`` from playing the given role.
-
-        :param transaction: The current transaction
-        :param role_type: The role to not be played by the instances of this type.
-        :return:
-
-        Examples
-        --------
-        ::
-
-            thing_type.unset_plays(transaction, role_type).resolve()
-        """
-        pass
-
-    @abstractmethod
-    def set_owns(
-        self,
-        transaction: TypeDBTransaction,
-        attribute_type: AttributeType,
-        overridden_type: Optional[AttributeType] = None,
-        annotations: Optional[set[Annotation]] = None,
-    ) -> Promise[None]:
-        """
-        Allows the instances of this ``ThingType`` to own
-        the given ``AttributeType``.
-
-        :param transaction: The current transaction
-        :param attribute_type: The ``AttributeType`` to be owned
-            by the instances of this type.
-        :param overridden_type: The ``AttributeType`` that this attribute
-            ownership overrides, if applicable.
-        :param annotations: Adds annotations to the ownership.
-        :return:
-
-        Examples
-        --------
-        ::
-
-            thing_type.set_owns(transaction, attribute_type).resolve()
-            thing_type.set_owns(transaction, attribute_type,
-                                overridden_type=overridden_type,
-                                annotations={Annotation.key()}).resolve()
-        """
-        pass
-
-    @abstractmethod
-    def unset_owns(self, transaction: TypeDBTransaction, attribute_type: AttributeType) -> Promise[None]:
-        """
-        Disallows the instances of this ``ThingType`` from owning
-        the given ``AttributeType``.
-
-        :param transaction: The current transaction
-        :param attribute_type: The ``AttributeType`` to not be owned by the type.
-        :return:
-
-        Examples
-        --------
-        ::
-
-            thing_type.unset_owns(transaction, attribute_type).resolve()
-        """
-        pass
-
-    @abstractmethod
-    def get_plays(
-        self,
-        transaction: TypeDBTransaction,
-        transitivity: Transitivity = Transitivity.TRANSITIVE,
-    ) -> Iterator[RoleType]:
-        """
-        Retrieves all direct and inherited (or direct only) roles that
-        are allowed to be played by the instances of this ``ThingType``.
-
-        :param transaction: The current transaction
-        :param transitivity: ``Transitivity.TRANSITIVE`` for direct
-            and indirect playing, ``Transitivity.EXPLICIT`` for direct
-            playing only
-        :return:
-
-        Examples
-        --------
-        ::
-
-            thing_type.get_plays(transaction)
-            thing_type.get_plays(transaction, Transitivity.EXPLICIT)
-        """
-        pass
-
-    @abstractmethod
-    def get_plays_overridden(self, transaction: TypeDBTransaction, role_type: RoleType) -> Promise[Optional[RoleType]]:
-        """
-        Retrieves a ``RoleType`` that is overridden by the given ``role_type``
-        for this ``ThingType``.
-
-        :param transaction: The current transaction
-        :param role_type: The ``RoleType`` that overrides an inherited role
-        :return:
-
-        Examples
-        --------
-        ::
-
-            thing_type.get_plays_overridden(transaction, role_type).resolve()
-        """
-        pass
-
-    @abstractmethod
-    def get_owns(
-        self,
-        transaction: TypeDBTransaction,
-        value_type: Optional[ValueType] = None,
-        transitivity: Transitivity = Transitivity.TRANSITIVE,
-        annotations: Optional[set[Annotation]] = None,
-    ) -> Iterator[AttributeType]:
-        """
-        Retrieves ``AttributeType`` that the instances of this ``ThingType``
-        are allowed to own directly or via inheritance.
-
-        :param transaction: The current transaction
-        :param value_type: If specified, only attribute types of this
-            ``ValueType`` will be retrieved.
-        :param transitivity: ``Transitivity.TRANSITIVE`` for direct
-            and inherited ownership, ``Transitivity.EXPLICIT`` for direct
-            ownership only
-        :param annotations: Only retrieve attribute types owned with annotations.
-        :return:
-
-        Examples
-        --------
-        ::
-
-            thing_type.get_owns(transaction)
-            thing_type.get_owns(transaction, value_type,
-                                transitivity=Transitivity.EXPLICIT,
-                                annotations={Annotation.key()})
-        """
-        pass
-
-    @abstractmethod
-    def get_owns_overridden(
-        self,
-        transaction: TypeDBTransaction,
-        attribute_type: AttributeType,
-    ) -> Promise[Optional[AttributeType]]:
-        """
-        Retrieves an ``AttributeType``, ownership of which is overridden
-        for this ``ThingType`` by a given ``attribute_type``.
-
-        :param transaction: The current transaction
-        :param attribute_type: The ``AttributeType`` that overrides requested
-            ``AttributeType``
-        :return:
-
-        Examples
-        --------
-        ::
-
-            thing_type.get_owns_overridden(transaction, attribute_type).resolve()
-        """
-        pass
-
-    @abstractmethod
-    def get_syntax(self, transaction: TypeDBTransaction) -> Promise[str]:
-        """
-        Produces a pattern for creating this ``ThingType`` in a ``define`` query.
-
-        :param transaction: The current transaction
-        :return:
-
-        Examples
-        --------
-        ::
-
-            thing_type.get_syntax(transaction).resolve()
-        """
-        pass
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from abc import ABC, abstractmethod
+from typing import TYPE_CHECKING, Iterator, Optional
+
+from typedb.api.concept.type.type import Type
+from typedb.common.transitivity import Transitivity
+
+if TYPE_CHECKING:
+    from typedb.api.concept.type.annotation import Annotation
+    from typedb.api.concept.thing.thing import Thing
+    from typedb.api.concept.type.role_type import RoleType
+    from typedb.api.concept.value.value import ValueType
+    from typedb.api.concept.type.attribute_type import AttributeType
+    from typedb.api.connection.transaction import TypeDBTransaction
+    from typedb.common.promise import Promise
+
+
+class ThingType(Type, ABC):
+    def is_thing_type(self) -> bool:
+        """
+        Checks if the concept is a ``ThingType``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+             thing_type.is_thing_type()
+        """
+        return True
+
+    @abstractmethod
+    def get_supertype(self, transaction: TypeDBTransaction) -> Promise[Optional[ThingType]]:
+        """
+        Retrieves the most immediate supertype of the ``ThingType``.
+
+        :param transaction: The current transaction
+        :return:
+
+        Examples
+        --------
+        ::
+
+            thing_type.get_supertype(transaction).resolve()
+        """
+        pass
+
+    @abstractmethod
+    def get_supertypes(self, transaction: TypeDBTransaction) -> Iterator[ThingType]:
+        """
+        Retrieves all supertypes of the ``ThingType``.
+
+        :param transaction: The current transaction
+        :return:
+
+        Examples
+        --------
+        ::
+
+            thing_type.get_supertypes(transaction)
+        """
+        pass
+
+    @abstractmethod
+    def get_subtypes(
+        self,
+        transaction: TypeDBTransaction,
+        transitivity: Transitivity = Transitivity.TRANSITIVE,
+    ) -> Iterator[ThingType]:
+        """
+        Retrieves all direct and indirect (or direct only) subtypes of the ``ThingType``.
+
+        :param transaction: The current transaction
+        :param transitivity: ``Transitivity.TRANSITIVE`` for direct
+            and indirect subtypes, ``Transitivity.EXPLICIT`` for direct
+            subtypes only
+        :return:
+
+        Examples
+        --------
+        ::
+
+            thing_type.get_subtypes(transaction)
+            thing_type.get_subtypes(transaction, Transitivity.EXPLICIT)
+        """
+        pass
+
+    @abstractmethod
+    def get_instances(
+        self,
+        transaction: TypeDBTransaction,
+        transitivity: Transitivity = Transitivity.TRANSITIVE,
+    ) -> Iterator[Thing]:
+        """
+        Retrieves all direct and indirect (or direct only) ``Thing`` objects
+        that are instances of this ``ThingType``.
+
+        :param transaction: The current transaction
+        :param transitivity: ``Transitivity.TRANSITIVE`` for direct
+            and indirect instances, ``Transitivity.EXPLICIT`` for direct
+            instances only
+        :return:
+
+        Examples
+        --------
+        ::
+
+            thing_type.get_instances(transaction)
+            thing_type.get_instances(transaction, Transitivity.EXPLICIT)
+        """
+        pass
+
+    @abstractmethod
+    def set_abstract(self, transaction: TypeDBTransaction) -> Promise[None]:
+        """
+        Set a ``ThingType`` to be abstract, meaning it cannot have instances.
+
+        :param transaction: The current transaction
+        :return:
+
+        Examples
+        --------
+        ::
+
+            thing_type.set_abstract(transaction).resolve()
+        """
+        pass
+
+    @abstractmethod
+    def unset_abstract(self, transaction: TypeDBTransaction) -> Promise[None]:
+        """
+        Set a ``ThingType`` to be non-abstract, meaning it can have instances.
+
+        :param transaction: The current transaction
+        :return:
+
+        Examples
+        --------
+        ::
+
+            thing_type.unset_abstract(transaction).resolve()
+        """
+        pass
+
+    @abstractmethod
+    def set_plays(
+        self,
+        transaction: TypeDBTransaction,
+        role_type: RoleType,
+        overriden_type: Optional[RoleType] = None,
+    ) -> Promise[None]:
+        """
+        Allows the instances of this ``ThingType`` to play the given role.
+
+        :param transaction: The current transaction
+        :param role_type: The role to be played by the instances of this type
+        :param overriden_type: The role type that this role overrides,
+            if applicable
+        :return:
+
+        Examples
+        --------
+        ::
+
+            thing_type.set_plays(transaction, role_type).resolve()
+            thing_type.set_plays(transaction, role_type, overridden_type).resolve()
+        """
+        pass
+
+    @abstractmethod
+    def unset_plays(self, transaction: TypeDBTransaction, role_type: RoleType) -> Promise[None]:
+        """
+        Disallows the instances of this ``ThingType`` from playing the given role.
+
+        :param transaction: The current transaction
+        :param role_type: The role to not be played by the instances of this type.
+        :return:
+
+        Examples
+        --------
+        ::
+
+            thing_type.unset_plays(transaction, role_type).resolve()
+        """
+        pass
+
+    @abstractmethod
+    def set_owns(
+        self,
+        transaction: TypeDBTransaction,
+        attribute_type: AttributeType,
+        overridden_type: Optional[AttributeType] = None,
+        annotations: Optional[set[Annotation]] = None,
+    ) -> Promise[None]:
+        """
+        Allows the instances of this ``ThingType`` to own
+        the given ``AttributeType``.
+
+        :param transaction: The current transaction
+        :param attribute_type: The ``AttributeType`` to be owned
+            by the instances of this type.
+        :param overridden_type: The ``AttributeType`` that this attribute
+            ownership overrides, if applicable.
+        :param annotations: Adds annotations to the ownership.
+        :return:
+
+        Examples
+        --------
+        ::
+
+            thing_type.set_owns(transaction, attribute_type).resolve()
+            thing_type.set_owns(transaction, attribute_type,
+                                overridden_type=overridden_type,
+                                annotations={Annotation.key()}).resolve()
+        """
+        pass
+
+    @abstractmethod
+    def unset_owns(self, transaction: TypeDBTransaction, attribute_type: AttributeType) -> Promise[None]:
+        """
+        Disallows the instances of this ``ThingType`` from owning
+        the given ``AttributeType``.
+
+        :param transaction: The current transaction
+        :param attribute_type: The ``AttributeType`` to not be owned by the type.
+        :return:
+
+        Examples
+        --------
+        ::
+
+            thing_type.unset_owns(transaction, attribute_type).resolve()
+        """
+        pass
+
+    @abstractmethod
+    def get_plays(
+        self,
+        transaction: TypeDBTransaction,
+        transitivity: Transitivity = Transitivity.TRANSITIVE,
+    ) -> Iterator[RoleType]:
+        """
+        Retrieves all direct and inherited (or direct only) roles that
+        are allowed to be played by the instances of this ``ThingType``.
+
+        :param transaction: The current transaction
+        :param transitivity: ``Transitivity.TRANSITIVE`` for direct
+            and indirect playing, ``Transitivity.EXPLICIT`` for direct
+            playing only
+        :return:
+
+        Examples
+        --------
+        ::
+
+            thing_type.get_plays(transaction)
+            thing_type.get_plays(transaction, Transitivity.EXPLICIT)
+        """
+        pass
+
+    @abstractmethod
+    def get_plays_overridden(self, transaction: TypeDBTransaction, role_type: RoleType) -> Promise[Optional[RoleType]]:
+        """
+        Retrieves a ``RoleType`` that is overridden by the given ``role_type``
+        for this ``ThingType``.
+
+        :param transaction: The current transaction
+        :param role_type: The ``RoleType`` that overrides an inherited role
+        :return:
+
+        Examples
+        --------
+        ::
+
+            thing_type.get_plays_overridden(transaction, role_type).resolve()
+        """
+        pass
+
+    @abstractmethod
+    def get_owns(
+        self,
+        transaction: TypeDBTransaction,
+        value_type: Optional[ValueType] = None,
+        transitivity: Transitivity = Transitivity.TRANSITIVE,
+        annotations: Optional[set[Annotation]] = None,
+    ) -> Iterator[AttributeType]:
+        """
+        Retrieves ``AttributeType`` that the instances of this ``ThingType``
+        are allowed to own directly or via inheritance.
+
+        :param transaction: The current transaction
+        :param value_type: If specified, only attribute types of this
+            ``ValueType`` will be retrieved.
+        :param transitivity: ``Transitivity.TRANSITIVE`` for direct
+            and inherited ownership, ``Transitivity.EXPLICIT`` for direct
+            ownership only
+        :param annotations: Only retrieve attribute types owned with annotations.
+        :return:
+
+        Examples
+        --------
+        ::
+
+            thing_type.get_owns(transaction)
+            thing_type.get_owns(transaction, value_type,
+                                transitivity=Transitivity.EXPLICIT,
+                                annotations={Annotation.key()})
+        """
+        pass
+
+    @abstractmethod
+    def get_owns_overridden(
+        self,
+        transaction: TypeDBTransaction,
+        attribute_type: AttributeType,
+    ) -> Promise[Optional[AttributeType]]:
+        """
+        Retrieves an ``AttributeType``, ownership of which is overridden
+        for this ``ThingType`` by a given ``attribute_type``.
+
+        :param transaction: The current transaction
+        :param attribute_type: The ``AttributeType`` that overrides requested
+            ``AttributeType``
+        :return:
+
+        Examples
+        --------
+        ::
+
+            thing_type.get_owns_overridden(transaction, attribute_type).resolve()
+        """
+        pass
+
+    @abstractmethod
+    def get_syntax(self, transaction: TypeDBTransaction) -> Promise[str]:
+        """
+        Produces a pattern for creating this ``ThingType`` in a ``define`` query.
+
+        :param transaction: The current transaction
+        :return:
+
+        Examples
+        --------
+        ::
+
+            thing_type.get_syntax(transaction).resolve()
+        """
+        pass
```

## typedb/api/concept/type/type.py

 * *Ordering differences only*

```diff
@@ -1,179 +1,179 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from abc import ABC, abstractmethod
-from typing import Iterator, Mapping, Optional, TYPE_CHECKING
-
-from typedb.api.concept.concept import Concept
-from typedb.common.transitivity import Transitivity
-
-if TYPE_CHECKING:
-    from typedb.api.connection.transaction import TypeDBTransaction
-    from typedb.common.label import Label
-    from typedb.common.promise import Promise
-
-
-class Type(Concept, ABC):
-    @abstractmethod
-    def get_label(self) -> Label:
-        """
-        Retrieves the unique label of the type.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            type_.get_label()
-        """
-        pass
-
-    @abstractmethod
-    def set_label(self, transaction: TypeDBTransaction, new_label: str) -> Promise[None]:
-        """
-        Renames the label of the type. The new label must remain unique.
-
-        :param transaction: The current transaction
-        :param new_label: The new name to be given to the type.
-        :return:
-
-        Examples
-        --------
-        ::
-
-            type_.set_label(transaction, new_label).resolve()
-        """
-        pass
-
-    @abstractmethod
-    def is_root(self) -> bool:
-        """
-        Checks if the type is a root type.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            type_.is_root()
-        """
-        pass
-
-    @abstractmethod
-    def is_abstract(self) -> bool:
-        """
-        Checks if the type is prevented from having data instances (i.e., ``abstract``).
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            type_.is_abstract()
-        """
-        pass
-
-    def is_type(self) -> bool:
-        """
-        Checks if the concept is a ``Type``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            type_.is_type()
-        """
-        return True
-
-    @abstractmethod
-    def get_supertype(self, transaction: TypeDBTransaction) -> Promise[Optional[Type]]:
-        """
-        Retrieves the most immediate supertype of the type.
-
-        :param transaction: The current transaction
-        :return:
-
-        Examples
-        --------
-        ::
-
-            type_.get_supertype(transaction).resolve()
-        """
-        pass
-
-    @abstractmethod
-    def get_supertypes(self, transaction: TypeDBTransaction) -> Iterator[Type]:
-        """
-        Retrieves all supertypes of the type.
-
-        :param transaction: The current transaction
-        :return:
-
-        Examples
-        --------
-        ::
-
-            type_.get_supertypes(transaction)
-        """
-        pass
-
-    @abstractmethod
-    def get_subtypes(
-        self,
-        transaction: TypeDBTransaction,
-        transitivity: Transitivity = Transitivity.TRANSITIVE,
-    ) -> Iterator[Type]:
-        """
-        Retrieves all direct and indirect (or direct only) subtypes of the type.
-
-        :param transaction: The current transaction
-        :param transitivity: ``Transitivity.TRANSITIVE`` for direct
-            and indirect subtypes, ``Transitivity.EXPLICIT`` for direct
-            subtypes only
-        :return:
-
-        Examples
-        --------
-        ::
-
-            type_.get_subtypes(transaction)
-            type_.get_subtypes(transaction, Transitivity.EXPLICIT)
-        """
-        pass
-
-    @abstractmethod
-    def delete(self, transaction: TypeDBTransaction) -> Promise[None]:
-        """
-        Deletes this type from the database.
-
-        :param transaction: The current transaction
-        :return:
-
-        Examples
-        --------
-        ::
-
-            type_.delete(transaction).resolve()
-        """
-        pass
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from abc import ABC, abstractmethod
+from typing import Iterator, Mapping, Optional, TYPE_CHECKING
+
+from typedb.api.concept.concept import Concept
+from typedb.common.transitivity import Transitivity
+
+if TYPE_CHECKING:
+    from typedb.api.connection.transaction import TypeDBTransaction
+    from typedb.common.label import Label
+    from typedb.common.promise import Promise
+
+
+class Type(Concept, ABC):
+    @abstractmethod
+    def get_label(self) -> Label:
+        """
+        Retrieves the unique label of the type.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            type_.get_label()
+        """
+        pass
+
+    @abstractmethod
+    def set_label(self, transaction: TypeDBTransaction, new_label: str) -> Promise[None]:
+        """
+        Renames the label of the type. The new label must remain unique.
+
+        :param transaction: The current transaction
+        :param new_label: The new name to be given to the type.
+        :return:
+
+        Examples
+        --------
+        ::
+
+            type_.set_label(transaction, new_label).resolve()
+        """
+        pass
+
+    @abstractmethod
+    def is_root(self) -> bool:
+        """
+        Checks if the type is a root type.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            type_.is_root()
+        """
+        pass
+
+    @abstractmethod
+    def is_abstract(self) -> bool:
+        """
+        Checks if the type is prevented from having data instances (i.e., ``abstract``).
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            type_.is_abstract()
+        """
+        pass
+
+    def is_type(self) -> bool:
+        """
+        Checks if the concept is a ``Type``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            type_.is_type()
+        """
+        return True
+
+    @abstractmethod
+    def get_supertype(self, transaction: TypeDBTransaction) -> Promise[Optional[Type]]:
+        """
+        Retrieves the most immediate supertype of the type.
+
+        :param transaction: The current transaction
+        :return:
+
+        Examples
+        --------
+        ::
+
+            type_.get_supertype(transaction).resolve()
+        """
+        pass
+
+    @abstractmethod
+    def get_supertypes(self, transaction: TypeDBTransaction) -> Iterator[Type]:
+        """
+        Retrieves all supertypes of the type.
+
+        :param transaction: The current transaction
+        :return:
+
+        Examples
+        --------
+        ::
+
+            type_.get_supertypes(transaction)
+        """
+        pass
+
+    @abstractmethod
+    def get_subtypes(
+        self,
+        transaction: TypeDBTransaction,
+        transitivity: Transitivity = Transitivity.TRANSITIVE,
+    ) -> Iterator[Type]:
+        """
+        Retrieves all direct and indirect (or direct only) subtypes of the type.
+
+        :param transaction: The current transaction
+        :param transitivity: ``Transitivity.TRANSITIVE`` for direct
+            and indirect subtypes, ``Transitivity.EXPLICIT`` for direct
+            subtypes only
+        :return:
+
+        Examples
+        --------
+        ::
+
+            type_.get_subtypes(transaction)
+            type_.get_subtypes(transaction, Transitivity.EXPLICIT)
+        """
+        pass
+
+    @abstractmethod
+    def delete(self, transaction: TypeDBTransaction) -> Promise[None]:
+        """
+        Deletes this type from the database.
+
+        :param transaction: The current transaction
+        :return:
+
+        Examples
+        --------
+        ::
+
+            type_.delete(transaction).resolve()
+        """
+        pass
```

## typedb/api/concept/value/value.py

 * *Ordering differences only*

```diff
@@ -1,300 +1,300 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from abc import ABC, abstractmethod
-from datetime import datetime
-from enum import Enum
-from typing import Mapping, Union
-
-from typedb.native_driver_wrapper import Object, Boolean, Long, Double, String, DateTime
-
-from typedb.api.concept.concept import Concept
-from typedb.common.exception import TypeDBDriverException, UNEXPECTED_NATIVE_VALUE
-
-
-class Value(Concept, ABC):
-
-    @abstractmethod
-    def get_value_type(self) -> ValueType:
-        """
-        Retrieves the ``ValueType`` of this value concept.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            value.get_value_type()
-        """
-        pass
-
-    @abstractmethod
-    def get(self) -> Union[bool, int, float, str, datetime]:
-        """
-        Retrieves the value which this value concept holds.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            value.get()
-        """
-        pass
-
-    def is_value(self) -> bool:
-        """
-        Checks if the concept is a ``Value``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            value.is_value()
-        """
-        return True
-
-    def as_value(self) -> Value:
-        """
-        Casts the concept to ``Value``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            value.as_value()
-        """
-        return self
-
-    @abstractmethod
-    def is_boolean(self) -> bool:
-        """
-        Returns ``True`` if the value which this value concept holds is of type ``boolean``.
-        Otherwise, returns ``False``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            value.is_boolean()
-        """
-        pass
-
-    @abstractmethod
-    def is_long(self) -> bool:
-        """
-        Returns ``True`` if the value which this value concept holds is of type ``long``.
-        Otherwise, returns ``False``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            value.is_long()
-        """
-        pass
-
-    @abstractmethod
-    def is_double(self) -> bool:
-        """
-        Returns ``True`` if the value which this value concept holds is of type ``double``.
-        Otherwise, returns ``False``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            value.is_double()
-        """
-        pass
-
-    @abstractmethod
-    def is_string(self) -> bool:
-        """
-        Returns ``True`` if the value which this value concept holds is of type ``string``.
-        Otherwise, returns ``False``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            value.is_string()
-        """
-        pass
-
-    @abstractmethod
-    def is_datetime(self) -> bool:
-        """
-        Returns ``True`` if the value which this value concept holds is of type ``datetime``.
-        Otherwise, returns ``False``.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            value.is_datetime()
-        """
-        pass
-
-    @abstractmethod
-    def as_boolean(self) -> bool:
-        """
-        Returns a ``boolean`` value of this value concept. If the value has
-        another type, raises an exception.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            value.as_boolean()
-        """
-        pass
-
-    @abstractmethod
-    def as_long(self) -> int:
-        """
-        Returns a ``long`` value of this value concept. If the value has
-        another type, raises an exception.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            value.as_long()
-        """
-        pass
-
-    @abstractmethod
-    def as_double(self) -> float:
-        """
-        Returns a ``double`` value of this value concept. If the value has
-        another type, raises an exception.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            value.as_double()
-        """
-        pass
-
-    @abstractmethod
-    def as_string(self) -> str:
-        """
-        Returns a ``string`` value of this value concept. If the value has
-        another type, raises an exception.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            value.as_string()
-        """
-        pass
-
-    @abstractmethod
-    def as_datetime(self) -> datetime:
-        """
-        Returns a timezone naive ``datetime`` value of this value concept. If the value has
-        another type, raises an exception.
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            value.as_datetime()
-        """
-        pass
-
-
-class _ValueType:
-
-    def __init__(self, is_writable: bool, is_keyable: bool, native_object):
-        self._is_writable = is_writable
-        self._is_keyable = is_keyable
-        self._native_object = native_object
-
-    @property
-    def native_object(self):
-        return self._native_object
-
-    def is_writable(self) -> bool:
-        return self._is_writable
-
-    def is_keyable(self) -> bool:
-        return self._is_keyable
-
-    def __repr__(self):
-        return f"_ValueType(is_writable={self._is_writable}, is_keyable={self._is_keyable}, {self._native_object})"
-
-
-class ValueType(Enum):
-    """ TypeQL value types for attributes and value concepts. """
-    OBJECT = _ValueType(False, False, Object)
-    BOOLEAN = _ValueType(True, False, Boolean)
-    LONG = _ValueType(True, True, Long)
-    DOUBLE = _ValueType(True, False, Double)
-    STRING = _ValueType(True, True, String)
-    DATETIME = _ValueType(True, True, DateTime)
-
-    @property
-    def native_object(self):
-        return self.value.native_object
-
-    def __str__(self):
-        return self.name.lower()
-
-    def __repr__(self):
-        return str(self)
-
-    @staticmethod
-    def of(value_type: Union[Object, Boolean, Long, Double, String, DateTime]) -> ValueType:
-        """
-        :meta private:
-        """
-        for type_ in ValueType:
-            if type_.native_object == value_type:
-                return type_
-        raise TypeDBDriverException(UNEXPECTED_NATIVE_VALUE)
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from abc import ABC, abstractmethod
+from datetime import datetime
+from enum import Enum
+from typing import Mapping, Union
+
+from typedb.native_driver_wrapper import Object, Boolean, Long, Double, String, DateTime
+
+from typedb.api.concept.concept import Concept
+from typedb.common.exception import TypeDBDriverException, UNEXPECTED_NATIVE_VALUE
+
+
+class Value(Concept, ABC):
+
+    @abstractmethod
+    def get_value_type(self) -> ValueType:
+        """
+        Retrieves the ``ValueType`` of this value concept.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            value.get_value_type()
+        """
+        pass
+
+    @abstractmethod
+    def get(self) -> Union[bool, int, float, str, datetime]:
+        """
+        Retrieves the value which this value concept holds.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            value.get()
+        """
+        pass
+
+    def is_value(self) -> bool:
+        """
+        Checks if the concept is a ``Value``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            value.is_value()
+        """
+        return True
+
+    def as_value(self) -> Value:
+        """
+        Casts the concept to ``Value``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            value.as_value()
+        """
+        return self
+
+    @abstractmethod
+    def is_boolean(self) -> bool:
+        """
+        Returns ``True`` if the value which this value concept holds is of type ``boolean``.
+        Otherwise, returns ``False``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            value.is_boolean()
+        """
+        pass
+
+    @abstractmethod
+    def is_long(self) -> bool:
+        """
+        Returns ``True`` if the value which this value concept holds is of type ``long``.
+        Otherwise, returns ``False``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            value.is_long()
+        """
+        pass
+
+    @abstractmethod
+    def is_double(self) -> bool:
+        """
+        Returns ``True`` if the value which this value concept holds is of type ``double``.
+        Otherwise, returns ``False``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            value.is_double()
+        """
+        pass
+
+    @abstractmethod
+    def is_string(self) -> bool:
+        """
+        Returns ``True`` if the value which this value concept holds is of type ``string``.
+        Otherwise, returns ``False``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            value.is_string()
+        """
+        pass
+
+    @abstractmethod
+    def is_datetime(self) -> bool:
+        """
+        Returns ``True`` if the value which this value concept holds is of type ``datetime``.
+        Otherwise, returns ``False``.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            value.is_datetime()
+        """
+        pass
+
+    @abstractmethod
+    def as_boolean(self) -> bool:
+        """
+        Returns a ``boolean`` value of this value concept. If the value has
+        another type, raises an exception.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            value.as_boolean()
+        """
+        pass
+
+    @abstractmethod
+    def as_long(self) -> int:
+        """
+        Returns a ``long`` value of this value concept. If the value has
+        another type, raises an exception.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            value.as_long()
+        """
+        pass
+
+    @abstractmethod
+    def as_double(self) -> float:
+        """
+        Returns a ``double`` value of this value concept. If the value has
+        another type, raises an exception.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            value.as_double()
+        """
+        pass
+
+    @abstractmethod
+    def as_string(self) -> str:
+        """
+        Returns a ``string`` value of this value concept. If the value has
+        another type, raises an exception.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            value.as_string()
+        """
+        pass
+
+    @abstractmethod
+    def as_datetime(self) -> datetime:
+        """
+        Returns a timezone naive ``datetime`` value of this value concept. If the value has
+        another type, raises an exception.
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            value.as_datetime()
+        """
+        pass
+
+
+class _ValueType:
+
+    def __init__(self, is_writable: bool, is_keyable: bool, native_object):
+        self._is_writable = is_writable
+        self._is_keyable = is_keyable
+        self._native_object = native_object
+
+    @property
+    def native_object(self):
+        return self._native_object
+
+    def is_writable(self) -> bool:
+        return self._is_writable
+
+    def is_keyable(self) -> bool:
+        return self._is_keyable
+
+    def __repr__(self):
+        return f"_ValueType(is_writable={self._is_writable}, is_keyable={self._is_keyable}, {self._native_object})"
+
+
+class ValueType(Enum):
+    """ TypeQL value types for attributes and value concepts. """
+    OBJECT = _ValueType(False, False, Object)
+    BOOLEAN = _ValueType(True, False, Boolean)
+    LONG = _ValueType(True, True, Long)
+    DOUBLE = _ValueType(True, False, Double)
+    STRING = _ValueType(True, True, String)
+    DATETIME = _ValueType(True, True, DateTime)
+
+    @property
+    def native_object(self):
+        return self.value.native_object
+
+    def __str__(self):
+        return self.name.lower()
+
+    def __repr__(self):
+        return str(self)
+
+    @staticmethod
+    def of(value_type: Union[Object, Boolean, Long, Double, String, DateTime]) -> ValueType:
+        """
+        :meta private:
+        """
+        for type_ in ValueType:
+            if type_.native_object == value_type:
+                return type_
+        raise TypeDBDriverException(UNEXPECTED_NATIVE_VALUE)
```

## typedb/api/connection/credential.py

 * *Ordering differences only*

```diff
@@ -1,52 +1,52 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from typing import Optional
-
-from typedb.native_driver_wrapper import credential_new, Credential as NativeCredential
-
-from typedb.common.exception import TypeDBDriverException, CLOUD_CREDENTIAL_INCONSISTENT, ILLEGAL_STATE
-from typedb.common.native_wrapper import NativeWrapper
-
-
-class TypeDBCredential(NativeWrapper[NativeCredential]):
-    """
-    User credentials and TLS encryption settings for connecting to TypeDB Cloud. Arguments:
-    1) username: The name of the user to connect as. 2) password: The password for the user.
-    3) tls_root_ca_path: Path to the CA certificate to use for authenticating server certificates.
-    4) tls_enabled: Specify whether the connection to TypeDB Cloud must be done over TLS.
-
-    Examples:
-    --------
-    ::
-
-        # Creates a credential using the specified username and password.
-        credential = TypeDBCredential(username, password)
-
-        # Creates a credential as above, but with TLS and the specified CA to authenticate server certificates.
-        credential = TypeDBCredential(username, password, tls_enabled=True, tls_root_ca_path="path/to/ca-certificate.pem")
-    """
-
-    def __init__(self, username: str, password: str, *, tls_root_ca_path: Optional[str] = None,
-                 tls_enabled: bool = False):
-        if tls_root_ca_path is not None and not tls_enabled:
-            raise TypeDBDriverException(CLOUD_CREDENTIAL_INCONSISTENT)
-        super().__init__(credential_new(username, password, tls_root_ca_path, tls_enabled))
-
-    @property
-    def _native_object_not_owned_exception(self) -> TypeDBDriverException:
-        return TypeDBDriverException(ILLEGAL_STATE)
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from typing import Optional
+
+from typedb.native_driver_wrapper import credential_new, Credential as NativeCredential
+
+from typedb.common.exception import TypeDBDriverException, CLOUD_CREDENTIAL_INCONSISTENT, ILLEGAL_STATE
+from typedb.common.native_wrapper import NativeWrapper
+
+
+class TypeDBCredential(NativeWrapper[NativeCredential]):
+    """
+    User credentials and TLS encryption settings for connecting to TypeDB Cloud. Arguments:
+    1) username: The name of the user to connect as. 2) password: The password for the user.
+    3) tls_root_ca_path: Path to the CA certificate to use for authenticating server certificates.
+    4) tls_enabled: Specify whether the connection to TypeDB Cloud must be done over TLS.
+
+    Examples:
+    --------
+    ::
+
+        # Creates a credential using the specified username and password.
+        credential = TypeDBCredential(username, password)
+
+        # Creates a credential as above, but with TLS and the specified CA to authenticate server certificates.
+        credential = TypeDBCredential(username, password, tls_enabled=True, tls_root_ca_path="path/to/ca-certificate.pem")
+    """
+
+    def __init__(self, username: str, password: str, *, tls_root_ca_path: Optional[str] = None,
+                 tls_enabled: bool = False):
+        if tls_root_ca_path is not None and not tls_enabled:
+            raise TypeDBDriverException(CLOUD_CREDENTIAL_INCONSISTENT)
+        super().__init__(credential_new(username, password, tls_root_ca_path, tls_enabled))
+
+    @property
+    def _native_object_not_owned_exception(self) -> TypeDBDriverException:
+        return TypeDBDriverException(ILLEGAL_STATE)
```

## typedb/api/connection/database.py

 * *Ordering differences only*

```diff
@@ -1,261 +1,261 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from abc import ABC, abstractmethod
-from typing import Optional, List, Set
-
-
-class Database(ABC):
-
-    @property
-    @abstractmethod
-    def name(self) -> str:
-        """
-        The database name as a string.
-        """
-        pass
-
-    @abstractmethod
-    def schema(self) -> str:
-        """
-        Returns a full schema text as a valid TypeQL define query string.
-
-        :return:
-
-        Examples:
-        ---------
-        ::
-
-            database.schema()
-        """
-        pass
-
-    def rule_schema(self) -> str:
-        """
-        Returns the rules in the schema as a valid TypeQL define query string.
-
-        :return:
-
-        Examples:
-        ---------
-        ::
-
-            database.rule_schema()
-        """
-        pass
-
-    def type_schema(self) -> str:
-        """
-        Returns the types in the schema as a valid TypeQL define query string.
-
-        :return:
-
-        Examples:
-        ---------
-        ::
-
-            database.type_schema()
-        """
-        pass
-
-    @abstractmethod
-    def delete(self) -> None:
-        """
-        Deletes this database.
-
-        :return:
-
-        Examples:
-        ---------
-        ::
-
-            database.delete()
-        """
-        pass
-
-    @abstractmethod
-    def replicas(self) -> Set[Replica]:
-        """
-        Set of ``Replica`` instances for this database.
-        *Only works in TypeDB Cloud*
-
-        :return:
-
-        Examples:
-        ---------
-        ::
-
-            database.replicas()
-        """
-        pass
-
-    @abstractmethod
-    def primary_replica(self) -> Optional[Replica]:
-        """
-        Returns the primary replica for this database.
-        *Only works in TypeDB Cloud*
-
-        :return:
-
-        Examples:
-        ---------
-        ::
-
-            database.primary_replica()
-        """
-        pass
-
-    @abstractmethod
-    def preferred_replica(self) -> Optional[Replica]:
-        """
-        Returns the preferred replica for this database.
-        Operations which can be run on any replica will prefer to use this replica.
-        *Only works in TypeDB Cloud*
-
-        :return:
-
-        Examples:
-        ---------
-        ::
-
-            database.preferred_replica()
-        """
-        pass
-
-
-class Replica(ABC):
-    """
-    The metadata and state of an individual raft replica of a database.
-    """
-
-    @abstractmethod
-    def database(self) -> Database:
-        """
-        Retrieves the database for which this is a replica
-
-        :return:
-        """
-        pass
-
-    @abstractmethod
-    def server(self) -> str:
-        """
-        The server hosting this replica
-
-        :return:
-        """
-        pass
-
-    @abstractmethod
-    def is_primary(self) -> bool:
-        """
-        Checks whether this is the primary replica of the raft cluster.
-
-        :return:
-        """
-
-        pass
-
-    @abstractmethod
-    def is_preferred(self) -> bool:
-        """
-        Checks whether this is the preferred replica of the raft cluster.
-        If true, Operations which can be run on any replica will prefer to use this replica.
-
-        :return:
-        """
-        pass
-
-    @abstractmethod
-    def term(self) -> int:
-        """
-        The raft protocol 'term' of this replica.
-
-        :return:
-        """
-        pass
-
-
-class DatabaseManager(ABC):
-    """
-    Provides access to all database management methods.
-    """
-
-    @abstractmethod
-    def get(self, name: str) -> Database:
-        """
-        Retrieve the database with the given name.
-
-        :param name: The name of the database to retrieve
-        :return:
-
-        Examples:
-        ---------
-        ::
-
-            driver.databases.get(name)
-        """
-        pass
-
-    @abstractmethod
-    def contains(self, name: str) -> bool:
-        """
-        Checks if a database with the given name exists
-
-        :param name: The database name to be checked
-        :return:
-
-        Examples:
-        ---------
-        ::
-
-            driver.databases.contains(name)
-        """
-        pass
-
-    @abstractmethod
-    def create(self, name: str) -> None:
-        """
-        Create a database with the given name
-
-        :param name: The name of the database to be created
-        :return:
-
-        Examples:
-        ---------
-        ::
-
-            driver.databases.create(name)
-        """
-        pass
-
-    @abstractmethod
-    def all(self) -> List[Database]:
-        """
-        Retrieves all databases present on the TypeDB server
-
-        :return:
-
-        Examples:
-        ---------
-        ::
-
-            driver.databases.all()
-        """
-        pass
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from abc import ABC, abstractmethod
+from typing import Optional, List, Set
+
+
+class Database(ABC):
+
+    @property
+    @abstractmethod
+    def name(self) -> str:
+        """
+        The database name as a string.
+        """
+        pass
+
+    @abstractmethod
+    def schema(self) -> str:
+        """
+        Returns a full schema text as a valid TypeQL define query string.
+
+        :return:
+
+        Examples:
+        ---------
+        ::
+
+            database.schema()
+        """
+        pass
+
+    def rule_schema(self) -> str:
+        """
+        Returns the rules in the schema as a valid TypeQL define query string.
+
+        :return:
+
+        Examples:
+        ---------
+        ::
+
+            database.rule_schema()
+        """
+        pass
+
+    def type_schema(self) -> str:
+        """
+        Returns the types in the schema as a valid TypeQL define query string.
+
+        :return:
+
+        Examples:
+        ---------
+        ::
+
+            database.type_schema()
+        """
+        pass
+
+    @abstractmethod
+    def delete(self) -> None:
+        """
+        Deletes this database.
+
+        :return:
+
+        Examples:
+        ---------
+        ::
+
+            database.delete()
+        """
+        pass
+
+    @abstractmethod
+    def replicas(self) -> Set[Replica]:
+        """
+        Set of ``Replica`` instances for this database.
+        *Only works in TypeDB Cloud*
+
+        :return:
+
+        Examples:
+        ---------
+        ::
+
+            database.replicas()
+        """
+        pass
+
+    @abstractmethod
+    def primary_replica(self) -> Optional[Replica]:
+        """
+        Returns the primary replica for this database.
+        *Only works in TypeDB Cloud*
+
+        :return:
+
+        Examples:
+        ---------
+        ::
+
+            database.primary_replica()
+        """
+        pass
+
+    @abstractmethod
+    def preferred_replica(self) -> Optional[Replica]:
+        """
+        Returns the preferred replica for this database.
+        Operations which can be run on any replica will prefer to use this replica.
+        *Only works in TypeDB Cloud*
+
+        :return:
+
+        Examples:
+        ---------
+        ::
+
+            database.preferred_replica()
+        """
+        pass
+
+
+class Replica(ABC):
+    """
+    The metadata and state of an individual raft replica of a database.
+    """
+
+    @abstractmethod
+    def database(self) -> Database:
+        """
+        Retrieves the database for which this is a replica
+
+        :return:
+        """
+        pass
+
+    @abstractmethod
+    def server(self) -> str:
+        """
+        The server hosting this replica
+
+        :return:
+        """
+        pass
+
+    @abstractmethod
+    def is_primary(self) -> bool:
+        """
+        Checks whether this is the primary replica of the raft cluster.
+
+        :return:
+        """
+
+        pass
+
+    @abstractmethod
+    def is_preferred(self) -> bool:
+        """
+        Checks whether this is the preferred replica of the raft cluster.
+        If true, Operations which can be run on any replica will prefer to use this replica.
+
+        :return:
+        """
+        pass
+
+    @abstractmethod
+    def term(self) -> int:
+        """
+        The raft protocol 'term' of this replica.
+
+        :return:
+        """
+        pass
+
+
+class DatabaseManager(ABC):
+    """
+    Provides access to all database management methods.
+    """
+
+    @abstractmethod
+    def get(self, name: str) -> Database:
+        """
+        Retrieve the database with the given name.
+
+        :param name: The name of the database to retrieve
+        :return:
+
+        Examples:
+        ---------
+        ::
+
+            driver.databases.get(name)
+        """
+        pass
+
+    @abstractmethod
+    def contains(self, name: str) -> bool:
+        """
+        Checks if a database with the given name exists
+
+        :param name: The database name to be checked
+        :return:
+
+        Examples:
+        ---------
+        ::
+
+            driver.databases.contains(name)
+        """
+        pass
+
+    @abstractmethod
+    def create(self, name: str) -> None:
+        """
+        Create a database with the given name
+
+        :param name: The name of the database to be created
+        :return:
+
+        Examples:
+        ---------
+        ::
+
+            driver.databases.create(name)
+        """
+        pass
+
+    @abstractmethod
+    def all(self) -> List[Database]:
+        """
+        Retrieves all databases present on the TypeDB server
+
+        :return:
+
+        Examples:
+        ---------
+        ::
+
+            driver.databases.all()
+        """
+        pass
```

## typedb/api/connection/driver.py

 * *Ordering differences only*

```diff
@@ -1,120 +1,120 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from abc import ABC, abstractmethod
-from typing import Optional, TYPE_CHECKING
-
-if TYPE_CHECKING:
-    from typedb.api.connection.database import DatabaseManager
-    from typedb.api.connection.options import TypeDBOptions
-    from typedb.api.connection.session import TypeDBSession, SessionType
-    from typedb.api.user.user import UserManager, User
-
-
-class TypeDBDriver(ABC):
-
-    @abstractmethod
-    def is_open(self) -> bool:
-        """
-        Checks whether this connection is presently open.
-
-        :return:
-
-        Examples:
-        ---------
-        ::
-
-            driver.is_open()
-        """
-        pass
-
-    @property
-    @abstractmethod
-    def databases(self) -> DatabaseManager:
-        """
-        The ``DatabaseManager`` for this connection, providing access to database management methods.
-        """
-        pass
-
-    @abstractmethod
-    def session(self, database_name: str, session_type: SessionType, options: Optional[TypeDBOptions] = None
-                ) -> TypeDBSession:
-        """
-        Opens a communication tunnel (session) to the given database on the running TypeDB server.
-        For more information on the methods, available with sessions, see the ``TypeDBSession`` section.
-
-        :param database_name: The name of the database with which the session connects
-        :param session_type: The type of session to be created (DATA or SCHEMA)
-        :param options: ``TypeDBOptions`` for the session
-        :return:
-
-        Examples:
-        ---------
-        ::
-
-            driver.session(database, session_type, options)
-        """
-        pass
-
-    @abstractmethod
-    def close(self) -> None:
-        """
-        Closes the driver. Before instantiating a new driver, the driver thats currently open should first be closed.
-
-        :return:
-
-        Examples:
-        ---------
-        ::
-
-            driver.close()
-        """
-        pass
-
-    @property
-    @abstractmethod
-    def users(self) -> UserManager:
-        """
-        The ``UserManager`` instance for this connection, providing access to user management methods.
-        Only for TypeDB Cloud.
-        """
-        pass
-
-    @abstractmethod
-    def user(self) -> User:
-        """
-        Returns the logged-in user for the connection. Only for TypeDB Cloud.
-
-        :return:
-
-        Examples:
-        ---------
-        ::
-
-            driver.user()
-        """
-        pass
-
-    @abstractmethod
-    def __enter__(self):
-        pass
-
-    @abstractmethod
-    def __exit__(self, exc_type, exc_val, exc_tb):
-        pass
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from abc import ABC, abstractmethod
+from typing import Optional, TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from typedb.api.connection.database import DatabaseManager
+    from typedb.api.connection.options import TypeDBOptions
+    from typedb.api.connection.session import TypeDBSession, SessionType
+    from typedb.api.user.user import UserManager, User
+
+
+class TypeDBDriver(ABC):
+
+    @abstractmethod
+    def is_open(self) -> bool:
+        """
+        Checks whether this connection is presently open.
+
+        :return:
+
+        Examples:
+        ---------
+        ::
+
+            driver.is_open()
+        """
+        pass
+
+    @property
+    @abstractmethod
+    def databases(self) -> DatabaseManager:
+        """
+        The ``DatabaseManager`` for this connection, providing access to database management methods.
+        """
+        pass
+
+    @abstractmethod
+    def session(self, database_name: str, session_type: SessionType, options: Optional[TypeDBOptions] = None
+                ) -> TypeDBSession:
+        """
+        Opens a communication tunnel (session) to the given database on the running TypeDB server.
+        For more information on the methods, available with sessions, see the ``TypeDBSession`` section.
+
+        :param database_name: The name of the database with which the session connects
+        :param session_type: The type of session to be created (DATA or SCHEMA)
+        :param options: ``TypeDBOptions`` for the session
+        :return:
+
+        Examples:
+        ---------
+        ::
+
+            driver.session(database, session_type, options)
+        """
+        pass
+
+    @abstractmethod
+    def close(self) -> None:
+        """
+        Closes the driver. Before instantiating a new driver, the driver thats currently open should first be closed.
+
+        :return:
+
+        Examples:
+        ---------
+        ::
+
+            driver.close()
+        """
+        pass
+
+    @property
+    @abstractmethod
+    def users(self) -> UserManager:
+        """
+        The ``UserManager`` instance for this connection, providing access to user management methods.
+        Only for TypeDB Cloud.
+        """
+        pass
+
+    @abstractmethod
+    def user(self) -> User:
+        """
+        Returns the logged-in user for the connection. Only for TypeDB Cloud.
+
+        :return:
+
+        Examples:
+        ---------
+        ::
+
+            driver.user()
+        """
+        pass
+
+    @abstractmethod
+    def __enter__(self):
+        pass
+
+    @abstractmethod
+    def __exit__(self, exc_type, exc_val, exc_tb):
+        pass
```

## typedb/api/connection/options.py

 * *Ordering differences only*

```diff
@@ -1,221 +1,221 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from typing import Optional
-
-from typedb.native_driver_wrapper import options_new, options_has_infer, options_get_infer, options_set_infer, \
-    options_get_trace_inference, options_has_trace_inference, options_set_trace_inference, options_get_explain, \
-    options_has_explain, options_set_explain, options_has_parallel, options_get_parallel, options_set_parallel, \
-    options_get_prefetch, options_has_prefetch, options_set_prefetch, options_has_prefetch_size, \
-    options_get_prefetch_size, options_set_prefetch_size, options_get_session_idle_timeout_millis, \
-    options_has_session_idle_timeout_millis, options_set_session_idle_timeout_millis, \
-    options_has_transaction_timeout_millis, options_get_transaction_timeout_millis, \
-    options_set_transaction_timeout_millis, options_get_schema_lock_acquire_timeout_millis, \
-    options_has_schema_lock_acquire_timeout_millis, options_set_schema_lock_acquire_timeout_millis, \
-    options_set_read_any_replica, options_get_read_any_replica, options_has_read_any_replica, Options as NativeOptions
-
-from typedb.common.exception import TypeDBDriverException, ILLEGAL_STATE, POSITIVE_VALUE_REQUIRED
-from typedb.common.native_wrapper import NativeWrapper
-
-
-class TypeDBOptions(NativeWrapper[NativeOptions]):
-    """
-    TypeDB session and transaction options. ``TypeDBOptions`` object
-    can be used to override the default server behaviour.
-
-    Options could be specified either as constructor arguments or using
-    properties assignment.
-
-    Examples
-    --------
-
-    ::
-
-      transaction_options = TypeDBOptions(infer=True, session_idle_timeout_millis=20000)
-      transaction_options.explain = True
-    """
-
-    def __init__(self, *,
-                 infer: Optional[bool] = None,
-                 trace_inference: Optional[bool] = None,
-                 explain: Optional[bool] = None,
-                 parallel: Optional[bool] = None,
-                 prefetch: Optional[bool] = None,
-                 prefetch_size: Optional[int] = None,
-                 session_idle_timeout_millis: Optional[int] = None,
-                 transaction_timeout_millis: Optional[int] = None,
-                 schema_lock_acquire_timeout_millis: Optional[int] = None,
-                 read_any_replica: Optional[bool] = None,
-                 ):
-        super().__init__(options_new())
-        if infer is not None:
-            self.infer = infer
-        if trace_inference is not None:
-            self.trace_inference = trace_inference
-        if explain is not None:
-            self.explain = explain
-        if parallel is not None:
-            self.parallel = parallel
-        if prefetch is not None:
-            self.prefetch = prefetch
-        if prefetch_size is not None:
-            self.prefetch_size = prefetch_size
-        if session_idle_timeout_millis is not None:
-            self.session_idle_timeout_millis = session_idle_timeout_millis
-        if transaction_timeout_millis is not None:
-            self.transaction_timeout_millis = transaction_timeout_millis
-        if schema_lock_acquire_timeout_millis is not None:
-            self.schema_lock_acquire_timeout_millis = schema_lock_acquire_timeout_millis
-        if read_any_replica is not None:
-            self.read_any_replica = read_any_replica
-
-    @property
-    def _native_object_not_owned_exception(self) -> TypeDBDriverException:
-        return TypeDBDriverException(ILLEGAL_STATE)
-
-    @property
-    def infer(self) -> Optional[bool]:
-        """
-        If set to ``True``, enables inference for queries. Only settable at transaction level and above.
-        Only affects read transactions.
-        """
-        return options_get_infer(self.native_object) if options_has_infer(self.native_object) else None
-
-    @infer.setter
-    def infer(self, infer: bool):
-        options_set_infer(self.native_object, infer)
-
-    @property
-    def trace_inference(self) -> Optional[bool]:
-        """
-        If set to ``True``, reasoning tracing graphs are output in the logging directory.
-        Should be used with ``parallel = False``.
-        """
-        return options_get_trace_inference(self.native_object) if options_has_trace_inference(self.native_object) \
-            else None
-
-    @trace_inference.setter
-    def trace_inference(self, trace_inference: bool):
-        options_set_trace_inference(self.native_object, trace_inference)
-
-    @property
-    def explain(self) -> Optional[bool]:
-        """
-        If set to ``True``, enables explanations for queries. Only affects read transactions.
-        """
-        return options_get_explain(self.native_object) if options_has_explain(self.native_object) else None
-
-    @explain.setter
-    def explain(self, explain: bool):
-        options_set_explain(self.native_object, explain)
-
-    @property
-    def parallel(self) -> Optional[bool]:
-        """
-        If set to ``True``, the server uses parallel instead of single-threaded execution.
-        """
-        return options_get_parallel(self.native_object) if options_has_parallel(self.native_object) else None
-
-    @parallel.setter
-    def parallel(self, parallel: bool):
-        options_set_parallel(self.native_object, parallel)
-
-    @property
-    def prefetch(self) -> Optional[bool]:
-        """
-        If set to ``True``, the first batch of answers is streamed to the driver
-        even without an explicit request for it.
-        """
-        return options_get_prefetch(self.native_object) if options_has_prefetch(self.native_object) else None
-
-    @prefetch.setter
-    def prefetch(self, prefetch: bool):
-        options_set_prefetch(self.native_object, prefetch)
-
-    @property
-    def prefetch_size(self) -> Optional[int]:
-        """
-        If set, specifies a guideline number of answers that the server should send
-        before the driver issues a fresh request.
-        """
-        return options_get_prefetch_size(self.native_object) if options_has_prefetch_size(self.native_object) else None
-
-    @prefetch_size.setter
-    def prefetch_size(self, prefetch_size: int):
-        if prefetch_size < 1:
-            raise TypeDBDriverException(POSITIVE_VALUE_REQUIRED, prefetch_size)
-        options_set_prefetch_size(self.native_object, prefetch_size)
-
-    @property
-    def session_idle_timeout_millis(self) -> Optional[int]:
-        """
-        If set, specifies a timeout that allows the server to close sessions if the driver
-        terminates or becomes unresponsive.
-        """
-        return options_get_session_idle_timeout_millis(self.native_object) \
-            if options_has_session_idle_timeout_millis(self.native_object) else None
-
-    @session_idle_timeout_millis.setter
-    def session_idle_timeout_millis(self, session_idle_timeout_millis: int):
-        if session_idle_timeout_millis < 1:
-            raise TypeDBDriverException(POSITIVE_VALUE_REQUIRED, session_idle_timeout_millis)
-        options_set_session_idle_timeout_millis(self.native_object, session_idle_timeout_millis)
-
-    @property
-    def transaction_timeout_millis(self) -> Optional[int]:
-        """
-        If set, specifies a timeout for killing transactions automatically, preventing
-        memory leaks in unclosed transactions.
-        """
-        return options_get_transaction_timeout_millis(self.native_object) \
-            if options_has_transaction_timeout_millis(self.native_object) else None
-
-    @transaction_timeout_millis.setter
-    def transaction_timeout_millis(self, transaction_timeout_millis: int):
-        if transaction_timeout_millis < 1:
-            raise TypeDBDriverException(POSITIVE_VALUE_REQUIRED, transaction_timeout_millis)
-        options_set_transaction_timeout_millis(self.native_object, transaction_timeout_millis)
-
-    @property
-    def schema_lock_acquire_timeout_millis(self) -> Optional[int]:
-        """
-        If set, specifies how long the driver should wait if opening a session or transaction
-        is blocked by a schema write lock.
-        """
-        return options_get_schema_lock_acquire_timeout_millis(self.native_object) \
-            if options_has_schema_lock_acquire_timeout_millis(self.native_object) else None
-
-    @schema_lock_acquire_timeout_millis.setter
-    def schema_lock_acquire_timeout_millis(self, schema_lock_acquire_timeout_millis: int):
-        if schema_lock_acquire_timeout_millis < 1:
-            raise TypeDBDriverException(POSITIVE_VALUE_REQUIRED, schema_lock_acquire_timeout_millis)
-        options_set_schema_lock_acquire_timeout_millis(self.native_object, schema_lock_acquire_timeout_millis)
-
-    @property
-    def read_any_replica(self) -> Optional[bool]:
-        """
-        If set to ``True``, enables reading data from any replica, potentially boosting
-        read throughput. Only settable in TypeDB Cloud.
-        """
-        return options_get_read_any_replica(self.native_object) if options_has_read_any_replica(self.native_object) \
-            else None
-
-    @read_any_replica.setter
-    def read_any_replica(self, read_any_replice: bool):
-        options_set_read_any_replica(self.native_object, read_any_replice)
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from typing import Optional
+
+from typedb.native_driver_wrapper import options_new, options_has_infer, options_get_infer, options_set_infer, \
+    options_get_trace_inference, options_has_trace_inference, options_set_trace_inference, options_get_explain, \
+    options_has_explain, options_set_explain, options_has_parallel, options_get_parallel, options_set_parallel, \
+    options_get_prefetch, options_has_prefetch, options_set_prefetch, options_has_prefetch_size, \
+    options_get_prefetch_size, options_set_prefetch_size, options_get_session_idle_timeout_millis, \
+    options_has_session_idle_timeout_millis, options_set_session_idle_timeout_millis, \
+    options_has_transaction_timeout_millis, options_get_transaction_timeout_millis, \
+    options_set_transaction_timeout_millis, options_get_schema_lock_acquire_timeout_millis, \
+    options_has_schema_lock_acquire_timeout_millis, options_set_schema_lock_acquire_timeout_millis, \
+    options_set_read_any_replica, options_get_read_any_replica, options_has_read_any_replica, Options as NativeOptions
+
+from typedb.common.exception import TypeDBDriverException, ILLEGAL_STATE, POSITIVE_VALUE_REQUIRED
+from typedb.common.native_wrapper import NativeWrapper
+
+
+class TypeDBOptions(NativeWrapper[NativeOptions]):
+    """
+    TypeDB session and transaction options. ``TypeDBOptions`` object
+    can be used to override the default server behaviour.
+
+    Options could be specified either as constructor arguments or using
+    properties assignment.
+
+    Examples
+    --------
+
+    ::
+
+      transaction_options = TypeDBOptions(infer=True, session_idle_timeout_millis=20000)
+      transaction_options.explain = True
+    """
+
+    def __init__(self, *,
+                 infer: Optional[bool] = None,
+                 trace_inference: Optional[bool] = None,
+                 explain: Optional[bool] = None,
+                 parallel: Optional[bool] = None,
+                 prefetch: Optional[bool] = None,
+                 prefetch_size: Optional[int] = None,
+                 session_idle_timeout_millis: Optional[int] = None,
+                 transaction_timeout_millis: Optional[int] = None,
+                 schema_lock_acquire_timeout_millis: Optional[int] = None,
+                 read_any_replica: Optional[bool] = None,
+                 ):
+        super().__init__(options_new())
+        if infer is not None:
+            self.infer = infer
+        if trace_inference is not None:
+            self.trace_inference = trace_inference
+        if explain is not None:
+            self.explain = explain
+        if parallel is not None:
+            self.parallel = parallel
+        if prefetch is not None:
+            self.prefetch = prefetch
+        if prefetch_size is not None:
+            self.prefetch_size = prefetch_size
+        if session_idle_timeout_millis is not None:
+            self.session_idle_timeout_millis = session_idle_timeout_millis
+        if transaction_timeout_millis is not None:
+            self.transaction_timeout_millis = transaction_timeout_millis
+        if schema_lock_acquire_timeout_millis is not None:
+            self.schema_lock_acquire_timeout_millis = schema_lock_acquire_timeout_millis
+        if read_any_replica is not None:
+            self.read_any_replica = read_any_replica
+
+    @property
+    def _native_object_not_owned_exception(self) -> TypeDBDriverException:
+        return TypeDBDriverException(ILLEGAL_STATE)
+
+    @property
+    def infer(self) -> Optional[bool]:
+        """
+        If set to ``True``, enables inference for queries. Only settable at transaction level and above.
+        Only affects read transactions.
+        """
+        return options_get_infer(self.native_object) if options_has_infer(self.native_object) else None
+
+    @infer.setter
+    def infer(self, infer: bool):
+        options_set_infer(self.native_object, infer)
+
+    @property
+    def trace_inference(self) -> Optional[bool]:
+        """
+        If set to ``True``, reasoning tracing graphs are output in the logging directory.
+        Should be used with ``parallel = False``.
+        """
+        return options_get_trace_inference(self.native_object) if options_has_trace_inference(self.native_object) \
+            else None
+
+    @trace_inference.setter
+    def trace_inference(self, trace_inference: bool):
+        options_set_trace_inference(self.native_object, trace_inference)
+
+    @property
+    def explain(self) -> Optional[bool]:
+        """
+        If set to ``True``, enables explanations for queries. Only affects read transactions.
+        """
+        return options_get_explain(self.native_object) if options_has_explain(self.native_object) else None
+
+    @explain.setter
+    def explain(self, explain: bool):
+        options_set_explain(self.native_object, explain)
+
+    @property
+    def parallel(self) -> Optional[bool]:
+        """
+        If set to ``True``, the server uses parallel instead of single-threaded execution.
+        """
+        return options_get_parallel(self.native_object) if options_has_parallel(self.native_object) else None
+
+    @parallel.setter
+    def parallel(self, parallel: bool):
+        options_set_parallel(self.native_object, parallel)
+
+    @property
+    def prefetch(self) -> Optional[bool]:
+        """
+        If set to ``True``, the first batch of answers is streamed to the driver
+        even without an explicit request for it.
+        """
+        return options_get_prefetch(self.native_object) if options_has_prefetch(self.native_object) else None
+
+    @prefetch.setter
+    def prefetch(self, prefetch: bool):
+        options_set_prefetch(self.native_object, prefetch)
+
+    @property
+    def prefetch_size(self) -> Optional[int]:
+        """
+        If set, specifies a guideline number of answers that the server should send
+        before the driver issues a fresh request.
+        """
+        return options_get_prefetch_size(self.native_object) if options_has_prefetch_size(self.native_object) else None
+
+    @prefetch_size.setter
+    def prefetch_size(self, prefetch_size: int):
+        if prefetch_size < 1:
+            raise TypeDBDriverException(POSITIVE_VALUE_REQUIRED, prefetch_size)
+        options_set_prefetch_size(self.native_object, prefetch_size)
+
+    @property
+    def session_idle_timeout_millis(self) -> Optional[int]:
+        """
+        If set, specifies a timeout that allows the server to close sessions if the driver
+        terminates or becomes unresponsive.
+        """
+        return options_get_session_idle_timeout_millis(self.native_object) \
+            if options_has_session_idle_timeout_millis(self.native_object) else None
+
+    @session_idle_timeout_millis.setter
+    def session_idle_timeout_millis(self, session_idle_timeout_millis: int):
+        if session_idle_timeout_millis < 1:
+            raise TypeDBDriverException(POSITIVE_VALUE_REQUIRED, session_idle_timeout_millis)
+        options_set_session_idle_timeout_millis(self.native_object, session_idle_timeout_millis)
+
+    @property
+    def transaction_timeout_millis(self) -> Optional[int]:
+        """
+        If set, specifies a timeout for killing transactions automatically, preventing
+        memory leaks in unclosed transactions.
+        """
+        return options_get_transaction_timeout_millis(self.native_object) \
+            if options_has_transaction_timeout_millis(self.native_object) else None
+
+    @transaction_timeout_millis.setter
+    def transaction_timeout_millis(self, transaction_timeout_millis: int):
+        if transaction_timeout_millis < 1:
+            raise TypeDBDriverException(POSITIVE_VALUE_REQUIRED, transaction_timeout_millis)
+        options_set_transaction_timeout_millis(self.native_object, transaction_timeout_millis)
+
+    @property
+    def schema_lock_acquire_timeout_millis(self) -> Optional[int]:
+        """
+        If set, specifies how long the driver should wait if opening a session or transaction
+        is blocked by a schema write lock.
+        """
+        return options_get_schema_lock_acquire_timeout_millis(self.native_object) \
+            if options_has_schema_lock_acquire_timeout_millis(self.native_object) else None
+
+    @schema_lock_acquire_timeout_millis.setter
+    def schema_lock_acquire_timeout_millis(self, schema_lock_acquire_timeout_millis: int):
+        if schema_lock_acquire_timeout_millis < 1:
+            raise TypeDBDriverException(POSITIVE_VALUE_REQUIRED, schema_lock_acquire_timeout_millis)
+        options_set_schema_lock_acquire_timeout_millis(self.native_object, schema_lock_acquire_timeout_millis)
+
+    @property
+    def read_any_replica(self) -> Optional[bool]:
+        """
+        If set to ``True``, enables reading data from any replica, potentially boosting
+        read throughput. Only settable in TypeDB Cloud.
+        """
+        return options_get_read_any_replica(self.native_object) if options_has_read_any_replica(self.native_object) \
+            else None
+
+    @read_any_replica.setter
+    def read_any_replica(self, read_any_replice: bool):
+        options_set_read_any_replica(self.native_object, read_any_replice)
```

## typedb/api/connection/session.py

 * *Ordering differences only*

```diff
@@ -1,172 +1,172 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from abc import ABC, abstractmethod
-from enum import Enum
-from typing import TYPE_CHECKING
-
-from typedb.native_driver_wrapper import Data, Schema
-
-if TYPE_CHECKING:
-    from typedb.api.connection.options import TypeDBOptions
-    from typedb.api.connection.transaction import TypeDBTransaction, TransactionType
-
-
-class SessionType(Enum):
-    """
-    This class is used to specify the type of the session.
-
-    Examples
-    --------
-    ::
-
-       driver.session(database, SessionType.SCHEMA)
-    """
-    DATA = Data
-    SCHEMA = Schema
-
-    def is_data(self) -> bool:
-        return self is SessionType.DATA
-
-    def is_schema(self) -> bool:
-        return self is SessionType.SCHEMA
-
-
-class TypeDBSession(ABC):
-
-    @abstractmethod
-    def is_open(self) -> bool:
-        """
-        Checks whether this session is open.
-
-        :return:
-
-        Examples:
-        ---------
-        ::
-
-            session.is_open()
-        """
-        pass
-
-    @property
-    @abstractmethod
-    def type(self) -> SessionType:
-        """
-        The current sessions type (SCHEMA or DATA)
-        """
-        pass
-
-    @abstractmethod
-    def database_name(self) -> str:
-        """
-        Returns the name of the database of the session.
-
-        :return:
-
-        Examples:
-        ---------
-        ::
-
-            session.database_name()
-        """
-        pass
-
-    @property
-    @abstractmethod
-    def options(self) -> TypeDBOptions:
-        """
-        Gets the options for the session
-        """
-        pass
-
-    @abstractmethod
-    def transaction(self, transaction_type: TransactionType, options: TypeDBOptions = None) -> TypeDBTransaction:
-        """
-        Opens a transaction to perform read or write queries on the database connected to the session.
-
-        :param transaction_type: The type of transaction to be created (READ or WRITE)
-        :param options: Options for the session
-        :return:
-
-        Examples:
-        ---------
-        ::
-
-            session.transaction(transaction_type, options)
-        """
-        pass
-
-    @abstractmethod
-    def on_close(self, function: callable) -> None:
-        """
-        Registers a callback function which will be executed when this session is closed.
-
-        :param function: The callback function.
-        :return:
-
-        Examples:
-        ---------
-        ::
-
-            session.on_close(function)
-        """
-        pass
-
-    @abstractmethod
-    def on_reopen(self, function: callable) -> None:
-        """
-        Registers a callback function which will be executed when this session is reopened.
-        A session may be closed if it times out, or loses the connection to the database.
-        In such situations, the session is reopened automatically when opening a new transaction.
-
-        :param function: The callback function.
-        :return:
-
-        Examples:
-        ---------
-        ::
-
-            session.on_close(function)
-        """
-        pass
-
-    @abstractmethod
-    def close(self) -> None:
-        """
-        Closes the session.
-        **Before opening a new session, the session currently open should first be closed.**
-
-        :return:
-
-        Examples:
-        ---------
-        ::
-
-            session.close()
-        """
-        pass
-
-    @abstractmethod
-    def __enter__(self):
-        pass
-
-    @abstractmethod
-    def __exit__(self, exc_type, exc_val, exc_tb):
-        pass
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from abc import ABC, abstractmethod
+from enum import Enum
+from typing import TYPE_CHECKING
+
+from typedb.native_driver_wrapper import Data, Schema
+
+if TYPE_CHECKING:
+    from typedb.api.connection.options import TypeDBOptions
+    from typedb.api.connection.transaction import TypeDBTransaction, TransactionType
+
+
+class SessionType(Enum):
+    """
+    This class is used to specify the type of the session.
+
+    Examples
+    --------
+    ::
+
+       driver.session(database, SessionType.SCHEMA)
+    """
+    DATA = Data
+    SCHEMA = Schema
+
+    def is_data(self) -> bool:
+        return self is SessionType.DATA
+
+    def is_schema(self) -> bool:
+        return self is SessionType.SCHEMA
+
+
+class TypeDBSession(ABC):
+
+    @abstractmethod
+    def is_open(self) -> bool:
+        """
+        Checks whether this session is open.
+
+        :return:
+
+        Examples:
+        ---------
+        ::
+
+            session.is_open()
+        """
+        pass
+
+    @property
+    @abstractmethod
+    def type(self) -> SessionType:
+        """
+        The current sessions type (SCHEMA or DATA)
+        """
+        pass
+
+    @abstractmethod
+    def database_name(self) -> str:
+        """
+        Returns the name of the database of the session.
+
+        :return:
+
+        Examples:
+        ---------
+        ::
+
+            session.database_name()
+        """
+        pass
+
+    @property
+    @abstractmethod
+    def options(self) -> TypeDBOptions:
+        """
+        Gets the options for the session
+        """
+        pass
+
+    @abstractmethod
+    def transaction(self, transaction_type: TransactionType, options: TypeDBOptions = None) -> TypeDBTransaction:
+        """
+        Opens a transaction to perform read or write queries on the database connected to the session.
+
+        :param transaction_type: The type of transaction to be created (READ or WRITE)
+        :param options: Options for the session
+        :return:
+
+        Examples:
+        ---------
+        ::
+
+            session.transaction(transaction_type, options)
+        """
+        pass
+
+    @abstractmethod
+    def on_close(self, function: callable) -> None:
+        """
+        Registers a callback function which will be executed when this session is closed.
+
+        :param function: The callback function.
+        :return:
+
+        Examples:
+        ---------
+        ::
+
+            session.on_close(function)
+        """
+        pass
+
+    @abstractmethod
+    def on_reopen(self, function: callable) -> None:
+        """
+        Registers a callback function which will be executed when this session is reopened.
+        A session may be closed if it times out, or loses the connection to the database.
+        In such situations, the session is reopened automatically when opening a new transaction.
+
+        :param function: The callback function.
+        :return:
+
+        Examples:
+        ---------
+        ::
+
+            session.on_close(function)
+        """
+        pass
+
+    @abstractmethod
+    def close(self) -> None:
+        """
+        Closes the session.
+        **Before opening a new session, the session currently open should first be closed.**
+
+        :return:
+
+        Examples:
+        ---------
+        ::
+
+            session.close()
+        """
+        pass
+
+    @abstractmethod
+    def __enter__(self):
+        pass
+
+    @abstractmethod
+    def __exit__(self, exc_type, exc_val, exc_tb):
+        pass
```

## typedb/api/connection/transaction.py

 * *Ordering differences only*

```diff
@@ -1,177 +1,177 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-import enum
-from abc import ABC, abstractmethod
-from typing import TYPE_CHECKING
-
-if TYPE_CHECKING:
-    from typedb.api.concept.concept_manager import ConceptManager
-    from typedb.api.logic.logic_manager import LogicManager
-    from typedb.api.connection.options import TypeDBOptions
-    from typedb.api.query.query_manager import QueryManager
-
-
-class TransactionType(enum.Enum):
-    """
-    This class is used to specify the type of transaction.
-
-    Examples
-    --------
-    ::
-
-       session.transaction(TransactionType.READ)
-    """
-    READ = 0
-    WRITE = 1
-
-    def is_read(self) -> bool:
-        return self is TransactionType.READ
-
-    def is_write(self) -> bool:
-        return self is TransactionType.WRITE
-
-
-class TypeDBTransaction(ABC):
-
-    @abstractmethod
-    def is_open(self) -> bool:
-        """
-        Checks whether this transaction is open.
-
-        :return:
-
-        Examples:
-        ---------
-        ::
-
-            transaction.is_open()
-        """
-        pass
-
-    @property
-    @abstractmethod
-    def transaction_type(self) -> TransactionType:
-        """
-        The transaction's type (READ or WRITE)
-        """
-        pass
-
-    @property
-    @abstractmethod
-    def options(self) -> TypeDBOptions:
-        """
-        The options for the transaction
-        """
-        pass
-
-    @property
-    @abstractmethod
-    def concepts(self) -> ConceptManager:
-        """
-        The ``ConceptManager`` for this transaction, providing access to all Concept API methods.
-        """
-        pass
-
-    @property
-    @abstractmethod
-    def logic(self) -> LogicManager:
-        """
-        The ``LogicManager`` for this Transaction, providing access to all Concept API - Logic methods.
-        """
-        pass
-
-    @property
-    @abstractmethod
-    def query(self) -> QueryManager:
-        """
-        The``QueryManager`` for this Transaction, from which any TypeQL query can be executed.
-        """
-        pass
-
-    @abstractmethod
-    def commit(self) -> None:
-        """
-        Commits the changes made via this transaction to the TypeDB database.
-        **Whether or not the transaction is commited successfully, it gets closed after the commit call.**
-
-
-        :return:
-
-        Examples:
-        ---------
-        ::
-
-            transaction.commit()
-        """
-        pass
-
-    @abstractmethod
-    def rollback(self) -> None:
-        """
-        Rolls back the uncommitted changes made via this transaction.
-
-        :return:
-
-        Examples:
-        ---------
-        ::
-
-            transaction.rollback()
-        """
-        pass
-
-    @abstractmethod
-    def on_close(self, function: callable) -> None:
-        """
-        Registers a callback function which will be executed when this transaction is closed.
-
-        :param function: The callback function.
-        :return:
-
-        Examples:
-        ---------
-        ::
-
-            transaction.on_close(function)
-        """
-        pass
-
-    @abstractmethod
-    def close(self) -> None:
-        """
-        Closes the transaction.
-
-        :return:
-
-        Examples:
-        ---------
-        ::
-
-            transaction.close()
-        """
-        pass
-
-    @abstractmethod
-    def __enter__(self):
-        pass
-
-    @abstractmethod
-    def __exit__(self, exc_type, exc_val, exc_tb):
-        pass
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+import enum
+from abc import ABC, abstractmethod
+from typing import TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from typedb.api.concept.concept_manager import ConceptManager
+    from typedb.api.logic.logic_manager import LogicManager
+    from typedb.api.connection.options import TypeDBOptions
+    from typedb.api.query.query_manager import QueryManager
+
+
+class TransactionType(enum.Enum):
+    """
+    This class is used to specify the type of transaction.
+
+    Examples
+    --------
+    ::
+
+       session.transaction(TransactionType.READ)
+    """
+    READ = 0
+    WRITE = 1
+
+    def is_read(self) -> bool:
+        return self is TransactionType.READ
+
+    def is_write(self) -> bool:
+        return self is TransactionType.WRITE
+
+
+class TypeDBTransaction(ABC):
+
+    @abstractmethod
+    def is_open(self) -> bool:
+        """
+        Checks whether this transaction is open.
+
+        :return:
+
+        Examples:
+        ---------
+        ::
+
+            transaction.is_open()
+        """
+        pass
+
+    @property
+    @abstractmethod
+    def transaction_type(self) -> TransactionType:
+        """
+        The transaction's type (READ or WRITE)
+        """
+        pass
+
+    @property
+    @abstractmethod
+    def options(self) -> TypeDBOptions:
+        """
+        The options for the transaction
+        """
+        pass
+
+    @property
+    @abstractmethod
+    def concepts(self) -> ConceptManager:
+        """
+        The ``ConceptManager`` for this transaction, providing access to all Concept API methods.
+        """
+        pass
+
+    @property
+    @abstractmethod
+    def logic(self) -> LogicManager:
+        """
+        The ``LogicManager`` for this Transaction, providing access to all Concept API - Logic methods.
+        """
+        pass
+
+    @property
+    @abstractmethod
+    def query(self) -> QueryManager:
+        """
+        The``QueryManager`` for this Transaction, from which any TypeQL query can be executed.
+        """
+        pass
+
+    @abstractmethod
+    def commit(self) -> None:
+        """
+        Commits the changes made via this transaction to the TypeDB database.
+        **Whether or not the transaction is commited successfully, it gets closed after the commit call.**
+
+
+        :return:
+
+        Examples:
+        ---------
+        ::
+
+            transaction.commit()
+        """
+        pass
+
+    @abstractmethod
+    def rollback(self) -> None:
+        """
+        Rolls back the uncommitted changes made via this transaction.
+
+        :return:
+
+        Examples:
+        ---------
+        ::
+
+            transaction.rollback()
+        """
+        pass
+
+    @abstractmethod
+    def on_close(self, function: callable) -> None:
+        """
+        Registers a callback function which will be executed when this transaction is closed.
+
+        :param function: The callback function.
+        :return:
+
+        Examples:
+        ---------
+        ::
+
+            transaction.on_close(function)
+        """
+        pass
+
+    @abstractmethod
+    def close(self) -> None:
+        """
+        Closes the transaction.
+
+        :return:
+
+        Examples:
+        ---------
+        ::
+
+            transaction.close()
+        """
+        pass
+
+    @abstractmethod
+    def __enter__(self):
+        pass
+
+    @abstractmethod
+    def __exit__(self, exc_type, exc_val, exc_tb):
+        pass
```

## typedb/api/logic/explanation.py

 * *Ordering differences only*

```diff
@@ -1,108 +1,108 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from abc import ABC, abstractmethod
-from typing import TYPE_CHECKING
-
-if TYPE_CHECKING:
-    from typedb.api.answer.concept_map import ConceptMap
-    from typedb.api.logic.rule import Rule
-
-
-class Explanation(ABC):
-    """
-    An explanation of which rule was used for inferring the explained concept, the condition of the rule,
-    the conclusion of the rule, and the mapping of variables between the query and the rule's conclusion.
-    """
-
-    @abstractmethod
-    def rule(self) -> Rule:
-        """
-        Retrieves the Rule for this Explanation.
-
-        :return:
-
-        Examples:
-        ---------
-        ::
-
-            explanation.rule()
-        """
-        pass
-
-    @abstractmethod
-    def conclusion(self) -> ConceptMap:
-        """
-        Retrieves the Conclusion for this Explanation.
-
-        :return:
-
-        Examples:
-        ---------
-        ::
-
-            explanation.conclusion()
-        """
-        pass
-
-    @abstractmethod
-    def condition(self) -> ConceptMap:
-        """
-        Retrieves the Condition for this Explanation.
-
-        :return:
-
-        Examples:
-        ---------
-        ::
-
-            explanation.condition()
-        """
-        pass
-
-    @abstractmethod
-    def query_variables(self) -> set[str]:
-        """
-        Retrieves the query variables for this ``Explanation``.
-
-        :return:
-
-        Examples:
-        ---------
-        ::
-
-            explanation.query_variables()
-        """
-        pass
-
-    @abstractmethod
-    def query_variable_mapping(self, var: str) -> set[str]:
-        """
-        Retrieves the rule variables corresponding to the query variable `var` for this ``Explanation``.
-
-        :param var: The query variable to map to rule variables.
-        :return:
-
-        Examples:
-        ---------
-        ::
-
-            explanation.variable_mapping(var)
-        """
-        pass
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from abc import ABC, abstractmethod
+from typing import TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from typedb.api.answer.concept_map import ConceptMap
+    from typedb.api.logic.rule import Rule
+
+
+class Explanation(ABC):
+    """
+    An explanation of which rule was used for inferring the explained concept, the condition of the rule,
+    the conclusion of the rule, and the mapping of variables between the query and the rule's conclusion.
+    """
+
+    @abstractmethod
+    def rule(self) -> Rule:
+        """
+        Retrieves the Rule for this Explanation.
+
+        :return:
+
+        Examples:
+        ---------
+        ::
+
+            explanation.rule()
+        """
+        pass
+
+    @abstractmethod
+    def conclusion(self) -> ConceptMap:
+        """
+        Retrieves the Conclusion for this Explanation.
+
+        :return:
+
+        Examples:
+        ---------
+        ::
+
+            explanation.conclusion()
+        """
+        pass
+
+    @abstractmethod
+    def condition(self) -> ConceptMap:
+        """
+        Retrieves the Condition for this Explanation.
+
+        :return:
+
+        Examples:
+        ---------
+        ::
+
+            explanation.condition()
+        """
+        pass
+
+    @abstractmethod
+    def query_variables(self) -> set[str]:
+        """
+        Retrieves the query variables for this ``Explanation``.
+
+        :return:
+
+        Examples:
+        ---------
+        ::
+
+            explanation.query_variables()
+        """
+        pass
+
+    @abstractmethod
+    def query_variable_mapping(self, var: str) -> set[str]:
+        """
+        Retrieves the rule variables corresponding to the query variable `var` for this ``Explanation``.
+
+        :param var: The query variable to map to rule variables.
+        :return:
+
+        Examples:
+        ---------
+        ::
+
+            explanation.variable_mapping(var)
+        """
+        pass
```

## typedb/api/logic/logic_manager.py

 * *Ordering differences only*

```diff
@@ -1,80 +1,80 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from abc import ABC, abstractmethod
-from typing import Iterator, Optional, TYPE_CHECKING
-
-if TYPE_CHECKING:
-    from typedb.api.logic.rule import Rule
-    from typedb.common.promise import Promise
-
-
-class LogicManager(ABC):
-    """
-    Provides methods for manipulating rules in the database.
-    """
-
-    @abstractmethod
-    def get_rule(self, label: str) -> Promise[Optional[Rule]]:
-        """
-        Retrieves the Rule that has the given label.
-
-        :param label: The label of the Rule to create or retrieve
-        :return:
-
-        Examples:
-        ---------
-        ::
-
-            transaction.logic.get_rule(label).resolve()
-        """
-        pass
-
-    @abstractmethod
-    def get_rules(self) -> Iterator[Rule]:
-        """
-        Retrieves all rules.
-
-        :return:
-
-        Examples:
-        ---------
-        ::
-
-            transaction.logic.get_rules()
-        """
-        pass
-
-    @abstractmethod
-    def put_rule(self, label: str, when: str, then: str) -> Promise[Rule]:
-        """
-        Creates a new Rule if none exists with the given label, or replaces the existing one.
-
-        :param label: The label of the Rule to create or replace
-        :param when: The when body of the rule to create
-        :param then: The then body of the rule to create
-        :return:
-
-        Examples:
-        ---------
-        ::
-
-            transaction.logic.put_rule(label, when, then).resolve()
-        """
-        pass
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from abc import ABC, abstractmethod
+from typing import Iterator, Optional, TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from typedb.api.logic.rule import Rule
+    from typedb.common.promise import Promise
+
+
+class LogicManager(ABC):
+    """
+    Provides methods for manipulating rules in the database.
+    """
+
+    @abstractmethod
+    def get_rule(self, label: str) -> Promise[Optional[Rule]]:
+        """
+        Retrieves the Rule that has the given label.
+
+        :param label: The label of the Rule to create or retrieve
+        :return:
+
+        Examples:
+        ---------
+        ::
+
+            transaction.logic.get_rule(label).resolve()
+        """
+        pass
+
+    @abstractmethod
+    def get_rules(self) -> Iterator[Rule]:
+        """
+        Retrieves all rules.
+
+        :return:
+
+        Examples:
+        ---------
+        ::
+
+            transaction.logic.get_rules()
+        """
+        pass
+
+    @abstractmethod
+    def put_rule(self, label: str, when: str, then: str) -> Promise[Rule]:
+        """
+        Creates a new Rule if none exists with the given label, or replaces the existing one.
+
+        :param label: The label of the Rule to create or replace
+        :param when: The when body of the rule to create
+        :param then: The then body of the rule to create
+        :return:
+
+        Examples:
+        ---------
+        ::
+
+            transaction.logic.put_rule(label, when, then).resolve()
+        """
+        pass
```

## typedb/api/logic/rule.py

 * *Ordering differences only*

```diff
@@ -1,106 +1,106 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from abc import ABC, abstractmethod
-from typing import TYPE_CHECKING
-
-if TYPE_CHECKING:
-    from typedb.api.connection.transaction import TypeDBTransaction
-    from typedb.common.promise import Promise
-
-
-class Rule(ABC):
-    """
-    Rules are a part of schema and define embedded logic.
-    The reasoning engine uses rules as a set of logic to infer new data.
-    A rule consists of a condition and a conclusion, and is uniquely identified by a label.
-    """
-
-    @property
-    @abstractmethod
-    def label(self) -> str:
-        """
-        The unique label of the rule.
-        """
-        pass
-
-    @abstractmethod
-    def set_label(self, transaction: TypeDBTransaction, new_label: str) -> Promise[None]:
-        """
-        Renames the label of the rule. The new label must remain unique.
-
-        :param transaction: The current ``Transaction``
-        :param new_label: The new label to be given to the rule
-        :return:
-
-        Examples:
-        ---------
-        ::
-
-            rule.set_label(transaction, new_label).resolve()
-        """
-        pass
-
-    @property
-    @abstractmethod
-    def when(self) -> str:
-        """
-        The statements that constitute the 'when' of the rule.
-        """
-        pass
-
-    @property
-    @abstractmethod
-    def then(self) -> str:
-        """
-        The single statement that constitutes the 'then' of the rule.
-        """
-        pass
-
-    @abstractmethod
-    def delete(self, transaction: TypeDBTransaction) -> Promise[None]:
-        """
-        Deletes this rule.
-
-        :param transaction: The current ``Transaction``
-        :return:
-
-        Examples:
-        ---------
-        ::
-
-            rule.delete(transaction).resolve()
-        """
-        pass
-
-    @abstractmethod
-    def is_deleted(self, transaction: TypeDBTransaction) -> Promise[bool]:
-        """
-        Check if this rule has been deleted.
-
-        :param transaction: The current ``Transaction``
-        :return:
-
-        Examples:
-        ---------
-        ::
-
-            rule.is_deleted(transaction).resolve()
-        """
-        pass
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from abc import ABC, abstractmethod
+from typing import TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from typedb.api.connection.transaction import TypeDBTransaction
+    from typedb.common.promise import Promise
+
+
+class Rule(ABC):
+    """
+    Rules are a part of schema and define embedded logic.
+    The reasoning engine uses rules as a set of logic to infer new data.
+    A rule consists of a condition and a conclusion, and is uniquely identified by a label.
+    """
+
+    @property
+    @abstractmethod
+    def label(self) -> str:
+        """
+        The unique label of the rule.
+        """
+        pass
+
+    @abstractmethod
+    def set_label(self, transaction: TypeDBTransaction, new_label: str) -> Promise[None]:
+        """
+        Renames the label of the rule. The new label must remain unique.
+
+        :param transaction: The current ``Transaction``
+        :param new_label: The new label to be given to the rule
+        :return:
+
+        Examples:
+        ---------
+        ::
+
+            rule.set_label(transaction, new_label).resolve()
+        """
+        pass
+
+    @property
+    @abstractmethod
+    def when(self) -> str:
+        """
+        The statements that constitute the 'when' of the rule.
+        """
+        pass
+
+    @property
+    @abstractmethod
+    def then(self) -> str:
+        """
+        The single statement that constitutes the 'then' of the rule.
+        """
+        pass
+
+    @abstractmethod
+    def delete(self, transaction: TypeDBTransaction) -> Promise[None]:
+        """
+        Deletes this rule.
+
+        :param transaction: The current ``Transaction``
+        :return:
+
+        Examples:
+        ---------
+        ::
+
+            rule.delete(transaction).resolve()
+        """
+        pass
+
+    @abstractmethod
+    def is_deleted(self, transaction: TypeDBTransaction) -> Promise[bool]:
+        """
+        Check if this rule has been deleted.
+
+        :param transaction: The current ``Transaction``
+        :return:
+
+        Examples:
+        ---------
+        ::
+
+            rule.is_deleted(transaction).resolve()
+        """
+        pass
```

## typedb/api/query/query_manager.py

 * *Ordering differences only*

```diff
@@ -1,224 +1,224 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from abc import ABC, abstractmethod
-from typing import Iterator, Optional, TYPE_CHECKING
-
-if TYPE_CHECKING:
-    from typedb.api.answer.concept_map import ConceptMap
-    from typedb.api.answer.concept_map_group import ConceptMapGroup
-    from typedb.api.answer.value_group import ValueGroup
-    from typedb.api.concept.value.value import Value
-    from typedb.api.connection.options import TypeDBOptions
-    from typedb.api.logic.explanation import Explanation
-    from typedb.common.promise import Promise
-
-
-class QueryManager(ABC):
-    """
-    Provides methods for executing TypeQL queries in the transaction.
-    """
-    
-    @abstractmethod
-    def get(self, query: str, options: Optional[TypeDBOptions] = None) -> Iterator[ConceptMap]:
-        """
-        Performs a TypeQL Match (Get) query in the transaction.
-
-        :param query:   The TypeQL Match (Get) query to be executed
-        :param options: Specify query options
-        :return:
-
-        Examples
-        --------
-        ::
-
-            transaction.query.get(query, options)
-        """
-        pass
-
-    @abstractmethod
-    def get_aggregate(self, query: str, options: Optional[TypeDBOptions] = None) -> Promise[Optional[Value]]:
-        """
-        Performs a TypeQL Match Aggregate query in the transaction.
-
-        :param query: The TypeQL Match Aggregate query to be executed
-        :param options: Specify query options
-        :return:
-
-        Examples
-        --------
-        ::
-
-            transaction.query.get_aggregate(query, options).resolve()
-        """
-        pass
-
-    @abstractmethod
-    def get_group(self, query: str, options: Optional[TypeDBOptions] = None) -> Iterator[ConceptMapGroup]:
-        """
-        Performs a TypeQL Match Group query in the transaction.
-
-        :param query: The TypeQL Match Group query to be executed
-        :param options: Specify query options
-        :return:
-
-        Examples
-        --------
-        ::
-
-             transaction.query.get_group(query, options)
-        """
-        pass
-
-    @abstractmethod
-    def get_group_aggregate(self, query: str, options: Optional[TypeDBOptions] = None) -> Iterator[ValueGroup]:
-        """
-        Performs a TypeQL Match Group Aggregate query in the transaction.
-
-        :param query: The TypeQL Match Group Aggregate query to be executed
-        :param options: Specify query options
-        :return:
-
-        Examples
-        --------
-        ::
-
-            transaction.query.get_group_aggregate(query, options)
-        """
-        pass
-
-    @abstractmethod
-    def fetch(self, query: str, options: Optional[TypeDBOptions] = None) -> Iterator[dict]:
-        """
-        Performs a TypeQL Fetch query in the transaction.
-
-        :param query:   The TypeQL Fetch query to be executed
-        :param options: Specify query options
-        :return:
-
-        Examples
-        --------
-        ::
-
-            transaction.query.fetch(query, options)
-        """
-        pass
-
-    @abstractmethod
-    def insert(self, query: str, options: Optional[TypeDBOptions] = None) -> Iterator[ConceptMap]:
-        """
-        Performs a TypeQL Insert query in the transaction.
-
-        :param query: The TypeQL Insert query to be executed
-        :param options: Specify query options
-        :return:
-
-        Examples
-        --------
-        ::
-
-            transaction.query.insert(query, options)
-        """
-        pass
-
-    @abstractmethod
-    def delete(self, query: str, options: Optional[TypeDBOptions] = None) -> Promise[None]:
-        """
-        Performs a TypeQL Delete query in the transaction.
-
-        :param query: The TypeQL Delete query to be executed
-        :param options: Specify query options
-        :return:
-
-        Examples
-        --------
-        ::
-
-            transaction.query.delete(query, options).resolve()
-        """
-        pass
-
-    @abstractmethod
-    def define(self, query: str, options: TypeDBOptions = None) -> Promise[None]:
-        """
-        Performs a TypeQL Define query in the transaction.
-
-        :param query: The TypeQL Define query to be executed
-        :param options: Specify query options
-        :return:
-
-        Examples
-        --------
-        ::
-
-            transaction.query.define(query, options).resolve()
-        """
-        pass
-
-    @abstractmethod
-    def undefine(self, query: str, options: TypeDBOptions = None) -> Promise[None]:
-        """
-        Performs a TypeQL Undefine query in the transaction.
-
-        :param query: The TypeQL Undefine query to be executed
-        :param options: Specify query options
-        :return:
-
-        Examples
-        --------
-        ::
-
-            transaction.query.undefine(query, options).resolve()
-        """
-        pass
-
-    @abstractmethod
-    def update(self, query: str, options: Optional[TypeDBOptions] = None) -> Iterator[ConceptMap]:
-        """
-        Performs a TypeQL Update query in the transaction.
-
-        :param query: The TypeQL Update query to be executed
-        :param options: Specify query options
-        :return:
-
-        Examples
-        --------
-        ::
-
-            transaction.query.update(query, options)
-        """
-        pass
-
-    @abstractmethod
-    def explain(self, explainable: ConceptMap.Explainable, options: Optional[TypeDBOptions] = None) -> Iterator[Explanation]:
-        """
-        Performs a TypeQL Explain query in the transaction.
-
-        :param explainable: The Explainable to be explained
-        :param options: Specify query options
-
-        :return:
-
-        Examples
-        --------
-        ::
-
-            transaction.query.explain(explainable, options)
-        """
-        pass
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from abc import ABC, abstractmethod
+from typing import Iterator, Optional, TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from typedb.api.answer.concept_map import ConceptMap
+    from typedb.api.answer.concept_map_group import ConceptMapGroup
+    from typedb.api.answer.value_group import ValueGroup
+    from typedb.api.concept.value.value import Value
+    from typedb.api.connection.options import TypeDBOptions
+    from typedb.api.logic.explanation import Explanation
+    from typedb.common.promise import Promise
+
+
+class QueryManager(ABC):
+    """
+    Provides methods for executing TypeQL queries in the transaction.
+    """
+    
+    @abstractmethod
+    def get(self, query: str, options: Optional[TypeDBOptions] = None) -> Iterator[ConceptMap]:
+        """
+        Performs a TypeQL Match (Get) query in the transaction.
+
+        :param query:   The TypeQL Match (Get) query to be executed
+        :param options: Specify query options
+        :return:
+
+        Examples
+        --------
+        ::
+
+            transaction.query.get(query, options)
+        """
+        pass
+
+    @abstractmethod
+    def get_aggregate(self, query: str, options: Optional[TypeDBOptions] = None) -> Promise[Optional[Value]]:
+        """
+        Performs a TypeQL Match Aggregate query in the transaction.
+
+        :param query: The TypeQL Match Aggregate query to be executed
+        :param options: Specify query options
+        :return:
+
+        Examples
+        --------
+        ::
+
+            transaction.query.get_aggregate(query, options).resolve()
+        """
+        pass
+
+    @abstractmethod
+    def get_group(self, query: str, options: Optional[TypeDBOptions] = None) -> Iterator[ConceptMapGroup]:
+        """
+        Performs a TypeQL Match Group query in the transaction.
+
+        :param query: The TypeQL Match Group query to be executed
+        :param options: Specify query options
+        :return:
+
+        Examples
+        --------
+        ::
+
+             transaction.query.get_group(query, options)
+        """
+        pass
+
+    @abstractmethod
+    def get_group_aggregate(self, query: str, options: Optional[TypeDBOptions] = None) -> Iterator[ValueGroup]:
+        """
+        Performs a TypeQL Match Group Aggregate query in the transaction.
+
+        :param query: The TypeQL Match Group Aggregate query to be executed
+        :param options: Specify query options
+        :return:
+
+        Examples
+        --------
+        ::
+
+            transaction.query.get_group_aggregate(query, options)
+        """
+        pass
+
+    @abstractmethod
+    def fetch(self, query: str, options: Optional[TypeDBOptions] = None) -> Iterator[dict]:
+        """
+        Performs a TypeQL Fetch query in the transaction.
+
+        :param query:   The TypeQL Fetch query to be executed
+        :param options: Specify query options
+        :return:
+
+        Examples
+        --------
+        ::
+
+            transaction.query.fetch(query, options)
+        """
+        pass
+
+    @abstractmethod
+    def insert(self, query: str, options: Optional[TypeDBOptions] = None) -> Iterator[ConceptMap]:
+        """
+        Performs a TypeQL Insert query in the transaction.
+
+        :param query: The TypeQL Insert query to be executed
+        :param options: Specify query options
+        :return:
+
+        Examples
+        --------
+        ::
+
+            transaction.query.insert(query, options)
+        """
+        pass
+
+    @abstractmethod
+    def delete(self, query: str, options: Optional[TypeDBOptions] = None) -> Promise[None]:
+        """
+        Performs a TypeQL Delete query in the transaction.
+
+        :param query: The TypeQL Delete query to be executed
+        :param options: Specify query options
+        :return:
+
+        Examples
+        --------
+        ::
+
+            transaction.query.delete(query, options).resolve()
+        """
+        pass
+
+    @abstractmethod
+    def define(self, query: str, options: TypeDBOptions = None) -> Promise[None]:
+        """
+        Performs a TypeQL Define query in the transaction.
+
+        :param query: The TypeQL Define query to be executed
+        :param options: Specify query options
+        :return:
+
+        Examples
+        --------
+        ::
+
+            transaction.query.define(query, options).resolve()
+        """
+        pass
+
+    @abstractmethod
+    def undefine(self, query: str, options: TypeDBOptions = None) -> Promise[None]:
+        """
+        Performs a TypeQL Undefine query in the transaction.
+
+        :param query: The TypeQL Undefine query to be executed
+        :param options: Specify query options
+        :return:
+
+        Examples
+        --------
+        ::
+
+            transaction.query.undefine(query, options).resolve()
+        """
+        pass
+
+    @abstractmethod
+    def update(self, query: str, options: Optional[TypeDBOptions] = None) -> Iterator[ConceptMap]:
+        """
+        Performs a TypeQL Update query in the transaction.
+
+        :param query: The TypeQL Update query to be executed
+        :param options: Specify query options
+        :return:
+
+        Examples
+        --------
+        ::
+
+            transaction.query.update(query, options)
+        """
+        pass
+
+    @abstractmethod
+    def explain(self, explainable: ConceptMap.Explainable, options: Optional[TypeDBOptions] = None) -> Iterator[Explanation]:
+        """
+        Performs a TypeQL Explain query in the transaction.
+
+        :param explainable: The Explainable to be explained
+        :param options: Specify query options
+
+        :return:
+
+        Examples
+        --------
+        ::
+
+            transaction.query.explain(explainable, options)
+        """
+        pass
```

## typedb/api/user/user.py

 * *Ordering differences only*

```diff
@@ -1,156 +1,156 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from abc import ABC, abstractmethod
-from typing import Optional, List
-
-
-class User(ABC):
-    """TypeDB user information"""
-
-    @abstractmethod
-    def username(self) -> str:
-        """
-        Returns the name of this user.
-
-        :return:
-        """
-        pass
-
-    @abstractmethod
-    def password_expiry_seconds(self) -> Optional[int]:
-        """
-        Returns the number of seconds remaining till this user's current password expires.
-
-        :return:
-        """
-        pass
-
-    @abstractmethod
-    def password_update(self, password_old: str, password_new: str) -> None:
-        """
-        Updates the password for this user.
-
-        :param password_old: The current password of this user
-        :param password_new: The new password
-        :return:
-        """
-        pass
-
-
-class UserManager(ABC):
-    """
-    Provides access to all user management methods.
-    """
-
-    @abstractmethod
-    def contains(self, username: str) -> bool:
-        """
-        Checks if a user with the given name exists.
-
-        :param username: The user name to be checked
-        :return:
-
-        Examples:
-        ---------
-        ::
-
-           driver.users.contains(username)
-        """
-        pass
-
-    @abstractmethod
-    def create(self, username: str, password: str) -> None:
-        """
-        Create a user with the given name and password.
-
-        :param username: The name of the user to be created
-        :param password: The password of the user to be created
-        :return:
-
-        Examples:
-        ---------
-        ::
-
-           driver.users.create(username, password)
-        """
-        pass
-
-    @abstractmethod
-    def delete(self, username: str) -> None:
-        """
-        Deletes a user with the given name.
-
-        :param username: The name of the user to be deleted
-        :return:
-
-        Examples:
-        ---------
-        ::
-
-           driver.users.delete(username)
-        """
-        pass
-
-    @abstractmethod
-    def get(self, username: str) -> Optional[User]:
-        """
-        Retrieve a user with the given name.
-
-        :param username: The name of the user to retrieve
-        :return:
-
-        Examples:
-        ---------
-        ::
-
-           driver.users.get(username)
-        """
-        pass
-
-    @abstractmethod
-    def all(self) -> List[User]:
-        """
-        Retrieves all users which exist on the TypeDB server.
-
-        :return:
-
-        Examples:
-        ---------
-        ::
-
-           driver.users.all()
-
-        """
-        pass
-
-    @abstractmethod
-    def password_set(self, username: str, password: str) -> None:
-        """
-        Sets a new password for a user. This operation can only be performed by administrators.
-
-        :param username: The name of the user to set the password of
-        :param password: The new password
-        :return:
-
-        Examples:
-        ---------
-        ::
-
-           driver.users.password_set(username, password)
-        """
-        pass
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from abc import ABC, abstractmethod
+from typing import Optional, List
+
+
+class User(ABC):
+    """TypeDB user information"""
+
+    @abstractmethod
+    def username(self) -> str:
+        """
+        Returns the name of this user.
+
+        :return:
+        """
+        pass
+
+    @abstractmethod
+    def password_expiry_seconds(self) -> Optional[int]:
+        """
+        Returns the number of seconds remaining till this user's current password expires.
+
+        :return:
+        """
+        pass
+
+    @abstractmethod
+    def password_update(self, password_old: str, password_new: str) -> None:
+        """
+        Updates the password for this user.
+
+        :param password_old: The current password of this user
+        :param password_new: The new password
+        :return:
+        """
+        pass
+
+
+class UserManager(ABC):
+    """
+    Provides access to all user management methods.
+    """
+
+    @abstractmethod
+    def contains(self, username: str) -> bool:
+        """
+        Checks if a user with the given name exists.
+
+        :param username: The user name to be checked
+        :return:
+
+        Examples:
+        ---------
+        ::
+
+           driver.users.contains(username)
+        """
+        pass
+
+    @abstractmethod
+    def create(self, username: str, password: str) -> None:
+        """
+        Create a user with the given name and password.
+
+        :param username: The name of the user to be created
+        :param password: The password of the user to be created
+        :return:
+
+        Examples:
+        ---------
+        ::
+
+           driver.users.create(username, password)
+        """
+        pass
+
+    @abstractmethod
+    def delete(self, username: str) -> None:
+        """
+        Deletes a user with the given name.
+
+        :param username: The name of the user to be deleted
+        :return:
+
+        Examples:
+        ---------
+        ::
+
+           driver.users.delete(username)
+        """
+        pass
+
+    @abstractmethod
+    def get(self, username: str) -> Optional[User]:
+        """
+        Retrieve a user with the given name.
+
+        :param username: The name of the user to retrieve
+        :return:
+
+        Examples:
+        ---------
+        ::
+
+           driver.users.get(username)
+        """
+        pass
+
+    @abstractmethod
+    def all(self) -> List[User]:
+        """
+        Retrieves all users which exist on the TypeDB server.
+
+        :return:
+
+        Examples:
+        ---------
+        ::
+
+           driver.users.all()
+
+        """
+        pass
+
+    @abstractmethod
+    def password_set(self, username: str, password: str) -> None:
+        """
+        Sets a new password for a user. This operation can only be performed by administrators.
+
+        :param username: The name of the user to set the password of
+        :param password: The new password
+        :return:
+
+        Examples:
+        ---------
+        ::
+
+           driver.users.password_set(username, password)
+        """
+        pass
```

## typedb/common/exception.py

 * *Ordering differences only*

```diff
@@ -1,162 +1,162 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from typing import Union, Any
-
-from typedb.native_driver_wrapper import TypeDBDriverExceptionNative
-
-
-class TypeDBDriverException(RuntimeError):
-    """
-    Exceptions raised by the driver.
-
-    Examples
-    --------
-
-    ::
-
-        try:
-            transaction.commit()
-        except TypeDBDriverException as err:
-            print("Error:", err)
-    """
-
-    def __init__(self, msg: Union[ErrorMessage, str], params: Any = None):
-        if isinstance(msg, str):
-            self.message = msg
-            self.error_message = None
-        else:
-            self.message = msg.message(params)
-            self.error_message = msg
-
-        super().__init__(self.message)
-
-    @staticmethod
-    def of(exception: TypeDBDriverExceptionNative) -> TypeDBDriverException:
-        """
-        :meta private:
-        """
-        return TypeDBDriverException(str(exception))
-
-
-class ErrorMessage:
-    """
-    :meta private:
-    """
-
-    def __init__(self, code_prefix: str, code_number: int, message_prefix: str, message_body: str):
-        self._code_prefix = code_prefix
-        self._code_number = code_number
-        self._message = message_prefix + ": " + message_body
-
-    def code(self) -> str:
-        return self._code_prefix + str(self._code_number).zfill(2)
-
-    def message(self, params: Any) -> str:
-        return self._message % params if params else self._message
-
-    def __str__(self):
-        return "[%s] %s" % (self.code(), self._message)
-
-
-class DriverErrorMessage(ErrorMessage):
-    """
-    :meta private:
-    """
-
-    def __init__(self, code: int, message: str):
-        super(DriverErrorMessage, self).__init__(code_prefix="PDR", code_number=code, message_prefix="Driver Error",
-                                                 message_body=message)
-
-
-DRIVER_CLOSED = DriverErrorMessage(1, "The driver has been closed and no further operation is allowed.")
-SESSION_CLOSED = DriverErrorMessage(2, "The session has been closed and no further operation is allowed.")
-TRANSACTION_CLOSED = DriverErrorMessage(3, "The transaction has been closed and no further operation is allowed.")
-DATABASE_DELETED = DriverErrorMessage(4, "The database '%s' has been deleted and no further operation is allowed.")
-MISSING_DB_NAME = DriverErrorMessage(5, "Database name cannot be empty.")
-POSITIVE_VALUE_REQUIRED = DriverErrorMessage(6, "Value should be positive, was: '%d'.")
-CLOUD_CREDENTIAL_INCONSISTENT = DriverErrorMessage(7, "TLS disabled but the Root CA path provided.")
-
-
-class ConceptErrorMessage(ErrorMessage):
-    """
-    :meta private:
-    """
-
-    def __init__(self, code: int, message: str):
-        super(ConceptErrorMessage, self).__init__(code_prefix="PCO", code_number=code,
-                                                  message_prefix="Concept Error", message_body=message)
-
-
-INVALID_CONCEPT_CASTING = ConceptErrorMessage(1, "Invalid concept conversion from '%s' to '%s'.")
-MISSING_IID = ConceptErrorMessage(2, "IID cannot be null or empty.")
-MISSING_LABEL = ConceptErrorMessage(3, "Label cannot be null or empty.")
-MISSING_VARIABLE = ConceptErrorMessage(4, "Variable name cannot be null or empty.")
-MISSING_VALUE = ConceptErrorMessage(5, "Value cannot be null or empty.")
-NONEXISTENT_EXPLAINABLE_CONCEPT = ConceptErrorMessage(6, "The concept identified by '%s' is not explainable.")
-NONEXISTENT_EXPLAINABLE_OWNERSHIP = ConceptErrorMessage(7, "The ownership by owner '%s' of attribute '%s' "
-                                                        "is not explainable.")
-GET_HAS_WITH_MULTIPLE_FILTERS = ConceptErrorMessage(8, "Only one filter can be applied at a time to get_has. "
-                                                    "The possible filters are: [attribute_type, attribute_types, "
-                                                    "annotations].")
-UNRECOGNISED_ANNOTATION = ConceptErrorMessage(9, "The annotation '%s' is not recognised.")
-
-
-class QueryErrorMessage(ErrorMessage):
-    """
-    :meta private:
-    """
-
-    def __init__(self, code: int, message: str):
-        super(QueryErrorMessage, self).__init__(code_prefix="PQR", code_number=code,
-                                                message_prefix="Query Error", message_body=message)
-
-
-VARIABLE_DOES_NOT_EXIST = QueryErrorMessage(1, "The variable '%s' does not exist.")
-MISSING_QUERY = QueryErrorMessage(2, "Query cannot be null or empty.")
-
-
-class InternalErrorMessage(ErrorMessage):
-    """
-    :meta private:
-    """
-
-    def __init__(self, code: int, message: str):
-        super(InternalErrorMessage, self).__init__(code_prefix="PIN", code_number=code,
-                                                   message_prefix="Python Internal Error", message_body=message)
-
-
-UNEXPECTED_NATIVE_VALUE = InternalErrorMessage(1, "Unexpected native value encountered!")
-ILLEGAL_STATE = InternalErrorMessage(2, "Illegal state has been reached!")
-ILLEGAL_CAST = InternalErrorMessage(3, "Illegal casting operation to '%s'.")
-NULL_NATIVE_OBJECT = InternalErrorMessage(4, "Unhandled null pointer to a native object encountered!")
-
-
-class TypeDBException(Exception):
-    """
-    :meta private:
-    """
-
-    def __init__(self, code: str, message: str):
-        super().__init__(code, message)
-        self._code = code
-        self._message = message
-
-    def __str__(self):
-        return "%s %s" % (self._code, self._message)
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from typing import Union, Any
+
+from typedb.native_driver_wrapper import TypeDBDriverExceptionNative
+
+
+class TypeDBDriverException(RuntimeError):
+    """
+    Exceptions raised by the driver.
+
+    Examples
+    --------
+
+    ::
+
+        try:
+            transaction.commit()
+        except TypeDBDriverException as err:
+            print("Error:", err)
+    """
+
+    def __init__(self, msg: Union[ErrorMessage, str], params: Any = None):
+        if isinstance(msg, str):
+            self.message = msg
+            self.error_message = None
+        else:
+            self.message = msg.message(params)
+            self.error_message = msg
+
+        super().__init__(self.message)
+
+    @staticmethod
+    def of(exception: TypeDBDriverExceptionNative) -> TypeDBDriverException:
+        """
+        :meta private:
+        """
+        return TypeDBDriverException(str(exception))
+
+
+class ErrorMessage:
+    """
+    :meta private:
+    """
+
+    def __init__(self, code_prefix: str, code_number: int, message_prefix: str, message_body: str):
+        self._code_prefix = code_prefix
+        self._code_number = code_number
+        self._message = message_prefix + ": " + message_body
+
+    def code(self) -> str:
+        return self._code_prefix + str(self._code_number).zfill(2)
+
+    def message(self, params: Any) -> str:
+        return self._message % params if params else self._message
+
+    def __str__(self):
+        return "[%s] %s" % (self.code(), self._message)
+
+
+class DriverErrorMessage(ErrorMessage):
+    """
+    :meta private:
+    """
+
+    def __init__(self, code: int, message: str):
+        super(DriverErrorMessage, self).__init__(code_prefix="PDR", code_number=code, message_prefix="Driver Error",
+                                                 message_body=message)
+
+
+DRIVER_CLOSED = DriverErrorMessage(1, "The driver has been closed and no further operation is allowed.")
+SESSION_CLOSED = DriverErrorMessage(2, "The session has been closed and no further operation is allowed.")
+TRANSACTION_CLOSED = DriverErrorMessage(3, "The transaction has been closed and no further operation is allowed.")
+DATABASE_DELETED = DriverErrorMessage(4, "The database '%s' has been deleted and no further operation is allowed.")
+MISSING_DB_NAME = DriverErrorMessage(5, "Database name cannot be empty.")
+POSITIVE_VALUE_REQUIRED = DriverErrorMessage(6, "Value should be positive, was: '%d'.")
+CLOUD_CREDENTIAL_INCONSISTENT = DriverErrorMessage(7, "TLS disabled but the Root CA path provided.")
+
+
+class ConceptErrorMessage(ErrorMessage):
+    """
+    :meta private:
+    """
+
+    def __init__(self, code: int, message: str):
+        super(ConceptErrorMessage, self).__init__(code_prefix="PCO", code_number=code,
+                                                  message_prefix="Concept Error", message_body=message)
+
+
+INVALID_CONCEPT_CASTING = ConceptErrorMessage(1, "Invalid concept conversion from '%s' to '%s'.")
+MISSING_IID = ConceptErrorMessage(2, "IID cannot be null or empty.")
+MISSING_LABEL = ConceptErrorMessage(3, "Label cannot be null or empty.")
+MISSING_VARIABLE = ConceptErrorMessage(4, "Variable name cannot be null or empty.")
+MISSING_VALUE = ConceptErrorMessage(5, "Value cannot be null or empty.")
+NONEXISTENT_EXPLAINABLE_CONCEPT = ConceptErrorMessage(6, "The concept identified by '%s' is not explainable.")
+NONEXISTENT_EXPLAINABLE_OWNERSHIP = ConceptErrorMessage(7, "The ownership by owner '%s' of attribute '%s' "
+                                                        "is not explainable.")
+GET_HAS_WITH_MULTIPLE_FILTERS = ConceptErrorMessage(8, "Only one filter can be applied at a time to get_has. "
+                                                    "The possible filters are: [attribute_type, attribute_types, "
+                                                    "annotations].")
+UNRECOGNISED_ANNOTATION = ConceptErrorMessage(9, "The annotation '%s' is not recognised.")
+
+
+class QueryErrorMessage(ErrorMessage):
+    """
+    :meta private:
+    """
+
+    def __init__(self, code: int, message: str):
+        super(QueryErrorMessage, self).__init__(code_prefix="PQR", code_number=code,
+                                                message_prefix="Query Error", message_body=message)
+
+
+VARIABLE_DOES_NOT_EXIST = QueryErrorMessage(1, "The variable '%s' does not exist.")
+MISSING_QUERY = QueryErrorMessage(2, "Query cannot be null or empty.")
+
+
+class InternalErrorMessage(ErrorMessage):
+    """
+    :meta private:
+    """
+
+    def __init__(self, code: int, message: str):
+        super(InternalErrorMessage, self).__init__(code_prefix="PIN", code_number=code,
+                                                   message_prefix="Python Internal Error", message_body=message)
+
+
+UNEXPECTED_NATIVE_VALUE = InternalErrorMessage(1, "Unexpected native value encountered!")
+ILLEGAL_STATE = InternalErrorMessage(2, "Illegal state has been reached!")
+ILLEGAL_CAST = InternalErrorMessage(3, "Illegal casting operation to '%s'.")
+NULL_NATIVE_OBJECT = InternalErrorMessage(4, "Unhandled null pointer to a native object encountered!")
+
+
+class TypeDBException(Exception):
+    """
+    :meta private:
+    """
+
+    def __init__(self, code: str, message: str):
+        super().__init__(code, message)
+        self._code = code
+        self._message = message
+
+    def __str__(self):
+        return "%s %s" % (self._code, self._message)
```

## typedb/common/iterator_wrapper.py

 * *Ordering differences only*

```diff
@@ -1,39 +1,39 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from typing import Callable
-
-from typedb.native_driver_wrapper import TypeDBDriverExceptionNative
-from typedb.common.exception import TypeDBDriverException
-
-
-class IteratorWrapper:
-
-    def __init__(self, native_iterator: object, native_next: Callable):
-        self._iterator = native_iterator
-        self._next = native_next
-
-    def __iter__(self):
-        return self
-
-    def __next__(self):
-        try:
-            if next_item := self._next(self._iterator):
-                return next_item
-            raise StopIteration
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from typing import Callable
+
+from typedb.native_driver_wrapper import TypeDBDriverExceptionNative
+from typedb.common.exception import TypeDBDriverException
+
+
+class IteratorWrapper:
+
+    def __init__(self, native_iterator: object, native_next: Callable):
+        self._iterator = native_iterator
+        self._next = native_next
+
+    def __iter__(self):
+        return self
+
+    def __next__(self):
+        try:
+            if next_item := self._next(self._iterator):
+                return next_item
+            raise StopIteration
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
```

## typedb/common/label.py

 * *Ordering differences only*

```diff
@@ -1,92 +1,92 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from typing import Optional
-
-
-class Label:
-    """
-    A ``Label`` holds the uniquely identifying name of a type.
-
-    It consists of an optional ``scope``, and a ``name``, represented ``scope:name``.
-    The scope is used only used to distinguish between role-types of the same name declared in different relation types.
-    """
-    def __init__(self, scope: Optional[str], name: str):
-        self._scope = scope
-        self._name = name
-
-    @staticmethod
-    def of(*args: str) -> Label:
-        """
-        Creates a Label from a specified name, or scoped name.
-
-        :param args: If a single string is provided, this is interpreted as the label name.
-            If a pair of strings is provided, the first string is the scope and the second string is the name.
-        :return:
-
-        Examples
-        --------
-
-        ::
-
-            Label.of("entity")
-            Label.of("relation", "role")
-        """
-        return Label(scope=args[0], name=args[1]) if len(args) == 2 else Label(scope=None, name=args[0])
-
-    @property
-    def scope(self) -> Optional[str]:
-        """ The scope part of the label """
-        return self._scope
-
-    @property
-    def name(self) -> str:
-        """ The name part of the label """
-        return self._name
-
-    def scoped_name(self) -> str:
-        """
-        Returns the string representation of the scoped name.
-
-        :return:
-
-        Examples
-        --------
-
-        ::
-
-            label.scoped_name()
-        """
-        return "%s:%s" % (self.scope, self.name) if self.scope else self.name
-
-    def __str__(self):
-        return self.scoped_name()
-
-    def __repr__(self):
-        return f"Label('{str(self)}')"
-
-    def __hash__(self):
-        return hash((self.name, self.scope))
-
-    def __eq__(self, other):
-        if other is self:
-            return True
-        if not other or type(self) != type(other):
-            return False
-        return self.scope == other.scope and self.name == other.name
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from typing import Optional
+
+
+class Label:
+    """
+    A ``Label`` holds the uniquely identifying name of a type.
+
+    It consists of an optional ``scope``, and a ``name``, represented ``scope:name``.
+    The scope is used only used to distinguish between role-types of the same name declared in different relation types.
+    """
+    def __init__(self, scope: Optional[str], name: str):
+        self._scope = scope
+        self._name = name
+
+    @staticmethod
+    def of(*args: str) -> Label:
+        """
+        Creates a Label from a specified name, or scoped name.
+
+        :param args: If a single string is provided, this is interpreted as the label name.
+            If a pair of strings is provided, the first string is the scope and the second string is the name.
+        :return:
+
+        Examples
+        --------
+
+        ::
+
+            Label.of("entity")
+            Label.of("relation", "role")
+        """
+        return Label(scope=args[0], name=args[1]) if len(args) == 2 else Label(scope=None, name=args[0])
+
+    @property
+    def scope(self) -> Optional[str]:
+        """ The scope part of the label """
+        return self._scope
+
+    @property
+    def name(self) -> str:
+        """ The name part of the label """
+        return self._name
+
+    def scoped_name(self) -> str:
+        """
+        Returns the string representation of the scoped name.
+
+        :return:
+
+        Examples
+        --------
+
+        ::
+
+            label.scoped_name()
+        """
+        return "%s:%s" % (self.scope, self.name) if self.scope else self.name
+
+    def __str__(self):
+        return self.scoped_name()
+
+    def __repr__(self):
+        return f"Label('{str(self)}')"
+
+    def __hash__(self):
+        return hash((self.name, self.scope))
+
+    def __eq__(self, other):
+        if other is self:
+            return True
+        if not other or type(self) != type(other):
+            return False
+        return self.scope == other.scope and self.name == other.name
```

## typedb/common/native_wrapper.py

 * *Ordering differences only*

```diff
@@ -1,43 +1,43 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from abc import ABC, abstractmethod
-from typing import Any, Generic, TypeVar
-
-from typedb.common.exception import TypeDBDriverException
-
-
-T = TypeVar("T")
-
-
-class NativeWrapper(ABC, Generic[T]):
-
-    def __init__(self, native_object: T):
-        self._native_object = native_object
-
-    @property
-    @abstractmethod
-    def _native_object_not_owned_exception(self) -> TypeDBDriverException:
-        pass
-
-    @property
-    def native_object(self) -> Any:
-        if not self._native_object.thisown:
-            raise self._native_object_not_owned_exception
-        return self._native_object
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from abc import ABC, abstractmethod
+from typing import Any, Generic, TypeVar
+
+from typedb.common.exception import TypeDBDriverException
+
+
+T = TypeVar("T")
+
+
+class NativeWrapper(ABC, Generic[T]):
+
+    def __init__(self, native_object: T):
+        self._native_object = native_object
+
+    @property
+    @abstractmethod
+    def _native_object_not_owned_exception(self) -> TypeDBDriverException:
+        pass
+
+    @property
+    def native_object(self) -> Any:
+        if not self._native_object.thisown:
+            raise self._native_object_not_owned_exception
+        return self._native_object
```

## typedb/common/promise.py

 * *Ordering differences only*

```diff
@@ -1,64 +1,64 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from typing import Callable, Generic, TypeVar
-
-from typedb.native_driver_wrapper import TypeDBDriverExceptionNative
-
-from typedb.common.exception import TypeDBDriverException
-
-T = TypeVar('T')
-U = TypeVar('U')
-
-
-class Promise(Generic[T]):
-    """
-    A ``Promise`` represents an asynchronous network operation.
-
-    The request it represents is performed immediately. The response is only retrieved
-    once the ``Promise`` is ``resolve``\ d.
-    """
-
-    def __init__(self, inner: Callable[[], T]):
-        self.inner = inner
-
-    @classmethod
-    def map(cls, ctor: Callable[[U], T], raw: Callable[[], U]) -> 'Promise[T]':
-        def inner():
-            if _res := raw():
-                return ctor(_res)
-            return None
-
-        return cls(inner)
-
-    def resolve(self) -> T:
-        """
-        Retrieves the result of the Promise.
-
-        :return:
-
-        Examples
-        --------
-
-        ::
-
-            promise.resolve()
-        """
-        try:
-            return self.inner()
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from typing import Callable, Generic, TypeVar
+
+from typedb.native_driver_wrapper import TypeDBDriverExceptionNative
+
+from typedb.common.exception import TypeDBDriverException
+
+T = TypeVar('T')
+U = TypeVar('U')
+
+
+class Promise(Generic[T]):
+    """
+    A ``Promise`` represents an asynchronous network operation.
+
+    The request it represents is performed immediately. The response is only retrieved
+    once the ``Promise`` is ``resolve``\ d.
+    """
+
+    def __init__(self, inner: Callable[[], T]):
+        self.inner = inner
+
+    @classmethod
+    def map(cls, ctor: Callable[[U], T], raw: Callable[[], U]) -> 'Promise[T]':
+        def inner():
+            if _res := raw():
+                return ctor(_res)
+            return None
+
+        return cls(inner)
+
+    def resolve(self) -> T:
+        """
+        Retrieves the result of the Promise.
+
+        :return:
+
+        Examples
+        --------
+
+        ::
+
+            promise.resolve()
+        """
+        try:
+            return self.inner()
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
```

## typedb/common/transitivity.py

 * *Ordering differences only*

```diff
@@ -1,36 +1,36 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from enum import Enum
-
-from typedb.native_driver_wrapper import Transitive, Explicit
-
-
-class Transitivity(Enum):
-    """
-    This class is used for specifying whether we need explicit
-    or transitive subtyping, instances, etc.
-
-    Examples
-    --------
-
-    ::
-
-       attribute_type.get_owners(transaction, annotations=annotations, transitivity=Transitivity.EXPLICIT)
-    """
-    TRANSITIVE = Transitive
-    EXPLICIT = Explicit
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from enum import Enum
+
+from typedb.native_driver_wrapper import Transitive, Explicit
+
+
+class Transitivity(Enum):
+    """
+    This class is used for specifying whether we need explicit
+    or transitive subtyping, instances, etc.
+
+    Examples
+    --------
+
+    ::
+
+       attribute_type.get_owners(transaction, annotations=annotations, transitivity=Transitivity.EXPLICIT)
+    """
+    TRANSITIVE = Transitive
+    EXPLICIT = Explicit
```

## typedb/concept/concept.py

 * *Ordering differences only*

```diff
@@ -1,48 +1,48 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from abc import ABC, abstractmethod
-
-from typedb.native_driver_wrapper import concept_to_string, concept_equals, Concept as NativeConcept
-
-from typedb.api.concept.concept import Concept
-from typedb.common.exception import TypeDBDriverException, ILLEGAL_STATE, NULL_NATIVE_OBJECT
-from typedb.common.native_wrapper import NativeWrapper
-
-
-class _Concept(Concept, NativeWrapper[NativeConcept], ABC):
-
-    def __init__(self, concept: NativeConcept):
-        if not concept:
-            raise TypeDBDriverException(NULL_NATIVE_OBJECT)
-        super().__init__(concept)
-
-    @property
-    def _native_object_not_owned_exception(self) -> TypeDBDriverException:
-        return TypeDBDriverException(ILLEGAL_STATE)
-
-    def __repr__(self):
-        return concept_to_string(self.native_object)
-
-    def __eq__(self, other):
-        return other and isinstance(other, _Concept) and concept_equals(self.native_object, other.native_object)
-
-    @abstractmethod
-    def __hash__(self):
-        pass
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from abc import ABC, abstractmethod
+
+from typedb.native_driver_wrapper import concept_to_string, concept_equals, Concept as NativeConcept
+
+from typedb.api.concept.concept import Concept
+from typedb.common.exception import TypeDBDriverException, ILLEGAL_STATE, NULL_NATIVE_OBJECT
+from typedb.common.native_wrapper import NativeWrapper
+
+
+class _Concept(Concept, NativeWrapper[NativeConcept], ABC):
+
+    def __init__(self, concept: NativeConcept):
+        if not concept:
+            raise TypeDBDriverException(NULL_NATIVE_OBJECT)
+        super().__init__(concept)
+
+    @property
+    def _native_object_not_owned_exception(self) -> TypeDBDriverException:
+        return TypeDBDriverException(ILLEGAL_STATE)
+
+    def __repr__(self):
+        return concept_to_string(self.native_object)
+
+    def __eq__(self, other):
+        return other and isinstance(other, _Concept) and concept_equals(self.native_object, other.native_object)
+
+    @abstractmethod
+    def __hash__(self):
+        pass
```

## typedb/concept/concept_factory.py

 * *Ordering differences only*

```diff
@@ -1,155 +1,155 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from typing import TYPE_CHECKING, Optional
-
-from typedb.native_driver_wrapper import \
-    concept_is_entity_type, concept_is_relation_type, concept_is_attribute_type, concept_is_root_thing_type, \
-    concept_is_entity, concept_is_relation, concept_is_attribute, concept_is_value, concept_is_role_type
-
-import typedb.concept
-from typedb.common.exception import TypeDBDriverException, UNEXPECTED_NATIVE_VALUE
-from typedb.concept.value.value import _Value
-
-if TYPE_CHECKING:
-    from typedb.concept.concept import _Concept
-    from typedb.concept.thing.attribute import _Attribute
-    from typedb.concept.thing.entity import _Entity
-    from typedb.concept.thing.relation import _Relation
-    from typedb.concept.thing.thing import _Thing
-    from typedb.concept.type.attribute_type import _AttributeType
-    from typedb.concept.type.entity_type import _EntityType
-    from typedb.concept.type.relation_type import _RelationType
-    from typedb.concept.type.role_type import _RoleType
-    from typedb.concept.type.thing_type import _ThingType, _Root
-    from typedb.native_driver_wrapper import Concept as NativeConcept
-
-
-def wrap_concept(native_concept: NativeConcept) -> _Concept:
-    if concept_thing_type := _try_thing_type(native_concept):
-        return concept_thing_type
-    elif concept_thing := _try_thing(native_concept):
-        return concept_thing
-    elif concept_is_value(native_concept):
-        return typedb.concept.value.value._Value(native_concept)
-    elif concept_is_role_type(native_concept):
-        return typedb.concept.type.role_type._RoleType(native_concept)
-    else:
-        raise TypeDBDriverException(UNEXPECTED_NATIVE_VALUE)
-
-
-def wrap_thing_type(native_concept: NativeConcept) -> _ThingType:
-    if concept_thing_type := _try_thing_type(native_concept):
-        return concept_thing_type
-    else:
-        raise TypeDBDriverException(UNEXPECTED_NATIVE_VALUE)
-
-
-def wrap_thing(native_concept: NativeConcept) -> _Thing:
-    if concept_thing := _try_thing(native_concept):
-        return concept_thing
-    else:
-        raise TypeDBDriverException(UNEXPECTED_NATIVE_VALUE)
-
-
-def wrap_entity_type(native_concept: NativeConcept) -> _EntityType:
-    if concept_is_entity_type(native_concept):
-        return typedb.concept.type.entity_type._EntityType(native_concept)
-    else:
-        raise TypeDBDriverException(UNEXPECTED_NATIVE_VALUE)
-
-
-def wrap_attribute_type(native_concept: NativeConcept) -> _AttributeType:
-    if concept_is_attribute_type(native_concept):
-        return typedb.concept.type.attribute_type._AttributeType(native_concept)
-    else:
-        raise TypeDBDriverException(UNEXPECTED_NATIVE_VALUE)
-
-
-def wrap_relation_type(native_concept: NativeConcept) -> _RelationType:
-    if concept_is_relation_type(native_concept):
-        return typedb.concept.type.relation_type._RelationType(native_concept)
-    else:
-        raise TypeDBDriverException(UNEXPECTED_NATIVE_VALUE)
-
-
-def wrap_role_type(native_concept: NativeConcept) -> _RoleType:
-    if concept_is_role_type(native_concept):
-        return typedb.concept.type.role_type._RoleType(native_concept)
-    else:
-        raise TypeDBDriverException(UNEXPECTED_NATIVE_VALUE)
-
-
-def wrap_root(native_concept: NativeConcept) -> _Root:
-    if concept_is_root_thing_type(native_concept):
-        return typedb.concept.type.thing_type._Root(native_concept)
-    else:
-        raise TypeDBDriverException(UNEXPECTED_NATIVE_VALUE)
-
-
-def wrap_entity(native_concept: NativeConcept) -> _Entity:
-    if concept_is_entity(native_concept):
-        return typedb.concept.thing.entity._Entity(native_concept)
-    else:
-        raise TypeDBDriverException(UNEXPECTED_NATIVE_VALUE)
-
-
-def wrap_attribute(native_concept: NativeConcept) -> _Attribute:
-    if concept_is_attribute(native_concept):
-        return typedb.concept.thing.attribute._Attribute(native_concept)
-    else:
-        raise TypeDBDriverException(UNEXPECTED_NATIVE_VALUE)
-
-
-def wrap_relation(native_concept: NativeConcept) -> _Relation:
-    if concept_is_relation(native_concept):
-        return typedb.concept.thing.relation._Relation(native_concept)
-    else:
-        raise TypeDBDriverException(UNEXPECTED_NATIVE_VALUE)
-
-
-def wrap_value(native_concept: NativeConcept) -> _Value:
-    if concept_is_value(native_concept):
-        return typedb.concept.value.value._Value(native_concept)
-    else:
-        raise TypeDBDriverException(UNEXPECTED_NATIVE_VALUE)
-
-
-def _try_thing_type(native_concept: NativeConcept) -> Optional[_ThingType]:
-    if concept_is_entity_type(native_concept):
-        return typedb.concept.type.entity_type._EntityType(native_concept)
-    elif concept_is_attribute_type(native_concept):
-        return typedb.concept.type.attribute_type._AttributeType(native_concept)
-    elif concept_is_relation_type(native_concept):
-        return typedb.concept.type.relation_type._RelationType(native_concept)
-    elif concept_is_root_thing_type(native_concept):
-        return typedb.concept.type.thing_type._Root(native_concept)
-    else:
-        return None
-
-
-def _try_thing(native_concept: NativeConcept) -> Optional[_Thing]:
-    if concept_is_entity(native_concept):
-        return typedb.concept.thing.entity._Entity(native_concept)
-    elif concept_is_attribute(native_concept):
-        return typedb.concept.thing.attribute._Attribute(native_concept)
-    elif concept_is_relation(native_concept):
-        return typedb.concept.thing.relation._Relation(native_concept)
-    else:
-        return None
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from typing import TYPE_CHECKING, Optional
+
+from typedb.native_driver_wrapper import \
+    concept_is_entity_type, concept_is_relation_type, concept_is_attribute_type, concept_is_root_thing_type, \
+    concept_is_entity, concept_is_relation, concept_is_attribute, concept_is_value, concept_is_role_type
+
+import typedb.concept
+from typedb.common.exception import TypeDBDriverException, UNEXPECTED_NATIVE_VALUE
+from typedb.concept.value.value import _Value
+
+if TYPE_CHECKING:
+    from typedb.concept.concept import _Concept
+    from typedb.concept.thing.attribute import _Attribute
+    from typedb.concept.thing.entity import _Entity
+    from typedb.concept.thing.relation import _Relation
+    from typedb.concept.thing.thing import _Thing
+    from typedb.concept.type.attribute_type import _AttributeType
+    from typedb.concept.type.entity_type import _EntityType
+    from typedb.concept.type.relation_type import _RelationType
+    from typedb.concept.type.role_type import _RoleType
+    from typedb.concept.type.thing_type import _ThingType, _Root
+    from typedb.native_driver_wrapper import Concept as NativeConcept
+
+
+def wrap_concept(native_concept: NativeConcept) -> _Concept:
+    if concept_thing_type := _try_thing_type(native_concept):
+        return concept_thing_type
+    elif concept_thing := _try_thing(native_concept):
+        return concept_thing
+    elif concept_is_value(native_concept):
+        return typedb.concept.value.value._Value(native_concept)
+    elif concept_is_role_type(native_concept):
+        return typedb.concept.type.role_type._RoleType(native_concept)
+    else:
+        raise TypeDBDriverException(UNEXPECTED_NATIVE_VALUE)
+
+
+def wrap_thing_type(native_concept: NativeConcept) -> _ThingType:
+    if concept_thing_type := _try_thing_type(native_concept):
+        return concept_thing_type
+    else:
+        raise TypeDBDriverException(UNEXPECTED_NATIVE_VALUE)
+
+
+def wrap_thing(native_concept: NativeConcept) -> _Thing:
+    if concept_thing := _try_thing(native_concept):
+        return concept_thing
+    else:
+        raise TypeDBDriverException(UNEXPECTED_NATIVE_VALUE)
+
+
+def wrap_entity_type(native_concept: NativeConcept) -> _EntityType:
+    if concept_is_entity_type(native_concept):
+        return typedb.concept.type.entity_type._EntityType(native_concept)
+    else:
+        raise TypeDBDriverException(UNEXPECTED_NATIVE_VALUE)
+
+
+def wrap_attribute_type(native_concept: NativeConcept) -> _AttributeType:
+    if concept_is_attribute_type(native_concept):
+        return typedb.concept.type.attribute_type._AttributeType(native_concept)
+    else:
+        raise TypeDBDriverException(UNEXPECTED_NATIVE_VALUE)
+
+
+def wrap_relation_type(native_concept: NativeConcept) -> _RelationType:
+    if concept_is_relation_type(native_concept):
+        return typedb.concept.type.relation_type._RelationType(native_concept)
+    else:
+        raise TypeDBDriverException(UNEXPECTED_NATIVE_VALUE)
+
+
+def wrap_role_type(native_concept: NativeConcept) -> _RoleType:
+    if concept_is_role_type(native_concept):
+        return typedb.concept.type.role_type._RoleType(native_concept)
+    else:
+        raise TypeDBDriverException(UNEXPECTED_NATIVE_VALUE)
+
+
+def wrap_root(native_concept: NativeConcept) -> _Root:
+    if concept_is_root_thing_type(native_concept):
+        return typedb.concept.type.thing_type._Root(native_concept)
+    else:
+        raise TypeDBDriverException(UNEXPECTED_NATIVE_VALUE)
+
+
+def wrap_entity(native_concept: NativeConcept) -> _Entity:
+    if concept_is_entity(native_concept):
+        return typedb.concept.thing.entity._Entity(native_concept)
+    else:
+        raise TypeDBDriverException(UNEXPECTED_NATIVE_VALUE)
+
+
+def wrap_attribute(native_concept: NativeConcept) -> _Attribute:
+    if concept_is_attribute(native_concept):
+        return typedb.concept.thing.attribute._Attribute(native_concept)
+    else:
+        raise TypeDBDriverException(UNEXPECTED_NATIVE_VALUE)
+
+
+def wrap_relation(native_concept: NativeConcept) -> _Relation:
+    if concept_is_relation(native_concept):
+        return typedb.concept.thing.relation._Relation(native_concept)
+    else:
+        raise TypeDBDriverException(UNEXPECTED_NATIVE_VALUE)
+
+
+def wrap_value(native_concept: NativeConcept) -> _Value:
+    if concept_is_value(native_concept):
+        return typedb.concept.value.value._Value(native_concept)
+    else:
+        raise TypeDBDriverException(UNEXPECTED_NATIVE_VALUE)
+
+
+def _try_thing_type(native_concept: NativeConcept) -> Optional[_ThingType]:
+    if concept_is_entity_type(native_concept):
+        return typedb.concept.type.entity_type._EntityType(native_concept)
+    elif concept_is_attribute_type(native_concept):
+        return typedb.concept.type.attribute_type._AttributeType(native_concept)
+    elif concept_is_relation_type(native_concept):
+        return typedb.concept.type.relation_type._RelationType(native_concept)
+    elif concept_is_root_thing_type(native_concept):
+        return typedb.concept.type.thing_type._Root(native_concept)
+    else:
+        return None
+
+
+def _try_thing(native_concept: NativeConcept) -> Optional[_Thing]:
+    if concept_is_entity(native_concept):
+        return typedb.concept.thing.entity._Entity(native_concept)
+    elif concept_is_attribute(native_concept):
+        return typedb.concept.thing.attribute._Attribute(native_concept)
+    elif concept_is_relation(native_concept):
+        return typedb.concept.thing.relation._Relation(native_concept)
+    else:
+        return None
```

## typedb/concept/concept_manager.py

 * *Ordering differences only*

```diff
@@ -1,121 +1,121 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from typing import Optional, TYPE_CHECKING
-
-from typedb.native_driver_wrapper import (
-    Transaction as NativeTransaction, TypeDBDriverExceptionNative, concept_promise_resolve, concepts_get_attribute,
-    concepts_get_attribute_type, concepts_get_entity, concepts_get_entity_type, concepts_get_relation, concepts_get_relation_type,
-    concepts_get_root_attribute_type, concepts_get_root_entity_type, concepts_get_root_relation_type,
-    concepts_get_schema_exceptions, concepts_put_attribute_type, concepts_put_entity_type, concepts_put_relation_type,
-    schema_exception_code, schema_exception_message,
-)
-
-from typedb.api.concept.concept_manager import ConceptManager
-from typedb.common.exception import TypeDBDriverException, TypeDBException, MISSING_LABEL, MISSING_IID, TRANSACTION_CLOSED
-from typedb.common.native_wrapper import NativeWrapper
-from typedb.common.promise import Promise
-from typedb.concept.thing.attribute import _Attribute
-from typedb.concept.thing.entity import _Entity
-from typedb.concept.thing.relation import _Relation
-from typedb.concept.type.attribute_type import _AttributeType
-from typedb.concept.type.entity_type import _EntityType
-from typedb.concept.type.relation_type import _RelationType
-
-if TYPE_CHECKING:
-    from typedb.api.concept.value.value import ValueType
-
-
-def _not_blank_label(label: str) -> str:
-    if not label or label.isspace():
-        raise TypeDBDriverException(MISSING_LABEL)
-    return label
-
-
-def _not_blank_iid(iid: str) -> str:
-    if not iid or iid.isspace():
-        raise TypeDBDriverException(MISSING_IID)
-    return iid
-
-
-class _ConceptManager(ConceptManager, NativeWrapper[NativeTransaction]):
-    def __init__(self, transaction: NativeTransaction):
-        super().__init__(transaction)
-
-    @property
-    def _native_object_not_owned_exception(self) -> TypeDBDriverException:
-        return TypeDBDriverException(TRANSACTION_CLOSED)
-
-    @property
-    def native_transaction(self) -> NativeTransaction:
-        return self.native_object
-
-    def get_root_entity_type(self) -> _EntityType:
-        return _EntityType(concepts_get_root_entity_type())
-
-    def get_root_relation_type(self) -> _RelationType:
-        return _RelationType(concepts_get_root_relation_type())
-
-    def get_root_attribute_type(self) -> _AttributeType:
-        return _AttributeType(concepts_get_root_attribute_type())
-
-    def get_entity_type(self, label: str) -> Promise[Optional[_EntityType]]:
-        promise = concepts_get_entity_type(self.native_transaction, _not_blank_label(label))
-        return Promise.map(_EntityType, lambda: concept_promise_resolve(promise))
-
-    def get_relation_type(self, label: str) -> Promise[Optional[_RelationType]]:
-        promise = concepts_get_relation_type(self.native_transaction, _not_blank_label(label))
-        return Promise.map(_RelationType, lambda: concept_promise_resolve(promise))
-
-    def get_attribute_type(self, label: str) -> Promise[Optional[_AttributeType]]:
-        promise = concepts_get_attribute_type(self.native_transaction, _not_blank_label(label))
-        return Promise.map(_AttributeType, lambda: concept_promise_resolve(promise))
-
-    def put_entity_type(self, label: str) -> Promise[_EntityType]:
-        promise = concepts_put_entity_type(self.native_transaction, _not_blank_label(label))
-        return Promise.map(_EntityType, lambda: concept_promise_resolve(promise))
-
-    def put_relation_type(self, label: str) -> Promise[_RelationType]:
-        promise = concepts_put_relation_type(self.native_transaction, _not_blank_label(label))
-        return Promise.map(_RelationType, lambda: concept_promise_resolve(promise))
-
-    def put_attribute_type(self, label: str, value_type: ValueType) -> Promise[_AttributeType]:
-        promise = concepts_put_attribute_type(self.native_transaction, _not_blank_label(label), value_type.native_object)
-        return Promise.map(_AttributeType, lambda: concept_promise_resolve(promise))
-
-    def get_entity(self, iid: str) -> Promise[Optional[_Entity]]:
-        promise = concepts_get_entity(self.native_transaction, _not_blank_iid(iid))
-        return Promise.map(_Entity, lambda: concept_promise_resolve(promise))
-
-    def get_relation(self, iid: str) -> Promise[Optional[_Relation]]:
-        promise = concepts_get_relation(self.native_transaction, _not_blank_iid(iid))
-        return Promise.map(_Relation, lambda: concept_promise_resolve(promise))
-
-    def get_attribute(self, iid: str) -> Promise[Optional[_Attribute]]:
-        promise = concepts_get_attribute(self.native_transaction, _not_blank_iid(iid))
-        return Promise.map(_Attribute, lambda: concept_promise_resolve(promise))
-
-    def get_schema_exception(self) -> list[TypeDBException]:
-        try:
-            return [
-                TypeDBException(schema_exception_code(e), schema_exception_message(e))
-                for e in concepts_get_schema_exceptions(self.native_transaction)
-            ]
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from typing import Optional, TYPE_CHECKING
+
+from typedb.native_driver_wrapper import (
+    Transaction as NativeTransaction, TypeDBDriverExceptionNative, concept_promise_resolve, concepts_get_attribute,
+    concepts_get_attribute_type, concepts_get_entity, concepts_get_entity_type, concepts_get_relation, concepts_get_relation_type,
+    concepts_get_root_attribute_type, concepts_get_root_entity_type, concepts_get_root_relation_type,
+    concepts_get_schema_exceptions, concepts_put_attribute_type, concepts_put_entity_type, concepts_put_relation_type,
+    schema_exception_code, schema_exception_message,
+)
+
+from typedb.api.concept.concept_manager import ConceptManager
+from typedb.common.exception import TypeDBDriverException, TypeDBException, MISSING_LABEL, MISSING_IID, TRANSACTION_CLOSED
+from typedb.common.native_wrapper import NativeWrapper
+from typedb.common.promise import Promise
+from typedb.concept.thing.attribute import _Attribute
+from typedb.concept.thing.entity import _Entity
+from typedb.concept.thing.relation import _Relation
+from typedb.concept.type.attribute_type import _AttributeType
+from typedb.concept.type.entity_type import _EntityType
+from typedb.concept.type.relation_type import _RelationType
+
+if TYPE_CHECKING:
+    from typedb.api.concept.value.value import ValueType
+
+
+def _not_blank_label(label: str) -> str:
+    if not label or label.isspace():
+        raise TypeDBDriverException(MISSING_LABEL)
+    return label
+
+
+def _not_blank_iid(iid: str) -> str:
+    if not iid or iid.isspace():
+        raise TypeDBDriverException(MISSING_IID)
+    return iid
+
+
+class _ConceptManager(ConceptManager, NativeWrapper[NativeTransaction]):
+    def __init__(self, transaction: NativeTransaction):
+        super().__init__(transaction)
+
+    @property
+    def _native_object_not_owned_exception(self) -> TypeDBDriverException:
+        return TypeDBDriverException(TRANSACTION_CLOSED)
+
+    @property
+    def native_transaction(self) -> NativeTransaction:
+        return self.native_object
+
+    def get_root_entity_type(self) -> _EntityType:
+        return _EntityType(concepts_get_root_entity_type())
+
+    def get_root_relation_type(self) -> _RelationType:
+        return _RelationType(concepts_get_root_relation_type())
+
+    def get_root_attribute_type(self) -> _AttributeType:
+        return _AttributeType(concepts_get_root_attribute_type())
+
+    def get_entity_type(self, label: str) -> Promise[Optional[_EntityType]]:
+        promise = concepts_get_entity_type(self.native_transaction, _not_blank_label(label))
+        return Promise.map(_EntityType, lambda: concept_promise_resolve(promise))
+
+    def get_relation_type(self, label: str) -> Promise[Optional[_RelationType]]:
+        promise = concepts_get_relation_type(self.native_transaction, _not_blank_label(label))
+        return Promise.map(_RelationType, lambda: concept_promise_resolve(promise))
+
+    def get_attribute_type(self, label: str) -> Promise[Optional[_AttributeType]]:
+        promise = concepts_get_attribute_type(self.native_transaction, _not_blank_label(label))
+        return Promise.map(_AttributeType, lambda: concept_promise_resolve(promise))
+
+    def put_entity_type(self, label: str) -> Promise[_EntityType]:
+        promise = concepts_put_entity_type(self.native_transaction, _not_blank_label(label))
+        return Promise.map(_EntityType, lambda: concept_promise_resolve(promise))
+
+    def put_relation_type(self, label: str) -> Promise[_RelationType]:
+        promise = concepts_put_relation_type(self.native_transaction, _not_blank_label(label))
+        return Promise.map(_RelationType, lambda: concept_promise_resolve(promise))
+
+    def put_attribute_type(self, label: str, value_type: ValueType) -> Promise[_AttributeType]:
+        promise = concepts_put_attribute_type(self.native_transaction, _not_blank_label(label), value_type.native_object)
+        return Promise.map(_AttributeType, lambda: concept_promise_resolve(promise))
+
+    def get_entity(self, iid: str) -> Promise[Optional[_Entity]]:
+        promise = concepts_get_entity(self.native_transaction, _not_blank_iid(iid))
+        return Promise.map(_Entity, lambda: concept_promise_resolve(promise))
+
+    def get_relation(self, iid: str) -> Promise[Optional[_Relation]]:
+        promise = concepts_get_relation(self.native_transaction, _not_blank_iid(iid))
+        return Promise.map(_Relation, lambda: concept_promise_resolve(promise))
+
+    def get_attribute(self, iid: str) -> Promise[Optional[_Attribute]]:
+        promise = concepts_get_attribute(self.native_transaction, _not_blank_iid(iid))
+        return Promise.map(_Attribute, lambda: concept_promise_resolve(promise))
+
+    def get_schema_exception(self) -> list[TypeDBException]:
+        try:
+            return [
+                TypeDBException(schema_exception_code(e), schema_exception_message(e))
+                for e in concepts_get_schema_exceptions(self.native_transaction)
+            ]
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
```

## typedb/concept/answer/concept_map.py

 * *Ordering differences only*

```diff
@@ -1,180 +1,180 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from typing import Mapping, Iterator, TYPE_CHECKING
-
-from typedb.native_driver_wrapper import concept_map_get_variables, string_iterator_next, concept_map_get_values, \
-    concept_iterator_next, concept_map_get, concept_map_get_explainables, concept_map_to_string, concept_map_equals, \
-    explainables_get_relation, explainables_get_attribute, explainables_get_ownership, \
-    explainables_get_relations_keys, explainables_get_attributes_keys, explainables_get_ownerships_keys, \
-    string_pair_iterator_next, explainables_to_string, explainables_equals, explainable_get_conjunction, \
-    explainable_get_id, ConceptMap as NativeConceptMap, Explainables as NativeExplainables, \
-    Explainable as NativeExplainable
-
-from typedb.api.answer.concept_map import ConceptMap
-from typedb.common.exception import TypeDBDriverException, ILLEGAL_STATE, MISSING_VARIABLE, \
-    NONEXISTENT_EXPLAINABLE_CONCEPT, NONEXISTENT_EXPLAINABLE_OWNERSHIP, NULL_NATIVE_OBJECT, VARIABLE_DOES_NOT_EXIST
-from typedb.common.iterator_wrapper import IteratorWrapper
-from typedb.common.native_wrapper import NativeWrapper
-from typedb.concept import concept_factory
-
-if TYPE_CHECKING:
-    from typedb.api.concept.concept import Concept
-
-
-def _not_blank_var(var: str) -> str:
-    if not var or var.isspace():
-        raise TypeDBDriverException(MISSING_VARIABLE)
-    return var
-
-
-class _ConceptMap(ConceptMap, NativeWrapper[NativeConceptMap]):
-
-    def __init__(self, concept_map: NativeConceptMap):
-        if not concept_map:
-            raise TypeDBDriverException(NULL_NATIVE_OBJECT)
-        super().__init__(concept_map)
-        self.cached_map = None
-
-    @property
-    def _native_object_not_owned_exception(self) -> TypeDBDriverException:
-        return TypeDBDriverException(ILLEGAL_STATE)
-
-    def variables(self) -> Iterator[str]:
-        return IteratorWrapper(concept_map_get_variables(self.native_object), string_iterator_next)
-
-    def concepts(self) -> Iterator[Concept]:
-        return map(concept_factory.wrap_concept, IteratorWrapper(concept_map_get_values(self.native_object),
-                                                                 concept_iterator_next))
-
-    @property
-    def map(self) -> Mapping[str, Concept]:
-        if self.cached_map is None:
-            self.cached_map = {v: self.get(v) for v in self.variables()}
-        return self.cached_map
-
-    def get(self, variable: str) -> Concept:
-        concept = concept_map_get(self.native_object, _not_blank_var(variable))
-        if not concept:
-            raise TypeDBDriverException(VARIABLE_DOES_NOT_EXIST, variable)
-        return concept_factory.wrap_concept(concept)
-
-    def explainables(self) -> ConceptMap.Explainables:
-        return _ConceptMap.Explainables(concept_map_get_explainables(self.native_object))
-
-    def __repr__(self):
-        return concept_map_to_string(self.native_object)
-
-    def __eq__(self, other):
-        if other is self:
-            return True
-        if not other or type(other) != type(self):
-            return False
-        return concept_map_equals(self.native_object, other.native_object)
-
-    def __hash__(self):
-        return hash((tuple(self.variables()), tuple(self.concepts())))
-
-    class Explainables(ConceptMap.Explainables, NativeWrapper[NativeExplainables]):
-
-        def __init__(self, explainables: NativeExplainables):
-            if not explainables:
-                raise TypeDBDriverException(NULL_NATIVE_OBJECT)
-            super().__init__(explainables)
-
-        @property
-        def _native_object_not_owned_exception(self) -> TypeDBDriverException:
-            return TypeDBDriverException(ILLEGAL_STATE)
-
-        def relation(self, variable: str) -> ConceptMap.Explainable:
-            explainable = explainables_get_relation(self.native_object, _not_blank_var(variable))
-            if not explainable:
-                raise TypeDBDriverException(NONEXISTENT_EXPLAINABLE_CONCEPT, variable)
-            return _ConceptMap.Explainable(explainable)
-
-        def attribute(self, variable: str) -> ConceptMap.Explainable:
-            explainable = explainables_get_attribute(self.native_object, _not_blank_var(variable))
-            if not explainable:
-                raise TypeDBDriverException(NONEXISTENT_EXPLAINABLE_CONCEPT, variable)
-            return _ConceptMap.Explainable(explainable)
-
-        def ownership(self, owner: str, attribute: str) -> ConceptMap.Explainable:
-            explainable = explainables_get_ownership(self.native_object, _not_blank_var(owner),
-                                                     _not_blank_var(attribute))
-            if not explainable:
-                raise TypeDBDriverException(NONEXISTENT_EXPLAINABLE_OWNERSHIP, (owner, attribute))
-            return _ConceptMap.Explainable(explainable)
-
-        def relations(self) -> Mapping[str, ConceptMap.Explainable]:
-            return {key: self.relation(key)
-                    for key in IteratorWrapper(explainables_get_relations_keys(self.native_object),
-                                               string_iterator_next)}
-
-        def attributes(self) -> Mapping[str, ConceptMap.Explainable]:
-            return {key: self.attribute(key)
-                    for key in IteratorWrapper(explainables_get_attributes_keys(self.native_object),
-                                               string_iterator_next)}
-
-        def ownerships(self) -> Mapping[tuple[str, str], ConceptMap.Explainable]:
-            return {key: self.ownership(*key)
-                    for key in IteratorWrapper(explainables_get_ownerships_keys(self.native_object),
-                                               string_pair_iterator_next)}
-
-        def __repr__(self):
-            return explainables_to_string(self.native_object)
-
-        def __eq__(self, other):
-            if other is self:
-                return True
-            if not other or type(other) != type(self):
-                return False
-            return explainables_equals(self.native_object, other.native_object)
-
-        def __hash__(self):
-            return hash((tuple(self.relations()), tuple(self.attributes()), tuple(self.ownerships())))
-
-    class Explainable(ConceptMap.Explainable, NativeWrapper[NativeExplainable]):
-
-        def __init__(self, explainable: NativeExplainable):
-            if not explainable:
-                raise TypeDBDriverException(NULL_NATIVE_OBJECT)
-            super().__init__(explainable)
-
-        @property
-        def _native_object_not_owned_exception(self) -> TypeDBDriverException:
-            return TypeDBDriverException(ILLEGAL_STATE)
-
-        def conjunction(self) -> str:
-            return explainable_get_conjunction(self.native_object)
-
-        def id(self) -> int:
-            return explainable_get_id(self.native_object)
-
-        def __repr__(self):
-            return f"Explainable {{ id: {self.id()}, conjunction: {self.conjunction()} }}"
-
-        def __eq__(self, other):
-            if other is self:
-                return True
-            if not other or type(other) != type(self):
-                return False
-            return self.id() == other.id()
-
-        def __hash__(self):
-            return hash(self.id())
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from typing import Mapping, Iterator, TYPE_CHECKING
+
+from typedb.native_driver_wrapper import concept_map_get_variables, string_iterator_next, concept_map_get_values, \
+    concept_iterator_next, concept_map_get, concept_map_get_explainables, concept_map_to_string, concept_map_equals, \
+    explainables_get_relation, explainables_get_attribute, explainables_get_ownership, \
+    explainables_get_relations_keys, explainables_get_attributes_keys, explainables_get_ownerships_keys, \
+    string_pair_iterator_next, explainables_to_string, explainables_equals, explainable_get_conjunction, \
+    explainable_get_id, ConceptMap as NativeConceptMap, Explainables as NativeExplainables, \
+    Explainable as NativeExplainable
+
+from typedb.api.answer.concept_map import ConceptMap
+from typedb.common.exception import TypeDBDriverException, ILLEGAL_STATE, MISSING_VARIABLE, \
+    NONEXISTENT_EXPLAINABLE_CONCEPT, NONEXISTENT_EXPLAINABLE_OWNERSHIP, NULL_NATIVE_OBJECT, VARIABLE_DOES_NOT_EXIST
+from typedb.common.iterator_wrapper import IteratorWrapper
+from typedb.common.native_wrapper import NativeWrapper
+from typedb.concept import concept_factory
+
+if TYPE_CHECKING:
+    from typedb.api.concept.concept import Concept
+
+
+def _not_blank_var(var: str) -> str:
+    if not var or var.isspace():
+        raise TypeDBDriverException(MISSING_VARIABLE)
+    return var
+
+
+class _ConceptMap(ConceptMap, NativeWrapper[NativeConceptMap]):
+
+    def __init__(self, concept_map: NativeConceptMap):
+        if not concept_map:
+            raise TypeDBDriverException(NULL_NATIVE_OBJECT)
+        super().__init__(concept_map)
+        self.cached_map = None
+
+    @property
+    def _native_object_not_owned_exception(self) -> TypeDBDriverException:
+        return TypeDBDriverException(ILLEGAL_STATE)
+
+    def variables(self) -> Iterator[str]:
+        return IteratorWrapper(concept_map_get_variables(self.native_object), string_iterator_next)
+
+    def concepts(self) -> Iterator[Concept]:
+        return map(concept_factory.wrap_concept, IteratorWrapper(concept_map_get_values(self.native_object),
+                                                                 concept_iterator_next))
+
+    @property
+    def map(self) -> Mapping[str, Concept]:
+        if self.cached_map is None:
+            self.cached_map = {v: self.get(v) for v in self.variables()}
+        return self.cached_map
+
+    def get(self, variable: str) -> Concept:
+        concept = concept_map_get(self.native_object, _not_blank_var(variable))
+        if not concept:
+            raise TypeDBDriverException(VARIABLE_DOES_NOT_EXIST, variable)
+        return concept_factory.wrap_concept(concept)
+
+    def explainables(self) -> ConceptMap.Explainables:
+        return _ConceptMap.Explainables(concept_map_get_explainables(self.native_object))
+
+    def __repr__(self):
+        return concept_map_to_string(self.native_object)
+
+    def __eq__(self, other):
+        if other is self:
+            return True
+        if not other or type(other) != type(self):
+            return False
+        return concept_map_equals(self.native_object, other.native_object)
+
+    def __hash__(self):
+        return hash((tuple(self.variables()), tuple(self.concepts())))
+
+    class Explainables(ConceptMap.Explainables, NativeWrapper[NativeExplainables]):
+
+        def __init__(self, explainables: NativeExplainables):
+            if not explainables:
+                raise TypeDBDriverException(NULL_NATIVE_OBJECT)
+            super().__init__(explainables)
+
+        @property
+        def _native_object_not_owned_exception(self) -> TypeDBDriverException:
+            return TypeDBDriverException(ILLEGAL_STATE)
+
+        def relation(self, variable: str) -> ConceptMap.Explainable:
+            explainable = explainables_get_relation(self.native_object, _not_blank_var(variable))
+            if not explainable:
+                raise TypeDBDriverException(NONEXISTENT_EXPLAINABLE_CONCEPT, variable)
+            return _ConceptMap.Explainable(explainable)
+
+        def attribute(self, variable: str) -> ConceptMap.Explainable:
+            explainable = explainables_get_attribute(self.native_object, _not_blank_var(variable))
+            if not explainable:
+                raise TypeDBDriverException(NONEXISTENT_EXPLAINABLE_CONCEPT, variable)
+            return _ConceptMap.Explainable(explainable)
+
+        def ownership(self, owner: str, attribute: str) -> ConceptMap.Explainable:
+            explainable = explainables_get_ownership(self.native_object, _not_blank_var(owner),
+                                                     _not_blank_var(attribute))
+            if not explainable:
+                raise TypeDBDriverException(NONEXISTENT_EXPLAINABLE_OWNERSHIP, (owner, attribute))
+            return _ConceptMap.Explainable(explainable)
+
+        def relations(self) -> Mapping[str, ConceptMap.Explainable]:
+            return {key: self.relation(key)
+                    for key in IteratorWrapper(explainables_get_relations_keys(self.native_object),
+                                               string_iterator_next)}
+
+        def attributes(self) -> Mapping[str, ConceptMap.Explainable]:
+            return {key: self.attribute(key)
+                    for key in IteratorWrapper(explainables_get_attributes_keys(self.native_object),
+                                               string_iterator_next)}
+
+        def ownerships(self) -> Mapping[tuple[str, str], ConceptMap.Explainable]:
+            return {key: self.ownership(*key)
+                    for key in IteratorWrapper(explainables_get_ownerships_keys(self.native_object),
+                                               string_pair_iterator_next)}
+
+        def __repr__(self):
+            return explainables_to_string(self.native_object)
+
+        def __eq__(self, other):
+            if other is self:
+                return True
+            if not other or type(other) != type(self):
+                return False
+            return explainables_equals(self.native_object, other.native_object)
+
+        def __hash__(self):
+            return hash((tuple(self.relations()), tuple(self.attributes()), tuple(self.ownerships())))
+
+    class Explainable(ConceptMap.Explainable, NativeWrapper[NativeExplainable]):
+
+        def __init__(self, explainable: NativeExplainable):
+            if not explainable:
+                raise TypeDBDriverException(NULL_NATIVE_OBJECT)
+            super().__init__(explainable)
+
+        @property
+        def _native_object_not_owned_exception(self) -> TypeDBDriverException:
+            return TypeDBDriverException(ILLEGAL_STATE)
+
+        def conjunction(self) -> str:
+            return explainable_get_conjunction(self.native_object)
+
+        def id(self) -> int:
+            return explainable_get_id(self.native_object)
+
+        def __repr__(self):
+            return f"Explainable {{ id: {self.id()}, conjunction: {self.conjunction()} }}"
+
+        def __eq__(self, other):
+            if other is self:
+                return True
+            if not other or type(other) != type(self):
+                return False
+            return self.id() == other.id()
+
+        def __hash__(self):
+            return hash(self.id())
```

## typedb/concept/answer/concept_map_group.py

 * *Ordering differences only*

```diff
@@ -1,67 +1,67 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from typing import Iterator, TYPE_CHECKING
-
-from typedb.native_driver_wrapper import concept_map_group_get_owner, concept_map_group_get_concept_maps, \
-    concept_map_iterator_next, concept_map_group_to_string, concept_map_group_equals, \
-    ConceptMapGroup as NativeConceptMapGroup
-
-from typedb.api.answer.concept_map_group import ConceptMapGroup
-from typedb.common.exception import TypeDBDriverException, ILLEGAL_STATE, NULL_NATIVE_OBJECT
-from typedb.common.iterator_wrapper import IteratorWrapper
-from typedb.common.native_wrapper import NativeWrapper
-from typedb.concept import concept_factory
-from typedb.concept.answer.concept_map import _ConceptMap
-
-if TYPE_CHECKING:
-    from typedb.api.concept.concept import Concept
-    from typedb.api.answer.concept_map import ConceptMap
-
-
-class _ConceptMapGroup(ConceptMapGroup, NativeWrapper[NativeConceptMapGroup]):
-
-    def __init__(self, concept_map_group: NativeConceptMapGroup):
-        if not concept_map_group:
-            raise TypeDBDriverException(NULL_NATIVE_OBJECT)
-        super().__init__(concept_map_group)
-
-    @property
-    def _native_object_not_owned_exception(self) -> TypeDBDriverException:
-        return TypeDBDriverException(ILLEGAL_STATE)
-
-    def owner(self) -> Concept:
-        return concept_factory.wrap_concept(concept_map_group_get_owner(self.native_object))
-
-    def concept_maps(self) -> Iterator[ConceptMap]:
-        return map(_ConceptMap, IteratorWrapper(concept_map_group_get_concept_maps(self.native_object),
-                                                concept_map_iterator_next))
-
-    def __repr__(self):
-        return concept_map_group_to_string(self.native_object)
-
-    def __eq__(self, other):
-        if other is self:
-            return True
-        if not other or type(other) != type(self):
-            return False
-        return concept_map_group_equals(self.native_object, other.native_object)
-
-    def __hash__(self):
-        return hash((self.owner(), tuple(self.concept_maps())))
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from typing import Iterator, TYPE_CHECKING
+
+from typedb.native_driver_wrapper import concept_map_group_get_owner, concept_map_group_get_concept_maps, \
+    concept_map_iterator_next, concept_map_group_to_string, concept_map_group_equals, \
+    ConceptMapGroup as NativeConceptMapGroup
+
+from typedb.api.answer.concept_map_group import ConceptMapGroup
+from typedb.common.exception import TypeDBDriverException, ILLEGAL_STATE, NULL_NATIVE_OBJECT
+from typedb.common.iterator_wrapper import IteratorWrapper
+from typedb.common.native_wrapper import NativeWrapper
+from typedb.concept import concept_factory
+from typedb.concept.answer.concept_map import _ConceptMap
+
+if TYPE_CHECKING:
+    from typedb.api.concept.concept import Concept
+    from typedb.api.answer.concept_map import ConceptMap
+
+
+class _ConceptMapGroup(ConceptMapGroup, NativeWrapper[NativeConceptMapGroup]):
+
+    def __init__(self, concept_map_group: NativeConceptMapGroup):
+        if not concept_map_group:
+            raise TypeDBDriverException(NULL_NATIVE_OBJECT)
+        super().__init__(concept_map_group)
+
+    @property
+    def _native_object_not_owned_exception(self) -> TypeDBDriverException:
+        return TypeDBDriverException(ILLEGAL_STATE)
+
+    def owner(self) -> Concept:
+        return concept_factory.wrap_concept(concept_map_group_get_owner(self.native_object))
+
+    def concept_maps(self) -> Iterator[ConceptMap]:
+        return map(_ConceptMap, IteratorWrapper(concept_map_group_get_concept_maps(self.native_object),
+                                                concept_map_iterator_next))
+
+    def __repr__(self):
+        return concept_map_group_to_string(self.native_object)
+
+    def __eq__(self, other):
+        if other is self:
+            return True
+        if not other or type(other) != type(self):
+            return False
+        return concept_map_group_equals(self.native_object, other.native_object)
+
+    def __hash__(self):
+        return hash((self.owner(), tuple(self.concept_maps())))
```

## typedb/concept/answer/value_group.py

 * *Ordering differences only*

```diff
@@ -1,64 +1,64 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from typing import TYPE_CHECKING, Optional
-
-from typedb.native_driver_wrapper import value_group_get_owner, value_group_get_value, \
-    value_group_to_string, value_group_equals, ValueGroup as NativeValueGroup
-
-from typedb.api.answer.value_group import ValueGroup
-from typedb.common.exception import TypeDBDriverException, NULL_NATIVE_OBJECT, ILLEGAL_STATE
-from typedb.common.native_wrapper import NativeWrapper
-from typedb.concept import concept_factory
-from typedb.concept.value.value import _Value
-
-if TYPE_CHECKING:
-    from typedb.api.concept.concept import Concept
-    from typedb.api.concept.value.value import Value
-
-
-class _ValueGroup(ValueGroup, NativeWrapper[NativeValueGroup]):
-
-    def __init__(self, value_group: NativeValueGroup):
-        if not value_group:
-            raise TypeDBDriverException(NULL_NATIVE_OBJECT)
-        super().__init__(value_group)
-
-    @property
-    def _native_object_not_owned_exception(self) -> TypeDBDriverException:
-        return TypeDBDriverException(ILLEGAL_STATE)
-
-    def owner(self) -> Concept:
-        return concept_factory.wrap_concept(value_group_get_owner(self.native_object))
-
-    def value(self) -> Optional[Value]:
-        if native_value := value_group_get_value(self.native_object):
-            return _Value(native_value)
-        else:
-            return None
-
-    def __repr__(self):
-        return value_group_to_string(self.native_object)
-
-    def __eq__(self, other):
-        return other and isinstance(other, ValueGroup) and \
-            value_group_equals(self.native_object, self.native_object)
-
-    def __hash__(self):
-        return hash((self.owner(), self.value()))
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from typing import TYPE_CHECKING, Optional
+
+from typedb.native_driver_wrapper import value_group_get_owner, value_group_get_value, \
+    value_group_to_string, value_group_equals, ValueGroup as NativeValueGroup
+
+from typedb.api.answer.value_group import ValueGroup
+from typedb.common.exception import TypeDBDriverException, NULL_NATIVE_OBJECT, ILLEGAL_STATE
+from typedb.common.native_wrapper import NativeWrapper
+from typedb.concept import concept_factory
+from typedb.concept.value.value import _Value
+
+if TYPE_CHECKING:
+    from typedb.api.concept.concept import Concept
+    from typedb.api.concept.value.value import Value
+
+
+class _ValueGroup(ValueGroup, NativeWrapper[NativeValueGroup]):
+
+    def __init__(self, value_group: NativeValueGroup):
+        if not value_group:
+            raise TypeDBDriverException(NULL_NATIVE_OBJECT)
+        super().__init__(value_group)
+
+    @property
+    def _native_object_not_owned_exception(self) -> TypeDBDriverException:
+        return TypeDBDriverException(ILLEGAL_STATE)
+
+    def owner(self) -> Concept:
+        return concept_factory.wrap_concept(value_group_get_owner(self.native_object))
+
+    def value(self) -> Optional[Value]:
+        if native_value := value_group_get_value(self.native_object):
+            return _Value(native_value)
+        else:
+            return None
+
+    def __repr__(self):
+        return value_group_to_string(self.native_object)
+
+    def __eq__(self, other):
+        return other and isinstance(other, ValueGroup) and \
+            value_group_equals(self.native_object, self.native_object)
+
+    def __hash__(self):
+        return hash((self.owner(), self.value()))
```

## typedb/concept/thing/attribute.py

 * *Ordering differences only*

```diff
@@ -1,94 +1,94 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from typing import Any, Iterator, Mapping, Optional, TYPE_CHECKING, Union
-
-from typedb.native_driver_wrapper import attribute_get_type, attribute_get_value, attribute_get_owners, \
-    concept_iterator_next, TypeDBDriverExceptionNative
-
-from typedb.api.concept.thing.attribute import Attribute
-from typedb.api.concept.value.value import ValueType
-from typedb.common.exception import TypeDBDriverException
-from typedb.common.iterator_wrapper import IteratorWrapper
-from typedb.concept.concept_factory import wrap_attribute_type, wrap_thing, wrap_value
-from typedb.concept.thing.thing import _Thing
-from typedb.concept.type.attribute_type import _AttributeType
-from typedb.concept.value.value import _Value
-
-if TYPE_CHECKING:
-    from datetime import datetime
-    from typedb.concept.type.thing_type import _ThingType
-    from typedb.connection.transaction import _Transaction
-
-
-class _Attribute(Attribute, _Thing):
-
-    def _value(self) -> _Value:
-        return wrap_value(attribute_get_value(self.native_object))
-
-    def get_type(self) -> _AttributeType:
-        return wrap_attribute_type(attribute_get_type(self.native_object))
-
-    def get_value(self) -> Union[bool, int, float, str, datetime]:
-        return wrap_value(attribute_get_value(self.native_object)).get()
-
-    def get_value_type(self) -> ValueType:
-        return self._value().get_value_type()
-
-    def is_boolean(self) -> bool:
-        return self._value().is_boolean()
-
-    def is_long(self) -> bool:
-        return self._value().is_long()
-
-    def is_double(self) -> bool:
-        return self._value().is_double()
-
-    def is_string(self) -> bool:
-        return self._value().is_string()
-
-    def is_datetime(self) -> bool:
-        return self._value().is_datetime()
-
-    def as_boolean(self) -> bool:
-        return self._value().as_boolean()
-
-    def as_long(self) -> int:
-        return self._value().as_long()
-
-    def as_double(self) -> float:
-        return self._value().as_double()
-
-    def as_string(self) -> str:
-        return self._value().as_string()
-
-    def as_datetime(self) -> datetime:
-        return self._value().as_datetime()
-
-    def to_json(self) -> Mapping[str, Union[str, int, float, bool]]:
-        return {"type": self.get_type().get_label().scoped_name()} | self._value().to_json()
-
-    def get_owners(self, transaction: _Transaction, owner_type: Optional[_ThingType] = None) -> Iterator[Any]:
-        try:
-            return map(wrap_thing,
-                       IteratorWrapper(attribute_get_owners(transaction.native_object, self.native_object,
-                                                            owner_type.native_object if owner_type else None),
-                                       concept_iterator_next))
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from typing import Any, Iterator, Mapping, Optional, TYPE_CHECKING, Union
+
+from typedb.native_driver_wrapper import attribute_get_type, attribute_get_value, attribute_get_owners, \
+    concept_iterator_next, TypeDBDriverExceptionNative
+
+from typedb.api.concept.thing.attribute import Attribute
+from typedb.api.concept.value.value import ValueType
+from typedb.common.exception import TypeDBDriverException
+from typedb.common.iterator_wrapper import IteratorWrapper
+from typedb.concept.concept_factory import wrap_attribute_type, wrap_thing, wrap_value
+from typedb.concept.thing.thing import _Thing
+from typedb.concept.type.attribute_type import _AttributeType
+from typedb.concept.value.value import _Value
+
+if TYPE_CHECKING:
+    from datetime import datetime
+    from typedb.concept.type.thing_type import _ThingType
+    from typedb.connection.transaction import _Transaction
+
+
+class _Attribute(Attribute, _Thing):
+
+    def _value(self) -> _Value:
+        return wrap_value(attribute_get_value(self.native_object))
+
+    def get_type(self) -> _AttributeType:
+        return wrap_attribute_type(attribute_get_type(self.native_object))
+
+    def get_value(self) -> Union[bool, int, float, str, datetime]:
+        return wrap_value(attribute_get_value(self.native_object)).get()
+
+    def get_value_type(self) -> ValueType:
+        return self._value().get_value_type()
+
+    def is_boolean(self) -> bool:
+        return self._value().is_boolean()
+
+    def is_long(self) -> bool:
+        return self._value().is_long()
+
+    def is_double(self) -> bool:
+        return self._value().is_double()
+
+    def is_string(self) -> bool:
+        return self._value().is_string()
+
+    def is_datetime(self) -> bool:
+        return self._value().is_datetime()
+
+    def as_boolean(self) -> bool:
+        return self._value().as_boolean()
+
+    def as_long(self) -> int:
+        return self._value().as_long()
+
+    def as_double(self) -> float:
+        return self._value().as_double()
+
+    def as_string(self) -> str:
+        return self._value().as_string()
+
+    def as_datetime(self) -> datetime:
+        return self._value().as_datetime()
+
+    def to_json(self) -> Mapping[str, Union[str, int, float, bool]]:
+        return {"type": self.get_type().get_label().scoped_name()} | self._value().to_json()
+
+    def get_owners(self, transaction: _Transaction, owner_type: Optional[_ThingType] = None) -> Iterator[Any]:
+        try:
+            return map(wrap_thing,
+                       IteratorWrapper(attribute_get_owners(transaction.native_object, self.native_object,
+                                                            owner_type.native_object if owner_type else None),
+                                       concept_iterator_next))
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
```

## typedb/concept/thing/entity.py

 * *Ordering differences only*

```diff
@@ -1,35 +1,35 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from typing import TYPE_CHECKING
-
-from typedb.native_driver_wrapper import entity_get_type
-
-from typedb.api.concept.thing.entity import Entity
-from typedb.concept.concept_factory import wrap_entity_type
-from typedb.concept.thing.thing import _Thing
-
-if TYPE_CHECKING:
-    from typedb.concept.type.entity_type import _EntityType
-
-
-class _Entity(Entity, _Thing):
-
-    def get_type(self) -> _EntityType:
-        return wrap_entity_type(entity_get_type(self.native_object))
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+from typedb.native_driver_wrapper import entity_get_type
+
+from typedb.api.concept.thing.entity import Entity
+from typedb.concept.concept_factory import wrap_entity_type
+from typedb.concept.thing.thing import _Thing
+
+if TYPE_CHECKING:
+    from typedb.concept.type.entity_type import _EntityType
+
+
+class _Entity(Entity, _Thing):
+
+    def get_type(self) -> _EntityType:
+        return wrap_entity_type(entity_get_type(self.native_object))
```

## typedb/concept/thing/relation.py

 * *Ordering differences only*

```diff
@@ -1,91 +1,91 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from typing import Iterator, Any, TYPE_CHECKING
-
-from typedb.native_driver_wrapper import (
-    TypeDBDriverExceptionNative, concept_iterator_next, relation_add_role_player, relation_get_players_by_role_type,
-    relation_get_relating, relation_get_role_players, relation_get_type, relation_remove_role_player, role_player_get_player,
-    role_player_get_role_type, role_player_iterator_next,
-)
-
-from typedb.api.concept.thing.relation import Relation
-from typedb.common.exception import TypeDBDriverException
-from typedb.common.iterator_wrapper import IteratorWrapper
-from typedb.common.promise import Promise
-from typedb.concept.concept_factory import wrap_relation_type, wrap_role_type, wrap_thing
-from typedb.concept.thing.thing import _Thing
-from typedb.concept.type.role_type import _RoleType
-from typedb.native_driver_wrapper import void_promise_resolve
-
-if TYPE_CHECKING:
-    from typedb.concept.type.relation_type import _RelationType
-    from typedb.connection.transaction import _Transaction
-
-
-class _Relation(Relation, _Thing):
-    def get_type(self) -> _RelationType:
-        return wrap_relation_type(relation_get_type(self.native_object))
-
-    def add_player(self, transaction: _Transaction, role_type: _RoleType, player: _Thing) -> Promise[None]:
-        promise = relation_add_role_player(
-            transaction.native_object, self.native_object, role_type.native_object, player.native_object
-        )
-        return Promise(lambda: void_promise_resolve(promise))
-
-    def remove_player(self, transaction: _Transaction, role_type: _RoleType, player: _Thing) -> Promise[None]:
-        promise = relation_remove_role_player(
-            transaction.native_object, self.native_object, role_type.native_object, player.native_object
-        )
-        return Promise(lambda: void_promise_resolve(promise))
-
-    def get_players_by_role_type(self, transaction: _Transaction, *role_types: _RoleType) -> Iterator[Any]:
-        try:
-            native_role_types = [rt.native_object for rt in role_types]
-            return map(
-                wrap_thing,
-                IteratorWrapper(
-                    relation_get_players_by_role_type(transaction.native_object, self.native_object, native_role_types),
-                    concept_iterator_next
-                )
-            )
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
-
-    def get_players(self, transaction: _Transaction) -> dict[_RoleType, list[_Thing]]:
-        try:
-            role_players = {}
-            for role_player in IteratorWrapper(relation_get_role_players(transaction.native_object, self.native_object),
-                                               role_player_iterator_next):
-                role = wrap_role_type(role_player_get_role_type(role_player))
-                player = wrap_thing(role_player_get_player(role_player))
-                role_players.setdefault(role, [])
-                role_players[role].append(player)
-            return role_players
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
-
-    def get_relating(self, transaction: _Transaction) -> Iterator[_RoleType]:
-        try:
-            return map(
-                wrap_role_type,
-                IteratorWrapper(relation_get_relating(transaction.native_object, self.native_object), concept_iterator_next)
-            )
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from typing import Iterator, Any, TYPE_CHECKING
+
+from typedb.native_driver_wrapper import (
+    TypeDBDriverExceptionNative, concept_iterator_next, relation_add_role_player, relation_get_players_by_role_type,
+    relation_get_relating, relation_get_role_players, relation_get_type, relation_remove_role_player, role_player_get_player,
+    role_player_get_role_type, role_player_iterator_next,
+)
+
+from typedb.api.concept.thing.relation import Relation
+from typedb.common.exception import TypeDBDriverException
+from typedb.common.iterator_wrapper import IteratorWrapper
+from typedb.common.promise import Promise
+from typedb.concept.concept_factory import wrap_relation_type, wrap_role_type, wrap_thing
+from typedb.concept.thing.thing import _Thing
+from typedb.concept.type.role_type import _RoleType
+from typedb.native_driver_wrapper import void_promise_resolve
+
+if TYPE_CHECKING:
+    from typedb.concept.type.relation_type import _RelationType
+    from typedb.connection.transaction import _Transaction
+
+
+class _Relation(Relation, _Thing):
+    def get_type(self) -> _RelationType:
+        return wrap_relation_type(relation_get_type(self.native_object))
+
+    def add_player(self, transaction: _Transaction, role_type: _RoleType, player: _Thing) -> Promise[None]:
+        promise = relation_add_role_player(
+            transaction.native_object, self.native_object, role_type.native_object, player.native_object
+        )
+        return Promise(lambda: void_promise_resolve(promise))
+
+    def remove_player(self, transaction: _Transaction, role_type: _RoleType, player: _Thing) -> Promise[None]:
+        promise = relation_remove_role_player(
+            transaction.native_object, self.native_object, role_type.native_object, player.native_object
+        )
+        return Promise(lambda: void_promise_resolve(promise))
+
+    def get_players_by_role_type(self, transaction: _Transaction, *role_types: _RoleType) -> Iterator[Any]:
+        try:
+            native_role_types = [rt.native_object for rt in role_types]
+            return map(
+                wrap_thing,
+                IteratorWrapper(
+                    relation_get_players_by_role_type(transaction.native_object, self.native_object, native_role_types),
+                    concept_iterator_next
+                )
+            )
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
+
+    def get_players(self, transaction: _Transaction) -> dict[_RoleType, list[_Thing]]:
+        try:
+            role_players = {}
+            for role_player in IteratorWrapper(relation_get_role_players(transaction.native_object, self.native_object),
+                                               role_player_iterator_next):
+                role = wrap_role_type(role_player_get_role_type(role_player))
+                player = wrap_thing(role_player_get_player(role_player))
+                role_players.setdefault(role, [])
+                role_players[role].append(player)
+            return role_players
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
+
+    def get_relating(self, transaction: _Transaction) -> Iterator[_RoleType]:
+        try:
+            return map(
+                wrap_role_type,
+                IteratorWrapper(relation_get_relating(transaction.native_object, self.native_object), concept_iterator_next)
+            )
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
```

## typedb/concept/thing/thing.py

 * *Ordering differences only*

```diff
@@ -1,125 +1,125 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from abc import ABC
-from typing import TYPE_CHECKING, Iterator, Optional
-
-from typedb.native_driver_wrapper import (
-    TypeDBDriverExceptionNative, bool_promise_resolve, concept_iterator_next, thing_delete, thing_get_has, thing_get_iid,
-    thing_get_is_inferred, thing_get_playing, thing_get_relations, thing_is_deleted, thing_set_has, thing_unset_has,
-    void_promise_resolve,
-)
-
-from typedb.api.concept.thing.thing import Thing
-from typedb.common.exception import TypeDBDriverException, GET_HAS_WITH_MULTIPLE_FILTERS
-from typedb.common.iterator_wrapper import IteratorWrapper
-from typedb.common.promise import Promise
-from typedb.concept.concept import _Concept
-from typedb.concept.concept_factory import wrap_attribute, wrap_relation, wrap_role_type
-
-if TYPE_CHECKING:
-    from typedb.api.concept.type.annotation import Annotation
-    from typedb.concept.thing.attribute import _Attribute
-    from typedb.concept.thing.relation import _Relation
-    from typedb.concept.type.role_type import _RoleType
-    from typedb.concept.type.attribute_type import _AttributeType
-    from typedb.connection.transaction import _Transaction
-
-
-class _Thing(Thing, _Concept, ABC):
-    def get_iid(self) -> str:
-        return thing_get_iid(self.native_object)
-
-    def is_inferred(self) -> bool:
-        return thing_get_is_inferred(self.native_object)
-
-    def get_has(
-        self,
-        transaction: _Transaction,
-        *,
-        attribute_type: Optional[_AttributeType] = None,
-        attribute_types: list[_AttributeType] = (),
-        annotations: set[Annotation] = frozenset(),
-    ) -> Iterator[_Attribute]:
-        if [bool(attribute_type), bool(attribute_types), bool(annotations)].count(True) > 1:
-            raise TypeDBDriverException(GET_HAS_WITH_MULTIPLE_FILTERS)
-        if attribute_type:
-            attribute_types = [attribute_type]
-        native_attribute_types = [type_.native_object for type_ in attribute_types]
-        native_annotations = [anno.native_object for anno in annotations]
-        try:
-            return map(
-                wrap_attribute,
-                IteratorWrapper(
-                    thing_get_has(transaction.native_object, self.native_object, native_attribute_types, native_annotations),
-                    concept_iterator_next
-                )
-            )
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
-
-    def get_relations(self, transaction: _Transaction, *role_types: _RoleType) -> Iterator[_Relation]:
-        try:
-            native_role_types = [rt.native_object for rt in role_types]
-            return map(
-                wrap_relation,
-                IteratorWrapper(
-                    thing_get_relations(transaction.native_object, self.native_object, native_role_types), concept_iterator_next
-                ),
-            )
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
-
-    def get_playing(self, transaction: _Transaction) -> Iterator[_RoleType]:
-        try:
-            return map(
-                wrap_role_type,
-                IteratorWrapper(thing_get_playing(transaction.native_object, self.native_object), concept_iterator_next),
-            )
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
-
-    def set_has(self, transaction: _Transaction, attribute: _Attribute) -> Promise[None]:
-        promise = thing_set_has(transaction.native_object, self.native_object, attribute.native_object)
-        return Promise(lambda: void_promise_resolve(promise))
-
-    def unset_has(self, transaction: _Transaction, attribute: _Attribute) -> Promise[None]:
-        promise = thing_unset_has(transaction.native_object, self.native_object, attribute.native_object)
-        return Promise(lambda: void_promise_resolve(promise))
-
-    def delete(self, transaction: _Transaction) -> Promise[None]:
-        promise = thing_delete(transaction.native_object, self.native_object)
-        return Promise(lambda: void_promise_resolve(promise))
-
-    def is_deleted(self, transaction: _Transaction) -> Promise[bool]:
-        promise = thing_is_deleted(transaction.native_object, self.native_object)
-        return Promise(lambda: bool_promise_resolve(promise))
-
-    def __repr__(self):
-        return "%s[%s:%s]" % (type(self).__name__, self.get_type().get_label(), self.get_iid())
-
-    def __eq__(self, other):
-        if other is self:
-            return True
-        if not other or type(self) is not type(other):
-            return False
-        return self.get_iid() == other.get_iid()
-
-    def __hash__(self):
-        return hash(self.get_iid())
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from abc import ABC
+from typing import TYPE_CHECKING, Iterator, Optional
+
+from typedb.native_driver_wrapper import (
+    TypeDBDriverExceptionNative, bool_promise_resolve, concept_iterator_next, thing_delete, thing_get_has, thing_get_iid,
+    thing_get_is_inferred, thing_get_playing, thing_get_relations, thing_is_deleted, thing_set_has, thing_unset_has,
+    void_promise_resolve,
+)
+
+from typedb.api.concept.thing.thing import Thing
+from typedb.common.exception import TypeDBDriverException, GET_HAS_WITH_MULTIPLE_FILTERS
+from typedb.common.iterator_wrapper import IteratorWrapper
+from typedb.common.promise import Promise
+from typedb.concept.concept import _Concept
+from typedb.concept.concept_factory import wrap_attribute, wrap_relation, wrap_role_type
+
+if TYPE_CHECKING:
+    from typedb.api.concept.type.annotation import Annotation
+    from typedb.concept.thing.attribute import _Attribute
+    from typedb.concept.thing.relation import _Relation
+    from typedb.concept.type.role_type import _RoleType
+    from typedb.concept.type.attribute_type import _AttributeType
+    from typedb.connection.transaction import _Transaction
+
+
+class _Thing(Thing, _Concept, ABC):
+    def get_iid(self) -> str:
+        return thing_get_iid(self.native_object)
+
+    def is_inferred(self) -> bool:
+        return thing_get_is_inferred(self.native_object)
+
+    def get_has(
+        self,
+        transaction: _Transaction,
+        *,
+        attribute_type: Optional[_AttributeType] = None,
+        attribute_types: list[_AttributeType] = (),
+        annotations: set[Annotation] = frozenset(),
+    ) -> Iterator[_Attribute]:
+        if [bool(attribute_type), bool(attribute_types), bool(annotations)].count(True) > 1:
+            raise TypeDBDriverException(GET_HAS_WITH_MULTIPLE_FILTERS)
+        if attribute_type:
+            attribute_types = [attribute_type]
+        native_attribute_types = [type_.native_object for type_ in attribute_types]
+        native_annotations = [anno.native_object for anno in annotations]
+        try:
+            return map(
+                wrap_attribute,
+                IteratorWrapper(
+                    thing_get_has(transaction.native_object, self.native_object, native_attribute_types, native_annotations),
+                    concept_iterator_next
+                )
+            )
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
+
+    def get_relations(self, transaction: _Transaction, *role_types: _RoleType) -> Iterator[_Relation]:
+        try:
+            native_role_types = [rt.native_object for rt in role_types]
+            return map(
+                wrap_relation,
+                IteratorWrapper(
+                    thing_get_relations(transaction.native_object, self.native_object, native_role_types), concept_iterator_next
+                ),
+            )
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
+
+    def get_playing(self, transaction: _Transaction) -> Iterator[_RoleType]:
+        try:
+            return map(
+                wrap_role_type,
+                IteratorWrapper(thing_get_playing(transaction.native_object, self.native_object), concept_iterator_next),
+            )
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
+
+    def set_has(self, transaction: _Transaction, attribute: _Attribute) -> Promise[None]:
+        promise = thing_set_has(transaction.native_object, self.native_object, attribute.native_object)
+        return Promise(lambda: void_promise_resolve(promise))
+
+    def unset_has(self, transaction: _Transaction, attribute: _Attribute) -> Promise[None]:
+        promise = thing_unset_has(transaction.native_object, self.native_object, attribute.native_object)
+        return Promise(lambda: void_promise_resolve(promise))
+
+    def delete(self, transaction: _Transaction) -> Promise[None]:
+        promise = thing_delete(transaction.native_object, self.native_object)
+        return Promise(lambda: void_promise_resolve(promise))
+
+    def is_deleted(self, transaction: _Transaction) -> Promise[bool]:
+        promise = thing_is_deleted(transaction.native_object, self.native_object)
+        return Promise(lambda: bool_promise_resolve(promise))
+
+    def __repr__(self):
+        return "%s[%s:%s]" % (type(self).__name__, self.get_type().get_label(), self.get_iid())
+
+    def __eq__(self, other):
+        if other is self:
+            return True
+        if not other or type(self) is not type(other):
+            return False
+        return self.get_iid() == other.get_iid()
+
+    def __hash__(self):
+        return hash(self.get_iid())
```

## typedb/concept/type/attribute_type.py

 * *Ordering differences only*

```diff
@@ -1,173 +1,173 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from datetime import datetime
-from typing import Optional, Iterator, TYPE_CHECKING, Union, Any
-
-from typedb.native_driver_wrapper import (
-    TypeDBDriverExceptionNative, attribute_type_get, attribute_type_get_instances, attribute_type_get_owners,
-    attribute_type_get_regex, attribute_type_get_subtypes, attribute_type_get_subtypes_with_value_type,
-    attribute_type_get_supertype, attribute_type_get_supertypes, attribute_type_get_value_type, attribute_type_put,
-    attribute_type_set_regex, attribute_type_set_supertype, attribute_type_unset_regex, concept_iterator_next,
-    concept_promise_resolve, string_promise_resolve, void_promise_resolve,
-)
-
-from typedb.api.concept.type.attribute_type import AttributeType
-from typedb.api.concept.value.value import ValueType
-from typedb.common.exception import TypeDBDriverException
-from typedb.common.iterator_wrapper import IteratorWrapper
-from typedb.common.promise import Promise
-from typedb.common.transitivity import Transitivity
-from typedb.concept.concept_factory import wrap_attribute, wrap_thing_type
-from typedb.concept.type.thing_type import _ThingType
-from typedb.concept.value.value import _Value
-
-if TYPE_CHECKING:
-    from typedb.api.concept.type.annotation import Annotation
-    from typedb.api.concept.value.value import Value
-    from typedb.concept.thing.attribute import _Attribute
-    from typedb.connection.transaction import _Transaction
-
-
-class _AttributeType(AttributeType, _ThingType):
-    def get_value_type(self) -> ValueType:
-        return ValueType.of(attribute_type_get_value_type(self.native_object))
-
-    def __eq__(self, other):
-        if other is self:
-            return True
-        # root "attribute" should always be equal to itself regardless of which value class it holds
-        if not other or not isinstance(other, _AttributeType):
-            return False
-        return self.get_label() == other.get_label()
-
-    def __hash__(self):
-        return super(_AttributeType, self).__hash__()
-
-    def set_supertype(self, transaction: _Transaction, super_attribute_type: _AttributeType) -> Promise[None]:
-        promise = attribute_type_set_supertype(transaction.native_object, self.native_object, super_attribute_type.native_object)
-        return Promise(lambda: void_promise_resolve(promise))
-
-    def get_supertype(self, transaction: _Transaction) -> Promise[Optional[_AttributeType]]:
-        promise = attribute_type_get_supertype(transaction.native_object, self.native_object)
-        return Promise.map(_AttributeType, lambda: concept_promise_resolve(promise))
-
-    def get_supertypes(self, transaction: _Transaction) -> Iterator[_AttributeType]:
-        try:
-            return map(
-                _AttributeType,
-                IteratorWrapper(
-                    attribute_type_get_supertypes(transaction.native_object, self.native_object), concept_iterator_next
-                )
-            )
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
-
-    def get_subtypes(
-        self,
-        transaction: _Transaction,
-        transitivity: Transitivity = Transitivity.TRANSITIVE,
-    ) -> Iterator[_AttributeType]:
-        try:
-            return map(
-                _AttributeType,
-                IteratorWrapper(
-                    attribute_type_get_subtypes(transaction.native_object, self.native_object, transitivity.value),
-                    concept_iterator_next
-                )
-            )
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
-
-    def get_subtypes_with_value_type(
-        self,
-        transaction: _Transaction,
-        value_type: ValueType,
-        transitivity: Transitivity = Transitivity.TRANSITIVE
-    ) -> Iterator[_AttributeType]:
-        try:
-            return map(
-                _AttributeType,
-                IteratorWrapper(
-                    attribute_type_get_subtypes_with_value_type(
-                        transaction.native_object, self.native_object, value_type.native_object, transitivity.value
-                    ), concept_iterator_next
-                )
-            )
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
-
-    def get_instances(
-        self,
-        transaction: _Transaction,
-        transitivity: Transitivity = Transitivity.TRANSITIVE,
-    ) -> Iterator[_Attribute]:
-        try:
-            return map(
-                wrap_attribute,
-                IteratorWrapper(
-                    attribute_type_get_instances(transaction.native_object, self.native_object, transitivity.value),
-                    concept_iterator_next
-                )
-            )
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
-
-    def get_owners(
-        self,
-        transaction: _Transaction,
-        annotations: Optional[set[Annotation]] = None,
-        transitivity: Transitivity = Transitivity.TRANSITIVE,
-    ) -> Iterator[Any]:
-        try:
-            annotations_array = [anno.native_object for anno in annotations] if annotations else []
-            return map(
-                wrap_thing_type,
-                IteratorWrapper(
-                    attribute_type_get_owners(
-                        transaction.native_object, self.native_object, transitivity.value, annotations_array
-                    ), concept_iterator_next
-                )
-            )
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
-
-    def put(self, transaction: _Transaction, value: Union[Value, bool, int, float, str, datetime]) -> Promise[_Attribute]:
-        promise = attribute_type_put(transaction.native_object, self.native_object, _Value.of(value).native_object)
-        return Promise.map(wrap_attribute, lambda: concept_promise_resolve(promise))
-
-    def get(
-        self,
-        transaction: _Transaction,
-        value: Union[Value, bool, int, float, str, datetime],
-    ) -> Promise[Optional[_Attribute]]:
-        promise = attribute_type_get(transaction.native_object, self.native_object, _Value.of(value).native_object)
-        return Promise.map(wrap_attribute, lambda: concept_promise_resolve(promise))
-
-    def get_regex(self, transaction: _Transaction) -> Promise[str]:
-        promise = attribute_type_get_regex(transaction.native_object, self.native_object)
-        return Promise(lambda: string_promise_resolve(promise))
-
-    def set_regex(self, transaction: _Transaction, regex: str) -> Promise[None]:
-        promise = attribute_type_set_regex(transaction.native_object, self.native_object, regex)
-        return Promise(lambda: void_promise_resolve(promise))
-
-    def unset_regex(self, transaction: _Transaction) -> Promise[None]:
-        promise = attribute_type_unset_regex(transaction.native_object, self.native_object)
-        return Promise(lambda: void_promise_resolve(promise))
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from datetime import datetime
+from typing import Optional, Iterator, TYPE_CHECKING, Union, Any
+
+from typedb.native_driver_wrapper import (
+    TypeDBDriverExceptionNative, attribute_type_get, attribute_type_get_instances, attribute_type_get_owners,
+    attribute_type_get_regex, attribute_type_get_subtypes, attribute_type_get_subtypes_with_value_type,
+    attribute_type_get_supertype, attribute_type_get_supertypes, attribute_type_get_value_type, attribute_type_put,
+    attribute_type_set_regex, attribute_type_set_supertype, attribute_type_unset_regex, concept_iterator_next,
+    concept_promise_resolve, string_promise_resolve, void_promise_resolve,
+)
+
+from typedb.api.concept.type.attribute_type import AttributeType
+from typedb.api.concept.value.value import ValueType
+from typedb.common.exception import TypeDBDriverException
+from typedb.common.iterator_wrapper import IteratorWrapper
+from typedb.common.promise import Promise
+from typedb.common.transitivity import Transitivity
+from typedb.concept.concept_factory import wrap_attribute, wrap_thing_type
+from typedb.concept.type.thing_type import _ThingType
+from typedb.concept.value.value import _Value
+
+if TYPE_CHECKING:
+    from typedb.api.concept.type.annotation import Annotation
+    from typedb.api.concept.value.value import Value
+    from typedb.concept.thing.attribute import _Attribute
+    from typedb.connection.transaction import _Transaction
+
+
+class _AttributeType(AttributeType, _ThingType):
+    def get_value_type(self) -> ValueType:
+        return ValueType.of(attribute_type_get_value_type(self.native_object))
+
+    def __eq__(self, other):
+        if other is self:
+            return True
+        # root "attribute" should always be equal to itself regardless of which value class it holds
+        if not other or not isinstance(other, _AttributeType):
+            return False
+        return self.get_label() == other.get_label()
+
+    def __hash__(self):
+        return super(_AttributeType, self).__hash__()
+
+    def set_supertype(self, transaction: _Transaction, super_attribute_type: _AttributeType) -> Promise[None]:
+        promise = attribute_type_set_supertype(transaction.native_object, self.native_object, super_attribute_type.native_object)
+        return Promise(lambda: void_promise_resolve(promise))
+
+    def get_supertype(self, transaction: _Transaction) -> Promise[Optional[_AttributeType]]:
+        promise = attribute_type_get_supertype(transaction.native_object, self.native_object)
+        return Promise.map(_AttributeType, lambda: concept_promise_resolve(promise))
+
+    def get_supertypes(self, transaction: _Transaction) -> Iterator[_AttributeType]:
+        try:
+            return map(
+                _AttributeType,
+                IteratorWrapper(
+                    attribute_type_get_supertypes(transaction.native_object, self.native_object), concept_iterator_next
+                )
+            )
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
+
+    def get_subtypes(
+        self,
+        transaction: _Transaction,
+        transitivity: Transitivity = Transitivity.TRANSITIVE,
+    ) -> Iterator[_AttributeType]:
+        try:
+            return map(
+                _AttributeType,
+                IteratorWrapper(
+                    attribute_type_get_subtypes(transaction.native_object, self.native_object, transitivity.value),
+                    concept_iterator_next
+                )
+            )
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
+
+    def get_subtypes_with_value_type(
+        self,
+        transaction: _Transaction,
+        value_type: ValueType,
+        transitivity: Transitivity = Transitivity.TRANSITIVE
+    ) -> Iterator[_AttributeType]:
+        try:
+            return map(
+                _AttributeType,
+                IteratorWrapper(
+                    attribute_type_get_subtypes_with_value_type(
+                        transaction.native_object, self.native_object, value_type.native_object, transitivity.value
+                    ), concept_iterator_next
+                )
+            )
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
+
+    def get_instances(
+        self,
+        transaction: _Transaction,
+        transitivity: Transitivity = Transitivity.TRANSITIVE,
+    ) -> Iterator[_Attribute]:
+        try:
+            return map(
+                wrap_attribute,
+                IteratorWrapper(
+                    attribute_type_get_instances(transaction.native_object, self.native_object, transitivity.value),
+                    concept_iterator_next
+                )
+            )
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
+
+    def get_owners(
+        self,
+        transaction: _Transaction,
+        annotations: Optional[set[Annotation]] = None,
+        transitivity: Transitivity = Transitivity.TRANSITIVE,
+    ) -> Iterator[Any]:
+        try:
+            annotations_array = [anno.native_object for anno in annotations] if annotations else []
+            return map(
+                wrap_thing_type,
+                IteratorWrapper(
+                    attribute_type_get_owners(
+                        transaction.native_object, self.native_object, transitivity.value, annotations_array
+                    ), concept_iterator_next
+                )
+            )
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
+
+    def put(self, transaction: _Transaction, value: Union[Value, bool, int, float, str, datetime]) -> Promise[_Attribute]:
+        promise = attribute_type_put(transaction.native_object, self.native_object, _Value.of(value).native_object)
+        return Promise.map(wrap_attribute, lambda: concept_promise_resolve(promise))
+
+    def get(
+        self,
+        transaction: _Transaction,
+        value: Union[Value, bool, int, float, str, datetime],
+    ) -> Promise[Optional[_Attribute]]:
+        promise = attribute_type_get(transaction.native_object, self.native_object, _Value.of(value).native_object)
+        return Promise.map(wrap_attribute, lambda: concept_promise_resolve(promise))
+
+    def get_regex(self, transaction: _Transaction) -> Promise[str]:
+        promise = attribute_type_get_regex(transaction.native_object, self.native_object)
+        return Promise(lambda: string_promise_resolve(promise))
+
+    def set_regex(self, transaction: _Transaction, regex: str) -> Promise[None]:
+        promise = attribute_type_set_regex(transaction.native_object, self.native_object, regex)
+        return Promise(lambda: void_promise_resolve(promise))
+
+    def unset_regex(self, transaction: _Transaction) -> Promise[None]:
+        promise = attribute_type_unset_regex(transaction.native_object, self.native_object)
+        return Promise(lambda: void_promise_resolve(promise))
```

## typedb/concept/type/entity_type.py

 * *Ordering differences only*

```diff
@@ -1,87 +1,87 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from typing import Iterator, Optional, TYPE_CHECKING
-
-from typedb.native_driver_wrapper import (
-    TypeDBDriverExceptionNative, concept_iterator_next, concept_promise_resolve, entity_type_create, entity_type_get_instances,
-    entity_type_get_subtypes, entity_type_get_supertype, entity_type_get_supertypes, entity_type_set_supertype,
-    void_promise_resolve,
-)
-
-from typedb.api.concept.type.entity_type import EntityType
-from typedb.common.exception import TypeDBDriverException
-from typedb.common.iterator_wrapper import IteratorWrapper
-from typedb.common.promise import Promise
-from typedb.common.transitivity import Transitivity
-from typedb.concept.concept_factory import wrap_entity
-from typedb.concept.type.thing_type import _ThingType
-
-if TYPE_CHECKING:
-    from typedb.concept.thing.entity import _Entity
-    from typedb.connection.transaction import _Transaction
-
-
-class _EntityType(EntityType, _ThingType):
-    def create(self, transaction: _Transaction) -> Promise[_Entity]:
-        promise = entity_type_create(transaction.native_object, self.native_object)
-        return Promise.map(wrap_entity, lambda: concept_promise_resolve(promise))
-
-    def set_supertype(self, transaction: _Transaction, super_entity_type: _EntityType) -> Promise[None]:
-        promise = entity_type_set_supertype(transaction.native_object, self.native_object, super_entity_type.native_object)
-        return Promise(lambda: void_promise_resolve(promise))
-
-    def get_supertype(self, transaction: _Transaction) -> Promise[Optional[_EntityType]]:
-        promise = entity_type_get_supertype(transaction.native_object, self.native_object)
-        return Promise.map(_EntityType, lambda: concept_promise_resolve(promise))
-
-    def get_supertypes(self, transaction: _Transaction) -> Iterator[_EntityType]:
-        try:
-            return map(
-                _EntityType,
-                IteratorWrapper(entity_type_get_supertypes(transaction.native_object, self.native_object), concept_iterator_next)
-            )
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
-
-    def get_subtypes(self,
-                     transaction: _Transaction,
-                     transitivity: Transitivity = Transitivity.TRANSITIVE) -> Iterator[_EntityType]:
-        try:
-            return map(
-                _EntityType,
-                IteratorWrapper(
-                    entity_type_get_subtypes(transaction.native_object, self.native_object, transitivity.value),
-                    concept_iterator_next
-                )
-            )
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
-
-    def get_instances(self, transaction: _Transaction, transitivity: Transitivity = Transitivity.TRANSITIVE) -> Iterator[_Entity]:
-        try:
-            return map(
-                wrap_entity,
-                IteratorWrapper(
-                    entity_type_get_instances(transaction.native_object, self.native_object, transitivity.value),
-                    concept_iterator_next
-                )
-            )
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from typing import Iterator, Optional, TYPE_CHECKING
+
+from typedb.native_driver_wrapper import (
+    TypeDBDriverExceptionNative, concept_iterator_next, concept_promise_resolve, entity_type_create, entity_type_get_instances,
+    entity_type_get_subtypes, entity_type_get_supertype, entity_type_get_supertypes, entity_type_set_supertype,
+    void_promise_resolve,
+)
+
+from typedb.api.concept.type.entity_type import EntityType
+from typedb.common.exception import TypeDBDriverException
+from typedb.common.iterator_wrapper import IteratorWrapper
+from typedb.common.promise import Promise
+from typedb.common.transitivity import Transitivity
+from typedb.concept.concept_factory import wrap_entity
+from typedb.concept.type.thing_type import _ThingType
+
+if TYPE_CHECKING:
+    from typedb.concept.thing.entity import _Entity
+    from typedb.connection.transaction import _Transaction
+
+
+class _EntityType(EntityType, _ThingType):
+    def create(self, transaction: _Transaction) -> Promise[_Entity]:
+        promise = entity_type_create(transaction.native_object, self.native_object)
+        return Promise.map(wrap_entity, lambda: concept_promise_resolve(promise))
+
+    def set_supertype(self, transaction: _Transaction, super_entity_type: _EntityType) -> Promise[None]:
+        promise = entity_type_set_supertype(transaction.native_object, self.native_object, super_entity_type.native_object)
+        return Promise(lambda: void_promise_resolve(promise))
+
+    def get_supertype(self, transaction: _Transaction) -> Promise[Optional[_EntityType]]:
+        promise = entity_type_get_supertype(transaction.native_object, self.native_object)
+        return Promise.map(_EntityType, lambda: concept_promise_resolve(promise))
+
+    def get_supertypes(self, transaction: _Transaction) -> Iterator[_EntityType]:
+        try:
+            return map(
+                _EntityType,
+                IteratorWrapper(entity_type_get_supertypes(transaction.native_object, self.native_object), concept_iterator_next)
+            )
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
+
+    def get_subtypes(self,
+                     transaction: _Transaction,
+                     transitivity: Transitivity = Transitivity.TRANSITIVE) -> Iterator[_EntityType]:
+        try:
+            return map(
+                _EntityType,
+                IteratorWrapper(
+                    entity_type_get_subtypes(transaction.native_object, self.native_object, transitivity.value),
+                    concept_iterator_next
+                )
+            )
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
+
+    def get_instances(self, transaction: _Transaction, transitivity: Transitivity = Transitivity.TRANSITIVE) -> Iterator[_Entity]:
+        try:
+            return map(
+                wrap_entity,
+                IteratorWrapper(
+                    entity_type_get_instances(transaction.native_object, self.native_object, transitivity.value),
+                    concept_iterator_next
+                )
+            )
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
```

## typedb/concept/type/relation_type.py

 * *Ordering differences only*

```diff
@@ -1,130 +1,130 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from typing import Iterator, Optional, Union, TYPE_CHECKING
-
-from typedb.native_driver_wrapper import (
-    TypeDBDriverExceptionNative, concept_iterator_next, concept_promise_resolve, relation_type_create,
-    relation_type_get_instances, relation_type_get_relates, relation_type_get_relates_for_role_label,
-    relation_type_get_relates_overridden, relation_type_get_subtypes, relation_type_get_supertype, relation_type_get_supertypes,
-    relation_type_set_relates, relation_type_set_supertype, relation_type_unset_relates, void_promise_resolve
-)
-
-from typedb.api.concept.type.relation_type import RelationType
-from typedb.common.exception import TypeDBDriverException
-from typedb.common.iterator_wrapper import IteratorWrapper
-from typedb.common.promise import Promise
-from typedb.common.transitivity import Transitivity
-from typedb.concept.concept_factory import wrap_relation, wrap_role_type
-from typedb.concept.type.thing_type import _ThingType
-
-if TYPE_CHECKING:
-    from typedb.concept.thing.relation import _Relation
-    from typedb.concept.type.role_type import _RoleType
-    from typedb.connection.transaction import _Transaction
-
-
-class _RelationType(RelationType, _ThingType):
-    def create(self, transaction: _Transaction) -> Promise[_Relation]:
-        promise = relation_type_create(transaction.native_object, self.native_object)
-        return Promise.map(wrap_relation, lambda: concept_promise_resolve(promise))
-
-    def get_instances(
-        self,
-        transaction: _Transaction,
-        transitivity: Transitivity = Transitivity.TRANSITIVE,
-    ) -> Iterator[_Relation]:
-        try:
-            return map(
-                wrap_relation,
-                IteratorWrapper(
-                    relation_type_get_instances(transaction.native_object, self.native_object, transitivity.value),
-                    concept_iterator_next
-                )
-            )
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
-
-    def get_relates(
-        self,
-        transaction: _Transaction,
-        role_label: Optional[str] = None,
-        transitivity: Transitivity = Transitivity.TRANSITIVE,
-    ) -> Union[Promise[Optional[_RoleType]], Iterator[_RoleType]]:
-        if role_label:
-            promise = relation_type_get_relates_for_role_label(transaction.native_object, self.native_object, role_label)
-            return Promise.map(wrap_role_type, lambda: concept_promise_resolve(promise))
-        else:
-            try:
-                return map(
-                    wrap_role_type,
-                    IteratorWrapper(
-                        relation_type_get_relates(transaction.native_object, self.native_object, transitivity.value),
-                        concept_iterator_next
-                    )
-                )
-            except TypeDBDriverExceptionNative as e:
-                raise TypeDBDriverException.of(e)
-
-    def get_relates_overridden(self, transaction: _Transaction, role_label: str) -> Promise[Optional[_RoleType]]:
-        promise = relation_type_get_relates_overridden(transaction.native_object, self.native_object, role_label)
-        return Promise.map(wrap_role_type, lambda: concept_promise_resolve(promise))
-
-    def set_relates(self, transaction: _Transaction, role_label: str, overridden_label: Optional[str] = None) -> Promise[None]:
-        promise = relation_type_set_relates(transaction.native_object, self.native_object, role_label, overridden_label)
-        return Promise(lambda: void_promise_resolve(promise))
-
-    def unset_relates(self, transaction: _Transaction, role_label: str) -> Promise[None]:
-        promise = relation_type_unset_relates(transaction.native_object, self.native_object, role_label)
-        return Promise(lambda: void_promise_resolve(promise))
-
-    def get_subtypes(
-        self,
-        transaction: _Transaction,
-        transitivity: Transitivity = Transitivity.TRANSITIVE,
-    ) -> Iterator[_RelationType]:
-        try:
-            return map(
-                _RelationType,
-                IteratorWrapper(
-                    relation_type_get_subtypes(transaction.native_object, self.native_object, transitivity.value),
-                    concept_iterator_next
-                )
-            )
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
-
-    def get_supertype(self, transaction: _Transaction) -> Promise[Optional[_RelationType]]:
-        promise = relation_type_get_supertype(transaction.native_object, self.native_object)
-        return Promise.map(_RelationType, lambda: concept_promise_resolve(promise))
-
-    def get_supertypes(self, transaction: _Transaction) -> Iterator[_RelationType]:
-        try:
-            return map(
-                _RelationType,
-                IteratorWrapper(
-                    relation_type_get_supertypes(transaction.native_object, self.native_object), concept_iterator_next
-                )
-            )
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
-
-    def set_supertype(self, transaction: _Transaction, super_relation_type: _RelationType) -> Promise[None]:
-        promise = relation_type_set_supertype(transaction.native_object, self.native_object, super_relation_type.native_object)
-        return Promise(lambda: void_promise_resolve(promise))
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from typing import Iterator, Optional, Union, TYPE_CHECKING
+
+from typedb.native_driver_wrapper import (
+    TypeDBDriverExceptionNative, concept_iterator_next, concept_promise_resolve, relation_type_create,
+    relation_type_get_instances, relation_type_get_relates, relation_type_get_relates_for_role_label,
+    relation_type_get_relates_overridden, relation_type_get_subtypes, relation_type_get_supertype, relation_type_get_supertypes,
+    relation_type_set_relates, relation_type_set_supertype, relation_type_unset_relates, void_promise_resolve
+)
+
+from typedb.api.concept.type.relation_type import RelationType
+from typedb.common.exception import TypeDBDriverException
+from typedb.common.iterator_wrapper import IteratorWrapper
+from typedb.common.promise import Promise
+from typedb.common.transitivity import Transitivity
+from typedb.concept.concept_factory import wrap_relation, wrap_role_type
+from typedb.concept.type.thing_type import _ThingType
+
+if TYPE_CHECKING:
+    from typedb.concept.thing.relation import _Relation
+    from typedb.concept.type.role_type import _RoleType
+    from typedb.connection.transaction import _Transaction
+
+
+class _RelationType(RelationType, _ThingType):
+    def create(self, transaction: _Transaction) -> Promise[_Relation]:
+        promise = relation_type_create(transaction.native_object, self.native_object)
+        return Promise.map(wrap_relation, lambda: concept_promise_resolve(promise))
+
+    def get_instances(
+        self,
+        transaction: _Transaction,
+        transitivity: Transitivity = Transitivity.TRANSITIVE,
+    ) -> Iterator[_Relation]:
+        try:
+            return map(
+                wrap_relation,
+                IteratorWrapper(
+                    relation_type_get_instances(transaction.native_object, self.native_object, transitivity.value),
+                    concept_iterator_next
+                )
+            )
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
+
+    def get_relates(
+        self,
+        transaction: _Transaction,
+        role_label: Optional[str] = None,
+        transitivity: Transitivity = Transitivity.TRANSITIVE,
+    ) -> Union[Promise[Optional[_RoleType]], Iterator[_RoleType]]:
+        if role_label:
+            promise = relation_type_get_relates_for_role_label(transaction.native_object, self.native_object, role_label)
+            return Promise.map(wrap_role_type, lambda: concept_promise_resolve(promise))
+        else:
+            try:
+                return map(
+                    wrap_role_type,
+                    IteratorWrapper(
+                        relation_type_get_relates(transaction.native_object, self.native_object, transitivity.value),
+                        concept_iterator_next
+                    )
+                )
+            except TypeDBDriverExceptionNative as e:
+                raise TypeDBDriverException.of(e)
+
+    def get_relates_overridden(self, transaction: _Transaction, role_label: str) -> Promise[Optional[_RoleType]]:
+        promise = relation_type_get_relates_overridden(transaction.native_object, self.native_object, role_label)
+        return Promise.map(wrap_role_type, lambda: concept_promise_resolve(promise))
+
+    def set_relates(self, transaction: _Transaction, role_label: str, overridden_label: Optional[str] = None) -> Promise[None]:
+        promise = relation_type_set_relates(transaction.native_object, self.native_object, role_label, overridden_label)
+        return Promise(lambda: void_promise_resolve(promise))
+
+    def unset_relates(self, transaction: _Transaction, role_label: str) -> Promise[None]:
+        promise = relation_type_unset_relates(transaction.native_object, self.native_object, role_label)
+        return Promise(lambda: void_promise_resolve(promise))
+
+    def get_subtypes(
+        self,
+        transaction: _Transaction,
+        transitivity: Transitivity = Transitivity.TRANSITIVE,
+    ) -> Iterator[_RelationType]:
+        try:
+            return map(
+                _RelationType,
+                IteratorWrapper(
+                    relation_type_get_subtypes(transaction.native_object, self.native_object, transitivity.value),
+                    concept_iterator_next
+                )
+            )
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
+
+    def get_supertype(self, transaction: _Transaction) -> Promise[Optional[_RelationType]]:
+        promise = relation_type_get_supertype(transaction.native_object, self.native_object)
+        return Promise.map(_RelationType, lambda: concept_promise_resolve(promise))
+
+    def get_supertypes(self, transaction: _Transaction) -> Iterator[_RelationType]:
+        try:
+            return map(
+                _RelationType,
+                IteratorWrapper(
+                    relation_type_get_supertypes(transaction.native_object, self.native_object), concept_iterator_next
+                )
+            )
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
+
+    def set_supertype(self, transaction: _Transaction, super_relation_type: _RelationType) -> Promise[None]:
+        promise = relation_type_set_supertype(transaction.native_object, self.native_object, super_relation_type.native_object)
+        return Promise(lambda: void_promise_resolve(promise))
```

## typedb/concept/type/role_type.py

 * *Ordering differences only*

```diff
@@ -1,156 +1,156 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from typing import TYPE_CHECKING, Any, Iterator, Optional
-
-from typedb.api.concept.type.role_type import RoleType
-from typedb.common.exception import TypeDBDriverException
-from typedb.common.iterator_wrapper import IteratorWrapper
-from typedb.common.label import Label
-from typedb.common.promise import Promise
-from typedb.common.transitivity import Transitivity
-from typedb.concept.concept_factory import (wrap_relation, wrap_relation_type, wrap_thing, wrap_thing_type)
-from typedb.concept.type.type import _Type
-from typedb.native_driver_wrapper import (
-    TypeDBDriverExceptionNative, bool_promise_resolve, concept_iterator_next, concept_promise_resolve, role_type_delete,
-    role_type_get_name, role_type_get_player_instances, role_type_get_player_types, role_type_get_relation_instances,
-    role_type_get_relation_type, role_type_get_relation_types, role_type_get_scope, role_type_get_subtypes,
-    role_type_get_supertype, role_type_get_supertypes, role_type_is_abstract, role_type_is_deleted, role_type_is_root,
-    role_type_set_label, void_promise_resolve
-)
-
-if TYPE_CHECKING:
-    from typedb.concept.thing.relation import _Relation
-    from typedb.concept.thing.thing import _Thing
-    from typedb.concept.type.relation_type import _RelationType
-    from typedb.connection.transaction import _Transaction
-
-
-class _RoleType(_Type, RoleType):
-    def is_root(self) -> bool:
-        return role_type_is_root(self.native_object)
-
-    def is_abstract(self) -> bool:
-        return role_type_is_abstract(self.native_object)
-
-    def get_label(self) -> Label:
-        return Label.of(
-            role_type_get_scope(self.native_object),
-            role_type_get_name(self.native_object),
-        )
-
-    def delete(self, transaction: _Transaction) -> Promise[None]:
-        promise = role_type_delete(transaction.native_object, self.native_object)
-        return Promise(lambda: void_promise_resolve(promise))
-
-    def is_deleted(self, transaction: _Transaction) -> Promise[bool]:
-        promise = role_type_is_deleted(transaction.native_object, self.native_object)
-        return Promise(lambda: bool_promise_resolve(promise))
-
-    def set_label(self, transaction: _Transaction, new_label: Label) -> Promise[None]:
-        promise = role_type_set_label(transaction.native_object, self.native_object, new_label)
-        return Promise(lambda: void_promise_resolve(promise))
-
-    def get_supertype(self, transaction: _Transaction) -> Promise[Optional[_RoleType]]:
-        promise = role_type_get_supertype(transaction.native_object, self.native_object)
-        return Promise.map(_RoleType, lambda: concept_promise_resolve(promise))
-
-    def get_supertypes(self, transaction: _Transaction) -> Iterator[_RoleType]:
-        try:
-            return map(
-                _RoleType,
-                IteratorWrapper(role_type_get_supertypes(transaction.native_object, self.native_object), concept_iterator_next)
-            )
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
-
-    def get_subtypes(
-        self,
-        transaction: _Transaction,
-        transitivity: Transitivity = Transitivity.TRANSITIVE,
-    ) -> Iterator[_RoleType]:
-        try:
-            return map(
-                _RoleType,
-                IteratorWrapper(
-                    role_type_get_subtypes(transaction.native_object, self.native_object, transitivity.value),
-                    concept_iterator_next
-                )
-            )
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
-
-    def get_relation_type(self, transaction: _Transaction) -> Promise[_RelationType]:
-        promise = wrap_relation_type(role_type_get_relation_type(transaction.native_object, self.native_object))
-        return Promise.map(wrap_relation_type, lambda: concept_promise_resolve(promise))
-
-    def get_relation_types(self, transaction: _Transaction) -> Iterator[_RelationType]:
-        try:
-            return map(
-                wrap_relation_type,
-                IteratorWrapper(
-                    role_type_get_relation_types(transaction.native_object, self.native_object), concept_iterator_next
-                )
-            )
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
-
-    def get_player_types(self, transaction: _Transaction, transitivity: Transitivity = Transitivity.TRANSITIVE) -> Iterator[Any]:
-        try:
-            return map(
-                wrap_thing_type,
-                IteratorWrapper(
-                    role_type_get_player_types(transaction.native_object, self.native_object, transitivity.value),
-                    concept_iterator_next
-                )
-            )
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
-
-    def get_relation_instances(
-        self,
-        transaction: _Transaction,
-        transitivity: Transitivity = Transitivity.TRANSITIVE,
-    ) -> Iterator[_Relation]:
-        try:
-            return map(
-                wrap_relation,
-                IteratorWrapper(
-                    role_type_get_relation_instances(transaction.native_object, self.native_object, transitivity.value),
-                    concept_iterator_next
-                )
-            )
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
-
-    def get_player_instances(
-        self,
-        transaction: _Transaction,
-        transitivity: Transitivity = Transitivity.TRANSITIVE,
-    ) -> Iterator[_Thing]:
-        try:
-            return map(
-                wrap_thing,
-                IteratorWrapper(
-                    role_type_get_player_instances(transaction.native_object, self.native_object, transitivity.value),
-                    concept_iterator_next
-                )
-            )
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from typing import TYPE_CHECKING, Any, Iterator, Optional
+
+from typedb.api.concept.type.role_type import RoleType
+from typedb.common.exception import TypeDBDriverException
+from typedb.common.iterator_wrapper import IteratorWrapper
+from typedb.common.label import Label
+from typedb.common.promise import Promise
+from typedb.common.transitivity import Transitivity
+from typedb.concept.concept_factory import (wrap_relation, wrap_relation_type, wrap_thing, wrap_thing_type)
+from typedb.concept.type.type import _Type
+from typedb.native_driver_wrapper import (
+    TypeDBDriverExceptionNative, bool_promise_resolve, concept_iterator_next, concept_promise_resolve, role_type_delete,
+    role_type_get_name, role_type_get_player_instances, role_type_get_player_types, role_type_get_relation_instances,
+    role_type_get_relation_type, role_type_get_relation_types, role_type_get_scope, role_type_get_subtypes,
+    role_type_get_supertype, role_type_get_supertypes, role_type_is_abstract, role_type_is_deleted, role_type_is_root,
+    role_type_set_label, void_promise_resolve
+)
+
+if TYPE_CHECKING:
+    from typedb.concept.thing.relation import _Relation
+    from typedb.concept.thing.thing import _Thing
+    from typedb.concept.type.relation_type import _RelationType
+    from typedb.connection.transaction import _Transaction
+
+
+class _RoleType(_Type, RoleType):
+    def is_root(self) -> bool:
+        return role_type_is_root(self.native_object)
+
+    def is_abstract(self) -> bool:
+        return role_type_is_abstract(self.native_object)
+
+    def get_label(self) -> Label:
+        return Label.of(
+            role_type_get_scope(self.native_object),
+            role_type_get_name(self.native_object),
+        )
+
+    def delete(self, transaction: _Transaction) -> Promise[None]:
+        promise = role_type_delete(transaction.native_object, self.native_object)
+        return Promise(lambda: void_promise_resolve(promise))
+
+    def is_deleted(self, transaction: _Transaction) -> Promise[bool]:
+        promise = role_type_is_deleted(transaction.native_object, self.native_object)
+        return Promise(lambda: bool_promise_resolve(promise))
+
+    def set_label(self, transaction: _Transaction, new_label: Label) -> Promise[None]:
+        promise = role_type_set_label(transaction.native_object, self.native_object, new_label)
+        return Promise(lambda: void_promise_resolve(promise))
+
+    def get_supertype(self, transaction: _Transaction) -> Promise[Optional[_RoleType]]:
+        promise = role_type_get_supertype(transaction.native_object, self.native_object)
+        return Promise.map(_RoleType, lambda: concept_promise_resolve(promise))
+
+    def get_supertypes(self, transaction: _Transaction) -> Iterator[_RoleType]:
+        try:
+            return map(
+                _RoleType,
+                IteratorWrapper(role_type_get_supertypes(transaction.native_object, self.native_object), concept_iterator_next)
+            )
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
+
+    def get_subtypes(
+        self,
+        transaction: _Transaction,
+        transitivity: Transitivity = Transitivity.TRANSITIVE,
+    ) -> Iterator[_RoleType]:
+        try:
+            return map(
+                _RoleType,
+                IteratorWrapper(
+                    role_type_get_subtypes(transaction.native_object, self.native_object, transitivity.value),
+                    concept_iterator_next
+                )
+            )
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
+
+    def get_relation_type(self, transaction: _Transaction) -> Promise[_RelationType]:
+        promise = wrap_relation_type(role_type_get_relation_type(transaction.native_object, self.native_object))
+        return Promise.map(wrap_relation_type, lambda: concept_promise_resolve(promise))
+
+    def get_relation_types(self, transaction: _Transaction) -> Iterator[_RelationType]:
+        try:
+            return map(
+                wrap_relation_type,
+                IteratorWrapper(
+                    role_type_get_relation_types(transaction.native_object, self.native_object), concept_iterator_next
+                )
+            )
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
+
+    def get_player_types(self, transaction: _Transaction, transitivity: Transitivity = Transitivity.TRANSITIVE) -> Iterator[Any]:
+        try:
+            return map(
+                wrap_thing_type,
+                IteratorWrapper(
+                    role_type_get_player_types(transaction.native_object, self.native_object, transitivity.value),
+                    concept_iterator_next
+                )
+            )
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
+
+    def get_relation_instances(
+        self,
+        transaction: _Transaction,
+        transitivity: Transitivity = Transitivity.TRANSITIVE,
+    ) -> Iterator[_Relation]:
+        try:
+            return map(
+                wrap_relation,
+                IteratorWrapper(
+                    role_type_get_relation_instances(transaction.native_object, self.native_object, transitivity.value),
+                    concept_iterator_next
+                )
+            )
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
+
+    def get_player_instances(
+        self,
+        transaction: _Transaction,
+        transitivity: Transitivity = Transitivity.TRANSITIVE,
+    ) -> Iterator[_Thing]:
+        try:
+            return map(
+                wrap_thing,
+                IteratorWrapper(
+                    role_type_get_player_instances(transaction.native_object, self.native_object, transitivity.value),
+                    concept_iterator_next
+                )
+            )
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
```

## typedb/concept/type/thing_type.py

 * *Ordering differences only*

```diff
@@ -1,218 +1,218 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from abc import abstractmethod, ABC
-from itertools import chain
-from typing import Optional, Iterator, TYPE_CHECKING, Any
-
-from typedb.native_driver_wrapper import (
-    TypeDBDriverExceptionNative, bool_promise_resolve, concept_iterator_next, concept_promise_resolve, thing_type_delete,
-    thing_type_get_label, thing_type_get_owns, thing_type_get_owns_overridden, thing_type_get_plays,
-    thing_type_get_plays_overridden, thing_type_get_syntax, thing_type_is_abstract, thing_type_is_deleted, thing_type_is_root,
-    thing_type_set_abstract, thing_type_set_label, thing_type_set_owns, thing_type_set_plays, thing_type_unset_abstract,
-    thing_type_unset_owns, thing_type_unset_plays, void_promise_resolve,
-)
-
-from typedb.api.concept.type.thing_type import ThingType
-from typedb.common.exception import TypeDBDriverException
-from typedb.common.iterator_wrapper import IteratorWrapper
-from typedb.common.label import Label
-from typedb.common.promise import Promise
-from typedb.common.transitivity import Transitivity
-from typedb.concept.concept_factory import wrap_attribute_type, wrap_role_type
-from typedb.concept.type.type import _Type
-
-if TYPE_CHECKING:
-    from typedb.api.concept.type.attribute_type import AttributeType
-    from typedb.api.concept.value.value import ValueType
-    from typedb.api.concept.type.annotation import Annotation
-    from typedb.concept.type.attribute_type import _AttributeType
-    from typedb.concept.type.role_type import _RoleType
-    from typedb.connection.transaction import _Transaction
-
-
-class _ThingType(ThingType, _Type, ABC):
-    def as_thing_type(self) -> ThingType:
-        return self
-
-    def is_root(self) -> bool:
-        try:
-            return thing_type_is_root(self.native_object)
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
-
-    def is_abstract(self) -> bool:
-        try:
-            return thing_type_is_abstract(self.native_object)
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
-
-    def get_label(self) -> Label:
-        try:
-            return Label.of(thing_type_get_label(self.native_object))
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
-
-    def delete(self, transaction: _Transaction) -> Promise[None]:
-        promise = thing_type_delete(transaction.native_object, self.native_object)
-        return Promise(lambda: void_promise_resolve(promise))
-
-    def is_deleted(self, transaction: _Transaction) -> Promise[bool]:
-        promise = thing_type_is_deleted(transaction.native_object, self.native_object)
-        return Promise(lambda: bool_promise_resolve(promise))
-
-    def set_label(self, transaction: _Transaction, new_label: str) -> Promise[None]:
-        promise = thing_type_set_label(transaction.native_object, self.native_object, new_label)
-        return Promise(lambda: void_promise_resolve(promise))
-
-    @abstractmethod
-    def get_instances(
-        self,
-        transaction: _Transaction,
-        transitivity: Transitivity = Transitivity.TRANSITIVE,
-    ):
-        pass
-
-    def set_abstract(self, transaction: _Transaction) -> Promise[None]:
-        promise = thing_type_set_abstract(transaction.native_object, self.native_object)
-        return Promise(lambda: void_promise_resolve(promise))
-
-    def unset_abstract(self, transaction: _Transaction) -> Promise[None]:
-        promise = thing_type_unset_abstract(transaction.native_object, self.native_object)
-        return Promise(lambda: void_promise_resolve(promise))
-
-    def set_plays(
-        self,
-        transaction: _Transaction,
-        role_type: _RoleType,
-        overridden_role_type: Optional[_RoleType] = None,
-    ) -> Promise[None]:
-        promise = thing_type_set_plays(
-            transaction.native_object,
-            self.native_object,
-            role_type.native_object,
-            overridden_role_type.native_object if overridden_role_type else None,
-        )
-        return Promise(lambda: void_promise_resolve(promise))
-
-    def unset_plays(self, transaction: _Transaction, role_type: _RoleType) -> Promise[None]:
-        promise = thing_type_unset_plays(transaction.native_object, self.native_object, role_type.native_object)
-        return Promise(lambda: void_promise_resolve(promise))
-
-    def set_owns(
-        self,
-        transaction: _Transaction,
-        attribute_type: _AttributeType,
-        overridden_type: Optional[_AttributeType] = None,
-        annotations: Optional[set[Annotation]] = None,
-    ) -> Promise[None]:
-        overridden_type_native = (overridden_type.native_object if overridden_type else None)
-        annotations_array = ([anno.native_object for anno in annotations] if annotations else [])
-        promise = thing_type_set_owns(
-            transaction.native_object,
-            self.native_object,
-            attribute_type.native_object,
-            overridden_type_native,
-            annotations_array,
-        )
-        return Promise(lambda: void_promise_resolve(promise))
-
-    def unset_owns(self, transaction: _Transaction, attribute_type: _AttributeType) -> Promise[None]:
-        promise = thing_type_unset_owns(transaction.native_object, self.native_object, attribute_type.native_object)
-        return Promise(lambda: void_promise_resolve(promise))
-
-    def get_plays(self, transaction: _Transaction, transitivity: Transitivity = Transitivity.TRANSITIVE) -> Iterator[_RoleType]:
-        try:
-            return map(
-                wrap_role_type,
-                IteratorWrapper(
-                    thing_type_get_plays(transaction.native_object, self.native_object, transitivity.value), concept_iterator_next
-                )
-            )
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
-
-    def get_plays_overridden(self, transaction: _Transaction, role_type: _RoleType) -> Promise[Optional[_RoleType]]:
-        if res := thing_type_get_plays_overridden(transaction.native_object, self.native_object, role_type.native_object):
-            return wrap_role_type(res)
-        return None
-
-    def get_owns(
-        self,
-        transaction: _Transaction,
-        value_type: Optional[ValueType] = None,
-        transitivity: Transitivity = Transitivity.TRANSITIVE,
-        annotations: Optional[set[Annotation]] = None,
-    ) -> Iterator[AttributeType]:
-        try:
-            return map(
-                wrap_attribute_type,
-                IteratorWrapper(
-                    thing_type_get_owns(
-                        transaction.native_object, self.native_object, value_type.native_object if value_type else None,
-                        transitivity.value, [anno.native_object for anno in annotations] if annotations else []
-                    ), concept_iterator_next
-                )
-            )
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
-
-    def get_owns_overridden(self, transaction: _Transaction, attribute_type: _AttributeType) -> Promise[Optional[AttributeType]]:
-        promise = thing_type_get_owns_overridden(transaction.native_object, self.native_object, attribute_type.native_object)
-        return Promise.map(wrap_attribute_type, lambda: concept_promise_resolve(promise))
-
-    def get_syntax(self, transaction: _Transaction) -> Promise[str]:
-        return thing_type_get_syntax(transaction.native_object, self.native_object)
-
-
-class _Root(_ThingType):
-    ROOT_LABEL = Label.of("thing")
-
-    def get_label(self) -> Label:
-        return self.ROOT_LABEL
-
-    def get_supertype(self, transaction: _Transaction) -> Promise[Optional[_ThingType]]:
-        return Promise(lambda: None)
-
-    def get_supertypes(self, transaction: _Transaction) -> Iterator[_ThingType]:
-        return (self,)
-
-    def get_subtypes(
-        self,
-        transaction: _Transaction,
-        transitivity: Transitivity = Transitivity.TRANSITIVE,
-    ) -> Iterator[Any]:
-        return chain(
-            (self,),
-            transaction.concepts.get_root_entity_type().get_subtypes(transaction, transitivity),
-            transaction.concepts.get_root_relation_type().get_subtypes(transaction, transitivity),
-            transaction.concepts.get_root_attribute_type().get_subtypes(transaction, transitivity),
-        )
-
-    def get_instances(
-        self,
-        transaction: _Transaction,
-        transitivity: Transitivity = Transitivity.TRANSITIVE,
-    ) -> Iterator[Any]:
-        return chain(
-            (self,),
-            transaction.concepts.get_root_entity_type().get_instances(transaction, transitivity),
-            transaction.concepts.get_root_relation_type().get_instances(transaction, transitivity),
-            transaction.concepts.get_root_attribute_type().get_instances(transaction, transitivity),
-        )
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from abc import abstractmethod, ABC
+from itertools import chain
+from typing import Optional, Iterator, TYPE_CHECKING, Any
+
+from typedb.native_driver_wrapper import (
+    TypeDBDriverExceptionNative, bool_promise_resolve, concept_iterator_next, concept_promise_resolve, thing_type_delete,
+    thing_type_get_label, thing_type_get_owns, thing_type_get_owns_overridden, thing_type_get_plays,
+    thing_type_get_plays_overridden, thing_type_get_syntax, thing_type_is_abstract, thing_type_is_deleted, thing_type_is_root,
+    thing_type_set_abstract, thing_type_set_label, thing_type_set_owns, thing_type_set_plays, thing_type_unset_abstract,
+    thing_type_unset_owns, thing_type_unset_plays, void_promise_resolve,
+)
+
+from typedb.api.concept.type.thing_type import ThingType
+from typedb.common.exception import TypeDBDriverException
+from typedb.common.iterator_wrapper import IteratorWrapper
+from typedb.common.label import Label
+from typedb.common.promise import Promise
+from typedb.common.transitivity import Transitivity
+from typedb.concept.concept_factory import wrap_attribute_type, wrap_role_type
+from typedb.concept.type.type import _Type
+
+if TYPE_CHECKING:
+    from typedb.api.concept.type.attribute_type import AttributeType
+    from typedb.api.concept.value.value import ValueType
+    from typedb.api.concept.type.annotation import Annotation
+    from typedb.concept.type.attribute_type import _AttributeType
+    from typedb.concept.type.role_type import _RoleType
+    from typedb.connection.transaction import _Transaction
+
+
+class _ThingType(ThingType, _Type, ABC):
+    def as_thing_type(self) -> ThingType:
+        return self
+
+    def is_root(self) -> bool:
+        try:
+            return thing_type_is_root(self.native_object)
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
+
+    def is_abstract(self) -> bool:
+        try:
+            return thing_type_is_abstract(self.native_object)
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
+
+    def get_label(self) -> Label:
+        try:
+            return Label.of(thing_type_get_label(self.native_object))
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
+
+    def delete(self, transaction: _Transaction) -> Promise[None]:
+        promise = thing_type_delete(transaction.native_object, self.native_object)
+        return Promise(lambda: void_promise_resolve(promise))
+
+    def is_deleted(self, transaction: _Transaction) -> Promise[bool]:
+        promise = thing_type_is_deleted(transaction.native_object, self.native_object)
+        return Promise(lambda: bool_promise_resolve(promise))
+
+    def set_label(self, transaction: _Transaction, new_label: str) -> Promise[None]:
+        promise = thing_type_set_label(transaction.native_object, self.native_object, new_label)
+        return Promise(lambda: void_promise_resolve(promise))
+
+    @abstractmethod
+    def get_instances(
+        self,
+        transaction: _Transaction,
+        transitivity: Transitivity = Transitivity.TRANSITIVE,
+    ):
+        pass
+
+    def set_abstract(self, transaction: _Transaction) -> Promise[None]:
+        promise = thing_type_set_abstract(transaction.native_object, self.native_object)
+        return Promise(lambda: void_promise_resolve(promise))
+
+    def unset_abstract(self, transaction: _Transaction) -> Promise[None]:
+        promise = thing_type_unset_abstract(transaction.native_object, self.native_object)
+        return Promise(lambda: void_promise_resolve(promise))
+
+    def set_plays(
+        self,
+        transaction: _Transaction,
+        role_type: _RoleType,
+        overridden_role_type: Optional[_RoleType] = None,
+    ) -> Promise[None]:
+        promise = thing_type_set_plays(
+            transaction.native_object,
+            self.native_object,
+            role_type.native_object,
+            overridden_role_type.native_object if overridden_role_type else None,
+        )
+        return Promise(lambda: void_promise_resolve(promise))
+
+    def unset_plays(self, transaction: _Transaction, role_type: _RoleType) -> Promise[None]:
+        promise = thing_type_unset_plays(transaction.native_object, self.native_object, role_type.native_object)
+        return Promise(lambda: void_promise_resolve(promise))
+
+    def set_owns(
+        self,
+        transaction: _Transaction,
+        attribute_type: _AttributeType,
+        overridden_type: Optional[_AttributeType] = None,
+        annotations: Optional[set[Annotation]] = None,
+    ) -> Promise[None]:
+        overridden_type_native = (overridden_type.native_object if overridden_type else None)
+        annotations_array = ([anno.native_object for anno in annotations] if annotations else [])
+        promise = thing_type_set_owns(
+            transaction.native_object,
+            self.native_object,
+            attribute_type.native_object,
+            overridden_type_native,
+            annotations_array,
+        )
+        return Promise(lambda: void_promise_resolve(promise))
+
+    def unset_owns(self, transaction: _Transaction, attribute_type: _AttributeType) -> Promise[None]:
+        promise = thing_type_unset_owns(transaction.native_object, self.native_object, attribute_type.native_object)
+        return Promise(lambda: void_promise_resolve(promise))
+
+    def get_plays(self, transaction: _Transaction, transitivity: Transitivity = Transitivity.TRANSITIVE) -> Iterator[_RoleType]:
+        try:
+            return map(
+                wrap_role_type,
+                IteratorWrapper(
+                    thing_type_get_plays(transaction.native_object, self.native_object, transitivity.value), concept_iterator_next
+                )
+            )
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
+
+    def get_plays_overridden(self, transaction: _Transaction, role_type: _RoleType) -> Promise[Optional[_RoleType]]:
+        if res := thing_type_get_plays_overridden(transaction.native_object, self.native_object, role_type.native_object):
+            return wrap_role_type(res)
+        return None
+
+    def get_owns(
+        self,
+        transaction: _Transaction,
+        value_type: Optional[ValueType] = None,
+        transitivity: Transitivity = Transitivity.TRANSITIVE,
+        annotations: Optional[set[Annotation]] = None,
+    ) -> Iterator[AttributeType]:
+        try:
+            return map(
+                wrap_attribute_type,
+                IteratorWrapper(
+                    thing_type_get_owns(
+                        transaction.native_object, self.native_object, value_type.native_object if value_type else None,
+                        transitivity.value, [anno.native_object for anno in annotations] if annotations else []
+                    ), concept_iterator_next
+                )
+            )
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
+
+    def get_owns_overridden(self, transaction: _Transaction, attribute_type: _AttributeType) -> Promise[Optional[AttributeType]]:
+        promise = thing_type_get_owns_overridden(transaction.native_object, self.native_object, attribute_type.native_object)
+        return Promise.map(wrap_attribute_type, lambda: concept_promise_resolve(promise))
+
+    def get_syntax(self, transaction: _Transaction) -> Promise[str]:
+        return thing_type_get_syntax(transaction.native_object, self.native_object)
+
+
+class _Root(_ThingType):
+    ROOT_LABEL = Label.of("thing")
+
+    def get_label(self) -> Label:
+        return self.ROOT_LABEL
+
+    def get_supertype(self, transaction: _Transaction) -> Promise[Optional[_ThingType]]:
+        return Promise(lambda: None)
+
+    def get_supertypes(self, transaction: _Transaction) -> Iterator[_ThingType]:
+        return (self,)
+
+    def get_subtypes(
+        self,
+        transaction: _Transaction,
+        transitivity: Transitivity = Transitivity.TRANSITIVE,
+    ) -> Iterator[Any]:
+        return chain(
+            (self,),
+            transaction.concepts.get_root_entity_type().get_subtypes(transaction, transitivity),
+            transaction.concepts.get_root_relation_type().get_subtypes(transaction, transitivity),
+            transaction.concepts.get_root_attribute_type().get_subtypes(transaction, transitivity),
+        )
+
+    def get_instances(
+        self,
+        transaction: _Transaction,
+        transitivity: Transitivity = Transitivity.TRANSITIVE,
+    ) -> Iterator[Any]:
+        return chain(
+            (self,),
+            transaction.concepts.get_root_entity_type().get_instances(transaction, transitivity),
+            transaction.concepts.get_root_relation_type().get_instances(transaction, transitivity),
+            transaction.concepts.get_root_attribute_type().get_instances(transaction, transitivity),
+        )
```

## typedb/concept/type/type.py

 * *Ordering differences only*

```diff
@@ -1,59 +1,59 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from abc import ABC, abstractmethod
-from typing import TYPE_CHECKING, Iterator, Optional
-
-from typedb.api.concept.type.type import Type
-from typedb.common.transitivity import Transitivity
-from typedb.concept.concept import _Concept
-
-if TYPE_CHECKING:
-    from typedb.common.promise import Promise
-    from typedb.connection.transaction import _Transaction
-
-
-class _Type(Type, _Concept, ABC):
-    def as_type(self) -> Type:
-        return self
-
-    @abstractmethod
-    def get_supertype(self, transaction: _Transaction) -> Promise[Optional[_Type]]:
-        pass
-
-    @abstractmethod
-    def get_supertypes(self, transaction: _Transaction) -> Iterator[_Type]:
-        pass
-
-    @abstractmethod
-    def get_subtypes(self, transaction: _Transaction, transitivity: Transitivity = Transitivity.TRANSITIVE) -> Iterator[_Type]:
-        pass
-
-    def __str__(self):
-        return type(self).__name__ + "[label: %s]" % self.get_label()
-
-    def __eq__(self, other):
-        if other is self:
-            return True
-        if not other or type(self) is not type(other):
-            return False
-        return self.get_label() == other.get_label()
-
-    def __hash__(self):
-        return self.get_label().__hash__()
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from abc import ABC, abstractmethod
+from typing import TYPE_CHECKING, Iterator, Optional
+
+from typedb.api.concept.type.type import Type
+from typedb.common.transitivity import Transitivity
+from typedb.concept.concept import _Concept
+
+if TYPE_CHECKING:
+    from typedb.common.promise import Promise
+    from typedb.connection.transaction import _Transaction
+
+
+class _Type(Type, _Concept, ABC):
+    def as_type(self) -> Type:
+        return self
+
+    @abstractmethod
+    def get_supertype(self, transaction: _Transaction) -> Promise[Optional[_Type]]:
+        pass
+
+    @abstractmethod
+    def get_supertypes(self, transaction: _Transaction) -> Iterator[_Type]:
+        pass
+
+    @abstractmethod
+    def get_subtypes(self, transaction: _Transaction, transitivity: Transitivity = Transitivity.TRANSITIVE) -> Iterator[_Type]:
+        pass
+
+    def __str__(self):
+        return type(self).__name__ + "[label: %s]" % self.get_label()
+
+    def __eq__(self, other):
+        if other is self:
+            return True
+        if not other or type(self) is not type(other):
+            return False
+        return self.get_label() == other.get_label()
+
+    def __hash__(self):
+        return self.get_label().__hash__()
```

## typedb/concept/value/value.py

 * *Ordering differences only*

```diff
@@ -1,131 +1,131 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from datetime import datetime, timezone
-from functools import singledispatchmethod
-from typing import Union
-
-from typedb.native_driver_wrapper import value_new_boolean, value_new_long, value_new_double, value_new_string, \
-    value_new_date_time_from_millis, value_is_boolean, value_is_long, value_is_double, value_is_string, \
-    value_is_date_time, value_get_boolean, value_get_long, value_get_double, value_get_string, \
-    value_get_date_time_as_millis
-
-from typedb.api.concept.value.value import Value, ValueType
-from typedb.common.exception import TypeDBDriverException, UNEXPECTED_NATIVE_VALUE, ILLEGAL_STATE, MISSING_VALUE
-from typedb.concept.concept import _Concept
-
-
-class _Value(Value, _Concept):
-
-    @singledispatchmethod
-    def of(value):
-        raise TypeDBDriverException(UNEXPECTED_NATIVE_VALUE)
-
-    @of.register
-    def _(value: bool):
-        return _Value(value_new_boolean(value))
-
-    @of.register
-    def _(value: int):
-        return _Value(value_new_long(value))
-
-    @of.register
-    def _(value: float):
-        return _Value(value_new_double(value))
-
-    @of.register
-    def _(value: str):
-        if not value:
-            raise TypeDBDriverException(MISSING_VALUE)
-        return _Value(value_new_string(value))
-
-    @of.register
-    def _(value: datetime):
-        return _Value(value_new_date_time_from_millis(int(value.replace(tzinfo=timezone.utc).timestamp() * 1000)))
-
-    @of.register
-    def _(value: Value):
-        return value
-
-    def get_value_type(self) -> ValueType:
-        if self.is_boolean():
-            return ValueType.BOOLEAN
-        elif self.is_long():
-            return ValueType.LONG
-        elif self.is_double():
-            return ValueType.DOUBLE
-        elif self.is_string():
-            return ValueType.STRING
-        elif self.is_datetime():
-            return ValueType.DATETIME
-        else:
-            raise TypeDBDriverException(ILLEGAL_STATE)
-
-    def get(self) -> Union[bool, int, float, str, datetime]:
-        if self.is_boolean():
-            return self.as_boolean()
-        elif self.is_long():
-            return self.as_long()
-        elif self.is_double():
-            return self.as_double()
-        elif self.is_string():
-            return self.as_string()
-        elif self.is_datetime():
-            return self.as_datetime()
-        else:
-            raise TypeDBDriverException(ILLEGAL_STATE)
-
-    def is_boolean(self) -> bool:
-        return value_is_boolean(self.native_object)
-
-    def is_long(self) -> bool:
-        return value_is_long(self.native_object)
-
-    def is_double(self) -> bool:
-        return value_is_double(self.native_object)
-
-    def is_string(self) -> bool:
-        return value_is_string(self.native_object)
-
-    def is_datetime(self) -> bool:
-        return value_is_date_time(self.native_object)
-
-    def as_boolean(self) -> bool:
-        return value_get_boolean(self.native_object)
-
-    def as_long(self) -> int:
-        return value_get_long(self.native_object)
-
-    def as_double(self) -> float:
-        return value_get_double(self.native_object)
-
-    def as_string(self) -> str:
-        return value_get_string(self.native_object)
-
-    def as_datetime(self) -> datetime:
-        return datetime.utcfromtimestamp(value_get_date_time_as_millis(self.native_object) / 1000)
-
-    def __str__(self):
-        return str(self.get())
-
-    def __repr__(self):
-        return f"{self.get_value_type()}({self.get()})"
-
-    def __hash__(self):
-        return hash(self.get())
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from datetime import datetime, timezone
+from functools import singledispatchmethod
+from typing import Union
+
+from typedb.native_driver_wrapper import value_new_boolean, value_new_long, value_new_double, value_new_string, \
+    value_new_date_time_from_millis, value_is_boolean, value_is_long, value_is_double, value_is_string, \
+    value_is_date_time, value_get_boolean, value_get_long, value_get_double, value_get_string, \
+    value_get_date_time_as_millis
+
+from typedb.api.concept.value.value import Value, ValueType
+from typedb.common.exception import TypeDBDriverException, UNEXPECTED_NATIVE_VALUE, ILLEGAL_STATE, MISSING_VALUE
+from typedb.concept.concept import _Concept
+
+
+class _Value(Value, _Concept):
+
+    @singledispatchmethod
+    def of(value):
+        raise TypeDBDriverException(UNEXPECTED_NATIVE_VALUE)
+
+    @of.register
+    def _(value: bool):
+        return _Value(value_new_boolean(value))
+
+    @of.register
+    def _(value: int):
+        return _Value(value_new_long(value))
+
+    @of.register
+    def _(value: float):
+        return _Value(value_new_double(value))
+
+    @of.register
+    def _(value: str):
+        if not value:
+            raise TypeDBDriverException(MISSING_VALUE)
+        return _Value(value_new_string(value))
+
+    @of.register
+    def _(value: datetime):
+        return _Value(value_new_date_time_from_millis(int(value.replace(tzinfo=timezone.utc).timestamp() * 1000)))
+
+    @of.register
+    def _(value: Value):
+        return value
+
+    def get_value_type(self) -> ValueType:
+        if self.is_boolean():
+            return ValueType.BOOLEAN
+        elif self.is_long():
+            return ValueType.LONG
+        elif self.is_double():
+            return ValueType.DOUBLE
+        elif self.is_string():
+            return ValueType.STRING
+        elif self.is_datetime():
+            return ValueType.DATETIME
+        else:
+            raise TypeDBDriverException(ILLEGAL_STATE)
+
+    def get(self) -> Union[bool, int, float, str, datetime]:
+        if self.is_boolean():
+            return self.as_boolean()
+        elif self.is_long():
+            return self.as_long()
+        elif self.is_double():
+            return self.as_double()
+        elif self.is_string():
+            return self.as_string()
+        elif self.is_datetime():
+            return self.as_datetime()
+        else:
+            raise TypeDBDriverException(ILLEGAL_STATE)
+
+    def is_boolean(self) -> bool:
+        return value_is_boolean(self.native_object)
+
+    def is_long(self) -> bool:
+        return value_is_long(self.native_object)
+
+    def is_double(self) -> bool:
+        return value_is_double(self.native_object)
+
+    def is_string(self) -> bool:
+        return value_is_string(self.native_object)
+
+    def is_datetime(self) -> bool:
+        return value_is_date_time(self.native_object)
+
+    def as_boolean(self) -> bool:
+        return value_get_boolean(self.native_object)
+
+    def as_long(self) -> int:
+        return value_get_long(self.native_object)
+
+    def as_double(self) -> float:
+        return value_get_double(self.native_object)
+
+    def as_string(self) -> str:
+        return value_get_string(self.native_object)
+
+    def as_datetime(self) -> datetime:
+        return datetime.utcfromtimestamp(value_get_date_time_as_millis(self.native_object) / 1000)
+
+    def __str__(self):
+        return str(self.get())
+
+    def __repr__(self):
+        return f"{self.get_value_type()}({self.get()})"
+
+    def __hash__(self):
+        return hash(self.get())
```

## typedb/connection/database.py

 * *Ordering differences only*

```diff
@@ -1,118 +1,118 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from typing import Optional
-
-from typedb.native_driver_wrapper import database_get_name, database_schema, database_delete, database_rule_schema, \
-    database_type_schema, ReplicaInfo, replica_info_get_server, replica_info_is_primary, replica_info_is_preferred, \
-    replica_info_get_term, database_get_replicas_info, database_get_primary_replica_info, \
-    database_get_preferred_replica_info, replica_info_iterator_next, Database as NativeDatabase, \
-    TypeDBDriverExceptionNative
-
-from typedb.api.connection.database import Database, Replica
-from typedb.common.exception import TypeDBDriverException, DATABASE_DELETED, NULL_NATIVE_OBJECT
-from typedb.common.iterator_wrapper import IteratorWrapper
-from typedb.common.native_wrapper import NativeWrapper
-
-
-class _Database(Database, NativeWrapper[NativeDatabase]):
-
-    def __init__(self, database: NativeDatabase):
-        if not database:
-            raise TypeDBDriverException(NULL_NATIVE_OBJECT)
-        super().__init__(database)
-        self._name = database_get_name(database)
-
-    @property
-    def _native_object_not_owned_exception(self) -> TypeDBDriverException:
-        return TypeDBDriverException(DATABASE_DELETED)
-
-    @property
-    def name(self) -> str:
-        if not self._native_object.thisown:
-            raise self._native_object_not_owned_exception
-        return self._name
-
-    def schema(self) -> str:
-        try:
-            return database_schema(self.native_object)
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
-
-    def rule_schema(self) -> str:
-        try:
-            return database_rule_schema(self.native_object)
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
-
-    def type_schema(self) -> str:
-        try:
-            return database_type_schema(self.native_object)
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
-
-    def delete(self) -> None:
-        try:
-            self.native_object.thisown = 0
-            database_delete(self._native_object)
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
-
-    def replicas(self) -> set[Replica]:
-        try:
-            repl_iter = IteratorWrapper(database_get_replicas_info(self.native_object), replica_info_iterator_next)
-            return set(_Database.Replica(replica_info) for replica_info in repl_iter)
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
-
-    def primary_replica(self) -> Optional[Replica]:
-        if res := database_get_primary_replica_info(self.native_object):
-            return _Database.Replica(res)
-        return None
-
-    def preferred_replica(self) -> Optional[Replica]:
-        if res := database_get_preferred_replica_info(self.native_object):
-            return _Database.Replica(res)
-        return None
-
-    def __str__(self):
-        return self.name
-
-    def __repr__(self):
-        return f"Database('{str(self)}')"
-
-    class Replica(Replica):
-
-        def __init__(self, replica_info: ReplicaInfo):
-            self._info = replica_info
-
-        def database(self) -> Database:
-            pass
-
-        def server(self) -> str:
-            return replica_info_get_server(self._info)
-
-        def is_primary(self) -> bool:
-            return replica_info_is_primary(self._info)
-
-        def is_preferred(self) -> bool:
-            return replica_info_is_preferred(self._info)
-
-        def term(self) -> int:
-            return replica_info_get_term(self._info)
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from typing import Optional
+
+from typedb.native_driver_wrapper import database_get_name, database_schema, database_delete, database_rule_schema, \
+    database_type_schema, ReplicaInfo, replica_info_get_server, replica_info_is_primary, replica_info_is_preferred, \
+    replica_info_get_term, database_get_replicas_info, database_get_primary_replica_info, \
+    database_get_preferred_replica_info, replica_info_iterator_next, Database as NativeDatabase, \
+    TypeDBDriverExceptionNative
+
+from typedb.api.connection.database import Database, Replica
+from typedb.common.exception import TypeDBDriverException, DATABASE_DELETED, NULL_NATIVE_OBJECT
+from typedb.common.iterator_wrapper import IteratorWrapper
+from typedb.common.native_wrapper import NativeWrapper
+
+
+class _Database(Database, NativeWrapper[NativeDatabase]):
+
+    def __init__(self, database: NativeDatabase):
+        if not database:
+            raise TypeDBDriverException(NULL_NATIVE_OBJECT)
+        super().__init__(database)
+        self._name = database_get_name(database)
+
+    @property
+    def _native_object_not_owned_exception(self) -> TypeDBDriverException:
+        return TypeDBDriverException(DATABASE_DELETED)
+
+    @property
+    def name(self) -> str:
+        if not self._native_object.thisown:
+            raise self._native_object_not_owned_exception
+        return self._name
+
+    def schema(self) -> str:
+        try:
+            return database_schema(self.native_object)
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
+
+    def rule_schema(self) -> str:
+        try:
+            return database_rule_schema(self.native_object)
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
+
+    def type_schema(self) -> str:
+        try:
+            return database_type_schema(self.native_object)
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
+
+    def delete(self) -> None:
+        try:
+            self.native_object.thisown = 0
+            database_delete(self._native_object)
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
+
+    def replicas(self) -> set[Replica]:
+        try:
+            repl_iter = IteratorWrapper(database_get_replicas_info(self.native_object), replica_info_iterator_next)
+            return set(_Database.Replica(replica_info) for replica_info in repl_iter)
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
+
+    def primary_replica(self) -> Optional[Replica]:
+        if res := database_get_primary_replica_info(self.native_object):
+            return _Database.Replica(res)
+        return None
+
+    def preferred_replica(self) -> Optional[Replica]:
+        if res := database_get_preferred_replica_info(self.native_object):
+            return _Database.Replica(res)
+        return None
+
+    def __str__(self):
+        return self.name
+
+    def __repr__(self):
+        return f"Database('{str(self)}')"
+
+    class Replica(Replica):
+
+        def __init__(self, replica_info: ReplicaInfo):
+            self._info = replica_info
+
+        def database(self) -> Database:
+            pass
+
+        def server(self) -> str:
+            return replica_info_get_server(self._info)
+
+        def is_primary(self) -> bool:
+            return replica_info_is_primary(self._info)
+
+        def is_preferred(self) -> bool:
+            return replica_info_is_preferred(self._info)
+
+        def term(self) -> int:
+            return replica_info_get_term(self._info)
```

## typedb/connection/database_manager.py

 * *Ordering differences only*

```diff
@@ -1,74 +1,74 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-#   Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from typing import TYPE_CHECKING
-
-from typedb.native_driver_wrapper import databases_contains, databases_create, database_manager_new, databases_get, \
-    databases_all, database_iterator_next, DatabaseManager as NativeDatabaseManager, TypeDBDriverExceptionNative
-
-from typedb.api.connection.database import DatabaseManager
-from typedb.common.exception import TypeDBDriverException, DATABASE_DELETED, ILLEGAL_STATE, MISSING_DB_NAME
-from typedb.common.iterator_wrapper import IteratorWrapper
-from typedb.common.native_wrapper import NativeWrapper
-from typedb.connection.database import _Database
-
-if TYPE_CHECKING:
-    from typedb.native_driver_wrapper import Connection as NativeConnection
-
-
-def _not_blank(name: str) -> str:
-    if not name or name.isspace():
-        raise TypeDBDriverException(MISSING_DB_NAME)
-    return name
-
-
-class _DatabaseManager(DatabaseManager, NativeWrapper[NativeDatabaseManager]):
-
-    def __init__(self, connection: NativeConnection):
-        super().__init__(database_manager_new(connection))
-
-    @property
-    def _native_object_not_owned_exception(self) -> TypeDBDriverException:
-        return TypeDBDriverException(ILLEGAL_STATE)
-
-    def get(self, name: str) -> _Database:
-        try:
-            if not self.contains(name):
-                raise TypeDBDriverException(DATABASE_DELETED, name)
-            return _Database(databases_get(self.native_object, name))
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
-
-    def contains(self, name: str) -> bool:
-        try:
-            return databases_contains(self.native_object, _not_blank(name))
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
-
-    def create(self, name: str) -> None:
-        try:
-            databases_create(self.native_object, _not_blank(name))
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
-
-    def all(self) -> list[_Database]:
-        try:
-            return list(map(_Database, IteratorWrapper(databases_all(self.native_object), database_iterator_next)))
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+#   Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+from typedb.native_driver_wrapper import databases_contains, databases_create, database_manager_new, databases_get, \
+    databases_all, database_iterator_next, DatabaseManager as NativeDatabaseManager, TypeDBDriverExceptionNative
+
+from typedb.api.connection.database import DatabaseManager
+from typedb.common.exception import TypeDBDriverException, DATABASE_DELETED, ILLEGAL_STATE, MISSING_DB_NAME
+from typedb.common.iterator_wrapper import IteratorWrapper
+from typedb.common.native_wrapper import NativeWrapper
+from typedb.connection.database import _Database
+
+if TYPE_CHECKING:
+    from typedb.native_driver_wrapper import Connection as NativeConnection
+
+
+def _not_blank(name: str) -> str:
+    if not name or name.isspace():
+        raise TypeDBDriverException(MISSING_DB_NAME)
+    return name
+
+
+class _DatabaseManager(DatabaseManager, NativeWrapper[NativeDatabaseManager]):
+
+    def __init__(self, connection: NativeConnection):
+        super().__init__(database_manager_new(connection))
+
+    @property
+    def _native_object_not_owned_exception(self) -> TypeDBDriverException:
+        return TypeDBDriverException(ILLEGAL_STATE)
+
+    def get(self, name: str) -> _Database:
+        try:
+            if not self.contains(name):
+                raise TypeDBDriverException(DATABASE_DELETED, name)
+            return _Database(databases_get(self.native_object, name))
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
+
+    def contains(self, name: str) -> bool:
+        try:
+            return databases_contains(self.native_object, _not_blank(name))
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
+
+    def create(self, name: str) -> None:
+        try:
+            databases_create(self.native_object, _not_blank(name))
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
+
+    def all(self) -> list[_Database]:
+        try:
+            return list(map(_Database, IteratorWrapper(databases_all(self.native_object), database_iterator_next)))
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
```

## typedb/connection/driver.py

 * *Ordering differences only*

```diff
@@ -1,97 +1,97 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-#   Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from typing import Optional, TYPE_CHECKING
-
-from typedb.native_driver_wrapper import connection_open_core, connection_open_cloud, connection_open_cloud_translated, \
-        connection_is_open, connection_force_close, Connection as NativeConnection, TypeDBDriverExceptionNative
-
-from typedb.api.connection.driver import TypeDBDriver
-from typedb.api.connection.options import TypeDBOptions
-from typedb.common.exception import TypeDBDriverException, DRIVER_CLOSED
-from typedb.common.native_wrapper import NativeWrapper
-from typedb.connection.database_manager import _DatabaseManager
-from typedb.connection.session import _Session
-from typedb.user.user_manager import _UserManager
-
-if TYPE_CHECKING:
-    from typedb.api.connection.credential import TypeDBCredential
-    from typedb.api.connection.session import SessionType
-    from typedb.api.user.user import UserManager, User
-
-
-class _Driver(TypeDBDriver, NativeWrapper[NativeConnection]):
-
-    def __init__(self, addresses: list[str] | dict[str], credential: Optional[TypeDBCredential] = None):
-        if credential:
-            try:
-                if isinstance(addresses, list):
-                    native_connection = connection_open_cloud(addresses, credential.native_object)
-                else:
-                    advertised_addresses = list(addresses.keys())
-                    translated_addresses = [addresses[advertised] for advertised in advertised_addresses]
-                    native_connection = connection_open_cloud_translated(
-                            advertised_addresses, translated_addresses, credential.native_object)
-            except TypeDBDriverExceptionNative as e:
-                raise TypeDBDriverException.of(e)
-        else:
-            try:
-                native_connection = connection_open_core(addresses[0])
-            except TypeDBDriverExceptionNative as e:
-                raise TypeDBDriverException.of(e)
-        super().__init__(native_connection)
-        self._database_manager = _DatabaseManager(native_connection)
-        self._user_manager = _UserManager(native_connection)
-
-    @property
-    def _native_object_not_owned_exception(self) -> TypeDBDriverException:
-        return TypeDBDriverException(DRIVER_CLOSED)
-
-    @property
-    def _native_connection(self) -> NativeConnection:
-        return self.native_object
-
-    def session(self, database_name: str, session_type: SessionType, options: TypeDBOptions = None) -> _Session:
-        return _Session(self.databases, database_name, session_type, options if options else TypeDBOptions())
-
-    def is_open(self) -> bool:
-        return connection_is_open(self._native_connection)
-
-    @property
-    def databases(self) -> _DatabaseManager:
-        return self._database_manager
-
-    @property
-    def users(self) -> UserManager:
-        return self._user_manager
-
-    def user(self) -> User:
-        return self._user_manager.get_current_user()
-
-    def __enter__(self):
-        return self
-
-    def __exit__(self, exc_type, exc_val, exc_tb):
-        self.close()
-        if exc_tb is not None:
-            return False
-
-    def close(self) -> None:
-        if not self.is_open():
-            connection_force_close(self._native_connection)
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+#   Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from typing import Optional, TYPE_CHECKING
+
+from typedb.native_driver_wrapper import connection_open_core, connection_open_cloud, connection_open_cloud_translated, \
+        connection_is_open, connection_force_close, Connection as NativeConnection, TypeDBDriverExceptionNative
+
+from typedb.api.connection.driver import TypeDBDriver
+from typedb.api.connection.options import TypeDBOptions
+from typedb.common.exception import TypeDBDriverException, DRIVER_CLOSED
+from typedb.common.native_wrapper import NativeWrapper
+from typedb.connection.database_manager import _DatabaseManager
+from typedb.connection.session import _Session
+from typedb.user.user_manager import _UserManager
+
+if TYPE_CHECKING:
+    from typedb.api.connection.credential import TypeDBCredential
+    from typedb.api.connection.session import SessionType
+    from typedb.api.user.user import UserManager, User
+
+
+class _Driver(TypeDBDriver, NativeWrapper[NativeConnection]):
+
+    def __init__(self, addresses: list[str] | dict[str], credential: Optional[TypeDBCredential] = None):
+        if credential:
+            try:
+                if isinstance(addresses, list):
+                    native_connection = connection_open_cloud(addresses, credential.native_object)
+                else:
+                    advertised_addresses = list(addresses.keys())
+                    translated_addresses = [addresses[advertised] for advertised in advertised_addresses]
+                    native_connection = connection_open_cloud_translated(
+                            advertised_addresses, translated_addresses, credential.native_object)
+            except TypeDBDriverExceptionNative as e:
+                raise TypeDBDriverException.of(e)
+        else:
+            try:
+                native_connection = connection_open_core(addresses[0])
+            except TypeDBDriverExceptionNative as e:
+                raise TypeDBDriverException.of(e)
+        super().__init__(native_connection)
+        self._database_manager = _DatabaseManager(native_connection)
+        self._user_manager = _UserManager(native_connection)
+
+    @property
+    def _native_object_not_owned_exception(self) -> TypeDBDriverException:
+        return TypeDBDriverException(DRIVER_CLOSED)
+
+    @property
+    def _native_connection(self) -> NativeConnection:
+        return self.native_object
+
+    def session(self, database_name: str, session_type: SessionType, options: TypeDBOptions = None) -> _Session:
+        return _Session(self.databases, database_name, session_type, options if options else TypeDBOptions())
+
+    def is_open(self) -> bool:
+        return connection_is_open(self._native_connection)
+
+    @property
+    def databases(self) -> _DatabaseManager:
+        return self._database_manager
+
+    @property
+    def users(self) -> UserManager:
+        return self._user_manager
+
+    def user(self) -> User:
+        return self._user_manager.get_current_user()
+
+    def __enter__(self):
+        return self
+
+    def __exit__(self, exc_type, exc_val, exc_tb):
+        self.close()
+        if exc_tb is not None:
+            return False
+
+    def close(self) -> None:
+        if not self.is_open():
+            connection_force_close(self._native_connection)
```

## typedb/connection/session.py

 * *Ordering differences only*

```diff
@@ -1,95 +1,95 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from typing import TYPE_CHECKING, Optional
-
-from typedb.native_driver_wrapper import session_new, session_on_close, session_force_close, session_is_open, \
-    session_get_database_name, SessionCallbackDirector, Session as NativeSession, TypeDBDriverExceptionNative
-
-from typedb.api.connection.options import TypeDBOptions
-from typedb.api.connection.session import TypeDBSession
-from typedb.common.exception import TypeDBDriverException, SESSION_CLOSED
-from typedb.common.native_wrapper import NativeWrapper
-from typedb.connection.transaction import _Transaction
-
-if TYPE_CHECKING:
-    from typedb.api.connection.session import SessionType
-    from typedb.api.connection.transaction import TypeDBTransaction, TransactionType
-    from typedb.connection.database import _Database
-    from typedb.connection.database_manager import DatabaseManager
-
-
-class _Session(TypeDBSession, NativeWrapper[NativeSession]):
-
-    def __init__(self, database_manager: DatabaseManager , database_name: str, session_type: SessionType, options: Optional[TypeDBOptions] = None):
-        if not options:
-            options = TypeDBOptions()
-        self._type = session_type
-        self._options = options
-        try:
-            super().__init__(session_new(database_manager.native_object, database_name, session_type.value, options.native_object))
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
-
-    @property
-    def _native_object_not_owned_exception(self) -> TypeDBDriverException:
-        return TypeDBDriverException(SESSION_CLOSED)
-
-    def is_open(self) -> bool:
-        return session_is_open(self.native_object)
-
-    @property
-    def type(self) -> SessionType:
-        return self._type
-
-    def database_name(self) -> str:
-        return session_get_database_name(self.native_object)
-
-    @property
-    def options(self) -> TypeDBOptions:
-        return self._options
-
-    def transaction(self, transaction_type: TransactionType, options: TypeDBOptions = None) -> TypeDBTransaction:
-        return _Transaction(self, transaction_type, options)
-
-    def close(self) -> None:
-        session_force_close(self.native_object)
-
-    def on_close(self, function: callable):
-        session_on_close(self.native_object, _Session.Callback(function).__disown__())
-
-    def on_reopen(self, function: callable):
-        session_on_reopen(self.native_object, _Session.Callback(function).__disown__())
-
-    class Callback(SessionCallbackDirector):
-
-        def __init__(self, function: callable):
-            super().__init__()
-            self._function = function
-
-        def callback(self) -> None:
-            self._function()
-
-    def __enter__(self):
-        return self
-
-    def __exit__(self, exc_type, exc_val, exc_tb):
-        self.close()
-        if exc_tb is not None:
-            return False
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from typing import TYPE_CHECKING, Optional
+
+from typedb.native_driver_wrapper import session_new, session_on_close, session_force_close, session_is_open, \
+    session_get_database_name, SessionCallbackDirector, Session as NativeSession, TypeDBDriverExceptionNative
+
+from typedb.api.connection.options import TypeDBOptions
+from typedb.api.connection.session import TypeDBSession
+from typedb.common.exception import TypeDBDriverException, SESSION_CLOSED
+from typedb.common.native_wrapper import NativeWrapper
+from typedb.connection.transaction import _Transaction
+
+if TYPE_CHECKING:
+    from typedb.api.connection.session import SessionType
+    from typedb.api.connection.transaction import TypeDBTransaction, TransactionType
+    from typedb.connection.database import _Database
+    from typedb.connection.database_manager import DatabaseManager
+
+
+class _Session(TypeDBSession, NativeWrapper[NativeSession]):
+
+    def __init__(self, database_manager: DatabaseManager , database_name: str, session_type: SessionType, options: Optional[TypeDBOptions] = None):
+        if not options:
+            options = TypeDBOptions()
+        self._type = session_type
+        self._options = options
+        try:
+            super().__init__(session_new(database_manager.native_object, database_name, session_type.value, options.native_object))
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
+
+    @property
+    def _native_object_not_owned_exception(self) -> TypeDBDriverException:
+        return TypeDBDriverException(SESSION_CLOSED)
+
+    def is_open(self) -> bool:
+        return session_is_open(self.native_object)
+
+    @property
+    def type(self) -> SessionType:
+        return self._type
+
+    def database_name(self) -> str:
+        return session_get_database_name(self.native_object)
+
+    @property
+    def options(self) -> TypeDBOptions:
+        return self._options
+
+    def transaction(self, transaction_type: TransactionType, options: TypeDBOptions = None) -> TypeDBTransaction:
+        return _Transaction(self, transaction_type, options)
+
+    def close(self) -> None:
+        session_force_close(self.native_object)
+
+    def on_close(self, function: callable):
+        session_on_close(self.native_object, _Session.Callback(function).__disown__())
+
+    def on_reopen(self, function: callable):
+        session_on_reopen(self.native_object, _Session.Callback(function).__disown__())
+
+    class Callback(SessionCallbackDirector):
+
+        def __init__(self, function: callable):
+            super().__init__()
+            self._function = function
+
+        def callback(self) -> None:
+            self._function()
+
+    def __enter__(self):
+        return self
+
+    def __exit__(self, exc_type, exc_val, exc_tb):
+        self.close()
+        if exc_tb is not None:
+            return False
```

## typedb/connection/transaction.py

 * *Ordering differences only*

```diff
@@ -1,119 +1,119 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from typing import TYPE_CHECKING
-
-from typedb.native_driver_wrapper import error_code, error_message, transaction_new, transaction_commit, \
-    transaction_rollback, transaction_is_open, transaction_on_close, transaction_force_close, \
-    Transaction as NativeTransaction, TransactionCallbackDirector, TypeDBDriverExceptionNative, void_promise_resolve
-
-from typedb.api.connection.options import TypeDBOptions
-from typedb.api.connection.transaction import TypeDBTransaction
-from typedb.common.exception import TypeDBDriverException, TRANSACTION_CLOSED, TypeDBException
-from typedb.common.native_wrapper import NativeWrapper
-from typedb.concept.concept_manager import _ConceptManager
-from typedb.logic.logic_manager import _LogicManager
-from typedb.query.query_manager import _QueryManager
-
-if TYPE_CHECKING:
-    from typedb.connection.session import _Session
-    from typedb.api.connection.transaction import TransactionType
-    from typedb.native_driver_wrapper import Error as NativeError
-
-
-class _Transaction(TypeDBTransaction, NativeWrapper[NativeTransaction]):
-
-    def __init__(self, session: _Session, transaction_type: TransactionType, options: TypeDBOptions = None):
-        if not options:
-            options = TypeDBOptions()
-        self._transaction_type = transaction_type
-        self._options = options
-        try:
-            super().__init__(transaction_new(session.native_object, transaction_type.value, options.native_object))
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
-        self._concept_manager = _ConceptManager(self._native_object)
-        self._query_manager = _QueryManager(self._native_object)
-        self._logic_manager = _LogicManager(self._native_object)
-
-    @property
-    def _native_object_not_owned_exception(self) -> TypeDBDriverException:
-        return TypeDBDriverException(TRANSACTION_CLOSED)
-
-    @property
-    def transaction_type(self) -> TransactionType:
-        return self._transaction_type
-
-    @property
-    def options(self) -> TypeDBOptions:
-        return self._options
-
-    @property
-    def concepts(self) -> _ConceptManager:
-        return self._concept_manager
-
-    @property
-    def logic(self) -> _LogicManager:
-        return self._logic_manager
-
-    @property
-    def query(self) -> _QueryManager:
-        return self._query_manager
-
-    def is_open(self) -> bool:
-        if not self.native_object.thisown:
-            return False
-        return transaction_is_open(self.native_object)
-
-    def on_close(self, function: callable):
-        transaction_on_close(self.native_object, _Transaction.TransactionOnClose(function).__disown__())
-
-    class TransactionOnClose(TransactionCallbackDirector):
-
-        def __init__(self, function: callable):
-            super().__init__()
-            self._function = function
-
-        def callback(self, error: NativeError) -> None:
-            self._function(TypeDBException(error_code(error), error_message(error)))
-
-    def commit(self):
-        try:
-            self.native_object.thisown = 0
-            void_promise_resolve(transaction_commit(self._native_object))
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
-
-    def rollback(self):
-        try:
-            void_promise_resolve(transaction_rollback(self.native_object))
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
-
-    def close(self):
-        if self._native_object.thisown:
-            transaction_force_close(self._native_object)
-
-    def __enter__(self):
-        return self
-
-    def __exit__(self, exc_type, exc_val, exc_tb):
-        self.close()
-        if exc_tb is not None:
-            return False
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+from typedb.native_driver_wrapper import error_code, error_message, transaction_new, transaction_commit, \
+    transaction_rollback, transaction_is_open, transaction_on_close, transaction_force_close, \
+    Transaction as NativeTransaction, TransactionCallbackDirector, TypeDBDriverExceptionNative, void_promise_resolve
+
+from typedb.api.connection.options import TypeDBOptions
+from typedb.api.connection.transaction import TypeDBTransaction
+from typedb.common.exception import TypeDBDriverException, TRANSACTION_CLOSED, TypeDBException
+from typedb.common.native_wrapper import NativeWrapper
+from typedb.concept.concept_manager import _ConceptManager
+from typedb.logic.logic_manager import _LogicManager
+from typedb.query.query_manager import _QueryManager
+
+if TYPE_CHECKING:
+    from typedb.connection.session import _Session
+    from typedb.api.connection.transaction import TransactionType
+    from typedb.native_driver_wrapper import Error as NativeError
+
+
+class _Transaction(TypeDBTransaction, NativeWrapper[NativeTransaction]):
+
+    def __init__(self, session: _Session, transaction_type: TransactionType, options: TypeDBOptions = None):
+        if not options:
+            options = TypeDBOptions()
+        self._transaction_type = transaction_type
+        self._options = options
+        try:
+            super().__init__(transaction_new(session.native_object, transaction_type.value, options.native_object))
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
+        self._concept_manager = _ConceptManager(self._native_object)
+        self._query_manager = _QueryManager(self._native_object)
+        self._logic_manager = _LogicManager(self._native_object)
+
+    @property
+    def _native_object_not_owned_exception(self) -> TypeDBDriverException:
+        return TypeDBDriverException(TRANSACTION_CLOSED)
+
+    @property
+    def transaction_type(self) -> TransactionType:
+        return self._transaction_type
+
+    @property
+    def options(self) -> TypeDBOptions:
+        return self._options
+
+    @property
+    def concepts(self) -> _ConceptManager:
+        return self._concept_manager
+
+    @property
+    def logic(self) -> _LogicManager:
+        return self._logic_manager
+
+    @property
+    def query(self) -> _QueryManager:
+        return self._query_manager
+
+    def is_open(self) -> bool:
+        if not self.native_object.thisown:
+            return False
+        return transaction_is_open(self.native_object)
+
+    def on_close(self, function: callable):
+        transaction_on_close(self.native_object, _Transaction.TransactionOnClose(function).__disown__())
+
+    class TransactionOnClose(TransactionCallbackDirector):
+
+        def __init__(self, function: callable):
+            super().__init__()
+            self._function = function
+
+        def callback(self, error: NativeError) -> None:
+            self._function(TypeDBException(error_code(error), error_message(error)))
+
+    def commit(self):
+        try:
+            self.native_object.thisown = 0
+            void_promise_resolve(transaction_commit(self._native_object))
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
+
+    def rollback(self):
+        try:
+            void_promise_resolve(transaction_rollback(self.native_object))
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
+
+    def close(self):
+        if self._native_object.thisown:
+            transaction_force_close(self._native_object)
+
+    def __enter__(self):
+        return self
+
+    def __exit__(self, exc_type, exc_val, exc_tb):
+        self.close()
+        if exc_tb is not None:
+            return False
```

## typedb/logic/explanation.py

 * *Ordering differences only*

```diff
@@ -1,77 +1,77 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from typing import TYPE_CHECKING
-
-from typedb.native_driver_wrapper import explanation_get_rule, explanation_get_conclusion, \
-    explanation_get_mapped_variables, explanation_get_condition, string_iterator_next, \
-    explanation_get_mapping, explanation_to_string, explanation_equals, Explanation as NativeExplanation
-
-from typedb.api.logic.explanation import Explanation
-from typedb.common.exception import TypeDBDriverException, ILLEGAL_STATE, MISSING_VARIABLE, NULL_NATIVE_OBJECT
-from typedb.common.iterator_wrapper import IteratorWrapper
-from typedb.common.native_wrapper import NativeWrapper
-from typedb.concept.answer.concept_map import _ConceptMap
-from typedb.logic.rule import _Rule
-
-if TYPE_CHECKING:
-    from typedb.api.answer.concept_map import ConceptMap
-    from typedb.api.logic.rule import Rule
-
-
-class _Explanation(Explanation, NativeWrapper[NativeExplanation]):
-
-    def __init__(self, explanation: NativeExplanation):
-        if not explanation:
-            raise TypeDBDriverException(NULL_NATIVE_OBJECT)
-        super().__init__(explanation)
-
-    @property
-    def _native_object_not_owned_exception(self) -> TypeDBDriverException:
-        return TypeDBDriverException(ILLEGAL_STATE)
-
-    def rule(self) -> Rule:
-        return _Rule(explanation_get_rule(self.native_object))
-
-    def conclusion(self) -> ConceptMap:
-        return _ConceptMap(explanation_get_conclusion(self.native_object))
-
-    def condition(self) -> ConceptMap:
-        return _ConceptMap(explanation_get_condition(self.native_object))
-
-    def query_variables(self) -> set[str]:
-        return set(IteratorWrapper(explanation_get_mapped_variables(self.native_object), string_iterator_next))
-
-    def query_variable_mapping(self, var: str) -> set[str]:
-        if not var:
-            raise TypeDBDriverException(MISSING_VARIABLE)
-        return set(IteratorWrapper(explanation_get_mapping(self.native_object, var), string_iterator_next))
-
-    def __repr__(self):
-        return explanation_to_string(self.native_object)
-
-    def __eq__(self, other):
-        if other is self:
-            return True
-        if not other or type(self) != type(other):
-            return False
-        return explanation_equals(self.native_object, other.native_object)
-
-    def __hash__(self):
-        return hash((self.rule(), self.condition(), self.conclusion()))
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+from typedb.native_driver_wrapper import explanation_get_rule, explanation_get_conclusion, \
+    explanation_get_mapped_variables, explanation_get_condition, string_iterator_next, \
+    explanation_get_mapping, explanation_to_string, explanation_equals, Explanation as NativeExplanation
+
+from typedb.api.logic.explanation import Explanation
+from typedb.common.exception import TypeDBDriverException, ILLEGAL_STATE, MISSING_VARIABLE, NULL_NATIVE_OBJECT
+from typedb.common.iterator_wrapper import IteratorWrapper
+from typedb.common.native_wrapper import NativeWrapper
+from typedb.concept.answer.concept_map import _ConceptMap
+from typedb.logic.rule import _Rule
+
+if TYPE_CHECKING:
+    from typedb.api.answer.concept_map import ConceptMap
+    from typedb.api.logic.rule import Rule
+
+
+class _Explanation(Explanation, NativeWrapper[NativeExplanation]):
+
+    def __init__(self, explanation: NativeExplanation):
+        if not explanation:
+            raise TypeDBDriverException(NULL_NATIVE_OBJECT)
+        super().__init__(explanation)
+
+    @property
+    def _native_object_not_owned_exception(self) -> TypeDBDriverException:
+        return TypeDBDriverException(ILLEGAL_STATE)
+
+    def rule(self) -> Rule:
+        return _Rule(explanation_get_rule(self.native_object))
+
+    def conclusion(self) -> ConceptMap:
+        return _ConceptMap(explanation_get_conclusion(self.native_object))
+
+    def condition(self) -> ConceptMap:
+        return _ConceptMap(explanation_get_condition(self.native_object))
+
+    def query_variables(self) -> set[str]:
+        return set(IteratorWrapper(explanation_get_mapped_variables(self.native_object), string_iterator_next))
+
+    def query_variable_mapping(self, var: str) -> set[str]:
+        if not var:
+            raise TypeDBDriverException(MISSING_VARIABLE)
+        return set(IteratorWrapper(explanation_get_mapping(self.native_object, var), string_iterator_next))
+
+    def __repr__(self):
+        return explanation_to_string(self.native_object)
+
+    def __eq__(self, other):
+        if other is self:
+            return True
+        if not other or type(self) != type(other):
+            return False
+        return explanation_equals(self.native_object, other.native_object)
+
+    def __hash__(self):
+        return hash((self.rule(), self.condition(), self.conclusion()))
```

## typedb/logic/logic_manager.py

 * *Ordering differences only*

```diff
@@ -1,66 +1,66 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from typing import Optional
-
-from typedb.native_driver_wrapper import (
-    Transaction as NativeTransaction, TypeDBDriverExceptionNative, logic_manager_get_rule, logic_manager_get_rules,
-    logic_manager_put_rule, rule_iterator_next, rule_promise_resolve
-)
-
-from typedb.api.logic.logic_manager import LogicManager
-from typedb.api.logic.rule import Rule
-from typedb.common.exception import TypeDBDriverException, MISSING_LABEL, TRANSACTION_CLOSED
-from typedb.common.iterator_wrapper import IteratorWrapper
-from typedb.common.native_wrapper import NativeWrapper
-from typedb.common.promise import Promise
-from typedb.logic.rule import _Rule
-
-
-def _not_blank_label(label: str) -> str:
-    if not label or label.isspace():
-        raise TypeDBDriverException(MISSING_LABEL)
-    return label
-
-
-class _LogicManager(LogicManager, NativeWrapper[NativeTransaction]):
-    def __init__(self, transaction: NativeTransaction):
-        super().__init__(transaction)
-
-    @property
-    def _native_object_not_owned_exception(self) -> TypeDBDriverException:
-        return TypeDBDriverException(TRANSACTION_CLOSED)
-
-    @property
-    def _native_transaction(self) -> NativeTransaction:
-        return self.native_object
-
-    def get_rule(self, label: str) -> Promise[Optional[Rule]]:
-        promise = logic_manager_get_rule(self._native_transaction, _not_blank_label(label))
-        return Promise.map(_Rule, lambda: rule_promise_resolve(promise))
-
-    def get_rules(self):
-        try:
-            return map(_Rule, IteratorWrapper(logic_manager_get_rules(self._native_transaction), rule_iterator_next))
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
-
-    def put_rule(self, label: str, when: str, then: str) -> Promise[Rule]:
-        promise = logic_manager_put_rule(self._native_transaction, _not_blank_label(label), when, then)
-        return Promise.map(_Rule, lambda: rule_promise_resolve(promise))
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from typing import Optional
+
+from typedb.native_driver_wrapper import (
+    Transaction as NativeTransaction, TypeDBDriverExceptionNative, logic_manager_get_rule, logic_manager_get_rules,
+    logic_manager_put_rule, rule_iterator_next, rule_promise_resolve
+)
+
+from typedb.api.logic.logic_manager import LogicManager
+from typedb.api.logic.rule import Rule
+from typedb.common.exception import TypeDBDriverException, MISSING_LABEL, TRANSACTION_CLOSED
+from typedb.common.iterator_wrapper import IteratorWrapper
+from typedb.common.native_wrapper import NativeWrapper
+from typedb.common.promise import Promise
+from typedb.logic.rule import _Rule
+
+
+def _not_blank_label(label: str) -> str:
+    if not label or label.isspace():
+        raise TypeDBDriverException(MISSING_LABEL)
+    return label
+
+
+class _LogicManager(LogicManager, NativeWrapper[NativeTransaction]):
+    def __init__(self, transaction: NativeTransaction):
+        super().__init__(transaction)
+
+    @property
+    def _native_object_not_owned_exception(self) -> TypeDBDriverException:
+        return TypeDBDriverException(TRANSACTION_CLOSED)
+
+    @property
+    def _native_transaction(self) -> NativeTransaction:
+        return self.native_object
+
+    def get_rule(self, label: str) -> Promise[Optional[Rule]]:
+        promise = logic_manager_get_rule(self._native_transaction, _not_blank_label(label))
+        return Promise.map(_Rule, lambda: rule_promise_resolve(promise))
+
+    def get_rules(self):
+        try:
+            return map(_Rule, IteratorWrapper(logic_manager_get_rules(self._native_transaction), rule_iterator_next))
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
+
+    def put_rule(self, label: str, when: str, then: str) -> Promise[Rule]:
+        promise = logic_manager_put_rule(self._native_transaction, _not_blank_label(label), when, then)
+        return Promise.map(_Rule, lambda: rule_promise_resolve(promise))
```

## typedb/logic/rule.py

 * *Ordering differences only*

```diff
@@ -1,86 +1,86 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from typing import TYPE_CHECKING
-
-from typedb.native_driver_wrapper import (
-    Rule as NativeRule, bool_promise_resolve, rule_delete, rule_get_label, rule_get_then, rule_get_when, rule_is_deleted,
-    rule_set_label, rule_to_string, void_promise_resolve,
-)
-
-from typedb.api.logic.rule import Rule
-from typedb.common.exception import TypeDBDriverException, MISSING_LABEL, NULL_NATIVE_OBJECT, ILLEGAL_STATE
-from typedb.common.native_wrapper import NativeWrapper
-from typedb.common.promise import Promise
-
-if TYPE_CHECKING:
-    from typedb.connection.transaction import _Transaction
-
-
-class _Rule(Rule, NativeWrapper[NativeRule]):
-    def __init__(self, rule: NativeRule):
-        if not rule:
-            raise TypeDBDriverException(NULL_NATIVE_OBJECT)
-        super().__init__(rule)
-        self._rule = rule
-        self._when = rule_get_when(self._rule)
-        self._then = rule_get_then(self._rule)
-
-    @property
-    def _native_object_not_owned_exception(self) -> TypeDBDriverException:
-        return TypeDBDriverException(ILLEGAL_STATE)
-
-    @property
-    def label(self) -> str:
-        return rule_get_label(self.native_object)
-
-    def set_label(self, transaction: _Transaction, new_label: str) -> Promise[None]:
-        if not new_label:
-            raise TypeDBDriverException(MISSING_LABEL)
-        promise = rule_set_label(transaction.native_object, self.native_object, new_label)
-        return Promise(lambda: void_promise_resolve(promise))
-
-    @property
-    def when(self) -> str:
-        return self._when
-
-    @property
-    def then(self) -> str:
-        return self._then
-
-    def delete(self, transaction: _Transaction) -> Promise[None]:
-        promise = rule_delete(transaction.native_object, self.native_object)
-        return Promise(lambda: void_promise_resolve(promise))
-
-    def is_deleted(self, transaction: _Transaction) -> Promise[bool]:
-        promise = rule_is_deleted(transaction.native_object, self.native_object)
-        return Promise(lambda: bool_promise_resolve(promise))
-
-    def __repr__(self):
-        return rule_to_string(self.native_object)
-
-    def __eq__(self, other):
-        if other is self:
-            return True
-        if not other or type(self) is not type(other):
-            return False
-        return self.label == other.label
-
-    def __hash__(self):
-        return hash(self.label)
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+from typedb.native_driver_wrapper import (
+    Rule as NativeRule, bool_promise_resolve, rule_delete, rule_get_label, rule_get_then, rule_get_when, rule_is_deleted,
+    rule_set_label, rule_to_string, void_promise_resolve,
+)
+
+from typedb.api.logic.rule import Rule
+from typedb.common.exception import TypeDBDriverException, MISSING_LABEL, NULL_NATIVE_OBJECT, ILLEGAL_STATE
+from typedb.common.native_wrapper import NativeWrapper
+from typedb.common.promise import Promise
+
+if TYPE_CHECKING:
+    from typedb.connection.transaction import _Transaction
+
+
+class _Rule(Rule, NativeWrapper[NativeRule]):
+    def __init__(self, rule: NativeRule):
+        if not rule:
+            raise TypeDBDriverException(NULL_NATIVE_OBJECT)
+        super().__init__(rule)
+        self._rule = rule
+        self._when = rule_get_when(self._rule)
+        self._then = rule_get_then(self._rule)
+
+    @property
+    def _native_object_not_owned_exception(self) -> TypeDBDriverException:
+        return TypeDBDriverException(ILLEGAL_STATE)
+
+    @property
+    def label(self) -> str:
+        return rule_get_label(self.native_object)
+
+    def set_label(self, transaction: _Transaction, new_label: str) -> Promise[None]:
+        if not new_label:
+            raise TypeDBDriverException(MISSING_LABEL)
+        promise = rule_set_label(transaction.native_object, self.native_object, new_label)
+        return Promise(lambda: void_promise_resolve(promise))
+
+    @property
+    def when(self) -> str:
+        return self._when
+
+    @property
+    def then(self) -> str:
+        return self._then
+
+    def delete(self, transaction: _Transaction) -> Promise[None]:
+        promise = rule_delete(transaction.native_object, self.native_object)
+        return Promise(lambda: void_promise_resolve(promise))
+
+    def is_deleted(self, transaction: _Transaction) -> Promise[bool]:
+        promise = rule_is_deleted(transaction.native_object, self.native_object)
+        return Promise(lambda: bool_promise_resolve(promise))
+
+    def __repr__(self):
+        return rule_to_string(self.native_object)
+
+    def __eq__(self, other):
+        if other is self:
+            return True
+        if not other or type(self) is not type(other):
+            return False
+        return self.label == other.label
+
+    def __hash__(self):
+        return hash(self.label)
```

## typedb/query/query_manager.py

 * *Ordering differences only*

```diff
@@ -1,190 +1,190 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-import json
-
-from typing import TYPE_CHECKING, Iterator, Optional
-
-from typedb.native_driver_wrapper import (
-    Transaction as NativeTransaction, TypeDBDriverExceptionNative, concept_map_group_iterator_next, concept_map_iterator_next,
-    concept_promise_resolve, explanation_iterator_next, query_define, query_delete, query_explain, query_fetch, query_get,
-    query_get_aggregate, query_get_group, query_get_group_aggregate, query_insert, query_undefine, query_update, string_iterator_next,
-    value_group_iterator_next, void_promise_resolve,
-)
-
-from typedb.api.connection.options import TypeDBOptions
-from typedb.api.query.query_manager import QueryManager
-from typedb.common.exception import TypeDBDriverException, MISSING_QUERY, TRANSACTION_CLOSED
-from typedb.common.iterator_wrapper import IteratorWrapper
-from typedb.common.native_wrapper import NativeWrapper
-from typedb.common.promise import Promise
-from typedb.concept.answer.concept_map import _ConceptMap
-from typedb.concept.answer.concept_map_group import _ConceptMapGroup
-from typedb.concept.answer.value_group import _ValueGroup
-from typedb.concept.value.value import _Value
-from typedb.logic.explanation import _Explanation
-
-if TYPE_CHECKING:
-    from typedb.api.answer.concept_map import ConceptMap
-    from typedb.api.answer.concept_map_group import ConceptMapGroup
-    from typedb.api.answer.value_group import ValueGroup
-    from typedb.api.concept.value.value import Value
-    from typedb.api.logic.explanation import Explanation
-
-
-class _QueryManager(QueryManager, NativeWrapper[NativeTransaction]):
-    def __init__(self, transaction: NativeTransaction):
-        super().__init__(transaction)
-
-    @property
-    def _native_object_not_owned_exception(self) -> TypeDBDriverException:
-        return TypeDBDriverException(TRANSACTION_CLOSED)
-
-    @property
-    def _native_transaction(self) -> NativeTransaction:
-        return self.native_object
-
-    def get(self, query: str, options: Optional[TypeDBOptions] = None) -> Iterator[ConceptMap]:
-        if not query:
-            raise TypeDBDriverException(MISSING_QUERY)
-        if not options:
-            options = TypeDBOptions()
-        try:
-            return map(
-                _ConceptMap,
-                IteratorWrapper(query_get(self._native_transaction, query, options.native_object), concept_map_iterator_next)
-            )
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
-
-    def get_aggregate(self, query: str, options: Optional[TypeDBOptions] = None) -> Promise[Optional[Value]]:
-        if not query:
-            raise TypeDBDriverException(MISSING_QUERY)
-        if not options:
-            options = TypeDBOptions()
-        promise = query_get_aggregate(self._native_transaction, query, options.native_object)
-        return Promise.map(_Value, lambda: concept_promise_resolve(promise))
-
-    def get_group(self, query: str, options: Optional[TypeDBOptions] = None) -> Iterator[ConceptMapGroup]:
-        if not query:
-            raise TypeDBDriverException(MISSING_QUERY)
-        if not options:
-            options = TypeDBOptions()
-        try:
-            return map(
-                _ConceptMapGroup,
-                IteratorWrapper(
-                    query_get_group(self._native_transaction, query, options.native_object), concept_map_group_iterator_next
-                )
-            )
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
-
-    def get_group_aggregate(self, query: str, options: Optional[TypeDBOptions] = None) -> Iterator[ValueGroup]:
-        if not query:
-            raise TypeDBDriverException(MISSING_QUERY)
-        if not options:
-            options = TypeDBOptions()
-        try:
-            return map(
-                _ValueGroup,
-                IteratorWrapper(
-                    query_get_group_aggregate(self._native_transaction, query, options.native_object),
-                    value_group_iterator_next
-                )
-            )
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
-
-    def fetch(self, query: str, options: Optional[TypeDBOptions] = None) -> Iterator[dict]:
-        if not query:
-            raise TypeDBDriverException(MISSING_QUERY)
-        if not options:
-            options = TypeDBOptions()
-        try:
-            return map(
-                json.loads,
-                IteratorWrapper(query_fetch(self._native_transaction, query, options.native_object), string_iterator_next)
-            )
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
-
-    def insert(self, query: str, options: Optional[TypeDBOptions] = None) -> Iterator[ConceptMap]:
-        if not query:
-            raise TypeDBDriverException(MISSING_QUERY)
-        if not options:
-            options = TypeDBOptions()
-        try:
-            return map(
-                _ConceptMap,
-                IteratorWrapper(query_insert(self._native_transaction, query, options.native_object), concept_map_iterator_next)
-            )
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
-
-    def delete(self, query: str, options: Optional[TypeDBOptions] = None) -> Promise[None]:
-        if not query:
-            raise TypeDBDriverException(MISSING_QUERY)
-        if not options:
-            options = TypeDBOptions()
-        promise = query_delete(self._native_transaction, query, options.native_object)
-        return Promise(lambda: void_promise_resolve(promise))
-
-    def update(self, query: str, options: Optional[TypeDBOptions] = None) -> Iterator[ConceptMap]:
-        if not query:
-            raise TypeDBDriverException(MISSING_QUERY)
-        if not options:
-            options = TypeDBOptions()
-        try:
-            return map(
-                _ConceptMap,
-                IteratorWrapper(query_update(self._native_transaction, query, options.native_object), concept_map_iterator_next)
-            )
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
-
-    def define(self, query: str, options: TypeDBOptions = None) -> Promise[None]:
-        if not query:
-            raise TypeDBDriverException(MISSING_QUERY)
-        if not options:
-            options = TypeDBOptions()
-        promise = query_define(self._native_transaction, query, options.native_object)
-        return Promise(lambda: void_promise_resolve(promise))
-
-    def undefine(self, query: str, options: TypeDBOptions = None) -> Promise[None]:
-        if not query:
-            raise TypeDBDriverException(MISSING_QUERY)
-        if not options:
-            options = TypeDBOptions()
-        promise = query_undefine(self._native_transaction, query, options.native_object)
-        return Promise(lambda: void_promise_resolve(promise))
-
-    def explain(self, explainable: ConceptMap.Explainable, options: Optional[TypeDBOptions] = None) -> Iterator[Explanation]:
-        if not options:
-            options = TypeDBOptions()
-        try:
-            return map(
-                _Explanation,
-                IteratorWrapper(
-                    query_explain(self._native_transaction, explainable._native_object, options.native_object),
-                    explanation_iterator_next
-                )
-            )
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+import json
+
+from typing import TYPE_CHECKING, Iterator, Optional
+
+from typedb.native_driver_wrapper import (
+    Transaction as NativeTransaction, TypeDBDriverExceptionNative, concept_map_group_iterator_next, concept_map_iterator_next,
+    concept_promise_resolve, explanation_iterator_next, query_define, query_delete, query_explain, query_fetch, query_get,
+    query_get_aggregate, query_get_group, query_get_group_aggregate, query_insert, query_undefine, query_update, string_iterator_next,
+    value_group_iterator_next, void_promise_resolve,
+)
+
+from typedb.api.connection.options import TypeDBOptions
+from typedb.api.query.query_manager import QueryManager
+from typedb.common.exception import TypeDBDriverException, MISSING_QUERY, TRANSACTION_CLOSED
+from typedb.common.iterator_wrapper import IteratorWrapper
+from typedb.common.native_wrapper import NativeWrapper
+from typedb.common.promise import Promise
+from typedb.concept.answer.concept_map import _ConceptMap
+from typedb.concept.answer.concept_map_group import _ConceptMapGroup
+from typedb.concept.answer.value_group import _ValueGroup
+from typedb.concept.value.value import _Value
+from typedb.logic.explanation import _Explanation
+
+if TYPE_CHECKING:
+    from typedb.api.answer.concept_map import ConceptMap
+    from typedb.api.answer.concept_map_group import ConceptMapGroup
+    from typedb.api.answer.value_group import ValueGroup
+    from typedb.api.concept.value.value import Value
+    from typedb.api.logic.explanation import Explanation
+
+
+class _QueryManager(QueryManager, NativeWrapper[NativeTransaction]):
+    def __init__(self, transaction: NativeTransaction):
+        super().__init__(transaction)
+
+    @property
+    def _native_object_not_owned_exception(self) -> TypeDBDriverException:
+        return TypeDBDriverException(TRANSACTION_CLOSED)
+
+    @property
+    def _native_transaction(self) -> NativeTransaction:
+        return self.native_object
+
+    def get(self, query: str, options: Optional[TypeDBOptions] = None) -> Iterator[ConceptMap]:
+        if not query:
+            raise TypeDBDriverException(MISSING_QUERY)
+        if not options:
+            options = TypeDBOptions()
+        try:
+            return map(
+                _ConceptMap,
+                IteratorWrapper(query_get(self._native_transaction, query, options.native_object), concept_map_iterator_next)
+            )
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
+
+    def get_aggregate(self, query: str, options: Optional[TypeDBOptions] = None) -> Promise[Optional[Value]]:
+        if not query:
+            raise TypeDBDriverException(MISSING_QUERY)
+        if not options:
+            options = TypeDBOptions()
+        promise = query_get_aggregate(self._native_transaction, query, options.native_object)
+        return Promise.map(_Value, lambda: concept_promise_resolve(promise))
+
+    def get_group(self, query: str, options: Optional[TypeDBOptions] = None) -> Iterator[ConceptMapGroup]:
+        if not query:
+            raise TypeDBDriverException(MISSING_QUERY)
+        if not options:
+            options = TypeDBOptions()
+        try:
+            return map(
+                _ConceptMapGroup,
+                IteratorWrapper(
+                    query_get_group(self._native_transaction, query, options.native_object), concept_map_group_iterator_next
+                )
+            )
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
+
+    def get_group_aggregate(self, query: str, options: Optional[TypeDBOptions] = None) -> Iterator[ValueGroup]:
+        if not query:
+            raise TypeDBDriverException(MISSING_QUERY)
+        if not options:
+            options = TypeDBOptions()
+        try:
+            return map(
+                _ValueGroup,
+                IteratorWrapper(
+                    query_get_group_aggregate(self._native_transaction, query, options.native_object),
+                    value_group_iterator_next
+                )
+            )
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
+
+    def fetch(self, query: str, options: Optional[TypeDBOptions] = None) -> Iterator[dict]:
+        if not query:
+            raise TypeDBDriverException(MISSING_QUERY)
+        if not options:
+            options = TypeDBOptions()
+        try:
+            return map(
+                json.loads,
+                IteratorWrapper(query_fetch(self._native_transaction, query, options.native_object), string_iterator_next)
+            )
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
+
+    def insert(self, query: str, options: Optional[TypeDBOptions] = None) -> Iterator[ConceptMap]:
+        if not query:
+            raise TypeDBDriverException(MISSING_QUERY)
+        if not options:
+            options = TypeDBOptions()
+        try:
+            return map(
+                _ConceptMap,
+                IteratorWrapper(query_insert(self._native_transaction, query, options.native_object), concept_map_iterator_next)
+            )
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
+
+    def delete(self, query: str, options: Optional[TypeDBOptions] = None) -> Promise[None]:
+        if not query:
+            raise TypeDBDriverException(MISSING_QUERY)
+        if not options:
+            options = TypeDBOptions()
+        promise = query_delete(self._native_transaction, query, options.native_object)
+        return Promise(lambda: void_promise_resolve(promise))
+
+    def update(self, query: str, options: Optional[TypeDBOptions] = None) -> Iterator[ConceptMap]:
+        if not query:
+            raise TypeDBDriverException(MISSING_QUERY)
+        if not options:
+            options = TypeDBOptions()
+        try:
+            return map(
+                _ConceptMap,
+                IteratorWrapper(query_update(self._native_transaction, query, options.native_object), concept_map_iterator_next)
+            )
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
+
+    def define(self, query: str, options: TypeDBOptions = None) -> Promise[None]:
+        if not query:
+            raise TypeDBDriverException(MISSING_QUERY)
+        if not options:
+            options = TypeDBOptions()
+        promise = query_define(self._native_transaction, query, options.native_object)
+        return Promise(lambda: void_promise_resolve(promise))
+
+    def undefine(self, query: str, options: TypeDBOptions = None) -> Promise[None]:
+        if not query:
+            raise TypeDBDriverException(MISSING_QUERY)
+        if not options:
+            options = TypeDBOptions()
+        promise = query_undefine(self._native_transaction, query, options.native_object)
+        return Promise(lambda: void_promise_resolve(promise))
+
+    def explain(self, explainable: ConceptMap.Explainable, options: Optional[TypeDBOptions] = None) -> Iterator[Explanation]:
+        if not options:
+            options = TypeDBOptions()
+        try:
+            return map(
+                _Explanation,
+                IteratorWrapper(
+                    query_explain(self._native_transaction, explainable._native_object, options.native_object),
+                    explanation_iterator_next
+                )
+            )
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
```

## typedb/user/user.py

 * *Ordering differences only*

```diff
@@ -1,55 +1,55 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-#   Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from typing import Optional, TYPE_CHECKING
-
-from typedb.native_driver_wrapper import user_get_username, user_get_password_expiry_seconds, user_password_update, \
-    User as NativeUser, TypeDBDriverExceptionNative
-
-from typedb.api.user.user import User
-from typedb.common.exception import TypeDBDriverException, ILLEGAL_STATE
-from typedb.common.native_wrapper import NativeWrapper
-
-if TYPE_CHECKING:
-    from typedb.user.user_manager import _UserManager
-
-
-class _User(User, NativeWrapper[NativeUser]):
-
-    def __init__(self, user: NativeUser, user_manager: _UserManager):
-        super().__init__(user)
-        self._user_manager = user_manager
-
-    @property
-    def _native_object_not_owned_exception(self) -> TypeDBDriverException:
-        return TypeDBDriverException(ILLEGAL_STATE)
-
-    def username(self) -> str:
-        return user_get_username(self.native_object)
-
-    def password_expiry_seconds(self) -> Optional[int]:
-        if res := user_get_password_expiry_seconds(self.native_object) >= 0:
-            return res
-        return None
-
-    def password_update(self, password_old: str, password_new: str) -> None:
-        try:
-            user_password_update(self.native_object, self._user_manager.native_object, password_old, password_new)
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+#   Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from typing import Optional, TYPE_CHECKING
+
+from typedb.native_driver_wrapper import user_get_username, user_get_password_expiry_seconds, user_password_update, \
+    User as NativeUser, TypeDBDriverExceptionNative
+
+from typedb.api.user.user import User
+from typedb.common.exception import TypeDBDriverException, ILLEGAL_STATE
+from typedb.common.native_wrapper import NativeWrapper
+
+if TYPE_CHECKING:
+    from typedb.user.user_manager import _UserManager
+
+
+class _User(User, NativeWrapper[NativeUser]):
+
+    def __init__(self, user: NativeUser, user_manager: _UserManager):
+        super().__init__(user)
+        self._user_manager = user_manager
+
+    @property
+    def _native_object_not_owned_exception(self) -> TypeDBDriverException:
+        return TypeDBDriverException(ILLEGAL_STATE)
+
+    def username(self) -> str:
+        return user_get_username(self.native_object)
+
+    def password_expiry_seconds(self) -> Optional[int]:
+        if res := user_get_password_expiry_seconds(self.native_object) >= 0:
+            return res
+        return None
+
+    def password_update(self, password_old: str, password_new: str) -> None:
+        try:
+            user_password_update(self.native_object, self._user_manager.native_object, password_old, password_new)
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
```

## typedb/user/user_manager.py

 * *Ordering differences only*

```diff
@@ -1,88 +1,88 @@
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-#   Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-
-from __future__ import annotations
-
-from typing import TYPE_CHECKING, Optional
-
-from typedb.native_driver_wrapper import user_manager_new, users_contains, users_create, users_delete, users_all, \
-    users_get, users_set_password, users_current_user, user_iterator_next, UserManager as NativeUserManager, \
-    TypeDBDriverExceptionNative
-
-from typedb.api.user.user import UserManager
-from typedb.common.exception import TypeDBDriverException, ILLEGAL_STATE
-from typedb.common.iterator_wrapper import IteratorWrapper
-from typedb.common.native_wrapper import NativeWrapper
-from typedb.user.user import _User
-
-if TYPE_CHECKING:
-    from typedb.api.user.user import User
-    from typedb.native_driver_wrapper import Connection as NativeConnection
-
-
-class _UserManager(UserManager, NativeWrapper[NativeUserManager]):
-
-    def __init__(self, connection: NativeConnection):
-        super().__init__(user_manager_new(connection))
-
-    @property
-    def _native_object_not_owned_exception(self) -> TypeDBDriverException:
-        return TypeDBDriverException(ILLEGAL_STATE)
-
-    def contains(self, username: str) -> bool:
-        try:
-            return users_contains(self.native_object, username)
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
-
-    def create(self, username: str, password: str) -> None:
-        try:
-            users_create(self.native_object, username, password)
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
-
-    def delete(self, username: str) -> None:
-        try:
-            users_delete(self.native_object, username)
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
-
-    def all(self) -> list[User]:
-        try:
-            return [_User(user, self) for user in IteratorWrapper(users_all(self.native_object), user_iterator_next)]
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
-
-    def get(self, username: str) -> Optional[User]:
-        try:
-            if user := users_get(self.native_object, username):
-                return _User(user, self)
-            return None
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
-
-    def password_set(self, username: str, password: str) -> None:
-        try:
-            users_set_password(self.native_object, username, password)
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
-
-    def get_current_user(self) -> User:
-        try:
-            return _User(users_current_user(self.native_object), self)
-        except TypeDBDriverExceptionNative as e:
-            raise TypeDBDriverException.of(e)
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+#   Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+from __future__ import annotations
+
+from typing import TYPE_CHECKING, Optional
+
+from typedb.native_driver_wrapper import user_manager_new, users_contains, users_create, users_delete, users_all, \
+    users_get, users_set_password, users_current_user, user_iterator_next, UserManager as NativeUserManager, \
+    TypeDBDriverExceptionNative
+
+from typedb.api.user.user import UserManager
+from typedb.common.exception import TypeDBDriverException, ILLEGAL_STATE
+from typedb.common.iterator_wrapper import IteratorWrapper
+from typedb.common.native_wrapper import NativeWrapper
+from typedb.user.user import _User
+
+if TYPE_CHECKING:
+    from typedb.api.user.user import User
+    from typedb.native_driver_wrapper import Connection as NativeConnection
+
+
+class _UserManager(UserManager, NativeWrapper[NativeUserManager]):
+
+    def __init__(self, connection: NativeConnection):
+        super().__init__(user_manager_new(connection))
+
+    @property
+    def _native_object_not_owned_exception(self) -> TypeDBDriverException:
+        return TypeDBDriverException(ILLEGAL_STATE)
+
+    def contains(self, username: str) -> bool:
+        try:
+            return users_contains(self.native_object, username)
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
+
+    def create(self, username: str, password: str) -> None:
+        try:
+            users_create(self.native_object, username, password)
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
+
+    def delete(self, username: str) -> None:
+        try:
+            users_delete(self.native_object, username)
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
+
+    def all(self) -> list[User]:
+        try:
+            return [_User(user, self) for user in IteratorWrapper(users_all(self.native_object), user_iterator_next)]
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
+
+    def get(self, username: str) -> Optional[User]:
+        try:
+            if user := users_get(self.native_object, username):
+                return _User(user, self)
+            return None
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
+
+    def password_set(self, username: str, password: str) -> None:
+        try:
+            users_set_password(self.native_object, username, password)
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
+
+    def get_current_user(self) -> User:
+        try:
+            return _User(users_current_user(self.native_object), self)
+        except TypeDBDriverExceptionNative as e:
+            raise TypeDBDriverException.of(e)
```

## Comparing `typedb_driver-2.28.2rc0.dist-info/METADATA` & `typedb_driver-2.28.2rc1.dist-info/METADATA`

 * *Files 17% similar despite different names*

```diff
@@ -1,44 +1,44 @@
-Metadata-Version: 2.1
-Name: typedb-driver
-Version: 2.28.2rc0
-Summary: TypeDB Driver for Python
-Home-page: https://github.com/vaticle/typedb-driver-python/
-Author: Vaticle
-Author-email: community@vaticle.com
-License: Apache-2.0
-Keywords: typedb database graph knowledgebase knowledge-engineering
-Classifier: Programming Language :: Python
-Classifier: Programming Language :: Python :: 3.9
-Classifier: License :: OSI Approved :: Apache Software License
-Classifier: Operating System :: OS Independent
-Classifier: Intended Audience :: Developers
-Classifier: Intended Audience :: Science/Research
-Classifier: Environment :: Console
-Classifier: Topic :: Database :: Front-Ends
-Requires-Python: >0
-Description-Content-Type: text/markdown
-Requires-Dist: parse (==1.18.0)
-
-# TypeDB Python Driver
-
-## Driver Architecture
-To learn about the mechanism that a TypeDB Driver uses to set up communication with databases running on the TypeDB Server, refer to the [Clients Overview](https://typedb.com/docs/drivers/overview).
-
-## API Reference
-To learn about the methods available for executing queries and retrieving their answers using Driver Python, refer to the [API Reference](https://typedb.com/docs/drivers/python/api-reference).
-
-## Install TypeDB Driver for Python through Pip
-```
-pip install typedb-driver
-```
-If multiple Python versions are available, you may wish to use
-```
-pip3 install typedb-driver
-```
-
-In your python program, import from typedb.driver:
-```py
-from typedb.driver import *
-
-driver = TypeDB.core_driver(address=TypeDB.DEFAULT_ADDRESS)
-```
+Metadata-Version: 2.1
+Name: typedb-driver
+Version: 2.28.2rc1
+Summary: TypeDB Driver for Python
+Home-page: https://github.com/vaticle/typedb-driver-python/
+Author: Vaticle
+Author-email: community@vaticle.com
+License: Apache-2.0
+Keywords: typedb database graph knowledgebase knowledge-engineering
+Classifier: Programming Language :: Python
+Classifier: Programming Language :: Python :: 3.9
+Classifier: License :: OSI Approved :: Apache Software License
+Classifier: Operating System :: OS Independent
+Classifier: Intended Audience :: Developers
+Classifier: Intended Audience :: Science/Research
+Classifier: Environment :: Console
+Classifier: Topic :: Database :: Front-Ends
+Requires-Python: >0
+Description-Content-Type: text/markdown
+Requires-Dist: parse (==1.18.0)
+
+# TypeDB Python Driver
+
+## Driver Architecture
+To learn about the mechanism that a TypeDB Driver uses to set up communication with databases running on the TypeDB Server, refer to the [Clients Overview](https://typedb.com/docs/drivers/overview).
+
+## API Reference
+To learn about the methods available for executing queries and retrieving their answers using Driver Python, refer to the [API Reference](https://typedb.com/docs/drivers/python/api-reference).
+
+## Install TypeDB Driver for Python through Pip
+```
+pip install typedb-driver
+```
+If multiple Python versions are available, you may wish to use
+```
+pip3 install typedb-driver
+```
+
+In your python program, import from typedb.driver:
+```py
+from typedb.driver import *
+
+driver = TypeDB.core_driver(address=TypeDB.DEFAULT_ADDRESS)
+```
```

## Comparing `typedb_driver-2.28.2rc0.dist-info/RECORD` & `typedb_driver-2.28.2rc1.dist-info/RECORD`

 * *Files 24% similar despite different names*

```diff
@@ -1,90 +1,90 @@
 typedb/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-typedb/driver.py,sha256=oFdPHgenksKEy2m4cW2GbBzjk67a6-06Z7ddcf4QE3I,4525
-typedb/native_driver_python.pyd,sha256=wmNba_xIwWo7ve8Tpfzf8VPBMTnmBliFBBNsdfIIk40,11001344
-typedb/native_driver_wrapper.py,sha256=bs7CHU9Ws4qjh5xKZEP6QsJKmCEy19q--L3mRhEbsaU,58352
+typedb/driver.py,sha256=bhp1Ex2_JQDFhIiaHPs1OW7VbAl9rBf75DGHx00PrlU,4441
+typedb/native_driver_python.so,sha256=NHMXckV-VXaBFVRHTRwrRa2X6Mc26jdv9GTBJAI0Ra8,21118924
+typedb/native_driver_wrapper.py,sha256=UQb01ERb1MhSrJVtegcGaoYfPBzGYz_BUi2K1_T1QSM,56958
 typedb/api/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 typedb/api/answer/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-typedb/api/answer/concept_map.py,sha256=bbiZPZFp7qjP2VUe3wC0F8fj3W6nhKN8qj29-ghSahE,6141
-typedb/api/answer/concept_map_group.py,sha256=mjwikqlMwd0mAYadU1F_5XodF0Tzv1iaCzmC6S-Z4a8,1706
-typedb/api/answer/value_group.py,sha256=N9sWZhn5aAYkD6SAP4zbvydmIdhKGtia0iFZ5GJPbWI,1677
+typedb/api/answer/concept_map.py,sha256=qHc-1NNO66m9oIXO1dmQtcZV1ZNhwrXXcwMPBVI2TC0,5900
+typedb/api/answer/concept_map_group.py,sha256=1__sldj3e6KaEgVCZfIrxHLUPVlBsWr1_DtbCHOtbVo,1645
+typedb/api/answer/value_group.py,sha256=YO6K6RUxCWRO9RF-StiyyKD5VntSgpNa9_d6qgnrewo,1616
 typedb/api/concept/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-typedb/api/concept/concept.py,sha256=ZOaATvSnjf-vYOjM8fceKXgBfb8SZZONfZTPFthGAXQ,7977
-typedb/api/concept/concept_manager.py,sha256=ic8GonpHMby1lmKtUtJ09o2Xwua-FhHvKmCMg-C3cD0,6658
+typedb/api/concept/concept.py,sha256=9fTfi-LLI5hz9_Qm6wHK5CWtyUFkp70dZEpXjfTgBZM,7629
+typedb/api/concept/concept_manager.py,sha256=JdJjS5zyeZh6LKxc2k3A0EOXWJGmmio-E7li0GaMK3c,6411
 typedb/api/concept/thing/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-typedb/api/concept/thing/attribute.py,sha256=h5-MYLNx7jwLRXIVjsyY5IYb_C5ZgCZUqbr3l1084kU,6728
-typedb/api/concept/thing/entity.py,sha256=jWwBI_QNdVZ8MHIG6l_GMSLI7e9HpUB2Uomuh4HDXEg,2107
-typedb/api/concept/thing/relation.py,sha256=VuPvOnNupv8L4EBskhvXT02Naaiezqqoxvzro6WH8oI,4857
-typedb/api/concept/thing/thing.py,sha256=Hupk4L5JW-n5-sqZphvShuDkWCH1jexJNmVWJHKJF7Y,6525
+typedb/api/concept/thing/attribute.py,sha256=YihjK88UwD7DS2yJOkp8EP8ZJ0aA1QvVi6l0PaW62bw,6437
+typedb/api/concept/thing/entity.py,sha256=f1ffKhQee-FSQaCA4T68uy1LcMVKp3GHfB4XA7P3G8Q,2028
+typedb/api/concept/thing/relation.py,sha256=4KzqknumotCv7eGer2zQsiiUGF2DH6Nv_ZsbyVBI7mg,4690
+typedb/api/concept/thing/thing.py,sha256=8UlKyO3jTWI97tnR0OYZXLgg7gJIxIYiU0fLn40bpNg,6282
 typedb/api/concept/type/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-typedb/api/concept/type/annotation.py,sha256=KKThtKV2L9fJ1mBtiehKyvbHzTaGFSV5EAWyJtlr9C4,2937
-typedb/api/concept/type/attribute_type.py,sha256=-1guXEfYhKGcIYxanAY64izL10AUvxv4K2rczqQ-nbw,11023
-typedb/api/concept/type/entity_type.py,sha256=vlAdbTE0W_9LoH0jkefWqOzPazJz13wLYOsKyHbSSEU,4303
-typedb/api/concept/type/relation_type.py,sha256=AX1IMjcnU2p6TnyKgRh9FpOOnXzlwJRD40wgEEPS2aE,7571
-typedb/api/concept/type/role_type.py,sha256=I73eZ7LErSrzDQw8No_4_BtQgItGJqFiTZtfZXuZzus,6647
-typedb/api/concept/type/thing_type.py,sha256=yuS_VpoCv-pPLZJplDcBN701sk34rl7udpovd6qP0Lo,11534
-typedb/api/concept/type/type.py,sha256=WSQfX_Qbk8Paq8t5BzX1U18yj1mVFsgM6aq_ScAXAsg,4578
+typedb/api/concept/type/annotation.py,sha256=qUfuXc0nCcJIAW6ucpi9UiZsk4_Q8M8_0LA9rHMdg3Y,2833
+typedb/api/concept/type/attribute_type.py,sha256=vr-KFSrQWm5IVF1bZJiC2VDcGu4CYyx96ktrds5Z-k8,10665
+typedb/api/concept/type/entity_type.py,sha256=MwtGEjYtQrS5jeYfK5-UjUWpdT6fZPdZc4XMCYOomyI,4157
+typedb/api/concept/type/relation_type.py,sha256=t9XcQrhtnMUK3VZf2OHjj1VkxTlQVqybFkgm8l0gF6c,7331
+typedb/api/concept/type/role_type.py,sha256=2E0yajlOXkR-BzqPBX6K3dhaTRQB7qpSB8K1qRIvjwE,6418
+typedb/api/concept/type/thing_type.py,sha256=rROnRc-hJ-zVz_ViC5m1Hu0ztVQGUlnE1d5WDQUm4Rc,11167
+typedb/api/concept/type/type.py,sha256=Q87n35Iz9eEAQKSVCnBccVzvB-_hlqTdZF1eE12N2R4,4399
 typedb/api/concept/value/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-typedb/api/concept/value/value.py,sha256=75hTxqmKgsS5MU7wq8Gm_V4bov8u85xCAVMcu-P5T0k,7033
+typedb/api/concept/value/value.py,sha256=ADDVW1YhjWaeGfGPY_av7Gm1koAxYLt1M1TPvI0UC_4,6733
 typedb/api/connection/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-typedb/api/connection/credential.py,sha256=4JhkdaQsymxS2-9I29BOqszXHCawuOu_BqBDk-3ILRw,2476
-typedb/api/connection/database.py,sha256=86YHvIN2YWmRbcPPJ-4tkS85jFnQpnprgN4cLOG28ic,5646
-typedb/api/connection/driver.py,sha256=k5E8vo1YzOYyhxECmqUYdW2OXsm-OFJ9hQ42cUIy-08,3483
-typedb/api/connection/options.py,sha256=Xd38Fy8f338zEP-Pltc9-WVqSDZkc36RJfkV0Gd0KDg,10093
-typedb/api/connection/session.py,sha256=0shNucFWQI0PVo2u2spgekN6xHbhRx46YEMDIpdW5gc,4386
-typedb/api/connection/transaction.py,sha256=zsbWPYNJ6sDu4zadk-lq5dWo9-PCEAK-ROGcpx-M5vw,4303
+typedb/api/connection/credential.py,sha256=ZRTB8_1AL9tihE3ZXdtzot8Q-abEfbdUoVchBMQOKZE,2424
+typedb/api/connection/database.py,sha256=tosFkpTwlAk-gy-Q5IljqoBjqbO49T4EuOf-hZPACNc,5385
+typedb/api/connection/driver.py,sha256=EHQYNM1uVlyzKwRGGYT4Sx2Z8rfO6YDGx5F7GgGBeKY,3363
+typedb/api/connection/options.py,sha256=G6DtYkbh67Kgx6B_pLie-UzJvDLlsM5BEgXStB4tKD8,9872
+typedb/api/connection/session.py,sha256=sZVWS36WAc-jmf1SRfh2d0RVopqHBFzOifVnq_m0GC4,4214
+typedb/api/connection/transaction.py,sha256=LfsVsjGcXEf0oAtEJ3B33u9-XSI5TfHwq2DTtkr8gbI,4126
 typedb/api/logic/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-typedb/api/logic/explanation.py,sha256=NTttLODqzjUtei1u0jphaRJvi-GpgVw9i3w34STSFW4,2791
-typedb/api/logic/logic_manager.py,sha256=ud_IhggXlMwvPRA9_wEj9jJlAbLDBSFuE-Tp_rjsZL4,2346
-typedb/api/logic/rule.py,sha256=42XBqHYnmvXwOOZdmI52RPO7ZyN2q6J5vZGaqJriHmI,3004
+typedb/api/logic/explanation.py,sha256=8F01IxEPOnHTWvtfwTv9Z8lxFtcz5sNQ58dn0PIquPg,2683
+typedb/api/logic/logic_manager.py,sha256=CYKpWh61pEiciqT3EdfbXyPV06v2JwZiKTlKo_XPOoA,2266
+typedb/api/logic/rule.py,sha256=jgoC-5be81IMbgVFI4muqVN8lJnNdckLnFPmbcSWEQg,2898
 typedb/api/query/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-typedb/api/query/query_manager.py,sha256=8bBl38_ThJ4WN4loOCs3HXxoIejLuua8TLtx3zT8Whc,6674
+typedb/api/query/query_manager.py,sha256=ciu2ewUcrmuhFe_e_QVP6vFmqZ-Bi8n4XCvPqMeyP4w,6450
 typedb/api/user/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-typedb/api/user/user.py,sha256=T-J8OH9K5WRIp5TgKESpgI4mMekiigr8zzxdGzVljOM,3910
+typedb/api/user/user.py,sha256=HYLlvsAePk3h0-bLDF0aWD6M1iQZIYRDU3TmeAblm3o,3754
 typedb/common/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-typedb/common/exception.py,sha256=8fIo7KHk8fgdek1B2OboVFhTkRDvJb4AOyWi6g6pSh4,6305
-typedb/common/iterator_wrapper.py,sha256=RjM5Zundv3rCSCDsHx74nAFXux9UuG60ZsiWECLznro,1452
-typedb/common/label.py,sha256=Gw79pEvRevrsEeShypxlK4iDjnZ4J1rCLNGb9UORJh0,2889
-typedb/common/native_wrapper.py,sha256=7PL5Dma968AZOlKtx3UVFzj47wfDhrO2LMT3_xhKouQ,1458
-typedb/common/promise.py,sha256=wXSGdmsamFXdMkuOPXC5NfqIrf4O5QT-zFPxFc53_Po,1945
-typedb/common/transitivity.py,sha256=46ZVfBZJTEG9zDW_jzG_HGjJkCjtfz3d2G5QRt5_Azg,1254
+typedb/common/exception.py,sha256=POZWi2GIkRCbhsGErvuAM13jD-R47jwX1b04xcBllV0,6143
+typedb/common/iterator_wrapper.py,sha256=iM3634Ww64NSSxcAT-geXb2NF-6WQbm2WZlOlY-nPPM,1413
+typedb/common/label.py,sha256=KTPWd8Z6xPp2Mb7Q7ehoINLl38dibxO9FUZxhRhFRIg,2797
+typedb/common/native_wrapper.py,sha256=7PCo4Uw-BzLkuG662lGFJFJ9SX4eF7PHKyKnFQoGozg,1415
+typedb/common/promise.py,sha256=-HTRARCQWb4SF4xN2a7AXcsdRtZ7PoJZhW2LF-_eqPY,1881
+typedb/common/transitivity.py,sha256=F6ZEK4O1VOIVZrjUNzkukAyNv40uoxZyWGWwbMU8678,1218
 typedb/concept/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-typedb/concept/concept.py,sha256=FQ_oBJ7Yj73s33Oo0gG-B70f3Yz_-OwjYKQI96DGfEo,1854
-typedb/concept/concept_factory.py,sha256=J3Q-2y8pM8UKcRtOtVynvarEU805Ya_SauoCx2O5llw,6438
-typedb/concept/concept_manager.py,sha256=bZFsnznbLWJ7IiPD0mY7sLMTplGM6AdjsIbcnnwsuEQ,5961
+typedb/concept/concept.py,sha256=6kEr-GpVBxoFNR7bMlUCMweJ2hAZfUdV1_zq9nnfCUY,1806
+typedb/concept/concept_factory.py,sha256=ybBh0oW-oqv1Ain5tthdvPiqeokymIjfNVDKbORRUxw,6283
+typedb/concept/concept_manager.py,sha256=gGbeXrF9J-GHCnxCJHVzUzlhScuBt1A0e6wDpR1SwVg,5840
 typedb/concept/answer/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-typedb/concept/answer/concept_map.py,sha256=tnZ4eZSqDzzFzucwX8FT5beiscqSUC1LhYLVC1yWa7Q,8160
-typedb/concept/answer/concept_map_group.py,sha256=p-S1UkSaUo7f6EUY6DpluiAiJ1XhlYedseQCFvDyxoI,2875
-typedb/concept/answer/value_group.py,sha256=hgygZ6-MStsy7auu8w4lEI4VElCSAMnKV92-vSEoGFo,2529
+typedb/concept/answer/concept_map.py,sha256=kTDggRutyCkU9_MttB0tNyrMF_wvh1EAPZeXFJhGp2U,7980
+typedb/concept/answer/concept_map_group.py,sha256=Q_bhR9QjAZNhjniemmU47kKQIbCR3-x0Fm-_22CZ42I,2808
+typedb/concept/answer/value_group.py,sha256=2fCM6rbgHN4IA2b5gkTFezkDlxnpAvR8JC69lQtLoa4,2465
 typedb/concept/thing/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-typedb/concept/thing/attribute.py,sha256=UH1Yh1TvZF35UhoHrYe9GJrhzgsoMdCwN4LHeewuadA,3735
-typedb/concept/thing/entity.py,sha256=kslfp3JsNudpG-1mZFKrxeJhW7IBTQA3XG3qgM869cA,1327
-typedb/concept/thing/relation.py,sha256=btopdvR4ghNGi-JjkLN0HfhyorYA0ExXr4rOjaF5wVA,4388
-typedb/concept/thing/thing.py,sha256=hpDOKv8QEsx_8VwnPwQiuJEgp0H1aVY7uiZrnvpQ-s8,5596
+typedb/concept/thing/attribute.py,sha256=4dTLbxtsYUy13-bFFhTLpEPV-5br1haLxYlFhgmMYoA,3641
+typedb/concept/thing/entity.py,sha256=9_k11gGRHmhBdtjMWX7oYIXl1zPN_hwDqoJ57LyadDE,1292
+typedb/concept/thing/relation.py,sha256=oFsaAUyQf03FKIyAT8LfyUtoCw0BaSTazDrY7-cQ4C8,4297
+typedb/concept/thing/thing.py,sha256=qyZZW_b-FeS6B7JhjrW0d4P1O4Sd6OfAQ7RISZPuVo8,5471
 typedb/concept/type/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-typedb/concept/type/attribute_type.py,sha256=KMgC1fGZuUonfxLvpdm2Fhc4OEIBimZl7W7I8tnb1Sc,7897
-typedb/concept/type/entity_type.py,sha256=QdBSsPyzIcc-JqWvjCo_DePoATK8r8ty8Ft7gFeTpr0,4080
-typedb/concept/type/relation_type.py,sha256=Gg23TtF8GOZwzRjTp3TTOYwAwrfwWGTqi0lGen0OoO0,6289
-typedb/concept/type/role_type.py,sha256=bC2tlxgnuoGibbJKyPLIHk44X1sYaoJqaAzmdmqWejU,6910
-typedb/concept/type/thing_type.py,sha256=LvA9M_4OwSL--fz6y3ykiZTwJAT2CH52sQc4cmLM4dc,9846
-typedb/concept/type/type.py,sha256=K6s36oDV0OjulZnnupclEJjSkS3CGzqWZy_wRPNoee0,2089
+typedb/concept/type/attribute_type.py,sha256=PybHQuh5h_46SM5elvU8guS7CDGuDjQ8TFCKGF4n_Ck,7724
+typedb/concept/type/entity_type.py,sha256=ImofMt0JQ1WjWcGZPz8ofoG6gQ4Gv2_kAj_j-flOjIU,3993
+typedb/concept/type/relation_type.py,sha256=JnKrLMLPi548QPnlUAbctAj27Rie-HSBgm9FbpLuAIc,6159
+typedb/concept/type/role_type.py,sha256=2SIJqHHo4X-7xgEfJftataC7QpM5LVRB-pd_6P93JiU,6754
+typedb/concept/type/thing_type.py,sha256=BcngUOufMv3AIIkSfFYc3WJS_rMPc3H32ChWwsPS2c8,9628
+typedb/concept/type/type.py,sha256=4aO7Xw_BaWZKakf3ijjZPO6eq6taZMHnYuVE73vyoaA,2030
 typedb/concept/value/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-typedb/concept/value/value.py,sha256=rJq-la92Qk7jOlopkZHEEL6VrqH3ioBDmMC17Ek5oc8,4442
+typedb/concept/value/value.py,sha256=_QIHmD4dR_7ry48XPMcKnenku_0XU1UGIwh5KK7XIWc,4311
 typedb/connection/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-typedb/connection/database.py,sha256=hfsO1yqZO8amHTeY0gycNKmJ66IllwUXESj_A6nl30U,4519
-typedb/connection/database_manager.py,sha256=Iij6Xo7i52Oml0Ij7QOD56MVr2j7IKiGwNNFP6B5s88,3106
-typedb/connection/driver.py,sha256=dnM9C0VzutpX0hjxUgoqEkrErp9WhCMn9J415c3uLIo,4125
-typedb/connection/session.py,sha256=ZwUR6R9ejWqmoPOwcIwZ2Iz7JK3IGhKNrasDlb68GBc,3751
-typedb/connection/transaction.py,sha256=6RQIG8OJv315Hn0DrGcbwVpOqEKDHjYzFdZtJZgPLSw,4666
+typedb/connection/database.py,sha256=w1YMH1fBy3WZFd_q5fhNURzGJ58tSQ9YutoWH4SeDS0,4401
+typedb/connection/database_manager.py,sha256=XdTqy8-xGp1-Du4PEBzqO80fjnA8lUibGjVql-1CRks,3032
+typedb/connection/driver.py,sha256=U-ZmPQG9-RnrgcEtNfvqmsvY8lfGPxc9THklQEBqaWc,4028
+typedb/connection/session.py,sha256=bcANJCyPfe472gfsQulniV8nbzn9hZhscViyKKsA_CY,3656
+typedb/connection/transaction.py,sha256=JBgEEi77nxne8KHScY_giMwK_88NMdbftj_57mCHEkQ,4547
 typedb/logic/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-typedb/logic/explanation.py,sha256=dozmmr6Ef-3f8Qs_z6SGdC9vTX3-irQJ7ytfVIi0d5g,3241
-typedb/logic/logic_manager.py,sha256=sja9AZcsUs0Y9QK6kIZwgn9xngmmj-1iXT_r0g61vpI,2827
-typedb/logic/rule.py,sha256=6iV4ekpDmH1ms2fL0WRSHtIzxl7Wzl24PyUsnvZrX8k,3256
+typedb/logic/explanation.py,sha256=ju3tQKXuyvqO_4gImN-Jy-vyxsl10A-TY-Z4M4JGz08,3164
+typedb/logic/logic_manager.py,sha256=HjTSGi6lyzkLqWSI8a-DcvxDZVTTVuaCaBmQBLn89GI,2761
+typedb/logic/rule.py,sha256=DdpunHdOe6RlrShqi1A8ijr8-s1s-4pURuZq3OT4Weo,3170
 typedb/query/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-typedb/query/query_manager.py,sha256=e36ZDFhn7csXFX5RQfY36nTpDcEKzSeHEteTY-W8vXw,8437
+typedb/query/query_manager.py,sha256=40cW5XRxz_NGjrmNzryeiIcuXZt_88xhWasPS1imzZw,8247
 typedb/user/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-typedb/user/user.py,sha256=kLZx4Y70HNCeD9eMHBYIvMLCRxjjnLVuUAyqFjEQEdw,2232
-typedb/user/user_manager.py,sha256=f4MLDBxEKy892_Aw3XEmXmyKL_Dc2taXm_O4Rtun7RE,3622
-typedb_driver-2.28.2rc0.dist-info/METADATA,sha256=nPajeoX7kfWG1hJBgiZpenh5EDPu_uITubRzldJ89jQ,1597
-typedb_driver-2.28.2rc0.dist-info/WHEEL,sha256=2wepM1nk4DS4eFpYrW1TTqPcoGNfHhhO_i5m4cOimbo,92
-typedb_driver-2.28.2rc0.dist-info/top_level.txt,sha256=l56UcG8gm_C6cLgPH8oiKkAWhrO4HjqaYKk37srAp1Y,12
-typedb_driver-2.28.2rc0.dist-info/RECORD,,
+typedb/user/user.py,sha256=1FeNeeY4JV6ktqEUIwAATjRUBpavlWTUC8FEASae654,2177
+typedb/user/user_manager.py,sha256=hD-pR6KVJ30LDL7K3EYHNhOlfmzfp4OzEMmRqkwxARs,3534
+typedb_driver-2.28.2rc1.dist-info/METADATA,sha256=uuIBEU8r6cz9BTXJmJLXuwNWhy4-5VHBnIC1dSWqAPo,1553
+typedb_driver-2.28.2rc1.dist-info/WHEEL,sha256=2wepM1nk4DS4eFpYrW1TTqPcoGNfHhhO_i5m4cOimbo,92
+typedb_driver-2.28.2rc1.dist-info/top_level.txt,sha256=l56UcG8gm_C6cLgPH8oiKkAWhrO4HjqaYKk37srAp1Y,12
+typedb_driver-2.28.2rc1.dist-info/RECORD,,
```

